<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › scsi › lpfc › lpfc_sli.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>lpfc_sli.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*******************************************************************</span>
<span class="cm"> * This file is part of the Emulex Linux Device Driver for         *</span>
<span class="cm"> * Fibre Channel Host Bus Adapters.                                *</span>
<span class="cm"> * Copyright (C) 2004-2012 Emulex.  All rights reserved.           *</span>
<span class="cm"> * EMULEX and SLI are trademarks of Emulex.                        *</span>
<span class="cm"> * www.emulex.com                                                  *</span>
<span class="cm"> * Portions Copyright (C) 2004-2005 Christoph Hellwig              *</span>
<span class="cm"> *                                                                 *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or   *</span>
<span class="cm"> * modify it under the terms of version 2 of the GNU General       *</span>
<span class="cm"> * Public License as published by the Free Software Foundation.    *</span>
<span class="cm"> * This program is distributed in the hope that it will be useful. *</span>
<span class="cm"> * ALL EXPRESS OR IMPLIED CONDITIONS, REPRESENTATIONS AND          *</span>
<span class="cm"> * WARRANTIES, INCLUDING ANY IMPLIED WARRANTY OF MERCHANTABILITY,  *</span>
<span class="cm"> * FITNESS FOR A PARTICULAR PURPOSE, OR NON-INFRINGEMENT, ARE      *</span>
<span class="cm"> * DISCLAIMED, EXCEPT TO THE EXTENT THAT SUCH DISCLAIMERS ARE HELD *</span>
<span class="cm"> * TO BE LEGALLY INVALID.  See the GNU General Public License for  *</span>
<span class="cm"> * more details, a copy of which can be found in the file COPYING  *</span>
<span class="cm"> * included with this package.                                     *</span>
<span class="cm"> *******************************************************************/</span>

<span class="cp">#include &lt;linux/blkdev.h&gt;</span>
<span class="cp">#include &lt;linux/pci.h&gt;</span>
<span class="cp">#include &lt;linux/interrupt.h&gt;</span>
<span class="cp">#include &lt;linux/delay.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>

<span class="cp">#include &lt;scsi/scsi.h&gt;</span>
<span class="cp">#include &lt;scsi/scsi_cmnd.h&gt;</span>
<span class="cp">#include &lt;scsi/scsi_device.h&gt;</span>
<span class="cp">#include &lt;scsi/scsi_host.h&gt;</span>
<span class="cp">#include &lt;scsi/scsi_transport_fc.h&gt;</span>
<span class="cp">#include &lt;scsi/fc/fc_fs.h&gt;</span>
<span class="cp">#include &lt;linux/aer.h&gt;</span>

<span class="cp">#include &quot;lpfc_hw4.h&quot;</span>
<span class="cp">#include &quot;lpfc_hw.h&quot;</span>
<span class="cp">#include &quot;lpfc_sli.h&quot;</span>
<span class="cp">#include &quot;lpfc_sli4.h&quot;</span>
<span class="cp">#include &quot;lpfc_nl.h&quot;</span>
<span class="cp">#include &quot;lpfc_disc.h&quot;</span>
<span class="cp">#include &quot;lpfc_scsi.h&quot;</span>
<span class="cp">#include &quot;lpfc.h&quot;</span>
<span class="cp">#include &quot;lpfc_crtn.h&quot;</span>
<span class="cp">#include &quot;lpfc_logmsg.h&quot;</span>
<span class="cp">#include &quot;lpfc_compat.h&quot;</span>
<span class="cp">#include &quot;lpfc_debugfs.h&quot;</span>
<span class="cp">#include &quot;lpfc_vport.h&quot;</span>

<span class="cm">/* There are only four IOCB completion types. */</span>
<span class="k">typedef</span> <span class="k">enum</span> <span class="n">_lpfc_iocb_type</span> <span class="p">{</span>
	<span class="n">LPFC_UNKNOWN_IOCB</span><span class="p">,</span>
	<span class="n">LPFC_UNSOL_IOCB</span><span class="p">,</span>
	<span class="n">LPFC_SOL_IOCB</span><span class="p">,</span>
	<span class="n">LPFC_ABORT_IOCB</span>
<span class="p">}</span> <span class="n">lpfc_iocb_type</span><span class="p">;</span>


<span class="cm">/* Provide function prototypes local to this module. */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">lpfc_sli_issue_mbox_s4</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="p">,</span> <span class="n">LPFC_MBOXQ_t</span> <span class="o">*</span><span class="p">,</span>
				  <span class="kt">uint32_t</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">lpfc_sli4_read_rev</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="p">,</span> <span class="n">LPFC_MBOXQ_t</span> <span class="o">*</span><span class="p">,</span>
			      <span class="kt">uint8_t</span> <span class="o">*</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="o">*</span><span class="p">);</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">lpfc_iocbq</span> <span class="o">*</span><span class="n">lpfc_sli4_els_wcqe_to_rspiocbq</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="p">,</span>
							 <span class="k">struct</span> <span class="n">lpfc_iocbq</span> <span class="o">*</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">lpfc_sli4_send_seq_to_ulp</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="p">,</span>
				      <span class="k">struct</span> <span class="n">hbq_dmabuf</span> <span class="o">*</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">lpfc_sli4_fp_handle_wcqe</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">lpfc_queue</span> <span class="o">*</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">lpfc_cqe</span> <span class="o">*</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">lpfc_sli4_post_els_sgl_list</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="p">,</span>
				       <span class="kt">int</span><span class="p">);</span>

<span class="k">static</span> <span class="n">IOCB_t</span> <span class="o">*</span>
<span class="nf">lpfc_get_iocb_from_iocbq</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_iocbq</span> <span class="o">*</span><span class="n">iocbq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">&amp;</span><span class="n">iocbq</span><span class="o">-&gt;</span><span class="n">iocb</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_sli4_wq_put - Put a Work Queue Entry on an Work Queue</span>
<span class="cm"> * @q: The Work Queue to operate on.</span>
<span class="cm"> * @wqe: The work Queue Entry to put on the Work queue.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine will copy the contents of @wqe to the next available entry on</span>
<span class="cm"> * the @q. This function will then ring the Work Queue Doorbell to signal the</span>
<span class="cm"> * HBA to start processing the Work Queue Entry. This function returns 0 if</span>
<span class="cm"> * successful. If no entries are available on @q then this function will return</span>
<span class="cm"> * -ENOMEM.</span>
<span class="cm"> * The caller is expected to hold the hbalock when calling this routine.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">uint32_t</span>
<span class="nf">lpfc_sli4_wq_put</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span> <span class="k">union</span> <span class="n">lpfc_wqe</span> <span class="o">*</span><span class="n">wqe</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">union</span> <span class="n">lpfc_wqe</span> <span class="o">*</span><span class="n">temp_wqe</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_register</span> <span class="n">doorbell</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">host_index</span><span class="p">;</span>

	<span class="cm">/* sanity check on queue memory */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">q</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="n">temp_wqe</span> <span class="o">=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">qe</span><span class="p">[</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">host_index</span><span class="p">].</span><span class="n">wqe</span><span class="p">;</span>

	<span class="cm">/* If the host has not yet processed the next entry then we are done */</span>
	<span class="k">if</span> <span class="p">(((</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">host_index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">entry_count</span><span class="p">)</span> <span class="o">==</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">hba_index</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="cm">/* set consumption flag every once in a while */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">((</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">host_index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">entry_repost</span><span class="p">))</span>
		<span class="n">bf_set</span><span class="p">(</span><span class="n">wqe_wqec</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wqe</span><span class="o">-&gt;</span><span class="n">generic</span><span class="p">.</span><span class="n">wqe_com</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli3_options</span> <span class="o">&amp;</span> <span class="n">LPFC_SLI4_PHWQ_ENABLED</span><span class="p">)</span>
		<span class="n">bf_set</span><span class="p">(</span><span class="n">wqe_wqid</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wqe</span><span class="o">-&gt;</span><span class="n">generic</span><span class="p">.</span><span class="n">wqe_com</span><span class="p">,</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">queue_id</span><span class="p">);</span>
	<span class="n">lpfc_sli_pcimem_bcopy</span><span class="p">(</span><span class="n">wqe</span><span class="p">,</span> <span class="n">temp_wqe</span><span class="p">,</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">entry_size</span><span class="p">);</span>

	<span class="cm">/* Update the host index before invoking device */</span>
	<span class="n">host_index</span> <span class="o">=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">host_index</span><span class="p">;</span>
	<span class="n">q</span><span class="o">-&gt;</span><span class="n">host_index</span> <span class="o">=</span> <span class="p">((</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">host_index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">entry_count</span><span class="p">);</span>

	<span class="cm">/* Ring Doorbell */</span>
	<span class="n">doorbell</span><span class="p">.</span><span class="n">word0</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">bf_set</span><span class="p">(</span><span class="n">lpfc_wq_doorbell_num_posted</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">doorbell</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">bf_set</span><span class="p">(</span><span class="n">lpfc_wq_doorbell_index</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">doorbell</span><span class="p">,</span> <span class="n">host_index</span><span class="p">);</span>
	<span class="n">bf_set</span><span class="p">(</span><span class="n">lpfc_wq_doorbell_id</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">doorbell</span><span class="p">,</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">queue_id</span><span class="p">);</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">doorbell</span><span class="p">.</span><span class="n">word0</span><span class="p">,</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">WQDBregaddr</span><span class="p">);</span>
	<span class="n">readl</span><span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">WQDBregaddr</span><span class="p">);</span> <span class="cm">/* Flush */</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_sli4_wq_release - Updates internal hba index for WQ</span>
<span class="cm"> * @q: The Work Queue to operate on.</span>
<span class="cm"> * @index: The index to advance the hba index to.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine will update the HBA index of a queue to reflect consumption of</span>
<span class="cm"> * Work Queue Entries by the HBA. When the HBA indicates that it has consumed</span>
<span class="cm"> * an entry the host calls this function to update the queue&#39;s internal</span>
<span class="cm"> * pointers. This routine returns the number of entries that were consumed by</span>
<span class="cm"> * the HBA.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">uint32_t</span>
<span class="nf">lpfc_sli4_wq_release</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">index</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">uint32_t</span> <span class="n">released</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* sanity check on queue memory */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">q</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">hba_index</span> <span class="o">==</span> <span class="n">index</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="n">q</span><span class="o">-&gt;</span><span class="n">hba_index</span> <span class="o">=</span> <span class="p">((</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">hba_index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">entry_count</span><span class="p">);</span>
		<span class="n">released</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">hba_index</span> <span class="o">!=</span> <span class="n">index</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">released</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_sli4_mq_put - Put a Mailbox Queue Entry on an Mailbox Queue</span>
<span class="cm"> * @q: The Mailbox Queue to operate on.</span>
<span class="cm"> * @wqe: The Mailbox Queue Entry to put on the Work queue.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine will copy the contents of @mqe to the next available entry on</span>
<span class="cm"> * the @q. This function will then ring the Work Queue Doorbell to signal the</span>
<span class="cm"> * HBA to start processing the Work Queue Entry. This function returns 0 if</span>
<span class="cm"> * successful. If no entries are available on @q then this function will return</span>
<span class="cm"> * -ENOMEM.</span>
<span class="cm"> * The caller is expected to hold the hbalock when calling this routine.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">uint32_t</span>
<span class="nf">lpfc_sli4_mq_put</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span> <span class="k">struct</span> <span class="n">lpfc_mqe</span> <span class="o">*</span><span class="n">mqe</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpfc_mqe</span> <span class="o">*</span><span class="n">temp_mqe</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_register</span> <span class="n">doorbell</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">host_index</span><span class="p">;</span>

	<span class="cm">/* sanity check on queue memory */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">q</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="n">temp_mqe</span> <span class="o">=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">qe</span><span class="p">[</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">host_index</span><span class="p">].</span><span class="n">mqe</span><span class="p">;</span>

	<span class="cm">/* If the host has not yet processed the next entry then we are done */</span>
	<span class="k">if</span> <span class="p">(((</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">host_index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">entry_count</span><span class="p">)</span> <span class="o">==</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">hba_index</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="n">lpfc_sli_pcimem_bcopy</span><span class="p">(</span><span class="n">mqe</span><span class="p">,</span> <span class="n">temp_mqe</span><span class="p">,</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">entry_size</span><span class="p">);</span>
	<span class="cm">/* Save off the mailbox pointer for completion */</span>
	<span class="n">q</span><span class="o">-&gt;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">mbox</span> <span class="o">=</span> <span class="p">(</span><span class="n">MAILBOX_t</span> <span class="o">*</span><span class="p">)</span><span class="n">temp_mqe</span><span class="p">;</span>

	<span class="cm">/* Update the host index before invoking device */</span>
	<span class="n">host_index</span> <span class="o">=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">host_index</span><span class="p">;</span>
	<span class="n">q</span><span class="o">-&gt;</span><span class="n">host_index</span> <span class="o">=</span> <span class="p">((</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">host_index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">entry_count</span><span class="p">);</span>

	<span class="cm">/* Ring Doorbell */</span>
	<span class="n">doorbell</span><span class="p">.</span><span class="n">word0</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">bf_set</span><span class="p">(</span><span class="n">lpfc_mq_doorbell_num_posted</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">doorbell</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">bf_set</span><span class="p">(</span><span class="n">lpfc_mq_doorbell_id</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">doorbell</span><span class="p">,</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">queue_id</span><span class="p">);</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">doorbell</span><span class="p">.</span><span class="n">word0</span><span class="p">,</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">MQDBregaddr</span><span class="p">);</span>
	<span class="n">readl</span><span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">MQDBregaddr</span><span class="p">);</span> <span class="cm">/* Flush */</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_sli4_mq_release - Updates internal hba index for MQ</span>
<span class="cm"> * @q: The Mailbox Queue to operate on.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine will update the HBA index of a queue to reflect consumption of</span>
<span class="cm"> * a Mailbox Queue Entry by the HBA. When the HBA indicates that it has consumed</span>
<span class="cm"> * an entry the host calls this function to update the queue&#39;s internal</span>
<span class="cm"> * pointers. This routine returns the number of entries that were consumed by</span>
<span class="cm"> * the HBA.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">uint32_t</span>
<span class="nf">lpfc_sli4_mq_release</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* sanity check on queue memory */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">q</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Clear the mailbox pointer for completion */</span>
	<span class="n">q</span><span class="o">-&gt;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">mbox</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">q</span><span class="o">-&gt;</span><span class="n">hba_index</span> <span class="o">=</span> <span class="p">((</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">hba_index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">entry_count</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_sli4_eq_get - Gets the next valid EQE from a EQ</span>
<span class="cm"> * @q: The Event Queue to get the first valid EQE from</span>
<span class="cm"> *</span>
<span class="cm"> * This routine will get the first valid Event Queue Entry from @q, update</span>
<span class="cm"> * the queue&#39;s internal hba index, and return the EQE. If no valid EQEs are in</span>
<span class="cm"> * the Queue (no more work to do), or the Queue is full of EQEs that have been</span>
<span class="cm"> * processed, but not popped back to the HBA then this routine will return NULL.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">lpfc_eqe</span> <span class="o">*</span>
<span class="nf">lpfc_sli4_eq_get</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpfc_eqe</span> <span class="o">*</span><span class="n">eqe</span><span class="p">;</span>

	<span class="cm">/* sanity check on queue memory */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">q</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">eqe</span> <span class="o">=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">qe</span><span class="p">[</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">hba_index</span><span class="p">].</span><span class="n">eqe</span><span class="p">;</span>

	<span class="cm">/* If the next EQE is not valid then we are done */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bf_get_le32</span><span class="p">(</span><span class="n">lpfc_eqe_valid</span><span class="p">,</span> <span class="n">eqe</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="cm">/* If the host has not yet processed the next entry then we are done */</span>
	<span class="k">if</span> <span class="p">(((</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">hba_index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">entry_count</span><span class="p">)</span> <span class="o">==</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">host_index</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">q</span><span class="o">-&gt;</span><span class="n">hba_index</span> <span class="o">=</span> <span class="p">((</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">hba_index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">entry_count</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">eqe</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_sli4_eq_release - Indicates the host has finished processing an EQ</span>
<span class="cm"> * @q: The Event Queue that the host has completed processing for.</span>
<span class="cm"> * @arm: Indicates whether the host wants to arms this CQ.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine will mark all Event Queue Entries on @q, from the last</span>
<span class="cm"> * known completed entry to the last entry that was processed, as completed</span>
<span class="cm"> * by clearing the valid bit for each completion queue entry. Then it will</span>
<span class="cm"> * notify the HBA, by ringing the doorbell, that the EQEs have been processed.</span>
<span class="cm"> * The internal host index in the @q will be updated by this routine to indicate</span>
<span class="cm"> * that the host has finished processing the entries. The @arm parameter</span>
<span class="cm"> * indicates that the queue should be rearmed when ringing the doorbell.</span>
<span class="cm"> *</span>
<span class="cm"> * This function will return the number of EQEs that were popped.</span>
<span class="cm"> **/</span>
<span class="kt">uint32_t</span>
<span class="nf">lpfc_sli4_eq_release</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span> <span class="n">bool</span> <span class="n">arm</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">uint32_t</span> <span class="n">released</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_eqe</span> <span class="o">*</span><span class="n">temp_eqe</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_register</span> <span class="n">doorbell</span><span class="p">;</span>

	<span class="cm">/* sanity check on queue memory */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">q</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* while there are valid entries */</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">hba_index</span> <span class="o">!=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">host_index</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">temp_eqe</span> <span class="o">=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">qe</span><span class="p">[</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">host_index</span><span class="p">].</span><span class="n">eqe</span><span class="p">;</span>
		<span class="n">bf_set_le32</span><span class="p">(</span><span class="n">lpfc_eqe_valid</span><span class="p">,</span> <span class="n">temp_eqe</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">released</span><span class="o">++</span><span class="p">;</span>
		<span class="n">q</span><span class="o">-&gt;</span><span class="n">host_index</span> <span class="o">=</span> <span class="p">((</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">host_index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">entry_count</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">released</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">arm</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* ring doorbell for number popped */</span>
	<span class="n">doorbell</span><span class="p">.</span><span class="n">word0</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">arm</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">bf_set</span><span class="p">(</span><span class="n">lpfc_eqcq_doorbell_arm</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">doorbell</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">bf_set</span><span class="p">(</span><span class="n">lpfc_eqcq_doorbell_eqci</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">doorbell</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">bf_set</span><span class="p">(</span><span class="n">lpfc_eqcq_doorbell_num_released</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">doorbell</span><span class="p">,</span> <span class="n">released</span><span class="p">);</span>
	<span class="n">bf_set</span><span class="p">(</span><span class="n">lpfc_eqcq_doorbell_qt</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">doorbell</span><span class="p">,</span> <span class="n">LPFC_QUEUE_TYPE_EVENT</span><span class="p">);</span>
	<span class="n">bf_set</span><span class="p">(</span><span class="n">lpfc_eqcq_doorbell_eqid_hi</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">doorbell</span><span class="p">,</span>
			<span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">queue_id</span> <span class="o">&gt;&gt;</span> <span class="n">LPFC_EQID_HI_FIELD_SHIFT</span><span class="p">));</span>
	<span class="n">bf_set</span><span class="p">(</span><span class="n">lpfc_eqcq_doorbell_eqid_lo</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">doorbell</span><span class="p">,</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">queue_id</span><span class="p">);</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">doorbell</span><span class="p">.</span><span class="n">word0</span><span class="p">,</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">EQCQDBregaddr</span><span class="p">);</span>
	<span class="cm">/* PCI read to flush PCI pipeline on re-arming for INTx mode */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">intr_type</span> <span class="o">==</span> <span class="n">INTx</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">arm</span> <span class="o">==</span> <span class="n">LPFC_QUEUE_REARM</span><span class="p">))</span>
		<span class="n">readl</span><span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">EQCQDBregaddr</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">released</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_sli4_cq_get - Gets the next valid CQE from a CQ</span>
<span class="cm"> * @q: The Completion Queue to get the first valid CQE from</span>
<span class="cm"> *</span>
<span class="cm"> * This routine will get the first valid Completion Queue Entry from @q, update</span>
<span class="cm"> * the queue&#39;s internal hba index, and return the CQE. If no valid CQEs are in</span>
<span class="cm"> * the Queue (no more work to do), or the Queue is full of CQEs that have been</span>
<span class="cm"> * processed, but not popped back to the HBA then this routine will return NULL.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">lpfc_cqe</span> <span class="o">*</span>
<span class="nf">lpfc_sli4_cq_get</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpfc_cqe</span> <span class="o">*</span><span class="n">cqe</span><span class="p">;</span>

	<span class="cm">/* sanity check on queue memory */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">q</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="cm">/* If the next CQE is not valid then we are done */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bf_get_le32</span><span class="p">(</span><span class="n">lpfc_cqe_valid</span><span class="p">,</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">qe</span><span class="p">[</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">hba_index</span><span class="p">].</span><span class="n">cqe</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="cm">/* If the host has not yet processed the next entry then we are done */</span>
	<span class="k">if</span> <span class="p">(((</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">hba_index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">entry_count</span><span class="p">)</span> <span class="o">==</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">host_index</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">cqe</span> <span class="o">=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">qe</span><span class="p">[</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">hba_index</span><span class="p">].</span><span class="n">cqe</span><span class="p">;</span>
	<span class="n">q</span><span class="o">-&gt;</span><span class="n">hba_index</span> <span class="o">=</span> <span class="p">((</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">hba_index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">entry_count</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">cqe</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_sli4_cq_release - Indicates the host has finished processing a CQ</span>
<span class="cm"> * @q: The Completion Queue that the host has completed processing for.</span>
<span class="cm"> * @arm: Indicates whether the host wants to arms this CQ.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine will mark all Completion queue entries on @q, from the last</span>
<span class="cm"> * known completed entry to the last entry that was processed, as completed</span>
<span class="cm"> * by clearing the valid bit for each completion queue entry. Then it will</span>
<span class="cm"> * notify the HBA, by ringing the doorbell, that the CQEs have been processed.</span>
<span class="cm"> * The internal host index in the @q will be updated by this routine to indicate</span>
<span class="cm"> * that the host has finished processing the entries. The @arm parameter</span>
<span class="cm"> * indicates that the queue should be rearmed when ringing the doorbell.</span>
<span class="cm"> *</span>
<span class="cm"> * This function will return the number of CQEs that were released.</span>
<span class="cm"> **/</span>
<span class="kt">uint32_t</span>
<span class="nf">lpfc_sli4_cq_release</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span> <span class="n">bool</span> <span class="n">arm</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">uint32_t</span> <span class="n">released</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_cqe</span> <span class="o">*</span><span class="n">temp_qe</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_register</span> <span class="n">doorbell</span><span class="p">;</span>

	<span class="cm">/* sanity check on queue memory */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">q</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="cm">/* while there are valid entries */</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">hba_index</span> <span class="o">!=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">host_index</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">temp_qe</span> <span class="o">=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">qe</span><span class="p">[</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">host_index</span><span class="p">].</span><span class="n">cqe</span><span class="p">;</span>
		<span class="n">bf_set_le32</span><span class="p">(</span><span class="n">lpfc_cqe_valid</span><span class="p">,</span> <span class="n">temp_qe</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">released</span><span class="o">++</span><span class="p">;</span>
		<span class="n">q</span><span class="o">-&gt;</span><span class="n">host_index</span> <span class="o">=</span> <span class="p">((</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">host_index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">entry_count</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">released</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">arm</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* ring doorbell for number popped */</span>
	<span class="n">doorbell</span><span class="p">.</span><span class="n">word0</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">arm</span><span class="p">)</span>
		<span class="n">bf_set</span><span class="p">(</span><span class="n">lpfc_eqcq_doorbell_arm</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">doorbell</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">bf_set</span><span class="p">(</span><span class="n">lpfc_eqcq_doorbell_num_released</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">doorbell</span><span class="p">,</span> <span class="n">released</span><span class="p">);</span>
	<span class="n">bf_set</span><span class="p">(</span><span class="n">lpfc_eqcq_doorbell_qt</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">doorbell</span><span class="p">,</span> <span class="n">LPFC_QUEUE_TYPE_COMPLETION</span><span class="p">);</span>
	<span class="n">bf_set</span><span class="p">(</span><span class="n">lpfc_eqcq_doorbell_cqid_hi</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">doorbell</span><span class="p">,</span>
			<span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">queue_id</span> <span class="o">&gt;&gt;</span> <span class="n">LPFC_CQID_HI_FIELD_SHIFT</span><span class="p">));</span>
	<span class="n">bf_set</span><span class="p">(</span><span class="n">lpfc_eqcq_doorbell_cqid_lo</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">doorbell</span><span class="p">,</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">queue_id</span><span class="p">);</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">doorbell</span><span class="p">.</span><span class="n">word0</span><span class="p">,</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">EQCQDBregaddr</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">released</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_sli4_rq_put - Put a Receive Buffer Queue Entry on a Receive Queue</span>
<span class="cm"> * @q: The Header Receive Queue to operate on.</span>
<span class="cm"> * @wqe: The Receive Queue Entry to put on the Receive queue.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine will copy the contents of @wqe to the next available entry on</span>
<span class="cm"> * the @q. This function will then ring the Receive Queue Doorbell to signal the</span>
<span class="cm"> * HBA to start processing the Receive Queue Entry. This function returns the</span>
<span class="cm"> * index that the rqe was copied to if successful. If no entries are available</span>
<span class="cm"> * on @q then this function will return -ENOMEM.</span>
<span class="cm"> * The caller is expected to hold the hbalock when calling this routine.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">lpfc_sli4_rq_put</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_queue</span> <span class="o">*</span><span class="n">hq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">lpfc_queue</span> <span class="o">*</span><span class="n">dq</span><span class="p">,</span>
		 <span class="k">struct</span> <span class="n">lpfc_rqe</span> <span class="o">*</span><span class="n">hrqe</span><span class="p">,</span> <span class="k">struct</span> <span class="n">lpfc_rqe</span> <span class="o">*</span><span class="n">drqe</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpfc_rqe</span> <span class="o">*</span><span class="n">temp_hrqe</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_rqe</span> <span class="o">*</span><span class="n">temp_drqe</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_register</span> <span class="n">doorbell</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">put_index</span> <span class="o">=</span> <span class="n">hq</span><span class="o">-&gt;</span><span class="n">host_index</span><span class="p">;</span>

	<span class="cm">/* sanity check on queue memory */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">hq</span><span class="p">)</span> <span class="o">||</span> <span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">dq</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="n">temp_hrqe</span> <span class="o">=</span> <span class="n">hq</span><span class="o">-&gt;</span><span class="n">qe</span><span class="p">[</span><span class="n">hq</span><span class="o">-&gt;</span><span class="n">host_index</span><span class="p">].</span><span class="n">rqe</span><span class="p">;</span>
	<span class="n">temp_drqe</span> <span class="o">=</span> <span class="n">dq</span><span class="o">-&gt;</span><span class="n">qe</span><span class="p">[</span><span class="n">dq</span><span class="o">-&gt;</span><span class="n">host_index</span><span class="p">].</span><span class="n">rqe</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">hq</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">!=</span> <span class="n">LPFC_HRQ</span> <span class="o">||</span> <span class="n">dq</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">!=</span> <span class="n">LPFC_DRQ</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hq</span><span class="o">-&gt;</span><span class="n">host_index</span> <span class="o">!=</span> <span class="n">dq</span><span class="o">-&gt;</span><span class="n">host_index</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="cm">/* If the host has not yet processed the next entry then we are done */</span>
	<span class="k">if</span> <span class="p">(((</span><span class="n">hq</span><span class="o">-&gt;</span><span class="n">host_index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">hq</span><span class="o">-&gt;</span><span class="n">entry_count</span><span class="p">)</span> <span class="o">==</span> <span class="n">hq</span><span class="o">-&gt;</span><span class="n">hba_index</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
	<span class="n">lpfc_sli_pcimem_bcopy</span><span class="p">(</span><span class="n">hrqe</span><span class="p">,</span> <span class="n">temp_hrqe</span><span class="p">,</span> <span class="n">hq</span><span class="o">-&gt;</span><span class="n">entry_size</span><span class="p">);</span>
	<span class="n">lpfc_sli_pcimem_bcopy</span><span class="p">(</span><span class="n">drqe</span><span class="p">,</span> <span class="n">temp_drqe</span><span class="p">,</span> <span class="n">dq</span><span class="o">-&gt;</span><span class="n">entry_size</span><span class="p">);</span>

	<span class="cm">/* Update the host index to point to the next slot */</span>
	<span class="n">hq</span><span class="o">-&gt;</span><span class="n">host_index</span> <span class="o">=</span> <span class="p">((</span><span class="n">hq</span><span class="o">-&gt;</span><span class="n">host_index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">hq</span><span class="o">-&gt;</span><span class="n">entry_count</span><span class="p">);</span>
	<span class="n">dq</span><span class="o">-&gt;</span><span class="n">host_index</span> <span class="o">=</span> <span class="p">((</span><span class="n">dq</span><span class="o">-&gt;</span><span class="n">host_index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">dq</span><span class="o">-&gt;</span><span class="n">entry_count</span><span class="p">);</span>

	<span class="cm">/* Ring The Header Receive Queue Doorbell */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">hq</span><span class="o">-&gt;</span><span class="n">host_index</span> <span class="o">%</span> <span class="n">hq</span><span class="o">-&gt;</span><span class="n">entry_repost</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">doorbell</span><span class="p">.</span><span class="n">word0</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">bf_set</span><span class="p">(</span><span class="n">lpfc_rq_doorbell_num_posted</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">doorbell</span><span class="p">,</span>
		       <span class="n">hq</span><span class="o">-&gt;</span><span class="n">entry_repost</span><span class="p">);</span>
		<span class="n">bf_set</span><span class="p">(</span><span class="n">lpfc_rq_doorbell_id</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">doorbell</span><span class="p">,</span> <span class="n">hq</span><span class="o">-&gt;</span><span class="n">queue_id</span><span class="p">);</span>
		<span class="n">writel</span><span class="p">(</span><span class="n">doorbell</span><span class="p">.</span><span class="n">word0</span><span class="p">,</span> <span class="n">hq</span><span class="o">-&gt;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">RQDBregaddr</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">put_index</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_sli4_rq_release - Updates internal hba index for RQ</span>
<span class="cm"> * @q: The Header Receive Queue to operate on.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine will update the HBA index of a queue to reflect consumption of</span>
<span class="cm"> * one Receive Queue Entry by the HBA. When the HBA indicates that it has</span>
<span class="cm"> * consumed an entry the host calls this function to update the queue&#39;s</span>
<span class="cm"> * internal pointers. This routine returns the number of entries that were</span>
<span class="cm"> * consumed by the HBA.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">uint32_t</span>
<span class="nf">lpfc_sli4_rq_release</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_queue</span> <span class="o">*</span><span class="n">hq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">lpfc_queue</span> <span class="o">*</span><span class="n">dq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* sanity check on queue memory */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">hq</span><span class="p">)</span> <span class="o">||</span> <span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">dq</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">hq</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">!=</span> <span class="n">LPFC_HRQ</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">dq</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">!=</span> <span class="n">LPFC_DRQ</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">hq</span><span class="o">-&gt;</span><span class="n">hba_index</span> <span class="o">=</span> <span class="p">((</span><span class="n">hq</span><span class="o">-&gt;</span><span class="n">hba_index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">hq</span><span class="o">-&gt;</span><span class="n">entry_count</span><span class="p">);</span>
	<span class="n">dq</span><span class="o">-&gt;</span><span class="n">hba_index</span> <span class="o">=</span> <span class="p">((</span><span class="n">dq</span><span class="o">-&gt;</span><span class="n">hba_index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">dq</span><span class="o">-&gt;</span><span class="n">entry_count</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_cmd_iocb - Get next command iocb entry in the ring</span>
<span class="cm"> * @phba: Pointer to HBA context object.</span>
<span class="cm"> * @pring: Pointer to driver SLI ring object.</span>
<span class="cm"> *</span>
<span class="cm"> * This function returns pointer to next command iocb entry</span>
<span class="cm"> * in the command ring. The caller must hold hbalock to prevent</span>
<span class="cm"> * other threads consume the next command iocb.</span>
<span class="cm"> * SLI-2/SLI-3 provide different sized iocbs.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">IOCB_t</span> <span class="o">*</span>
<span class="nf">lpfc_cmd_iocb</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">,</span> <span class="k">struct</span> <span class="n">lpfc_sli_ring</span> <span class="o">*</span><span class="n">pring</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">IOCB_t</span> <span class="o">*</span><span class="p">)</span> <span class="p">(((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span> <span class="n">pring</span><span class="o">-&gt;</span><span class="n">cmdringaddr</span><span class="p">)</span> <span class="o">+</span>
			   <span class="n">pring</span><span class="o">-&gt;</span><span class="n">cmdidx</span> <span class="o">*</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">iocb_cmd_size</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_resp_iocb - Get next response iocb entry in the ring</span>
<span class="cm"> * @phba: Pointer to HBA context object.</span>
<span class="cm"> * @pring: Pointer to driver SLI ring object.</span>
<span class="cm"> *</span>
<span class="cm"> * This function returns pointer to next response iocb entry</span>
<span class="cm"> * in the response ring. The caller must hold hbalock to make sure</span>
<span class="cm"> * that no other thread consume the next response iocb.</span>
<span class="cm"> * SLI-2/SLI-3 provide different sized iocbs.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">IOCB_t</span> <span class="o">*</span>
<span class="nf">lpfc_resp_iocb</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">,</span> <span class="k">struct</span> <span class="n">lpfc_sli_ring</span> <span class="o">*</span><span class="n">pring</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">IOCB_t</span> <span class="o">*</span><span class="p">)</span> <span class="p">(((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span> <span class="n">pring</span><span class="o">-&gt;</span><span class="n">rspringaddr</span><span class="p">)</span> <span class="o">+</span>
			   <span class="n">pring</span><span class="o">-&gt;</span><span class="n">rspidx</span> <span class="o">*</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">iocb_rsp_size</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * __lpfc_sli_get_iocbq - Allocates an iocb object from iocb pool</span>
<span class="cm"> * @phba: Pointer to HBA context object.</span>
<span class="cm"> *</span>
<span class="cm"> * This function is called with hbalock held. This function</span>
<span class="cm"> * allocates a new driver iocb object from the iocb pool. If the</span>
<span class="cm"> * allocation is successful, it returns pointer to the newly</span>
<span class="cm"> * allocated iocb object else it returns NULL.</span>
<span class="cm"> **/</span>
<span class="k">struct</span> <span class="n">lpfc_iocbq</span> <span class="o">*</span>
<span class="nf">__lpfc_sli_get_iocbq</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">lpfc_iocb_list</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">lpfc_iocb_list</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_iocbq</span> <span class="o">*</span> <span class="n">iocbq</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">list_remove_head</span><span class="p">(</span><span class="n">lpfc_iocb_list</span><span class="p">,</span> <span class="n">iocbq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">lpfc_iocbq</span><span class="p">,</span> <span class="n">list</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">iocbq</span><span class="p">)</span>
		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">iocb_cnt</span><span class="o">++</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">iocb_cnt</span> <span class="o">&gt;</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">iocb_max</span><span class="p">)</span>
		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">iocb_max</span> <span class="o">=</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">iocb_cnt</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">iocbq</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * __lpfc_clear_active_sglq - Remove the active sglq for this XRI.</span>
<span class="cm"> * @phba: Pointer to HBA context object.</span>
<span class="cm"> * @xritag: XRI value.</span>
<span class="cm"> *</span>
<span class="cm"> * This function clears the sglq pointer from the array of acive</span>
<span class="cm"> * sglq&#39;s. The xritag that is passed in is used to index into the</span>
<span class="cm"> * array. Before the xritag can be used it needs to be adjusted</span>
<span class="cm"> * by subtracting the xribase.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns sglq ponter = success, NULL = Failure.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">lpfc_sglq</span> <span class="o">*</span>
<span class="nf">__lpfc_clear_active_sglq</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">,</span> <span class="kt">uint16_t</span> <span class="n">xritag</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpfc_sglq</span> <span class="o">*</span><span class="n">sglq</span><span class="p">;</span>

	<span class="n">sglq</span> <span class="o">=</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">lpfc_sglq_active_list</span><span class="p">[</span><span class="n">xritag</span><span class="p">];</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">lpfc_sglq_active_list</span><span class="p">[</span><span class="n">xritag</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">sglq</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * __lpfc_get_active_sglq - Get the active sglq for this XRI.</span>
<span class="cm"> * @phba: Pointer to HBA context object.</span>
<span class="cm"> * @xritag: XRI value.</span>
<span class="cm"> *</span>
<span class="cm"> * This function returns the sglq pointer from the array of acive</span>
<span class="cm"> * sglq&#39;s. The xritag that is passed in is used to index into the</span>
<span class="cm"> * array. Before the xritag can be used it needs to be adjusted</span>
<span class="cm"> * by subtracting the xribase.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns sglq ponter = success, NULL = Failure.</span>
<span class="cm"> **/</span>
<span class="k">struct</span> <span class="n">lpfc_sglq</span> <span class="o">*</span>
<span class="nf">__lpfc_get_active_sglq</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">,</span> <span class="kt">uint16_t</span> <span class="n">xritag</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpfc_sglq</span> <span class="o">*</span><span class="n">sglq</span><span class="p">;</span>

	<span class="n">sglq</span> <span class="o">=</span>  <span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">lpfc_sglq_active_list</span><span class="p">[</span><span class="n">xritag</span><span class="p">];</span>
	<span class="k">return</span> <span class="n">sglq</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_clr_rrq_active - Clears RRQ active bit in xri_bitmap.</span>
<span class="cm"> * @phba: Pointer to HBA context object.</span>
<span class="cm"> * @xritag: xri used in this exchange.</span>
<span class="cm"> * @rrq: The RRQ to be cleared.</span>
<span class="cm"> *</span>
<span class="cm"> **/</span>
<span class="kt">void</span>
<span class="nf">lpfc_clr_rrq_active</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">,</span>
		    <span class="kt">uint16_t</span> <span class="n">xritag</span><span class="p">,</span>
		    <span class="k">struct</span> <span class="n">lpfc_node_rrq</span> <span class="o">*</span><span class="n">rrq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpfc_nodelist</span> <span class="o">*</span><span class="n">ndlp</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">rrq</span><span class="o">-&gt;</span><span class="n">vport</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">NLP_CHK_NODE_ACT</span><span class="p">(</span><span class="n">rrq</span><span class="o">-&gt;</span><span class="n">ndlp</span><span class="p">))</span>
		<span class="n">ndlp</span> <span class="o">=</span> <span class="n">lpfc_findnode_did</span><span class="p">(</span><span class="n">rrq</span><span class="o">-&gt;</span><span class="n">vport</span><span class="p">,</span> <span class="n">rrq</span><span class="o">-&gt;</span><span class="n">nlp_DID</span><span class="p">);</span>

	<span class="cm">/* The target DID could have been swapped (cable swap)</span>
<span class="cm">	 * we should use the ndlp from the findnode if it is</span>
<span class="cm">	 * available.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="o">!</span><span class="n">ndlp</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">rrq</span><span class="o">-&gt;</span><span class="n">ndlp</span><span class="p">)</span>
		<span class="n">ndlp</span> <span class="o">=</span> <span class="n">rrq</span><span class="o">-&gt;</span><span class="n">ndlp</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ndlp</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">test_and_clear_bit</span><span class="p">(</span><span class="n">xritag</span><span class="p">,</span> <span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">active_rrqs</span><span class="p">.</span><span class="n">xri_bitmap</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">rrq</span><span class="o">-&gt;</span><span class="n">send_rrq</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">rrq</span><span class="o">-&gt;</span><span class="n">xritag</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">rrq</span><span class="o">-&gt;</span><span class="n">rrq_stop_time</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
<span class="nl">out:</span>
	<span class="n">mempool_free</span><span class="p">(</span><span class="n">rrq</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">rrq_pool</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_handle_rrq_active - Checks if RRQ has waithed RATOV.</span>
<span class="cm"> * @phba: Pointer to HBA context object.</span>
<span class="cm"> *</span>
<span class="cm"> * This function is called with hbalock held. This function</span>
<span class="cm"> * Checks if stop_time (ratov from setting rrq active) has</span>
<span class="cm"> * been reached, if it has and the send_rrq flag is set then</span>
<span class="cm"> * it will call lpfc_send_rrq. If the send_rrq flag is not set</span>
<span class="cm"> * then it will just call the routine to clear the rrq and</span>
<span class="cm"> * free the rrq resource.</span>
<span class="cm"> * The timer is set to the next rrq that is going to expire before</span>
<span class="cm"> * leaving the routine.</span>
<span class="cm"> *</span>
<span class="cm"> **/</span>
<span class="kt">void</span>
<span class="nf">lpfc_handle_rrq_active</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpfc_node_rrq</span> <span class="o">*</span><span class="n">rrq</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_node_rrq</span> <span class="o">*</span><span class="n">nextrrq</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">next_time</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">iflags</span><span class="p">;</span>
	<span class="n">LIST_HEAD</span><span class="p">(</span><span class="n">send_rrq</span><span class="p">);</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">,</span> <span class="n">iflags</span><span class="p">);</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">hba_flag</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">HBA_RRQ_ACTIVE</span><span class="p">;</span>
	<span class="n">next_time</span> <span class="o">=</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="n">HZ</span> <span class="o">*</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">fc_ratov</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">rrq</span><span class="p">,</span> <span class="n">nextrrq</span><span class="p">,</span>
				 <span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">active_rrq_list</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">time_after</span><span class="p">(</span><span class="n">jiffies</span><span class="p">,</span> <span class="n">rrq</span><span class="o">-&gt;</span><span class="n">rrq_stop_time</span><span class="p">))</span>
			<span class="n">list_move</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rrq</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">send_rrq</span><span class="p">);</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">time_before</span><span class="p">(</span><span class="n">rrq</span><span class="o">-&gt;</span><span class="n">rrq_stop_time</span><span class="p">,</span> <span class="n">next_time</span><span class="p">))</span>
			<span class="n">next_time</span> <span class="o">=</span> <span class="n">rrq</span><span class="o">-&gt;</span><span class="n">rrq_stop_time</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">,</span> <span class="n">iflags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">active_rrq_list</span><span class="p">))</span>
		<span class="n">mod_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">rrq_tmr</span><span class="p">,</span> <span class="n">next_time</span><span class="p">);</span>
	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">rrq</span><span class="p">,</span> <span class="n">nextrrq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">send_rrq</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rrq</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rrq</span><span class="o">-&gt;</span><span class="n">send_rrq</span><span class="p">)</span>
			<span class="cm">/* this call will free the rrq */</span>
		<span class="n">lpfc_clr_rrq_active</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">rrq</span><span class="o">-&gt;</span><span class="n">xritag</span><span class="p">,</span> <span class="n">rrq</span><span class="p">);</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">lpfc_send_rrq</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">rrq</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/* if we send the rrq then the completion handler</span>
<span class="cm">			*  will clear the bit in the xribitmap.</span>
<span class="cm">			*/</span>
			<span class="n">lpfc_clr_rrq_active</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">rrq</span><span class="o">-&gt;</span><span class="n">xritag</span><span class="p">,</span>
					    <span class="n">rrq</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_get_active_rrq - Get the active RRQ for this exchange.</span>
<span class="cm"> * @vport: Pointer to vport context object.</span>
<span class="cm"> * @xri: The xri used in the exchange.</span>
<span class="cm"> * @did: The targets DID for this exchange.</span>
<span class="cm"> *</span>
<span class="cm"> * returns NULL = rrq not found in the phba-&gt;active_rrq_list.</span>
<span class="cm"> *         rrq = rrq for this xri and target.</span>
<span class="cm"> **/</span>
<span class="k">struct</span> <span class="n">lpfc_node_rrq</span> <span class="o">*</span>
<span class="nf">lpfc_get_active_rrq</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="n">vport</span><span class="p">,</span> <span class="kt">uint16_t</span> <span class="n">xri</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">did</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span> <span class="o">=</span> <span class="n">vport</span><span class="o">-&gt;</span><span class="n">phba</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_node_rrq</span> <span class="o">*</span><span class="n">rrq</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_node_rrq</span> <span class="o">*</span><span class="n">nextrrq</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">iflags</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli_rev</span> <span class="o">!=</span> <span class="n">LPFC_SLI_REV4</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">,</span> <span class="n">iflags</span><span class="p">);</span>
	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">rrq</span><span class="p">,</span> <span class="n">nextrrq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">active_rrq_list</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rrq</span><span class="o">-&gt;</span><span class="n">vport</span> <span class="o">==</span> <span class="n">vport</span> <span class="o">&amp;&amp;</span> <span class="n">rrq</span><span class="o">-&gt;</span><span class="n">xritag</span> <span class="o">==</span> <span class="n">xri</span> <span class="o">&amp;&amp;</span>
				<span class="n">rrq</span><span class="o">-&gt;</span><span class="n">nlp_DID</span> <span class="o">==</span> <span class="n">did</span><span class="p">){</span>
			<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rrq</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
			<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">,</span> <span class="n">iflags</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">rrq</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">,</span> <span class="n">iflags</span><span class="p">);</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_cleanup_vports_rrqs - Remove and clear the active RRQ for this vport.</span>
<span class="cm"> * @vport: Pointer to vport context object.</span>
<span class="cm"> * @ndlp: Pointer to the lpfc_node_list structure.</span>
<span class="cm"> * If ndlp is NULL Remove all active RRQs for this vport from the</span>
<span class="cm"> * phba-&gt;active_rrq_list and clear the rrq.</span>
<span class="cm"> * If ndlp is not NULL then only remove rrqs for this vport &amp; this ndlp.</span>
<span class="cm"> **/</span>
<span class="kt">void</span>
<span class="nf">lpfc_cleanup_vports_rrqs</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="n">vport</span><span class="p">,</span> <span class="k">struct</span> <span class="n">lpfc_nodelist</span> <span class="o">*</span><span class="n">ndlp</span><span class="p">)</span>

<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span> <span class="o">=</span> <span class="n">vport</span><span class="o">-&gt;</span><span class="n">phba</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_node_rrq</span> <span class="o">*</span><span class="n">rrq</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_node_rrq</span> <span class="o">*</span><span class="n">nextrrq</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">iflags</span><span class="p">;</span>
	<span class="n">LIST_HEAD</span><span class="p">(</span><span class="n">rrq_list</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli_rev</span> <span class="o">!=</span> <span class="n">LPFC_SLI_REV4</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ndlp</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lpfc_sli4_vport_delete_els_xri_aborted</span><span class="p">(</span><span class="n">vport</span><span class="p">);</span>
		<span class="n">lpfc_sli4_vport_delete_fcp_xri_aborted</span><span class="p">(</span><span class="n">vport</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">,</span> <span class="n">iflags</span><span class="p">);</span>
	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">rrq</span><span class="p">,</span> <span class="n">nextrrq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">active_rrq_list</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">rrq</span><span class="o">-&gt;</span><span class="n">vport</span> <span class="o">==</span> <span class="n">vport</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="o">!</span><span class="n">ndlp</span>  <span class="o">||</span> <span class="n">rrq</span><span class="o">-&gt;</span><span class="n">ndlp</span> <span class="o">==</span> <span class="n">ndlp</span><span class="p">))</span>
			<span class="n">list_move</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rrq</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rrq_list</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">,</span> <span class="n">iflags</span><span class="p">);</span>

	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">rrq</span><span class="p">,</span> <span class="n">nextrrq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rrq_list</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rrq</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
		<span class="n">lpfc_clr_rrq_active</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">rrq</span><span class="o">-&gt;</span><span class="n">xritag</span><span class="p">,</span> <span class="n">rrq</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_cleanup_wt_rrqs - Remove all rrq&#39;s from the active list.</span>
<span class="cm"> * @phba: Pointer to HBA context object.</span>
<span class="cm"> *</span>
<span class="cm"> * Remove all rrqs from the phba-&gt;active_rrq_list and free them by</span>
<span class="cm"> * calling __lpfc_clr_active_rrq</span>
<span class="cm"> *</span>
<span class="cm"> **/</span>
<span class="kt">void</span>
<span class="nf">lpfc_cleanup_wt_rrqs</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpfc_node_rrq</span> <span class="o">*</span><span class="n">rrq</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_node_rrq</span> <span class="o">*</span><span class="n">nextrrq</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">next_time</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">iflags</span><span class="p">;</span>
	<span class="n">LIST_HEAD</span><span class="p">(</span><span class="n">rrq_list</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli_rev</span> <span class="o">!=</span> <span class="n">LPFC_SLI_REV4</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">,</span> <span class="n">iflags</span><span class="p">);</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">hba_flag</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">HBA_RRQ_ACTIVE</span><span class="p">;</span>
	<span class="n">next_time</span> <span class="o">=</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="n">HZ</span> <span class="o">*</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">fc_ratov</span> <span class="o">*</span> <span class="mi">2</span><span class="p">);</span>
	<span class="n">list_splice_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">active_rrq_list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rrq_list</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">,</span> <span class="n">iflags</span><span class="p">);</span>

	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">rrq</span><span class="p">,</span> <span class="n">nextrrq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rrq_list</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rrq</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
		<span class="n">lpfc_clr_rrq_active</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">rrq</span><span class="o">-&gt;</span><span class="n">xritag</span><span class="p">,</span> <span class="n">rrq</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">active_rrq_list</span><span class="p">))</span>
		<span class="n">mod_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">rrq_tmr</span><span class="p">,</span> <span class="n">next_time</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/**</span>
<span class="cm"> * lpfc_test_rrq_active - Test RRQ bit in xri_bitmap.</span>
<span class="cm"> * @phba: Pointer to HBA context object.</span>
<span class="cm"> * @ndlp: Targets nodelist pointer for this exchange.</span>
<span class="cm"> * @xritag the xri in the bitmap to test.</span>
<span class="cm"> *</span>
<span class="cm"> * This function is called with hbalock held. This function</span>
<span class="cm"> * returns 0 = rrq not active for this xri</span>
<span class="cm"> *         1 = rrq is valid for this xri.</span>
<span class="cm"> **/</span>
<span class="kt">int</span>
<span class="nf">lpfc_test_rrq_active</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">,</span> <span class="k">struct</span> <span class="n">lpfc_nodelist</span> <span class="o">*</span><span class="n">ndlp</span><span class="p">,</span>
			<span class="kt">uint16_t</span>  <span class="n">xritag</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ndlp</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">xritag</span><span class="p">,</span> <span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">active_rrqs</span><span class="p">.</span><span class="n">xri_bitmap</span><span class="p">))</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_set_rrq_active - set RRQ active bit in xri_bitmap.</span>
<span class="cm"> * @phba: Pointer to HBA context object.</span>
<span class="cm"> * @ndlp: nodelist pointer for this target.</span>
<span class="cm"> * @xritag: xri used in this exchange.</span>
<span class="cm"> * @rxid: Remote Exchange ID.</span>
<span class="cm"> * @send_rrq: Flag used to determine if we should send rrq els cmd.</span>
<span class="cm"> *</span>
<span class="cm"> * This function takes the hbalock.</span>
<span class="cm"> * The active bit is always set in the active rrq xri_bitmap even</span>
<span class="cm"> * if there is no slot avaiable for the other rrq information.</span>
<span class="cm"> *</span>
<span class="cm"> * returns 0 rrq actived for this xri</span>
<span class="cm"> *         &lt; 0 No memory or invalid ndlp.</span>
<span class="cm"> **/</span>
<span class="kt">int</span>
<span class="nf">lpfc_set_rrq_active</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">,</span> <span class="k">struct</span> <span class="n">lpfc_nodelist</span> <span class="o">*</span><span class="n">ndlp</span><span class="p">,</span>
		    <span class="kt">uint16_t</span> <span class="n">xritag</span><span class="p">,</span> <span class="kt">uint16_t</span> <span class="n">rxid</span><span class="p">,</span> <span class="kt">uint16_t</span> <span class="n">send_rrq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">iflags</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_node_rrq</span> <span class="o">*</span><span class="n">rrq</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">empty</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ndlp</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">cfg_enable_rrq</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">,</span> <span class="n">iflags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">pport</span><span class="o">-&gt;</span><span class="n">load_flag</span> <span class="o">&amp;</span> <span class="n">FC_UNLOADING</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">hba_flag</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">HBA_RRQ_ACTIVE</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * set the active bit even if there is no mem available.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">NLP_CHK_FREE_REQ</span><span class="p">(</span><span class="n">ndlp</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">vport</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">load_flag</span> <span class="o">&amp;</span> <span class="n">FC_UNLOADING</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">test_and_set_bit</span><span class="p">(</span><span class="n">xritag</span><span class="p">,</span> <span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">active_rrqs</span><span class="p">.</span><span class="n">xri_bitmap</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">,</span> <span class="n">iflags</span><span class="p">);</span>
	<span class="n">rrq</span> <span class="o">=</span> <span class="n">mempool_alloc</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">rrq_pool</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rrq</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_INFO</span><span class="p">,</span> <span class="n">LOG_SLI</span><span class="p">,</span>
				<span class="s">&quot;3155 Unable to allocate RRQ xri:0x%x rxid:0x%x&quot;</span>
				<span class="s">&quot; DID:0x%x Send:%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">xritag</span><span class="p">,</span> <span class="n">rxid</span><span class="p">,</span> <span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_DID</span><span class="p">,</span> <span class="n">send_rrq</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">rrq</span><span class="o">-&gt;</span><span class="n">send_rrq</span> <span class="o">=</span> <span class="n">send_rrq</span><span class="p">;</span>
	<span class="n">rrq</span><span class="o">-&gt;</span><span class="n">xritag</span> <span class="o">=</span> <span class="n">xritag</span><span class="p">;</span>
	<span class="n">rrq</span><span class="o">-&gt;</span><span class="n">rrq_stop_time</span> <span class="o">=</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="n">HZ</span> <span class="o">*</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">fc_ratov</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">rrq</span><span class="o">-&gt;</span><span class="n">ndlp</span> <span class="o">=</span> <span class="n">ndlp</span><span class="p">;</span>
	<span class="n">rrq</span><span class="o">-&gt;</span><span class="n">nlp_DID</span> <span class="o">=</span> <span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_DID</span><span class="p">;</span>
	<span class="n">rrq</span><span class="o">-&gt;</span><span class="n">vport</span> <span class="o">=</span> <span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">vport</span><span class="p">;</span>
	<span class="n">rrq</span><span class="o">-&gt;</span><span class="n">rxid</span> <span class="o">=</span> <span class="n">rxid</span><span class="p">;</span>
	<span class="n">rrq</span><span class="o">-&gt;</span><span class="n">send_rrq</span> <span class="o">=</span> <span class="n">send_rrq</span><span class="p">;</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">,</span> <span class="n">iflags</span><span class="p">);</span>
	<span class="n">empty</span> <span class="o">=</span> <span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">active_rrq_list</span><span class="p">);</span>
	<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rrq</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">active_rrq_list</span><span class="p">);</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">hba_flag</span> <span class="o">|=</span> <span class="n">HBA_RRQ_ACTIVE</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">empty</span><span class="p">)</span>
		<span class="n">lpfc_worker_wake_up</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">,</span> <span class="n">iflags</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">out:</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">,</span> <span class="n">iflags</span><span class="p">);</span>
	<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_INFO</span><span class="p">,</span> <span class="n">LOG_SLI</span><span class="p">,</span>
			<span class="s">&quot;2921 Can&#39;t set rrq active xri:0x%x rxid:0x%x&quot;</span>
			<span class="s">&quot; DID:0x%x Send:%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">xritag</span><span class="p">,</span> <span class="n">rxid</span><span class="p">,</span> <span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_DID</span><span class="p">,</span> <span class="n">send_rrq</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * __lpfc_sli_get_sglq - Allocates an iocb object from sgl pool</span>
<span class="cm"> * @phba: Pointer to HBA context object.</span>
<span class="cm"> * @piocb: Pointer to the iocbq.</span>
<span class="cm"> *</span>
<span class="cm"> * This function is called with hbalock held. This function</span>
<span class="cm"> * gets a new driver sglq object from the sglq list. If the</span>
<span class="cm"> * list is not empty then it is successful, it returns pointer to the newly</span>
<span class="cm"> * allocated sglq object else it returns NULL.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">lpfc_sglq</span> <span class="o">*</span>
<span class="nf">__lpfc_sli_get_sglq</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">,</span> <span class="k">struct</span> <span class="n">lpfc_iocbq</span> <span class="o">*</span><span class="n">piocbq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">lpfc_sgl_list</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">lpfc_sgl_list</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_sglq</span> <span class="o">*</span><span class="n">sglq</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_sglq</span> <span class="o">*</span><span class="n">start_sglq</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_scsi_buf</span> <span class="o">*</span><span class="n">lpfc_cmd</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_nodelist</span> <span class="o">*</span><span class="n">ndlp</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">found</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">piocbq</span><span class="o">-&gt;</span><span class="n">iocb_flag</span> <span class="o">&amp;</span>  <span class="n">LPFC_IO_FCP</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lpfc_cmd</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_scsi_buf</span> <span class="o">*</span><span class="p">)</span> <span class="n">piocbq</span><span class="o">-&gt;</span><span class="n">context1</span><span class="p">;</span>
		<span class="n">ndlp</span> <span class="o">=</span> <span class="n">lpfc_cmd</span><span class="o">-&gt;</span><span class="n">rdata</span><span class="o">-&gt;</span><span class="n">pnode</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span>  <span class="k">if</span> <span class="p">((</span><span class="n">piocbq</span><span class="o">-&gt;</span><span class="n">iocb</span><span class="p">.</span><span class="n">ulpCommand</span> <span class="o">==</span> <span class="n">CMD_GEN_REQUEST64_CR</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			<span class="o">!</span><span class="p">(</span><span class="n">piocbq</span><span class="o">-&gt;</span><span class="n">iocb_flag</span> <span class="o">&amp;</span> <span class="n">LPFC_IO_LIBDFC</span><span class="p">))</span>
		<span class="n">ndlp</span> <span class="o">=</span> <span class="n">piocbq</span><span class="o">-&gt;</span><span class="n">context_un</span><span class="p">.</span><span class="n">ndlp</span><span class="p">;</span>
	<span class="k">else</span>  <span class="k">if</span> <span class="p">((</span><span class="n">piocbq</span><span class="o">-&gt;</span><span class="n">iocb</span><span class="p">.</span><span class="n">ulpCommand</span> <span class="o">==</span> <span class="n">CMD_ELS_REQUEST64_CR</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			<span class="p">(</span><span class="n">piocbq</span><span class="o">-&gt;</span><span class="n">iocb_flag</span> <span class="o">&amp;</span> <span class="n">LPFC_IO_LIBDFC</span><span class="p">))</span>
		<span class="n">ndlp</span> <span class="o">=</span> <span class="n">piocbq</span><span class="o">-&gt;</span><span class="n">context_un</span><span class="p">.</span><span class="n">ndlp</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">ndlp</span> <span class="o">=</span> <span class="n">piocbq</span><span class="o">-&gt;</span><span class="n">context1</span><span class="p">;</span>

	<span class="n">list_remove_head</span><span class="p">(</span><span class="n">lpfc_sgl_list</span><span class="p">,</span> <span class="n">sglq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">lpfc_sglq</span><span class="p">,</span> <span class="n">list</span><span class="p">);</span>
	<span class="n">start_sglq</span> <span class="o">=</span> <span class="n">sglq</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">found</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sglq</span><span class="p">)</span>
			<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">lpfc_test_rrq_active</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">ndlp</span><span class="p">,</span> <span class="n">sglq</span><span class="o">-&gt;</span><span class="n">sli4_lxritag</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/* This xri has an rrq outstanding for this DID.</span>
<span class="cm">			 * put it back in the list and get another xri.</span>
<span class="cm">			 */</span>
			<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sglq</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="n">lpfc_sgl_list</span><span class="p">);</span>
			<span class="n">sglq</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="n">list_remove_head</span><span class="p">(</span><span class="n">lpfc_sgl_list</span><span class="p">,</span> <span class="n">sglq</span><span class="p">,</span>
						<span class="k">struct</span> <span class="n">lpfc_sglq</span><span class="p">,</span> <span class="n">list</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">sglq</span> <span class="o">==</span> <span class="n">start_sglq</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">sglq</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span>
				<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">sglq</span><span class="o">-&gt;</span><span class="n">ndlp</span> <span class="o">=</span> <span class="n">ndlp</span><span class="p">;</span>
		<span class="n">found</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">lpfc_sglq_active_list</span><span class="p">[</span><span class="n">sglq</span><span class="o">-&gt;</span><span class="n">sli4_lxritag</span><span class="p">]</span> <span class="o">=</span> <span class="n">sglq</span><span class="p">;</span>
		<span class="n">sglq</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">SGL_ALLOCATED</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">sglq</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_sli_get_iocbq - Allocates an iocb object from iocb pool</span>
<span class="cm"> * @phba: Pointer to HBA context object.</span>
<span class="cm"> *</span>
<span class="cm"> * This function is called with no lock held. This function</span>
<span class="cm"> * allocates a new driver iocb object from the iocb pool. If the</span>
<span class="cm"> * allocation is successful, it returns pointer to the newly</span>
<span class="cm"> * allocated iocb object else it returns NULL.</span>
<span class="cm"> **/</span>
<span class="k">struct</span> <span class="n">lpfc_iocbq</span> <span class="o">*</span>
<span class="nf">lpfc_sli_get_iocbq</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpfc_iocbq</span> <span class="o">*</span> <span class="n">iocbq</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">iflags</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">,</span> <span class="n">iflags</span><span class="p">);</span>
	<span class="n">iocbq</span> <span class="o">=</span> <span class="n">__lpfc_sli_get_iocbq</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">,</span> <span class="n">iflags</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">iocbq</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * __lpfc_sli_release_iocbq_s4 - Release iocb to the iocb pool</span>
<span class="cm"> * @phba: Pointer to HBA context object.</span>
<span class="cm"> * @iocbq: Pointer to driver iocb object.</span>
<span class="cm"> *</span>
<span class="cm"> * This function is called with hbalock held to release driver</span>
<span class="cm"> * iocb object to the iocb pool. The iotag in the iocb object</span>
<span class="cm"> * does not change for each use of the iocb object. This function</span>
<span class="cm"> * clears all other fields of the iocb object when it is freed.</span>
<span class="cm"> * The sqlq structure that holds the xritag and phys and virtual</span>
<span class="cm"> * mappings for the scatter gather list is retrieved from the</span>
<span class="cm"> * active array of sglq. The get of the sglq pointer also clears</span>
<span class="cm"> * the entry in the array. If the status of the IO indiactes that</span>
<span class="cm"> * this IO was aborted then the sglq entry it put on the</span>
<span class="cm"> * lpfc_abts_els_sgl_list until the CQ_ABORTED_XRI is received. If the</span>
<span class="cm"> * IO has good status or fails for any other reason then the sglq</span>
<span class="cm"> * entry is added to the free list (lpfc_sgl_list).</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">__lpfc_sli_release_iocbq_s4</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">,</span> <span class="k">struct</span> <span class="n">lpfc_iocbq</span> <span class="o">*</span><span class="n">iocbq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpfc_sglq</span> <span class="o">*</span><span class="n">sglq</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">start_clean</span> <span class="o">=</span> <span class="n">offsetof</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_iocbq</span><span class="p">,</span> <span class="n">iocb</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">iflag</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_sli_ring</span> <span class="o">*</span><span class="n">pring</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli</span><span class="p">.</span><span class="n">ring</span><span class="p">[</span><span class="n">LPFC_ELS_RING</span><span class="p">];</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">iocbq</span><span class="o">-&gt;</span><span class="n">sli4_xritag</span> <span class="o">==</span> <span class="n">NO_XRI</span><span class="p">)</span>
		<span class="n">sglq</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">sglq</span> <span class="o">=</span> <span class="n">__lpfc_clear_active_sglq</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">iocbq</span><span class="o">-&gt;</span><span class="n">sli4_lxritag</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sglq</span><span class="p">)</span>  <span class="p">{</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">iocbq</span><span class="o">-&gt;</span><span class="n">iocb_flag</span> <span class="o">&amp;</span> <span class="n">LPFC_EXCHANGE_BUSY</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			<span class="p">(</span><span class="n">sglq</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">!=</span> <span class="n">SGL_XRI_ABORTED</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">abts_sgl_list_lock</span><span class="p">,</span>
					<span class="n">iflag</span><span class="p">);</span>
			<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sglq</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span>
				<span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">lpfc_abts_els_sgl_list</span><span class="p">);</span>
			<span class="n">spin_unlock_irqrestore</span><span class="p">(</span>
				<span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">abts_sgl_list_lock</span><span class="p">,</span> <span class="n">iflag</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">sglq</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">SGL_FREED</span><span class="p">;</span>
			<span class="n">sglq</span><span class="o">-&gt;</span><span class="n">ndlp</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sglq</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span>
				<span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">lpfc_sgl_list</span><span class="p">);</span>

			<span class="cm">/* Check if TXQ queue needs to be serviced */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">pring</span><span class="o">-&gt;</span><span class="n">txq_cnt</span><span class="p">)</span>
				<span class="n">lpfc_worker_wake_up</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>


	<span class="cm">/*</span>
<span class="cm">	 * Clean all volatile data fields, preserve iotag and node struct.</span>
<span class="cm">	 */</span>
	<span class="n">memset</span><span class="p">((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">iocbq</span> <span class="o">+</span> <span class="n">start_clean</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">iocbq</span><span class="p">)</span> <span class="o">-</span> <span class="n">start_clean</span><span class="p">);</span>
	<span class="n">iocbq</span><span class="o">-&gt;</span><span class="n">sli4_lxritag</span> <span class="o">=</span> <span class="n">NO_XRI</span><span class="p">;</span>
	<span class="n">iocbq</span><span class="o">-&gt;</span><span class="n">sli4_xritag</span> <span class="o">=</span> <span class="n">NO_XRI</span><span class="p">;</span>
	<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iocbq</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">lpfc_iocb_list</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/**</span>
<span class="cm"> * __lpfc_sli_release_iocbq_s3 - Release iocb to the iocb pool</span>
<span class="cm"> * @phba: Pointer to HBA context object.</span>
<span class="cm"> * @iocbq: Pointer to driver iocb object.</span>
<span class="cm"> *</span>
<span class="cm"> * This function is called with hbalock held to release driver</span>
<span class="cm"> * iocb object to the iocb pool. The iotag in the iocb object</span>
<span class="cm"> * does not change for each use of the iocb object. This function</span>
<span class="cm"> * clears all other fields of the iocb object when it is freed.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">__lpfc_sli_release_iocbq_s3</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">,</span> <span class="k">struct</span> <span class="n">lpfc_iocbq</span> <span class="o">*</span><span class="n">iocbq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">size_t</span> <span class="n">start_clean</span> <span class="o">=</span> <span class="n">offsetof</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_iocbq</span><span class="p">,</span> <span class="n">iocb</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Clean all volatile data fields, preserve iotag and node struct.</span>
<span class="cm">	 */</span>
	<span class="n">memset</span><span class="p">((</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="n">iocbq</span> <span class="o">+</span> <span class="n">start_clean</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">iocbq</span><span class="p">)</span> <span class="o">-</span> <span class="n">start_clean</span><span class="p">);</span>
	<span class="n">iocbq</span><span class="o">-&gt;</span><span class="n">sli4_xritag</span> <span class="o">=</span> <span class="n">NO_XRI</span><span class="p">;</span>
	<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iocbq</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">lpfc_iocb_list</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * __lpfc_sli_release_iocbq - Release iocb to the iocb pool</span>
<span class="cm"> * @phba: Pointer to HBA context object.</span>
<span class="cm"> * @iocbq: Pointer to driver iocb object.</span>
<span class="cm"> *</span>
<span class="cm"> * This function is called with hbalock held to release driver</span>
<span class="cm"> * iocb object to the iocb pool. The iotag in the iocb object</span>
<span class="cm"> * does not change for each use of the iocb object. This function</span>
<span class="cm"> * clears all other fields of the iocb object when it is freed.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">__lpfc_sli_release_iocbq</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">,</span> <span class="k">struct</span> <span class="n">lpfc_iocbq</span> <span class="o">*</span><span class="n">iocbq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">__lpfc_sli_release_iocbq</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">iocbq</span><span class="p">);</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">iocb_cnt</span><span class="o">--</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_sli_release_iocbq - Release iocb to the iocb pool</span>
<span class="cm"> * @phba: Pointer to HBA context object.</span>
<span class="cm"> * @iocbq: Pointer to driver iocb object.</span>
<span class="cm"> *</span>
<span class="cm"> * This function is called with no lock held to release the iocb to</span>
<span class="cm"> * iocb pool.</span>
<span class="cm"> **/</span>
<span class="kt">void</span>
<span class="nf">lpfc_sli_release_iocbq</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">,</span> <span class="k">struct</span> <span class="n">lpfc_iocbq</span> <span class="o">*</span><span class="n">iocbq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">iflags</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Clean all volatile data fields, preserve iotag and node struct.</span>
<span class="cm">	 */</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">,</span> <span class="n">iflags</span><span class="p">);</span>
	<span class="n">__lpfc_sli_release_iocbq</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">iocbq</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">,</span> <span class="n">iflags</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_sli_cancel_iocbs - Cancel all iocbs from a list.</span>
<span class="cm"> * @phba: Pointer to HBA context object.</span>
<span class="cm"> * @iocblist: List of IOCBs.</span>
<span class="cm"> * @ulpstatus: ULP status in IOCB command field.</span>
<span class="cm"> * @ulpWord4: ULP word-4 in IOCB command field.</span>
<span class="cm"> *</span>
<span class="cm"> * This function is called with a list of IOCBs to cancel. It cancels the IOCB</span>
<span class="cm"> * on the list by invoking the complete callback function associated with the</span>
<span class="cm"> * IOCB with the provided @ulpstatus and @ulpword4 set to the IOCB commond</span>
<span class="cm"> * fields.</span>
<span class="cm"> **/</span>
<span class="kt">void</span>
<span class="nf">lpfc_sli_cancel_iocbs</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">,</span> <span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">iocblist</span><span class="p">,</span>
		      <span class="kt">uint32_t</span> <span class="n">ulpstatus</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">ulpWord4</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpfc_iocbq</span> <span class="o">*</span><span class="n">piocb</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="n">iocblist</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">list_remove_head</span><span class="p">(</span><span class="n">iocblist</span><span class="p">,</span> <span class="n">piocb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">lpfc_iocbq</span><span class="p">,</span> <span class="n">list</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">piocb</span><span class="o">-&gt;</span><span class="n">iocb_cmpl</span><span class="p">)</span>
			<span class="n">lpfc_sli_release_iocbq</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">piocb</span><span class="p">);</span>
		<span class="k">else</span> <span class="p">{</span>
			<span class="n">piocb</span><span class="o">-&gt;</span><span class="n">iocb</span><span class="p">.</span><span class="n">ulpStatus</span> <span class="o">=</span> <span class="n">ulpstatus</span><span class="p">;</span>
			<span class="n">piocb</span><span class="o">-&gt;</span><span class="n">iocb</span><span class="p">.</span><span class="n">un</span><span class="p">.</span><span class="n">ulpWord</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="n">ulpWord4</span><span class="p">;</span>
			<span class="p">(</span><span class="n">piocb</span><span class="o">-&gt;</span><span class="n">iocb_cmpl</span><span class="p">)</span> <span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">piocb</span><span class="p">,</span> <span class="n">piocb</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_sli_iocb_cmd_type - Get the iocb type</span>
<span class="cm"> * @iocb_cmnd: iocb command code.</span>
<span class="cm"> *</span>
<span class="cm"> * This function is called by ring event handler function to get the iocb type.</span>
<span class="cm"> * This function translates the iocb command to an iocb command type used to</span>
<span class="cm"> * decide the final disposition of each completed IOCB.</span>
<span class="cm"> * The function returns</span>
<span class="cm"> * LPFC_UNKNOWN_IOCB if it is an unsupported iocb</span>
<span class="cm"> * LPFC_SOL_IOCB     if it is a solicited iocb completion</span>
<span class="cm"> * LPFC_ABORT_IOCB   if it is an abort iocb</span>
<span class="cm"> * LPFC_UNSOL_IOCB   if it is an unsolicited iocb</span>
<span class="cm"> *</span>
<span class="cm"> * The caller is not required to hold any lock.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="n">lpfc_iocb_type</span>
<span class="nf">lpfc_sli_iocb_cmd_type</span><span class="p">(</span><span class="kt">uint8_t</span> <span class="n">iocb_cmnd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">lpfc_iocb_type</span> <span class="n">type</span> <span class="o">=</span> <span class="n">LPFC_UNKNOWN_IOCB</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">iocb_cmnd</span> <span class="o">&gt;</span> <span class="n">CMD_MAX_IOCB_CMD</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">iocb_cmnd</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">CMD_XMIT_SEQUENCE_CR</span>:
	<span class="k">case</span> <span class="n">CMD_XMIT_SEQUENCE_CX</span>:
	<span class="k">case</span> <span class="n">CMD_XMIT_BCAST_CN</span>:
	<span class="k">case</span> <span class="n">CMD_XMIT_BCAST_CX</span>:
	<span class="k">case</span> <span class="n">CMD_ELS_REQUEST_CR</span>:
	<span class="k">case</span> <span class="n">CMD_ELS_REQUEST_CX</span>:
	<span class="k">case</span> <span class="n">CMD_CREATE_XRI_CR</span>:
	<span class="k">case</span> <span class="n">CMD_CREATE_XRI_CX</span>:
	<span class="k">case</span> <span class="n">CMD_GET_RPI_CN</span>:
	<span class="k">case</span> <span class="n">CMD_XMIT_ELS_RSP_CX</span>:
	<span class="k">case</span> <span class="n">CMD_GET_RPI_CR</span>:
	<span class="k">case</span> <span class="n">CMD_FCP_IWRITE_CR</span>:
	<span class="k">case</span> <span class="n">CMD_FCP_IWRITE_CX</span>:
	<span class="k">case</span> <span class="n">CMD_FCP_IREAD_CR</span>:
	<span class="k">case</span> <span class="n">CMD_FCP_IREAD_CX</span>:
	<span class="k">case</span> <span class="n">CMD_FCP_ICMND_CR</span>:
	<span class="k">case</span> <span class="n">CMD_FCP_ICMND_CX</span>:
	<span class="k">case</span> <span class="n">CMD_FCP_TSEND_CX</span>:
	<span class="k">case</span> <span class="n">CMD_FCP_TRSP_CX</span>:
	<span class="k">case</span> <span class="n">CMD_FCP_TRECEIVE_CX</span>:
	<span class="k">case</span> <span class="n">CMD_FCP_AUTO_TRSP_CX</span>:
	<span class="k">case</span> <span class="n">CMD_ADAPTER_MSG</span>:
	<span class="k">case</span> <span class="n">CMD_ADAPTER_DUMP</span>:
	<span class="k">case</span> <span class="n">CMD_XMIT_SEQUENCE64_CR</span>:
	<span class="k">case</span> <span class="n">CMD_XMIT_SEQUENCE64_CX</span>:
	<span class="k">case</span> <span class="n">CMD_XMIT_BCAST64_CN</span>:
	<span class="k">case</span> <span class="n">CMD_XMIT_BCAST64_CX</span>:
	<span class="k">case</span> <span class="n">CMD_ELS_REQUEST64_CR</span>:
	<span class="k">case</span> <span class="n">CMD_ELS_REQUEST64_CX</span>:
	<span class="k">case</span> <span class="n">CMD_FCP_IWRITE64_CR</span>:
	<span class="k">case</span> <span class="n">CMD_FCP_IWRITE64_CX</span>:
	<span class="k">case</span> <span class="n">CMD_FCP_IREAD64_CR</span>:
	<span class="k">case</span> <span class="n">CMD_FCP_IREAD64_CX</span>:
	<span class="k">case</span> <span class="n">CMD_FCP_ICMND64_CR</span>:
	<span class="k">case</span> <span class="n">CMD_FCP_ICMND64_CX</span>:
	<span class="k">case</span> <span class="n">CMD_FCP_TSEND64_CX</span>:
	<span class="k">case</span> <span class="n">CMD_FCP_TRSP64_CX</span>:
	<span class="k">case</span> <span class="n">CMD_FCP_TRECEIVE64_CX</span>:
	<span class="k">case</span> <span class="n">CMD_GEN_REQUEST64_CR</span>:
	<span class="k">case</span> <span class="n">CMD_GEN_REQUEST64_CX</span>:
	<span class="k">case</span> <span class="n">CMD_XMIT_ELS_RSP64_CX</span>:
	<span class="k">case</span> <span class="n">DSSCMD_IWRITE64_CR</span>:
	<span class="k">case</span> <span class="n">DSSCMD_IWRITE64_CX</span>:
	<span class="k">case</span> <span class="n">DSSCMD_IREAD64_CR</span>:
	<span class="k">case</span> <span class="n">DSSCMD_IREAD64_CX</span>:
		<span class="n">type</span> <span class="o">=</span> <span class="n">LPFC_SOL_IOCB</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">CMD_ABORT_XRI_CN</span>:
	<span class="k">case</span> <span class="n">CMD_ABORT_XRI_CX</span>:
	<span class="k">case</span> <span class="n">CMD_CLOSE_XRI_CN</span>:
	<span class="k">case</span> <span class="n">CMD_CLOSE_XRI_CX</span>:
	<span class="k">case</span> <span class="n">CMD_XRI_ABORTED_CX</span>:
	<span class="k">case</span> <span class="n">CMD_ABORT_MXRI64_CN</span>:
	<span class="k">case</span> <span class="n">CMD_XMIT_BLS_RSP64_CX</span>:
		<span class="n">type</span> <span class="o">=</span> <span class="n">LPFC_ABORT_IOCB</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">CMD_RCV_SEQUENCE_CX</span>:
	<span class="k">case</span> <span class="n">CMD_RCV_ELS_REQ_CX</span>:
	<span class="k">case</span> <span class="n">CMD_RCV_SEQUENCE64_CX</span>:
	<span class="k">case</span> <span class="n">CMD_RCV_ELS_REQ64_CX</span>:
	<span class="k">case</span> <span class="n">CMD_ASYNC_STATUS</span>:
	<span class="k">case</span> <span class="n">CMD_IOCB_RCV_SEQ64_CX</span>:
	<span class="k">case</span> <span class="n">CMD_IOCB_RCV_ELS64_CX</span>:
	<span class="k">case</span> <span class="n">CMD_IOCB_RCV_CONT64_CX</span>:
	<span class="k">case</span> <span class="n">CMD_IOCB_RET_XRI64_CX</span>:
		<span class="n">type</span> <span class="o">=</span> <span class="n">LPFC_UNSOL_IOCB</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">CMD_IOCB_XMIT_MSEQ64_CR</span>:
	<span class="k">case</span> <span class="n">CMD_IOCB_XMIT_MSEQ64_CX</span>:
	<span class="k">case</span> <span class="n">CMD_IOCB_RCV_SEQ_LIST64_CX</span>:
	<span class="k">case</span> <span class="n">CMD_IOCB_RCV_ELS_LIST64_CX</span>:
	<span class="k">case</span> <span class="n">CMD_IOCB_CLOSE_EXTENDED_CN</span>:
	<span class="k">case</span> <span class="n">CMD_IOCB_ABORT_EXTENDED_CN</span>:
	<span class="k">case</span> <span class="n">CMD_IOCB_RET_HBQE64_CN</span>:
	<span class="k">case</span> <span class="n">CMD_IOCB_FCP_IBIDIR64_CR</span>:
	<span class="k">case</span> <span class="n">CMD_IOCB_FCP_IBIDIR64_CX</span>:
	<span class="k">case</span> <span class="n">CMD_IOCB_FCP_ITASKMGT64_CX</span>:
	<span class="k">case</span> <span class="n">CMD_IOCB_LOGENTRY_CN</span>:
	<span class="k">case</span> <span class="n">CMD_IOCB_LOGENTRY_ASYNC_CN</span>:
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%s - Unhandled SLI-3 Command x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">__func__</span><span class="p">,</span> <span class="n">iocb_cmnd</span><span class="p">);</span>
		<span class="n">type</span> <span class="o">=</span> <span class="n">LPFC_UNKNOWN_IOCB</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">type</span> <span class="o">=</span> <span class="n">LPFC_UNKNOWN_IOCB</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">type</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_sli_ring_map - Issue config_ring mbox for all rings</span>
<span class="cm"> * @phba: Pointer to HBA context object.</span>
<span class="cm"> *</span>
<span class="cm"> * This function is called from SLI initialization code</span>
<span class="cm"> * to configure every ring of the HBA&#39;s SLI interface. The</span>
<span class="cm"> * caller is not required to hold any lock. This function issues</span>
<span class="cm"> * a config_ring mailbox command for each ring.</span>
<span class="cm"> * This function returns zero if successful else returns a negative</span>
<span class="cm"> * error code.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">lpfc_sli_ring_map</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpfc_sli</span> <span class="o">*</span><span class="n">psli</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli</span><span class="p">;</span>
	<span class="n">LPFC_MBOXQ_t</span> <span class="o">*</span><span class="n">pmb</span><span class="p">;</span>
	<span class="n">MAILBOX_t</span> <span class="o">*</span><span class="n">pmbox</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">rc</span><span class="p">,</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">pmb</span> <span class="o">=</span> <span class="p">(</span><span class="n">LPFC_MBOXQ_t</span> <span class="o">*</span><span class="p">)</span> <span class="n">mempool_alloc</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">mbox_mem_pool</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pmb</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="n">pmbox</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">pmb</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">mb</span><span class="p">;</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">link_state</span> <span class="o">=</span> <span class="n">LPFC_INIT_MBX_CMDS</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">psli</span><span class="o">-&gt;</span><span class="n">num_rings</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lpfc_config_ring</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">pmb</span><span class="p">);</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">lpfc_sli_issue_mbox</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">pmb</span><span class="p">,</span> <span class="n">MBX_POLL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">!=</span> <span class="n">MBX_SUCCESS</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_INIT</span><span class="p">,</span>
					<span class="s">&quot;0446 Adapter failed to init (%d), &quot;</span>
					<span class="s">&quot;mbxCmd x%x CFG_RING, mbxStatus x%x, &quot;</span>
					<span class="s">&quot;ring %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">rc</span><span class="p">,</span> <span class="n">pmbox</span><span class="o">-&gt;</span><span class="n">mbxCommand</span><span class="p">,</span>
					<span class="n">pmbox</span><span class="o">-&gt;</span><span class="n">mbxStatus</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
			<span class="n">phba</span><span class="o">-&gt;</span><span class="n">link_state</span> <span class="o">=</span> <span class="n">LPFC_HBA_ERROR</span><span class="p">;</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENXIO</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">mempool_free</span><span class="p">(</span><span class="n">pmb</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">mbox_mem_pool</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_sli_ringtxcmpl_put - Adds new iocb to the txcmplq</span>
<span class="cm"> * @phba: Pointer to HBA context object.</span>
<span class="cm"> * @pring: Pointer to driver SLI ring object.</span>
<span class="cm"> * @piocb: Pointer to the driver iocb object.</span>
<span class="cm"> *</span>
<span class="cm"> * This function is called with hbalock held. The function adds the</span>
<span class="cm"> * new iocb to txcmplq of the given ring. This function always returns</span>
<span class="cm"> * 0. If this function is called for ELS ring, this function checks if</span>
<span class="cm"> * there is a vport associated with the ELS command. This function also</span>
<span class="cm"> * starts els_tmofunc timer if this is an ELS command.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">lpfc_sli_ringtxcmpl_put</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">,</span> <span class="k">struct</span> <span class="n">lpfc_sli_ring</span> <span class="o">*</span><span class="n">pring</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">lpfc_iocbq</span> <span class="o">*</span><span class="n">piocb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">piocb</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pring</span><span class="o">-&gt;</span><span class="n">txcmplq</span><span class="p">);</span>
	<span class="n">piocb</span><span class="o">-&gt;</span><span class="n">iocb_flag</span> <span class="o">|=</span> <span class="n">LPFC_IO_ON_TXCMPLQ</span><span class="p">;</span>
	<span class="n">pring</span><span class="o">-&gt;</span><span class="n">txcmplq_cnt</span><span class="o">++</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pring</span><span class="o">-&gt;</span><span class="n">txcmplq_cnt</span> <span class="o">&gt;</span> <span class="n">pring</span><span class="o">-&gt;</span><span class="n">txcmplq_max</span><span class="p">)</span>
		<span class="n">pring</span><span class="o">-&gt;</span><span class="n">txcmplq_max</span> <span class="o">=</span> <span class="n">pring</span><span class="o">-&gt;</span><span class="n">txcmplq_cnt</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">unlikely</span><span class="p">(</span><span class="n">pring</span><span class="o">-&gt;</span><span class="n">ringno</span> <span class="o">==</span> <span class="n">LPFC_ELS_RING</span><span class="p">))</span> <span class="o">&amp;&amp;</span>
	   <span class="p">(</span><span class="n">piocb</span><span class="o">-&gt;</span><span class="n">iocb</span><span class="p">.</span><span class="n">ulpCommand</span> <span class="o">!=</span> <span class="n">CMD_ABORT_XRI_CN</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	   <span class="p">(</span><span class="n">piocb</span><span class="o">-&gt;</span><span class="n">iocb</span><span class="p">.</span><span class="n">ulpCommand</span> <span class="o">!=</span> <span class="n">CMD_CLOSE_XRI_CN</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">piocb</span><span class="o">-&gt;</span><span class="n">vport</span><span class="p">)</span>
			<span class="n">BUG</span><span class="p">();</span>
		<span class="k">else</span>
			<span class="n">mod_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">piocb</span><span class="o">-&gt;</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">els_tmofunc</span><span class="p">,</span>
				  <span class="n">jiffies</span> <span class="o">+</span> <span class="n">HZ</span> <span class="o">*</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">fc_ratov</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">));</span>
	<span class="p">}</span>


	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_sli_ringtx_get - Get first element of the txq</span>
<span class="cm"> * @phba: Pointer to HBA context object.</span>
<span class="cm"> * @pring: Pointer to driver SLI ring object.</span>
<span class="cm"> *</span>
<span class="cm"> * This function is called with hbalock held to get next</span>
<span class="cm"> * iocb in txq of the given ring. If there is any iocb in</span>
<span class="cm"> * the txq, the function returns first iocb in the list after</span>
<span class="cm"> * removing the iocb from the list, else it returns NULL.</span>
<span class="cm"> **/</span>
<span class="k">struct</span> <span class="n">lpfc_iocbq</span> <span class="o">*</span>
<span class="nf">lpfc_sli_ringtx_get</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">,</span> <span class="k">struct</span> <span class="n">lpfc_sli_ring</span> <span class="o">*</span><span class="n">pring</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpfc_iocbq</span> <span class="o">*</span><span class="n">cmd_iocb</span><span class="p">;</span>

	<span class="n">list_remove_head</span><span class="p">((</span><span class="o">&amp;</span><span class="n">pring</span><span class="o">-&gt;</span><span class="n">txq</span><span class="p">),</span> <span class="n">cmd_iocb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">lpfc_iocbq</span><span class="p">,</span> <span class="n">list</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cmd_iocb</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="n">pring</span><span class="o">-&gt;</span><span class="n">txq_cnt</span><span class="o">--</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">cmd_iocb</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_sli_next_iocb_slot - Get next iocb slot in the ring</span>
<span class="cm"> * @phba: Pointer to HBA context object.</span>
<span class="cm"> * @pring: Pointer to driver SLI ring object.</span>
<span class="cm"> *</span>
<span class="cm"> * This function is called with hbalock held and the caller must post the</span>
<span class="cm"> * iocb without releasing the lock. If the caller releases the lock,</span>
<span class="cm"> * iocb slot returned by the function is not guaranteed to be available.</span>
<span class="cm"> * The function returns pointer to the next available iocb slot if there</span>
<span class="cm"> * is available slot in the ring, else it returns NULL.</span>
<span class="cm"> * If the get index of the ring is ahead of the put index, the function</span>
<span class="cm"> * will post an error attention event to the worker thread to take the</span>
<span class="cm"> * HBA to offline state.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="n">IOCB_t</span> <span class="o">*</span>
<span class="nf">lpfc_sli_next_iocb_slot</span> <span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">,</span> <span class="k">struct</span> <span class="n">lpfc_sli_ring</span> <span class="o">*</span><span class="n">pring</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpfc_pgp</span> <span class="o">*</span><span class="n">pgp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">port_gp</span><span class="p">[</span><span class="n">pring</span><span class="o">-&gt;</span><span class="n">ringno</span><span class="p">];</span>
	<span class="kt">uint32_t</span>  <span class="n">max_cmd_idx</span> <span class="o">=</span> <span class="n">pring</span><span class="o">-&gt;</span><span class="n">numCiocb</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">pring</span><span class="o">-&gt;</span><span class="n">next_cmdidx</span> <span class="o">==</span> <span class="n">pring</span><span class="o">-&gt;</span><span class="n">cmdidx</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	   <span class="p">(</span><span class="o">++</span><span class="n">pring</span><span class="o">-&gt;</span><span class="n">next_cmdidx</span> <span class="o">&gt;=</span> <span class="n">max_cmd_idx</span><span class="p">))</span>
		<span class="n">pring</span><span class="o">-&gt;</span><span class="n">next_cmdidx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">pring</span><span class="o">-&gt;</span><span class="n">local_getidx</span> <span class="o">==</span> <span class="n">pring</span><span class="o">-&gt;</span><span class="n">next_cmdidx</span><span class="p">))</span> <span class="p">{</span>

		<span class="n">pring</span><span class="o">-&gt;</span><span class="n">local_getidx</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">pgp</span><span class="o">-&gt;</span><span class="n">cmdGetInx</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">pring</span><span class="o">-&gt;</span><span class="n">local_getidx</span> <span class="o">&gt;=</span> <span class="n">max_cmd_idx</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_SLI</span><span class="p">,</span>
					<span class="s">&quot;0315 Ring %d issue: portCmdGet %d &quot;</span>
					<span class="s">&quot;is bigger than cmd ring %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">pring</span><span class="o">-&gt;</span><span class="n">ringno</span><span class="p">,</span>
					<span class="n">pring</span><span class="o">-&gt;</span><span class="n">local_getidx</span><span class="p">,</span> <span class="n">max_cmd_idx</span><span class="p">);</span>

			<span class="n">phba</span><span class="o">-&gt;</span><span class="n">link_state</span> <span class="o">=</span> <span class="n">LPFC_HBA_ERROR</span><span class="p">;</span>
			<span class="cm">/*</span>
<span class="cm">			 * All error attention handlers are posted to</span>
<span class="cm">			 * worker thread</span>
<span class="cm">			 */</span>
			<span class="n">phba</span><span class="o">-&gt;</span><span class="n">work_ha</span> <span class="o">|=</span> <span class="n">HA_ERATT</span><span class="p">;</span>
			<span class="n">phba</span><span class="o">-&gt;</span><span class="n">work_hs</span> <span class="o">=</span> <span class="n">HS_FFER3</span><span class="p">;</span>

			<span class="n">lpfc_worker_wake_up</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>

			<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">pring</span><span class="o">-&gt;</span><span class="n">local_getidx</span> <span class="o">==</span> <span class="n">pring</span><span class="o">-&gt;</span><span class="n">next_cmdidx</span><span class="p">)</span>
			<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">lpfc_cmd_iocb</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">pring</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_sli_next_iotag - Get an iotag for the iocb</span>
<span class="cm"> * @phba: Pointer to HBA context object.</span>
<span class="cm"> * @iocbq: Pointer to driver iocb object.</span>
<span class="cm"> *</span>
<span class="cm"> * This function gets an iotag for the iocb. If there is no unused iotag and</span>
<span class="cm"> * the iocbq_lookup_len &lt; 0xffff, this function allocates a bigger iotag_lookup</span>
<span class="cm"> * array and assigns a new iotag.</span>
<span class="cm"> * The function returns the allocated iotag if successful, else returns zero.</span>
<span class="cm"> * Zero is not a valid iotag.</span>
<span class="cm"> * The caller is not required to hold any lock.</span>
<span class="cm"> **/</span>
<span class="kt">uint16_t</span>
<span class="nf">lpfc_sli_next_iotag</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">,</span> <span class="k">struct</span> <span class="n">lpfc_iocbq</span> <span class="o">*</span><span class="n">iocbq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpfc_iocbq</span> <span class="o">**</span><span class="n">new_arr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_iocbq</span> <span class="o">**</span><span class="n">old_arr</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">new_len</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_sli</span> <span class="o">*</span><span class="n">psli</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli</span><span class="p">;</span>
	<span class="kt">uint16_t</span> <span class="n">iotag</span><span class="p">;</span>

	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>
	<span class="n">iotag</span> <span class="o">=</span> <span class="n">psli</span><span class="o">-&gt;</span><span class="n">last_iotag</span><span class="p">;</span>
	<span class="k">if</span><span class="p">(</span><span class="o">++</span><span class="n">iotag</span> <span class="o">&lt;</span> <span class="n">psli</span><span class="o">-&gt;</span><span class="n">iocbq_lookup_len</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">psli</span><span class="o">-&gt;</span><span class="n">last_iotag</span> <span class="o">=</span> <span class="n">iotag</span><span class="p">;</span>
		<span class="n">psli</span><span class="o">-&gt;</span><span class="n">iocbq_lookup</span><span class="p">[</span><span class="n">iotag</span><span class="p">]</span> <span class="o">=</span> <span class="n">iocbq</span><span class="p">;</span>
		<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>
		<span class="n">iocbq</span><span class="o">-&gt;</span><span class="n">iotag</span> <span class="o">=</span> <span class="n">iotag</span><span class="p">;</span>
		<span class="k">return</span> <span class="n">iotag</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">psli</span><span class="o">-&gt;</span><span class="n">iocbq_lookup_len</span> <span class="o">&lt;</span> <span class="p">(</span><span class="mh">0xffff</span>
					   <span class="o">-</span> <span class="n">LPFC_IOCBQ_LOOKUP_INCREMENT</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">new_len</span> <span class="o">=</span> <span class="n">psli</span><span class="o">-&gt;</span><span class="n">iocbq_lookup_len</span> <span class="o">+</span> <span class="n">LPFC_IOCBQ_LOOKUP_INCREMENT</span><span class="p">;</span>
		<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>
		<span class="n">new_arr</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="n">new_len</span> <span class="o">*</span> <span class="k">sizeof</span> <span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_iocbq</span> <span class="o">*</span><span class="p">),</span>
				  <span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">new_arr</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>
			<span class="n">old_arr</span> <span class="o">=</span> <span class="n">psli</span><span class="o">-&gt;</span><span class="n">iocbq_lookup</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">new_len</span> <span class="o">&lt;=</span> <span class="n">psli</span><span class="o">-&gt;</span><span class="n">iocbq_lookup_len</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/* highly unprobable case */</span>
				<span class="n">kfree</span><span class="p">(</span><span class="n">new_arr</span><span class="p">);</span>
				<span class="n">iotag</span> <span class="o">=</span> <span class="n">psli</span><span class="o">-&gt;</span><span class="n">last_iotag</span><span class="p">;</span>
				<span class="k">if</span><span class="p">(</span><span class="o">++</span><span class="n">iotag</span> <span class="o">&lt;</span> <span class="n">psli</span><span class="o">-&gt;</span><span class="n">iocbq_lookup_len</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">psli</span><span class="o">-&gt;</span><span class="n">last_iotag</span> <span class="o">=</span> <span class="n">iotag</span><span class="p">;</span>
					<span class="n">psli</span><span class="o">-&gt;</span><span class="n">iocbq_lookup</span><span class="p">[</span><span class="n">iotag</span><span class="p">]</span> <span class="o">=</span> <span class="n">iocbq</span><span class="p">;</span>
					<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>
					<span class="n">iocbq</span><span class="o">-&gt;</span><span class="n">iotag</span> <span class="o">=</span> <span class="n">iotag</span><span class="p">;</span>
					<span class="k">return</span> <span class="n">iotag</span><span class="p">;</span>
				<span class="p">}</span>
				<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>
				<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">psli</span><span class="o">-&gt;</span><span class="n">iocbq_lookup</span><span class="p">)</span>
				<span class="n">memcpy</span><span class="p">(</span><span class="n">new_arr</span><span class="p">,</span> <span class="n">old_arr</span><span class="p">,</span>
				       <span class="p">((</span><span class="n">psli</span><span class="o">-&gt;</span><span class="n">last_iotag</span>  <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span>
					<span class="k">sizeof</span> <span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_iocbq</span> <span class="o">*</span><span class="p">)));</span>
			<span class="n">psli</span><span class="o">-&gt;</span><span class="n">iocbq_lookup</span> <span class="o">=</span> <span class="n">new_arr</span><span class="p">;</span>
			<span class="n">psli</span><span class="o">-&gt;</span><span class="n">iocbq_lookup_len</span> <span class="o">=</span> <span class="n">new_len</span><span class="p">;</span>
			<span class="n">psli</span><span class="o">-&gt;</span><span class="n">last_iotag</span> <span class="o">=</span> <span class="n">iotag</span><span class="p">;</span>
			<span class="n">psli</span><span class="o">-&gt;</span><span class="n">iocbq_lookup</span><span class="p">[</span><span class="n">iotag</span><span class="p">]</span> <span class="o">=</span> <span class="n">iocbq</span><span class="p">;</span>
			<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>
			<span class="n">iocbq</span><span class="o">-&gt;</span><span class="n">iotag</span> <span class="o">=</span> <span class="n">iotag</span><span class="p">;</span>
			<span class="n">kfree</span><span class="p">(</span><span class="n">old_arr</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">iotag</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>

	<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_WARNING</span><span class="p">,</span> <span class="n">LOG_SLI</span><span class="p">,</span>
			<span class="s">&quot;0318 Failed to allocate IOTAG.last IOTAG is %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">psli</span><span class="o">-&gt;</span><span class="n">last_iotag</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_sli_submit_iocb - Submit an iocb to the firmware</span>
<span class="cm"> * @phba: Pointer to HBA context object.</span>
<span class="cm"> * @pring: Pointer to driver SLI ring object.</span>
<span class="cm"> * @iocb: Pointer to iocb slot in the ring.</span>
<span class="cm"> * @nextiocb: Pointer to driver iocb object which need to be</span>
<span class="cm"> *            posted to firmware.</span>
<span class="cm"> *</span>
<span class="cm"> * This function is called with hbalock held to post a new iocb to</span>
<span class="cm"> * the firmware. This function copies the new iocb to ring iocb slot and</span>
<span class="cm"> * updates the ring pointers. It adds the new iocb to txcmplq if there is</span>
<span class="cm"> * a completion call back for this iocb else the function will free the</span>
<span class="cm"> * iocb object.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">lpfc_sli_submit_iocb</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">,</span> <span class="k">struct</span> <span class="n">lpfc_sli_ring</span> <span class="o">*</span><span class="n">pring</span><span class="p">,</span>
		<span class="n">IOCB_t</span> <span class="o">*</span><span class="n">iocb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">lpfc_iocbq</span> <span class="o">*</span><span class="n">nextiocb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * Set up an iotag</span>
<span class="cm">	 */</span>
	<span class="n">nextiocb</span><span class="o">-&gt;</span><span class="n">iocb</span><span class="p">.</span><span class="n">ulpIoTag</span> <span class="o">=</span> <span class="p">(</span><span class="n">nextiocb</span><span class="o">-&gt;</span><span class="n">iocb_cmpl</span><span class="p">)</span> <span class="o">?</span> <span class="n">nextiocb</span><span class="o">-&gt;</span><span class="n">iotag</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>


	<span class="k">if</span> <span class="p">(</span><span class="n">pring</span><span class="o">-&gt;</span><span class="n">ringno</span> <span class="o">==</span> <span class="n">LPFC_ELS_RING</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lpfc_debugfs_slow_ring_trc</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span>
			<span class="s">&quot;IOCB cmd ring:   wd4:x%08x wd6:x%08x wd7:x%08x&quot;</span><span class="p">,</span>
			<span class="o">*</span><span class="p">(((</span><span class="kt">uint32_t</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">nextiocb</span><span class="o">-&gt;</span><span class="n">iocb</span><span class="p">)</span> <span class="o">+</span> <span class="mi">4</span><span class="p">),</span>
			<span class="o">*</span><span class="p">(((</span><span class="kt">uint32_t</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">nextiocb</span><span class="o">-&gt;</span><span class="n">iocb</span><span class="p">)</span> <span class="o">+</span> <span class="mi">6</span><span class="p">),</span>
			<span class="o">*</span><span class="p">(((</span><span class="kt">uint32_t</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">nextiocb</span><span class="o">-&gt;</span><span class="n">iocb</span><span class="p">)</span> <span class="o">+</span> <span class="mi">7</span><span class="p">));</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Issue iocb command to adapter</span>
<span class="cm">	 */</span>
	<span class="n">lpfc_sli_pcimem_bcopy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nextiocb</span><span class="o">-&gt;</span><span class="n">iocb</span><span class="p">,</span> <span class="n">iocb</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">iocb_cmd_size</span><span class="p">);</span>
	<span class="n">wmb</span><span class="p">();</span>
	<span class="n">pring</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">iocb_cmd</span><span class="o">++</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * If there is no completion routine to call, we can release the</span>
<span class="cm">	 * IOCB buffer back right now. For IOCBs, like QUE_RING_BUF,</span>
<span class="cm">	 * that have no rsp ring completion, iocb_cmpl MUST be NULL.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nextiocb</span><span class="o">-&gt;</span><span class="n">iocb_cmpl</span><span class="p">)</span>
		<span class="n">lpfc_sli_ringtxcmpl_put</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">pring</span><span class="p">,</span> <span class="n">nextiocb</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">__lpfc_sli_release_iocbq</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">nextiocb</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Let the HBA know what IOCB slot will be the next one the</span>
<span class="cm">	 * driver will put a command into.</span>
<span class="cm">	 */</span>
	<span class="n">pring</span><span class="o">-&gt;</span><span class="n">cmdidx</span> <span class="o">=</span> <span class="n">pring</span><span class="o">-&gt;</span><span class="n">next_cmdidx</span><span class="p">;</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">pring</span><span class="o">-&gt;</span><span class="n">cmdidx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">host_gp</span><span class="p">[</span><span class="n">pring</span><span class="o">-&gt;</span><span class="n">ringno</span><span class="p">].</span><span class="n">cmdPutInx</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_sli_update_full_ring - Update the chip attention register</span>
<span class="cm"> * @phba: Pointer to HBA context object.</span>
<span class="cm"> * @pring: Pointer to driver SLI ring object.</span>
<span class="cm"> *</span>
<span class="cm"> * The caller is not required to hold any lock for calling this function.</span>
<span class="cm"> * This function updates the chip attention bits for the ring to inform firmware</span>
<span class="cm"> * that there are pending work to be done for this ring and requests an</span>
<span class="cm"> * interrupt when there is space available in the ring. This function is</span>
<span class="cm"> * called when the driver is unable to post more iocbs to the ring due</span>
<span class="cm"> * to unavailability of space in the ring.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">lpfc_sli_update_full_ring</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">,</span> <span class="k">struct</span> <span class="n">lpfc_sli_ring</span> <span class="o">*</span><span class="n">pring</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ringno</span> <span class="o">=</span> <span class="n">pring</span><span class="o">-&gt;</span><span class="n">ringno</span><span class="p">;</span>

	<span class="n">pring</span><span class="o">-&gt;</span><span class="n">flag</span> <span class="o">|=</span> <span class="n">LPFC_CALL_RING_AVAILABLE</span><span class="p">;</span>

	<span class="n">wmb</span><span class="p">();</span>

	<span class="cm">/*</span>
<span class="cm">	 * Set ring &#39;ringno&#39; to SET R0CE_REQ in Chip Att register.</span>
<span class="cm">	 * The HBA will tell us when an IOCB entry is available.</span>
<span class="cm">	 */</span>
	<span class="n">writel</span><span class="p">((</span><span class="n">CA_R0ATT</span><span class="o">|</span><span class="n">CA_R0CE_REQ</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">ringno</span><span class="o">*</span><span class="mi">4</span><span class="p">),</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">CAregaddr</span><span class="p">);</span>
	<span class="n">readl</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">CAregaddr</span><span class="p">);</span> <span class="cm">/* flush */</span>

	<span class="n">pring</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">iocb_cmd_full</span><span class="o">++</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_sli_update_ring - Update chip attention register</span>
<span class="cm"> * @phba: Pointer to HBA context object.</span>
<span class="cm"> * @pring: Pointer to driver SLI ring object.</span>
<span class="cm"> *</span>
<span class="cm"> * This function updates the chip attention register bit for the</span>
<span class="cm"> * given ring to inform HBA that there is more work to be done</span>
<span class="cm"> * in this ring. The caller is not required to hold any lock.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">lpfc_sli_update_ring</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">,</span> <span class="k">struct</span> <span class="n">lpfc_sli_ring</span> <span class="o">*</span><span class="n">pring</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ringno</span> <span class="o">=</span> <span class="n">pring</span><span class="o">-&gt;</span><span class="n">ringno</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Tell the HBA that there is work to do in this ring.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli3_options</span> <span class="o">&amp;</span> <span class="n">LPFC_SLI3_CRP_ENABLED</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">wmb</span><span class="p">();</span>
		<span class="n">writel</span><span class="p">(</span><span class="n">CA_R0ATT</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">ringno</span> <span class="o">*</span> <span class="mi">4</span><span class="p">),</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">CAregaddr</span><span class="p">);</span>
		<span class="n">readl</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">CAregaddr</span><span class="p">);</span> <span class="cm">/* flush */</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_sli_resume_iocb - Process iocbs in the txq</span>
<span class="cm"> * @phba: Pointer to HBA context object.</span>
<span class="cm"> * @pring: Pointer to driver SLI ring object.</span>
<span class="cm"> *</span>
<span class="cm"> * This function is called with hbalock held to post pending iocbs</span>
<span class="cm"> * in the txq to the firmware. This function is called when driver</span>
<span class="cm"> * detects space available in the ring.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">lpfc_sli_resume_iocb</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">,</span> <span class="k">struct</span> <span class="n">lpfc_sli_ring</span> <span class="o">*</span><span class="n">pring</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">IOCB_t</span> <span class="o">*</span><span class="n">iocb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_iocbq</span> <span class="o">*</span><span class="n">nextiocb</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Check to see if:</span>
<span class="cm">	 *  (a) there is anything on the txq to send</span>
<span class="cm">	 *  (b) link is up</span>
<span class="cm">	 *  (c) link attention events can be processed (fcp ring only)</span>
<span class="cm">	 *  (d) IOCB processing is not blocked by the outstanding mbox command.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pring</span><span class="o">-&gt;</span><span class="n">txq_cnt</span> <span class="o">&amp;&amp;</span>
	    <span class="n">lpfc_is_link_up</span><span class="p">(</span><span class="n">phba</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">pring</span><span class="o">-&gt;</span><span class="n">ringno</span> <span class="o">!=</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli</span><span class="p">.</span><span class="n">fcp_ring</span> <span class="o">||</span>
	     <span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli</span><span class="p">.</span><span class="n">sli_flag</span> <span class="o">&amp;</span> <span class="n">LPFC_PROCESS_LA</span><span class="p">))</span> <span class="p">{</span>

		<span class="k">while</span> <span class="p">((</span><span class="n">iocb</span> <span class="o">=</span> <span class="n">lpfc_sli_next_iocb_slot</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">pring</span><span class="p">))</span> <span class="o">&amp;&amp;</span>
		       <span class="p">(</span><span class="n">nextiocb</span> <span class="o">=</span> <span class="n">lpfc_sli_ringtx_get</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">pring</span><span class="p">)))</span>
			<span class="n">lpfc_sli_submit_iocb</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">pring</span><span class="p">,</span> <span class="n">iocb</span><span class="p">,</span> <span class="n">nextiocb</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">iocb</span><span class="p">)</span>
			<span class="n">lpfc_sli_update_ring</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">pring</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">lpfc_sli_update_full_ring</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">pring</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_sli_next_hbq_slot - Get next hbq entry for the HBQ</span>
<span class="cm"> * @phba: Pointer to HBA context object.</span>
<span class="cm"> * @hbqno: HBQ number.</span>
<span class="cm"> *</span>
<span class="cm"> * This function is called with hbalock held to get the next</span>
<span class="cm"> * available slot for the given HBQ. If there is free slot</span>
<span class="cm"> * available for the HBQ it will return pointer to the next available</span>
<span class="cm"> * HBQ entry else it will return NULL.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">lpfc_hbq_entry</span> <span class="o">*</span>
<span class="nf">lpfc_sli_next_hbq_slot</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">hbqno</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">hbq_s</span> <span class="o">*</span><span class="n">hbqp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbqs</span><span class="p">[</span><span class="n">hbqno</span><span class="p">];</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">hbqp</span><span class="o">-&gt;</span><span class="n">next_hbqPutIdx</span> <span class="o">==</span> <span class="n">hbqp</span><span class="o">-&gt;</span><span class="n">hbqPutIdx</span> <span class="o">&amp;&amp;</span>
	    <span class="o">++</span><span class="n">hbqp</span><span class="o">-&gt;</span><span class="n">next_hbqPutIdx</span> <span class="o">&gt;=</span> <span class="n">hbqp</span><span class="o">-&gt;</span><span class="n">entry_count</span><span class="p">)</span>
		<span class="n">hbqp</span><span class="o">-&gt;</span><span class="n">next_hbqPutIdx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">hbqp</span><span class="o">-&gt;</span><span class="n">local_hbqGetIdx</span> <span class="o">==</span> <span class="n">hbqp</span><span class="o">-&gt;</span><span class="n">next_hbqPutIdx</span><span class="p">))</span> <span class="p">{</span>
		<span class="kt">uint32_t</span> <span class="n">raw_index</span> <span class="o">=</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbq_get</span><span class="p">[</span><span class="n">hbqno</span><span class="p">];</span>
		<span class="kt">uint32_t</span> <span class="n">getidx</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">raw_index</span><span class="p">);</span>

		<span class="n">hbqp</span><span class="o">-&gt;</span><span class="n">local_hbqGetIdx</span> <span class="o">=</span> <span class="n">getidx</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">hbqp</span><span class="o">-&gt;</span><span class="n">local_hbqGetIdx</span> <span class="o">&gt;=</span> <span class="n">hbqp</span><span class="o">-&gt;</span><span class="n">entry_count</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span>
					<span class="n">LOG_SLI</span> <span class="o">|</span> <span class="n">LOG_VPORT</span><span class="p">,</span>
					<span class="s">&quot;1802 HBQ %d: local_hbqGetIdx &quot;</span>
					<span class="s">&quot;%u is &gt; than hbqp-&gt;entry_count %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">hbqno</span><span class="p">,</span> <span class="n">hbqp</span><span class="o">-&gt;</span><span class="n">local_hbqGetIdx</span><span class="p">,</span>
					<span class="n">hbqp</span><span class="o">-&gt;</span><span class="n">entry_count</span><span class="p">);</span>

			<span class="n">phba</span><span class="o">-&gt;</span><span class="n">link_state</span> <span class="o">=</span> <span class="n">LPFC_HBA_ERROR</span><span class="p">;</span>
			<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">hbqp</span><span class="o">-&gt;</span><span class="n">local_hbqGetIdx</span> <span class="o">==</span> <span class="n">hbqp</span><span class="o">-&gt;</span><span class="n">next_hbqPutIdx</span><span class="p">)</span>
			<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hbq_entry</span> <span class="o">*</span><span class="p">)</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbqs</span><span class="p">[</span><span class="n">hbqno</span><span class="p">].</span><span class="n">hbq_virt</span> <span class="o">+</span>
			<span class="n">hbqp</span><span class="o">-&gt;</span><span class="n">hbqPutIdx</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_sli_hbqbuf_free_all - Free all the hbq buffers</span>
<span class="cm"> * @phba: Pointer to HBA context object.</span>
<span class="cm"> *</span>
<span class="cm"> * This function is called with no lock held to free all the</span>
<span class="cm"> * hbq buffers while uninitializing the SLI interface. It also</span>
<span class="cm"> * frees the HBQ buffers returned by the firmware but not yet</span>
<span class="cm"> * processed by the upper layers.</span>
<span class="cm"> **/</span>
<span class="kt">void</span>
<span class="nf">lpfc_sli_hbqbuf_free_all</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpfc_dmabuf</span> <span class="o">*</span><span class="n">dmabuf</span><span class="p">,</span> <span class="o">*</span><span class="n">next_dmabuf</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hbq_dmabuf</span> <span class="o">*</span><span class="n">hbq_buf</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">hbq_count</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">hbqno</span><span class="p">;</span>

	<span class="n">hbq_count</span> <span class="o">=</span> <span class="n">lpfc_sli_hbq_count</span><span class="p">();</span>
	<span class="cm">/* Return all memory used by all HBQs */</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">hbq_count</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">dmabuf</span><span class="p">,</span> <span class="n">next_dmabuf</span><span class="p">,</span>
				<span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbqs</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">hbq_buffer_list</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">hbq_buf</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">dmabuf</span><span class="p">,</span> <span class="k">struct</span> <span class="n">hbq_dmabuf</span><span class="p">,</span> <span class="n">dbuf</span><span class="p">);</span>
			<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hbq_buf</span><span class="o">-&gt;</span><span class="n">dbuf</span><span class="p">.</span><span class="n">list</span><span class="p">);</span>
			<span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbqs</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">hbq_free_buffer</span><span class="p">)(</span><span class="n">phba</span><span class="p">,</span> <span class="n">hbq_buf</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbqs</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">buffer_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* Return all HBQ buffer that are in-fly */</span>
	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">dmabuf</span><span class="p">,</span> <span class="n">next_dmabuf</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">rb_pend_list</span><span class="p">,</span>
				 <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">hbq_buf</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">dmabuf</span><span class="p">,</span> <span class="k">struct</span> <span class="n">hbq_dmabuf</span><span class="p">,</span> <span class="n">dbuf</span><span class="p">);</span>
		<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hbq_buf</span><span class="o">-&gt;</span><span class="n">dbuf</span><span class="p">.</span><span class="n">list</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">hbq_buf</span><span class="o">-&gt;</span><span class="n">tag</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
			<span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbqs</span><span class="p">[</span><span class="n">LPFC_ELS_HBQ</span><span class="p">].</span><span class="n">hbq_free_buffer</span><span class="p">)</span>
				<span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">hbq_buf</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">hbqno</span> <span class="o">=</span> <span class="n">hbq_buf</span><span class="o">-&gt;</span><span class="n">tag</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">hbqno</span> <span class="o">&gt;=</span> <span class="n">LPFC_MAX_HBQS</span><span class="p">)</span>
				<span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbqs</span><span class="p">[</span><span class="n">LPFC_ELS_HBQ</span><span class="p">].</span><span class="n">hbq_free_buffer</span><span class="p">)</span>
					<span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">hbq_buf</span><span class="p">);</span>
			<span class="k">else</span>
				<span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbqs</span><span class="p">[</span><span class="n">hbqno</span><span class="p">].</span><span class="n">hbq_free_buffer</span><span class="p">)(</span><span class="n">phba</span><span class="p">,</span>
					<span class="n">hbq_buf</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* Mark the HBQs not in use */</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbq_in_use</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_sli_hbq_to_firmware - Post the hbq buffer to firmware</span>
<span class="cm"> * @phba: Pointer to HBA context object.</span>
<span class="cm"> * @hbqno: HBQ number.</span>
<span class="cm"> * @hbq_buf: Pointer to HBQ buffer.</span>
<span class="cm"> *</span>
<span class="cm"> * This function is called with the hbalock held to post a</span>
<span class="cm"> * hbq buffer to the firmware. If the function finds an empty</span>
<span class="cm"> * slot in the HBQ, it will post the buffer. The function will return</span>
<span class="cm"> * pointer to the hbq entry if it successfully post the buffer</span>
<span class="cm"> * else it will return NULL.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">lpfc_sli_hbq_to_firmware</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">hbqno</span><span class="p">,</span>
			 <span class="k">struct</span> <span class="n">hbq_dmabuf</span> <span class="o">*</span><span class="n">hbq_buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">lpfc_sli_hbq_to_firmware</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">hbqno</span><span class="p">,</span> <span class="n">hbq_buf</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_sli_hbq_to_firmware_s3 - Post the hbq buffer to SLI3 firmware</span>
<span class="cm"> * @phba: Pointer to HBA context object.</span>
<span class="cm"> * @hbqno: HBQ number.</span>
<span class="cm"> * @hbq_buf: Pointer to HBQ buffer.</span>
<span class="cm"> *</span>
<span class="cm"> * This function is called with the hbalock held to post a hbq buffer to the</span>
<span class="cm"> * firmware. If the function finds an empty slot in the HBQ, it will post the</span>
<span class="cm"> * buffer and place it on the hbq_buffer_list. The function will return zero if</span>
<span class="cm"> * it successfully post the buffer else it will return an error.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">lpfc_sli_hbq_to_firmware_s3</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">hbqno</span><span class="p">,</span>
			    <span class="k">struct</span> <span class="n">hbq_dmabuf</span> <span class="o">*</span><span class="n">hbq_buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpfc_hbq_entry</span> <span class="o">*</span><span class="n">hbqe</span><span class="p">;</span>
	<span class="n">dma_addr_t</span> <span class="n">physaddr</span> <span class="o">=</span> <span class="n">hbq_buf</span><span class="o">-&gt;</span><span class="n">dbuf</span><span class="p">.</span><span class="n">phys</span><span class="p">;</span>

	<span class="cm">/* Get next HBQ entry slot to use */</span>
	<span class="n">hbqe</span> <span class="o">=</span> <span class="n">lpfc_sli_next_hbq_slot</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">hbqno</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hbqe</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">hbq_s</span> <span class="o">*</span><span class="n">hbqp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbqs</span><span class="p">[</span><span class="n">hbqno</span><span class="p">];</span>

		<span class="n">hbqe</span><span class="o">-&gt;</span><span class="n">bde</span><span class="p">.</span><span class="n">addrHigh</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">putPaddrHigh</span><span class="p">(</span><span class="n">physaddr</span><span class="p">));</span>
		<span class="n">hbqe</span><span class="o">-&gt;</span><span class="n">bde</span><span class="p">.</span><span class="n">addrLow</span>  <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">putPaddrLow</span><span class="p">(</span><span class="n">physaddr</span><span class="p">));</span>
		<span class="n">hbqe</span><span class="o">-&gt;</span><span class="n">bde</span><span class="p">.</span><span class="n">tus</span><span class="p">.</span><span class="n">f</span><span class="p">.</span><span class="n">bdeSize</span> <span class="o">=</span> <span class="n">hbq_buf</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">;</span>
		<span class="n">hbqe</span><span class="o">-&gt;</span><span class="n">bde</span><span class="p">.</span><span class="n">tus</span><span class="p">.</span><span class="n">f</span><span class="p">.</span><span class="n">bdeFlags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">hbqe</span><span class="o">-&gt;</span><span class="n">bde</span><span class="p">.</span><span class="n">tus</span><span class="p">.</span><span class="n">w</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">hbqe</span><span class="o">-&gt;</span><span class="n">bde</span><span class="p">.</span><span class="n">tus</span><span class="p">.</span><span class="n">w</span><span class="p">);</span>
		<span class="n">hbqe</span><span class="o">-&gt;</span><span class="n">buffer_tag</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">hbq_buf</span><span class="o">-&gt;</span><span class="n">tag</span><span class="p">);</span>
				<span class="cm">/* Sync SLIM */</span>
		<span class="n">hbqp</span><span class="o">-&gt;</span><span class="n">hbqPutIdx</span> <span class="o">=</span> <span class="n">hbqp</span><span class="o">-&gt;</span><span class="n">next_hbqPutIdx</span><span class="p">;</span>
		<span class="n">writel</span><span class="p">(</span><span class="n">hbqp</span><span class="o">-&gt;</span><span class="n">hbqPutIdx</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbq_put</span> <span class="o">+</span> <span class="n">hbqno</span><span class="p">);</span>
				<span class="cm">/* flush */</span>
		<span class="n">readl</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbq_put</span> <span class="o">+</span> <span class="n">hbqno</span><span class="p">);</span>
		<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hbq_buf</span><span class="o">-&gt;</span><span class="n">dbuf</span><span class="p">.</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hbqp</span><span class="o">-&gt;</span><span class="n">hbq_buffer_list</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_sli_hbq_to_firmware_s4 - Post the hbq buffer to SLI4 firmware</span>
<span class="cm"> * @phba: Pointer to HBA context object.</span>
<span class="cm"> * @hbqno: HBQ number.</span>
<span class="cm"> * @hbq_buf: Pointer to HBQ buffer.</span>
<span class="cm"> *</span>
<span class="cm"> * This function is called with the hbalock held to post an RQE to the SLI4</span>
<span class="cm"> * firmware. If able to post the RQE to the RQ it will queue the hbq entry to</span>
<span class="cm"> * the hbq_buffer_list and return zero, otherwise it will return an error.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">lpfc_sli_hbq_to_firmware_s4</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">hbqno</span><span class="p">,</span>
			    <span class="k">struct</span> <span class="n">hbq_dmabuf</span> <span class="o">*</span><span class="n">hbq_buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_rqe</span> <span class="n">hrqe</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_rqe</span> <span class="n">drqe</span><span class="p">;</span>

	<span class="n">hrqe</span><span class="p">.</span><span class="n">address_lo</span> <span class="o">=</span> <span class="n">putPaddrLow</span><span class="p">(</span><span class="n">hbq_buf</span><span class="o">-&gt;</span><span class="n">hbuf</span><span class="p">.</span><span class="n">phys</span><span class="p">);</span>
	<span class="n">hrqe</span><span class="p">.</span><span class="n">address_hi</span> <span class="o">=</span> <span class="n">putPaddrHigh</span><span class="p">(</span><span class="n">hbq_buf</span><span class="o">-&gt;</span><span class="n">hbuf</span><span class="p">.</span><span class="n">phys</span><span class="p">);</span>
	<span class="n">drqe</span><span class="p">.</span><span class="n">address_lo</span> <span class="o">=</span> <span class="n">putPaddrLow</span><span class="p">(</span><span class="n">hbq_buf</span><span class="o">-&gt;</span><span class="n">dbuf</span><span class="p">.</span><span class="n">phys</span><span class="p">);</span>
	<span class="n">drqe</span><span class="p">.</span><span class="n">address_hi</span> <span class="o">=</span> <span class="n">putPaddrHigh</span><span class="p">(</span><span class="n">hbq_buf</span><span class="o">-&gt;</span><span class="n">dbuf</span><span class="p">.</span><span class="n">phys</span><span class="p">);</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">lpfc_sli4_rq_put</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">hdr_rq</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">dat_rq</span><span class="p">,</span>
			      <span class="o">&amp;</span><span class="n">hrqe</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">drqe</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
	<span class="n">hbq_buf</span><span class="o">-&gt;</span><span class="n">tag</span> <span class="o">=</span> <span class="n">rc</span><span class="p">;</span>
	<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hbq_buf</span><span class="o">-&gt;</span><span class="n">dbuf</span><span class="p">.</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbqs</span><span class="p">[</span><span class="n">hbqno</span><span class="p">].</span><span class="n">hbq_buffer_list</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* HBQ for ELS and CT traffic. */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">lpfc_hbq_init</span> <span class="n">lpfc_els_hbq</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">rn</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
	<span class="p">.</span><span class="n">entry_count</span> <span class="o">=</span> <span class="mi">256</span><span class="p">,</span>
	<span class="p">.</span><span class="n">mask_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	<span class="p">.</span><span class="n">profile</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ring_mask</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">LPFC_ELS_RING</span><span class="p">),</span>
	<span class="p">.</span><span class="n">buffer_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	<span class="p">.</span><span class="n">init_count</span> <span class="o">=</span> <span class="mi">40</span><span class="p">,</span>
	<span class="p">.</span><span class="n">add_count</span> <span class="o">=</span> <span class="mi">40</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/* HBQ for the extra ring if needed */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">lpfc_hbq_init</span> <span class="n">lpfc_extra_hbq</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">rn</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
	<span class="p">.</span><span class="n">entry_count</span> <span class="o">=</span> <span class="mi">200</span><span class="p">,</span>
	<span class="p">.</span><span class="n">mask_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	<span class="p">.</span><span class="n">profile</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ring_mask</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">LPFC_EXTRA_RING</span><span class="p">),</span>
	<span class="p">.</span><span class="n">buffer_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	<span class="p">.</span><span class="n">init_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	<span class="p">.</span><span class="n">add_count</span> <span class="o">=</span> <span class="mi">5</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/* Array of HBQs */</span>
<span class="k">struct</span> <span class="n">lpfc_hbq_init</span> <span class="o">*</span><span class="n">lpfc_hbq_defs</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="o">&amp;</span><span class="n">lpfc_els_hbq</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">lpfc_extra_hbq</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_sli_hbqbuf_fill_hbqs - Post more hbq buffers to HBQ</span>
<span class="cm"> * @phba: Pointer to HBA context object.</span>
<span class="cm"> * @hbqno: HBQ number.</span>
<span class="cm"> * @count: Number of HBQ buffers to be posted.</span>
<span class="cm"> *</span>
<span class="cm"> * This function is called with no lock held to post more hbq buffers to the</span>
<span class="cm"> * given HBQ. The function returns the number of HBQ buffers successfully</span>
<span class="cm"> * posted.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">lpfc_sli_hbqbuf_fill_hbqs</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">hbqno</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">uint32_t</span> <span class="n">i</span><span class="p">,</span> <span class="n">posted</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hbq_dmabuf</span> <span class="o">*</span><span class="n">hbq_buffer</span><span class="p">;</span>
	<span class="n">LIST_HEAD</span><span class="p">(</span><span class="n">hbq_buf_list</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbqs</span><span class="p">[</span><span class="n">hbqno</span><span class="p">].</span><span class="n">hbq_alloc_buffer</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbqs</span><span class="p">[</span><span class="n">hbqno</span><span class="p">].</span><span class="n">buffer_count</span> <span class="o">+</span> <span class="n">count</span><span class="p">)</span> <span class="o">&gt;</span>
	    <span class="n">lpfc_hbq_defs</span><span class="p">[</span><span class="n">hbqno</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">entry_count</span><span class="p">)</span>
		<span class="n">count</span> <span class="o">=</span> <span class="n">lpfc_hbq_defs</span><span class="p">[</span><span class="n">hbqno</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">entry_count</span> <span class="o">-</span>
					<span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbqs</span><span class="p">[</span><span class="n">hbqno</span><span class="p">].</span><span class="n">buffer_count</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">count</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="cm">/* Allocate HBQ entries */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">hbq_buffer</span> <span class="o">=</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbqs</span><span class="p">[</span><span class="n">hbqno</span><span class="p">].</span><span class="n">hbq_alloc_buffer</span><span class="p">)(</span><span class="n">phba</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hbq_buffer</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hbq_buffer</span><span class="o">-&gt;</span><span class="n">dbuf</span><span class="p">.</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hbq_buf_list</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="cm">/* Check whether HBQ is still in use */</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbq_in_use</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hbq_buf_list</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">list_remove_head</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hbq_buf_list</span><span class="p">,</span> <span class="n">hbq_buffer</span><span class="p">,</span> <span class="k">struct</span> <span class="n">hbq_dmabuf</span><span class="p">,</span>
				 <span class="n">dbuf</span><span class="p">.</span><span class="n">list</span><span class="p">);</span>
		<span class="n">hbq_buffer</span><span class="o">-&gt;</span><span class="n">tag</span> <span class="o">=</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbqs</span><span class="p">[</span><span class="n">hbqno</span><span class="p">].</span><span class="n">buffer_count</span> <span class="o">|</span>
				      <span class="p">(</span><span class="n">hbqno</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">lpfc_sli_hbq_to_firmware</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">hbqno</span><span class="p">,</span> <span class="n">hbq_buffer</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbqs</span><span class="p">[</span><span class="n">hbqno</span><span class="p">].</span><span class="n">buffer_count</span><span class="o">++</span><span class="p">;</span>
			<span class="n">posted</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbqs</span><span class="p">[</span><span class="n">hbqno</span><span class="p">].</span><span class="n">hbq_free_buffer</span><span class="p">)(</span><span class="n">phba</span><span class="p">,</span> <span class="n">hbq_buffer</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">posted</span><span class="p">;</span>
<span class="nl">err:</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hbq_buf_list</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">list_remove_head</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hbq_buf_list</span><span class="p">,</span> <span class="n">hbq_buffer</span><span class="p">,</span> <span class="k">struct</span> <span class="n">hbq_dmabuf</span><span class="p">,</span>
				 <span class="n">dbuf</span><span class="p">.</span><span class="n">list</span><span class="p">);</span>
		<span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbqs</span><span class="p">[</span><span class="n">hbqno</span><span class="p">].</span><span class="n">hbq_free_buffer</span><span class="p">)(</span><span class="n">phba</span><span class="p">,</span> <span class="n">hbq_buffer</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_sli_hbqbuf_add_hbqs - Post more HBQ buffers to firmware</span>
<span class="cm"> * @phba: Pointer to HBA context object.</span>
<span class="cm"> * @qno: HBQ number.</span>
<span class="cm"> *</span>
<span class="cm"> * This function posts more buffers to the HBQ. This function</span>
<span class="cm"> * is called with no lock held. The function returns the number of HBQ entries</span>
<span class="cm"> * successfully allocated.</span>
<span class="cm"> **/</span>
<span class="kt">int</span>
<span class="nf">lpfc_sli_hbqbuf_add_hbqs</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">qno</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli_rev</span> <span class="o">==</span> <span class="n">LPFC_SLI_REV4</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="k">return</span> <span class="n">lpfc_sli_hbqbuf_fill_hbqs</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">qno</span><span class="p">,</span>
					 <span class="n">lpfc_hbq_defs</span><span class="p">[</span><span class="n">qno</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">add_count</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_sli_hbqbuf_init_hbqs - Post initial buffers to the HBQ</span>
<span class="cm"> * @phba: Pointer to HBA context object.</span>
<span class="cm"> * @qno:  HBQ queue number.</span>
<span class="cm"> *</span>
<span class="cm"> * This function is called from SLI initialization code path with</span>
<span class="cm"> * no lock held to post initial HBQ buffers to firmware. The</span>
<span class="cm"> * function returns the number of HBQ entries successfully allocated.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">lpfc_sli_hbqbuf_init_hbqs</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">qno</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli_rev</span> <span class="o">==</span> <span class="n">LPFC_SLI_REV4</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">lpfc_sli_hbqbuf_fill_hbqs</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">qno</span><span class="p">,</span>
					<span class="n">lpfc_hbq_defs</span><span class="p">[</span><span class="n">qno</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">entry_count</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="k">return</span> <span class="n">lpfc_sli_hbqbuf_fill_hbqs</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">qno</span><span class="p">,</span>
					 <span class="n">lpfc_hbq_defs</span><span class="p">[</span><span class="n">qno</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">init_count</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_sli_hbqbuf_get - Remove the first hbq off of an hbq list</span>
<span class="cm"> * @phba: Pointer to HBA context object.</span>
<span class="cm"> * @hbqno: HBQ number.</span>
<span class="cm"> *</span>
<span class="cm"> * This function removes the first hbq buffer on an hbq list and returns a</span>
<span class="cm"> * pointer to that buffer. If it finds no buffers on the list it returns NULL.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">hbq_dmabuf</span> <span class="o">*</span>
<span class="nf">lpfc_sli_hbqbuf_get</span><span class="p">(</span><span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">rb_list</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpfc_dmabuf</span> <span class="o">*</span><span class="n">d_buf</span><span class="p">;</span>

	<span class="n">list_remove_head</span><span class="p">(</span><span class="n">rb_list</span><span class="p">,</span> <span class="n">d_buf</span><span class="p">,</span> <span class="k">struct</span> <span class="n">lpfc_dmabuf</span><span class="p">,</span> <span class="n">list</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">d_buf</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">container_of</span><span class="p">(</span><span class="n">d_buf</span><span class="p">,</span> <span class="k">struct</span> <span class="n">hbq_dmabuf</span><span class="p">,</span> <span class="n">dbuf</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_sli_hbqbuf_find - Find the hbq buffer associated with a tag</span>
<span class="cm"> * @phba: Pointer to HBA context object.</span>
<span class="cm"> * @tag: Tag of the hbq buffer.</span>
<span class="cm"> *</span>
<span class="cm"> * This function is called with hbalock held. This function searches</span>
<span class="cm"> * for the hbq buffer associated with the given tag in the hbq buffer</span>
<span class="cm"> * list. If it finds the hbq buffer, it returns the hbq_buffer other wise</span>
<span class="cm"> * it returns NULL.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">hbq_dmabuf</span> <span class="o">*</span>
<span class="nf">lpfc_sli_hbqbuf_find</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">tag</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpfc_dmabuf</span> <span class="o">*</span><span class="n">d_buf</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hbq_dmabuf</span> <span class="o">*</span><span class="n">hbq_buf</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">hbqno</span><span class="p">;</span>

	<span class="n">hbqno</span> <span class="o">=</span> <span class="n">tag</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hbqno</span> <span class="o">&gt;=</span> <span class="n">LPFC_MAX_HBQS</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">d_buf</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbqs</span><span class="p">[</span><span class="n">hbqno</span><span class="p">].</span><span class="n">hbq_buffer_list</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">hbq_buf</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">d_buf</span><span class="p">,</span> <span class="k">struct</span> <span class="n">hbq_dmabuf</span><span class="p">,</span> <span class="n">dbuf</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">hbq_buf</span><span class="o">-&gt;</span><span class="n">tag</span> <span class="o">==</span> <span class="n">tag</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">hbq_buf</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>
	<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_SLI</span> <span class="o">|</span> <span class="n">LOG_VPORT</span><span class="p">,</span>
			<span class="s">&quot;1803 Bad hbq tag. Data: x%x x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">tag</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbqs</span><span class="p">[</span><span class="n">tag</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">].</span><span class="n">buffer_count</span><span class="p">);</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_sli_free_hbq - Give back the hbq buffer to firmware</span>
<span class="cm"> * @phba: Pointer to HBA context object.</span>
<span class="cm"> * @hbq_buffer: Pointer to HBQ buffer.</span>
<span class="cm"> *</span>
<span class="cm"> * This function is called with hbalock. This function gives back</span>
<span class="cm"> * the hbq buffer to firmware. If the HBQ does not have space to</span>
<span class="cm"> * post the buffer, it will free the buffer.</span>
<span class="cm"> **/</span>
<span class="kt">void</span>
<span class="nf">lpfc_sli_free_hbq</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">,</span> <span class="k">struct</span> <span class="n">hbq_dmabuf</span> <span class="o">*</span><span class="n">hbq_buffer</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">uint32_t</span> <span class="n">hbqno</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">hbq_buffer</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">hbqno</span> <span class="o">=</span> <span class="n">hbq_buffer</span><span class="o">-&gt;</span><span class="n">tag</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">lpfc_sli_hbq_to_firmware</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">hbqno</span><span class="p">,</span> <span class="n">hbq_buffer</span><span class="p">))</span>
			<span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbqs</span><span class="p">[</span><span class="n">hbqno</span><span class="p">].</span><span class="n">hbq_free_buffer</span><span class="p">)(</span><span class="n">phba</span><span class="p">,</span> <span class="n">hbq_buffer</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_sli_chk_mbx_command - Check if the mailbox is a legitimate mailbox</span>
<span class="cm"> * @mbxCommand: mailbox command code.</span>
<span class="cm"> *</span>
<span class="cm"> * This function is called by the mailbox event handler function to verify</span>
<span class="cm"> * that the completed mailbox command is a legitimate mailbox command. If the</span>
<span class="cm"> * completed mailbox is not known to the function, it will return MBX_SHUTDOWN</span>
<span class="cm"> * and the mailbox event handler will take the HBA offline.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">lpfc_sli_chk_mbx_command</span><span class="p">(</span><span class="kt">uint8_t</span> <span class="n">mbxCommand</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">uint8_t</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">mbxCommand</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">MBX_LOAD_SM</span>:
	<span class="k">case</span> <span class="n">MBX_READ_NV</span>:
	<span class="k">case</span> <span class="n">MBX_WRITE_NV</span>:
	<span class="k">case</span> <span class="n">MBX_WRITE_VPARMS</span>:
	<span class="k">case</span> <span class="n">MBX_RUN_BIU_DIAG</span>:
	<span class="k">case</span> <span class="n">MBX_INIT_LINK</span>:
	<span class="k">case</span> <span class="n">MBX_DOWN_LINK</span>:
	<span class="k">case</span> <span class="n">MBX_CONFIG_LINK</span>:
	<span class="k">case</span> <span class="n">MBX_CONFIG_RING</span>:
	<span class="k">case</span> <span class="n">MBX_RESET_RING</span>:
	<span class="k">case</span> <span class="n">MBX_READ_CONFIG</span>:
	<span class="k">case</span> <span class="n">MBX_READ_RCONFIG</span>:
	<span class="k">case</span> <span class="n">MBX_READ_SPARM</span>:
	<span class="k">case</span> <span class="n">MBX_READ_STATUS</span>:
	<span class="k">case</span> <span class="n">MBX_READ_RPI</span>:
	<span class="k">case</span> <span class="n">MBX_READ_XRI</span>:
	<span class="k">case</span> <span class="n">MBX_READ_REV</span>:
	<span class="k">case</span> <span class="n">MBX_READ_LNK_STAT</span>:
	<span class="k">case</span> <span class="n">MBX_REG_LOGIN</span>:
	<span class="k">case</span> <span class="n">MBX_UNREG_LOGIN</span>:
	<span class="k">case</span> <span class="n">MBX_CLEAR_LA</span>:
	<span class="k">case</span> <span class="n">MBX_DUMP_MEMORY</span>:
	<span class="k">case</span> <span class="n">MBX_DUMP_CONTEXT</span>:
	<span class="k">case</span> <span class="n">MBX_RUN_DIAGS</span>:
	<span class="k">case</span> <span class="n">MBX_RESTART</span>:
	<span class="k">case</span> <span class="n">MBX_UPDATE_CFG</span>:
	<span class="k">case</span> <span class="n">MBX_DOWN_LOAD</span>:
	<span class="k">case</span> <span class="n">MBX_DEL_LD_ENTRY</span>:
	<span class="k">case</span> <span class="n">MBX_RUN_PROGRAM</span>:
	<span class="k">case</span> <span class="n">MBX_SET_MASK</span>:
	<span class="k">case</span> <span class="n">MBX_SET_VARIABLE</span>:
	<span class="k">case</span> <span class="n">MBX_UNREG_D_ID</span>:
	<span class="k">case</span> <span class="n">MBX_KILL_BOARD</span>:
	<span class="k">case</span> <span class="n">MBX_CONFIG_FARP</span>:
	<span class="k">case</span> <span class="n">MBX_BEACON</span>:
	<span class="k">case</span> <span class="n">MBX_LOAD_AREA</span>:
	<span class="k">case</span> <span class="n">MBX_RUN_BIU_DIAG64</span>:
	<span class="k">case</span> <span class="n">MBX_CONFIG_PORT</span>:
	<span class="k">case</span> <span class="n">MBX_READ_SPARM64</span>:
	<span class="k">case</span> <span class="n">MBX_READ_RPI64</span>:
	<span class="k">case</span> <span class="n">MBX_REG_LOGIN64</span>:
	<span class="k">case</span> <span class="n">MBX_READ_TOPOLOGY</span>:
	<span class="k">case</span> <span class="n">MBX_WRITE_WWN</span>:
	<span class="k">case</span> <span class="n">MBX_SET_DEBUG</span>:
	<span class="k">case</span> <span class="n">MBX_LOAD_EXP_ROM</span>:
	<span class="k">case</span> <span class="n">MBX_ASYNCEVT_ENABLE</span>:
	<span class="k">case</span> <span class="n">MBX_REG_VPI</span>:
	<span class="k">case</span> <span class="n">MBX_UNREG_VPI</span>:
	<span class="k">case</span> <span class="n">MBX_HEARTBEAT</span>:
	<span class="k">case</span> <span class="n">MBX_PORT_CAPABILITIES</span>:
	<span class="k">case</span> <span class="n">MBX_PORT_IOV_CONTROL</span>:
	<span class="k">case</span> <span class="n">MBX_SLI4_CONFIG</span>:
	<span class="k">case</span> <span class="n">MBX_SLI4_REQ_FTRS</span>:
	<span class="k">case</span> <span class="n">MBX_REG_FCFI</span>:
	<span class="k">case</span> <span class="n">MBX_UNREG_FCFI</span>:
	<span class="k">case</span> <span class="n">MBX_REG_VFI</span>:
	<span class="k">case</span> <span class="n">MBX_UNREG_VFI</span>:
	<span class="k">case</span> <span class="n">MBX_INIT_VPI</span>:
	<span class="k">case</span> <span class="n">MBX_INIT_VFI</span>:
	<span class="k">case</span> <span class="n">MBX_RESUME_RPI</span>:
	<span class="k">case</span> <span class="n">MBX_READ_EVENT_LOG_STATUS</span>:
	<span class="k">case</span> <span class="n">MBX_READ_EVENT_LOG</span>:
	<span class="k">case</span> <span class="n">MBX_SECURITY_MGMT</span>:
	<span class="k">case</span> <span class="n">MBX_AUTH_PORT</span>:
		<span class="n">ret</span> <span class="o">=</span> <span class="n">mbxCommand</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">MBX_SHUTDOWN</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_sli_wake_mbox_wait - lpfc_sli_issue_mbox_wait mbox completion handler</span>
<span class="cm"> * @phba: Pointer to HBA context object.</span>
<span class="cm"> * @pmboxq: Pointer to mailbox command.</span>
<span class="cm"> *</span>
<span class="cm"> * This is completion handler function for mailbox commands issued from</span>
<span class="cm"> * lpfc_sli_issue_mbox_wait function. This function is called by the</span>
<span class="cm"> * mailbox event handler function with no lock held. This function</span>
<span class="cm"> * will wake up thread waiting on the wait queue pointed by context1</span>
<span class="cm"> * of the mailbox.</span>
<span class="cm"> **/</span>
<span class="kt">void</span>
<span class="nf">lpfc_sli_wake_mbox_wait</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">,</span> <span class="n">LPFC_MBOXQ_t</span> <span class="o">*</span><span class="n">pmboxq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">wait_queue_head_t</span> <span class="o">*</span><span class="n">pdone_q</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">drvr_flag</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * If pdone_q is empty, the driver thread gave up waiting and</span>
<span class="cm">	 * continued running.</span>
<span class="cm">	 */</span>
	<span class="n">pmboxq</span><span class="o">-&gt;</span><span class="n">mbox_flag</span> <span class="o">|=</span> <span class="n">LPFC_MBX_WAKE</span><span class="p">;</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">,</span> <span class="n">drvr_flag</span><span class="p">);</span>
	<span class="n">pdone_q</span> <span class="o">=</span> <span class="p">(</span><span class="n">wait_queue_head_t</span> <span class="o">*</span><span class="p">)</span> <span class="n">pmboxq</span><span class="o">-&gt;</span><span class="n">context1</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pdone_q</span><span class="p">)</span>
		<span class="n">wake_up_interruptible</span><span class="p">(</span><span class="n">pdone_q</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">,</span> <span class="n">drvr_flag</span><span class="p">);</span>
	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/**</span>
<span class="cm"> * lpfc_sli_def_mbox_cmpl - Default mailbox completion handler</span>
<span class="cm"> * @phba: Pointer to HBA context object.</span>
<span class="cm"> * @pmb: Pointer to mailbox object.</span>
<span class="cm"> *</span>
<span class="cm"> * This function is the default mailbox completion handler. It</span>
<span class="cm"> * frees the memory resources associated with the completed mailbox</span>
<span class="cm"> * command. If the completed command is a REG_LOGIN mailbox command,</span>
<span class="cm"> * this function will issue a UREG_LOGIN to re-claim the RPI.</span>
<span class="cm"> **/</span>
<span class="kt">void</span>
<span class="nf">lpfc_sli_def_mbox_cmpl</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">,</span> <span class="n">LPFC_MBOXQ_t</span> <span class="o">*</span><span class="n">pmb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpfc_vport</span>  <span class="o">*</span><span class="n">vport</span> <span class="o">=</span> <span class="n">pmb</span><span class="o">-&gt;</span><span class="n">vport</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_dmabuf</span> <span class="o">*</span><span class="n">mp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_nodelist</span> <span class="o">*</span><span class="n">ndlp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span><span class="p">;</span>
	<span class="kt">uint16_t</span> <span class="n">rpi</span><span class="p">,</span> <span class="n">vpi</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">mp</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_dmabuf</span> <span class="o">*</span><span class="p">)</span> <span class="p">(</span><span class="n">pmb</span><span class="o">-&gt;</span><span class="n">context1</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">mp</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lpfc_mbuf_free</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">virt</span><span class="p">,</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">phys</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">mp</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * If a REG_LOGIN succeeded  after node is destroyed or node</span>
<span class="cm">	 * is in re-discovery driver need to cleanup the RPI.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">pport</span><span class="o">-&gt;</span><span class="n">load_flag</span> <span class="o">&amp;</span> <span class="n">FC_UNLOADING</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="n">pmb</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">mb</span><span class="p">.</span><span class="n">mbxCommand</span> <span class="o">==</span> <span class="n">MBX_REG_LOGIN64</span> <span class="o">&amp;&amp;</span>
	    <span class="o">!</span><span class="n">pmb</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">mb</span><span class="p">.</span><span class="n">mbxStatus</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rpi</span> <span class="o">=</span> <span class="n">pmb</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">mb</span><span class="p">.</span><span class="n">un</span><span class="p">.</span><span class="n">varWords</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
		<span class="n">vpi</span> <span class="o">=</span> <span class="n">pmb</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">mb</span><span class="p">.</span><span class="n">un</span><span class="p">.</span><span class="n">varRegLogin</span><span class="p">.</span><span class="n">vpi</span><span class="p">;</span>
		<span class="n">lpfc_unreg_login</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">vpi</span><span class="p">,</span> <span class="n">rpi</span><span class="p">,</span> <span class="n">pmb</span><span class="p">);</span>
		<span class="n">pmb</span><span class="o">-&gt;</span><span class="n">mbox_cmpl</span> <span class="o">=</span> <span class="n">lpfc_sli_def_mbox_cmpl</span><span class="p">;</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">lpfc_sli_issue_mbox</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">pmb</span><span class="p">,</span> <span class="n">MBX_NOWAIT</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">!=</span> <span class="n">MBX_NOT_FINISHED</span><span class="p">)</span>
			<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">pmb</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">mb</span><span class="p">.</span><span class="n">mbxCommand</span> <span class="o">==</span> <span class="n">MBX_REG_VPI</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		<span class="o">!</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">pport</span><span class="o">-&gt;</span><span class="n">load_flag</span> <span class="o">&amp;</span> <span class="n">FC_UNLOADING</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		<span class="o">!</span><span class="n">pmb</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">mb</span><span class="p">.</span><span class="n">mbxStatus</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">shost</span> <span class="o">=</span> <span class="n">lpfc_shost_from_vport</span><span class="p">(</span><span class="n">vport</span><span class="p">);</span>
		<span class="n">spin_lock_irq</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>
		<span class="n">vport</span><span class="o">-&gt;</span><span class="n">vpi_state</span> <span class="o">|=</span> <span class="n">LPFC_VPI_REGISTERED</span><span class="p">;</span>
		<span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_flag</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">FC_VPORT_NEEDS_REG_VPI</span><span class="p">;</span>
		<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pmb</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">mb</span><span class="p">.</span><span class="n">mbxCommand</span> <span class="o">==</span> <span class="n">MBX_REG_LOGIN64</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ndlp</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_nodelist</span> <span class="o">*</span><span class="p">)</span><span class="n">pmb</span><span class="o">-&gt;</span><span class="n">context2</span><span class="p">;</span>
		<span class="n">lpfc_nlp_put</span><span class="p">(</span><span class="n">ndlp</span><span class="p">);</span>
		<span class="n">pmb</span><span class="o">-&gt;</span><span class="n">context2</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Check security permission status on INIT_LINK mailbox command */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">pmb</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">mb</span><span class="p">.</span><span class="n">mbxCommand</span> <span class="o">==</span> <span class="n">MBX_INIT_LINK</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">pmb</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">mb</span><span class="p">.</span><span class="n">mbxStatus</span> <span class="o">==</span> <span class="n">MBXERR_SEC_NO_PERMISSION</span><span class="p">))</span>
		<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_MBOX</span> <span class="o">|</span> <span class="n">LOG_SLI</span><span class="p">,</span>
				<span class="s">&quot;2860 SLI authentication is required &quot;</span>
				<span class="s">&quot;for INIT_LINK but has not done yet</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_mqe_command</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pmb</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">mqe</span><span class="p">)</span> <span class="o">==</span> <span class="n">MBX_SLI4_CONFIG</span><span class="p">)</span>
		<span class="n">lpfc_sli4_mbox_cmd_free</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">pmb</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">mempool_free</span><span class="p">(</span><span class="n">pmb</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">mbox_mem_pool</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_sli_handle_mb_event - Handle mailbox completions from firmware</span>
<span class="cm"> * @phba: Pointer to HBA context object.</span>
<span class="cm"> *</span>
<span class="cm"> * This function is called with no lock held. This function processes all</span>
<span class="cm"> * the completed mailbox commands and gives it to upper layers. The interrupt</span>
<span class="cm"> * service routine processes mailbox completion interrupt and adds completed</span>
<span class="cm"> * mailbox commands to the mboxq_cmpl queue and signals the worker thread.</span>
<span class="cm"> * Worker thread call lpfc_sli_handle_mb_event, which will return the</span>
<span class="cm"> * completed mailbox commands in mboxq_cmpl queue to the upper layers. This</span>
<span class="cm"> * function returns the mailbox commands to the upper layer by calling the</span>
<span class="cm"> * completion handler function of each mailbox.</span>
<span class="cm"> **/</span>
<span class="kt">int</span>
<span class="nf">lpfc_sli_handle_mb_event</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">MAILBOX_t</span> <span class="o">*</span><span class="n">pmbox</span><span class="p">;</span>
	<span class="n">LPFC_MBOXQ_t</span> <span class="o">*</span><span class="n">pmb</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>
	<span class="n">LIST_HEAD</span><span class="p">(</span><span class="n">cmplq</span><span class="p">);</span>

	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli</span><span class="p">.</span><span class="n">slistat</span><span class="p">.</span><span class="n">mbox_event</span><span class="o">++</span><span class="p">;</span>

	<span class="cm">/* Get all completed mailboxe buffers into the cmplq */</span>
	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>
	<span class="n">list_splice_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli</span><span class="p">.</span><span class="n">mboxq_cmpl</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cmplq</span><span class="p">);</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>

	<span class="cm">/* Get a Mailbox buffer to setup mailbox commands for callback */</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="n">list_remove_head</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmplq</span><span class="p">,</span> <span class="n">pmb</span><span class="p">,</span> <span class="n">LPFC_MBOXQ_t</span><span class="p">,</span> <span class="n">list</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pmb</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="n">pmbox</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">pmb</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">mb</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">pmbox</span><span class="o">-&gt;</span><span class="n">mbxCommand</span> <span class="o">!=</span> <span class="n">MBX_HEARTBEAT</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">pmb</span><span class="o">-&gt;</span><span class="n">vport</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">lpfc_debugfs_disc_trc</span><span class="p">(</span><span class="n">pmb</span><span class="o">-&gt;</span><span class="n">vport</span><span class="p">,</span>
					<span class="n">LPFC_DISC_TRC_MBOX_VPORT</span><span class="p">,</span>
					<span class="s">&quot;MBOX cmpl vport: cmd:x%x mb:x%x x%x&quot;</span><span class="p">,</span>
					<span class="p">(</span><span class="kt">uint32_t</span><span class="p">)</span><span class="n">pmbox</span><span class="o">-&gt;</span><span class="n">mbxCommand</span><span class="p">,</span>
					<span class="n">pmbox</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">varWords</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
					<span class="n">pmbox</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">varWords</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
			<span class="p">}</span>
			<span class="k">else</span> <span class="p">{</span>
				<span class="n">lpfc_debugfs_disc_trc</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">pport</span><span class="p">,</span>
					<span class="n">LPFC_DISC_TRC_MBOX</span><span class="p">,</span>
					<span class="s">&quot;MBOX cmpl:       cmd:x%x mb:x%x x%x&quot;</span><span class="p">,</span>
					<span class="p">(</span><span class="kt">uint32_t</span><span class="p">)</span><span class="n">pmbox</span><span class="o">-&gt;</span><span class="n">mbxCommand</span><span class="p">,</span>
					<span class="n">pmbox</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">varWords</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
					<span class="n">pmbox</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">varWords</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 * It is a fatal error if unknown mbox command completion.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">lpfc_sli_chk_mbx_command</span><span class="p">(</span><span class="n">pmbox</span><span class="o">-&gt;</span><span class="n">mbxCommand</span><span class="p">)</span> <span class="o">==</span>
		    <span class="n">MBX_SHUTDOWN</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Unknown mailbox command compl */</span>
			<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_MBOX</span> <span class="o">|</span> <span class="n">LOG_SLI</span><span class="p">,</span>
					<span class="s">&quot;(%d):0323 Unknown Mailbox command &quot;</span>
					<span class="s">&quot;x%x (x%x/x%x) Cmpl</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">pmb</span><span class="o">-&gt;</span><span class="n">vport</span> <span class="o">?</span> <span class="n">pmb</span><span class="o">-&gt;</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">vpi</span> <span class="o">:</span> <span class="mi">0</span><span class="p">,</span>
					<span class="n">pmbox</span><span class="o">-&gt;</span><span class="n">mbxCommand</span><span class="p">,</span>
					<span class="n">lpfc_sli_config_mbox_subsys_get</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span>
									<span class="n">pmb</span><span class="p">),</span>
					<span class="n">lpfc_sli_config_mbox_opcode_get</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span>
									<span class="n">pmb</span><span class="p">));</span>
			<span class="n">phba</span><span class="o">-&gt;</span><span class="n">link_state</span> <span class="o">=</span> <span class="n">LPFC_HBA_ERROR</span><span class="p">;</span>
			<span class="n">phba</span><span class="o">-&gt;</span><span class="n">work_hs</span> <span class="o">=</span> <span class="n">HS_FFER3</span><span class="p">;</span>
			<span class="n">lpfc_handle_eratt</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">pmbox</span><span class="o">-&gt;</span><span class="n">mbxStatus</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli</span><span class="p">.</span><span class="n">slistat</span><span class="p">.</span><span class="n">mbox_stat_err</span><span class="o">++</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">pmbox</span><span class="o">-&gt;</span><span class="n">mbxStatus</span> <span class="o">==</span> <span class="n">MBXERR_NO_RESOURCES</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/* Mbox cmd cmpl error - RETRYing */</span>
				<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_INFO</span><span class="p">,</span>
					<span class="n">LOG_MBOX</span> <span class="o">|</span> <span class="n">LOG_SLI</span><span class="p">,</span>
					<span class="s">&quot;(%d):0305 Mbox cmd cmpl &quot;</span>
					<span class="s">&quot;error - RETRYing Data: x%x &quot;</span>
					<span class="s">&quot;(x%x/x%x) x%x x%x x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">pmb</span><span class="o">-&gt;</span><span class="n">vport</span> <span class="o">?</span> <span class="n">pmb</span><span class="o">-&gt;</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">vpi</span> <span class="o">:</span> <span class="mi">0</span><span class="p">,</span>
					<span class="n">pmbox</span><span class="o">-&gt;</span><span class="n">mbxCommand</span><span class="p">,</span>
					<span class="n">lpfc_sli_config_mbox_subsys_get</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span>
									<span class="n">pmb</span><span class="p">),</span>
					<span class="n">lpfc_sli_config_mbox_opcode_get</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span>
									<span class="n">pmb</span><span class="p">),</span>
					<span class="n">pmbox</span><span class="o">-&gt;</span><span class="n">mbxStatus</span><span class="p">,</span>
					<span class="n">pmbox</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">varWords</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
					<span class="n">pmb</span><span class="o">-&gt;</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">port_state</span><span class="p">);</span>
				<span class="n">pmbox</span><span class="o">-&gt;</span><span class="n">mbxStatus</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
				<span class="n">pmbox</span><span class="o">-&gt;</span><span class="n">mbxOwner</span> <span class="o">=</span> <span class="n">OWN_HOST</span><span class="p">;</span>
				<span class="n">rc</span> <span class="o">=</span> <span class="n">lpfc_sli_issue_mbox</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">pmb</span><span class="p">,</span> <span class="n">MBX_NOWAIT</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">!=</span> <span class="n">MBX_NOT_FINISHED</span><span class="p">)</span>
					<span class="k">continue</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="cm">/* Mailbox cmd &lt;cmd&gt; Cmpl &lt;cmpl&gt; */</span>
		<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_INFO</span><span class="p">,</span> <span class="n">LOG_MBOX</span> <span class="o">|</span> <span class="n">LOG_SLI</span><span class="p">,</span>
				<span class="s">&quot;(%d):0307 Mailbox cmd x%x (x%x/x%x) Cmpl x%p &quot;</span>
				<span class="s">&quot;Data: x%x x%x x%x x%x x%x x%x x%x x%x x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">pmb</span><span class="o">-&gt;</span><span class="n">vport</span> <span class="o">?</span> <span class="n">pmb</span><span class="o">-&gt;</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">vpi</span> <span class="o">:</span> <span class="mi">0</span><span class="p">,</span>
				<span class="n">pmbox</span><span class="o">-&gt;</span><span class="n">mbxCommand</span><span class="p">,</span>
				<span class="n">lpfc_sli_config_mbox_subsys_get</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">pmb</span><span class="p">),</span>
				<span class="n">lpfc_sli_config_mbox_opcode_get</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">pmb</span><span class="p">),</span>
				<span class="n">pmb</span><span class="o">-&gt;</span><span class="n">mbox_cmpl</span><span class="p">,</span>
				<span class="o">*</span><span class="p">((</span><span class="kt">uint32_t</span> <span class="o">*</span><span class="p">)</span> <span class="n">pmbox</span><span class="p">),</span>
				<span class="n">pmbox</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">varWords</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
				<span class="n">pmbox</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">varWords</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
				<span class="n">pmbox</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">varWords</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span>
				<span class="n">pmbox</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">varWords</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span>
				<span class="n">pmbox</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">varWords</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span>
				<span class="n">pmbox</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">varWords</span><span class="p">[</span><span class="mi">5</span><span class="p">],</span>
				<span class="n">pmbox</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">varWords</span><span class="p">[</span><span class="mi">6</span><span class="p">],</span>
				<span class="n">pmbox</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">varWords</span><span class="p">[</span><span class="mi">7</span><span class="p">]);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">pmb</span><span class="o">-&gt;</span><span class="n">mbox_cmpl</span><span class="p">)</span>
			<span class="n">pmb</span><span class="o">-&gt;</span><span class="n">mbox_cmpl</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span><span class="n">pmb</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_sli_get_buff - Get the buffer associated with the buffer tag</span>
<span class="cm"> * @phba: Pointer to HBA context object.</span>
<span class="cm"> * @pring: Pointer to driver SLI ring object.</span>
<span class="cm"> * @tag: buffer tag.</span>
<span class="cm"> *</span>
<span class="cm"> * This function is called with no lock held. When QUE_BUFTAG_BIT bit</span>
<span class="cm"> * is set in the tag the buffer is posted for a particular exchange,</span>
<span class="cm"> * the function will return the buffer without replacing the buffer.</span>
<span class="cm"> * If the buffer is for unsolicited ELS or CT traffic, this function</span>
<span class="cm"> * returns the buffer and also posts another buffer to the firmware.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">lpfc_dmabuf</span> <span class="o">*</span>
<span class="nf">lpfc_sli_get_buff</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">,</span>
		  <span class="k">struct</span> <span class="n">lpfc_sli_ring</span> <span class="o">*</span><span class="n">pring</span><span class="p">,</span>
		  <span class="kt">uint32_t</span> <span class="n">tag</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">hbq_dmabuf</span> <span class="o">*</span><span class="n">hbq_entry</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">tag</span> <span class="o">&amp;</span> <span class="n">QUE_BUFTAG_BIT</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">lpfc_sli_ring_taggedbuf_get</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">pring</span><span class="p">,</span> <span class="n">tag</span><span class="p">);</span>
	<span class="n">hbq_entry</span> <span class="o">=</span> <span class="n">lpfc_sli_hbqbuf_find</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">tag</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hbq_entry</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">return</span> <span class="o">&amp;</span><span class="n">hbq_entry</span><span class="o">-&gt;</span><span class="n">dbuf</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_complete_unsol_iocb - Complete an unsolicited sequence</span>
<span class="cm"> * @phba: Pointer to HBA context object.</span>
<span class="cm"> * @pring: Pointer to driver SLI ring object.</span>
<span class="cm"> * @saveq: Pointer to the iocbq struct representing the sequence starting frame.</span>
<span class="cm"> * @fch_r_ctl: the r_ctl for the first frame of the sequence.</span>
<span class="cm"> * @fch_type: the type for the first frame of the sequence.</span>
<span class="cm"> *</span>
<span class="cm"> * This function is called with no lock held. This function uses the r_ctl and</span>
<span class="cm"> * type of the received sequence to find the correct callback function to call</span>
<span class="cm"> * to process the sequence.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">lpfc_complete_unsol_iocb</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">,</span> <span class="k">struct</span> <span class="n">lpfc_sli_ring</span> <span class="o">*</span><span class="n">pring</span><span class="p">,</span>
			 <span class="k">struct</span> <span class="n">lpfc_iocbq</span> <span class="o">*</span><span class="n">saveq</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">fch_r_ctl</span><span class="p">,</span>
			 <span class="kt">uint32_t</span> <span class="n">fch_type</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="cm">/* unSolicited Responses */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pring</span><span class="o">-&gt;</span><span class="n">prt</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">profile</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pring</span><span class="o">-&gt;</span><span class="n">prt</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">lpfc_sli_rcv_unsol_event</span><span class="p">)</span>
			<span class="p">(</span><span class="n">pring</span><span class="o">-&gt;</span><span class="n">prt</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">lpfc_sli_rcv_unsol_event</span><span class="p">)</span> <span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">pring</span><span class="p">,</span>
									<span class="n">saveq</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* We must search, based on rctl / type</span>
<span class="cm">	   for the right routine */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">pring</span><span class="o">-&gt;</span><span class="n">num_mask</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">pring</span><span class="o">-&gt;</span><span class="n">prt</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">rctl</span> <span class="o">==</span> <span class="n">fch_r_ctl</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="p">(</span><span class="n">pring</span><span class="o">-&gt;</span><span class="n">prt</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">type</span> <span class="o">==</span> <span class="n">fch_type</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">pring</span><span class="o">-&gt;</span><span class="n">prt</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">lpfc_sli_rcv_unsol_event</span><span class="p">)</span>
				<span class="p">(</span><span class="n">pring</span><span class="o">-&gt;</span><span class="n">prt</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">lpfc_sli_rcv_unsol_event</span><span class="p">)</span>
						<span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">pring</span><span class="p">,</span> <span class="n">saveq</span><span class="p">);</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_sli_process_unsol_iocb - Unsolicited iocb handler</span>
<span class="cm"> * @phba: Pointer to HBA context object.</span>
<span class="cm"> * @pring: Pointer to driver SLI ring object.</span>
<span class="cm"> * @saveq: Pointer to the unsolicited iocb.</span>
<span class="cm"> *</span>
<span class="cm"> * This function is called with no lock held by the ring event handler</span>
<span class="cm"> * when there is an unsolicited iocb posted to the response ring by the</span>
<span class="cm"> * firmware. This function gets the buffer associated with the iocbs</span>
<span class="cm"> * and calls the event handler for the ring. This function handles both</span>
<span class="cm"> * qring buffers and hbq buffers.</span>
<span class="cm"> * When the function returns 1 the caller can free the iocb object otherwise</span>
<span class="cm"> * upper layer functions will free the iocb objects.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">lpfc_sli_process_unsol_iocb</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">,</span> <span class="k">struct</span> <span class="n">lpfc_sli_ring</span> <span class="o">*</span><span class="n">pring</span><span class="p">,</span>
			    <span class="k">struct</span> <span class="n">lpfc_iocbq</span> <span class="o">*</span><span class="n">saveq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">IOCB_t</span>           <span class="o">*</span> <span class="n">irsp</span><span class="p">;</span>
	<span class="n">WORD5</span>            <span class="o">*</span> <span class="n">w5p</span><span class="p">;</span>
	<span class="kt">uint32_t</span>           <span class="n">Rctl</span><span class="p">,</span> <span class="n">Type</span><span class="p">;</span>
	<span class="kt">uint32_t</span>           <span class="n">match</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_iocbq</span> <span class="o">*</span><span class="n">iocbq</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_dmabuf</span> <span class="o">*</span><span class="n">dmzbuf</span><span class="p">;</span>

	<span class="n">match</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">irsp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">saveq</span><span class="o">-&gt;</span><span class="n">iocb</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">irsp</span><span class="o">-&gt;</span><span class="n">ulpCommand</span> <span class="o">==</span> <span class="n">CMD_ASYNC_STATUS</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pring</span><span class="o">-&gt;</span><span class="n">lpfc_sli_rcv_async_status</span><span class="p">)</span>
			<span class="n">pring</span><span class="o">-&gt;</span><span class="n">lpfc_sli_rcv_async_status</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">pring</span><span class="p">,</span> <span class="n">saveq</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span>
					<span class="n">KERN_WARNING</span><span class="p">,</span>
					<span class="n">LOG_SLI</span><span class="p">,</span>
					<span class="s">&quot;0316 Ring %d handler: unexpected &quot;</span>
					<span class="s">&quot;ASYNC_STATUS iocb received evt_code &quot;</span>
					<span class="s">&quot;0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">pring</span><span class="o">-&gt;</span><span class="n">ringno</span><span class="p">,</span>
					<span class="n">irsp</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">asyncstat</span><span class="p">.</span><span class="n">evt_code</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">irsp</span><span class="o">-&gt;</span><span class="n">ulpCommand</span> <span class="o">==</span> <span class="n">CMD_IOCB_RET_XRI64_CX</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		<span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli3_options</span> <span class="o">&amp;</span> <span class="n">LPFC_SLI3_HBQ_ENABLED</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">irsp</span><span class="o">-&gt;</span><span class="n">ulpBdeCount</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dmzbuf</span> <span class="o">=</span> <span class="n">lpfc_sli_get_buff</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">pring</span><span class="p">,</span>
					<span class="n">irsp</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">ulpWord</span><span class="p">[</span><span class="mi">3</span><span class="p">]);</span>
			<span class="n">lpfc_in_buf_free</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">dmzbuf</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">irsp</span><span class="o">-&gt;</span><span class="n">ulpBdeCount</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dmzbuf</span> <span class="o">=</span> <span class="n">lpfc_sli_get_buff</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">pring</span><span class="p">,</span>
					<span class="n">irsp</span><span class="o">-&gt;</span><span class="n">unsli3</span><span class="p">.</span><span class="n">sli3Words</span><span class="p">[</span><span class="mi">3</span><span class="p">]);</span>
			<span class="n">lpfc_in_buf_free</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">dmzbuf</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">irsp</span><span class="o">-&gt;</span><span class="n">ulpBdeCount</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dmzbuf</span> <span class="o">=</span> <span class="n">lpfc_sli_get_buff</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">pring</span><span class="p">,</span>
				<span class="n">irsp</span><span class="o">-&gt;</span><span class="n">unsli3</span><span class="p">.</span><span class="n">sli3Words</span><span class="p">[</span><span class="mi">7</span><span class="p">]);</span>
			<span class="n">lpfc_in_buf_free</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">dmzbuf</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli3_options</span> <span class="o">&amp;</span> <span class="n">LPFC_SLI3_HBQ_ENABLED</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">irsp</span><span class="o">-&gt;</span><span class="n">ulpBdeCount</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">saveq</span><span class="o">-&gt;</span><span class="n">context2</span> <span class="o">=</span> <span class="n">lpfc_sli_get_buff</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">pring</span><span class="p">,</span>
						<span class="n">irsp</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">ulpWord</span><span class="p">[</span><span class="mi">3</span><span class="p">]);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">saveq</span><span class="o">-&gt;</span><span class="n">context2</span><span class="p">)</span>
				<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span>
					<span class="n">KERN_ERR</span><span class="p">,</span>
					<span class="n">LOG_SLI</span><span class="p">,</span>
					<span class="s">&quot;0341 Ring %d Cannot find buffer for &quot;</span>
					<span class="s">&quot;an unsolicited iocb. tag 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">pring</span><span class="o">-&gt;</span><span class="n">ringno</span><span class="p">,</span>
					<span class="n">irsp</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">ulpWord</span><span class="p">[</span><span class="mi">3</span><span class="p">]);</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">irsp</span><span class="o">-&gt;</span><span class="n">ulpBdeCount</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">saveq</span><span class="o">-&gt;</span><span class="n">context3</span> <span class="o">=</span> <span class="n">lpfc_sli_get_buff</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">pring</span><span class="p">,</span>
						<span class="n">irsp</span><span class="o">-&gt;</span><span class="n">unsli3</span><span class="p">.</span><span class="n">sli3Words</span><span class="p">[</span><span class="mi">7</span><span class="p">]);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">saveq</span><span class="o">-&gt;</span><span class="n">context3</span><span class="p">)</span>
				<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span>
					<span class="n">KERN_ERR</span><span class="p">,</span>
					<span class="n">LOG_SLI</span><span class="p">,</span>
					<span class="s">&quot;0342 Ring %d Cannot find buffer for an&quot;</span>
					<span class="s">&quot; unsolicited iocb. tag 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">pring</span><span class="o">-&gt;</span><span class="n">ringno</span><span class="p">,</span>
					<span class="n">irsp</span><span class="o">-&gt;</span><span class="n">unsli3</span><span class="p">.</span><span class="n">sli3Words</span><span class="p">[</span><span class="mi">7</span><span class="p">]);</span>
		<span class="p">}</span>
		<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">iocbq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">saveq</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">irsp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">iocbq</span><span class="o">-&gt;</span><span class="n">iocb</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">irsp</span><span class="o">-&gt;</span><span class="n">ulpBdeCount</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">iocbq</span><span class="o">-&gt;</span><span class="n">context2</span> <span class="o">=</span> <span class="n">lpfc_sli_get_buff</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">pring</span><span class="p">,</span>
							<span class="n">irsp</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">ulpWord</span><span class="p">[</span><span class="mi">3</span><span class="p">]);</span>
				<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">iocbq</span><span class="o">-&gt;</span><span class="n">context2</span><span class="p">)</span>
					<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span>
						<span class="n">KERN_ERR</span><span class="p">,</span>
						<span class="n">LOG_SLI</span><span class="p">,</span>
						<span class="s">&quot;0343 Ring %d Cannot find &quot;</span>
						<span class="s">&quot;buffer for an unsolicited iocb&quot;</span>
						<span class="s">&quot;. tag 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">pring</span><span class="o">-&gt;</span><span class="n">ringno</span><span class="p">,</span>
						<span class="n">irsp</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">ulpWord</span><span class="p">[</span><span class="mi">3</span><span class="p">]);</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">irsp</span><span class="o">-&gt;</span><span class="n">ulpBdeCount</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">iocbq</span><span class="o">-&gt;</span><span class="n">context3</span> <span class="o">=</span> <span class="n">lpfc_sli_get_buff</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">pring</span><span class="p">,</span>
						<span class="n">irsp</span><span class="o">-&gt;</span><span class="n">unsli3</span><span class="p">.</span><span class="n">sli3Words</span><span class="p">[</span><span class="mi">7</span><span class="p">]);</span>
				<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">iocbq</span><span class="o">-&gt;</span><span class="n">context3</span><span class="p">)</span>
					<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span>
						<span class="n">KERN_ERR</span><span class="p">,</span>
						<span class="n">LOG_SLI</span><span class="p">,</span>
						<span class="s">&quot;0344 Ring %d Cannot find &quot;</span>
						<span class="s">&quot;buffer for an unsolicited &quot;</span>
						<span class="s">&quot;iocb. tag 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
						<span class="n">pring</span><span class="o">-&gt;</span><span class="n">ringno</span><span class="p">,</span>
						<span class="n">irsp</span><span class="o">-&gt;</span><span class="n">unsli3</span><span class="p">.</span><span class="n">sli3Words</span><span class="p">[</span><span class="mi">7</span><span class="p">]);</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">irsp</span><span class="o">-&gt;</span><span class="n">ulpBdeCount</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">irsp</span><span class="o">-&gt;</span><span class="n">ulpCommand</span> <span class="o">==</span> <span class="n">CMD_IOCB_RCV_CONT64_CX</span> <span class="o">||</span>
	     <span class="n">irsp</span><span class="o">-&gt;</span><span class="n">ulpStatus</span> <span class="o">==</span> <span class="n">IOSTAT_INTERMED_RSP</span><span class="p">))</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">found</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="cm">/* search continue save q for same XRI */</span>
		<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">iocbq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pring</span><span class="o">-&gt;</span><span class="n">iocb_continue_saveq</span><span class="p">,</span> <span class="n">clist</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">iocbq</span><span class="o">-&gt;</span><span class="n">iocb</span><span class="p">.</span><span class="n">unsli3</span><span class="p">.</span><span class="n">rcvsli3</span><span class="p">.</span><span class="n">ox_id</span> <span class="o">==</span>
				<span class="n">saveq</span><span class="o">-&gt;</span><span class="n">iocb</span><span class="p">.</span><span class="n">unsli3</span><span class="p">.</span><span class="n">rcvsli3</span><span class="p">.</span><span class="n">ox_id</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">saveq</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">iocbq</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
				<span class="n">found</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">found</span><span class="p">)</span>
			<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">saveq</span><span class="o">-&gt;</span><span class="n">clist</span><span class="p">,</span>
				      <span class="o">&amp;</span><span class="n">pring</span><span class="o">-&gt;</span><span class="n">iocb_continue_saveq</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">saveq</span><span class="o">-&gt;</span><span class="n">iocb</span><span class="p">.</span><span class="n">ulpStatus</span> <span class="o">!=</span> <span class="n">IOSTAT_INTERMED_RSP</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iocbq</span><span class="o">-&gt;</span><span class="n">clist</span><span class="p">);</span>
			<span class="n">saveq</span> <span class="o">=</span> <span class="n">iocbq</span><span class="p">;</span>
			<span class="n">irsp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">saveq</span><span class="o">-&gt;</span><span class="n">iocb</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">irsp</span><span class="o">-&gt;</span><span class="n">ulpCommand</span> <span class="o">==</span> <span class="n">CMD_RCV_ELS_REQ64_CX</span><span class="p">)</span> <span class="o">||</span>
	    <span class="p">(</span><span class="n">irsp</span><span class="o">-&gt;</span><span class="n">ulpCommand</span> <span class="o">==</span> <span class="n">CMD_RCV_ELS_REQ_CX</span><span class="p">)</span> <span class="o">||</span>
	    <span class="p">(</span><span class="n">irsp</span><span class="o">-&gt;</span><span class="n">ulpCommand</span> <span class="o">==</span> <span class="n">CMD_IOCB_RCV_ELS64_CX</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">Rctl</span> <span class="o">=</span> <span class="n">FC_RCTL_ELS_REQ</span><span class="p">;</span>
		<span class="n">Type</span> <span class="o">=</span> <span class="n">FC_TYPE_ELS</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">w5p</span> <span class="o">=</span> <span class="p">(</span><span class="n">WORD5</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="p">(</span><span class="n">saveq</span><span class="o">-&gt;</span><span class="n">iocb</span><span class="p">.</span><span class="n">un</span><span class="p">.</span><span class="n">ulpWord</span><span class="p">[</span><span class="mi">5</span><span class="p">]);</span>
		<span class="n">Rctl</span> <span class="o">=</span> <span class="n">w5p</span><span class="o">-&gt;</span><span class="n">hcsw</span><span class="p">.</span><span class="n">Rctl</span><span class="p">;</span>
		<span class="n">Type</span> <span class="o">=</span> <span class="n">w5p</span><span class="o">-&gt;</span><span class="n">hcsw</span><span class="p">.</span><span class="n">Type</span><span class="p">;</span>

		<span class="cm">/* Firmware Workaround */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">Rctl</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">pring</span><span class="o">-&gt;</span><span class="n">ringno</span> <span class="o">==</span> <span class="n">LPFC_ELS_RING</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			<span class="p">(</span><span class="n">irsp</span><span class="o">-&gt;</span><span class="n">ulpCommand</span> <span class="o">==</span> <span class="n">CMD_RCV_SEQUENCE64_CX</span> <span class="o">||</span>
			 <span class="n">irsp</span><span class="o">-&gt;</span><span class="n">ulpCommand</span> <span class="o">==</span> <span class="n">CMD_IOCB_RCV_SEQ64_CX</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">Rctl</span> <span class="o">=</span> <span class="n">FC_RCTL_ELS_REQ</span><span class="p">;</span>
			<span class="n">Type</span> <span class="o">=</span> <span class="n">FC_TYPE_ELS</span><span class="p">;</span>
			<span class="n">w5p</span><span class="o">-&gt;</span><span class="n">hcsw</span><span class="p">.</span><span class="n">Rctl</span> <span class="o">=</span> <span class="n">Rctl</span><span class="p">;</span>
			<span class="n">w5p</span><span class="o">-&gt;</span><span class="n">hcsw</span><span class="p">.</span><span class="n">Type</span> <span class="o">=</span> <span class="n">Type</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">lpfc_complete_unsol_iocb</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">pring</span><span class="p">,</span> <span class="n">saveq</span><span class="p">,</span> <span class="n">Rctl</span><span class="p">,</span> <span class="n">Type</span><span class="p">))</span>
		<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_WARNING</span><span class="p">,</span> <span class="n">LOG_SLI</span><span class="p">,</span>
				<span class="s">&quot;0313 Ring %d handler: unexpected Rctl x%x &quot;</span>
				<span class="s">&quot;Type x%x received</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">pring</span><span class="o">-&gt;</span><span class="n">ringno</span><span class="p">,</span> <span class="n">Rctl</span><span class="p">,</span> <span class="n">Type</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_sli_iocbq_lookup - Find command iocb for the given response iocb</span>
<span class="cm"> * @phba: Pointer to HBA context object.</span>
<span class="cm"> * @pring: Pointer to driver SLI ring object.</span>
<span class="cm"> * @prspiocb: Pointer to response iocb object.</span>
<span class="cm"> *</span>
<span class="cm"> * This function looks up the iocb_lookup table to get the command iocb</span>
<span class="cm"> * corresponding to the given response iocb using the iotag of the</span>
<span class="cm"> * response iocb. This function is called with the hbalock held.</span>
<span class="cm"> * This function returns the command iocb object if it finds the command</span>
<span class="cm"> * iocb else returns NULL.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">lpfc_iocbq</span> <span class="o">*</span>
<span class="nf">lpfc_sli_iocbq_lookup</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">,</span>
		      <span class="k">struct</span> <span class="n">lpfc_sli_ring</span> <span class="o">*</span><span class="n">pring</span><span class="p">,</span>
		      <span class="k">struct</span> <span class="n">lpfc_iocbq</span> <span class="o">*</span><span class="n">prspiocb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpfc_iocbq</span> <span class="o">*</span><span class="n">cmd_iocb</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">uint16_t</span> <span class="n">iotag</span><span class="p">;</span>

	<span class="n">iotag</span> <span class="o">=</span> <span class="n">prspiocb</span><span class="o">-&gt;</span><span class="n">iocb</span><span class="p">.</span><span class="n">ulpIoTag</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">iotag</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">iotag</span> <span class="o">&lt;=</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli</span><span class="p">.</span><span class="n">last_iotag</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cmd_iocb</span> <span class="o">=</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli</span><span class="p">.</span><span class="n">iocbq_lookup</span><span class="p">[</span><span class="n">iotag</span><span class="p">];</span>
		<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmd_iocb</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cmd_iocb</span><span class="o">-&gt;</span><span class="n">iocb_flag</span> <span class="o">&amp;</span> <span class="n">LPFC_IO_ON_TXCMPLQ</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pring</span><span class="o">-&gt;</span><span class="n">txcmplq_cnt</span><span class="o">--</span><span class="p">;</span>
			<span class="n">cmd_iocb</span><span class="o">-&gt;</span><span class="n">iocb_flag</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">LPFC_IO_ON_TXCMPLQ</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">return</span> <span class="n">cmd_iocb</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_SLI</span><span class="p">,</span>
			<span class="s">&quot;0317 iotag x%x is out off &quot;</span>
			<span class="s">&quot;range: max iotag x%x wd0 x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">iotag</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli</span><span class="p">.</span><span class="n">last_iotag</span><span class="p">,</span>
			<span class="o">*</span><span class="p">(((</span><span class="kt">uint32_t</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">prspiocb</span><span class="o">-&gt;</span><span class="n">iocb</span><span class="p">)</span> <span class="o">+</span> <span class="mi">7</span><span class="p">));</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_sli_iocbq_lookup_by_tag - Find command iocb for the iotag</span>
<span class="cm"> * @phba: Pointer to HBA context object.</span>
<span class="cm"> * @pring: Pointer to driver SLI ring object.</span>
<span class="cm"> * @iotag: IOCB tag.</span>
<span class="cm"> *</span>
<span class="cm"> * This function looks up the iocb_lookup table to get the command iocb</span>
<span class="cm"> * corresponding to the given iotag. This function is called with the</span>
<span class="cm"> * hbalock held.</span>
<span class="cm"> * This function returns the command iocb object if it finds the command</span>
<span class="cm"> * iocb else returns NULL.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">lpfc_iocbq</span> <span class="o">*</span>
<span class="nf">lpfc_sli_iocbq_lookup_by_tag</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">lpfc_sli_ring</span> <span class="o">*</span><span class="n">pring</span><span class="p">,</span> <span class="kt">uint16_t</span> <span class="n">iotag</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpfc_iocbq</span> <span class="o">*</span><span class="n">cmd_iocb</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">iotag</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">iotag</span> <span class="o">&lt;=</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli</span><span class="p">.</span><span class="n">last_iotag</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cmd_iocb</span> <span class="o">=</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli</span><span class="p">.</span><span class="n">iocbq_lookup</span><span class="p">[</span><span class="n">iotag</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cmd_iocb</span><span class="o">-&gt;</span><span class="n">iocb_flag</span> <span class="o">&amp;</span> <span class="n">LPFC_IO_ON_TXCMPLQ</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* remove from txcmpl queue list */</span>
			<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmd_iocb</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
			<span class="n">cmd_iocb</span><span class="o">-&gt;</span><span class="n">iocb_flag</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">LPFC_IO_ON_TXCMPLQ</span><span class="p">;</span>
			<span class="n">pring</span><span class="o">-&gt;</span><span class="n">txcmplq_cnt</span><span class="o">--</span><span class="p">;</span>
			<span class="k">return</span> <span class="n">cmd_iocb</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_SLI</span><span class="p">,</span>
			<span class="s">&quot;0372 iotag x%x is out off range: max iotag (x%x)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">iotag</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli</span><span class="p">.</span><span class="n">last_iotag</span><span class="p">);</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_sli_process_sol_iocb - process solicited iocb completion</span>
<span class="cm"> * @phba: Pointer to HBA context object.</span>
<span class="cm"> * @pring: Pointer to driver SLI ring object.</span>
<span class="cm"> * @saveq: Pointer to the response iocb to be processed.</span>
<span class="cm"> *</span>
<span class="cm"> * This function is called by the ring event handler for non-fcp</span>
<span class="cm"> * rings when there is a new response iocb in the response ring.</span>
<span class="cm"> * The caller is not required to hold any locks. This function</span>
<span class="cm"> * gets the command iocb associated with the response iocb and</span>
<span class="cm"> * calls the completion handler for the command iocb. If there</span>
<span class="cm"> * is no completion handler, the function will free the resources</span>
<span class="cm"> * associated with command iocb. If the response iocb is for</span>
<span class="cm"> * an already aborted command iocb, the status of the completion</span>
<span class="cm"> * is changed to IOSTAT_LOCAL_REJECT/IOERR_SLI_ABORTED.</span>
<span class="cm"> * This function always returns 1.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">lpfc_sli_process_sol_iocb</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">,</span> <span class="k">struct</span> <span class="n">lpfc_sli_ring</span> <span class="o">*</span><span class="n">pring</span><span class="p">,</span>
			  <span class="k">struct</span> <span class="n">lpfc_iocbq</span> <span class="o">*</span><span class="n">saveq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpfc_iocbq</span> <span class="o">*</span><span class="n">cmdiocbp</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">iflag</span><span class="p">;</span>

	<span class="cm">/* Based on the iotag field, get the cmd IOCB from the txcmplq */</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">,</span> <span class="n">iflag</span><span class="p">);</span>
	<span class="n">cmdiocbp</span> <span class="o">=</span> <span class="n">lpfc_sli_iocbq_lookup</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">pring</span><span class="p">,</span> <span class="n">saveq</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">,</span> <span class="n">iflag</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cmdiocbp</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cmdiocbp</span><span class="o">-&gt;</span><span class="n">iocb_cmpl</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * If an ELS command failed send an event to mgmt</span>
<span class="cm">			 * application.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">saveq</span><span class="o">-&gt;</span><span class="n">iocb</span><span class="p">.</span><span class="n">ulpStatus</span> <span class="o">&amp;&amp;</span>
			     <span class="p">(</span><span class="n">pring</span><span class="o">-&gt;</span><span class="n">ringno</span> <span class="o">==</span> <span class="n">LPFC_ELS_RING</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			     <span class="p">(</span><span class="n">cmdiocbp</span><span class="o">-&gt;</span><span class="n">iocb</span><span class="p">.</span><span class="n">ulpCommand</span> <span class="o">==</span>
				<span class="n">CMD_ELS_REQUEST64_CR</span><span class="p">))</span>
				<span class="n">lpfc_send_els_failure_event</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span>
					<span class="n">cmdiocbp</span><span class="p">,</span> <span class="n">saveq</span><span class="p">);</span>

			<span class="cm">/*</span>
<span class="cm">			 * Post all ELS completions to the worker thread.</span>
<span class="cm">			 * All other are passed to the completion callback.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">pring</span><span class="o">-&gt;</span><span class="n">ringno</span> <span class="o">==</span> <span class="n">LPFC_ELS_RING</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">((</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli_rev</span> <span class="o">&lt;</span> <span class="n">LPFC_SLI_REV4</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
				    <span class="p">(</span><span class="n">cmdiocbp</span><span class="o">-&gt;</span><span class="n">iocb_flag</span> <span class="o">&amp;</span>
							<span class="n">LPFC_DRIVER_ABORTED</span><span class="p">))</span> <span class="p">{</span>
					<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">,</span>
							  <span class="n">iflag</span><span class="p">);</span>
					<span class="n">cmdiocbp</span><span class="o">-&gt;</span><span class="n">iocb_flag</span> <span class="o">&amp;=</span>
						<span class="o">~</span><span class="n">LPFC_DRIVER_ABORTED</span><span class="p">;</span>
					<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">,</span>
							       <span class="n">iflag</span><span class="p">);</span>
					<span class="n">saveq</span><span class="o">-&gt;</span><span class="n">iocb</span><span class="p">.</span><span class="n">ulpStatus</span> <span class="o">=</span>
						<span class="n">IOSTAT_LOCAL_REJECT</span><span class="p">;</span>
					<span class="n">saveq</span><span class="o">-&gt;</span><span class="n">iocb</span><span class="p">.</span><span class="n">un</span><span class="p">.</span><span class="n">ulpWord</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span>
						<span class="n">IOERR_SLI_ABORTED</span><span class="p">;</span>

					<span class="cm">/* Firmware could still be in progress</span>
<span class="cm">					 * of DMAing payload, so don&#39;t free data</span>
<span class="cm">					 * buffer till after a hbeat.</span>
<span class="cm">					 */</span>
					<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">,</span>
							  <span class="n">iflag</span><span class="p">);</span>
					<span class="n">saveq</span><span class="o">-&gt;</span><span class="n">iocb_flag</span> <span class="o">|=</span> <span class="n">LPFC_DELAY_MEM_FREE</span><span class="p">;</span>
					<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">,</span>
							       <span class="n">iflag</span><span class="p">);</span>
				<span class="p">}</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli_rev</span> <span class="o">==</span> <span class="n">LPFC_SLI_REV4</span><span class="p">)</span> <span class="p">{</span>
					<span class="k">if</span> <span class="p">(</span><span class="n">saveq</span><span class="o">-&gt;</span><span class="n">iocb_flag</span> <span class="o">&amp;</span>
					    <span class="n">LPFC_EXCHANGE_BUSY</span><span class="p">)</span> <span class="p">{</span>
						<span class="cm">/* Set cmdiocb flag for the</span>
<span class="cm">						 * exchange busy so sgl (xri)</span>
<span class="cm">						 * will not be released until</span>
<span class="cm">						 * the abort xri is received</span>
<span class="cm">						 * from hba.</span>
<span class="cm">						 */</span>
						<span class="n">spin_lock_irqsave</span><span class="p">(</span>
							<span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">,</span> <span class="n">iflag</span><span class="p">);</span>
						<span class="n">cmdiocbp</span><span class="o">-&gt;</span><span class="n">iocb_flag</span> <span class="o">|=</span>
							<span class="n">LPFC_EXCHANGE_BUSY</span><span class="p">;</span>
						<span class="n">spin_unlock_irqrestore</span><span class="p">(</span>
							<span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">,</span> <span class="n">iflag</span><span class="p">);</span>
					<span class="p">}</span>
					<span class="k">if</span> <span class="p">(</span><span class="n">cmdiocbp</span><span class="o">-&gt;</span><span class="n">iocb_flag</span> <span class="o">&amp;</span>
					    <span class="n">LPFC_DRIVER_ABORTED</span><span class="p">)</span> <span class="p">{</span>
						<span class="cm">/*</span>
<span class="cm">						 * Clear LPFC_DRIVER_ABORTED</span>
<span class="cm">						 * bit in case it was driver</span>
<span class="cm">						 * initiated abort.</span>
<span class="cm">						 */</span>
						<span class="n">spin_lock_irqsave</span><span class="p">(</span>
							<span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">,</span> <span class="n">iflag</span><span class="p">);</span>
						<span class="n">cmdiocbp</span><span class="o">-&gt;</span><span class="n">iocb_flag</span> <span class="o">&amp;=</span>
							<span class="o">~</span><span class="n">LPFC_DRIVER_ABORTED</span><span class="p">;</span>
						<span class="n">spin_unlock_irqrestore</span><span class="p">(</span>
							<span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">,</span> <span class="n">iflag</span><span class="p">);</span>
						<span class="n">cmdiocbp</span><span class="o">-&gt;</span><span class="n">iocb</span><span class="p">.</span><span class="n">ulpStatus</span> <span class="o">=</span>
							<span class="n">IOSTAT_LOCAL_REJECT</span><span class="p">;</span>
						<span class="n">cmdiocbp</span><span class="o">-&gt;</span><span class="n">iocb</span><span class="p">.</span><span class="n">un</span><span class="p">.</span><span class="n">ulpWord</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span>
							<span class="n">IOERR_ABORT_REQUESTED</span><span class="p">;</span>
						<span class="cm">/*</span>
<span class="cm">						 * For SLI4, irsiocb contains</span>
<span class="cm">						 * NO_XRI in sli_xritag, it</span>
<span class="cm">						 * shall not affect releasing</span>
<span class="cm">						 * sgl (xri) process.</span>
<span class="cm">						 */</span>
						<span class="n">saveq</span><span class="o">-&gt;</span><span class="n">iocb</span><span class="p">.</span><span class="n">ulpStatus</span> <span class="o">=</span>
							<span class="n">IOSTAT_LOCAL_REJECT</span><span class="p">;</span>
						<span class="n">saveq</span><span class="o">-&gt;</span><span class="n">iocb</span><span class="p">.</span><span class="n">un</span><span class="p">.</span><span class="n">ulpWord</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span>
							<span class="n">IOERR_SLI_ABORTED</span><span class="p">;</span>
						<span class="n">spin_lock_irqsave</span><span class="p">(</span>
							<span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">,</span> <span class="n">iflag</span><span class="p">);</span>
						<span class="n">saveq</span><span class="o">-&gt;</span><span class="n">iocb_flag</span> <span class="o">|=</span>
							<span class="n">LPFC_DELAY_MEM_FREE</span><span class="p">;</span>
						<span class="n">spin_unlock_irqrestore</span><span class="p">(</span>
							<span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">,</span> <span class="n">iflag</span><span class="p">);</span>
					<span class="p">}</span>
				<span class="p">}</span>
			<span class="p">}</span>
			<span class="p">(</span><span class="n">cmdiocbp</span><span class="o">-&gt;</span><span class="n">iocb_cmpl</span><span class="p">)</span> <span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">cmdiocbp</span><span class="p">,</span> <span class="n">saveq</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="n">lpfc_sli_release_iocbq</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">cmdiocbp</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Unknown initiating command based on the response iotag.</span>
<span class="cm">		 * This could be the case on the ELS ring because of</span>
<span class="cm">		 * lpfc_els_abort().</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pring</span><span class="o">-&gt;</span><span class="n">ringno</span> <span class="o">!=</span> <span class="n">LPFC_ELS_RING</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * Ring &lt;ringno&gt; handler: unexpected completion IoTag</span>
<span class="cm">			 * &lt;IoTag&gt;</span>
<span class="cm">			 */</span>
			<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_WARNING</span><span class="p">,</span> <span class="n">LOG_SLI</span><span class="p">,</span>
					 <span class="s">&quot;0322 Ring %d handler: &quot;</span>
					 <span class="s">&quot;unexpected completion IoTag x%x &quot;</span>
					 <span class="s">&quot;Data: x%x x%x x%x x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					 <span class="n">pring</span><span class="o">-&gt;</span><span class="n">ringno</span><span class="p">,</span>
					 <span class="n">saveq</span><span class="o">-&gt;</span><span class="n">iocb</span><span class="p">.</span><span class="n">ulpIoTag</span><span class="p">,</span>
					 <span class="n">saveq</span><span class="o">-&gt;</span><span class="n">iocb</span><span class="p">.</span><span class="n">ulpStatus</span><span class="p">,</span>
					 <span class="n">saveq</span><span class="o">-&gt;</span><span class="n">iocb</span><span class="p">.</span><span class="n">un</span><span class="p">.</span><span class="n">ulpWord</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span>
					 <span class="n">saveq</span><span class="o">-&gt;</span><span class="n">iocb</span><span class="p">.</span><span class="n">ulpCommand</span><span class="p">,</span>
					 <span class="n">saveq</span><span class="o">-&gt;</span><span class="n">iocb</span><span class="p">.</span><span class="n">ulpContext</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_sli_rsp_pointers_error - Response ring pointer error handler</span>
<span class="cm"> * @phba: Pointer to HBA context object.</span>
<span class="cm"> * @pring: Pointer to driver SLI ring object.</span>
<span class="cm"> *</span>
<span class="cm"> * This function is called from the iocb ring event handlers when</span>
<span class="cm"> * put pointer is ahead of the get pointer for a ring. This function signal</span>
<span class="cm"> * an error attention condition to the worker thread and the worker</span>
<span class="cm"> * thread will transition the HBA to offline state.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">lpfc_sli_rsp_pointers_error</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">,</span> <span class="k">struct</span> <span class="n">lpfc_sli_ring</span> <span class="o">*</span><span class="n">pring</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpfc_pgp</span> <span class="o">*</span><span class="n">pgp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">port_gp</span><span class="p">[</span><span class="n">pring</span><span class="o">-&gt;</span><span class="n">ringno</span><span class="p">];</span>
	<span class="cm">/*</span>
<span class="cm">	 * Ring &lt;ringno&gt; handler: portRspPut &lt;portRspPut&gt; is bigger than</span>
<span class="cm">	 * rsp ring &lt;portRspMax&gt;</span>
<span class="cm">	 */</span>
	<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_SLI</span><span class="p">,</span>
			<span class="s">&quot;0312 Ring %d handler: portRspPut %d &quot;</span>
			<span class="s">&quot;is bigger than rsp ring %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">pring</span><span class="o">-&gt;</span><span class="n">ringno</span><span class="p">,</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">pgp</span><span class="o">-&gt;</span><span class="n">rspPutInx</span><span class="p">),</span>
			<span class="n">pring</span><span class="o">-&gt;</span><span class="n">numRiocb</span><span class="p">);</span>

	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">link_state</span> <span class="o">=</span> <span class="n">LPFC_HBA_ERROR</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * All error attention handlers are posted to</span>
<span class="cm">	 * worker thread</span>
<span class="cm">	 */</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">work_ha</span> <span class="o">|=</span> <span class="n">HA_ERATT</span><span class="p">;</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">work_hs</span> <span class="o">=</span> <span class="n">HS_FFER3</span><span class="p">;</span>

	<span class="n">lpfc_worker_wake_up</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>

	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_poll_eratt - Error attention polling timer timeout handler</span>
<span class="cm"> * @ptr: Pointer to address of HBA context object.</span>
<span class="cm"> *</span>
<span class="cm"> * This function is invoked by the Error Attention polling timer when the</span>
<span class="cm"> * timer times out. It will check the SLI Error Attention register for</span>
<span class="cm"> * possible attention events. If so, it will post an Error Attention event</span>
<span class="cm"> * and wake up worker thread to process it. Otherwise, it will set up the</span>
<span class="cm"> * Error Attention polling timer for the next poll.</span>
<span class="cm"> **/</span>
<span class="kt">void</span> <span class="nf">lpfc_poll_eratt</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ptr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">eratt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">phba</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="p">)</span><span class="n">ptr</span><span class="p">;</span>

	<span class="cm">/* Check chip HA register for error event */</span>
	<span class="n">eratt</span> <span class="o">=</span> <span class="n">lpfc_sli_check_eratt</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">eratt</span><span class="p">)</span>
		<span class="cm">/* Tell the worker thread there is work to do */</span>
		<span class="n">lpfc_worker_wake_up</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="cm">/* Restart the timer for next eratt poll */</span>
		<span class="n">mod_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">eratt_poll</span><span class="p">,</span> <span class="n">jiffies</span> <span class="o">+</span>
					<span class="n">HZ</span> <span class="o">*</span> <span class="n">LPFC_ERATT_POLL_INTERVAL</span><span class="p">);</span>
	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/**</span>
<span class="cm"> * lpfc_sli_handle_fast_ring_event - Handle ring events on FCP ring</span>
<span class="cm"> * @phba: Pointer to HBA context object.</span>
<span class="cm"> * @pring: Pointer to driver SLI ring object.</span>
<span class="cm"> * @mask: Host attention register mask for this ring.</span>
<span class="cm"> *</span>
<span class="cm"> * This function is called from the interrupt context when there is a ring</span>
<span class="cm"> * event for the fcp ring. The caller does not hold any lock.</span>
<span class="cm"> * The function processes each response iocb in the response ring until it</span>
<span class="cm"> * finds an iocb with LE bit set and chains all the iocbs up to the iocb with</span>
<span class="cm"> * LE bit set. The function will call the completion handler of the command iocb</span>
<span class="cm"> * if the response iocb indicates a completion for a command iocb or it is</span>
<span class="cm"> * an abort completion. The function will call lpfc_sli_process_unsol_iocb</span>
<span class="cm"> * function if this is an unsolicited iocb.</span>
<span class="cm"> * This routine presumes LPFC_FCP_RING handling and doesn&#39;t bother</span>
<span class="cm"> * to check it explicitly.</span>
<span class="cm"> */</span>
<span class="kt">int</span>
<span class="nf">lpfc_sli_handle_fast_ring_event</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">lpfc_sli_ring</span> <span class="o">*</span><span class="n">pring</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">mask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpfc_pgp</span> <span class="o">*</span><span class="n">pgp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">port_gp</span><span class="p">[</span><span class="n">pring</span><span class="o">-&gt;</span><span class="n">ringno</span><span class="p">];</span>
	<span class="n">IOCB_t</span> <span class="o">*</span><span class="n">irsp</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">IOCB_t</span> <span class="o">*</span><span class="n">entry</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_iocbq</span> <span class="o">*</span><span class="n">cmdiocbq</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_iocbq</span> <span class="n">rspiocbq</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">status</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">portRspPut</span><span class="p">,</span> <span class="n">portRspMax</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">lpfc_iocb_type</span> <span class="n">type</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">iflag</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">rsp_cmpl</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">,</span> <span class="n">iflag</span><span class="p">);</span>
	<span class="n">pring</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">iocb_event</span><span class="o">++</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * The next available response entry should never exceed the maximum</span>
<span class="cm">	 * entries.  If it does, treat it as an adapter hardware error.</span>
<span class="cm">	 */</span>
	<span class="n">portRspMax</span> <span class="o">=</span> <span class="n">pring</span><span class="o">-&gt;</span><span class="n">numRiocb</span><span class="p">;</span>
	<span class="n">portRspPut</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">pgp</span><span class="o">-&gt;</span><span class="n">rspPutInx</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">portRspPut</span> <span class="o">&gt;=</span> <span class="n">portRspMax</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">lpfc_sli_rsp_pointers_error</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">pring</span><span class="p">);</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">,</span> <span class="n">iflag</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">fcp_ring_in_use</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">,</span> <span class="n">iflag</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">fcp_ring_in_use</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">rmb</span><span class="p">();</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">pring</span><span class="o">-&gt;</span><span class="n">rspidx</span> <span class="o">!=</span> <span class="n">portRspPut</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Fetch an entry off the ring and copy it into a local data</span>
<span class="cm">		 * structure.  The copy involves a byte-swap since the</span>
<span class="cm">		 * network byte order and pci byte orders are different.</span>
<span class="cm">		 */</span>
		<span class="n">entry</span> <span class="o">=</span> <span class="n">lpfc_resp_iocb</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">pring</span><span class="p">);</span>
		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">last_completion_time</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">++</span><span class="n">pring</span><span class="o">-&gt;</span><span class="n">rspidx</span> <span class="o">&gt;=</span> <span class="n">portRspMax</span><span class="p">)</span>
			<span class="n">pring</span><span class="o">-&gt;</span><span class="n">rspidx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="n">lpfc_sli_pcimem_bcopy</span><span class="p">((</span><span class="kt">uint32_t</span> <span class="o">*</span><span class="p">)</span> <span class="n">entry</span><span class="p">,</span>
				      <span class="p">(</span><span class="kt">uint32_t</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">rspiocbq</span><span class="p">.</span><span class="n">iocb</span><span class="p">,</span>
				      <span class="n">phba</span><span class="o">-&gt;</span><span class="n">iocb_rsp_size</span><span class="p">);</span>
		<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">rspiocbq</span><span class="p">.</span><span class="n">list</span><span class="p">));</span>
		<span class="n">irsp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">rspiocbq</span><span class="p">.</span><span class="n">iocb</span><span class="p">;</span>

		<span class="n">type</span> <span class="o">=</span> <span class="n">lpfc_sli_iocb_cmd_type</span><span class="p">(</span><span class="n">irsp</span><span class="o">-&gt;</span><span class="n">ulpCommand</span> <span class="o">&amp;</span> <span class="n">CMD_IOCB_MASK</span><span class="p">);</span>
		<span class="n">pring</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">iocb_rsp</span><span class="o">++</span><span class="p">;</span>
		<span class="n">rsp_cmpl</span><span class="o">++</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">irsp</span><span class="o">-&gt;</span><span class="n">ulpStatus</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * If resource errors reported from HBA, reduce</span>
<span class="cm">			 * queuedepths of the SCSI device.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">irsp</span><span class="o">-&gt;</span><span class="n">ulpStatus</span> <span class="o">==</span> <span class="n">IOSTAT_LOCAL_REJECT</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
				<span class="p">(</span><span class="n">irsp</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">ulpWord</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">==</span> <span class="n">IOERR_NO_RESOURCES</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">,</span> <span class="n">iflag</span><span class="p">);</span>
				<span class="n">phba</span><span class="o">-&gt;</span><span class="n">lpfc_rampdown_queue_depth</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
				<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">,</span> <span class="n">iflag</span><span class="p">);</span>
			<span class="p">}</span>

			<span class="cm">/* Rsp ring &lt;ringno&gt; error: IOCB */</span>
			<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_WARNING</span><span class="p">,</span> <span class="n">LOG_SLI</span><span class="p">,</span>
					<span class="s">&quot;0336 Rsp Ring %d error: IOCB Data: &quot;</span>
					<span class="s">&quot;x%x x%x x%x x%x x%x x%x x%x x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">pring</span><span class="o">-&gt;</span><span class="n">ringno</span><span class="p">,</span>
					<span class="n">irsp</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">ulpWord</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
					<span class="n">irsp</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">ulpWord</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
					<span class="n">irsp</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">ulpWord</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span>
					<span class="n">irsp</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">ulpWord</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span>
					<span class="n">irsp</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">ulpWord</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span>
					<span class="n">irsp</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">ulpWord</span><span class="p">[</span><span class="mi">5</span><span class="p">],</span>
					<span class="o">*</span><span class="p">(</span><span class="kt">uint32_t</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">irsp</span><span class="o">-&gt;</span><span class="n">un1</span><span class="p">,</span>
					<span class="o">*</span><span class="p">((</span><span class="kt">uint32_t</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">irsp</span><span class="o">-&gt;</span><span class="n">un1</span> <span class="o">+</span> <span class="mi">1</span><span class="p">));</span>
		<span class="p">}</span>

		<span class="k">switch</span> <span class="p">(</span><span class="n">type</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">LPFC_ABORT_IOCB</span>:
		<span class="k">case</span> <span class="n">LPFC_SOL_IOCB</span>:
			<span class="cm">/*</span>
<span class="cm">			 * Idle exchange closed via ABTS from port.  No iocb</span>
<span class="cm">			 * resources need to be recovered.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">irsp</span><span class="o">-&gt;</span><span class="n">ulpCommand</span> <span class="o">==</span> <span class="n">CMD_XRI_ABORTED_CX</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_INFO</span><span class="p">,</span> <span class="n">LOG_SLI</span><span class="p">,</span>
						<span class="s">&quot;0333 IOCB cmd 0x%x&quot;</span>
						<span class="s">&quot; processed. Skipping&quot;</span>
						<span class="s">&quot; completion</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
						<span class="n">irsp</span><span class="o">-&gt;</span><span class="n">ulpCommand</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="n">cmdiocbq</span> <span class="o">=</span> <span class="n">lpfc_sli_iocbq_lookup</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">pring</span><span class="p">,</span>
							 <span class="o">&amp;</span><span class="n">rspiocbq</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">cmdiocbq</span><span class="p">))</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">cmdiocbq</span><span class="o">-&gt;</span><span class="n">iocb_flag</span> <span class="o">&amp;</span> <span class="n">LPFC_DRIVER_ABORTED</span><span class="p">)</span>
				<span class="n">cmdiocbq</span><span class="o">-&gt;</span><span class="n">iocb_flag</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">LPFC_DRIVER_ABORTED</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">cmdiocbq</span><span class="o">-&gt;</span><span class="n">iocb_cmpl</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">,</span> <span class="n">iflag</span><span class="p">);</span>
				<span class="p">(</span><span class="n">cmdiocbq</span><span class="o">-&gt;</span><span class="n">iocb_cmpl</span><span class="p">)(</span><span class="n">phba</span><span class="p">,</span> <span class="n">cmdiocbq</span><span class="p">,</span>
						      <span class="o">&amp;</span><span class="n">rspiocbq</span><span class="p">);</span>
				<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">,</span> <span class="n">iflag</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">LPFC_UNSOL_IOCB</span>:
			<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">,</span> <span class="n">iflag</span><span class="p">);</span>
			<span class="n">lpfc_sli_process_unsol_iocb</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">pring</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rspiocbq</span><span class="p">);</span>
			<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">,</span> <span class="n">iflag</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="nl">default:</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">irsp</span><span class="o">-&gt;</span><span class="n">ulpCommand</span> <span class="o">==</span> <span class="n">CMD_ADAPTER_MSG</span><span class="p">)</span> <span class="p">{</span>
				<span class="kt">char</span> <span class="n">adaptermsg</span><span class="p">[</span><span class="n">LPFC_MAX_ADPTMSG</span><span class="p">];</span>
				<span class="n">memset</span><span class="p">(</span><span class="n">adaptermsg</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">LPFC_MAX_ADPTMSG</span><span class="p">);</span>
				<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adaptermsg</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="p">(</span><span class="kt">uint8_t</span> <span class="o">*</span><span class="p">)</span> <span class="n">irsp</span><span class="p">,</span>
				       <span class="n">MAX_MSG_DATA</span><span class="p">);</span>
				<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="p">((</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">pcidev</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">),</span>
					 <span class="s">&quot;lpfc%d: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					 <span class="n">phba</span><span class="o">-&gt;</span><span class="n">brd_no</span><span class="p">,</span> <span class="n">adaptermsg</span><span class="p">);</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="cm">/* Unknown IOCB command */</span>
				<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_SLI</span><span class="p">,</span>
						<span class="s">&quot;0334 Unknown IOCB command &quot;</span>
						<span class="s">&quot;Data: x%x, x%x x%x x%x x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
						<span class="n">type</span><span class="p">,</span> <span class="n">irsp</span><span class="o">-&gt;</span><span class="n">ulpCommand</span><span class="p">,</span>
						<span class="n">irsp</span><span class="o">-&gt;</span><span class="n">ulpStatus</span><span class="p">,</span>
						<span class="n">irsp</span><span class="o">-&gt;</span><span class="n">ulpIoTag</span><span class="p">,</span>
						<span class="n">irsp</span><span class="o">-&gt;</span><span class="n">ulpContext</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 * The response IOCB has been processed.  Update the ring</span>
<span class="cm">		 * pointer in SLIM.  If the port response put pointer has not</span>
<span class="cm">		 * been updated, sync the pgp-&gt;rspPutInx and fetch the new port</span>
<span class="cm">		 * response put pointer.</span>
<span class="cm">		 */</span>
		<span class="n">writel</span><span class="p">(</span><span class="n">pring</span><span class="o">-&gt;</span><span class="n">rspidx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">host_gp</span><span class="p">[</span><span class="n">pring</span><span class="o">-&gt;</span><span class="n">ringno</span><span class="p">].</span><span class="n">rspGetInx</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">pring</span><span class="o">-&gt;</span><span class="n">rspidx</span> <span class="o">==</span> <span class="n">portRspPut</span><span class="p">)</span>
			<span class="n">portRspPut</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">pgp</span><span class="o">-&gt;</span><span class="n">rspPutInx</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">rsp_cmpl</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">mask</span> <span class="o">&amp;</span> <span class="n">HA_R0RE_REQ</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">pring</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">iocb_rsp_full</span><span class="o">++</span><span class="p">;</span>
		<span class="n">status</span> <span class="o">=</span> <span class="p">((</span><span class="n">CA_R0ATT</span> <span class="o">|</span> <span class="n">CA_R0RE_RSP</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">pring</span><span class="o">-&gt;</span><span class="n">ringno</span> <span class="o">*</span> <span class="mi">4</span><span class="p">));</span>
		<span class="n">writel</span><span class="p">(</span><span class="n">status</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">CAregaddr</span><span class="p">);</span>
		<span class="n">readl</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">CAregaddr</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">mask</span> <span class="o">&amp;</span> <span class="n">HA_R0CE_RSP</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">pring</span><span class="o">-&gt;</span><span class="n">flag</span> <span class="o">&amp;</span> <span class="n">LPFC_CALL_RING_AVAILABLE</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">pring</span><span class="o">-&gt;</span><span class="n">flag</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">LPFC_CALL_RING_AVAILABLE</span><span class="p">;</span>
		<span class="n">pring</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">iocb_cmd_empty</span><span class="o">++</span><span class="p">;</span>

		<span class="cm">/* Force update of the local copy of cmdGetInx */</span>
		<span class="n">pring</span><span class="o">-&gt;</span><span class="n">local_getidx</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">pgp</span><span class="o">-&gt;</span><span class="n">cmdGetInx</span><span class="p">);</span>
		<span class="n">lpfc_sli_resume_iocb</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">pring</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">((</span><span class="n">pring</span><span class="o">-&gt;</span><span class="n">lpfc_sli_cmd_available</span><span class="p">))</span>
			<span class="p">(</span><span class="n">pring</span><span class="o">-&gt;</span><span class="n">lpfc_sli_cmd_available</span><span class="p">)</span> <span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">pring</span><span class="p">);</span>

	<span class="p">}</span>

	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">fcp_ring_in_use</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">,</span> <span class="n">iflag</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_sli_sp_handle_rspiocb - Handle slow-path response iocb</span>
<span class="cm"> * @phba: Pointer to HBA context object.</span>
<span class="cm"> * @pring: Pointer to driver SLI ring object.</span>
<span class="cm"> * @rspiocbp: Pointer to driver response IOCB object.</span>
<span class="cm"> *</span>
<span class="cm"> * This function is called from the worker thread when there is a slow-path</span>
<span class="cm"> * response IOCB to process. This function chains all the response iocbs until</span>
<span class="cm"> * seeing the iocb with the LE bit set. The function will call</span>
<span class="cm"> * lpfc_sli_process_sol_iocb function if the response iocb indicates a</span>
<span class="cm"> * completion of a command iocb. The function will call the</span>
<span class="cm"> * lpfc_sli_process_unsol_iocb function if this is an unsolicited iocb.</span>
<span class="cm"> * The function frees the resources or calls the completion handler if this</span>
<span class="cm"> * iocb is an abort completion. The function returns NULL when the response</span>
<span class="cm"> * iocb has the LE bit set and all the chained iocbs are processed, otherwise</span>
<span class="cm"> * this function shall chain the iocb on to the iocb_continueq and return the</span>
<span class="cm"> * response iocb passed in.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">lpfc_iocbq</span> <span class="o">*</span>
<span class="nf">lpfc_sli_sp_handle_rspiocb</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">,</span> <span class="k">struct</span> <span class="n">lpfc_sli_ring</span> <span class="o">*</span><span class="n">pring</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">lpfc_iocbq</span> <span class="o">*</span><span class="n">rspiocbp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpfc_iocbq</span> <span class="o">*</span><span class="n">saveq</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_iocbq</span> <span class="o">*</span><span class="n">cmdiocbp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_iocbq</span> <span class="o">*</span><span class="n">next_iocb</span><span class="p">;</span>
	<span class="n">IOCB_t</span> <span class="o">*</span><span class="n">irsp</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">free_saveq</span><span class="p">;</span>
	<span class="kt">uint8_t</span> <span class="n">iocb_cmd_type</span><span class="p">;</span>
	<span class="n">lpfc_iocb_type</span> <span class="n">type</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">iflag</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">,</span> <span class="n">iflag</span><span class="p">);</span>
	<span class="cm">/* First add the response iocb to the countinueq list */</span>
	<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rspiocbp</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">pring</span><span class="o">-&gt;</span><span class="n">iocb_continueq</span><span class="p">));</span>
	<span class="n">pring</span><span class="o">-&gt;</span><span class="n">iocb_continueq_cnt</span><span class="o">++</span><span class="p">;</span>

	<span class="cm">/* Now, determine whether the list is completed for processing */</span>
	<span class="n">irsp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">rspiocbp</span><span class="o">-&gt;</span><span class="n">iocb</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">irsp</span><span class="o">-&gt;</span><span class="n">ulpLe</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * By default, the driver expects to free all resources</span>
<span class="cm">		 * associated with this iocb completion.</span>
<span class="cm">		 */</span>
		<span class="n">free_saveq</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">saveq</span> <span class="o">=</span> <span class="n">list_get_first</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pring</span><span class="o">-&gt;</span><span class="n">iocb_continueq</span><span class="p">,</span>
				       <span class="k">struct</span> <span class="n">lpfc_iocbq</span><span class="p">,</span> <span class="n">list</span><span class="p">);</span>
		<span class="n">irsp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">saveq</span><span class="o">-&gt;</span><span class="n">iocb</span><span class="p">);</span>
		<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pring</span><span class="o">-&gt;</span><span class="n">iocb_continueq</span><span class="p">);</span>
		<span class="n">pring</span><span class="o">-&gt;</span><span class="n">iocb_continueq_cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="n">pring</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">iocb_rsp</span><span class="o">++</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * If resource errors reported from HBA, reduce</span>
<span class="cm">		 * queuedepths of the SCSI device.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">irsp</span><span class="o">-&gt;</span><span class="n">ulpStatus</span> <span class="o">==</span> <span class="n">IOSTAT_LOCAL_REJECT</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="p">(</span><span class="n">irsp</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">ulpWord</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">==</span> <span class="n">IOERR_NO_RESOURCES</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">,</span> <span class="n">iflag</span><span class="p">);</span>
			<span class="n">phba</span><span class="o">-&gt;</span><span class="n">lpfc_rampdown_queue_depth</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
			<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">,</span> <span class="n">iflag</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">irsp</span><span class="o">-&gt;</span><span class="n">ulpStatus</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Rsp ring &lt;ringno&gt; error: IOCB */</span>
			<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_WARNING</span><span class="p">,</span> <span class="n">LOG_SLI</span><span class="p">,</span>
					<span class="s">&quot;0328 Rsp Ring %d error: &quot;</span>
					<span class="s">&quot;IOCB Data: &quot;</span>
					<span class="s">&quot;x%x x%x x%x x%x &quot;</span>
					<span class="s">&quot;x%x x%x x%x x%x &quot;</span>
					<span class="s">&quot;x%x x%x x%x x%x &quot;</span>
					<span class="s">&quot;x%x x%x x%x x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">pring</span><span class="o">-&gt;</span><span class="n">ringno</span><span class="p">,</span>
					<span class="n">irsp</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">ulpWord</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
					<span class="n">irsp</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">ulpWord</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
					<span class="n">irsp</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">ulpWord</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span>
					<span class="n">irsp</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">ulpWord</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span>
					<span class="n">irsp</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">ulpWord</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span>
					<span class="n">irsp</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">ulpWord</span><span class="p">[</span><span class="mi">5</span><span class="p">],</span>
					<span class="o">*</span><span class="p">(((</span><span class="kt">uint32_t</span> <span class="o">*</span><span class="p">)</span> <span class="n">irsp</span><span class="p">)</span> <span class="o">+</span> <span class="mi">6</span><span class="p">),</span>
					<span class="o">*</span><span class="p">(((</span><span class="kt">uint32_t</span> <span class="o">*</span><span class="p">)</span> <span class="n">irsp</span><span class="p">)</span> <span class="o">+</span> <span class="mi">7</span><span class="p">),</span>
					<span class="o">*</span><span class="p">(((</span><span class="kt">uint32_t</span> <span class="o">*</span><span class="p">)</span> <span class="n">irsp</span><span class="p">)</span> <span class="o">+</span> <span class="mi">8</span><span class="p">),</span>
					<span class="o">*</span><span class="p">(((</span><span class="kt">uint32_t</span> <span class="o">*</span><span class="p">)</span> <span class="n">irsp</span><span class="p">)</span> <span class="o">+</span> <span class="mi">9</span><span class="p">),</span>
					<span class="o">*</span><span class="p">(((</span><span class="kt">uint32_t</span> <span class="o">*</span><span class="p">)</span> <span class="n">irsp</span><span class="p">)</span> <span class="o">+</span> <span class="mi">10</span><span class="p">),</span>
					<span class="o">*</span><span class="p">(((</span><span class="kt">uint32_t</span> <span class="o">*</span><span class="p">)</span> <span class="n">irsp</span><span class="p">)</span> <span class="o">+</span> <span class="mi">11</span><span class="p">),</span>
					<span class="o">*</span><span class="p">(((</span><span class="kt">uint32_t</span> <span class="o">*</span><span class="p">)</span> <span class="n">irsp</span><span class="p">)</span> <span class="o">+</span> <span class="mi">12</span><span class="p">),</span>
					<span class="o">*</span><span class="p">(((</span><span class="kt">uint32_t</span> <span class="o">*</span><span class="p">)</span> <span class="n">irsp</span><span class="p">)</span> <span class="o">+</span> <span class="mi">13</span><span class="p">),</span>
					<span class="o">*</span><span class="p">(((</span><span class="kt">uint32_t</span> <span class="o">*</span><span class="p">)</span> <span class="n">irsp</span><span class="p">)</span> <span class="o">+</span> <span class="mi">14</span><span class="p">),</span>
					<span class="o">*</span><span class="p">(((</span><span class="kt">uint32_t</span> <span class="o">*</span><span class="p">)</span> <span class="n">irsp</span><span class="p">)</span> <span class="o">+</span> <span class="mi">15</span><span class="p">));</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 * Fetch the IOCB command type and call the correct completion</span>
<span class="cm">		 * routine. Solicited and Unsolicited IOCBs on the ELS ring</span>
<span class="cm">		 * get freed back to the lpfc_iocb_list by the discovery</span>
<span class="cm">		 * kernel thread.</span>
<span class="cm">		 */</span>
		<span class="n">iocb_cmd_type</span> <span class="o">=</span> <span class="n">irsp</span><span class="o">-&gt;</span><span class="n">ulpCommand</span> <span class="o">&amp;</span> <span class="n">CMD_IOCB_MASK</span><span class="p">;</span>
		<span class="n">type</span> <span class="o">=</span> <span class="n">lpfc_sli_iocb_cmd_type</span><span class="p">(</span><span class="n">iocb_cmd_type</span><span class="p">);</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">type</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">LPFC_SOL_IOCB</span>:
			<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">,</span> <span class="n">iflag</span><span class="p">);</span>
			<span class="n">rc</span> <span class="o">=</span> <span class="n">lpfc_sli_process_sol_iocb</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">pring</span><span class="p">,</span> <span class="n">saveq</span><span class="p">);</span>
			<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">,</span> <span class="n">iflag</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">LPFC_UNSOL_IOCB</span>:
			<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">,</span> <span class="n">iflag</span><span class="p">);</span>
			<span class="n">rc</span> <span class="o">=</span> <span class="n">lpfc_sli_process_unsol_iocb</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">pring</span><span class="p">,</span> <span class="n">saveq</span><span class="p">);</span>
			<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">,</span> <span class="n">iflag</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rc</span><span class="p">)</span>
				<span class="n">free_saveq</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">LPFC_ABORT_IOCB</span>:
			<span class="n">cmdiocbp</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">irsp</span><span class="o">-&gt;</span><span class="n">ulpCommand</span> <span class="o">!=</span> <span class="n">CMD_XRI_ABORTED_CX</span><span class="p">)</span>
				<span class="n">cmdiocbp</span> <span class="o">=</span> <span class="n">lpfc_sli_iocbq_lookup</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">pring</span><span class="p">,</span>
								 <span class="n">saveq</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">cmdiocbp</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/* Call the specified completion routine */</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">cmdiocbp</span><span class="o">-&gt;</span><span class="n">iocb_cmpl</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">,</span>
							       <span class="n">iflag</span><span class="p">);</span>
					<span class="p">(</span><span class="n">cmdiocbp</span><span class="o">-&gt;</span><span class="n">iocb_cmpl</span><span class="p">)(</span><span class="n">phba</span><span class="p">,</span> <span class="n">cmdiocbp</span><span class="p">,</span>
							      <span class="n">saveq</span><span class="p">);</span>
					<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">,</span>
							  <span class="n">iflag</span><span class="p">);</span>
				<span class="p">}</span> <span class="k">else</span>
					<span class="n">__lpfc_sli_release_iocbq</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span>
								 <span class="n">cmdiocbp</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">LPFC_UNKNOWN_IOCB</span>:
			<span class="k">if</span> <span class="p">(</span><span class="n">irsp</span><span class="o">-&gt;</span><span class="n">ulpCommand</span> <span class="o">==</span> <span class="n">CMD_ADAPTER_MSG</span><span class="p">)</span> <span class="p">{</span>
				<span class="kt">char</span> <span class="n">adaptermsg</span><span class="p">[</span><span class="n">LPFC_MAX_ADPTMSG</span><span class="p">];</span>
				<span class="n">memset</span><span class="p">(</span><span class="n">adaptermsg</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">LPFC_MAX_ADPTMSG</span><span class="p">);</span>
				<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adaptermsg</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="p">(</span><span class="kt">uint8_t</span> <span class="o">*</span><span class="p">)</span><span class="n">irsp</span><span class="p">,</span>
				       <span class="n">MAX_MSG_DATA</span><span class="p">);</span>
				<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="p">((</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">pcidev</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">),</span>
					 <span class="s">&quot;lpfc%d: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					 <span class="n">phba</span><span class="o">-&gt;</span><span class="n">brd_no</span><span class="p">,</span> <span class="n">adaptermsg</span><span class="p">);</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="cm">/* Unknown IOCB command */</span>
				<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_SLI</span><span class="p">,</span>
						<span class="s">&quot;0335 Unknown IOCB &quot;</span>
						<span class="s">&quot;command Data: x%x &quot;</span>
						<span class="s">&quot;x%x x%x x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
						<span class="n">irsp</span><span class="o">-&gt;</span><span class="n">ulpCommand</span><span class="p">,</span>
						<span class="n">irsp</span><span class="o">-&gt;</span><span class="n">ulpStatus</span><span class="p">,</span>
						<span class="n">irsp</span><span class="o">-&gt;</span><span class="n">ulpIoTag</span><span class="p">,</span>
						<span class="n">irsp</span><span class="o">-&gt;</span><span class="n">ulpContext</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">free_saveq</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">rspiocbp</span><span class="p">,</span> <span class="n">next_iocb</span><span class="p">,</span>
						 <span class="o">&amp;</span><span class="n">saveq</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rspiocbp</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
				<span class="n">__lpfc_sli_release_iocbq</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">rspiocbp</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="n">__lpfc_sli_release_iocbq</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">saveq</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">rspiocbp</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">,</span> <span class="n">iflag</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">rspiocbp</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_sli_handle_slow_ring_event - Wrapper func for handling slow-path iocbs</span>
<span class="cm"> * @phba: Pointer to HBA context object.</span>
<span class="cm"> * @pring: Pointer to driver SLI ring object.</span>
<span class="cm"> * @mask: Host attention register mask for this ring.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine wraps the actual slow_ring event process routine from the</span>
<span class="cm"> * API jump table function pointer from the lpfc_hba struct.</span>
<span class="cm"> **/</span>
<span class="kt">void</span>
<span class="nf">lpfc_sli_handle_slow_ring_event</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">lpfc_sli_ring</span> <span class="o">*</span><span class="n">pring</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">mask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">lpfc_sli_handle_slow_ring_event</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">pring</span><span class="p">,</span> <span class="n">mask</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_sli_handle_slow_ring_event_s3 - Handle SLI3 ring event for non-FCP rings</span>
<span class="cm"> * @phba: Pointer to HBA context object.</span>
<span class="cm"> * @pring: Pointer to driver SLI ring object.</span>
<span class="cm"> * @mask: Host attention register mask for this ring.</span>
<span class="cm"> *</span>
<span class="cm"> * This function is called from the worker thread when there is a ring event</span>
<span class="cm"> * for non-fcp rings. The caller does not hold any lock. The function will</span>
<span class="cm"> * remove each response iocb in the response ring and calls the handle</span>
<span class="cm"> * response iocb routine (lpfc_sli_sp_handle_rspiocb) to process it.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">lpfc_sli_handle_slow_ring_event_s3</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">lpfc_sli_ring</span> <span class="o">*</span><span class="n">pring</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">mask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpfc_pgp</span> <span class="o">*</span><span class="n">pgp</span><span class="p">;</span>
	<span class="n">IOCB_t</span> <span class="o">*</span><span class="n">entry</span><span class="p">;</span>
	<span class="n">IOCB_t</span> <span class="o">*</span><span class="n">irsp</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_iocbq</span> <span class="o">*</span><span class="n">rspiocbp</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">portRspPut</span><span class="p">,</span> <span class="n">portRspMax</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">iflag</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">status</span><span class="p">;</span>

	<span class="n">pgp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">port_gp</span><span class="p">[</span><span class="n">pring</span><span class="o">-&gt;</span><span class="n">ringno</span><span class="p">];</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">,</span> <span class="n">iflag</span><span class="p">);</span>
	<span class="n">pring</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">iocb_event</span><span class="o">++</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * The next available response entry should never exceed the maximum</span>
<span class="cm">	 * entries.  If it does, treat it as an adapter hardware error.</span>
<span class="cm">	 */</span>
	<span class="n">portRspMax</span> <span class="o">=</span> <span class="n">pring</span><span class="o">-&gt;</span><span class="n">numRiocb</span><span class="p">;</span>
	<span class="n">portRspPut</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">pgp</span><span class="o">-&gt;</span><span class="n">rspPutInx</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">portRspPut</span> <span class="o">&gt;=</span> <span class="n">portRspMax</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Ring &lt;ringno&gt; handler: portRspPut &lt;portRspPut&gt; is bigger than</span>
<span class="cm">		 * rsp ring &lt;portRspMax&gt;</span>
<span class="cm">		 */</span>
		<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_SLI</span><span class="p">,</span>
				<span class="s">&quot;0303 Ring %d handler: portRspPut %d &quot;</span>
				<span class="s">&quot;is bigger than rsp ring %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">pring</span><span class="o">-&gt;</span><span class="n">ringno</span><span class="p">,</span> <span class="n">portRspPut</span><span class="p">,</span> <span class="n">portRspMax</span><span class="p">);</span>

		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">link_state</span> <span class="o">=</span> <span class="n">LPFC_HBA_ERROR</span><span class="p">;</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">,</span> <span class="n">iflag</span><span class="p">);</span>

		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">work_hs</span> <span class="o">=</span> <span class="n">HS_FFER3</span><span class="p">;</span>
		<span class="n">lpfc_handle_eratt</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>

		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">rmb</span><span class="p">();</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">pring</span><span class="o">-&gt;</span><span class="n">rspidx</span> <span class="o">!=</span> <span class="n">portRspPut</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Build a completion list and call the appropriate handler.</span>
<span class="cm">		 * The process is to get the next available response iocb, get</span>
<span class="cm">		 * a free iocb from the list, copy the response data into the</span>
<span class="cm">		 * free iocb, insert to the continuation list, and update the</span>
<span class="cm">		 * next response index to slim.  This process makes response</span>
<span class="cm">		 * iocb&#39;s in the ring available to DMA as fast as possible but</span>
<span class="cm">		 * pays a penalty for a copy operation.  Since the iocb is</span>
<span class="cm">		 * only 32 bytes, this penalty is considered small relative to</span>
<span class="cm">		 * the PCI reads for register values and a slim write.  When</span>
<span class="cm">		 * the ulpLe field is set, the entire Command has been</span>
<span class="cm">		 * received.</span>
<span class="cm">		 */</span>
		<span class="n">entry</span> <span class="o">=</span> <span class="n">lpfc_resp_iocb</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">pring</span><span class="p">);</span>

		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">last_completion_time</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span>
		<span class="n">rspiocbp</span> <span class="o">=</span> <span class="n">__lpfc_sli_get_iocbq</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rspiocbp</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;%s: out of buffers! Failing &quot;</span>
			       <span class="s">&quot;completion.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">lpfc_sli_pcimem_bcopy</span><span class="p">(</span><span class="n">entry</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rspiocbp</span><span class="o">-&gt;</span><span class="n">iocb</span><span class="p">,</span>
				      <span class="n">phba</span><span class="o">-&gt;</span><span class="n">iocb_rsp_size</span><span class="p">);</span>
		<span class="n">irsp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">rspiocbp</span><span class="o">-&gt;</span><span class="n">iocb</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">++</span><span class="n">pring</span><span class="o">-&gt;</span><span class="n">rspidx</span> <span class="o">&gt;=</span> <span class="n">portRspMax</span><span class="p">)</span>
			<span class="n">pring</span><span class="o">-&gt;</span><span class="n">rspidx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">pring</span><span class="o">-&gt;</span><span class="n">ringno</span> <span class="o">==</span> <span class="n">LPFC_ELS_RING</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">lpfc_debugfs_slow_ring_trc</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span>
			<span class="s">&quot;IOCB rsp ring:   wd4:x%08x wd6:x%08x wd7:x%08x&quot;</span><span class="p">,</span>
				<span class="o">*</span><span class="p">(((</span><span class="kt">uint32_t</span> <span class="o">*</span><span class="p">)</span> <span class="n">irsp</span><span class="p">)</span> <span class="o">+</span> <span class="mi">4</span><span class="p">),</span>
				<span class="o">*</span><span class="p">(((</span><span class="kt">uint32_t</span> <span class="o">*</span><span class="p">)</span> <span class="n">irsp</span><span class="p">)</span> <span class="o">+</span> <span class="mi">6</span><span class="p">),</span>
				<span class="o">*</span><span class="p">(((</span><span class="kt">uint32_t</span> <span class="o">*</span><span class="p">)</span> <span class="n">irsp</span><span class="p">)</span> <span class="o">+</span> <span class="mi">7</span><span class="p">));</span>
		<span class="p">}</span>

		<span class="n">writel</span><span class="p">(</span><span class="n">pring</span><span class="o">-&gt;</span><span class="n">rspidx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">host_gp</span><span class="p">[</span><span class="n">pring</span><span class="o">-&gt;</span><span class="n">ringno</span><span class="p">].</span><span class="n">rspGetInx</span><span class="p">);</span>

		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">,</span> <span class="n">iflag</span><span class="p">);</span>
		<span class="cm">/* Handle the response IOCB */</span>
		<span class="n">rspiocbp</span> <span class="o">=</span> <span class="n">lpfc_sli_sp_handle_rspiocb</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">pring</span><span class="p">,</span> <span class="n">rspiocbp</span><span class="p">);</span>
		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">,</span> <span class="n">iflag</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * If the port response put pointer has not been updated, sync</span>
<span class="cm">		 * the pgp-&gt;rspPutInx in the MAILBOX_tand fetch the new port</span>
<span class="cm">		 * response put pointer.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pring</span><span class="o">-&gt;</span><span class="n">rspidx</span> <span class="o">==</span> <span class="n">portRspPut</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">portRspPut</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">pgp</span><span class="o">-&gt;</span><span class="n">rspPutInx</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="cm">/* while (pring-&gt;rspidx != portRspPut) */</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">rspiocbp</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">mask</span> <span class="o">&amp;</span> <span class="n">HA_R0RE_REQ</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* At least one response entry has been freed */</span>
		<span class="n">pring</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">iocb_rsp_full</span><span class="o">++</span><span class="p">;</span>
		<span class="cm">/* SET RxRE_RSP in Chip Att register */</span>
		<span class="n">status</span> <span class="o">=</span> <span class="p">((</span><span class="n">CA_R0ATT</span> <span class="o">|</span> <span class="n">CA_R0RE_RSP</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">pring</span><span class="o">-&gt;</span><span class="n">ringno</span> <span class="o">*</span> <span class="mi">4</span><span class="p">));</span>
		<span class="n">writel</span><span class="p">(</span><span class="n">status</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">CAregaddr</span><span class="p">);</span>
		<span class="n">readl</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">CAregaddr</span><span class="p">);</span> <span class="cm">/* flush */</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">mask</span> <span class="o">&amp;</span> <span class="n">HA_R0CE_RSP</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">pring</span><span class="o">-&gt;</span><span class="n">flag</span> <span class="o">&amp;</span> <span class="n">LPFC_CALL_RING_AVAILABLE</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">pring</span><span class="o">-&gt;</span><span class="n">flag</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">LPFC_CALL_RING_AVAILABLE</span><span class="p">;</span>
		<span class="n">pring</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">iocb_cmd_empty</span><span class="o">++</span><span class="p">;</span>

		<span class="cm">/* Force update of the local copy of cmdGetInx */</span>
		<span class="n">pring</span><span class="o">-&gt;</span><span class="n">local_getidx</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">pgp</span><span class="o">-&gt;</span><span class="n">cmdGetInx</span><span class="p">);</span>
		<span class="n">lpfc_sli_resume_iocb</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">pring</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">((</span><span class="n">pring</span><span class="o">-&gt;</span><span class="n">lpfc_sli_cmd_available</span><span class="p">))</span>
			<span class="p">(</span><span class="n">pring</span><span class="o">-&gt;</span><span class="n">lpfc_sli_cmd_available</span><span class="p">)</span> <span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">pring</span><span class="p">);</span>

	<span class="p">}</span>

	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">,</span> <span class="n">iflag</span><span class="p">);</span>
	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_sli_handle_slow_ring_event_s4 - Handle SLI4 slow-path els events</span>
<span class="cm"> * @phba: Pointer to HBA context object.</span>
<span class="cm"> * @pring: Pointer to driver SLI ring object.</span>
<span class="cm"> * @mask: Host attention register mask for this ring.</span>
<span class="cm"> *</span>
<span class="cm"> * This function is called from the worker thread when there is a pending</span>
<span class="cm"> * ELS response iocb on the driver internal slow-path response iocb worker</span>
<span class="cm"> * queue. The caller does not hold any lock. The function will remove each</span>
<span class="cm"> * response iocb from the response worker queue and calls the handle</span>
<span class="cm"> * response iocb routine (lpfc_sli_sp_handle_rspiocb) to process it.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">lpfc_sli_handle_slow_ring_event_s4</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">lpfc_sli_ring</span> <span class="o">*</span><span class="n">pring</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">mask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpfc_iocbq</span> <span class="o">*</span><span class="n">irspiocbq</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hbq_dmabuf</span> <span class="o">*</span><span class="n">dmabuf</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_cq_event</span> <span class="o">*</span><span class="n">cq_event</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">iflag</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">,</span> <span class="n">iflag</span><span class="p">);</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">hba_flag</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">HBA_SP_QUEUE_EVT</span><span class="p">;</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">,</span> <span class="n">iflag</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">sp_queue_event</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* Get the response iocb from the head of work queue */</span>
		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">,</span> <span class="n">iflag</span><span class="p">);</span>
		<span class="n">list_remove_head</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">sp_queue_event</span><span class="p">,</span>
				 <span class="n">cq_event</span><span class="p">,</span> <span class="k">struct</span> <span class="n">lpfc_cq_event</span><span class="p">,</span> <span class="n">list</span><span class="p">);</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">,</span> <span class="n">iflag</span><span class="p">);</span>

		<span class="k">switch</span> <span class="p">(</span><span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_wcqe_c_code</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cq_event</span><span class="o">-&gt;</span><span class="n">cqe</span><span class="p">.</span><span class="n">wcqe_cmpl</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">CQE_CODE_COMPL_WQE</span>:
			<span class="n">irspiocbq</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">cq_event</span><span class="p">,</span> <span class="k">struct</span> <span class="n">lpfc_iocbq</span><span class="p">,</span>
						 <span class="n">cq_event</span><span class="p">);</span>
			<span class="cm">/* Translate ELS WCQE to response IOCBQ */</span>
			<span class="n">irspiocbq</span> <span class="o">=</span> <span class="n">lpfc_sli4_els_wcqe_to_rspiocbq</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span>
								   <span class="n">irspiocbq</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">irspiocbq</span><span class="p">)</span>
				<span class="n">lpfc_sli_sp_handle_rspiocb</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">pring</span><span class="p">,</span>
							   <span class="n">irspiocbq</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">CQE_CODE_RECEIVE</span>:
		<span class="k">case</span> <span class="n">CQE_CODE_RECEIVE_V1</span>:
			<span class="n">dmabuf</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">cq_event</span><span class="p">,</span> <span class="k">struct</span> <span class="n">hbq_dmabuf</span><span class="p">,</span>
					      <span class="n">cq_event</span><span class="p">);</span>
			<span class="n">lpfc_sli4_handle_received_buffer</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">dmabuf</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="nl">default:</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_sli_abort_iocb_ring - Abort all iocbs in the ring</span>
<span class="cm"> * @phba: Pointer to HBA context object.</span>
<span class="cm"> * @pring: Pointer to driver SLI ring object.</span>
<span class="cm"> *</span>
<span class="cm"> * This function aborts all iocbs in the given ring and frees all the iocb</span>
<span class="cm"> * objects in txq. This function issues an abort iocb for all the iocb commands</span>
<span class="cm"> * in txcmplq. The iocbs in the txcmplq is not guaranteed to complete before</span>
<span class="cm"> * the return of this function. The caller is not required to hold any locks.</span>
<span class="cm"> **/</span>
<span class="kt">void</span>
<span class="nf">lpfc_sli_abort_iocb_ring</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">,</span> <span class="k">struct</span> <span class="n">lpfc_sli_ring</span> <span class="o">*</span><span class="n">pring</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">LIST_HEAD</span><span class="p">(</span><span class="n">completions</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">lpfc_iocbq</span> <span class="o">*</span><span class="n">iocb</span><span class="p">,</span> <span class="o">*</span><span class="n">next_iocb</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pring</span><span class="o">-&gt;</span><span class="n">ringno</span> <span class="o">==</span> <span class="n">LPFC_ELS_RING</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lpfc_fabric_abort_hba</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Error everything on txq and txcmplq</span>
<span class="cm">	 * First do the txq.</span>
<span class="cm">	 */</span>
	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>
	<span class="n">list_splice_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pring</span><span class="o">-&gt;</span><span class="n">txq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">completions</span><span class="p">);</span>
	<span class="n">pring</span><span class="o">-&gt;</span><span class="n">txq_cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Next issue ABTS for everything on the txcmplq */</span>
	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">iocb</span><span class="p">,</span> <span class="n">next_iocb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pring</span><span class="o">-&gt;</span><span class="n">txcmplq</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span>
		<span class="n">lpfc_sli_issue_abort_iotag</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">pring</span><span class="p">,</span> <span class="n">iocb</span><span class="p">);</span>

	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>

	<span class="cm">/* Cancel all the IOCBs from the completions list */</span>
	<span class="n">lpfc_sli_cancel_iocbs</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">completions</span><span class="p">,</span> <span class="n">IOSTAT_LOCAL_REJECT</span><span class="p">,</span>
			      <span class="n">IOERR_SLI_ABORTED</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_sli_flush_fcp_rings - flush all iocbs in the fcp ring</span>
<span class="cm"> * @phba: Pointer to HBA context object.</span>
<span class="cm"> *</span>
<span class="cm"> * This function flushes all iocbs in the fcp ring and frees all the iocb</span>
<span class="cm"> * objects in txq and txcmplq. This function will not issue abort iocbs</span>
<span class="cm"> * for all the iocb commands in txcmplq, they will just be returned with</span>
<span class="cm"> * IOERR_SLI_DOWN. This function is invoked with EEH when device&#39;s PCI</span>
<span class="cm"> * slot has been permanently disabled.</span>
<span class="cm"> **/</span>
<span class="kt">void</span>
<span class="nf">lpfc_sli_flush_fcp_rings</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">LIST_HEAD</span><span class="p">(</span><span class="n">txq</span><span class="p">);</span>
	<span class="n">LIST_HEAD</span><span class="p">(</span><span class="n">txcmplq</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">lpfc_sli</span> <span class="o">*</span><span class="n">psli</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_sli_ring</span>  <span class="o">*</span><span class="n">pring</span><span class="p">;</span>

	<span class="cm">/* Currently, only one fcp ring */</span>
	<span class="n">pring</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">psli</span><span class="o">-&gt;</span><span class="n">ring</span><span class="p">[</span><span class="n">psli</span><span class="o">-&gt;</span><span class="n">fcp_ring</span><span class="p">];</span>

	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>
	<span class="cm">/* Retrieve everything on txq */</span>
	<span class="n">list_splice_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pring</span><span class="o">-&gt;</span><span class="n">txq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">txq</span><span class="p">);</span>
	<span class="n">pring</span><span class="o">-&gt;</span><span class="n">txq_cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Retrieve everything on the txcmplq */</span>
	<span class="n">list_splice_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pring</span><span class="o">-&gt;</span><span class="n">txcmplq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">txcmplq</span><span class="p">);</span>
	<span class="n">pring</span><span class="o">-&gt;</span><span class="n">txcmplq_cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Indicate the I/O queues are flushed */</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">hba_flag</span> <span class="o">|=</span> <span class="n">HBA_FCP_IOQ_FLUSH</span><span class="p">;</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>

	<span class="cm">/* Flush the txq */</span>
	<span class="n">lpfc_sli_cancel_iocbs</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">txq</span><span class="p">,</span> <span class="n">IOSTAT_LOCAL_REJECT</span><span class="p">,</span>
			      <span class="n">IOERR_SLI_DOWN</span><span class="p">);</span>

	<span class="cm">/* Flush the txcmpq */</span>
	<span class="n">lpfc_sli_cancel_iocbs</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">txcmplq</span><span class="p">,</span> <span class="n">IOSTAT_LOCAL_REJECT</span><span class="p">,</span>
			      <span class="n">IOERR_SLI_DOWN</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_sli_brdready_s3 - Check for sli3 host ready status</span>
<span class="cm"> * @phba: Pointer to HBA context object.</span>
<span class="cm"> * @mask: Bit mask to be checked.</span>
<span class="cm"> *</span>
<span class="cm"> * This function reads the host status register and compares</span>
<span class="cm"> * with the provided bit mask to check if HBA completed</span>
<span class="cm"> * the restart. This function will wait in a loop for the</span>
<span class="cm"> * HBA to complete restart. If the HBA does not restart within</span>
<span class="cm"> * 15 iterations, the function will reset the HBA again. The</span>
<span class="cm"> * function returns 1 when HBA fail to restart otherwise returns</span>
<span class="cm"> * zero.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">lpfc_sli_brdready_s3</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">mask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">uint32_t</span> <span class="n">status</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">retval</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Read the HBA Host Status Register */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">lpfc_readl</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">HSregaddr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">status</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Check status register every 100ms for 5 retries, then every</span>
<span class="cm">	 * 500ms for 5, then every 2.5 sec for 5, then reset board and</span>
<span class="cm">	 * every 2.5 sec for 4.</span>
<span class="cm">	 * Break our of the loop if errors occurred during init.</span>
<span class="cm">	 */</span>
	<span class="k">while</span> <span class="p">(((</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">mask</span><span class="p">)</span> <span class="o">!=</span> <span class="n">mask</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	       <span class="o">!</span><span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">HS_FFERM</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	       <span class="n">i</span><span class="o">++</span> <span class="o">&lt;</span> <span class="mi">20</span><span class="p">)</span> <span class="p">{</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;=</span> <span class="mi">5</span><span class="p">)</span>
			<span class="n">msleep</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;=</span> <span class="mi">10</span><span class="p">)</span>
			<span class="n">msleep</span><span class="p">(</span><span class="mi">500</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">msleep</span><span class="p">(</span><span class="mi">2500</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="mi">15</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/* Do post */</span>
			<span class="n">phba</span><span class="o">-&gt;</span><span class="n">pport</span><span class="o">-&gt;</span><span class="n">port_state</span> <span class="o">=</span> <span class="n">LPFC_VPORT_UNKNOWN</span><span class="p">;</span>
			<span class="n">lpfc_sli_brdrestart</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="cm">/* Read the HBA Host Status Register */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">lpfc_readl</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">HSregaddr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">status</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">retval</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* Check to see if any errors occurred during init */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">HS_FFERM</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">20</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_INIT</span><span class="p">,</span>
				<span class="s">&quot;2751 Adapter failed to restart, &quot;</span>
				<span class="s">&quot;status reg x%x, FW Data: A8 x%x AC x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">status</span><span class="p">,</span>
				<span class="n">readl</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">MBslimaddr</span> <span class="o">+</span> <span class="mh">0xa8</span><span class="p">),</span>
				<span class="n">readl</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">MBslimaddr</span> <span class="o">+</span> <span class="mh">0xac</span><span class="p">));</span>
		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">link_state</span> <span class="o">=</span> <span class="n">LPFC_HBA_ERROR</span><span class="p">;</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_sli_brdready_s4 - Check for sli4 host ready status</span>
<span class="cm"> * @phba: Pointer to HBA context object.</span>
<span class="cm"> * @mask: Bit mask to be checked.</span>
<span class="cm"> *</span>
<span class="cm"> * This function checks the host status register to check if HBA is</span>
<span class="cm"> * ready. This function will wait in a loop for the HBA to be ready</span>
<span class="cm"> * If the HBA is not ready , the function will will reset the HBA PCI</span>
<span class="cm"> * function again. The function returns 1 when HBA fail to be ready</span>
<span class="cm"> * otherwise returns zero.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">lpfc_sli_brdready_s4</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">mask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">uint32_t</span> <span class="n">status</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">retval</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Read the HBA Host Status Register */</span>
	<span class="n">status</span> <span class="o">=</span> <span class="n">lpfc_sli4_post_status_check</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">status</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">pport</span><span class="o">-&gt;</span><span class="n">port_state</span> <span class="o">=</span> <span class="n">LPFC_VPORT_UNKNOWN</span><span class="p">;</span>
		<span class="n">lpfc_sli_brdrestart</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">lpfc_sli4_post_status_check</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Check to see if any errors occurred during init */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">link_state</span> <span class="o">=</span> <span class="n">LPFC_HBA_ERROR</span><span class="p">;</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">intr_enable</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_sli_brdready - Wrapper func for checking the hba readyness</span>
<span class="cm"> * @phba: Pointer to HBA context object.</span>
<span class="cm"> * @mask: Bit mask to be checked.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine wraps the actual SLI3 or SLI4 hba readyness check routine</span>
<span class="cm"> * from the API jump table function pointer from the lpfc_hba struct.</span>
<span class="cm"> **/</span>
<span class="kt">int</span>
<span class="nf">lpfc_sli_brdready</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">mask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">lpfc_sli_brdready</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">mask</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#define BARRIER_TEST_PATTERN (0xdeadbeef)</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_reset_barrier - Make HBA ready for HBA reset</span>
<span class="cm"> * @phba: Pointer to HBA context object.</span>
<span class="cm"> *</span>
<span class="cm"> * This function is called before resetting an HBA. This function is called</span>
<span class="cm"> * with hbalock held and requests HBA to quiesce DMAs before a reset.</span>
<span class="cm"> **/</span>
<span class="kt">void</span> <span class="nf">lpfc_reset_barrier</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">uint32_t</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">resp_buf</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">mbox_buf</span><span class="p">;</span>
	<span class="k">volatile</span> <span class="kt">uint32_t</span> <span class="n">mbox</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">hc_copy</span><span class="p">,</span> <span class="n">ha_copy</span><span class="p">,</span> <span class="n">resp_data</span><span class="p">;</span>
	<span class="kt">int</span>  <span class="n">i</span><span class="p">;</span>
	<span class="kt">uint8_t</span> <span class="n">hdrtype</span><span class="p">;</span>

	<span class="n">pci_read_config_byte</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">pcidev</span><span class="p">,</span> <span class="n">PCI_HEADER_TYPE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hdrtype</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hdrtype</span> <span class="o">!=</span> <span class="mh">0x80</span> <span class="o">||</span>
	    <span class="p">(</span><span class="n">FC_JEDEC_ID</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">vpd</span><span class="p">.</span><span class="n">rev</span><span class="p">.</span><span class="n">biuRev</span><span class="p">)</span> <span class="o">!=</span> <span class="n">HELIOS_JEDEC_ID</span> <span class="o">&amp;&amp;</span>
	     <span class="n">FC_JEDEC_ID</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">vpd</span><span class="p">.</span><span class="n">rev</span><span class="p">.</span><span class="n">biuRev</span><span class="p">)</span> <span class="o">!=</span> <span class="n">THOR_JEDEC_ID</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Tell the other part of the chip to suspend temporarily all</span>
<span class="cm">	 * its DMA activity.</span>
<span class="cm">	 */</span>
	<span class="n">resp_buf</span> <span class="o">=</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">MBslimaddr</span><span class="p">;</span>

	<span class="cm">/* Disable the error attention */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">lpfc_readl</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">HCregaddr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hc_copy</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">writel</span><span class="p">((</span><span class="n">hc_copy</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">HC_ERINT_ENA</span><span class="p">),</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">HCregaddr</span><span class="p">);</span>
	<span class="n">readl</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">HCregaddr</span><span class="p">);</span> <span class="cm">/* flush */</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">link_flag</span> <span class="o">|=</span> <span class="n">LS_IGNORE_ERATT</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">lpfc_readl</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">HAregaddr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ha_copy</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ha_copy</span> <span class="o">&amp;</span> <span class="n">HA_ERATT</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Clear Chip error bit */</span>
		<span class="n">writel</span><span class="p">(</span><span class="n">HA_ERATT</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">HAregaddr</span><span class="p">);</span>
		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">pport</span><span class="o">-&gt;</span><span class="n">stopped</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">mbox</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">((</span><span class="n">MAILBOX_t</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">mbox</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">mbxCommand</span> <span class="o">=</span> <span class="n">MBX_KILL_BOARD</span><span class="p">;</span>
	<span class="p">((</span><span class="n">MAILBOX_t</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">mbox</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">mbxOwner</span> <span class="o">=</span> <span class="n">OWN_CHIP</span><span class="p">;</span>

	<span class="n">writel</span><span class="p">(</span><span class="n">BARRIER_TEST_PATTERN</span><span class="p">,</span> <span class="p">(</span><span class="n">resp_buf</span> <span class="o">+</span> <span class="mi">1</span><span class="p">));</span>
	<span class="n">mbox_buf</span> <span class="o">=</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">MBslimaddr</span><span class="p">;</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">mbox</span><span class="p">,</span> <span class="n">mbox_buf</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">50</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">lpfc_readl</span><span class="p">((</span><span class="n">resp_buf</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">resp_data</span><span class="p">))</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">resp_data</span> <span class="o">!=</span> <span class="o">~</span><span class="p">(</span><span class="n">BARRIER_TEST_PATTERN</span><span class="p">))</span>
			<span class="n">mdelay</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">resp_data</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">lpfc_readl</span><span class="p">((</span><span class="n">resp_buf</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">resp_data</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">resp_data</span>  <span class="o">!=</span> <span class="o">~</span><span class="p">(</span><span class="n">BARRIER_TEST_PATTERN</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli</span><span class="p">.</span><span class="n">sli_flag</span> <span class="o">&amp;</span> <span class="n">LPFC_SLI_ACTIVE</span> <span class="o">||</span>
		    <span class="n">phba</span><span class="o">-&gt;</span><span class="n">pport</span><span class="o">-&gt;</span><span class="n">stopped</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">restore_hc</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="k">goto</span> <span class="n">clear_errat</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="p">((</span><span class="n">MAILBOX_t</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">mbox</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">mbxOwner</span> <span class="o">=</span> <span class="n">OWN_HOST</span><span class="p">;</span>
	<span class="n">resp_data</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">500</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">lpfc_readl</span><span class="p">(</span><span class="n">resp_buf</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">resp_data</span><span class="p">))</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">resp_data</span> <span class="o">!=</span> <span class="n">mbox</span><span class="p">)</span>
			<span class="n">mdelay</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

<span class="nl">clear_errat:</span>

	<span class="k">while</span> <span class="p">(</span><span class="o">++</span><span class="n">i</span> <span class="o">&lt;</span> <span class="mi">500</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">lpfc_readl</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">HAregaddr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ha_copy</span><span class="p">))</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">ha_copy</span> <span class="o">&amp;</span> <span class="n">HA_ERATT</span><span class="p">))</span>
			<span class="n">mdelay</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">readl</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">HAregaddr</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">HA_ERATT</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">writel</span><span class="p">(</span><span class="n">HA_ERATT</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">HAregaddr</span><span class="p">);</span>
		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">pport</span><span class="o">-&gt;</span><span class="n">stopped</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

<span class="nl">restore_hc:</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">link_flag</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">LS_IGNORE_ERATT</span><span class="p">;</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">hc_copy</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">HCregaddr</span><span class="p">);</span>
	<span class="n">readl</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">HCregaddr</span><span class="p">);</span> <span class="cm">/* flush */</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_sli_brdkill - Issue a kill_board mailbox command</span>
<span class="cm"> * @phba: Pointer to HBA context object.</span>
<span class="cm"> *</span>
<span class="cm"> * This function issues a kill_board mailbox command and waits for</span>
<span class="cm"> * the error attention interrupt. This function is called for stopping</span>
<span class="cm"> * the firmware processing. The caller is not required to hold any</span>
<span class="cm"> * locks. This function calls lpfc_hba_down_post function to free</span>
<span class="cm"> * any pending commands after the kill. The function will return 1 when it</span>
<span class="cm"> * fails to kill the board else will return 0.</span>
<span class="cm"> **/</span>
<span class="kt">int</span>
<span class="nf">lpfc_sli_brdkill</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpfc_sli</span> <span class="o">*</span><span class="n">psli</span><span class="p">;</span>
	<span class="n">LPFC_MBOXQ_t</span> <span class="o">*</span><span class="n">pmb</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">status</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">ha_copy</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">retval</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">psli</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli</span><span class="p">;</span>

	<span class="cm">/* Kill HBA */</span>
	<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_INFO</span><span class="p">,</span> <span class="n">LOG_SLI</span><span class="p">,</span>
			<span class="s">&quot;0329 Kill HBA Data: x%x x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">phba</span><span class="o">-&gt;</span><span class="n">pport</span><span class="o">-&gt;</span><span class="n">port_state</span><span class="p">,</span> <span class="n">psli</span><span class="o">-&gt;</span><span class="n">sli_flag</span><span class="p">);</span>

	<span class="n">pmb</span> <span class="o">=</span> <span class="p">(</span><span class="n">LPFC_MBOXQ_t</span> <span class="o">*</span><span class="p">)</span> <span class="n">mempool_alloc</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">mbox_mem_pool</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pmb</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/* Disable the error attention */</span>
	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">lpfc_readl</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">HCregaddr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">status</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>
		<span class="n">mempool_free</span><span class="p">(</span><span class="n">pmb</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">mbox_mem_pool</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">status</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">HC_ERINT_ENA</span><span class="p">;</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">status</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">HCregaddr</span><span class="p">);</span>
	<span class="n">readl</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">HCregaddr</span><span class="p">);</span> <span class="cm">/* flush */</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">link_flag</span> <span class="o">|=</span> <span class="n">LS_IGNORE_ERATT</span><span class="p">;</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>

	<span class="n">lpfc_kill_board</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">pmb</span><span class="p">);</span>
	<span class="n">pmb</span><span class="o">-&gt;</span><span class="n">mbox_cmpl</span> <span class="o">=</span> <span class="n">lpfc_sli_def_mbox_cmpl</span><span class="p">;</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="n">lpfc_sli_issue_mbox</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">pmb</span><span class="p">,</span> <span class="n">MBX_NOWAIT</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span> <span class="o">!=</span> <span class="n">MBX_SUCCESS</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">retval</span> <span class="o">!=</span> <span class="n">MBX_BUSY</span><span class="p">)</span>
			<span class="n">mempool_free</span><span class="p">(</span><span class="n">pmb</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">mbox_mem_pool</span><span class="p">);</span>
		<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_SLI</span><span class="p">,</span>
				<span class="s">&quot;2752 KILL_BOARD command failed retval %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">retval</span><span class="p">);</span>
		<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>
		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">link_flag</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">LS_IGNORE_ERATT</span><span class="p">;</span>
		<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>
	<span class="n">psli</span><span class="o">-&gt;</span><span class="n">sli_flag</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">LPFC_SLI_ACTIVE</span><span class="p">;</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>

	<span class="n">mempool_free</span><span class="p">(</span><span class="n">pmb</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">mbox_mem_pool</span><span class="p">);</span>

	<span class="cm">/* There is no completion for a KILL_BOARD mbox cmd. Check for an error</span>
<span class="cm">	 * attention every 100ms for 3 seconds. If we don&#39;t get ERATT after</span>
<span class="cm">	 * 3 seconds we still set HBA_ERROR state because the status of the</span>
<span class="cm">	 * board is now undefined.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">lpfc_readl</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">HAregaddr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ha_copy</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">((</span><span class="n">i</span><span class="o">++</span> <span class="o">&lt;</span> <span class="mi">30</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">ha_copy</span> <span class="o">&amp;</span> <span class="n">HA_ERATT</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">mdelay</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">lpfc_readl</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">HAregaddr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ha_copy</span><span class="p">))</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">del_timer_sync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">psli</span><span class="o">-&gt;</span><span class="n">mbox_tmo</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ha_copy</span> <span class="o">&amp;</span> <span class="n">HA_ERATT</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">writel</span><span class="p">(</span><span class="n">HA_ERATT</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">HAregaddr</span><span class="p">);</span>
		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">pport</span><span class="o">-&gt;</span><span class="n">stopped</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>
	<span class="n">psli</span><span class="o">-&gt;</span><span class="n">sli_flag</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">LPFC_SLI_MBOX_ACTIVE</span><span class="p">;</span>
	<span class="n">psli</span><span class="o">-&gt;</span><span class="n">mbox_active</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">link_flag</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">LS_IGNORE_ERATT</span><span class="p">;</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>

	<span class="n">lpfc_hba_down_post</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">link_state</span> <span class="o">=</span> <span class="n">LPFC_HBA_ERROR</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">ha_copy</span> <span class="o">&amp;</span> <span class="n">HA_ERATT</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_sli_brdreset - Reset a sli-2 or sli-3 HBA</span>
<span class="cm"> * @phba: Pointer to HBA context object.</span>
<span class="cm"> *</span>
<span class="cm"> * This function resets the HBA by writing HC_INITFF to the control</span>
<span class="cm"> * register. After the HBA resets, this function resets all the iocb ring</span>
<span class="cm"> * indices. This function disables PCI layer parity checking during</span>
<span class="cm"> * the reset.</span>
<span class="cm"> * This function returns 0 always.</span>
<span class="cm"> * The caller is not required to hold any locks.</span>
<span class="cm"> **/</span>
<span class="kt">int</span>
<span class="nf">lpfc_sli_brdreset</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpfc_sli</span> <span class="o">*</span><span class="n">psli</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_sli_ring</span> <span class="o">*</span><span class="n">pring</span><span class="p">;</span>
	<span class="kt">uint16_t</span> <span class="n">cfg_value</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">psli</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli</span><span class="p">;</span>

	<span class="cm">/* Reset HBA */</span>
	<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_INFO</span><span class="p">,</span> <span class="n">LOG_SLI</span><span class="p">,</span>
			<span class="s">&quot;0325 Reset HBA Data: x%x x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">phba</span><span class="o">-&gt;</span><span class="n">pport</span><span class="o">-&gt;</span><span class="n">port_state</span><span class="p">,</span> <span class="n">psli</span><span class="o">-&gt;</span><span class="n">sli_flag</span><span class="p">);</span>

	<span class="cm">/* perform board reset */</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">fc_eventTag</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">link_events</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">pport</span><span class="o">-&gt;</span><span class="n">fc_myDID</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">pport</span><span class="o">-&gt;</span><span class="n">fc_prevDID</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Turn off parity checking and serr during the physical reset */</span>
	<span class="n">pci_read_config_word</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">pcidev</span><span class="p">,</span> <span class="n">PCI_COMMAND</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cfg_value</span><span class="p">);</span>
	<span class="n">pci_write_config_word</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">pcidev</span><span class="p">,</span> <span class="n">PCI_COMMAND</span><span class="p">,</span>
			      <span class="p">(</span><span class="n">cfg_value</span> <span class="o">&amp;</span>
			       <span class="o">~</span><span class="p">(</span><span class="n">PCI_COMMAND_PARITY</span> <span class="o">|</span> <span class="n">PCI_COMMAND_SERR</span><span class="p">)));</span>

	<span class="n">psli</span><span class="o">-&gt;</span><span class="n">sli_flag</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">LPFC_SLI_ACTIVE</span> <span class="o">|</span> <span class="n">LPFC_PROCESS_LA</span><span class="p">);</span>

	<span class="cm">/* Now toggle INITFF bit in the Host Control Register */</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">HC_INITFF</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">HCregaddr</span><span class="p">);</span>
	<span class="n">mdelay</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
	<span class="n">readl</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">HCregaddr</span><span class="p">);</span> <span class="cm">/* flush */</span>
	<span class="n">writel</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">HCregaddr</span><span class="p">);</span>
	<span class="n">readl</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">HCregaddr</span><span class="p">);</span> <span class="cm">/* flush */</span>

	<span class="cm">/* Restore PCI cmd register */</span>
	<span class="n">pci_write_config_word</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">pcidev</span><span class="p">,</span> <span class="n">PCI_COMMAND</span><span class="p">,</span> <span class="n">cfg_value</span><span class="p">);</span>

	<span class="cm">/* Initialize relevant SLI info */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">psli</span><span class="o">-&gt;</span><span class="n">num_rings</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pring</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">psli</span><span class="o">-&gt;</span><span class="n">ring</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="n">pring</span><span class="o">-&gt;</span><span class="n">flag</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">pring</span><span class="o">-&gt;</span><span class="n">rspidx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">pring</span><span class="o">-&gt;</span><span class="n">next_cmdidx</span>  <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">pring</span><span class="o">-&gt;</span><span class="n">local_getidx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">pring</span><span class="o">-&gt;</span><span class="n">cmdidx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">pring</span><span class="o">-&gt;</span><span class="n">missbufcnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">link_state</span> <span class="o">=</span> <span class="n">LPFC_WARM_START</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_sli4_brdreset - Reset a sli-4 HBA</span>
<span class="cm"> * @phba: Pointer to HBA context object.</span>
<span class="cm"> *</span>
<span class="cm"> * This function resets a SLI4 HBA. This function disables PCI layer parity</span>
<span class="cm"> * checking during resets the device. The caller is not required to hold</span>
<span class="cm"> * any locks.</span>
<span class="cm"> *</span>
<span class="cm"> * This function returns 0 always.</span>
<span class="cm"> **/</span>
<span class="kt">int</span>
<span class="nf">lpfc_sli4_brdreset</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpfc_sli</span> <span class="o">*</span><span class="n">psli</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli</span><span class="p">;</span>
	<span class="kt">uint16_t</span> <span class="n">cfg_value</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="cm">/* Reset HBA */</span>
	<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_INFO</span><span class="p">,</span> <span class="n">LOG_SLI</span><span class="p">,</span>
			<span class="s">&quot;0295 Reset HBA Data: x%x x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">phba</span><span class="o">-&gt;</span><span class="n">pport</span><span class="o">-&gt;</span><span class="n">port_state</span><span class="p">,</span> <span class="n">psli</span><span class="o">-&gt;</span><span class="n">sli_flag</span><span class="p">);</span>

	<span class="cm">/* perform board reset */</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">fc_eventTag</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">link_events</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">pport</span><span class="o">-&gt;</span><span class="n">fc_myDID</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">pport</span><span class="o">-&gt;</span><span class="n">fc_prevDID</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>
	<span class="n">psli</span><span class="o">-&gt;</span><span class="n">sli_flag</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">LPFC_PROCESS_LA</span><span class="p">);</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">fcf</span><span class="p">.</span><span class="n">fcf_flag</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>

	<span class="cm">/* Now physically reset the device */</span>
	<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_INFO</span><span class="p">,</span> <span class="n">LOG_INIT</span><span class="p">,</span>
			<span class="s">&quot;0389 Performing PCI function reset!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="cm">/* Turn off parity checking and serr during the physical reset */</span>
	<span class="n">pci_read_config_word</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">pcidev</span><span class="p">,</span> <span class="n">PCI_COMMAND</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cfg_value</span><span class="p">);</span>
	<span class="n">pci_write_config_word</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">pcidev</span><span class="p">,</span> <span class="n">PCI_COMMAND</span><span class="p">,</span> <span class="p">(</span><span class="n">cfg_value</span> <span class="o">&amp;</span>
			      <span class="o">~</span><span class="p">(</span><span class="n">PCI_COMMAND_PARITY</span> <span class="o">|</span> <span class="n">PCI_COMMAND_SERR</span><span class="p">)));</span>

	<span class="cm">/* Perform FCoE PCI function reset */</span>
	<span class="n">lpfc_sli4_queue_destroy</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">lpfc_pci_function_reset</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>

	<span class="cm">/* Restore PCI cmd register */</span>
	<span class="n">pci_write_config_word</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">pcidev</span><span class="p">,</span> <span class="n">PCI_COMMAND</span><span class="p">,</span> <span class="n">cfg_value</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_sli_brdrestart_s3 - Restart a sli-3 hba</span>
<span class="cm"> * @phba: Pointer to HBA context object.</span>
<span class="cm"> *</span>
<span class="cm"> * This function is called in the SLI initialization code path to</span>
<span class="cm"> * restart the HBA. The caller is not required to hold any lock.</span>
<span class="cm"> * This function writes MBX_RESTART mailbox command to the SLIM and</span>
<span class="cm"> * resets the HBA. At the end of the function, it calls lpfc_hba_down_post</span>
<span class="cm"> * function to free any pending commands. The function enables</span>
<span class="cm"> * POST only during the first initialization. The function returns zero.</span>
<span class="cm"> * The function does not guarantee completion of MBX_RESTART mailbox</span>
<span class="cm"> * command before the return of this function.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">lpfc_sli_brdrestart_s3</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">MAILBOX_t</span> <span class="o">*</span><span class="n">mb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_sli</span> <span class="o">*</span><span class="n">psli</span><span class="p">;</span>
	<span class="k">volatile</span> <span class="kt">uint32_t</span> <span class="n">word0</span><span class="p">;</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">to_slim</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">hba_aer_enabled</span><span class="p">;</span>

	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>

	<span class="cm">/* Take PCIe device Advanced Error Reporting (AER) state */</span>
	<span class="n">hba_aer_enabled</span> <span class="o">=</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">hba_flag</span> <span class="o">&amp;</span> <span class="n">HBA_AER_ENABLED</span><span class="p">;</span>

	<span class="n">psli</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli</span><span class="p">;</span>

	<span class="cm">/* Restart HBA */</span>
	<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_INFO</span><span class="p">,</span> <span class="n">LOG_SLI</span><span class="p">,</span>
			<span class="s">&quot;0337 Restart HBA Data: x%x x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">phba</span><span class="o">-&gt;</span><span class="n">pport</span><span class="o">-&gt;</span><span class="n">port_state</span><span class="p">,</span> <span class="n">psli</span><span class="o">-&gt;</span><span class="n">sli_flag</span><span class="p">);</span>

	<span class="n">word0</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">mb</span> <span class="o">=</span> <span class="p">(</span><span class="n">MAILBOX_t</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">word0</span><span class="p">;</span>
	<span class="n">mb</span><span class="o">-&gt;</span><span class="n">mbxCommand</span> <span class="o">=</span> <span class="n">MBX_RESTART</span><span class="p">;</span>
	<span class="n">mb</span><span class="o">-&gt;</span><span class="n">mbxHc</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">lpfc_reset_barrier</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>

	<span class="n">to_slim</span> <span class="o">=</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">MBslimaddr</span><span class="p">;</span>
	<span class="n">writel</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="kt">uint32_t</span> <span class="o">*</span><span class="p">)</span> <span class="n">mb</span><span class="p">,</span> <span class="n">to_slim</span><span class="p">);</span>
	<span class="n">readl</span><span class="p">(</span><span class="n">to_slim</span><span class="p">);</span> <span class="cm">/* flush */</span>

	<span class="cm">/* Only skip post after fc_ffinit is completed */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">pport</span><span class="o">-&gt;</span><span class="n">port_state</span><span class="p">)</span>
		<span class="n">word0</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>	<span class="cm">/* This is really setting up word1 */</span>
	<span class="k">else</span>
		<span class="n">word0</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>	<span class="cm">/* This is really setting up word1 */</span>
	<span class="n">to_slim</span> <span class="o">=</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">MBslimaddr</span> <span class="o">+</span> <span class="k">sizeof</span> <span class="p">(</span><span class="kt">uint32_t</span><span class="p">);</span>
	<span class="n">writel</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="kt">uint32_t</span> <span class="o">*</span><span class="p">)</span> <span class="n">mb</span><span class="p">,</span> <span class="n">to_slim</span><span class="p">);</span>
	<span class="n">readl</span><span class="p">(</span><span class="n">to_slim</span><span class="p">);</span> <span class="cm">/* flush */</span>

	<span class="n">lpfc_sli_brdreset</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">pport</span><span class="o">-&gt;</span><span class="n">stopped</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">link_state</span> <span class="o">=</span> <span class="n">LPFC_INIT_START</span><span class="p">;</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">hba_flag</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>

	<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">psli</span><span class="o">-&gt;</span><span class="n">lnk_stat_offsets</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">psli</span><span class="o">-&gt;</span><span class="n">lnk_stat_offsets</span><span class="p">));</span>
	<span class="n">psli</span><span class="o">-&gt;</span><span class="n">stats_start</span> <span class="o">=</span> <span class="n">get_seconds</span><span class="p">();</span>

	<span class="cm">/* Give the INITFF and Post time to settle. */</span>
	<span class="n">mdelay</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span>

	<span class="cm">/* Reset HBA AER if it was enabled, note hba_flag was reset above */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hba_aer_enabled</span><span class="p">)</span>
		<span class="n">pci_disable_pcie_error_reporting</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">pcidev</span><span class="p">);</span>

	<span class="n">lpfc_hba_down_post</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_sli_brdrestart_s4 - Restart the sli-4 hba</span>
<span class="cm"> * @phba: Pointer to HBA context object.</span>
<span class="cm"> *</span>
<span class="cm"> * This function is called in the SLI initialization code path to restart</span>
<span class="cm"> * a SLI4 HBA. The caller is not required to hold any lock.</span>
<span class="cm"> * At the end of the function, it calls lpfc_hba_down_post function to</span>
<span class="cm"> * free any pending commands.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">lpfc_sli_brdrestart_s4</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpfc_sli</span> <span class="o">*</span><span class="n">psli</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">hba_aer_enabled</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="cm">/* Restart HBA */</span>
	<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_INFO</span><span class="p">,</span> <span class="n">LOG_SLI</span><span class="p">,</span>
			<span class="s">&quot;0296 Restart HBA Data: x%x x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">phba</span><span class="o">-&gt;</span><span class="n">pport</span><span class="o">-&gt;</span><span class="n">port_state</span><span class="p">,</span> <span class="n">psli</span><span class="o">-&gt;</span><span class="n">sli_flag</span><span class="p">);</span>

	<span class="cm">/* Take PCIe device Advanced Error Reporting (AER) state */</span>
	<span class="n">hba_aer_enabled</span> <span class="o">=</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">hba_flag</span> <span class="o">&amp;</span> <span class="n">HBA_AER_ENABLED</span><span class="p">;</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">lpfc_sli4_brdreset</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>

	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">pport</span><span class="o">-&gt;</span><span class="n">stopped</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">link_state</span> <span class="o">=</span> <span class="n">LPFC_INIT_START</span><span class="p">;</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">hba_flag</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>

	<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">psli</span><span class="o">-&gt;</span><span class="n">lnk_stat_offsets</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">psli</span><span class="o">-&gt;</span><span class="n">lnk_stat_offsets</span><span class="p">));</span>
	<span class="n">psli</span><span class="o">-&gt;</span><span class="n">stats_start</span> <span class="o">=</span> <span class="n">get_seconds</span><span class="p">();</span>

	<span class="cm">/* Reset HBA AER if it was enabled, note hba_flag was reset above */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hba_aer_enabled</span><span class="p">)</span>
		<span class="n">pci_disable_pcie_error_reporting</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">pcidev</span><span class="p">);</span>

	<span class="n">lpfc_hba_down_post</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_sli_brdrestart - Wrapper func for restarting hba</span>
<span class="cm"> * @phba: Pointer to HBA context object.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine wraps the actual SLI3 or SLI4 hba restart routine from the</span>
<span class="cm"> * API jump table function pointer from the lpfc_hba struct.</span>
<span class="cm">**/</span>
<span class="kt">int</span>
<span class="nf">lpfc_sli_brdrestart</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">lpfc_sli_brdrestart</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_sli_chipset_init - Wait for the restart of the HBA after a restart</span>
<span class="cm"> * @phba: Pointer to HBA context object.</span>
<span class="cm"> *</span>
<span class="cm"> * This function is called after a HBA restart to wait for successful</span>
<span class="cm"> * restart of the HBA. Successful restart of the HBA is indicated by</span>
<span class="cm"> * HS_FFRDY and HS_MBRDY bits. If the HBA fails to restart even after 15</span>
<span class="cm"> * iteration, the function will restart the HBA again. The function returns</span>
<span class="cm"> * zero if HBA successfully restarted else returns negative error code.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">lpfc_sli_chipset_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">uint32_t</span> <span class="n">status</span><span class="p">,</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Read the HBA Host Status Register */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">lpfc_readl</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">HSregaddr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">status</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>

	<span class="cm">/* Check status register to see what current state is */</span>
	<span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">((</span><span class="n">status</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">HS_FFRDY</span> <span class="o">|</span> <span class="n">HS_MBRDY</span><span class="p">))</span> <span class="o">!=</span> <span class="p">(</span><span class="n">HS_FFRDY</span> <span class="o">|</span> <span class="n">HS_MBRDY</span><span class="p">))</span> <span class="p">{</span>

		<span class="cm">/* Check every 10ms for 10 retries, then every 100ms for 90</span>
<span class="cm">		 * retries, then every 1 sec for 50 retires for a total of</span>
<span class="cm">		 * ~60 seconds before reset the board again and check every</span>
<span class="cm">		 * 1 sec for 50 retries. The up to 60 seconds before the</span>
<span class="cm">		 * board ready is required by the Falcon FIPS zeroization</span>
<span class="cm">		 * complete, and any reset the board in between shall cause</span>
<span class="cm">		 * restart of zeroization, further delay the board ready.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">i</span><span class="o">++</span> <span class="o">&gt;=</span> <span class="mi">200</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Adapter failed to init, timeout, status reg</span>
<span class="cm">			   &lt;status&gt; */</span>
			<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_INIT</span><span class="p">,</span>
					<span class="s">&quot;0436 Adapter failed to init, &quot;</span>
					<span class="s">&quot;timeout, status reg x%x, &quot;</span>
					<span class="s">&quot;FW Data: A8 x%x AC x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">status</span><span class="p">,</span>
					<span class="n">readl</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">MBslimaddr</span> <span class="o">+</span> <span class="mh">0xa8</span><span class="p">),</span>
					<span class="n">readl</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">MBslimaddr</span> <span class="o">+</span> <span class="mh">0xac</span><span class="p">));</span>
			<span class="n">phba</span><span class="o">-&gt;</span><span class="n">link_state</span> <span class="o">=</span> <span class="n">LPFC_HBA_ERROR</span><span class="p">;</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ETIMEDOUT</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* Check to see if any errors occurred during init */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">HS_FFERM</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* ERROR: During chipset initialization */</span>
			<span class="cm">/* Adapter failed to init, chipset, status reg</span>
<span class="cm">			   &lt;status&gt; */</span>
			<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_INIT</span><span class="p">,</span>
					<span class="s">&quot;0437 Adapter failed to init, &quot;</span>
					<span class="s">&quot;chipset, status reg x%x, &quot;</span>
					<span class="s">&quot;FW Data: A8 x%x AC x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">status</span><span class="p">,</span>
					<span class="n">readl</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">MBslimaddr</span> <span class="o">+</span> <span class="mh">0xa8</span><span class="p">),</span>
					<span class="n">readl</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">MBslimaddr</span> <span class="o">+</span> <span class="mh">0xac</span><span class="p">));</span>
			<span class="n">phba</span><span class="o">-&gt;</span><span class="n">link_state</span> <span class="o">=</span> <span class="n">LPFC_HBA_ERROR</span><span class="p">;</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;=</span> <span class="mi">10</span><span class="p">)</span>
			<span class="n">msleep</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;=</span> <span class="mi">100</span><span class="p">)</span>
			<span class="n">msleep</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">msleep</span><span class="p">(</span><span class="mi">1000</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="mi">150</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Do post */</span>
			<span class="n">phba</span><span class="o">-&gt;</span><span class="n">pport</span><span class="o">-&gt;</span><span class="n">port_state</span> <span class="o">=</span> <span class="n">LPFC_VPORT_UNKNOWN</span><span class="p">;</span>
			<span class="n">lpfc_sli_brdrestart</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="cm">/* Read the HBA Host Status Register */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">lpfc_readl</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">HSregaddr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">status</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Check to see if any errors occurred during init */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">HS_FFERM</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* ERROR: During chipset initialization */</span>
		<span class="cm">/* Adapter failed to init, chipset, status reg &lt;status&gt; */</span>
		<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_INIT</span><span class="p">,</span>
				<span class="s">&quot;0438 Adapter failed to init, chipset, &quot;</span>
				<span class="s">&quot;status reg x%x, &quot;</span>
				<span class="s">&quot;FW Data: A8 x%x AC x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">status</span><span class="p">,</span>
				<span class="n">readl</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">MBslimaddr</span> <span class="o">+</span> <span class="mh">0xa8</span><span class="p">),</span>
				<span class="n">readl</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">MBslimaddr</span> <span class="o">+</span> <span class="mh">0xac</span><span class="p">));</span>
		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">link_state</span> <span class="o">=</span> <span class="n">LPFC_HBA_ERROR</span><span class="p">;</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Clear all interrupt enable conditions */</span>
	<span class="n">writel</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">HCregaddr</span><span class="p">);</span>
	<span class="n">readl</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">HCregaddr</span><span class="p">);</span> <span class="cm">/* flush */</span>

	<span class="cm">/* setup host attn register */</span>
	<span class="n">writel</span><span class="p">(</span><span class="mh">0xffffffff</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">HAregaddr</span><span class="p">);</span>
	<span class="n">readl</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">HAregaddr</span><span class="p">);</span> <span class="cm">/* flush */</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_sli_hbq_count - Get the number of HBQs to be configured</span>
<span class="cm"> *</span>
<span class="cm"> * This function calculates and returns the number of HBQs required to be</span>
<span class="cm"> * configured.</span>
<span class="cm"> **/</span>
<span class="kt">int</span>
<span class="nf">lpfc_sli_hbq_count</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">lpfc_hbq_defs</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_sli_hbq_entry_count - Calculate total number of hbq entries</span>
<span class="cm"> *</span>
<span class="cm"> * This function adds the number of hbq entries in every HBQ to get</span>
<span class="cm"> * the total number of hbq entries required for the HBA and returns</span>
<span class="cm"> * the total count.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">lpfc_sli_hbq_entry_count</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span>  <span class="n">hbq_count</span> <span class="o">=</span> <span class="n">lpfc_sli_hbq_count</span><span class="p">();</span>
	<span class="kt">int</span>  <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span>  <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">hbq_count</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
		<span class="n">count</span> <span class="o">+=</span> <span class="n">lpfc_hbq_defs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">entry_count</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">count</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_sli_hbq_size - Calculate memory required for all hbq entries</span>
<span class="cm"> *</span>
<span class="cm"> * This function calculates amount of memory required for all hbq entries</span>
<span class="cm"> * to be configured and returns the total memory required.</span>
<span class="cm"> **/</span>
<span class="kt">int</span>
<span class="nf">lpfc_sli_hbq_size</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">lpfc_sli_hbq_entry_count</span><span class="p">()</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hbq_entry</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_sli_hbq_setup - configure and initialize HBQs</span>
<span class="cm"> * @phba: Pointer to HBA context object.</span>
<span class="cm"> *</span>
<span class="cm"> * This function is called during the SLI initialization to configure</span>
<span class="cm"> * all the HBQs and post buffers to the HBQ. The caller is not</span>
<span class="cm"> * required to hold any locks. This function will return zero if successful</span>
<span class="cm"> * else it will return negative error code.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">lpfc_sli_hbq_setup</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span>  <span class="n">hbq_count</span> <span class="o">=</span> <span class="n">lpfc_sli_hbq_count</span><span class="p">();</span>
	<span class="n">LPFC_MBOXQ_t</span> <span class="o">*</span><span class="n">pmb</span><span class="p">;</span>
	<span class="n">MAILBOX_t</span> <span class="o">*</span><span class="n">pmbox</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">hbqno</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">hbq_entry_index</span><span class="p">;</span>

				<span class="cm">/* Get a Mailbox buffer to setup mailbox</span>
<span class="cm">				 * commands for HBA initialization</span>
<span class="cm">				 */</span>
	<span class="n">pmb</span> <span class="o">=</span> <span class="p">(</span><span class="n">LPFC_MBOXQ_t</span> <span class="o">*</span><span class="p">)</span> <span class="n">mempool_alloc</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">mbox_mem_pool</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pmb</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">pmbox</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">pmb</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">mb</span><span class="p">;</span>

	<span class="cm">/* Initialize the struct lpfc_sli_hbq structure for each hbq */</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">link_state</span> <span class="o">=</span> <span class="n">LPFC_INIT_MBX_CMDS</span><span class="p">;</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbq_in_use</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">hbq_entry_index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">hbqno</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">hbqno</span> <span class="o">&lt;</span> <span class="n">hbq_count</span><span class="p">;</span> <span class="o">++</span><span class="n">hbqno</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbqs</span><span class="p">[</span><span class="n">hbqno</span><span class="p">].</span><span class="n">next_hbqPutIdx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbqs</span><span class="p">[</span><span class="n">hbqno</span><span class="p">].</span><span class="n">hbqPutIdx</span>      <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbqs</span><span class="p">[</span><span class="n">hbqno</span><span class="p">].</span><span class="n">local_hbqGetIdx</span>   <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbqs</span><span class="p">[</span><span class="n">hbqno</span><span class="p">].</span><span class="n">entry_count</span> <span class="o">=</span>
			<span class="n">lpfc_hbq_defs</span><span class="p">[</span><span class="n">hbqno</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">entry_count</span><span class="p">;</span>
		<span class="n">lpfc_config_hbq</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">hbqno</span><span class="p">,</span> <span class="n">lpfc_hbq_defs</span><span class="p">[</span><span class="n">hbqno</span><span class="p">],</span>
			<span class="n">hbq_entry_index</span><span class="p">,</span> <span class="n">pmb</span><span class="p">);</span>
		<span class="n">hbq_entry_index</span> <span class="o">+=</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbqs</span><span class="p">[</span><span class="n">hbqno</span><span class="p">].</span><span class="n">entry_count</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">lpfc_sli_issue_mbox</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">pmb</span><span class="p">,</span> <span class="n">MBX_POLL</span><span class="p">)</span> <span class="o">!=</span> <span class="n">MBX_SUCCESS</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Adapter failed to init, mbxCmd &lt;cmd&gt; CFG_RING,</span>
<span class="cm">			   mbxStatus &lt;status&gt;, ring &lt;num&gt; */</span>

			<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span>
					<span class="n">LOG_SLI</span> <span class="o">|</span> <span class="n">LOG_VPORT</span><span class="p">,</span>
					<span class="s">&quot;1805 Adapter failed to init. &quot;</span>
					<span class="s">&quot;Data: x%x x%x x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">pmbox</span><span class="o">-&gt;</span><span class="n">mbxCommand</span><span class="p">,</span>
					<span class="n">pmbox</span><span class="o">-&gt;</span><span class="n">mbxStatus</span><span class="p">,</span> <span class="n">hbqno</span><span class="p">);</span>

			<span class="n">phba</span><span class="o">-&gt;</span><span class="n">link_state</span> <span class="o">=</span> <span class="n">LPFC_HBA_ERROR</span><span class="p">;</span>
			<span class="n">mempool_free</span><span class="p">(</span><span class="n">pmb</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">mbox_mem_pool</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENXIO</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbq_count</span> <span class="o">=</span> <span class="n">hbq_count</span><span class="p">;</span>

	<span class="n">mempool_free</span><span class="p">(</span><span class="n">pmb</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">mbox_mem_pool</span><span class="p">);</span>

	<span class="cm">/* Initially populate or replenish the HBQs */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">hbqno</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">hbqno</span> <span class="o">&lt;</span> <span class="n">hbq_count</span><span class="p">;</span> <span class="o">++</span><span class="n">hbqno</span><span class="p">)</span>
		<span class="n">lpfc_sli_hbqbuf_init_hbqs</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">hbqno</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_sli4_rb_setup - Initialize and post RBs to HBA</span>
<span class="cm"> * @phba: Pointer to HBA context object.</span>
<span class="cm"> *</span>
<span class="cm"> * This function is called during the SLI initialization to configure</span>
<span class="cm"> * all the HBQs and post buffers to the HBQ. The caller is not</span>
<span class="cm"> * required to hold any locks. This function will return zero if successful</span>
<span class="cm"> * else it will return negative error code.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">lpfc_sli4_rb_setup</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbq_in_use</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbqs</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">entry_count</span> <span class="o">=</span> <span class="n">lpfc_hbq_defs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">entry_count</span><span class="p">;</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbq_count</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="cm">/* Initially populate or replenish the HBQs */</span>
	<span class="n">lpfc_sli_hbqbuf_init_hbqs</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_sli_config_port - Issue config port mailbox command</span>
<span class="cm"> * @phba: Pointer to HBA context object.</span>
<span class="cm"> * @sli_mode: sli mode - 2/3</span>
<span class="cm"> *</span>
<span class="cm"> * This function is called by the sli intialization code path</span>
<span class="cm"> * to issue config_port mailbox command. This function restarts the</span>
<span class="cm"> * HBA firmware and issues a config_port mailbox command to configure</span>
<span class="cm"> * the SLI interface in the sli mode specified by sli_mode</span>
<span class="cm"> * variable. The caller is not required to hold any locks.</span>
<span class="cm"> * The function returns 0 if successful, else returns negative error</span>
<span class="cm"> * code.</span>
<span class="cm"> **/</span>
<span class="kt">int</span>
<span class="nf">lpfc_sli_config_port</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">,</span> <span class="kt">int</span> <span class="n">sli_mode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">LPFC_MBOXQ_t</span> <span class="o">*</span><span class="n">pmb</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">resetcount</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">done</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">pmb</span> <span class="o">=</span> <span class="p">(</span><span class="n">LPFC_MBOXQ_t</span> <span class="o">*</span><span class="p">)</span> <span class="n">mempool_alloc</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">mbox_mem_pool</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pmb</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">link_state</span> <span class="o">=</span> <span class="n">LPFC_HBA_ERROR</span><span class="p">;</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli_rev</span> <span class="o">=</span> <span class="n">sli_mode</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">resetcount</span> <span class="o">&lt;</span> <span class="mi">2</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">done</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>
		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli</span><span class="p">.</span><span class="n">sli_flag</span> <span class="o">|=</span> <span class="n">LPFC_SLI_MBOX_ACTIVE</span><span class="p">;</span>
		<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>
		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">pport</span><span class="o">-&gt;</span><span class="n">port_state</span> <span class="o">=</span> <span class="n">LPFC_VPORT_UNKNOWN</span><span class="p">;</span>
		<span class="n">lpfc_sli_brdrestart</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">lpfc_sli_chipset_init</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>
		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli</span><span class="p">.</span><span class="n">sli_flag</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">LPFC_SLI_MBOX_ACTIVE</span><span class="p">;</span>
		<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>
		<span class="n">resetcount</span><span class="o">++</span><span class="p">;</span>

		<span class="cm">/* Call pre CONFIG_PORT mailbox command initialization.  A</span>
<span class="cm">		 * value of 0 means the call was successful.  Any other</span>
<span class="cm">		 * nonzero value is a failure, but if ERESTART is returned,</span>
<span class="cm">		 * the driver may reset the HBA and try again.</span>
<span class="cm">		 */</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">lpfc_config_port_prep</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">==</span> <span class="o">-</span><span class="n">ERESTART</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">phba</span><span class="o">-&gt;</span><span class="n">link_state</span> <span class="o">=</span> <span class="n">LPFC_LINK_UNKNOWN</span><span class="p">;</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">link_state</span> <span class="o">=</span> <span class="n">LPFC_INIT_MBX_CMDS</span><span class="p">;</span>
		<span class="n">lpfc_config_port</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">pmb</span><span class="p">);</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">lpfc_sli_issue_mbox</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">pmb</span><span class="p">,</span> <span class="n">MBX_POLL</span><span class="p">);</span>
		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli3_options</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">LPFC_SLI3_NPIV_ENABLED</span> <span class="o">|</span>
					<span class="n">LPFC_SLI3_HBQ_ENABLED</span> <span class="o">|</span>
					<span class="n">LPFC_SLI3_CRP_ENABLED</span> <span class="o">|</span>
					<span class="n">LPFC_SLI3_BG_ENABLED</span> <span class="o">|</span>
					<span class="n">LPFC_SLI3_DSS_ENABLED</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">!=</span> <span class="n">MBX_SUCCESS</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_INIT</span><span class="p">,</span>
				<span class="s">&quot;0442 Adapter failed to init, mbxCmd x%x &quot;</span>
				<span class="s">&quot;CONFIG_PORT, mbxStatus x%x Data: x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">pmb</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">mb</span><span class="p">.</span><span class="n">mbxCommand</span><span class="p">,</span> <span class="n">pmb</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">mb</span><span class="p">.</span><span class="n">mbxStatus</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
			<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>
			<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli</span><span class="p">.</span><span class="n">sli_flag</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">LPFC_SLI_ACTIVE</span><span class="p">;</span>
			<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>
			<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENXIO</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/* Allow asynchronous mailbox command to go through */</span>
			<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>
			<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli</span><span class="p">.</span><span class="n">sli_flag</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">LPFC_SLI_ASYNC_MBX_BLK</span><span class="p">;</span>
			<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>
			<span class="n">done</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">((</span><span class="n">pmb</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">mb</span><span class="p">.</span><span class="n">un</span><span class="p">.</span><span class="n">varCfgPort</span><span class="p">.</span><span class="n">casabt</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			    <span class="p">(</span><span class="n">pmb</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">mb</span><span class="p">.</span><span class="n">un</span><span class="p">.</span><span class="n">varCfgPort</span><span class="p">.</span><span class="n">gasabt</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span>
				<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_WARNING</span><span class="p">,</span> <span class="n">LOG_INIT</span><span class="p">,</span>
					<span class="s">&quot;3110 Port did not grant ASABT</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">done</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">do_prep_failed</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pmb</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">mb</span><span class="p">.</span><span class="n">un</span><span class="p">.</span><span class="n">varCfgPort</span><span class="p">.</span><span class="n">sli_mode</span> <span class="o">==</span> <span class="mi">3</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pmb</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">mb</span><span class="p">.</span><span class="n">un</span><span class="p">.</span><span class="n">varCfgPort</span><span class="p">.</span><span class="n">cMA</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENXIO</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">do_prep_failed</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">max_vpi</span> <span class="o">&amp;&amp;</span> <span class="n">pmb</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">mb</span><span class="p">.</span><span class="n">un</span><span class="p">.</span><span class="n">varCfgPort</span><span class="p">.</span><span class="n">gmv</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli3_options</span> <span class="o">|=</span> <span class="n">LPFC_SLI3_NPIV_ENABLED</span><span class="p">;</span>
			<span class="n">phba</span><span class="o">-&gt;</span><span class="n">max_vpi</span> <span class="o">=</span> <span class="n">pmb</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">mb</span><span class="p">.</span><span class="n">un</span><span class="p">.</span><span class="n">varCfgPort</span><span class="p">.</span><span class="n">max_vpi</span><span class="p">;</span>
			<span class="n">phba</span><span class="o">-&gt;</span><span class="n">max_vports</span> <span class="o">=</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">max_vpi</span> <span class="o">&gt;</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">max_vports</span><span class="p">)</span> <span class="o">?</span>
				<span class="n">phba</span><span class="o">-&gt;</span><span class="n">max_vpi</span> <span class="o">:</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">max_vports</span><span class="p">;</span>

		<span class="p">}</span> <span class="k">else</span>
			<span class="n">phba</span><span class="o">-&gt;</span><span class="n">max_vpi</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">fips_level</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">fips_spec_rev</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pmb</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">mb</span><span class="p">.</span><span class="n">un</span><span class="p">.</span><span class="n">varCfgPort</span><span class="p">.</span><span class="n">gdss</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli3_options</span> <span class="o">|=</span> <span class="n">LPFC_SLI3_DSS_ENABLED</span><span class="p">;</span>
			<span class="n">phba</span><span class="o">-&gt;</span><span class="n">fips_level</span> <span class="o">=</span> <span class="n">pmb</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">mb</span><span class="p">.</span><span class="n">un</span><span class="p">.</span><span class="n">varCfgPort</span><span class="p">.</span><span class="n">fips_level</span><span class="p">;</span>
			<span class="n">phba</span><span class="o">-&gt;</span><span class="n">fips_spec_rev</span> <span class="o">=</span> <span class="n">pmb</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">mb</span><span class="p">.</span><span class="n">un</span><span class="p">.</span><span class="n">varCfgPort</span><span class="p">.</span><span class="n">fips_rev</span><span class="p">;</span>
			<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_INFO</span><span class="p">,</span> <span class="n">LOG_INIT</span><span class="p">,</span>
					<span class="s">&quot;2850 Security Crypto Active. FIPS x%d &quot;</span>
					<span class="s">&quot;(Spec Rev: x%d)&quot;</span><span class="p">,</span>
					<span class="n">phba</span><span class="o">-&gt;</span><span class="n">fips_level</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">fips_spec_rev</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pmb</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">mb</span><span class="p">.</span><span class="n">un</span><span class="p">.</span><span class="n">varCfgPort</span><span class="p">.</span><span class="n">sec_err</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_INIT</span><span class="p">,</span>
					<span class="s">&quot;2856 Config Port Security Crypto &quot;</span>
					<span class="s">&quot;Error: x%x &quot;</span><span class="p">,</span>
					<span class="n">pmb</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">mb</span><span class="p">.</span><span class="n">un</span><span class="p">.</span><span class="n">varCfgPort</span><span class="p">.</span><span class="n">sec_err</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pmb</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">mb</span><span class="p">.</span><span class="n">un</span><span class="p">.</span><span class="n">varCfgPort</span><span class="p">.</span><span class="n">gerbm</span><span class="p">)</span>
			<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli3_options</span> <span class="o">|=</span> <span class="n">LPFC_SLI3_HBQ_ENABLED</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pmb</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">mb</span><span class="p">.</span><span class="n">un</span><span class="p">.</span><span class="n">varCfgPort</span><span class="p">.</span><span class="n">gcrp</span><span class="p">)</span>
			<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli3_options</span> <span class="o">|=</span> <span class="n">LPFC_SLI3_CRP_ENABLED</span><span class="p">;</span>

		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbq_get</span> <span class="o">=</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">mbox</span><span class="o">-&gt;</span><span class="n">us</span><span class="p">.</span><span class="n">s3_pgp</span><span class="p">.</span><span class="n">hbq_get</span><span class="p">;</span>
		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">port_gp</span> <span class="o">=</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">mbox</span><span class="o">-&gt;</span><span class="n">us</span><span class="p">.</span><span class="n">s3_pgp</span><span class="p">.</span><span class="n">port</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">cfg_enable_bg</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">pmb</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">mb</span><span class="p">.</span><span class="n">un</span><span class="p">.</span><span class="n">varCfgPort</span><span class="p">.</span><span class="n">gbg</span><span class="p">)</span>
				<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli3_options</span> <span class="o">|=</span> <span class="n">LPFC_SLI3_BG_ENABLED</span><span class="p">;</span>
			<span class="k">else</span>
				<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_INIT</span><span class="p">,</span>
						<span class="s">&quot;0443 Adapter did not grant &quot;</span>
						<span class="s">&quot;BlockGuard</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbq_get</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">port_gp</span> <span class="o">=</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">mbox</span><span class="o">-&gt;</span><span class="n">us</span><span class="p">.</span><span class="n">s2</span><span class="p">.</span><span class="n">port</span><span class="p">;</span>
		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">max_vpi</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
<span class="nl">do_prep_failed:</span>
	<span class="n">mempool_free</span><span class="p">(</span><span class="n">pmb</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">mbox_mem_pool</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/**</span>
<span class="cm"> * lpfc_sli_hba_setup - SLI intialization function</span>
<span class="cm"> * @phba: Pointer to HBA context object.</span>
<span class="cm"> *</span>
<span class="cm"> * This function is the main SLI intialization function. This function</span>
<span class="cm"> * is called by the HBA intialization code, HBA reset code and HBA</span>
<span class="cm"> * error attention handler code. Caller is not required to hold any</span>
<span class="cm"> * locks. This function issues config_port mailbox command to configure</span>
<span class="cm"> * the SLI, setup iocb rings and HBQ rings. In the end the function</span>
<span class="cm"> * calls the config_port_post function to issue init_link mailbox</span>
<span class="cm"> * command and to start the discovery. The function will return zero</span>
<span class="cm"> * if successful, else it will return negative error code.</span>
<span class="cm"> **/</span>
<span class="kt">int</span>
<span class="nf">lpfc_sli_hba_setup</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">uint32_t</span> <span class="n">rc</span><span class="p">;</span>
	<span class="kt">int</span>  <span class="n">mode</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">longs</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">lpfc_sli_mode</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="mi">2</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">cfg_enable_npiv</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_INIT</span> <span class="o">|</span> <span class="n">LOG_VPORT</span><span class="p">,</span>
				<span class="s">&quot;1824 NPIV enabled: Override lpfc_sli_mode &quot;</span>
				<span class="s">&quot;parameter (%d) to auto (0).</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">lpfc_sli_mode</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">mode</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">0</span>:
	<span class="k">case</span> <span class="mi">3</span>:
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_INIT</span> <span class="o">|</span> <span class="n">LOG_VPORT</span><span class="p">,</span>
				<span class="s">&quot;1819 Unrecognized lpfc_sli_mode &quot;</span>
				<span class="s">&quot;parameter: %d.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">lpfc_sli_mode</span><span class="p">);</span>

		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">lpfc_sli_config_port</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">mode</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">&amp;&amp;</span> <span class="n">lpfc_sli_mode</span> <span class="o">==</span> <span class="mi">3</span><span class="p">)</span>
		<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_INIT</span> <span class="o">|</span> <span class="n">LOG_VPORT</span><span class="p">,</span>
				<span class="s">&quot;1820 Unable to select SLI-3.  &quot;</span>
				<span class="s">&quot;Not supported by adapter.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">&amp;&amp;</span> <span class="n">mode</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">)</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">lpfc_sli_config_port</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">lpfc_sli_hba_setup_error</span><span class="p">;</span>

	<span class="cm">/* Enable PCIe device Advanced Error Reporting (AER) if configured */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">cfg_aer_support</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hba_flag</span> <span class="o">&amp;</span> <span class="n">HBA_AER_ENABLED</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">pci_enable_pcie_error_reporting</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">pcidev</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_INFO</span><span class="p">,</span> <span class="n">LOG_INIT</span><span class="p">,</span>
					<span class="s">&quot;2709 This device supports &quot;</span>
					<span class="s">&quot;Advanced Error Reporting (AER)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>
			<span class="n">phba</span><span class="o">-&gt;</span><span class="n">hba_flag</span> <span class="o">|=</span> <span class="n">HBA_AER_ENABLED</span><span class="p">;</span>
			<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_INFO</span><span class="p">,</span> <span class="n">LOG_INIT</span><span class="p">,</span>
					<span class="s">&quot;2708 This device does not support &quot;</span>
					<span class="s">&quot;Advanced Error Reporting (AER)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">phba</span><span class="o">-&gt;</span><span class="n">cfg_aer_support</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli_rev</span> <span class="o">==</span> <span class="mi">3</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">iocb_cmd_size</span> <span class="o">=</span> <span class="n">SLI3_IOCB_CMD_SIZE</span><span class="p">;</span>
		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">iocb_rsp_size</span> <span class="o">=</span> <span class="n">SLI3_IOCB_RSP_SIZE</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">iocb_cmd_size</span> <span class="o">=</span> <span class="n">SLI2_IOCB_CMD_SIZE</span><span class="p">;</span>
		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">iocb_rsp_size</span> <span class="o">=</span> <span class="n">SLI2_IOCB_RSP_SIZE</span><span class="p">;</span>
		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli3_options</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_INFO</span><span class="p">,</span> <span class="n">LOG_INIT</span><span class="p">,</span>
			<span class="s">&quot;0444 Firmware in SLI %x mode. Max_vpi %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli_rev</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">max_vpi</span><span class="p">);</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">lpfc_sli_ring_map</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">lpfc_sli_hba_setup_error</span><span class="p">;</span>

	<span class="cm">/* Initialize VPIs. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli_rev</span> <span class="o">==</span> <span class="n">LPFC_SLI_REV3</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * The VPI bitmask and physical ID array are allocated</span>
<span class="cm">		 * and initialized once only - at driver load.  A port</span>
<span class="cm">		 * reset doesn&#39;t need to reinitialize this memory.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">vpi_bmask</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">vpi_ids</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">longs</span> <span class="o">=</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">max_vpi</span> <span class="o">+</span> <span class="n">BITS_PER_LONG</span><span class="p">)</span> <span class="o">/</span> <span class="n">BITS_PER_LONG</span><span class="p">;</span>
			<span class="n">phba</span><span class="o">-&gt;</span><span class="n">vpi_bmask</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="n">longs</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">),</span>
						  <span class="n">GFP_KERNEL</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">vpi_bmask</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
				<span class="k">goto</span> <span class="n">lpfc_sli_hba_setup_error</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="n">phba</span><span class="o">-&gt;</span><span class="n">vpi_ids</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span>
					<span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">max_vpi</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">uint16_t</span><span class="p">),</span>
					<span class="n">GFP_KERNEL</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">vpi_ids</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">kfree</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">vpi_bmask</span><span class="p">);</span>
				<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
				<span class="k">goto</span> <span class="n">lpfc_sli_hba_setup_error</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">max_vpi</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
				<span class="n">phba</span><span class="o">-&gt;</span><span class="n">vpi_ids</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* Init HBQs */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli3_options</span> <span class="o">&amp;</span> <span class="n">LPFC_SLI3_HBQ_ENABLED</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">lpfc_sli_hbq_setup</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">lpfc_sli_hba_setup_error</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli</span><span class="p">.</span><span class="n">sli_flag</span> <span class="o">|=</span> <span class="n">LPFC_PROCESS_LA</span><span class="p">;</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">lpfc_config_port_post</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">lpfc_sli_hba_setup_error</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>

<span class="nl">lpfc_sli_hba_setup_error:</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">link_state</span> <span class="o">=</span> <span class="n">LPFC_HBA_ERROR</span><span class="p">;</span>
	<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_INIT</span><span class="p">,</span>
			<span class="s">&quot;0445 Firmware initialization failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_sli4_read_fcoe_params - Read fcoe params from conf region</span>
<span class="cm"> * @phba: Pointer to HBA context object.</span>
<span class="cm"> * @mboxq: mailbox pointer.</span>
<span class="cm"> * This function issue a dump mailbox command to read config region</span>
<span class="cm"> * 23 and parse the records in the region and populate driver</span>
<span class="cm"> * data structure.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">lpfc_sli4_read_fcoe_params</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">LPFC_MBOXQ_t</span> <span class="o">*</span><span class="n">mboxq</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_dmabuf</span> <span class="o">*</span><span class="n">mp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_mqe</span> <span class="o">*</span><span class="n">mqe</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">data_length</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="cm">/* Program the default value of vlan_id and fc_map */</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">valid_vlan</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">fc_map</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">LPFC_FCOE_FCF_MAP0</span><span class="p">;</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">fc_map</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">LPFC_FCOE_FCF_MAP1</span><span class="p">;</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">fc_map</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">LPFC_FCOE_FCF_MAP2</span><span class="p">;</span>

	<span class="n">mboxq</span> <span class="o">=</span> <span class="p">(</span><span class="n">LPFC_MBOXQ_t</span> <span class="o">*</span><span class="p">)</span><span class="n">mempool_alloc</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">mbox_mem_pool</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mboxq</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">mqe</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">mboxq</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">mqe</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">lpfc_sli4_dump_cfg_rg23</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">mboxq</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out_free_mboxq</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">mp</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_dmabuf</span> <span class="o">*</span><span class="p">)</span> <span class="n">mboxq</span><span class="o">-&gt;</span><span class="n">context1</span><span class="p">;</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">lpfc_sli_issue_mbox</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">mboxq</span><span class="p">,</span> <span class="n">MBX_POLL</span><span class="p">);</span>

	<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_INFO</span><span class="p">,</span> <span class="n">LOG_MBOX</span> <span class="o">|</span> <span class="n">LOG_SLI</span><span class="p">,</span>
			<span class="s">&quot;(%d):2571 Mailbox cmd x%x Status x%x &quot;</span>
			<span class="s">&quot;Data: x%x x%x x%x x%x x%x x%x x%x x%x x%x &quot;</span>
			<span class="s">&quot;x%x x%x x%x x%x x%x x%x x%x x%x x%x &quot;</span>
			<span class="s">&quot;CQ: x%x x%x x%x x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">mboxq</span><span class="o">-&gt;</span><span class="n">vport</span> <span class="o">?</span> <span class="n">mboxq</span><span class="o">-&gt;</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">vpi</span> <span class="o">:</span> <span class="mi">0</span><span class="p">,</span>
			<span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_mqe_command</span><span class="p">,</span> <span class="n">mqe</span><span class="p">),</span>
			<span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_mqe_status</span><span class="p">,</span> <span class="n">mqe</span><span class="p">),</span>
			<span class="n">mqe</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">mb_words</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">mqe</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">mb_words</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
			<span class="n">mqe</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">mb_words</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">mqe</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">mb_words</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span>
			<span class="n">mqe</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">mb_words</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span> <span class="n">mqe</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">mb_words</span><span class="p">[</span><span class="mi">5</span><span class="p">],</span>
			<span class="n">mqe</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">mb_words</span><span class="p">[</span><span class="mi">6</span><span class="p">],</span> <span class="n">mqe</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">mb_words</span><span class="p">[</span><span class="mi">7</span><span class="p">],</span>
			<span class="n">mqe</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">mb_words</span><span class="p">[</span><span class="mi">8</span><span class="p">],</span> <span class="n">mqe</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">mb_words</span><span class="p">[</span><span class="mi">9</span><span class="p">],</span>
			<span class="n">mqe</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">mb_words</span><span class="p">[</span><span class="mi">10</span><span class="p">],</span> <span class="n">mqe</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">mb_words</span><span class="p">[</span><span class="mi">11</span><span class="p">],</span>
			<span class="n">mqe</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">mb_words</span><span class="p">[</span><span class="mi">12</span><span class="p">],</span> <span class="n">mqe</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">mb_words</span><span class="p">[</span><span class="mi">13</span><span class="p">],</span>
			<span class="n">mqe</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">mb_words</span><span class="p">[</span><span class="mi">14</span><span class="p">],</span> <span class="n">mqe</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">mb_words</span><span class="p">[</span><span class="mi">15</span><span class="p">],</span>
			<span class="n">mqe</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">mb_words</span><span class="p">[</span><span class="mi">16</span><span class="p">],</span> <span class="n">mqe</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">mb_words</span><span class="p">[</span><span class="mi">50</span><span class="p">],</span>
			<span class="n">mboxq</span><span class="o">-&gt;</span><span class="n">mcqe</span><span class="p">.</span><span class="n">word0</span><span class="p">,</span>
			<span class="n">mboxq</span><span class="o">-&gt;</span><span class="n">mcqe</span><span class="p">.</span><span class="n">mcqe_tag0</span><span class="p">,</span> 	<span class="n">mboxq</span><span class="o">-&gt;</span><span class="n">mcqe</span><span class="p">.</span><span class="n">mcqe_tag1</span><span class="p">,</span>
			<span class="n">mboxq</span><span class="o">-&gt;</span><span class="n">mcqe</span><span class="p">.</span><span class="n">trailer</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lpfc_mbuf_free</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">virt</span><span class="p">,</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">phys</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">mp</span><span class="p">);</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out_free_mboxq</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">data_length</span> <span class="o">=</span> <span class="n">mqe</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">mb_words</span><span class="p">[</span><span class="mi">5</span><span class="p">];</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">data_length</span> <span class="o">&gt;</span> <span class="n">DMP_RGN23_SIZE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lpfc_mbuf_free</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">virt</span><span class="p">,</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">phys</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">mp</span><span class="p">);</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out_free_mboxq</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">lpfc_parse_fcoe_conf</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">virt</span><span class="p">,</span> <span class="n">data_length</span><span class="p">);</span>
	<span class="n">lpfc_mbuf_free</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">virt</span><span class="p">,</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">phys</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">mp</span><span class="p">);</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">out_free_mboxq:</span>
	<span class="n">mempool_free</span><span class="p">(</span><span class="n">mboxq</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">mbox_mem_pool</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_sli4_read_rev - Issue READ_REV and collect vpd data</span>
<span class="cm"> * @phba: pointer to lpfc hba data structure.</span>
<span class="cm"> * @mboxq: pointer to the LPFC_MBOXQ_t structure.</span>
<span class="cm"> * @vpd: pointer to the memory to hold resulting port vpd data.</span>
<span class="cm"> * @vpd_size: On input, the number of bytes allocated to @vpd.</span>
<span class="cm"> *	      On output, the number of data bytes in @vpd.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine executes a READ_REV SLI4 mailbox command.  In</span>
<span class="cm"> * addition, this routine gets the port vpd data.</span>
<span class="cm"> *</span>
<span class="cm"> * Return codes</span>
<span class="cm"> * 	0 - successful</span>
<span class="cm"> * 	-ENOMEM - could not allocated memory.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">lpfc_sli4_read_rev</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">,</span> <span class="n">LPFC_MBOXQ_t</span> <span class="o">*</span><span class="n">mboxq</span><span class="p">,</span>
		    <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">vpd</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="o">*</span><span class="n">vpd_size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">dma_size</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_dmabuf</span> <span class="o">*</span><span class="n">dmabuf</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_mqe</span> <span class="o">*</span><span class="n">mqe</span><span class="p">;</span>

	<span class="n">dmabuf</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_dmabuf</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dmabuf</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Get a DMA buffer for the vpd data resulting from the READ_REV</span>
<span class="cm">	 * mailbox command.</span>
<span class="cm">	 */</span>
	<span class="n">dma_size</span> <span class="o">=</span> <span class="o">*</span><span class="n">vpd_size</span><span class="p">;</span>
	<span class="n">dmabuf</span><span class="o">-&gt;</span><span class="n">virt</span> <span class="o">=</span> <span class="n">dma_alloc_coherent</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">pcidev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
					  <span class="n">dma_size</span><span class="p">,</span>
					  <span class="o">&amp;</span><span class="n">dmabuf</span><span class="o">-&gt;</span><span class="n">phys</span><span class="p">,</span>
					  <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dmabuf</span><span class="o">-&gt;</span><span class="n">virt</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">dmabuf</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">dmabuf</span><span class="o">-&gt;</span><span class="n">virt</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">dma_size</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * The SLI4 implementation of READ_REV conflicts at word1,</span>
<span class="cm">	 * bits 31:16 and SLI4 adds vpd functionality not present</span>
<span class="cm">	 * in SLI3.  This code corrects the conflicts.</span>
<span class="cm">	 */</span>
	<span class="n">lpfc_read_rev</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">mboxq</span><span class="p">);</span>
	<span class="n">mqe</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">mboxq</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">mqe</span><span class="p">;</span>
	<span class="n">mqe</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">read_rev</span><span class="p">.</span><span class="n">vpd_paddr_high</span> <span class="o">=</span> <span class="n">putPaddrHigh</span><span class="p">(</span><span class="n">dmabuf</span><span class="o">-&gt;</span><span class="n">phys</span><span class="p">);</span>
	<span class="n">mqe</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">read_rev</span><span class="p">.</span><span class="n">vpd_paddr_low</span> <span class="o">=</span> <span class="n">putPaddrLow</span><span class="p">(</span><span class="n">dmabuf</span><span class="o">-&gt;</span><span class="n">phys</span><span class="p">);</span>
	<span class="n">mqe</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">read_rev</span><span class="p">.</span><span class="n">word1</span> <span class="o">&amp;=</span> <span class="mh">0x0000FFFF</span><span class="p">;</span>
	<span class="n">bf_set</span><span class="p">(</span><span class="n">lpfc_mbx_rd_rev_vpd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mqe</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">read_rev</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">bf_set</span><span class="p">(</span><span class="n">lpfc_mbx_rd_rev_avail_len</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mqe</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">read_rev</span><span class="p">,</span> <span class="n">dma_size</span><span class="p">);</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">lpfc_sli_issue_mbox</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">mboxq</span><span class="p">,</span> <span class="n">MBX_POLL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dma_free_coherent</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">pcidev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">dma_size</span><span class="p">,</span>
				  <span class="n">dmabuf</span><span class="o">-&gt;</span><span class="n">virt</span><span class="p">,</span> <span class="n">dmabuf</span><span class="o">-&gt;</span><span class="n">phys</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">dmabuf</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * The available vpd length cannot be bigger than the</span>
<span class="cm">	 * DMA buffer passed to the port.  Catch the less than</span>
<span class="cm">	 * case and update the caller&#39;s size.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mqe</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">read_rev</span><span class="p">.</span><span class="n">avail_vpd_len</span> <span class="o">&lt;</span> <span class="o">*</span><span class="n">vpd_size</span><span class="p">)</span>
		<span class="o">*</span><span class="n">vpd_size</span> <span class="o">=</span> <span class="n">mqe</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">read_rev</span><span class="p">.</span><span class="n">avail_vpd_len</span><span class="p">;</span>

	<span class="n">memcpy</span><span class="p">(</span><span class="n">vpd</span><span class="p">,</span> <span class="n">dmabuf</span><span class="o">-&gt;</span><span class="n">virt</span><span class="p">,</span> <span class="o">*</span><span class="n">vpd_size</span><span class="p">);</span>

	<span class="n">dma_free_coherent</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">pcidev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">dma_size</span><span class="p">,</span>
			  <span class="n">dmabuf</span><span class="o">-&gt;</span><span class="n">virt</span><span class="p">,</span> <span class="n">dmabuf</span><span class="o">-&gt;</span><span class="n">phys</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">dmabuf</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_sli4_retrieve_pport_name - Retrieve SLI4 device physical port name</span>
<span class="cm"> * @phba: pointer to lpfc hba data structure.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine retrieves SLI4 device physical port name this PCI function</span>
<span class="cm"> * is attached to.</span>
<span class="cm"> *</span>
<span class="cm"> * Return codes</span>
<span class="cm"> *      0 - sucessful</span>
<span class="cm"> *      otherwise - failed to retrieve physical port name</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">lpfc_sli4_retrieve_pport_name</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">LPFC_MBOXQ_t</span> <span class="o">*</span><span class="n">mboxq</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_mbx_get_cntl_attributes</span> <span class="o">*</span><span class="n">mbx_cntl_attr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_controller_attribute</span> <span class="o">*</span><span class="n">cntl_attr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_mbx_get_port_name</span> <span class="o">*</span><span class="n">get_port_name</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">virtaddr</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">alloclen</span><span class="p">,</span> <span class="n">reqlen</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">shdr_status</span><span class="p">,</span> <span class="n">shdr_add_status</span><span class="p">;</span>
	<span class="k">union</span> <span class="n">lpfc_sli4_cfg_shdr</span> <span class="o">*</span><span class="n">shdr</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">cport_name</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="cm">/* We assume nothing at this point */</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">lnk_info</span><span class="p">.</span><span class="n">lnk_dv</span> <span class="o">=</span> <span class="n">LPFC_LNK_DAT_INVAL</span><span class="p">;</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">pport_name_sta</span> <span class="o">=</span> <span class="n">LPFC_SLI4_PPNAME_NON</span><span class="p">;</span>

	<span class="n">mboxq</span> <span class="o">=</span> <span class="p">(</span><span class="n">LPFC_MBOXQ_t</span> <span class="o">*</span><span class="p">)</span><span class="n">mempool_alloc</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">mbox_mem_pool</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mboxq</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="cm">/* obtain link type and link number via READ_CONFIG */</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">lnk_info</span><span class="p">.</span><span class="n">lnk_dv</span> <span class="o">=</span> <span class="n">LPFC_LNK_DAT_INVAL</span><span class="p">;</span>
	<span class="n">lpfc_sli4_read_config</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">lnk_info</span><span class="p">.</span><span class="n">lnk_dv</span> <span class="o">==</span> <span class="n">LPFC_LNK_DAT_VAL</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">retrieve_ppname</span><span class="p">;</span>

	<span class="cm">/* obtain link type and link number via COMMON_GET_CNTL_ATTRIBUTES */</span>
	<span class="n">reqlen</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_mbx_get_cntl_attributes</span><span class="p">);</span>
	<span class="n">alloclen</span> <span class="o">=</span> <span class="n">lpfc_sli4_config</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">mboxq</span><span class="p">,</span> <span class="n">LPFC_MBOX_SUBSYSTEM_COMMON</span><span class="p">,</span>
			<span class="n">LPFC_MBOX_OPCODE_GET_CNTL_ATTRIBUTES</span><span class="p">,</span> <span class="n">reqlen</span><span class="p">,</span>
			<span class="n">LPFC_SLI4_MBX_NEMBED</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">alloclen</span> <span class="o">&lt;</span> <span class="n">reqlen</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_SLI</span><span class="p">,</span>
				<span class="s">&quot;3084 Allocated DMA memory size (%d) is &quot;</span>
				<span class="s">&quot;less than the requested DMA memory size &quot;</span>
				<span class="s">&quot;(%d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">alloclen</span><span class="p">,</span> <span class="n">reqlen</span><span class="p">);</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out_free_mboxq</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">lpfc_sli_issue_mbox</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">mboxq</span><span class="p">,</span> <span class="n">MBX_POLL</span><span class="p">);</span>
	<span class="n">virtaddr</span> <span class="o">=</span> <span class="n">mboxq</span><span class="o">-&gt;</span><span class="n">sge_array</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="n">mbx_cntl_attr</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_mbx_get_cntl_attributes</span> <span class="o">*</span><span class="p">)</span><span class="n">virtaddr</span><span class="p">;</span>
	<span class="n">shdr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">mbx_cntl_attr</span><span class="o">-&gt;</span><span class="n">cfg_shdr</span><span class="p">;</span>
	<span class="n">shdr_status</span> <span class="o">=</span> <span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_mbox_hdr_status</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">shdr</span><span class="o">-&gt;</span><span class="n">response</span><span class="p">);</span>
	<span class="n">shdr_add_status</span> <span class="o">=</span> <span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_mbox_hdr_add_status</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">shdr</span><span class="o">-&gt;</span><span class="n">response</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">shdr_status</span> <span class="o">||</span> <span class="n">shdr_add_status</span> <span class="o">||</span> <span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_WARNING</span><span class="p">,</span> <span class="n">LOG_SLI</span><span class="p">,</span>
				<span class="s">&quot;3085 Mailbox x%x (x%x/x%x) failed, &quot;</span>
				<span class="s">&quot;rc:x%x, status:x%x, add_status:x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_mqe_command</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mboxq</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">mqe</span><span class="p">),</span>
				<span class="n">lpfc_sli_config_mbox_subsys_get</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">mboxq</span><span class="p">),</span>
				<span class="n">lpfc_sli_config_mbox_opcode_get</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">mboxq</span><span class="p">),</span>
				<span class="n">rc</span><span class="p">,</span> <span class="n">shdr_status</span><span class="p">,</span> <span class="n">shdr_add_status</span><span class="p">);</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENXIO</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out_free_mboxq</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">cntl_attr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">mbx_cntl_attr</span><span class="o">-&gt;</span><span class="n">cntl_attr</span><span class="p">;</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">lnk_info</span><span class="p">.</span><span class="n">lnk_dv</span> <span class="o">=</span> <span class="n">LPFC_LNK_DAT_VAL</span><span class="p">;</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">lnk_info</span><span class="p">.</span><span class="n">lnk_tp</span> <span class="o">=</span>
		<span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_cntl_attr_lnk_type</span><span class="p">,</span> <span class="n">cntl_attr</span><span class="p">);</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">lnk_info</span><span class="p">.</span><span class="n">lnk_no</span> <span class="o">=</span>
		<span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_cntl_attr_lnk_numb</span><span class="p">,</span> <span class="n">cntl_attr</span><span class="p">);</span>
	<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_INFO</span><span class="p">,</span> <span class="n">LOG_SLI</span><span class="p">,</span>
			<span class="s">&quot;3086 lnk_type:%d, lnk_numb:%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">lnk_info</span><span class="p">.</span><span class="n">lnk_tp</span><span class="p">,</span>
			<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">lnk_info</span><span class="p">.</span><span class="n">lnk_no</span><span class="p">);</span>

<span class="nl">retrieve_ppname:</span>
	<span class="n">lpfc_sli4_config</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">mboxq</span><span class="p">,</span> <span class="n">LPFC_MBOX_SUBSYSTEM_COMMON</span><span class="p">,</span>
		<span class="n">LPFC_MBOX_OPCODE_GET_PORT_NAME</span><span class="p">,</span>
		<span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_mbx_get_port_name</span><span class="p">)</span> <span class="o">-</span>
		<span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_sli4_cfg_mhdr</span><span class="p">),</span>
		<span class="n">LPFC_SLI4_MBX_EMBED</span><span class="p">);</span>
	<span class="n">get_port_name</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">mboxq</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">mqe</span><span class="p">.</span><span class="n">un</span><span class="p">.</span><span class="n">get_port_name</span><span class="p">;</span>
	<span class="n">shdr</span> <span class="o">=</span> <span class="p">(</span><span class="k">union</span> <span class="n">lpfc_sli4_cfg_shdr</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">get_port_name</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">cfg_shdr</span><span class="p">;</span>
	<span class="n">bf_set</span><span class="p">(</span><span class="n">lpfc_mbox_hdr_version</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">shdr</span><span class="o">-&gt;</span><span class="n">request</span><span class="p">,</span> <span class="n">LPFC_OPCODE_VERSION_1</span><span class="p">);</span>
	<span class="n">bf_set</span><span class="p">(</span><span class="n">lpfc_mbx_get_port_name_lnk_type</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">get_port_name</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">request</span><span class="p">,</span>
		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">lnk_info</span><span class="p">.</span><span class="n">lnk_tp</span><span class="p">);</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">lpfc_sli_issue_mbox</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">mboxq</span><span class="p">,</span> <span class="n">MBX_POLL</span><span class="p">);</span>
	<span class="n">shdr_status</span> <span class="o">=</span> <span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_mbox_hdr_status</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">shdr</span><span class="o">-&gt;</span><span class="n">response</span><span class="p">);</span>
	<span class="n">shdr_add_status</span> <span class="o">=</span> <span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_mbox_hdr_add_status</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">shdr</span><span class="o">-&gt;</span><span class="n">response</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">shdr_status</span> <span class="o">||</span> <span class="n">shdr_add_status</span> <span class="o">||</span> <span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_WARNING</span><span class="p">,</span> <span class="n">LOG_SLI</span><span class="p">,</span>
				<span class="s">&quot;3087 Mailbox x%x (x%x/x%x) failed: &quot;</span>
				<span class="s">&quot;rc:x%x, status:x%x, add_status:x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_mqe_command</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mboxq</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">mqe</span><span class="p">),</span>
				<span class="n">lpfc_sli_config_mbox_subsys_get</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">mboxq</span><span class="p">),</span>
				<span class="n">lpfc_sli_config_mbox_opcode_get</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">mboxq</span><span class="p">),</span>
				<span class="n">rc</span><span class="p">,</span> <span class="n">shdr_status</span><span class="p">,</span> <span class="n">shdr_add_status</span><span class="p">);</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENXIO</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out_free_mboxq</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">lnk_info</span><span class="p">.</span><span class="n">lnk_no</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">LPFC_LINK_NUMBER_0</span>:
		<span class="n">cport_name</span> <span class="o">=</span> <span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_mbx_get_port_name_name0</span><span class="p">,</span>
				<span class="o">&amp;</span><span class="n">get_port_name</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">response</span><span class="p">);</span>
		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">pport_name_sta</span> <span class="o">=</span> <span class="n">LPFC_SLI4_PPNAME_GET</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">LPFC_LINK_NUMBER_1</span>:
		<span class="n">cport_name</span> <span class="o">=</span> <span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_mbx_get_port_name_name1</span><span class="p">,</span>
				<span class="o">&amp;</span><span class="n">get_port_name</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">response</span><span class="p">);</span>
		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">pport_name_sta</span> <span class="o">=</span> <span class="n">LPFC_SLI4_PPNAME_GET</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">LPFC_LINK_NUMBER_2</span>:
		<span class="n">cport_name</span> <span class="o">=</span> <span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_mbx_get_port_name_name2</span><span class="p">,</span>
				<span class="o">&amp;</span><span class="n">get_port_name</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">response</span><span class="p">);</span>
		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">pport_name_sta</span> <span class="o">=</span> <span class="n">LPFC_SLI4_PPNAME_GET</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">LPFC_LINK_NUMBER_3</span>:
		<span class="n">cport_name</span> <span class="o">=</span> <span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_mbx_get_port_name_name3</span><span class="p">,</span>
				<span class="o">&amp;</span><span class="n">get_port_name</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">response</span><span class="p">);</span>
		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">pport_name_sta</span> <span class="o">=</span> <span class="n">LPFC_SLI4_PPNAME_GET</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">pport_name_sta</span> <span class="o">==</span> <span class="n">LPFC_SLI4_PPNAME_GET</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">Port</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">cport_name</span><span class="p">;</span>
		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">Port</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;\0&#39;</span><span class="p">;</span>
		<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_INFO</span><span class="p">,</span> <span class="n">LOG_SLI</span><span class="p">,</span>
				<span class="s">&quot;3091 SLI get port name: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">Port</span><span class="p">);</span>
	<span class="p">}</span>

<span class="nl">out_free_mboxq:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">!=</span> <span class="n">MBX_TIMEOUT</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_mqe_command</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mboxq</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">mqe</span><span class="p">)</span> <span class="o">==</span> <span class="n">MBX_SLI4_CONFIG</span><span class="p">)</span>
			<span class="n">lpfc_sli4_mbox_cmd_free</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">mboxq</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">mempool_free</span><span class="p">(</span><span class="n">mboxq</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">mbox_mem_pool</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_sli4_arm_cqeq_intr - Arm sli-4 device completion and event queues</span>
<span class="cm"> * @phba: pointer to lpfc hba data structure.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine is called to explicitly arm the SLI4 device&#39;s completion and</span>
<span class="cm"> * event queues</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">lpfc_sli4_arm_cqeq_intr</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">uint8_t</span> <span class="n">fcp_eqidx</span><span class="p">;</span>

	<span class="n">lpfc_sli4_cq_release</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">mbx_cq</span><span class="p">,</span> <span class="n">LPFC_QUEUE_REARM</span><span class="p">);</span>
	<span class="n">lpfc_sli4_cq_release</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">els_cq</span><span class="p">,</span> <span class="n">LPFC_QUEUE_REARM</span><span class="p">);</span>
	<span class="n">fcp_eqidx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">fcp_cq</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">do</span>
			<span class="n">lpfc_sli4_cq_release</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">fcp_cq</span><span class="p">[</span><span class="n">fcp_eqidx</span><span class="p">],</span>
					     <span class="n">LPFC_QUEUE_REARM</span><span class="p">);</span>
		<span class="k">while</span> <span class="p">(</span><span class="o">++</span><span class="n">fcp_eqidx</span> <span class="o">&lt;</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">cfg_fcp_eq_count</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">lpfc_sli4_eq_release</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">sp_eq</span><span class="p">,</span> <span class="n">LPFC_QUEUE_REARM</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">fp_eq</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">fcp_eqidx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">fcp_eqidx</span> <span class="o">&lt;</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">cfg_fcp_eq_count</span><span class="p">;</span>
		     <span class="n">fcp_eqidx</span><span class="o">++</span><span class="p">)</span>
			<span class="n">lpfc_sli4_eq_release</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">fp_eq</span><span class="p">[</span><span class="n">fcp_eqidx</span><span class="p">],</span>
					     <span class="n">LPFC_QUEUE_REARM</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_sli4_get_avail_extnt_rsrc - Get available resource extent count.</span>
<span class="cm"> * @phba: Pointer to HBA context object.</span>
<span class="cm"> * @type: The resource extent type.</span>
<span class="cm"> * @extnt_count: buffer to hold port available extent count.</span>
<span class="cm"> * @extnt_size: buffer to hold element count per extent.</span>
<span class="cm"> *</span>
<span class="cm"> * This function calls the port and retrievs the number of available</span>
<span class="cm"> * extents and their size for a particular extent type.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns: 0 if successful.  Nonzero otherwise.</span>
<span class="cm"> **/</span>
<span class="kt">int</span>
<span class="nf">lpfc_sli4_get_avail_extnt_rsrc</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">,</span> <span class="kt">uint16_t</span> <span class="n">type</span><span class="p">,</span>
			       <span class="kt">uint16_t</span> <span class="o">*</span><span class="n">extnt_count</span><span class="p">,</span> <span class="kt">uint16_t</span> <span class="o">*</span><span class="n">extnt_size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">length</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">mbox_tmo</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_mbx_get_rsrc_extent_info</span> <span class="o">*</span><span class="n">rsrc_info</span><span class="p">;</span>
	<span class="n">LPFC_MBOXQ_t</span> <span class="o">*</span><span class="n">mbox</span><span class="p">;</span>

	<span class="n">mbox</span> <span class="o">=</span> <span class="p">(</span><span class="n">LPFC_MBOXQ_t</span> <span class="o">*</span><span class="p">)</span> <span class="n">mempool_alloc</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">mbox_mem_pool</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mbox</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="cm">/* Find out how many extents are available for this resource type */</span>
	<span class="n">length</span> <span class="o">=</span> <span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_mbx_get_rsrc_extent_info</span><span class="p">)</span> <span class="o">-</span>
		  <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_sli4_cfg_mhdr</span><span class="p">));</span>
	<span class="n">lpfc_sli4_config</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">mbox</span><span class="p">,</span> <span class="n">LPFC_MBOX_SUBSYSTEM_COMMON</span><span class="p">,</span>
			 <span class="n">LPFC_MBOX_OPCODE_GET_RSRC_EXTENT_INFO</span><span class="p">,</span>
			 <span class="n">length</span><span class="p">,</span> <span class="n">LPFC_SLI4_MBX_EMBED</span><span class="p">);</span>

	<span class="cm">/* Send an extents count of 0 - the GET doesn&#39;t use it. */</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">lpfc_sli4_mbox_rsrc_extent</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">mbox</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">type</span><span class="p">,</span>
					<span class="n">LPFC_SLI4_MBX_EMBED</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">rc</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">err_exit</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">intr_enable</span><span class="p">)</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">lpfc_sli_issue_mbox</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">mbox</span><span class="p">,</span> <span class="n">MBX_POLL</span><span class="p">);</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="n">mbox_tmo</span> <span class="o">=</span> <span class="n">lpfc_mbox_tmo_val</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">mbox</span><span class="p">);</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">lpfc_sli_issue_mbox_wait</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">mbox</span><span class="p">,</span> <span class="n">mbox_tmo</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">rc</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">err_exit</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">rsrc_info</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">mbox</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">mqe</span><span class="p">.</span><span class="n">un</span><span class="p">.</span><span class="n">rsrc_extent_info</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_mbox_hdr_status</span><span class="p">,</span>
		   <span class="o">&amp;</span><span class="n">rsrc_info</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">cfg_shdr</span><span class="p">.</span><span class="n">response</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_MBOX</span> <span class="o">|</span> <span class="n">LOG_INIT</span><span class="p">,</span>
				<span class="s">&quot;2930 Failed to get resource extents &quot;</span>
				<span class="s">&quot;Status 0x%x Add&#39;l Status 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_mbox_hdr_status</span><span class="p">,</span>
				       <span class="o">&amp;</span><span class="n">rsrc_info</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">cfg_shdr</span><span class="p">.</span><span class="n">response</span><span class="p">),</span>
				<span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_mbox_hdr_add_status</span><span class="p">,</span>
				       <span class="o">&amp;</span><span class="n">rsrc_info</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">cfg_shdr</span><span class="p">.</span><span class="n">response</span><span class="p">));</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">err_exit</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="o">*</span><span class="n">extnt_count</span> <span class="o">=</span> <span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_mbx_get_rsrc_extent_info_cnt</span><span class="p">,</span>
			      <span class="o">&amp;</span><span class="n">rsrc_info</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">rsp</span><span class="p">);</span>
	<span class="o">*</span><span class="n">extnt_size</span> <span class="o">=</span> <span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_mbx_get_rsrc_extent_info_size</span><span class="p">,</span>
			     <span class="o">&amp;</span><span class="n">rsrc_info</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">rsp</span><span class="p">);</span>

	<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_INFO</span><span class="p">,</span> <span class="n">LOG_SLI</span><span class="p">,</span>
			<span class="s">&quot;3162 Retrieved extents type-%d from port: count:%d, &quot;</span>
			<span class="s">&quot;size:%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">type</span><span class="p">,</span> <span class="o">*</span><span class="n">extnt_count</span><span class="p">,</span> <span class="o">*</span><span class="n">extnt_size</span><span class="p">);</span>

<span class="nl">err_exit:</span>
	<span class="n">mempool_free</span><span class="p">(</span><span class="n">mbox</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">mbox_mem_pool</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_sli4_chk_avail_extnt_rsrc - Check for available SLI4 resource extents.</span>
<span class="cm"> * @phba: Pointer to HBA context object.</span>
<span class="cm"> * @type: The extent type to check.</span>
<span class="cm"> *</span>
<span class="cm"> * This function reads the current available extents from the port and checks</span>
<span class="cm"> * if the extent count or extent size has changed since the last access.</span>
<span class="cm"> * Callers use this routine post port reset to understand if there is a</span>
<span class="cm"> * extent reprovisioning requirement.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns:</span>
<span class="cm"> *   -Error: error indicates problem.</span>
<span class="cm"> *   1: Extent count or size has changed.</span>
<span class="cm"> *   0: No changes.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">lpfc_sli4_chk_avail_extnt_rsrc</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">,</span> <span class="kt">uint16_t</span> <span class="n">type</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">uint16_t</span> <span class="n">curr_ext_cnt</span><span class="p">,</span> <span class="n">rsrc_ext_cnt</span><span class="p">;</span>
	<span class="kt">uint16_t</span> <span class="n">size_diff</span><span class="p">,</span> <span class="n">rsrc_ext_size</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_rsrc_blks</span> <span class="o">*</span><span class="n">rsrc_entry</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">rsrc_blk_list</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">size_diff</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">curr_ext_cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">lpfc_sli4_get_avail_extnt_rsrc</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">type</span><span class="p">,</span>
					    <span class="o">&amp;</span><span class="n">rsrc_ext_cnt</span><span class="p">,</span>
					    <span class="o">&amp;</span><span class="n">rsrc_ext_size</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">rc</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">type</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">LPFC_RSC_TYPE_FCOE_RPI</span>:
		<span class="n">rsrc_blk_list</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">lpfc_rpi_blk_list</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">LPFC_RSC_TYPE_FCOE_VPI</span>:
		<span class="n">rsrc_blk_list</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">lpfc_vpi_blk_list</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">LPFC_RSC_TYPE_FCOE_XRI</span>:
		<span class="n">rsrc_blk_list</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">lpfc_xri_blk_list</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">LPFC_RSC_TYPE_FCOE_VFI</span>:
		<span class="n">rsrc_blk_list</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">lpfc_vfi_blk_list</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">rsrc_entry</span><span class="p">,</span> <span class="n">rsrc_blk_list</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">curr_ext_cnt</span><span class="o">++</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rsrc_entry</span><span class="o">-&gt;</span><span class="n">rsrc_size</span> <span class="o">!=</span> <span class="n">rsrc_ext_size</span><span class="p">)</span>
			<span class="n">size_diff</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">curr_ext_cnt</span> <span class="o">!=</span> <span class="n">rsrc_ext_cnt</span> <span class="o">||</span> <span class="n">size_diff</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_sli4_cfg_post_extnts -</span>
<span class="cm"> * @phba: Pointer to HBA context object.</span>
<span class="cm"> * @extnt_cnt - number of available extents.</span>
<span class="cm"> * @type - the extent type (rpi, xri, vfi, vpi).</span>
<span class="cm"> * @emb - buffer to hold either MBX_EMBED or MBX_NEMBED operation.</span>
<span class="cm"> * @mbox - pointer to the caller&#39;s allocated mailbox structure.</span>
<span class="cm"> *</span>
<span class="cm"> * This function executes the extents allocation request.  It also</span>
<span class="cm"> * takes care of the amount of memory needed to allocate or get the</span>
<span class="cm"> * allocated extents. It is the caller&#39;s responsibility to evaluate</span>
<span class="cm"> * the response.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns:</span>
<span class="cm"> *   -Error:  Error value describes the condition found.</span>
<span class="cm"> *   0: if successful</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">lpfc_sli4_cfg_post_extnts</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">,</span> <span class="kt">uint16_t</span> <span class="n">extnt_cnt</span><span class="p">,</span>
			  <span class="kt">uint16_t</span> <span class="n">type</span><span class="p">,</span> <span class="n">bool</span> <span class="o">*</span><span class="n">emb</span><span class="p">,</span> <span class="n">LPFC_MBOXQ_t</span> <span class="o">*</span><span class="n">mbox</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">req_len</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">emb_len</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">alloc_len</span><span class="p">,</span> <span class="n">mbox_tmo</span><span class="p">;</span>

	<span class="cm">/* Calculate the total requested length of the dma memory */</span>
	<span class="n">req_len</span> <span class="o">=</span> <span class="n">extnt_cnt</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">uint16_t</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Calculate the size of an embedded mailbox.  The uint32_t</span>
<span class="cm">	 * accounts for extents-specific word.</span>
<span class="cm">	 */</span>
	<span class="n">emb_len</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">MAILBOX_t</span><span class="p">)</span> <span class="o">-</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">mbox_header</span><span class="p">)</span> <span class="o">-</span>
		<span class="k">sizeof</span><span class="p">(</span><span class="kt">uint32_t</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Presume the allocation and response will fit into an embedded</span>
<span class="cm">	 * mailbox.  If not true, reconfigure to a non-embedded mailbox.</span>
<span class="cm">	 */</span>
	<span class="o">*</span><span class="n">emb</span> <span class="o">=</span> <span class="n">LPFC_SLI4_MBX_EMBED</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">req_len</span> <span class="o">&gt;</span> <span class="n">emb_len</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">req_len</span> <span class="o">=</span> <span class="n">extnt_cnt</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">uint16_t</span><span class="p">)</span> <span class="o">+</span>
			<span class="k">sizeof</span><span class="p">(</span><span class="k">union</span> <span class="n">lpfc_sli4_cfg_shdr</span><span class="p">)</span> <span class="o">+</span>
			<span class="k">sizeof</span><span class="p">(</span><span class="kt">uint32_t</span><span class="p">);</span>
		<span class="o">*</span><span class="n">emb</span> <span class="o">=</span> <span class="n">LPFC_SLI4_MBX_NEMBED</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">alloc_len</span> <span class="o">=</span> <span class="n">lpfc_sli4_config</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">mbox</span><span class="p">,</span> <span class="n">LPFC_MBOX_SUBSYSTEM_COMMON</span><span class="p">,</span>
				     <span class="n">LPFC_MBOX_OPCODE_ALLOC_RSRC_EXTENT</span><span class="p">,</span>
				     <span class="n">req_len</span><span class="p">,</span> <span class="o">*</span><span class="n">emb</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">alloc_len</span> <span class="o">&lt;</span> <span class="n">req_len</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_INIT</span><span class="p">,</span>
			<span class="s">&quot;2982 Allocated DMA memory size (x%x) is &quot;</span>
			<span class="s">&quot;less than the requested DMA memory &quot;</span>
			<span class="s">&quot;size (x%x)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">alloc_len</span><span class="p">,</span> <span class="n">req_len</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">lpfc_sli4_mbox_rsrc_extent</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">mbox</span><span class="p">,</span> <span class="n">extnt_cnt</span><span class="p">,</span> <span class="n">type</span><span class="p">,</span> <span class="o">*</span><span class="n">emb</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">rc</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">intr_enable</span><span class="p">)</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">lpfc_sli_issue_mbox</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">mbox</span><span class="p">,</span> <span class="n">MBX_POLL</span><span class="p">);</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="n">mbox_tmo</span> <span class="o">=</span> <span class="n">lpfc_mbox_tmo_val</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">mbox</span><span class="p">);</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">lpfc_sli_issue_mbox_wait</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">mbox</span><span class="p">,</span> <span class="n">mbox_tmo</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">rc</span><span class="p">))</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_sli4_alloc_extent - Allocate an SLI4 resource extent.</span>
<span class="cm"> * @phba: Pointer to HBA context object.</span>
<span class="cm"> * @type:  The resource extent type to allocate.</span>
<span class="cm"> *</span>
<span class="cm"> * This function allocates the number of elements for the specified</span>
<span class="cm"> * resource type.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">lpfc_sli4_alloc_extent</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">,</span> <span class="kt">uint16_t</span> <span class="n">type</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">bool</span> <span class="n">emb</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="kt">uint16_t</span> <span class="n">rsrc_id_cnt</span><span class="p">,</span> <span class="n">rsrc_cnt</span><span class="p">,</span> <span class="n">rsrc_size</span><span class="p">;</span>
	<span class="kt">uint16_t</span> <span class="n">rsrc_id</span><span class="p">,</span> <span class="n">rsrc_start</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">;</span>
	<span class="kt">uint16_t</span> <span class="o">*</span><span class="n">ids</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">rc</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">longs</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">bmask</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_rsrc_blks</span> <span class="o">*</span><span class="n">rsrc_blks</span><span class="p">;</span>
	<span class="n">LPFC_MBOXQ_t</span> <span class="o">*</span><span class="n">mbox</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">length</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_id_range</span> <span class="o">*</span><span class="n">id_array</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">virtaddr</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_mbx_nembed_rsrc_extent</span> <span class="o">*</span><span class="n">n_rsrc</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_mbx_alloc_rsrc_extents</span> <span class="o">*</span><span class="n">rsrc_ext</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">ext_blk_list</span><span class="p">;</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">lpfc_sli4_get_avail_extnt_rsrc</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">type</span><span class="p">,</span>
					    <span class="o">&amp;</span><span class="n">rsrc_cnt</span><span class="p">,</span>
					    <span class="o">&amp;</span><span class="n">rsrc_size</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">rc</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">rsrc_cnt</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">rsrc_size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_MBOX</span> <span class="o">|</span> <span class="n">LOG_INIT</span><span class="p">,</span>
			<span class="s">&quot;3009 No available Resource Extents &quot;</span>
			<span class="s">&quot;for resource type 0x%x: Count: 0x%x, &quot;</span>
			<span class="s">&quot;Size 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">type</span><span class="p">,</span> <span class="n">rsrc_cnt</span><span class="p">,</span>
			<span class="n">rsrc_size</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_INFO</span><span class="p">,</span> <span class="n">LOG_MBOX</span> <span class="o">|</span> <span class="n">LOG_INIT</span> <span class="o">|</span> <span class="n">LOG_SLI</span><span class="p">,</span>
			<span class="s">&quot;2903 Post resource extents type-0x%x: &quot;</span>
			<span class="s">&quot;count:%d, size %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">type</span><span class="p">,</span> <span class="n">rsrc_cnt</span><span class="p">,</span> <span class="n">rsrc_size</span><span class="p">);</span>

	<span class="n">mbox</span> <span class="o">=</span> <span class="p">(</span><span class="n">LPFC_MBOXQ_t</span> <span class="o">*</span><span class="p">)</span> <span class="n">mempool_alloc</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">mbox_mem_pool</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mbox</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">lpfc_sli4_cfg_post_extnts</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">rsrc_cnt</span><span class="p">,</span> <span class="n">type</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">emb</span><span class="p">,</span> <span class="n">mbox</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">rc</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">err_exit</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Figure out where the response is located.  Then get local pointers</span>
<span class="cm">	 * to the response data.  The port does not guarantee to respond to</span>
<span class="cm">	 * all extents counts request so update the local variable with the</span>
<span class="cm">	 * allocated count from the port.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">emb</span> <span class="o">==</span> <span class="n">LPFC_SLI4_MBX_EMBED</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rsrc_ext</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">mbox</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">mqe</span><span class="p">.</span><span class="n">un</span><span class="p">.</span><span class="n">alloc_rsrc_extents</span><span class="p">;</span>
		<span class="n">id_array</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">rsrc_ext</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">rsp</span><span class="p">.</span><span class="n">id</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
		<span class="n">rsrc_cnt</span> <span class="o">=</span> <span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_mbx_rsrc_cnt</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rsrc_ext</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">rsp</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">virtaddr</span> <span class="o">=</span> <span class="n">mbox</span><span class="o">-&gt;</span><span class="n">sge_array</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
		<span class="n">n_rsrc</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_mbx_nembed_rsrc_extent</span> <span class="o">*</span><span class="p">)</span> <span class="n">virtaddr</span><span class="p">;</span>
		<span class="n">rsrc_cnt</span> <span class="o">=</span> <span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_mbx_rsrc_cnt</span><span class="p">,</span> <span class="n">n_rsrc</span><span class="p">);</span>
		<span class="n">id_array</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">n_rsrc</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">longs</span> <span class="o">=</span> <span class="p">((</span><span class="n">rsrc_cnt</span> <span class="o">*</span> <span class="n">rsrc_size</span><span class="p">)</span> <span class="o">+</span> <span class="n">BITS_PER_LONG</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">BITS_PER_LONG</span><span class="p">;</span>
	<span class="n">rsrc_id_cnt</span> <span class="o">=</span> <span class="n">rsrc_cnt</span> <span class="o">*</span> <span class="n">rsrc_size</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Based on the resource size and count, correct the base and max</span>
<span class="cm">	 * resource values.</span>
<span class="cm">	 */</span>
	<span class="n">length</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_rsrc_blks</span><span class="p">);</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">type</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">LPFC_RSC_TYPE_FCOE_RPI</span>:
		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">rpi_bmask</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="n">longs</span> <span class="o">*</span>
						   <span class="k">sizeof</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">),</span>
						   <span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">rpi_bmask</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">err_exit</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">rpi_ids</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="n">rsrc_id_cnt</span> <span class="o">*</span>
						 <span class="k">sizeof</span><span class="p">(</span><span class="kt">uint16_t</span><span class="p">),</span>
						 <span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">rpi_ids</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">kfree</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">rpi_bmask</span><span class="p">);</span>
			<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">err_exit</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 * The next_rpi was initialized with the maximum available</span>
<span class="cm">		 * count but the port may allocate a smaller number.  Catch</span>
<span class="cm">		 * that case and update the next_rpi.</span>
<span class="cm">		 */</span>
		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">next_rpi</span> <span class="o">=</span> <span class="n">rsrc_id_cnt</span><span class="p">;</span>

		<span class="cm">/* Initialize local ptrs for common extent processing later. */</span>
		<span class="n">bmask</span> <span class="o">=</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">rpi_bmask</span><span class="p">;</span>
		<span class="n">ids</span> <span class="o">=</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">rpi_ids</span><span class="p">;</span>
		<span class="n">ext_blk_list</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">lpfc_rpi_blk_list</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">LPFC_RSC_TYPE_FCOE_VPI</span>:
		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">vpi_bmask</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="n">longs</span> <span class="o">*</span>
					  <span class="k">sizeof</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">),</span>
					  <span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">vpi_bmask</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">err_exit</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">vpi_ids</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="n">rsrc_id_cnt</span> <span class="o">*</span>
					 <span class="k">sizeof</span><span class="p">(</span><span class="kt">uint16_t</span><span class="p">),</span>
					 <span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">vpi_ids</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">kfree</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">vpi_bmask</span><span class="p">);</span>
			<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">err_exit</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* Initialize local ptrs for common extent processing later. */</span>
		<span class="n">bmask</span> <span class="o">=</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">vpi_bmask</span><span class="p">;</span>
		<span class="n">ids</span> <span class="o">=</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">vpi_ids</span><span class="p">;</span>
		<span class="n">ext_blk_list</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">lpfc_vpi_blk_list</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">LPFC_RSC_TYPE_FCOE_XRI</span>:
		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">xri_bmask</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="n">longs</span> <span class="o">*</span>
						   <span class="k">sizeof</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">),</span>
						   <span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">xri_bmask</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">err_exit</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">max_cfg_param</span><span class="p">.</span><span class="n">xri_used</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">xri_ids</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="n">rsrc_id_cnt</span> <span class="o">*</span>
						 <span class="k">sizeof</span><span class="p">(</span><span class="kt">uint16_t</span><span class="p">),</span>
						 <span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">xri_ids</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">kfree</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">xri_bmask</span><span class="p">);</span>
			<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">err_exit</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* Initialize local ptrs for common extent processing later. */</span>
		<span class="n">bmask</span> <span class="o">=</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">xri_bmask</span><span class="p">;</span>
		<span class="n">ids</span> <span class="o">=</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">xri_ids</span><span class="p">;</span>
		<span class="n">ext_blk_list</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">lpfc_xri_blk_list</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">LPFC_RSC_TYPE_FCOE_VFI</span>:
		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">vfi_bmask</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="n">longs</span> <span class="o">*</span>
						   <span class="k">sizeof</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">),</span>
						   <span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">vfi_bmask</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">err_exit</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">vfi_ids</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="n">rsrc_id_cnt</span> <span class="o">*</span>
						 <span class="k">sizeof</span><span class="p">(</span><span class="kt">uint16_t</span><span class="p">),</span>
						 <span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">vfi_ids</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">kfree</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">vfi_bmask</span><span class="p">);</span>
			<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">err_exit</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* Initialize local ptrs for common extent processing later. */</span>
		<span class="n">bmask</span> <span class="o">=</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">vfi_bmask</span><span class="p">;</span>
		<span class="n">ids</span> <span class="o">=</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">vfi_ids</span><span class="p">;</span>
		<span class="n">ext_blk_list</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">lpfc_vfi_blk_list</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="cm">/* Unsupported Opcode.  Fail call. */</span>
		<span class="n">id_array</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">bmask</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">ids</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">ext_blk_list</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">err_exit</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Complete initializing the extent configuration with the</span>
<span class="cm">	 * allocated ids assigned to this function.  The bitmask serves</span>
<span class="cm">	 * as an index into the array and manages the available ids.  The</span>
<span class="cm">	 * array just stores the ids communicated to the port via the wqes.</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">rsrc_cnt</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">i</span> <span class="o">%</span> <span class="mi">2</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">rsrc_id</span> <span class="o">=</span> <span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_mbx_rsrc_id_word4_0</span><span class="p">,</span>
					 <span class="o">&amp;</span><span class="n">id_array</span><span class="p">[</span><span class="n">k</span><span class="p">]);</span>
		<span class="k">else</span>
			<span class="n">rsrc_id</span> <span class="o">=</span> <span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_mbx_rsrc_id_word4_1</span><span class="p">,</span>
					 <span class="o">&amp;</span><span class="n">id_array</span><span class="p">[</span><span class="n">k</span><span class="p">]);</span>

		<span class="n">rsrc_blks</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="n">length</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">rsrc_blks</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
			<span class="n">kfree</span><span class="p">(</span><span class="n">bmask</span><span class="p">);</span>
			<span class="n">kfree</span><span class="p">(</span><span class="n">ids</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">err_exit</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">rsrc_blks</span><span class="o">-&gt;</span><span class="n">rsrc_start</span> <span class="o">=</span> <span class="n">rsrc_id</span><span class="p">;</span>
		<span class="n">rsrc_blks</span><span class="o">-&gt;</span><span class="n">rsrc_size</span> <span class="o">=</span> <span class="n">rsrc_size</span><span class="p">;</span>
		<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rsrc_blks</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="n">ext_blk_list</span><span class="p">);</span>
		<span class="n">rsrc_start</span> <span class="o">=</span> <span class="n">rsrc_id</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">type</span> <span class="o">==</span> <span class="n">LPFC_RSC_TYPE_FCOE_XRI</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">j</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span>
			<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">scsi_xri_start</span> <span class="o">=</span> <span class="n">rsrc_start</span> <span class="o">+</span>
				<span class="n">lpfc_sli4_get_els_iocb_cnt</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>

		<span class="k">while</span> <span class="p">(</span><span class="n">rsrc_id</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">rsrc_start</span> <span class="o">+</span> <span class="n">rsrc_size</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">ids</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">rsrc_id</span><span class="p">;</span>
			<span class="n">rsrc_id</span><span class="o">++</span><span class="p">;</span>
			<span class="n">j</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/* Entire word processed.  Get next word.*/</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">i</span> <span class="o">%</span> <span class="mi">2</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
			<span class="n">k</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
 <span class="nl">err_exit:</span>
	<span class="n">lpfc_sli4_mbox_cmd_free</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">mbox</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_sli4_dealloc_extent - Deallocate an SLI4 resource extent.</span>
<span class="cm"> * @phba: Pointer to HBA context object.</span>
<span class="cm"> * @type: the extent&#39;s type.</span>
<span class="cm"> *</span>
<span class="cm"> * This function deallocates all extents of a particular resource type.</span>
<span class="cm"> * SLI4 does not allow for deallocating a particular extent range.  It</span>
<span class="cm"> * is the caller&#39;s responsibility to release all kernel memory resources.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">lpfc_sli4_dealloc_extent</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">,</span> <span class="kt">uint16_t</span> <span class="n">type</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">length</span><span class="p">,</span> <span class="n">mbox_tmo</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">LPFC_MBOXQ_t</span> <span class="o">*</span><span class="n">mbox</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_mbx_dealloc_rsrc_extents</span> <span class="o">*</span><span class="n">dealloc_rsrc</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_rsrc_blks</span> <span class="o">*</span><span class="n">rsrc_blk</span><span class="p">,</span> <span class="o">*</span><span class="n">rsrc_blk_next</span><span class="p">;</span>

	<span class="n">mbox</span> <span class="o">=</span> <span class="p">(</span><span class="n">LPFC_MBOXQ_t</span> <span class="o">*</span><span class="p">)</span> <span class="n">mempool_alloc</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">mbox_mem_pool</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mbox</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * This function sends an embedded mailbox because it only sends the</span>
<span class="cm">	 * the resource type.  All extents of this type are released by the</span>
<span class="cm">	 * port.</span>
<span class="cm">	 */</span>
	<span class="n">length</span> <span class="o">=</span> <span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_mbx_dealloc_rsrc_extents</span><span class="p">)</span> <span class="o">-</span>
		  <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_sli4_cfg_mhdr</span><span class="p">));</span>
	<span class="n">lpfc_sli4_config</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">mbox</span><span class="p">,</span> <span class="n">LPFC_MBOX_SUBSYSTEM_COMMON</span><span class="p">,</span>
			 <span class="n">LPFC_MBOX_OPCODE_DEALLOC_RSRC_EXTENT</span><span class="p">,</span>
			 <span class="n">length</span><span class="p">,</span> <span class="n">LPFC_SLI4_MBX_EMBED</span><span class="p">);</span>

	<span class="cm">/* Send an extents count of 0 - the dealloc doesn&#39;t use it. */</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">lpfc_sli4_mbox_rsrc_extent</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">mbox</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">type</span><span class="p">,</span>
					<span class="n">LPFC_SLI4_MBX_EMBED</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">rc</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out_free_mbox</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">intr_enable</span><span class="p">)</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">lpfc_sli_issue_mbox</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">mbox</span><span class="p">,</span> <span class="n">MBX_POLL</span><span class="p">);</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="n">mbox_tmo</span> <span class="o">=</span> <span class="n">lpfc_mbox_tmo_val</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">mbox</span><span class="p">);</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">lpfc_sli_issue_mbox_wait</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">mbox</span><span class="p">,</span> <span class="n">mbox_tmo</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">rc</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out_free_mbox</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">dealloc_rsrc</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">mbox</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">mqe</span><span class="p">.</span><span class="n">un</span><span class="p">.</span><span class="n">dealloc_rsrc_extents</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_mbox_hdr_status</span><span class="p">,</span>
		   <span class="o">&amp;</span><span class="n">dealloc_rsrc</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">cfg_shdr</span><span class="p">.</span><span class="n">response</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_MBOX</span> <span class="o">|</span> <span class="n">LOG_INIT</span><span class="p">,</span>
				<span class="s">&quot;2919 Failed to release resource extents &quot;</span>
				<span class="s">&quot;for type %d - Status 0x%x Add&#39;l Status 0x%x. &quot;</span>
				<span class="s">&quot;Resource memory not released.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">type</span><span class="p">,</span>
				<span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_mbox_hdr_status</span><span class="p">,</span>
				    <span class="o">&amp;</span><span class="n">dealloc_rsrc</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">cfg_shdr</span><span class="p">.</span><span class="n">response</span><span class="p">),</span>
				<span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_mbox_hdr_add_status</span><span class="p">,</span>
				    <span class="o">&amp;</span><span class="n">dealloc_rsrc</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">cfg_shdr</span><span class="p">.</span><span class="n">response</span><span class="p">));</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out_free_mbox</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Release kernel memory resources for the specific type. */</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">type</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">LPFC_RSC_TYPE_FCOE_VPI</span>:
		<span class="n">kfree</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">vpi_bmask</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">vpi_ids</span><span class="p">);</span>
		<span class="n">bf_set</span><span class="p">(</span><span class="n">lpfc_vpi_rsrc_rdy</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">sli4_flags</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">rsrc_blk</span><span class="p">,</span> <span class="n">rsrc_blk_next</span><span class="p">,</span>
				    <span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">lpfc_vpi_blk_list</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rsrc_blk</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
			<span class="n">kfree</span><span class="p">(</span><span class="n">rsrc_blk</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">LPFC_RSC_TYPE_FCOE_XRI</span>:
		<span class="n">kfree</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">xri_bmask</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">xri_ids</span><span class="p">);</span>
		<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">rsrc_blk</span><span class="p">,</span> <span class="n">rsrc_blk_next</span><span class="p">,</span>
				    <span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">lpfc_xri_blk_list</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rsrc_blk</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
			<span class="n">kfree</span><span class="p">(</span><span class="n">rsrc_blk</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">LPFC_RSC_TYPE_FCOE_VFI</span>:
		<span class="n">kfree</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">vfi_bmask</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">vfi_ids</span><span class="p">);</span>
		<span class="n">bf_set</span><span class="p">(</span><span class="n">lpfc_vfi_rsrc_rdy</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">sli4_flags</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">rsrc_blk</span><span class="p">,</span> <span class="n">rsrc_blk_next</span><span class="p">,</span>
				    <span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">lpfc_vfi_blk_list</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rsrc_blk</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
			<span class="n">kfree</span><span class="p">(</span><span class="n">rsrc_blk</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">LPFC_RSC_TYPE_FCOE_RPI</span>:
		<span class="cm">/* RPI bitmask and physical id array are cleaned up earlier. */</span>
		<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">rsrc_blk</span><span class="p">,</span> <span class="n">rsrc_blk_next</span><span class="p">,</span>
				    <span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">lpfc_rpi_blk_list</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rsrc_blk</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
			<span class="n">kfree</span><span class="p">(</span><span class="n">rsrc_blk</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">bf_set</span><span class="p">(</span><span class="n">lpfc_idx_rsrc_rdy</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">sli4_flags</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

 <span class="nl">out_free_mbox:</span>
	<span class="n">mempool_free</span><span class="p">(</span><span class="n">mbox</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">mbox_mem_pool</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_sli4_alloc_resource_identifiers - Allocate all SLI4 resource extents.</span>
<span class="cm"> * @phba: Pointer to HBA context object.</span>
<span class="cm"> *</span>
<span class="cm"> * This function allocates all SLI4 resource identifiers.</span>
<span class="cm"> **/</span>
<span class="kt">int</span>
<span class="nf">lpfc_sli4_alloc_resource_identifiers</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">rc</span><span class="p">,</span> <span class="n">error</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">uint16_t</span> <span class="n">count</span><span class="p">,</span> <span class="n">base</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">longs</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">rpi_hdrs_in_use</span><span class="p">)</span>
		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">next_rpi</span> <span class="o">=</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">max_cfg_param</span><span class="p">.</span><span class="n">max_rpi</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">extents_in_use</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * The port supports resource extents. The XRI, VPI, VFI, RPI</span>
<span class="cm">		 * resource extent count must be read and allocated before</span>
<span class="cm">		 * provisioning the resource id arrays.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_idx_rsrc_rdy</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">sli4_flags</span><span class="p">)</span> <span class="o">==</span>
		    <span class="n">LPFC_IDX_RSRC_RDY</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * Extent-based resources are set - the driver could</span>
<span class="cm">			 * be in a port reset. Figure out if any corrective</span>
<span class="cm">			 * actions need to be taken.</span>
<span class="cm">			 */</span>
			<span class="n">rc</span> <span class="o">=</span> <span class="n">lpfc_sli4_chk_avail_extnt_rsrc</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span>
						 <span class="n">LPFC_RSC_TYPE_FCOE_VFI</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
				<span class="n">error</span><span class="o">++</span><span class="p">;</span>
			<span class="n">rc</span> <span class="o">=</span> <span class="n">lpfc_sli4_chk_avail_extnt_rsrc</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span>
						 <span class="n">LPFC_RSC_TYPE_FCOE_VPI</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
				<span class="n">error</span><span class="o">++</span><span class="p">;</span>
			<span class="n">rc</span> <span class="o">=</span> <span class="n">lpfc_sli4_chk_avail_extnt_rsrc</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span>
						 <span class="n">LPFC_RSC_TYPE_FCOE_XRI</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
				<span class="n">error</span><span class="o">++</span><span class="p">;</span>
			<span class="n">rc</span> <span class="o">=</span> <span class="n">lpfc_sli4_chk_avail_extnt_rsrc</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span>
						 <span class="n">LPFC_RSC_TYPE_FCOE_RPI</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
				<span class="n">error</span><span class="o">++</span><span class="p">;</span>

			<span class="cm">/*</span>
<span class="cm">			 * It&#39;s possible that the number of resources</span>
<span class="cm">			 * provided to this port instance changed between</span>
<span class="cm">			 * resets.  Detect this condition and reallocate</span>
<span class="cm">			 * resources.  Otherwise, there is no action.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_INFO</span><span class="p">,</span>
						<span class="n">LOG_MBOX</span> <span class="o">|</span> <span class="n">LOG_INIT</span><span class="p">,</span>
						<span class="s">&quot;2931 Detected extent resource &quot;</span>
						<span class="s">&quot;change.  Reallocating all &quot;</span>
						<span class="s">&quot;extents.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
				<span class="n">rc</span> <span class="o">=</span> <span class="n">lpfc_sli4_dealloc_extent</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span>
						 <span class="n">LPFC_RSC_TYPE_FCOE_VFI</span><span class="p">);</span>
				<span class="n">rc</span> <span class="o">=</span> <span class="n">lpfc_sli4_dealloc_extent</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span>
						 <span class="n">LPFC_RSC_TYPE_FCOE_VPI</span><span class="p">);</span>
				<span class="n">rc</span> <span class="o">=</span> <span class="n">lpfc_sli4_dealloc_extent</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span>
						 <span class="n">LPFC_RSC_TYPE_FCOE_XRI</span><span class="p">);</span>
				<span class="n">rc</span> <span class="o">=</span> <span class="n">lpfc_sli4_dealloc_extent</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span>
						 <span class="n">LPFC_RSC_TYPE_FCOE_RPI</span><span class="p">);</span>
			<span class="p">}</span> <span class="k">else</span>
				<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">rc</span> <span class="o">=</span> <span class="n">lpfc_sli4_alloc_extent</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">LPFC_RSC_TYPE_FCOE_VFI</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">rc</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">err_exit</span><span class="p">;</span>

		<span class="n">rc</span> <span class="o">=</span> <span class="n">lpfc_sli4_alloc_extent</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">LPFC_RSC_TYPE_FCOE_VPI</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">rc</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">err_exit</span><span class="p">;</span>

		<span class="n">rc</span> <span class="o">=</span> <span class="n">lpfc_sli4_alloc_extent</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">LPFC_RSC_TYPE_FCOE_RPI</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">rc</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">err_exit</span><span class="p">;</span>

		<span class="n">rc</span> <span class="o">=</span> <span class="n">lpfc_sli4_alloc_extent</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">LPFC_RSC_TYPE_FCOE_XRI</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">rc</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">err_exit</span><span class="p">;</span>
		<span class="n">bf_set</span><span class="p">(</span><span class="n">lpfc_idx_rsrc_rdy</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">sli4_flags</span><span class="p">,</span>
		       <span class="n">LPFC_IDX_RSRC_RDY</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * The port does not support resource extents.  The XRI, VPI,</span>
<span class="cm">		 * VFI, RPI resource ids were determined from READ_CONFIG.</span>
<span class="cm">		 * Just allocate the bitmasks and provision the resource id</span>
<span class="cm">		 * arrays.  If a port reset is active, the resources don&#39;t</span>
<span class="cm">		 * need any action - just exit.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_idx_rsrc_rdy</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">sli4_flags</span><span class="p">)</span> <span class="o">==</span>
		    <span class="n">LPFC_IDX_RSRC_RDY</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">lpfc_sli4_dealloc_resource_identifiers</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
			<span class="n">lpfc_sli4_remove_rpis</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="cm">/* RPIs. */</span>
		<span class="n">count</span> <span class="o">=</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">max_cfg_param</span><span class="p">.</span><span class="n">max_rpi</span><span class="p">;</span>
		<span class="n">base</span> <span class="o">=</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">max_cfg_param</span><span class="p">.</span><span class="n">rpi_base</span><span class="p">;</span>
		<span class="n">longs</span> <span class="o">=</span> <span class="p">(</span><span class="n">count</span> <span class="o">+</span> <span class="n">BITS_PER_LONG</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">BITS_PER_LONG</span><span class="p">;</span>
		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">rpi_bmask</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="n">longs</span> <span class="o">*</span>
						   <span class="k">sizeof</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">),</span>
						   <span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">rpi_bmask</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">err_exit</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">rpi_ids</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="n">count</span> <span class="o">*</span>
						 <span class="k">sizeof</span><span class="p">(</span><span class="kt">uint16_t</span><span class="p">),</span>
						 <span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">rpi_ids</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">free_rpi_bmask</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
			<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">rpi_ids</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">base</span> <span class="o">+</span> <span class="n">i</span><span class="p">;</span>

		<span class="cm">/* VPIs. */</span>
		<span class="n">count</span> <span class="o">=</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">max_cfg_param</span><span class="p">.</span><span class="n">max_vpi</span><span class="p">;</span>
		<span class="n">base</span> <span class="o">=</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">max_cfg_param</span><span class="p">.</span><span class="n">vpi_base</span><span class="p">;</span>
		<span class="n">longs</span> <span class="o">=</span> <span class="p">(</span><span class="n">count</span> <span class="o">+</span> <span class="n">BITS_PER_LONG</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">BITS_PER_LONG</span><span class="p">;</span>
		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">vpi_bmask</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="n">longs</span> <span class="o">*</span>
					  <span class="k">sizeof</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">),</span>
					  <span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">vpi_bmask</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">free_rpi_ids</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">vpi_ids</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="n">count</span> <span class="o">*</span>
					<span class="k">sizeof</span><span class="p">(</span><span class="kt">uint16_t</span><span class="p">),</span>
					<span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">vpi_ids</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">free_vpi_bmask</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
			<span class="n">phba</span><span class="o">-&gt;</span><span class="n">vpi_ids</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">base</span> <span class="o">+</span> <span class="n">i</span><span class="p">;</span>

		<span class="cm">/* XRIs. */</span>
		<span class="n">count</span> <span class="o">=</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">max_cfg_param</span><span class="p">.</span><span class="n">max_xri</span><span class="p">;</span>
		<span class="n">base</span> <span class="o">=</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">max_cfg_param</span><span class="p">.</span><span class="n">xri_base</span><span class="p">;</span>
		<span class="n">longs</span> <span class="o">=</span> <span class="p">(</span><span class="n">count</span> <span class="o">+</span> <span class="n">BITS_PER_LONG</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">BITS_PER_LONG</span><span class="p">;</span>
		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">xri_bmask</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="n">longs</span> <span class="o">*</span>
						   <span class="k">sizeof</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">),</span>
						   <span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">xri_bmask</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">free_vpi_ids</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">max_cfg_param</span><span class="p">.</span><span class="n">xri_used</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">xri_ids</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="n">count</span> <span class="o">*</span>
						 <span class="k">sizeof</span><span class="p">(</span><span class="kt">uint16_t</span><span class="p">),</span>
						 <span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">xri_ids</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">free_xri_bmask</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
			<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">xri_ids</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">base</span> <span class="o">+</span> <span class="n">i</span><span class="p">;</span>

		<span class="cm">/* VFIs. */</span>
		<span class="n">count</span> <span class="o">=</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">max_cfg_param</span><span class="p">.</span><span class="n">max_vfi</span><span class="p">;</span>
		<span class="n">base</span> <span class="o">=</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">max_cfg_param</span><span class="p">.</span><span class="n">vfi_base</span><span class="p">;</span>
		<span class="n">longs</span> <span class="o">=</span> <span class="p">(</span><span class="n">count</span> <span class="o">+</span> <span class="n">BITS_PER_LONG</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">BITS_PER_LONG</span><span class="p">;</span>
		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">vfi_bmask</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="n">longs</span> <span class="o">*</span>
						   <span class="k">sizeof</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">),</span>
						   <span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">vfi_bmask</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">free_xri_ids</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">vfi_ids</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="n">count</span> <span class="o">*</span>
						 <span class="k">sizeof</span><span class="p">(</span><span class="kt">uint16_t</span><span class="p">),</span>
						 <span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">vfi_ids</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">free_vfi_bmask</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
			<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">vfi_ids</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">base</span> <span class="o">+</span> <span class="n">i</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * Mark all resources ready.  An HBA reset doesn&#39;t need</span>
<span class="cm">		 * to reset the initialization.</span>
<span class="cm">		 */</span>
		<span class="n">bf_set</span><span class="p">(</span><span class="n">lpfc_idx_rsrc_rdy</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">sli4_flags</span><span class="p">,</span>
		       <span class="n">LPFC_IDX_RSRC_RDY</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

 <span class="nl">free_vfi_bmask:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">vfi_bmask</span><span class="p">);</span>
 <span class="nl">free_xri_ids:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">xri_ids</span><span class="p">);</span>
 <span class="nl">free_xri_bmask:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">xri_bmask</span><span class="p">);</span>
 <span class="nl">free_vpi_ids:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">vpi_ids</span><span class="p">);</span>
 <span class="nl">free_vpi_bmask:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">vpi_bmask</span><span class="p">);</span>
 <span class="nl">free_rpi_ids:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">rpi_ids</span><span class="p">);</span>
 <span class="nl">free_rpi_bmask:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">rpi_bmask</span><span class="p">);</span>
 <span class="nl">err_exit:</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_sli4_dealloc_resource_identifiers - Deallocate all SLI4 resource extents.</span>
<span class="cm"> * @phba: Pointer to HBA context object.</span>
<span class="cm"> *</span>
<span class="cm"> * This function allocates the number of elements for the specified</span>
<span class="cm"> * resource type.</span>
<span class="cm"> **/</span>
<span class="kt">int</span>
<span class="nf">lpfc_sli4_dealloc_resource_identifiers</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">extents_in_use</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lpfc_sli4_dealloc_extent</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">LPFC_RSC_TYPE_FCOE_VPI</span><span class="p">);</span>
		<span class="n">lpfc_sli4_dealloc_extent</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">LPFC_RSC_TYPE_FCOE_RPI</span><span class="p">);</span>
		<span class="n">lpfc_sli4_dealloc_extent</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">LPFC_RSC_TYPE_FCOE_XRI</span><span class="p">);</span>
		<span class="n">lpfc_sli4_dealloc_extent</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">LPFC_RSC_TYPE_FCOE_VFI</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">vpi_bmask</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">vpi_ids</span><span class="p">);</span>
		<span class="n">bf_set</span><span class="p">(</span><span class="n">lpfc_vpi_rsrc_rdy</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">sli4_flags</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">xri_bmask</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">xri_ids</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">vfi_bmask</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">vfi_ids</span><span class="p">);</span>
		<span class="n">bf_set</span><span class="p">(</span><span class="n">lpfc_vfi_rsrc_rdy</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">sli4_flags</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">bf_set</span><span class="p">(</span><span class="n">lpfc_idx_rsrc_rdy</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">sli4_flags</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_sli4_get_allocated_extnts - Get the port&#39;s allocated extents.</span>
<span class="cm"> * @phba: Pointer to HBA context object.</span>
<span class="cm"> * @type: The resource extent type.</span>
<span class="cm"> * @extnt_count: buffer to hold port extent count response</span>
<span class="cm"> * @extnt_size: buffer to hold port extent size response.</span>
<span class="cm"> *</span>
<span class="cm"> * This function calls the port to read the host allocated extents</span>
<span class="cm"> * for a particular type.</span>
<span class="cm"> **/</span>
<span class="kt">int</span>
<span class="nf">lpfc_sli4_get_allocated_extnts</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">,</span> <span class="kt">uint16_t</span> <span class="n">type</span><span class="p">,</span>
			       <span class="kt">uint16_t</span> <span class="o">*</span><span class="n">extnt_cnt</span><span class="p">,</span> <span class="kt">uint16_t</span> <span class="o">*</span><span class="n">extnt_size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">bool</span> <span class="n">emb</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">uint16_t</span> <span class="n">curr_blks</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">req_len</span><span class="p">,</span> <span class="n">emb_len</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">alloc_len</span><span class="p">,</span> <span class="n">mbox_tmo</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">blk_list_head</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_rsrc_blks</span> <span class="o">*</span><span class="n">rsrc_blk</span><span class="p">;</span>
	<span class="n">LPFC_MBOXQ_t</span> <span class="o">*</span><span class="n">mbox</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">virtaddr</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_mbx_nembed_rsrc_extent</span> <span class="o">*</span><span class="n">n_rsrc</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_mbx_alloc_rsrc_extents</span> <span class="o">*</span><span class="n">rsrc_ext</span><span class="p">;</span>
	<span class="k">union</span>  <span class="n">lpfc_sli4_cfg_shdr</span> <span class="o">*</span><span class="n">shdr</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">type</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">LPFC_RSC_TYPE_FCOE_VPI</span>:
		<span class="n">blk_list_head</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">lpfc_vpi_blk_list</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">LPFC_RSC_TYPE_FCOE_XRI</span>:
		<span class="n">blk_list_head</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">lpfc_xri_blk_list</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">LPFC_RSC_TYPE_FCOE_VFI</span>:
		<span class="n">blk_list_head</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">lpfc_vfi_blk_list</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">LPFC_RSC_TYPE_FCOE_RPI</span>:
		<span class="n">blk_list_head</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">lpfc_rpi_blk_list</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Count the number of extents currently allocatd for this type. */</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">rsrc_blk</span><span class="p">,</span> <span class="n">blk_list_head</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">curr_blks</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * The GET_ALLOCATED mailbox does not return the size,</span>
<span class="cm">			 * just the count.  The size should be just the size</span>
<span class="cm">			 * stored in the current allocated block and all sizes</span>
<span class="cm">			 * for an extent type are the same so set the return</span>
<span class="cm">			 * value now.</span>
<span class="cm">			 */</span>
			<span class="o">*</span><span class="n">extnt_size</span> <span class="o">=</span> <span class="n">rsrc_blk</span><span class="o">-&gt;</span><span class="n">rsrc_size</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">curr_blks</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Calculate the total requested length of the dma memory. */</span>
	<span class="n">req_len</span> <span class="o">=</span> <span class="n">curr_blks</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">uint16_t</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Calculate the size of an embedded mailbox.  The uint32_t</span>
<span class="cm">	 * accounts for extents-specific word.</span>
<span class="cm">	 */</span>
	<span class="n">emb_len</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">MAILBOX_t</span><span class="p">)</span> <span class="o">-</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">mbox_header</span><span class="p">)</span> <span class="o">-</span>
		<span class="k">sizeof</span><span class="p">(</span><span class="kt">uint32_t</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Presume the allocation and response will fit into an embedded</span>
<span class="cm">	 * mailbox.  If not true, reconfigure to a non-embedded mailbox.</span>
<span class="cm">	 */</span>
	<span class="n">emb</span> <span class="o">=</span> <span class="n">LPFC_SLI4_MBX_EMBED</span><span class="p">;</span>
	<span class="n">req_len</span> <span class="o">=</span> <span class="n">emb_len</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">req_len</span> <span class="o">&gt;</span> <span class="n">emb_len</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">req_len</span> <span class="o">=</span> <span class="n">curr_blks</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">uint16_t</span><span class="p">)</span> <span class="o">+</span>
			<span class="k">sizeof</span><span class="p">(</span><span class="k">union</span> <span class="n">lpfc_sli4_cfg_shdr</span><span class="p">)</span> <span class="o">+</span>
			<span class="k">sizeof</span><span class="p">(</span><span class="kt">uint32_t</span><span class="p">);</span>
		<span class="n">emb</span> <span class="o">=</span> <span class="n">LPFC_SLI4_MBX_NEMBED</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">mbox</span> <span class="o">=</span> <span class="p">(</span><span class="n">LPFC_MBOXQ_t</span> <span class="o">*</span><span class="p">)</span> <span class="n">mempool_alloc</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">mbox_mem_pool</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mbox</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">mbox</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">LPFC_MBOXQ_t</span><span class="p">));</span>

	<span class="n">alloc_len</span> <span class="o">=</span> <span class="n">lpfc_sli4_config</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">mbox</span><span class="p">,</span> <span class="n">LPFC_MBOX_SUBSYSTEM_COMMON</span><span class="p">,</span>
				     <span class="n">LPFC_MBOX_OPCODE_GET_ALLOC_RSRC_EXTENT</span><span class="p">,</span>
				     <span class="n">req_len</span><span class="p">,</span> <span class="n">emb</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">alloc_len</span> <span class="o">&lt;</span> <span class="n">req_len</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_INIT</span><span class="p">,</span>
			<span class="s">&quot;2983 Allocated DMA memory size (x%x) is &quot;</span>
			<span class="s">&quot;less than the requested DMA memory &quot;</span>
			<span class="s">&quot;size (x%x)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">alloc_len</span><span class="p">,</span> <span class="n">req_len</span><span class="p">);</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">err_exit</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">lpfc_sli4_mbox_rsrc_extent</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">mbox</span><span class="p">,</span> <span class="n">curr_blks</span><span class="p">,</span> <span class="n">type</span><span class="p">,</span> <span class="n">emb</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">rc</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">err_exit</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">intr_enable</span><span class="p">)</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">lpfc_sli_issue_mbox</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">mbox</span><span class="p">,</span> <span class="n">MBX_POLL</span><span class="p">);</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="n">mbox_tmo</span> <span class="o">=</span> <span class="n">lpfc_mbox_tmo_val</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">mbox</span><span class="p">);</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">lpfc_sli_issue_mbox_wait</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">mbox</span><span class="p">,</span> <span class="n">mbox_tmo</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">rc</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">err_exit</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Figure out where the response is located.  Then get local pointers</span>
<span class="cm">	 * to the response data.  The port does not guarantee to respond to</span>
<span class="cm">	 * all extents counts request so update the local variable with the</span>
<span class="cm">	 * allocated count from the port.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">emb</span> <span class="o">==</span> <span class="n">LPFC_SLI4_MBX_EMBED</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rsrc_ext</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">mbox</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">mqe</span><span class="p">.</span><span class="n">un</span><span class="p">.</span><span class="n">alloc_rsrc_extents</span><span class="p">;</span>
		<span class="n">shdr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">rsrc_ext</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">cfg_shdr</span><span class="p">;</span>
		<span class="o">*</span><span class="n">extnt_cnt</span> <span class="o">=</span> <span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_mbx_rsrc_cnt</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rsrc_ext</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">rsp</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">virtaddr</span> <span class="o">=</span> <span class="n">mbox</span><span class="o">-&gt;</span><span class="n">sge_array</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
		<span class="n">n_rsrc</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_mbx_nembed_rsrc_extent</span> <span class="o">*</span><span class="p">)</span> <span class="n">virtaddr</span><span class="p">;</span>
		<span class="n">shdr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">n_rsrc</span><span class="o">-&gt;</span><span class="n">cfg_shdr</span><span class="p">;</span>
		<span class="o">*</span><span class="n">extnt_cnt</span> <span class="o">=</span> <span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_mbx_rsrc_cnt</span><span class="p">,</span> <span class="n">n_rsrc</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_mbox_hdr_status</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">shdr</span><span class="o">-&gt;</span><span class="n">response</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_MBOX</span> <span class="o">|</span> <span class="n">LOG_INIT</span><span class="p">,</span>
			<span class="s">&quot;2984 Failed to read allocated resources &quot;</span>
			<span class="s">&quot;for type %d - Status 0x%x Add&#39;l Status 0x%x.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">type</span><span class="p">,</span>
			<span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_mbox_hdr_status</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">shdr</span><span class="o">-&gt;</span><span class="n">response</span><span class="p">),</span>
			<span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_mbox_hdr_add_status</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">shdr</span><span class="o">-&gt;</span><span class="n">response</span><span class="p">));</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">err_exit</span><span class="p">;</span>
	<span class="p">}</span>
 <span class="nl">err_exit:</span>
	<span class="n">lpfc_sli4_mbox_cmd_free</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">mbox</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_sli4_repost_els_sgl_list - Repsot the els buffers sgl pages as block</span>
<span class="cm"> * @phba: pointer to lpfc hba data structure.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine walks the list of els buffers that have been allocated and</span>
<span class="cm"> * repost them to the port by using SGL block post. This is needed after a</span>
<span class="cm"> * pci_function_reset/warm_start or start. It attempts to construct blocks</span>
<span class="cm"> * of els buffer sgls which contains contiguous xris and uses the non-embedded</span>
<span class="cm"> * SGL block post mailbox commands to post them to the port. For single els</span>
<span class="cm"> * buffer sgl with non-contiguous xri, if any, it shall use embedded SGL post</span>
<span class="cm"> * mailbox command for posting.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns: 0 = success, non-zero failure.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">lpfc_sli4_repost_els_sgl_list</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpfc_sglq</span> <span class="o">*</span><span class="n">sglq_entry</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_sglq</span> <span class="o">*</span><span class="n">sglq_entry_next</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_sglq</span> <span class="o">*</span><span class="n">sglq_entry_first</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">status</span><span class="p">,</span> <span class="n">post_cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">num_posted</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">block_cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">last_xritag</span> <span class="o">=</span> <span class="n">NO_XRI</span><span class="p">;</span>
	<span class="n">LIST_HEAD</span><span class="p">(</span><span class="n">prep_sgl_list</span><span class="p">);</span>
	<span class="n">LIST_HEAD</span><span class="p">(</span><span class="n">blck_sgl_list</span><span class="p">);</span>
	<span class="n">LIST_HEAD</span><span class="p">(</span><span class="n">allc_sgl_list</span><span class="p">);</span>
	<span class="n">LIST_HEAD</span><span class="p">(</span><span class="n">post_sgl_list</span><span class="p">);</span>
	<span class="n">LIST_HEAD</span><span class="p">(</span><span class="n">free_sgl_list</span><span class="p">);</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>
	<span class="n">list_splice_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">lpfc_sgl_list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">allc_sgl_list</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>

	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">sglq_entry</span><span class="p">,</span> <span class="n">sglq_entry_next</span><span class="p">,</span>
				 <span class="o">&amp;</span><span class="n">allc_sgl_list</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sglq_entry</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
		<span class="n">block_cnt</span><span class="o">++</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">last_xritag</span> <span class="o">!=</span> <span class="n">NO_XRI</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="p">(</span><span class="n">sglq_entry</span><span class="o">-&gt;</span><span class="n">sli4_xritag</span> <span class="o">!=</span> <span class="n">last_xritag</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/* a hole in xri block, form a sgl posting block */</span>
			<span class="n">list_splice_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">prep_sgl_list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">blck_sgl_list</span><span class="p">);</span>
			<span class="n">post_cnt</span> <span class="o">=</span> <span class="n">block_cnt</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
			<span class="cm">/* prepare list for next posting block */</span>
			<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sglq_entry</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">prep_sgl_list</span><span class="p">);</span>
			<span class="n">block_cnt</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/* prepare list for next posting block */</span>
			<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sglq_entry</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">prep_sgl_list</span><span class="p">);</span>
			<span class="cm">/* enough sgls for non-embed sgl mbox command */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">block_cnt</span> <span class="o">==</span> <span class="n">LPFC_NEMBED_MBOX_SGL_CNT</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">list_splice_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">prep_sgl_list</span><span class="p">,</span>
						 <span class="o">&amp;</span><span class="n">blck_sgl_list</span><span class="p">);</span>
				<span class="n">post_cnt</span> <span class="o">=</span> <span class="n">block_cnt</span><span class="p">;</span>
				<span class="n">block_cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="n">num_posted</span><span class="o">++</span><span class="p">;</span>

		<span class="cm">/* keep track of last sgl&#39;s xritag */</span>
		<span class="n">last_xritag</span> <span class="o">=</span> <span class="n">sglq_entry</span><span class="o">-&gt;</span><span class="n">sli4_xritag</span><span class="p">;</span>

		<span class="cm">/* end of repost sgl list condition for els buffers */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">num_posted</span> <span class="o">==</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">els_xri_cnt</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">post_cnt</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">list_splice_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">prep_sgl_list</span><span class="p">,</span>
						 <span class="o">&amp;</span><span class="n">blck_sgl_list</span><span class="p">);</span>
				<span class="n">post_cnt</span> <span class="o">=</span> <span class="n">block_cnt</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">block_cnt</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">status</span> <span class="o">=</span> <span class="n">lpfc_sli4_post_sgl</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span>
						<span class="n">sglq_entry</span><span class="o">-&gt;</span><span class="n">phys</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
						<span class="n">sglq_entry</span><span class="o">-&gt;</span><span class="n">sli4_xritag</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">status</span><span class="p">)</span> <span class="p">{</span>
					<span class="cm">/* successful, put sgl to posted list */</span>
					<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sglq_entry</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span>
						      <span class="o">&amp;</span><span class="n">post_sgl_list</span><span class="p">);</span>
				<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
					<span class="cm">/* Failure, put sgl to free list */</span>
					<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_WARNING</span><span class="p">,</span>
						<span class="n">LOG_SLI</span><span class="p">,</span>
						<span class="s">&quot;3159 Failed to post els &quot;</span>
						<span class="s">&quot;sgl, xritag:x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
						<span class="n">sglq_entry</span><span class="o">-&gt;</span><span class="n">sli4_xritag</span><span class="p">);</span>
					<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sglq_entry</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span>
						      <span class="o">&amp;</span><span class="n">free_sgl_list</span><span class="p">);</span>
					<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>
					<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">els_xri_cnt</span><span class="o">--</span><span class="p">;</span>
					<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>
				<span class="p">}</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="cm">/* continue until a nembed page worth of sgls */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">post_cnt</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="cm">/* post the els buffer list sgls as a block */</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">lpfc_sli4_post_els_sgl_list</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">blck_sgl_list</span><span class="p">,</span>
						     <span class="n">post_cnt</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">status</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* success, put sgl list to posted sgl list */</span>
			<span class="n">list_splice_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">blck_sgl_list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">post_sgl_list</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/* Failure, put sgl list to free sgl list */</span>
			<span class="n">sglq_entry_first</span> <span class="o">=</span> <span class="n">list_first_entry</span><span class="p">(</span><span class="o">&amp;</span><span class="n">blck_sgl_list</span><span class="p">,</span>
							    <span class="k">struct</span> <span class="n">lpfc_sglq</span><span class="p">,</span>
							    <span class="n">list</span><span class="p">);</span>
			<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_WARNING</span><span class="p">,</span> <span class="n">LOG_SLI</span><span class="p">,</span>
					<span class="s">&quot;3160 Failed to post els sgl-list, &quot;</span>
					<span class="s">&quot;xritag:x%x-x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">sglq_entry_first</span><span class="o">-&gt;</span><span class="n">sli4_xritag</span><span class="p">,</span>
					<span class="p">(</span><span class="n">sglq_entry_first</span><span class="o">-&gt;</span><span class="n">sli4_xritag</span> <span class="o">+</span>
					 <span class="n">post_cnt</span> <span class="o">-</span> <span class="mi">1</span><span class="p">));</span>
			<span class="n">list_splice_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">blck_sgl_list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">free_sgl_list</span><span class="p">);</span>
			<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>
			<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">els_xri_cnt</span> <span class="o">-=</span> <span class="n">post_cnt</span><span class="p">;</span>
			<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="cm">/* don&#39;t reset xirtag due to hole in xri block */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">block_cnt</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">last_xritag</span> <span class="o">=</span> <span class="n">NO_XRI</span><span class="p">;</span>

		<span class="cm">/* reset els sgl post count for next round of posting */</span>
		<span class="n">post_cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* free the els sgls failed to post */</span>
	<span class="n">lpfc_free_sgl_list</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">free_sgl_list</span><span class="p">);</span>

	<span class="cm">/* push els sgls posted to the availble list */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">post_sgl_list</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>
		<span class="n">list_splice_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">post_sgl_list</span><span class="p">,</span>
				 <span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">lpfc_sgl_list</span><span class="p">);</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_SLI</span><span class="p">,</span>
				<span class="s">&quot;3161 Failure to post els sgl to port.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_sli4_hba_setup - SLI4 device intialization PCI function</span>
<span class="cm"> * @phba: Pointer to HBA context object.</span>
<span class="cm"> *</span>
<span class="cm"> * This function is the main SLI4 device intialization PCI function. This</span>
<span class="cm"> * function is called by the HBA intialization code, HBA reset code and</span>
<span class="cm"> * HBA error attention handler code. Caller is not required to hold any</span>
<span class="cm"> * locks.</span>
<span class="cm"> **/</span>
<span class="kt">int</span>
<span class="nf">lpfc_sli4_hba_setup</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>
	<span class="n">LPFC_MBOXQ_t</span> <span class="o">*</span><span class="n">mboxq</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_mqe</span> <span class="o">*</span><span class="n">mqe</span><span class="p">;</span>
	<span class="kt">uint8_t</span> <span class="o">*</span><span class="n">vpd</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">vpd_size</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">ftr_rsp</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span> <span class="o">=</span> <span class="n">lpfc_shost_from_vport</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">pport</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="n">vport</span> <span class="o">=</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">pport</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_dmabuf</span> <span class="o">*</span><span class="n">mp</span><span class="p">;</span>

	<span class="cm">/* Perform a PCI function reset to start from clean */</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">lpfc_pci_function_reset</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">rc</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>

	<span class="cm">/* Check the HBA Host Status Register for readyness */</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">lpfc_sli4_post_status_check</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">rc</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>
		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli</span><span class="p">.</span><span class="n">sli_flag</span> <span class="o">|=</span> <span class="n">LPFC_SLI_ACTIVE</span><span class="p">;</span>
		<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Allocate a single mailbox container for initializing the</span>
<span class="cm">	 * port.</span>
<span class="cm">	 */</span>
	<span class="n">mboxq</span> <span class="o">=</span> <span class="p">(</span><span class="n">LPFC_MBOXQ_t</span> <span class="o">*</span><span class="p">)</span> <span class="n">mempool_alloc</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">mbox_mem_pool</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mboxq</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="cm">/* Issue READ_REV to collect vpd and FW information. */</span>
	<span class="n">vpd_size</span> <span class="o">=</span> <span class="n">SLI4_PAGE_SIZE</span><span class="p">;</span>
	<span class="n">vpd</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="n">vpd_size</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">vpd</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out_free_mbox</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">lpfc_sli4_read_rev</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">mboxq</span><span class="p">,</span> <span class="n">vpd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vpd_size</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">rc</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">vpd</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_free_mbox</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">mqe</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">mboxq</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">mqe</span><span class="p">;</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli_rev</span> <span class="o">=</span> <span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_mbx_rd_rev_sli_lvl</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mqe</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">read_rev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_mbx_rd_rev_fcoe</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mqe</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">read_rev</span><span class="p">))</span>
		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">hba_flag</span> <span class="o">|=</span> <span class="n">HBA_FCOE_MODE</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">hba_flag</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">HBA_FCOE_MODE</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_mbx_rd_rev_cee_ver</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mqe</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">read_rev</span><span class="p">)</span> <span class="o">==</span>
		<span class="n">LPFC_DCBX_CEE_MODE</span><span class="p">)</span>
		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">hba_flag</span> <span class="o">|=</span> <span class="n">HBA_FIP_SUPPORT</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">hba_flag</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">HBA_FIP_SUPPORT</span><span class="p">;</span>

	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">hba_flag</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">HBA_FCP_IOQ_FLUSH</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli_rev</span> <span class="o">!=</span> <span class="n">LPFC_SLI_REV4</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_MBOX</span> <span class="o">|</span> <span class="n">LOG_SLI</span><span class="p">,</span>
			<span class="s">&quot;0376 READ_REV Error. SLI Level %d &quot;</span>
			<span class="s">&quot;FCoE enabled %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli_rev</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">hba_flag</span> <span class="o">&amp;</span> <span class="n">HBA_FCOE_MODE</span><span class="p">);</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">vpd</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_free_mbox</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Continue initialization with default values even if driver failed</span>
<span class="cm">	 * to read FCoE param config regions, only read parameters if the</span>
<span class="cm">	 * board is FCoE</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hba_flag</span> <span class="o">&amp;</span> <span class="n">HBA_FCOE_MODE</span> <span class="o">&amp;&amp;</span>
	    <span class="n">lpfc_sli4_read_fcoe_params</span><span class="p">(</span><span class="n">phba</span><span class="p">))</span>
		<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_WARNING</span><span class="p">,</span> <span class="n">LOG_MBOX</span> <span class="o">|</span> <span class="n">LOG_INIT</span><span class="p">,</span>
			<span class="s">&quot;2570 Failed to read FCoE parameters</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Retrieve sli4 device physical port name, failure of doing it</span>
<span class="cm">	 * is considered as non-fatal.</span>
<span class="cm">	 */</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">lpfc_sli4_retrieve_pport_name</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rc</span><span class="p">)</span>
		<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_INFO</span><span class="p">,</span> <span class="n">LOG_MBOX</span> <span class="o">|</span> <span class="n">LOG_SLI</span><span class="p">,</span>
				<span class="s">&quot;3080 Successful retrieving SLI4 device &quot;</span>
				<span class="s">&quot;physical port name: %s.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">Port</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Evaluate the read rev and vpd data. Populate the driver</span>
<span class="cm">	 * state with the results. If this routine fails, the failure</span>
<span class="cm">	 * is not fatal as the driver will use generic values.</span>
<span class="cm">	 */</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">lpfc_parse_vpd</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">vpd</span><span class="p">,</span> <span class="n">vpd_size</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">rc</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_MBOX</span> <span class="o">|</span> <span class="n">LOG_SLI</span><span class="p">,</span>
				<span class="s">&quot;0377 Error %d parsing vpd. &quot;</span>
				<span class="s">&quot;Using defaults.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">rc</span><span class="p">);</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">vpd</span><span class="p">);</span>

	<span class="cm">/* Save information as VPD data */</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">vpd</span><span class="p">.</span><span class="n">rev</span><span class="p">.</span><span class="n">biuRev</span> <span class="o">=</span> <span class="n">mqe</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">read_rev</span><span class="p">.</span><span class="n">first_hw_rev</span><span class="p">;</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">vpd</span><span class="p">.</span><span class="n">rev</span><span class="p">.</span><span class="n">smRev</span> <span class="o">=</span> <span class="n">mqe</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">read_rev</span><span class="p">.</span><span class="n">second_hw_rev</span><span class="p">;</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">vpd</span><span class="p">.</span><span class="n">rev</span><span class="p">.</span><span class="n">endecRev</span> <span class="o">=</span> <span class="n">mqe</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">read_rev</span><span class="p">.</span><span class="n">third_hw_rev</span><span class="p">;</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">vpd</span><span class="p">.</span><span class="n">rev</span><span class="p">.</span><span class="n">fcphHigh</span> <span class="o">=</span> <span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_mbx_rd_rev_fcph_high</span><span class="p">,</span>
					 <span class="o">&amp;</span><span class="n">mqe</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">read_rev</span><span class="p">);</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">vpd</span><span class="p">.</span><span class="n">rev</span><span class="p">.</span><span class="n">fcphLow</span> <span class="o">=</span> <span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_mbx_rd_rev_fcph_low</span><span class="p">,</span>
				       <span class="o">&amp;</span><span class="n">mqe</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">read_rev</span><span class="p">);</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">vpd</span><span class="p">.</span><span class="n">rev</span><span class="p">.</span><span class="n">feaLevelHigh</span> <span class="o">=</span> <span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_mbx_rd_rev_ftr_lvl_high</span><span class="p">,</span>
					    <span class="o">&amp;</span><span class="n">mqe</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">read_rev</span><span class="p">);</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">vpd</span><span class="p">.</span><span class="n">rev</span><span class="p">.</span><span class="n">feaLevelLow</span> <span class="o">=</span> <span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_mbx_rd_rev_ftr_lvl_low</span><span class="p">,</span>
					   <span class="o">&amp;</span><span class="n">mqe</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">read_rev</span><span class="p">);</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">vpd</span><span class="p">.</span><span class="n">rev</span><span class="p">.</span><span class="n">sli1FwRev</span> <span class="o">=</span> <span class="n">mqe</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">read_rev</span><span class="p">.</span><span class="n">fw_id_rev</span><span class="p">;</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">vpd</span><span class="p">.</span><span class="n">rev</span><span class="p">.</span><span class="n">sli1FwName</span><span class="p">,</span> <span class="n">mqe</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">read_rev</span><span class="p">.</span><span class="n">fw_name</span><span class="p">,</span> <span class="mi">16</span><span class="p">);</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">vpd</span><span class="p">.</span><span class="n">rev</span><span class="p">.</span><span class="n">sli2FwRev</span> <span class="o">=</span> <span class="n">mqe</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">read_rev</span><span class="p">.</span><span class="n">ulp_fw_id_rev</span><span class="p">;</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">vpd</span><span class="p">.</span><span class="n">rev</span><span class="p">.</span><span class="n">sli2FwName</span><span class="p">,</span> <span class="n">mqe</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">read_rev</span><span class="p">.</span><span class="n">ulp_fw_name</span><span class="p">,</span> <span class="mi">16</span><span class="p">);</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">vpd</span><span class="p">.</span><span class="n">rev</span><span class="p">.</span><span class="n">opFwRev</span> <span class="o">=</span> <span class="n">mqe</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">read_rev</span><span class="p">.</span><span class="n">fw_id_rev</span><span class="p">;</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">vpd</span><span class="p">.</span><span class="n">rev</span><span class="p">.</span><span class="n">opFwName</span><span class="p">,</span> <span class="n">mqe</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">read_rev</span><span class="p">.</span><span class="n">fw_name</span><span class="p">,</span> <span class="mi">16</span><span class="p">);</span>
	<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_INFO</span><span class="p">,</span> <span class="n">LOG_MBOX</span> <span class="o">|</span> <span class="n">LOG_SLI</span><span class="p">,</span>
			<span class="s">&quot;(%d):0380 READ_REV Status x%x &quot;</span>
			<span class="s">&quot;fw_rev:%s fcphHi:%x fcphLo:%x flHi:%x flLo:%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">mboxq</span><span class="o">-&gt;</span><span class="n">vport</span> <span class="o">?</span> <span class="n">mboxq</span><span class="o">-&gt;</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">vpi</span> <span class="o">:</span> <span class="mi">0</span><span class="p">,</span>
			<span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_mqe_status</span><span class="p">,</span> <span class="n">mqe</span><span class="p">),</span>
			<span class="n">phba</span><span class="o">-&gt;</span><span class="n">vpd</span><span class="p">.</span><span class="n">rev</span><span class="p">.</span><span class="n">opFwName</span><span class="p">,</span>
			<span class="n">phba</span><span class="o">-&gt;</span><span class="n">vpd</span><span class="p">.</span><span class="n">rev</span><span class="p">.</span><span class="n">fcphHigh</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">vpd</span><span class="p">.</span><span class="n">rev</span><span class="p">.</span><span class="n">fcphLow</span><span class="p">,</span>
			<span class="n">phba</span><span class="o">-&gt;</span><span class="n">vpd</span><span class="p">.</span><span class="n">rev</span><span class="p">.</span><span class="n">feaLevelHigh</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">vpd</span><span class="p">.</span><span class="n">rev</span><span class="p">.</span><span class="n">feaLevelLow</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Discover the port&#39;s supported feature set and match it against the</span>
<span class="cm">	 * hosts requests.</span>
<span class="cm">	 */</span>
	<span class="n">lpfc_request_features</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">mboxq</span><span class="p">);</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">lpfc_sli_issue_mbox</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">mboxq</span><span class="p">,</span> <span class="n">MBX_POLL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">rc</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out_free_mbox</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * The port must support FCP initiator mode as this is the</span>
<span class="cm">	 * only mode running in the host.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_mbx_rq_ftr_rsp_fcpi</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mqe</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">req_ftrs</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_WARNING</span><span class="p">,</span> <span class="n">LOG_MBOX</span> <span class="o">|</span> <span class="n">LOG_SLI</span><span class="p">,</span>
				<span class="s">&quot;0378 No support for fcpi mode.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">ftr_rsp</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_mbx_rq_ftr_rsp_perfh</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mqe</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">req_ftrs</span><span class="p">))</span>
		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli3_options</span> <span class="o">|=</span> <span class="n">LPFC_SLI4_PERFH_ENABLED</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli3_options</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">LPFC_SLI4_PERFH_ENABLED</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * If the port cannot support the host&#39;s requested features</span>
<span class="cm">	 * then turn off the global config parameters to disable the</span>
<span class="cm">	 * feature in the driver.  This is not a fatal error.</span>
<span class="cm">	 */</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli3_options</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">LPFC_SLI3_BG_ENABLED</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">cfg_enable_bg</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_mbx_rq_ftr_rsp_dif</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mqe</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">req_ftrs</span><span class="p">))</span>
			<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli3_options</span> <span class="o">|=</span> <span class="n">LPFC_SLI3_BG_ENABLED</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">ftr_rsp</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">max_vpi</span> <span class="o">&amp;&amp;</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">cfg_enable_npiv</span> <span class="o">&amp;&amp;</span>
	    <span class="o">!</span><span class="p">(</span><span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_mbx_rq_ftr_rsp_npiv</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mqe</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">req_ftrs</span><span class="p">)))</span>
		<span class="n">ftr_rsp</span><span class="o">++</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ftr_rsp</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_WARNING</span><span class="p">,</span> <span class="n">LOG_MBOX</span> <span class="o">|</span> <span class="n">LOG_SLI</span><span class="p">,</span>
				<span class="s">&quot;0379 Feature Mismatch Data: x%08x %08x &quot;</span>
				<span class="s">&quot;x%x x%x x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">mqe</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">req_ftrs</span><span class="p">.</span><span class="n">word2</span><span class="p">,</span>
				<span class="n">mqe</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">req_ftrs</span><span class="p">.</span><span class="n">word3</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">cfg_enable_bg</span><span class="p">,</span>
				<span class="n">phba</span><span class="o">-&gt;</span><span class="n">cfg_enable_npiv</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">max_vpi</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_mbx_rq_ftr_rsp_dif</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mqe</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">req_ftrs</span><span class="p">)))</span>
			<span class="n">phba</span><span class="o">-&gt;</span><span class="n">cfg_enable_bg</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_mbx_rq_ftr_rsp_npiv</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mqe</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">req_ftrs</span><span class="p">)))</span>
			<span class="n">phba</span><span class="o">-&gt;</span><span class="n">cfg_enable_npiv</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* These SLI3 features are assumed in SLI4 */</span>
	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli3_options</span> <span class="o">|=</span> <span class="p">(</span><span class="n">LPFC_SLI3_NPIV_ENABLED</span> <span class="o">|</span> <span class="n">LPFC_SLI3_HBQ_ENABLED</span><span class="p">);</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Allocate all resources (xri,rpi,vpi,vfi) now.  Subsequent</span>
<span class="cm">	 * calls depends on these resources to complete port setup.</span>
<span class="cm">	 */</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">lpfc_sli4_alloc_resource_identifiers</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_MBOX</span> <span class="o">|</span> <span class="n">LOG_SLI</span><span class="p">,</span>
				<span class="s">&quot;2920 Failed to alloc Resource IDs &quot;</span>
				<span class="s">&quot;rc = x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">rc</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_free_mbox</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Read the port&#39;s service parameters. */</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">lpfc_read_sparam</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">mboxq</span><span class="p">,</span> <span class="n">vport</span><span class="o">-&gt;</span><span class="n">vpi</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">link_state</span> <span class="o">=</span> <span class="n">LPFC_HBA_ERROR</span><span class="p">;</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out_free_mbox</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">mboxq</span><span class="o">-&gt;</span><span class="n">vport</span> <span class="o">=</span> <span class="n">vport</span><span class="p">;</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">lpfc_sli_issue_mbox</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">mboxq</span><span class="p">,</span> <span class="n">MBX_POLL</span><span class="p">);</span>
	<span class="n">mp</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_dmabuf</span> <span class="o">*</span><span class="p">)</span> <span class="n">mboxq</span><span class="o">-&gt;</span><span class="n">context1</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">==</span> <span class="n">MBX_SUCCESS</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_sparam</span><span class="p">,</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">virt</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">serv_parm</span><span class="p">));</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * This memory was allocated by the lpfc_read_sparam routine. Release</span>
<span class="cm">	 * it to the mbuf pool.</span>
<span class="cm">	 */</span>
	<span class="n">lpfc_mbuf_free</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">virt</span><span class="p">,</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">phys</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">mp</span><span class="p">);</span>
	<span class="n">mboxq</span><span class="o">-&gt;</span><span class="n">context1</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">rc</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_MBOX</span> <span class="o">|</span> <span class="n">LOG_SLI</span><span class="p">,</span>
				<span class="s">&quot;0382 READ_SPARAM command failed &quot;</span>
				<span class="s">&quot;status %d, mbxStatus x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">rc</span><span class="p">,</span> <span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_mqe_status</span><span class="p">,</span> <span class="n">mqe</span><span class="p">));</span>
		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">link_state</span> <span class="o">=</span> <span class="n">LPFC_HBA_ERROR</span><span class="p">;</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out_free_mbox</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">lpfc_update_vport_wwn</span><span class="p">(</span><span class="n">vport</span><span class="p">);</span>

	<span class="cm">/* Update the fc_host data structures with new wwn. */</span>
	<span class="n">fc_host_node_name</span><span class="p">(</span><span class="n">shost</span><span class="p">)</span> <span class="o">=</span> <span class="n">wwn_to_u64</span><span class="p">(</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_nodename</span><span class="p">.</span><span class="n">u</span><span class="p">.</span><span class="n">wwn</span><span class="p">);</span>
	<span class="n">fc_host_port_name</span><span class="p">(</span><span class="n">shost</span><span class="p">)</span> <span class="o">=</span> <span class="n">wwn_to_u64</span><span class="p">(</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_portname</span><span class="p">.</span><span class="n">u</span><span class="p">.</span><span class="n">wwn</span><span class="p">);</span>

	<span class="cm">/* update host els and scsi xri-sgl sizes and mappings */</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">lpfc_sli4_xri_sgl_update</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">rc</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_MBOX</span> <span class="o">|</span> <span class="n">LOG_SLI</span><span class="p">,</span>
				<span class="s">&quot;1400 Failed to update xri-sgl size and &quot;</span>
				<span class="s">&quot;mapping: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">rc</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_free_mbox</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* register the els sgl pool to the port */</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">lpfc_sli4_repost_els_sgl_list</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">rc</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_MBOX</span> <span class="o">|</span> <span class="n">LOG_SLI</span><span class="p">,</span>
				<span class="s">&quot;0582 Error %d during els sgl post &quot;</span>
				<span class="s">&quot;operation</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">rc</span><span class="p">);</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out_free_mbox</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* register the allocated scsi sgl pool to the port */</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">lpfc_sli4_repost_scsi_sgl_list</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">rc</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_MBOX</span> <span class="o">|</span> <span class="n">LOG_SLI</span><span class="p">,</span>
				<span class="s">&quot;0383 Error %d during scsi sgl post &quot;</span>
				<span class="s">&quot;operation</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">rc</span><span class="p">);</span>
		<span class="cm">/* Some Scsi buffers were moved to the abort scsi list */</span>
		<span class="cm">/* A pci function reset will repost them */</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out_free_mbox</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Post the rpi header region to the device. */</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">lpfc_sli4_post_all_rpi_hdrs</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">rc</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_MBOX</span> <span class="o">|</span> <span class="n">LOG_SLI</span><span class="p">,</span>
				<span class="s">&quot;0393 Error %d during rpi post operation</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">rc</span><span class="p">);</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out_free_mbox</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">lpfc_sli4_node_prep</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>

	<span class="cm">/* Create all the SLI4 queues */</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">lpfc_sli4_queue_create</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_INIT</span><span class="p">,</span>
				<span class="s">&quot;3089 Failed to allocate queues</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out_stop_timers</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* Set up all the queues to the device */</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">lpfc_sli4_queue_setup</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">rc</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_MBOX</span> <span class="o">|</span> <span class="n">LOG_SLI</span><span class="p">,</span>
				<span class="s">&quot;0381 Error %d during queue setup.</span><span class="se">\n</span><span class="s"> &quot;</span><span class="p">,</span> <span class="n">rc</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_destroy_queue</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Arm the CQs and then EQs on device */</span>
	<span class="n">lpfc_sli4_arm_cqeq_intr</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>

	<span class="cm">/* Indicate device interrupt mode */</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">intr_enable</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/* Allow asynchronous mailbox command to go through */</span>
	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli</span><span class="p">.</span><span class="n">sli_flag</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">LPFC_SLI_ASYNC_MBX_BLK</span><span class="p">;</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>

	<span class="cm">/* Post receive buffers to the device */</span>
	<span class="n">lpfc_sli4_rb_setup</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>

	<span class="cm">/* Reset HBA FCF states after HBA reset */</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">fcf</span><span class="p">.</span><span class="n">fcf_flag</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">fcf</span><span class="p">.</span><span class="n">current_rec</span><span class="p">.</span><span class="n">flag</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Start the ELS watchdog timer */</span>
	<span class="n">mod_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">els_tmofunc</span><span class="p">,</span>
		  <span class="n">jiffies</span> <span class="o">+</span> <span class="n">HZ</span> <span class="o">*</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">fc_ratov</span> <span class="o">*</span> <span class="mi">2</span><span class="p">));</span>

	<span class="cm">/* Start heart beat timer */</span>
	<span class="n">mod_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hb_tmofunc</span><span class="p">,</span>
		  <span class="n">jiffies</span> <span class="o">+</span> <span class="n">HZ</span> <span class="o">*</span> <span class="n">LPFC_HB_MBOX_INTERVAL</span><span class="p">);</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">hb_outstanding</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">last_completion_time</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span>

	<span class="cm">/* Start error attention (ERATT) polling timer */</span>
	<span class="n">mod_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">eratt_poll</span><span class="p">,</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="n">HZ</span> <span class="o">*</span> <span class="n">LPFC_ERATT_POLL_INTERVAL</span><span class="p">);</span>

	<span class="cm">/* Enable PCIe device Advanced Error Reporting (AER) if configured */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">cfg_aer_support</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hba_flag</span> <span class="o">&amp;</span> <span class="n">HBA_AER_ENABLED</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">pci_enable_pcie_error_reporting</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">pcidev</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_INFO</span><span class="p">,</span> <span class="n">LOG_INIT</span><span class="p">,</span>
					<span class="s">&quot;2829 This device supports &quot;</span>
					<span class="s">&quot;Advanced Error Reporting (AER)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>
			<span class="n">phba</span><span class="o">-&gt;</span><span class="n">hba_flag</span> <span class="o">|=</span> <span class="n">HBA_AER_ENABLED</span><span class="p">;</span>
			<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_INFO</span><span class="p">,</span> <span class="n">LOG_INIT</span><span class="p">,</span>
					<span class="s">&quot;2830 This device does not support &quot;</span>
					<span class="s">&quot;Advanced Error Reporting (AER)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">phba</span><span class="o">-&gt;</span><span class="n">cfg_aer_support</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hba_flag</span> <span class="o">&amp;</span> <span class="n">HBA_FCOE_MODE</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * The FC Port needs to register FCFI (index 0)</span>
<span class="cm">		 */</span>
		<span class="n">lpfc_reg_fcfi</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">mboxq</span><span class="p">);</span>
		<span class="n">mboxq</span><span class="o">-&gt;</span><span class="n">vport</span> <span class="o">=</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">pport</span><span class="p">;</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">lpfc_sli_issue_mbox</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">mboxq</span><span class="p">,</span> <span class="n">MBX_POLL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">!=</span> <span class="n">MBX_SUCCESS</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out_unset_queue</span><span class="p">;</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">fcf</span><span class="p">.</span><span class="n">fcfi</span> <span class="o">=</span> <span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_reg_fcfi_fcfi</span><span class="p">,</span>
					<span class="o">&amp;</span><span class="n">mboxq</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">mqe</span><span class="p">.</span><span class="n">un</span><span class="p">.</span><span class="n">reg_fcfi</span><span class="p">);</span>

		<span class="cm">/* Check if the port is configured to be disabled */</span>
		<span class="n">lpfc_sli_read_link_ste</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * The port is ready, set the host&#39;s link state to LINK_DOWN</span>
<span class="cm">	 * in preparation for link interrupts.</span>
<span class="cm">	 */</span>
	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">link_state</span> <span class="o">=</span> <span class="n">LPFC_LINK_DOWN</span><span class="p">;</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hba_flag</span> <span class="o">&amp;</span> <span class="n">HBA_FCOE_MODE</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hba_flag</span> <span class="o">&amp;</span> <span class="n">LINK_DISABLED</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_INIT</span> <span class="o">|</span> <span class="n">LOG_SLI</span><span class="p">,</span>
				<span class="s">&quot;3103 Adapter Link is disabled.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">lpfc_down_link</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">mboxq</span><span class="p">);</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">lpfc_sli_issue_mbox</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">mboxq</span><span class="p">,</span> <span class="n">MBX_POLL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">!=</span> <span class="n">MBX_SUCCESS</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_INIT</span> <span class="o">|</span> <span class="n">LOG_SLI</span><span class="p">,</span>
					<span class="s">&quot;3104 Adapter failed to issue &quot;</span>
					<span class="s">&quot;DOWN_LINK mbox cmd, rc:x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">rc</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">out_unset_queue</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">cfg_suppress_link_up</span> <span class="o">==</span> <span class="n">LPFC_INITIALIZE_LINK</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* don&#39;t perform init_link on SLI4 FC port loopback test */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">link_flag</span> <span class="o">&amp;</span> <span class="n">LS_LOOPBACK_MODE</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">rc</span> <span class="o">=</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">lpfc_hba_init_link</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">MBX_NOWAIT</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">out_unset_queue</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">mempool_free</span><span class="p">(</span><span class="n">mboxq</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">mbox_mem_pool</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="nl">out_unset_queue:</span>
	<span class="cm">/* Unset all the queues set up in this routine when error out */</span>
	<span class="n">lpfc_sli4_queue_unset</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
<span class="nl">out_destroy_queue:</span>
	<span class="n">lpfc_sli4_queue_destroy</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
<span class="nl">out_stop_timers:</span>
	<span class="n">lpfc_stop_hba_timers</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
<span class="nl">out_free_mbox:</span>
	<span class="n">mempool_free</span><span class="p">(</span><span class="n">mboxq</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">mbox_mem_pool</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_mbox_timeout - Timeout call back function for mbox timer</span>
<span class="cm"> * @ptr: context object - pointer to hba structure.</span>
<span class="cm"> *</span>
<span class="cm"> * This is the callback function for mailbox timer. The mailbox</span>
<span class="cm"> * timer is armed when a new mailbox command is issued and the timer</span>
<span class="cm"> * is deleted when the mailbox complete. The function is called by</span>
<span class="cm"> * the kernel timer code when a mailbox does not complete within</span>
<span class="cm"> * expected time. This function wakes up the worker thread to</span>
<span class="cm"> * process the mailbox timeout and returns. All the processing is</span>
<span class="cm"> * done by the worker thread function lpfc_mbox_timeout_handler.</span>
<span class="cm"> **/</span>
<span class="kt">void</span>
<span class="nf">lpfc_mbox_timeout</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ptr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpfc_hba</span>  <span class="o">*</span><span class="n">phba</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="p">)</span> <span class="n">ptr</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">iflag</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">tmo_posted</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">pport</span><span class="o">-&gt;</span><span class="n">work_port_lock</span><span class="p">,</span> <span class="n">iflag</span><span class="p">);</span>
	<span class="n">tmo_posted</span> <span class="o">=</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">pport</span><span class="o">-&gt;</span><span class="n">work_port_events</span> <span class="o">&amp;</span> <span class="n">WORKER_MBOX_TMO</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tmo_posted</span><span class="p">)</span>
		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">pport</span><span class="o">-&gt;</span><span class="n">work_port_events</span> <span class="o">|=</span> <span class="n">WORKER_MBOX_TMO</span><span class="p">;</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">pport</span><span class="o">-&gt;</span><span class="n">work_port_lock</span><span class="p">,</span> <span class="n">iflag</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tmo_posted</span><span class="p">)</span>
		<span class="n">lpfc_worker_wake_up</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/**</span>
<span class="cm"> * lpfc_mbox_timeout_handler - Worker thread function to handle mailbox timeout</span>
<span class="cm"> * @phba: Pointer to HBA context object.</span>
<span class="cm"> *</span>
<span class="cm"> * This function is called from worker thread when a mailbox command times out.</span>
<span class="cm"> * The caller is not required to hold any locks. This function will reset the</span>
<span class="cm"> * HBA and recover all the pending commands.</span>
<span class="cm"> **/</span>
<span class="kt">void</span>
<span class="nf">lpfc_mbox_timeout_handler</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">LPFC_MBOXQ_t</span> <span class="o">*</span><span class="n">pmbox</span> <span class="o">=</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli</span><span class="p">.</span><span class="n">mbox_active</span><span class="p">;</span>
	<span class="n">MAILBOX_t</span> <span class="o">*</span><span class="n">mb</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">pmbox</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">mb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_sli</span> <span class="o">*</span><span class="n">psli</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_sli_ring</span> <span class="o">*</span><span class="n">pring</span><span class="p">;</span>

	<span class="cm">/* Check the pmbox pointer first.  There is a race condition</span>
<span class="cm">	 * between the mbox timeout handler getting executed in the</span>
<span class="cm">	 * worklist and the mailbox actually completing. When this</span>
<span class="cm">	 * race condition occurs, the mbox_active will be NULL.</span>
<span class="cm">	 */</span>
	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pmbox</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_WARNING</span><span class="p">,</span>
				<span class="n">LOG_MBOX</span> <span class="o">|</span> <span class="n">LOG_SLI</span><span class="p">,</span>
				<span class="s">&quot;0353 Active Mailbox cleared - mailbox timeout &quot;</span>
				<span class="s">&quot;exiting</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Mbox cmd &lt;mbxCommand&gt; timeout */</span>
	<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_MBOX</span> <span class="o">|</span> <span class="n">LOG_SLI</span><span class="p">,</span>
			<span class="s">&quot;0310 Mailbox command x%x timeout Data: x%x x%x x%p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">mb</span><span class="o">-&gt;</span><span class="n">mbxCommand</span><span class="p">,</span>
			<span class="n">phba</span><span class="o">-&gt;</span><span class="n">pport</span><span class="o">-&gt;</span><span class="n">port_state</span><span class="p">,</span>
			<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli</span><span class="p">.</span><span class="n">sli_flag</span><span class="p">,</span>
			<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli</span><span class="p">.</span><span class="n">mbox_active</span><span class="p">);</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>

	<span class="cm">/* Setting state unknown so lpfc_sli_abort_iocb_ring</span>
<span class="cm">	 * would get IOCB_ERROR from lpfc_sli_issue_iocb, allowing</span>
<span class="cm">	 * it to fail all outstanding SCSI IO.</span>
<span class="cm">	 */</span>
	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">pport</span><span class="o">-&gt;</span><span class="n">work_port_lock</span><span class="p">);</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">pport</span><span class="o">-&gt;</span><span class="n">work_port_events</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">WORKER_MBOX_TMO</span><span class="p">;</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">pport</span><span class="o">-&gt;</span><span class="n">work_port_lock</span><span class="p">);</span>
	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">link_state</span> <span class="o">=</span> <span class="n">LPFC_LINK_UNKNOWN</span><span class="p">;</span>
	<span class="n">psli</span><span class="o">-&gt;</span><span class="n">sli_flag</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">LPFC_SLI_ACTIVE</span><span class="p">;</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>

	<span class="n">pring</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">psli</span><span class="o">-&gt;</span><span class="n">ring</span><span class="p">[</span><span class="n">psli</span><span class="o">-&gt;</span><span class="n">fcp_ring</span><span class="p">];</span>
	<span class="n">lpfc_sli_abort_iocb_ring</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">pring</span><span class="p">);</span>

	<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_MBOX</span> <span class="o">|</span> <span class="n">LOG_SLI</span><span class="p">,</span>
			<span class="s">&quot;0345 Resetting board due to mailbox timeout</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="cm">/* Reset the HBA device */</span>
	<span class="n">lpfc_reset_hba</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_sli_issue_mbox_s3 - Issue an SLI3 mailbox command to firmware</span>
<span class="cm"> * @phba: Pointer to HBA context object.</span>
<span class="cm"> * @pmbox: Pointer to mailbox object.</span>
<span class="cm"> * @flag: Flag indicating how the mailbox need to be processed.</span>
<span class="cm"> *</span>
<span class="cm"> * This function is called by discovery code and HBA management code</span>
<span class="cm"> * to submit a mailbox command to firmware with SLI-3 interface spec. This</span>
<span class="cm"> * function gets the hbalock to protect the data structures.</span>
<span class="cm"> * The mailbox command can be submitted in polling mode, in which case</span>
<span class="cm"> * this function will wait in a polling loop for the completion of the</span>
<span class="cm"> * mailbox.</span>
<span class="cm"> * If the mailbox is submitted in no_wait mode (not polling) the</span>
<span class="cm"> * function will submit the command and returns immediately without waiting</span>
<span class="cm"> * for the mailbox completion. The no_wait is supported only when HBA</span>
<span class="cm"> * is in SLI2/SLI3 mode - interrupts are enabled.</span>
<span class="cm"> * The SLI interface allows only one mailbox pending at a time. If the</span>
<span class="cm"> * mailbox is issued in polling mode and there is already a mailbox</span>
<span class="cm"> * pending, then the function will return an error. If the mailbox is issued</span>
<span class="cm"> * in NO_WAIT mode and there is a mailbox pending already, the function</span>
<span class="cm"> * will return MBX_BUSY after queuing the mailbox into mailbox queue.</span>
<span class="cm"> * The sli layer owns the mailbox object until the completion of mailbox</span>
<span class="cm"> * command if this function return MBX_BUSY or MBX_SUCCESS. For all other</span>
<span class="cm"> * return codes the caller owns the mailbox command after the return of</span>
<span class="cm"> * the function.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">lpfc_sli_issue_mbox_s3</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">,</span> <span class="n">LPFC_MBOXQ_t</span> <span class="o">*</span><span class="n">pmbox</span><span class="p">,</span>
		       <span class="kt">uint32_t</span> <span class="n">flag</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">MAILBOX_t</span> <span class="o">*</span><span class="n">mb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_sli</span> <span class="o">*</span><span class="n">psli</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">status</span><span class="p">,</span> <span class="n">evtctr</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">ha_copy</span><span class="p">,</span> <span class="n">hc_copy</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">timeout</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">drvr_flag</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">word0</span><span class="p">,</span> <span class="n">ldata</span><span class="p">;</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">to_slim</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">processing_queue</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">,</span> <span class="n">drvr_flag</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pmbox</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli</span><span class="p">.</span><span class="n">sli_flag</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">LPFC_SLI_MBOX_ACTIVE</span><span class="p">;</span>
		<span class="cm">/* processing mbox queue from intr_handler */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">psli</span><span class="o">-&gt;</span><span class="n">sli_flag</span> <span class="o">&amp;</span> <span class="n">LPFC_SLI_ASYNC_MBX_BLK</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">,</span> <span class="n">drvr_flag</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">MBX_SUCCESS</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">processing_queue</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">pmbox</span> <span class="o">=</span> <span class="n">lpfc_mbox_get</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pmbox</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">,</span> <span class="n">drvr_flag</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">MBX_SUCCESS</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pmbox</span><span class="o">-&gt;</span><span class="n">mbox_cmpl</span> <span class="o">&amp;&amp;</span> <span class="n">pmbox</span><span class="o">-&gt;</span><span class="n">mbox_cmpl</span> <span class="o">!=</span> <span class="n">lpfc_sli_def_mbox_cmpl</span> <span class="o">&amp;&amp;</span>
		<span class="n">pmbox</span><span class="o">-&gt;</span><span class="n">mbox_cmpl</span> <span class="o">!=</span> <span class="n">lpfc_sli_wake_mbox_wait</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">pmbox</span><span class="o">-&gt;</span><span class="n">vport</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">,</span> <span class="n">drvr_flag</span><span class="p">);</span>
			<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span>
					<span class="n">LOG_MBOX</span> <span class="o">|</span> <span class="n">LOG_VPORT</span><span class="p">,</span>
					<span class="s">&quot;1806 Mbox x%x failed. No vport</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">pmbox</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">mb</span><span class="p">.</span><span class="n">mbxCommand</span><span class="p">);</span>
			<span class="n">dump_stack</span><span class="p">();</span>
			<span class="k">goto</span> <span class="n">out_not_finished</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* If the PCI channel is in offline state, do not post mbox. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">pci_channel_offline</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">pcidev</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">,</span> <span class="n">drvr_flag</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_not_finished</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* If HBA has a deferred error attention, fail the iocb. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hba_flag</span> <span class="o">&amp;</span> <span class="n">DEFER_ERATT</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">,</span> <span class="n">drvr_flag</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_not_finished</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">psli</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli</span><span class="p">;</span>

	<span class="n">mb</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">pmbox</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">mb</span><span class="p">;</span>
	<span class="n">status</span> <span class="o">=</span> <span class="n">MBX_SUCCESS</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">link_state</span> <span class="o">==</span> <span class="n">LPFC_HBA_ERROR</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">,</span> <span class="n">drvr_flag</span><span class="p">);</span>

		<span class="cm">/* Mbox command &lt;mbxCommand&gt; cannot issue */</span>
		<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_MBOX</span> <span class="o">|</span> <span class="n">LOG_SLI</span><span class="p">,</span>
				<span class="s">&quot;(%d):0311 Mailbox command x%x cannot &quot;</span>
				<span class="s">&quot;issue Data: x%x x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">pmbox</span><span class="o">-&gt;</span><span class="n">vport</span> <span class="o">?</span> <span class="n">pmbox</span><span class="o">-&gt;</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">vpi</span> <span class="o">:</span> <span class="mi">0</span><span class="p">,</span>
				<span class="n">pmbox</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">mb</span><span class="p">.</span><span class="n">mbxCommand</span><span class="p">,</span> <span class="n">psli</span><span class="o">-&gt;</span><span class="n">sli_flag</span><span class="p">,</span> <span class="n">flag</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_not_finished</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">mb</span><span class="o">-&gt;</span><span class="n">mbxCommand</span> <span class="o">!=</span> <span class="n">MBX_KILL_BOARD</span> <span class="o">&amp;&amp;</span> <span class="n">flag</span> <span class="o">&amp;</span> <span class="n">MBX_NOWAIT</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">lpfc_readl</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">HCregaddr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hc_copy</span><span class="p">)</span> <span class="o">||</span>
			<span class="o">!</span><span class="p">(</span><span class="n">hc_copy</span> <span class="o">&amp;</span> <span class="n">HC_MBINT_ENA</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">,</span> <span class="n">drvr_flag</span><span class="p">);</span>
			<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_MBOX</span> <span class="o">|</span> <span class="n">LOG_SLI</span><span class="p">,</span>
				<span class="s">&quot;(%d):2528 Mailbox command x%x cannot &quot;</span>
				<span class="s">&quot;issue Data: x%x x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">pmbox</span><span class="o">-&gt;</span><span class="n">vport</span> <span class="o">?</span> <span class="n">pmbox</span><span class="o">-&gt;</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">vpi</span> <span class="o">:</span> <span class="mi">0</span><span class="p">,</span>
				<span class="n">pmbox</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">mb</span><span class="p">.</span><span class="n">mbxCommand</span><span class="p">,</span> <span class="n">psli</span><span class="o">-&gt;</span><span class="n">sli_flag</span><span class="p">,</span> <span class="n">flag</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">out_not_finished</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">psli</span><span class="o">-&gt;</span><span class="n">sli_flag</span> <span class="o">&amp;</span> <span class="n">LPFC_SLI_MBOX_ACTIVE</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Polling for a mbox command when another one is already active</span>
<span class="cm">		 * is not allowed in SLI. Also, the driver must have established</span>
<span class="cm">		 * SLI2 mode to queue and process multiple mbox commands.</span>
<span class="cm">		 */</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">flag</span> <span class="o">&amp;</span> <span class="n">MBX_POLL</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">,</span> <span class="n">drvr_flag</span><span class="p">);</span>

			<span class="cm">/* Mbox command &lt;mbxCommand&gt; cannot issue */</span>
			<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_MBOX</span> <span class="o">|</span> <span class="n">LOG_SLI</span><span class="p">,</span>
					<span class="s">&quot;(%d):2529 Mailbox command x%x &quot;</span>
					<span class="s">&quot;cannot issue Data: x%x x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">pmbox</span><span class="o">-&gt;</span><span class="n">vport</span> <span class="o">?</span> <span class="n">pmbox</span><span class="o">-&gt;</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">vpi</span> <span class="o">:</span> <span class="mi">0</span><span class="p">,</span>
					<span class="n">pmbox</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">mb</span><span class="p">.</span><span class="n">mbxCommand</span><span class="p">,</span>
					<span class="n">psli</span><span class="o">-&gt;</span><span class="n">sli_flag</span><span class="p">,</span> <span class="n">flag</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">out_not_finished</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">psli</span><span class="o">-&gt;</span><span class="n">sli_flag</span> <span class="o">&amp;</span> <span class="n">LPFC_SLI_ACTIVE</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">,</span> <span class="n">drvr_flag</span><span class="p">);</span>
			<span class="cm">/* Mbox command &lt;mbxCommand&gt; cannot issue */</span>
			<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_MBOX</span> <span class="o">|</span> <span class="n">LOG_SLI</span><span class="p">,</span>
					<span class="s">&quot;(%d):2530 Mailbox command x%x &quot;</span>
					<span class="s">&quot;cannot issue Data: x%x x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">pmbox</span><span class="o">-&gt;</span><span class="n">vport</span> <span class="o">?</span> <span class="n">pmbox</span><span class="o">-&gt;</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">vpi</span> <span class="o">:</span> <span class="mi">0</span><span class="p">,</span>
					<span class="n">pmbox</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">mb</span><span class="p">.</span><span class="n">mbxCommand</span><span class="p">,</span>
					<span class="n">psli</span><span class="o">-&gt;</span><span class="n">sli_flag</span><span class="p">,</span> <span class="n">flag</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">out_not_finished</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* Another mailbox command is still being processed, queue this</span>
<span class="cm">		 * command to be processed later.</span>
<span class="cm">		 */</span>
		<span class="n">lpfc_mbox_put</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">pmbox</span><span class="p">);</span>

		<span class="cm">/* Mbox cmd issue - BUSY */</span>
		<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_INFO</span><span class="p">,</span> <span class="n">LOG_MBOX</span> <span class="o">|</span> <span class="n">LOG_SLI</span><span class="p">,</span>
				<span class="s">&quot;(%d):0308 Mbox cmd issue - BUSY Data: &quot;</span>
				<span class="s">&quot;x%x x%x x%x x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">pmbox</span><span class="o">-&gt;</span><span class="n">vport</span> <span class="o">?</span> <span class="n">pmbox</span><span class="o">-&gt;</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">vpi</span> <span class="o">:</span> <span class="mh">0xffffff</span><span class="p">,</span>
				<span class="n">mb</span><span class="o">-&gt;</span><span class="n">mbxCommand</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">pport</span><span class="o">-&gt;</span><span class="n">port_state</span><span class="p">,</span>
				<span class="n">psli</span><span class="o">-&gt;</span><span class="n">sli_flag</span><span class="p">,</span> <span class="n">flag</span><span class="p">);</span>

		<span class="n">psli</span><span class="o">-&gt;</span><span class="n">slistat</span><span class="p">.</span><span class="n">mbox_busy</span><span class="o">++</span><span class="p">;</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">,</span> <span class="n">drvr_flag</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">pmbox</span><span class="o">-&gt;</span><span class="n">vport</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">lpfc_debugfs_disc_trc</span><span class="p">(</span><span class="n">pmbox</span><span class="o">-&gt;</span><span class="n">vport</span><span class="p">,</span>
				<span class="n">LPFC_DISC_TRC_MBOX_VPORT</span><span class="p">,</span>
				<span class="s">&quot;MBOX Bsy vport:  cmd:x%x mb:x%x x%x&quot;</span><span class="p">,</span>
				<span class="p">(</span><span class="kt">uint32_t</span><span class="p">)</span><span class="n">mb</span><span class="o">-&gt;</span><span class="n">mbxCommand</span><span class="p">,</span>
				<span class="n">mb</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">varWords</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">mb</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">varWords</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
		<span class="p">}</span>
		<span class="k">else</span> <span class="p">{</span>
			<span class="n">lpfc_debugfs_disc_trc</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">pport</span><span class="p">,</span>
				<span class="n">LPFC_DISC_TRC_MBOX</span><span class="p">,</span>
				<span class="s">&quot;MBOX Bsy:        cmd:x%x mb:x%x x%x&quot;</span><span class="p">,</span>
				<span class="p">(</span><span class="kt">uint32_t</span><span class="p">)</span><span class="n">mb</span><span class="o">-&gt;</span><span class="n">mbxCommand</span><span class="p">,</span>
				<span class="n">mb</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">varWords</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">mb</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">varWords</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
		<span class="p">}</span>

		<span class="k">return</span> <span class="n">MBX_BUSY</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">psli</span><span class="o">-&gt;</span><span class="n">sli_flag</span> <span class="o">|=</span> <span class="n">LPFC_SLI_MBOX_ACTIVE</span><span class="p">;</span>

	<span class="cm">/* If we are not polling, we MUST be in SLI2 mode */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">flag</span> <span class="o">!=</span> <span class="n">MBX_POLL</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">psli</span><span class="o">-&gt;</span><span class="n">sli_flag</span> <span class="o">&amp;</span> <span class="n">LPFC_SLI_ACTIVE</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="p">(</span><span class="n">mb</span><span class="o">-&gt;</span><span class="n">mbxCommand</span> <span class="o">!=</span> <span class="n">MBX_KILL_BOARD</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">psli</span><span class="o">-&gt;</span><span class="n">sli_flag</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">LPFC_SLI_MBOX_ACTIVE</span><span class="p">;</span>
			<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">,</span> <span class="n">drvr_flag</span><span class="p">);</span>
			<span class="cm">/* Mbox command &lt;mbxCommand&gt; cannot issue */</span>
			<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_MBOX</span> <span class="o">|</span> <span class="n">LOG_SLI</span><span class="p">,</span>
					<span class="s">&quot;(%d):2531 Mailbox command x%x &quot;</span>
					<span class="s">&quot;cannot issue Data: x%x x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">pmbox</span><span class="o">-&gt;</span><span class="n">vport</span> <span class="o">?</span> <span class="n">pmbox</span><span class="o">-&gt;</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">vpi</span> <span class="o">:</span> <span class="mi">0</span><span class="p">,</span>
					<span class="n">pmbox</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">mb</span><span class="p">.</span><span class="n">mbxCommand</span><span class="p">,</span>
					<span class="n">psli</span><span class="o">-&gt;</span><span class="n">sli_flag</span><span class="p">,</span> <span class="n">flag</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">out_not_finished</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/* timeout active mbox command */</span>
		<span class="n">mod_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">psli</span><span class="o">-&gt;</span><span class="n">mbox_tmo</span><span class="p">,</span> <span class="p">(</span><span class="n">jiffies</span> <span class="o">+</span>
			       <span class="p">(</span><span class="n">HZ</span> <span class="o">*</span> <span class="n">lpfc_mbox_tmo_val</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">pmbox</span><span class="p">))));</span>
	<span class="p">}</span>

	<span class="cm">/* Mailbox cmd &lt;cmd&gt; issue */</span>
	<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_INFO</span><span class="p">,</span> <span class="n">LOG_MBOX</span> <span class="o">|</span> <span class="n">LOG_SLI</span><span class="p">,</span>
			<span class="s">&quot;(%d):0309 Mailbox cmd x%x issue Data: x%x x%x &quot;</span>
			<span class="s">&quot;x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">pmbox</span><span class="o">-&gt;</span><span class="n">vport</span> <span class="o">?</span> <span class="n">pmbox</span><span class="o">-&gt;</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">vpi</span> <span class="o">:</span> <span class="mi">0</span><span class="p">,</span>
			<span class="n">mb</span><span class="o">-&gt;</span><span class="n">mbxCommand</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">pport</span><span class="o">-&gt;</span><span class="n">port_state</span><span class="p">,</span>
			<span class="n">psli</span><span class="o">-&gt;</span><span class="n">sli_flag</span><span class="p">,</span> <span class="n">flag</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">mb</span><span class="o">-&gt;</span><span class="n">mbxCommand</span> <span class="o">!=</span> <span class="n">MBX_HEARTBEAT</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pmbox</span><span class="o">-&gt;</span><span class="n">vport</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">lpfc_debugfs_disc_trc</span><span class="p">(</span><span class="n">pmbox</span><span class="o">-&gt;</span><span class="n">vport</span><span class="p">,</span>
				<span class="n">LPFC_DISC_TRC_MBOX_VPORT</span><span class="p">,</span>
				<span class="s">&quot;MBOX Send vport: cmd:x%x mb:x%x x%x&quot;</span><span class="p">,</span>
				<span class="p">(</span><span class="kt">uint32_t</span><span class="p">)</span><span class="n">mb</span><span class="o">-&gt;</span><span class="n">mbxCommand</span><span class="p">,</span>
				<span class="n">mb</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">varWords</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">mb</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">varWords</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
		<span class="p">}</span>
		<span class="k">else</span> <span class="p">{</span>
			<span class="n">lpfc_debugfs_disc_trc</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">pport</span><span class="p">,</span>
				<span class="n">LPFC_DISC_TRC_MBOX</span><span class="p">,</span>
				<span class="s">&quot;MBOX Send:       cmd:x%x mb:x%x x%x&quot;</span><span class="p">,</span>
				<span class="p">(</span><span class="kt">uint32_t</span><span class="p">)</span><span class="n">mb</span><span class="o">-&gt;</span><span class="n">mbxCommand</span><span class="p">,</span>
				<span class="n">mb</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">varWords</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">mb</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">varWords</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">psli</span><span class="o">-&gt;</span><span class="n">slistat</span><span class="p">.</span><span class="n">mbox_cmd</span><span class="o">++</span><span class="p">;</span>
	<span class="n">evtctr</span> <span class="o">=</span> <span class="n">psli</span><span class="o">-&gt;</span><span class="n">slistat</span><span class="p">.</span><span class="n">mbox_event</span><span class="p">;</span>

	<span class="cm">/* next set own bit for the adapter and copy over command word */</span>
	<span class="n">mb</span><span class="o">-&gt;</span><span class="n">mbxOwner</span> <span class="o">=</span> <span class="n">OWN_CHIP</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">psli</span><span class="o">-&gt;</span><span class="n">sli_flag</span> <span class="o">&amp;</span> <span class="n">LPFC_SLI_ACTIVE</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Populate mbox extension offset word. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pmbox</span><span class="o">-&gt;</span><span class="n">in_ext_byte_len</span> <span class="o">||</span> <span class="n">pmbox</span><span class="o">-&gt;</span><span class="n">out_ext_byte_len</span><span class="p">)</span> <span class="p">{</span>
			<span class="o">*</span><span class="p">(((</span><span class="kt">uint32_t</span> <span class="o">*</span><span class="p">)</span><span class="n">mb</span><span class="p">)</span> <span class="o">+</span> <span class="n">pmbox</span><span class="o">-&gt;</span><span class="n">mbox_offset_word</span><span class="p">)</span>
				<span class="o">=</span> <span class="p">(</span><span class="kt">uint8_t</span> <span class="o">*</span><span class="p">)</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">mbox_ext</span>
				  <span class="o">-</span> <span class="p">(</span><span class="kt">uint8_t</span> <span class="o">*</span><span class="p">)</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">mbox</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* Copy the mailbox extension data */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pmbox</span><span class="o">-&gt;</span><span class="n">in_ext_byte_len</span> <span class="o">&amp;&amp;</span> <span class="n">pmbox</span><span class="o">-&gt;</span><span class="n">context2</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">lpfc_sli_pcimem_bcopy</span><span class="p">(</span><span class="n">pmbox</span><span class="o">-&gt;</span><span class="n">context2</span><span class="p">,</span>
				<span class="p">(</span><span class="kt">uint8_t</span> <span class="o">*</span><span class="p">)</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">mbox_ext</span><span class="p">,</span>
				<span class="n">pmbox</span><span class="o">-&gt;</span><span class="n">in_ext_byte_len</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="cm">/* Copy command data to host SLIM area */</span>
		<span class="n">lpfc_sli_pcimem_bcopy</span><span class="p">(</span><span class="n">mb</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">mbox</span><span class="p">,</span> <span class="n">MAILBOX_CMD_SIZE</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* Populate mbox extension offset word. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pmbox</span><span class="o">-&gt;</span><span class="n">in_ext_byte_len</span> <span class="o">||</span> <span class="n">pmbox</span><span class="o">-&gt;</span><span class="n">out_ext_byte_len</span><span class="p">)</span>
			<span class="o">*</span><span class="p">(((</span><span class="kt">uint32_t</span> <span class="o">*</span><span class="p">)</span><span class="n">mb</span><span class="p">)</span> <span class="o">+</span> <span class="n">pmbox</span><span class="o">-&gt;</span><span class="n">mbox_offset_word</span><span class="p">)</span>
				<span class="o">=</span> <span class="n">MAILBOX_HBA_EXT_OFFSET</span><span class="p">;</span>

		<span class="cm">/* Copy the mailbox extension data */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pmbox</span><span class="o">-&gt;</span><span class="n">in_ext_byte_len</span> <span class="o">&amp;&amp;</span> <span class="n">pmbox</span><span class="o">-&gt;</span><span class="n">context2</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">lpfc_memcpy_to_slim</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">MBslimaddr</span> <span class="o">+</span>
				<span class="n">MAILBOX_HBA_EXT_OFFSET</span><span class="p">,</span>
				<span class="n">pmbox</span><span class="o">-&gt;</span><span class="n">context2</span><span class="p">,</span> <span class="n">pmbox</span><span class="o">-&gt;</span><span class="n">in_ext_byte_len</span><span class="p">);</span>

		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">mb</span><span class="o">-&gt;</span><span class="n">mbxCommand</span> <span class="o">==</span> <span class="n">MBX_CONFIG_PORT</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* copy command data into host mbox for cmpl */</span>
			<span class="n">lpfc_sli_pcimem_bcopy</span><span class="p">(</span><span class="n">mb</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">mbox</span><span class="p">,</span> <span class="n">MAILBOX_CMD_SIZE</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="cm">/* First copy mbox command data to HBA SLIM, skip past first</span>
<span class="cm">		   word */</span>
		<span class="n">to_slim</span> <span class="o">=</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">MBslimaddr</span> <span class="o">+</span> <span class="k">sizeof</span> <span class="p">(</span><span class="kt">uint32_t</span><span class="p">);</span>
		<span class="n">lpfc_memcpy_to_slim</span><span class="p">(</span><span class="n">to_slim</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mb</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">varWords</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
			    <span class="n">MAILBOX_CMD_SIZE</span> <span class="o">-</span> <span class="k">sizeof</span> <span class="p">(</span><span class="kt">uint32_t</span><span class="p">));</span>

		<span class="cm">/* Next copy over first word, with mbxOwner set */</span>
		<span class="n">ldata</span> <span class="o">=</span> <span class="o">*</span><span class="p">((</span><span class="kt">uint32_t</span> <span class="o">*</span><span class="p">)</span><span class="n">mb</span><span class="p">);</span>
		<span class="n">to_slim</span> <span class="o">=</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">MBslimaddr</span><span class="p">;</span>
		<span class="n">writel</span><span class="p">(</span><span class="n">ldata</span><span class="p">,</span> <span class="n">to_slim</span><span class="p">);</span>
		<span class="n">readl</span><span class="p">(</span><span class="n">to_slim</span><span class="p">);</span> <span class="cm">/* flush */</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">mb</span><span class="o">-&gt;</span><span class="n">mbxCommand</span> <span class="o">==</span> <span class="n">MBX_CONFIG_PORT</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* switch over to host mailbox */</span>
			<span class="n">psli</span><span class="o">-&gt;</span><span class="n">sli_flag</span> <span class="o">|=</span> <span class="n">LPFC_SLI_ACTIVE</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">wmb</span><span class="p">();</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">flag</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">MBX_NOWAIT</span>:
		<span class="cm">/* Set up reference to mailbox command */</span>
		<span class="n">psli</span><span class="o">-&gt;</span><span class="n">mbox_active</span> <span class="o">=</span> <span class="n">pmbox</span><span class="p">;</span>
		<span class="cm">/* Interrupt board to do it */</span>
		<span class="n">writel</span><span class="p">(</span><span class="n">CA_MBATT</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">CAregaddr</span><span class="p">);</span>
		<span class="n">readl</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">CAregaddr</span><span class="p">);</span> <span class="cm">/* flush */</span>
		<span class="cm">/* Don&#39;t wait for it to finish, just return */</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">MBX_POLL</span>:
		<span class="cm">/* Set up null reference to mailbox command */</span>
		<span class="n">psli</span><span class="o">-&gt;</span><span class="n">mbox_active</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="cm">/* Interrupt board to do it */</span>
		<span class="n">writel</span><span class="p">(</span><span class="n">CA_MBATT</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">CAregaddr</span><span class="p">);</span>
		<span class="n">readl</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">CAregaddr</span><span class="p">);</span> <span class="cm">/* flush */</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">psli</span><span class="o">-&gt;</span><span class="n">sli_flag</span> <span class="o">&amp;</span> <span class="n">LPFC_SLI_ACTIVE</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* First read mbox status word */</span>
			<span class="n">word0</span> <span class="o">=</span> <span class="o">*</span><span class="p">((</span><span class="kt">uint32_t</span> <span class="o">*</span><span class="p">)</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">mbox</span><span class="p">);</span>
			<span class="n">word0</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">word0</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/* First read mbox status word */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">lpfc_readl</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">MBslimaddr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">word0</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">,</span>
						       <span class="n">drvr_flag</span><span class="p">);</span>
				<span class="k">goto</span> <span class="n">out_not_finished</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="cm">/* Read the HBA Host Attention Register */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">lpfc_readl</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">HAregaddr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ha_copy</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">,</span>
						       <span class="n">drvr_flag</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">out_not_finished</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">timeout</span> <span class="o">=</span> <span class="n">msecs_to_jiffies</span><span class="p">(</span><span class="n">lpfc_mbox_tmo_val</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">pmbox</span><span class="p">)</span> <span class="o">*</span>
							<span class="mi">1000</span><span class="p">)</span> <span class="o">+</span> <span class="n">jiffies</span><span class="p">;</span>
		<span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="cm">/* Wait for command to complete */</span>
		<span class="k">while</span> <span class="p">(((</span><span class="n">word0</span> <span class="o">&amp;</span> <span class="n">OWN_CHIP</span><span class="p">)</span> <span class="o">==</span> <span class="n">OWN_CHIP</span><span class="p">)</span> <span class="o">||</span>
		       <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">ha_copy</span> <span class="o">&amp;</span> <span class="n">HA_MBATT</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			<span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">link_state</span> <span class="o">&gt;</span> <span class="n">LPFC_WARM_START</span><span class="p">)))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">time_after</span><span class="p">(</span><span class="n">jiffies</span><span class="p">,</span> <span class="n">timeout</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">psli</span><span class="o">-&gt;</span><span class="n">sli_flag</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">LPFC_SLI_MBOX_ACTIVE</span><span class="p">;</span>
				<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">,</span>
						       <span class="n">drvr_flag</span><span class="p">);</span>
				<span class="k">goto</span> <span class="n">out_not_finished</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="cm">/* Check if we took a mbox interrupt while we were</span>
<span class="cm">			   polling */</span>
			<span class="k">if</span> <span class="p">(((</span><span class="n">word0</span> <span class="o">&amp;</span> <span class="n">OWN_CHIP</span><span class="p">)</span> <span class="o">!=</span> <span class="n">OWN_CHIP</span><span class="p">)</span>
			    <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">evtctr</span> <span class="o">!=</span> <span class="n">psli</span><span class="o">-&gt;</span><span class="n">slistat</span><span class="p">.</span><span class="n">mbox_event</span><span class="p">))</span>
				<span class="k">break</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">i</span><span class="o">++</span> <span class="o">&gt;</span> <span class="mi">10</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">,</span>
						       <span class="n">drvr_flag</span><span class="p">);</span>
				<span class="n">msleep</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
				<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">,</span> <span class="n">drvr_flag</span><span class="p">);</span>
			<span class="p">}</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">psli</span><span class="o">-&gt;</span><span class="n">sli_flag</span> <span class="o">&amp;</span> <span class="n">LPFC_SLI_ACTIVE</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/* First copy command data */</span>
				<span class="n">word0</span> <span class="o">=</span> <span class="o">*</span><span class="p">((</span><span class="kt">uint32_t</span> <span class="o">*</span><span class="p">)</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">mbox</span><span class="p">);</span>
				<span class="n">word0</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">word0</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">mb</span><span class="o">-&gt;</span><span class="n">mbxCommand</span> <span class="o">==</span> <span class="n">MBX_CONFIG_PORT</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">MAILBOX_t</span> <span class="o">*</span><span class="n">slimmb</span><span class="p">;</span>
					<span class="kt">uint32_t</span> <span class="n">slimword0</span><span class="p">;</span>
					<span class="cm">/* Check real SLIM for any errors */</span>
					<span class="n">slimword0</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">MBslimaddr</span><span class="p">);</span>
					<span class="n">slimmb</span> <span class="o">=</span> <span class="p">(</span><span class="n">MAILBOX_t</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">slimword0</span><span class="p">;</span>
					<span class="k">if</span> <span class="p">(((</span><span class="n">slimword0</span> <span class="o">&amp;</span> <span class="n">OWN_CHIP</span><span class="p">)</span> <span class="o">!=</span> <span class="n">OWN_CHIP</span><span class="p">)</span>
					    <span class="o">&amp;&amp;</span> <span class="n">slimmb</span><span class="o">-&gt;</span><span class="n">mbxStatus</span><span class="p">)</span> <span class="p">{</span>
						<span class="n">psli</span><span class="o">-&gt;</span><span class="n">sli_flag</span> <span class="o">&amp;=</span>
						    <span class="o">~</span><span class="n">LPFC_SLI_ACTIVE</span><span class="p">;</span>
						<span class="n">word0</span> <span class="o">=</span> <span class="n">slimword0</span><span class="p">;</span>
					<span class="p">}</span>
				<span class="p">}</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="cm">/* First copy command data */</span>
				<span class="n">word0</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">MBslimaddr</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="cm">/* Read the HBA Host Attention Register */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">lpfc_readl</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">HAregaddr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ha_copy</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">,</span>
						       <span class="n">drvr_flag</span><span class="p">);</span>
				<span class="k">goto</span> <span class="n">out_not_finished</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">psli</span><span class="o">-&gt;</span><span class="n">sli_flag</span> <span class="o">&amp;</span> <span class="n">LPFC_SLI_ACTIVE</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* copy results back to user */</span>
			<span class="n">lpfc_sli_pcimem_bcopy</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">mbox</span><span class="p">,</span> <span class="n">mb</span><span class="p">,</span> <span class="n">MAILBOX_CMD_SIZE</span><span class="p">);</span>
			<span class="cm">/* Copy the mailbox extension data */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">pmbox</span><span class="o">-&gt;</span><span class="n">out_ext_byte_len</span> <span class="o">&amp;&amp;</span> <span class="n">pmbox</span><span class="o">-&gt;</span><span class="n">context2</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">lpfc_sli_pcimem_bcopy</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">mbox_ext</span><span class="p">,</span>
						      <span class="n">pmbox</span><span class="o">-&gt;</span><span class="n">context2</span><span class="p">,</span>
						      <span class="n">pmbox</span><span class="o">-&gt;</span><span class="n">out_ext_byte_len</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/* First copy command data */</span>
			<span class="n">lpfc_memcpy_from_slim</span><span class="p">(</span><span class="n">mb</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">MBslimaddr</span><span class="p">,</span>
							<span class="n">MAILBOX_CMD_SIZE</span><span class="p">);</span>
			<span class="cm">/* Copy the mailbox extension data */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">pmbox</span><span class="o">-&gt;</span><span class="n">out_ext_byte_len</span> <span class="o">&amp;&amp;</span> <span class="n">pmbox</span><span class="o">-&gt;</span><span class="n">context2</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">lpfc_memcpy_from_slim</span><span class="p">(</span><span class="n">pmbox</span><span class="o">-&gt;</span><span class="n">context2</span><span class="p">,</span>
					<span class="n">phba</span><span class="o">-&gt;</span><span class="n">MBslimaddr</span> <span class="o">+</span>
					<span class="n">MAILBOX_HBA_EXT_OFFSET</span><span class="p">,</span>
					<span class="n">pmbox</span><span class="o">-&gt;</span><span class="n">out_ext_byte_len</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="n">writel</span><span class="p">(</span><span class="n">HA_MBATT</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">HAregaddr</span><span class="p">);</span>
		<span class="n">readl</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">HAregaddr</span><span class="p">);</span> <span class="cm">/* flush */</span>

		<span class="n">psli</span><span class="o">-&gt;</span><span class="n">sli_flag</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">LPFC_SLI_MBOX_ACTIVE</span><span class="p">;</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">mb</span><span class="o">-&gt;</span><span class="n">mbxStatus</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">,</span> <span class="n">drvr_flag</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>

<span class="nl">out_not_finished:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">processing_queue</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pmbox</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">mb</span><span class="p">.</span><span class="n">mbxStatus</span> <span class="o">=</span> <span class="n">MBX_NOT_FINISHED</span><span class="p">;</span>
		<span class="n">lpfc_mbox_cmpl_put</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">pmbox</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">MBX_NOT_FINISHED</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_sli4_async_mbox_block - Block posting SLI4 asynchronous mailbox command</span>
<span class="cm"> * @phba: Pointer to HBA context object.</span>
<span class="cm"> *</span>
<span class="cm"> * The function blocks the posting of SLI4 asynchronous mailbox commands from</span>
<span class="cm"> * the driver internal pending mailbox queue. It will then try to wait out the</span>
<span class="cm"> * possible outstanding mailbox command before return.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns:</span>
<span class="cm"> * 	0 - the outstanding mailbox command completed; otherwise, the wait for</span>
<span class="cm"> * 	the outstanding mailbox command timed out.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">lpfc_sli4_async_mbox_block</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpfc_sli</span> <span class="o">*</span><span class="n">psli</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">timeout</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Mark the asynchronous mailbox command posting as blocked */</span>
	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>
	<span class="n">psli</span><span class="o">-&gt;</span><span class="n">sli_flag</span> <span class="o">|=</span> <span class="n">LPFC_SLI_ASYNC_MBX_BLK</span><span class="p">;</span>
	<span class="cm">/* Determine how long we might wait for the active mailbox</span>
<span class="cm">	 * command to be gracefully completed by firmware.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli</span><span class="p">.</span><span class="n">mbox_active</span><span class="p">)</span>
		<span class="n">timeout</span> <span class="o">=</span> <span class="n">msecs_to_jiffies</span><span class="p">(</span><span class="n">lpfc_mbox_tmo_val</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span>
						<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli</span><span class="p">.</span><span class="n">mbox_active</span><span class="p">)</span> <span class="o">*</span>
						<span class="mi">1000</span><span class="p">)</span> <span class="o">+</span> <span class="n">jiffies</span><span class="p">;</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>

	<span class="cm">/* Wait for the outstnading mailbox command to complete */</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli</span><span class="p">.</span><span class="n">mbox_active</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Check active mailbox complete status every 2ms */</span>
		<span class="n">msleep</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">time_after</span><span class="p">(</span><span class="n">jiffies</span><span class="p">,</span> <span class="n">timeout</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/* Timeout, marked the outstanding cmd not complete */</span>
			<span class="n">rc</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* Can not cleanly block async mailbox command, fails it */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>
		<span class="n">psli</span><span class="o">-&gt;</span><span class="n">sli_flag</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">LPFC_SLI_ASYNC_MBX_BLK</span><span class="p">;</span>
		<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_sli4_async_mbox_unblock - Block posting SLI4 async mailbox command</span>
<span class="cm"> * @phba: Pointer to HBA context object.</span>
<span class="cm"> *</span>
<span class="cm"> * The function unblocks and resume posting of SLI4 asynchronous mailbox</span>
<span class="cm"> * commands from the driver internal pending mailbox queue. It makes sure</span>
<span class="cm"> * that there is no outstanding mailbox command before resuming posting</span>
<span class="cm"> * asynchronous mailbox commands. If, for any reason, there is outstanding</span>
<span class="cm"> * mailbox command, it will try to wait it out before resuming asynchronous</span>
<span class="cm"> * mailbox command posting.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">lpfc_sli4_async_mbox_unblock</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpfc_sli</span> <span class="o">*</span><span class="n">psli</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli</span><span class="p">;</span>

	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">psli</span><span class="o">-&gt;</span><span class="n">sli_flag</span> <span class="o">&amp;</span> <span class="n">LPFC_SLI_ASYNC_MBX_BLK</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* Asynchronous mailbox posting is not blocked, do nothing */</span>
		<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Outstanding synchronous mailbox command is guaranteed to be done,</span>
<span class="cm">	 * successful or timeout, after timing-out the outstanding mailbox</span>
<span class="cm">	 * command shall always be removed, so just unblock posting async</span>
<span class="cm">	 * mailbox command and resume</span>
<span class="cm">	 */</span>
	<span class="n">psli</span><span class="o">-&gt;</span><span class="n">sli_flag</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">LPFC_SLI_ASYNC_MBX_BLK</span><span class="p">;</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>

	<span class="cm">/* wake up worker thread to post asynchronlous mailbox command */</span>
	<span class="n">lpfc_worker_wake_up</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_sli4_post_sync_mbox - Post an SLI4 mailbox to the bootstrap mailbox</span>
<span class="cm"> * @phba: Pointer to HBA context object.</span>
<span class="cm"> * @mboxq: Pointer to mailbox object.</span>
<span class="cm"> *</span>
<span class="cm"> * The function posts a mailbox to the port.  The mailbox is expected</span>
<span class="cm"> * to be comletely filled in and ready for the port to operate on it.</span>
<span class="cm"> * This routine executes a synchronous completion operation on the</span>
<span class="cm"> * mailbox by polling for its completion.</span>
<span class="cm"> *</span>
<span class="cm"> * The caller must not be holding any locks when calling this routine.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns:</span>
<span class="cm"> *	MBX_SUCCESS - mailbox posted successfully</span>
<span class="cm"> *	Any of the MBX error values.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">lpfc_sli4_post_sync_mbox</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">,</span> <span class="n">LPFC_MBOXQ_t</span> <span class="o">*</span><span class="n">mboxq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="n">MBX_SUCCESS</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">iflag</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">db_ready</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">mcqe_status</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">mbx_cmnd</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">timeout</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_sli</span> <span class="o">*</span><span class="n">psli</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_mqe</span> <span class="o">*</span><span class="n">mb</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">mboxq</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">mqe</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_bmbx_create</span> <span class="o">*</span><span class="n">mbox_rgn</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dma_address</span> <span class="o">*</span><span class="n">dma_address</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_register</span> <span class="n">bmbx_reg</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Only one mailbox can be active to the bootstrap mailbox region</span>
<span class="cm">	 * at a time and there is no queueing provided.</span>
<span class="cm">	 */</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">,</span> <span class="n">iflag</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">psli</span><span class="o">-&gt;</span><span class="n">sli_flag</span> <span class="o">&amp;</span> <span class="n">LPFC_SLI_MBOX_ACTIVE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">,</span> <span class="n">iflag</span><span class="p">);</span>
		<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_MBOX</span> <span class="o">|</span> <span class="n">LOG_SLI</span><span class="p">,</span>
				<span class="s">&quot;(%d):2532 Mailbox command x%x (x%x/x%x) &quot;</span>
				<span class="s">&quot;cannot issue Data: x%x x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">mboxq</span><span class="o">-&gt;</span><span class="n">vport</span> <span class="o">?</span> <span class="n">mboxq</span><span class="o">-&gt;</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">vpi</span> <span class="o">:</span> <span class="mi">0</span><span class="p">,</span>
				<span class="n">mboxq</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">mb</span><span class="p">.</span><span class="n">mbxCommand</span><span class="p">,</span>
				<span class="n">lpfc_sli_config_mbox_subsys_get</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">mboxq</span><span class="p">),</span>
				<span class="n">lpfc_sli_config_mbox_opcode_get</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">mboxq</span><span class="p">),</span>
				<span class="n">psli</span><span class="o">-&gt;</span><span class="n">sli_flag</span><span class="p">,</span> <span class="n">MBX_POLL</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">MBXERR_ERROR</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* The server grabs the token and owns it until release */</span>
	<span class="n">psli</span><span class="o">-&gt;</span><span class="n">sli_flag</span> <span class="o">|=</span> <span class="n">LPFC_SLI_MBOX_ACTIVE</span><span class="p">;</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli</span><span class="p">.</span><span class="n">mbox_active</span> <span class="o">=</span> <span class="n">mboxq</span><span class="p">;</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">,</span> <span class="n">iflag</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Initialize the bootstrap memory region to avoid stale data areas</span>
<span class="cm">	 * in the mailbox post.  Then copy the caller&#39;s mailbox contents to</span>
<span class="cm">	 * the bmbx mailbox region.</span>
<span class="cm">	 */</span>
	<span class="n">mbx_cmnd</span> <span class="o">=</span> <span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_mqe_command</span><span class="p">,</span> <span class="n">mb</span><span class="p">);</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">bmbx</span><span class="p">.</span><span class="n">avirt</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_bmbx_create</span><span class="p">));</span>
	<span class="n">lpfc_sli_pcimem_bcopy</span><span class="p">(</span><span class="n">mb</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">bmbx</span><span class="p">.</span><span class="n">avirt</span><span class="p">,</span>
			      <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_mqe</span><span class="p">));</span>

	<span class="cm">/* Post the high mailbox dma address to the port and wait for ready. */</span>
	<span class="n">dma_address</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">bmbx</span><span class="p">.</span><span class="n">dma_address</span><span class="p">;</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">dma_address</span><span class="o">-&gt;</span><span class="n">addr_hi</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">BMBXregaddr</span><span class="p">);</span>

	<span class="n">timeout</span> <span class="o">=</span> <span class="n">msecs_to_jiffies</span><span class="p">(</span><span class="n">lpfc_mbox_tmo_val</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">mboxq</span><span class="p">)</span>
				   <span class="o">*</span> <span class="mi">1000</span><span class="p">)</span> <span class="o">+</span> <span class="n">jiffies</span><span class="p">;</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="n">bmbx_reg</span><span class="p">.</span><span class="n">word0</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">BMBXregaddr</span><span class="p">);</span>
		<span class="n">db_ready</span> <span class="o">=</span> <span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_bmbx_rdy</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bmbx_reg</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">db_ready</span><span class="p">)</span>
			<span class="n">msleep</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">time_after</span><span class="p">(</span><span class="n">jiffies</span><span class="p">,</span> <span class="n">timeout</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">rc</span> <span class="o">=</span> <span class="n">MBXERR_ERROR</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">exit</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">db_ready</span><span class="p">);</span>

	<span class="cm">/* Post the low mailbox dma address to the port. */</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">dma_address</span><span class="o">-&gt;</span><span class="n">addr_lo</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">BMBXregaddr</span><span class="p">);</span>
	<span class="n">timeout</span> <span class="o">=</span> <span class="n">msecs_to_jiffies</span><span class="p">(</span><span class="n">lpfc_mbox_tmo_val</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">mboxq</span><span class="p">)</span>
				   <span class="o">*</span> <span class="mi">1000</span><span class="p">)</span> <span class="o">+</span> <span class="n">jiffies</span><span class="p">;</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="n">bmbx_reg</span><span class="p">.</span><span class="n">word0</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">BMBXregaddr</span><span class="p">);</span>
		<span class="n">db_ready</span> <span class="o">=</span> <span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_bmbx_rdy</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bmbx_reg</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">db_ready</span><span class="p">)</span>
			<span class="n">msleep</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">time_after</span><span class="p">(</span><span class="n">jiffies</span><span class="p">,</span> <span class="n">timeout</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">rc</span> <span class="o">=</span> <span class="n">MBXERR_ERROR</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">exit</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">db_ready</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Read the CQ to ensure the mailbox has completed.</span>
<span class="cm">	 * If so, update the mailbox status so that the upper layers</span>
<span class="cm">	 * can complete the request normally.</span>
<span class="cm">	 */</span>
	<span class="n">lpfc_sli_pcimem_bcopy</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">bmbx</span><span class="p">.</span><span class="n">avirt</span><span class="p">,</span> <span class="n">mb</span><span class="p">,</span>
			      <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_mqe</span><span class="p">));</span>
	<span class="n">mbox_rgn</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_bmbx_create</span> <span class="o">*</span><span class="p">)</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">bmbx</span><span class="p">.</span><span class="n">avirt</span><span class="p">;</span>
	<span class="n">lpfc_sli_pcimem_bcopy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mbox_rgn</span><span class="o">-&gt;</span><span class="n">mcqe</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mboxq</span><span class="o">-&gt;</span><span class="n">mcqe</span><span class="p">,</span>
			      <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_mcqe</span><span class="p">));</span>
	<span class="n">mcqe_status</span> <span class="o">=</span> <span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_mcqe_status</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mbox_rgn</span><span class="o">-&gt;</span><span class="n">mcqe</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * When the CQE status indicates a failure and the mailbox status</span>
<span class="cm">	 * indicates success then copy the CQE status into the mailbox status</span>
<span class="cm">	 * (and prefix it with x4000).</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mcqe_status</span> <span class="o">!=</span> <span class="n">MB_CQE_STATUS_SUCCESS</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_mqe_status</span><span class="p">,</span> <span class="n">mb</span><span class="p">)</span> <span class="o">==</span> <span class="n">MBX_SUCCESS</span><span class="p">)</span>
			<span class="n">bf_set</span><span class="p">(</span><span class="n">lpfc_mqe_status</span><span class="p">,</span> <span class="n">mb</span><span class="p">,</span>
			       <span class="p">(</span><span class="n">LPFC_MBX_ERROR_RANGE</span> <span class="o">|</span> <span class="n">mcqe_status</span><span class="p">));</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">MBXERR_ERROR</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">lpfc_sli4_swap_str</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">mboxq</span><span class="p">);</span>

	<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_INFO</span><span class="p">,</span> <span class="n">LOG_MBOX</span> <span class="o">|</span> <span class="n">LOG_SLI</span><span class="p">,</span>
			<span class="s">&quot;(%d):0356 Mailbox cmd x%x (x%x/x%x) Status x%x &quot;</span>
			<span class="s">&quot;Data: x%x x%x x%x x%x x%x x%x x%x x%x x%x x%x x%x&quot;</span>
			<span class="s">&quot; x%x x%x CQ: x%x x%x x%x x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">mboxq</span><span class="o">-&gt;</span><span class="n">vport</span> <span class="o">?</span> <span class="n">mboxq</span><span class="o">-&gt;</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">vpi</span> <span class="o">:</span> <span class="mi">0</span><span class="p">,</span> <span class="n">mbx_cmnd</span><span class="p">,</span>
			<span class="n">lpfc_sli_config_mbox_subsys_get</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">mboxq</span><span class="p">),</span>
			<span class="n">lpfc_sli_config_mbox_opcode_get</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">mboxq</span><span class="p">),</span>
			<span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_mqe_status</span><span class="p">,</span> <span class="n">mb</span><span class="p">),</span>
			<span class="n">mb</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">mb_words</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">mb</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">mb_words</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
			<span class="n">mb</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">mb_words</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">mb</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">mb_words</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span>
			<span class="n">mb</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">mb_words</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span> <span class="n">mb</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">mb_words</span><span class="p">[</span><span class="mi">5</span><span class="p">],</span>
			<span class="n">mb</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">mb_words</span><span class="p">[</span><span class="mi">6</span><span class="p">],</span> <span class="n">mb</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">mb_words</span><span class="p">[</span><span class="mi">7</span><span class="p">],</span>
			<span class="n">mb</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">mb_words</span><span class="p">[</span><span class="mi">8</span><span class="p">],</span> <span class="n">mb</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">mb_words</span><span class="p">[</span><span class="mi">9</span><span class="p">],</span>
			<span class="n">mb</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">mb_words</span><span class="p">[</span><span class="mi">10</span><span class="p">],</span> <span class="n">mb</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">mb_words</span><span class="p">[</span><span class="mi">11</span><span class="p">],</span>
			<span class="n">mb</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">mb_words</span><span class="p">[</span><span class="mi">12</span><span class="p">],</span> <span class="n">mboxq</span><span class="o">-&gt;</span><span class="n">mcqe</span><span class="p">.</span><span class="n">word0</span><span class="p">,</span>
			<span class="n">mboxq</span><span class="o">-&gt;</span><span class="n">mcqe</span><span class="p">.</span><span class="n">mcqe_tag0</span><span class="p">,</span> 	<span class="n">mboxq</span><span class="o">-&gt;</span><span class="n">mcqe</span><span class="p">.</span><span class="n">mcqe_tag1</span><span class="p">,</span>
			<span class="n">mboxq</span><span class="o">-&gt;</span><span class="n">mcqe</span><span class="p">.</span><span class="n">trailer</span><span class="p">);</span>
<span class="nl">exit:</span>
	<span class="cm">/* We are holding the token, no needed for lock when release */</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">,</span> <span class="n">iflag</span><span class="p">);</span>
	<span class="n">psli</span><span class="o">-&gt;</span><span class="n">sli_flag</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">LPFC_SLI_MBOX_ACTIVE</span><span class="p">;</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli</span><span class="p">.</span><span class="n">mbox_active</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">,</span> <span class="n">iflag</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_sli_issue_mbox_s4 - Issue an SLI4 mailbox command to firmware</span>
<span class="cm"> * @phba: Pointer to HBA context object.</span>
<span class="cm"> * @pmbox: Pointer to mailbox object.</span>
<span class="cm"> * @flag: Flag indicating how the mailbox need to be processed.</span>
<span class="cm"> *</span>
<span class="cm"> * This function is called by discovery code and HBA management code to submit</span>
<span class="cm"> * a mailbox command to firmware with SLI-4 interface spec.</span>
<span class="cm"> *</span>
<span class="cm"> * Return codes the caller owns the mailbox command after the return of the</span>
<span class="cm"> * function.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">lpfc_sli_issue_mbox_s4</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">,</span> <span class="n">LPFC_MBOXQ_t</span> <span class="o">*</span><span class="n">mboxq</span><span class="p">,</span>
		       <span class="kt">uint32_t</span> <span class="n">flag</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpfc_sli</span> <span class="o">*</span><span class="n">psli</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">iflags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="cm">/* dump from issue mailbox command if setup */</span>
	<span class="n">lpfc_idiag_mbxacc_dump_issue_mbox</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mboxq</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">mb</span><span class="p">);</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">lpfc_mbox_dev_check</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">rc</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_MBOX</span> <span class="o">|</span> <span class="n">LOG_SLI</span><span class="p">,</span>
				<span class="s">&quot;(%d):2544 Mailbox command x%x (x%x/x%x) &quot;</span>
				<span class="s">&quot;cannot issue Data: x%x x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">mboxq</span><span class="o">-&gt;</span><span class="n">vport</span> <span class="o">?</span> <span class="n">mboxq</span><span class="o">-&gt;</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">vpi</span> <span class="o">:</span> <span class="mi">0</span><span class="p">,</span>
				<span class="n">mboxq</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">mb</span><span class="p">.</span><span class="n">mbxCommand</span><span class="p">,</span>
				<span class="n">lpfc_sli_config_mbox_subsys_get</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">mboxq</span><span class="p">),</span>
				<span class="n">lpfc_sli_config_mbox_opcode_get</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">mboxq</span><span class="p">),</span>
				<span class="n">psli</span><span class="o">-&gt;</span><span class="n">sli_flag</span><span class="p">,</span> <span class="n">flag</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_not_finished</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Detect polling mode and jump to a handler */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">intr_enable</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">flag</span> <span class="o">==</span> <span class="n">MBX_POLL</span><span class="p">)</span>
			<span class="n">rc</span> <span class="o">=</span> <span class="n">lpfc_sli4_post_sync_mbox</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">mboxq</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">!=</span> <span class="n">MBX_SUCCESS</span><span class="p">)</span>
			<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_WARNING</span><span class="p">,</span> <span class="n">LOG_MBOX</span> <span class="o">|</span> <span class="n">LOG_SLI</span><span class="p">,</span>
					<span class="s">&quot;(%d):2541 Mailbox command x%x &quot;</span>
					<span class="s">&quot;(x%x/x%x) failure: &quot;</span>
					<span class="s">&quot;mqe_sta: x%x mcqe_sta: x%x/x%x &quot;</span>
					<span class="s">&quot;Data: x%x x%x</span><span class="se">\n</span><span class="s">,&quot;</span><span class="p">,</span>
					<span class="n">mboxq</span><span class="o">-&gt;</span><span class="n">vport</span> <span class="o">?</span> <span class="n">mboxq</span><span class="o">-&gt;</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">vpi</span> <span class="o">:</span> <span class="mi">0</span><span class="p">,</span>
					<span class="n">mboxq</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">mb</span><span class="p">.</span><span class="n">mbxCommand</span><span class="p">,</span>
					<span class="n">lpfc_sli_config_mbox_subsys_get</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span>
									<span class="n">mboxq</span><span class="p">),</span>
					<span class="n">lpfc_sli_config_mbox_opcode_get</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span>
									<span class="n">mboxq</span><span class="p">),</span>
					<span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_mqe_status</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mboxq</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">mqe</span><span class="p">),</span>
					<span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_mcqe_status</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mboxq</span><span class="o">-&gt;</span><span class="n">mcqe</span><span class="p">),</span>
					<span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_mcqe_ext_status</span><span class="p">,</span>
					       <span class="o">&amp;</span><span class="n">mboxq</span><span class="o">-&gt;</span><span class="n">mcqe</span><span class="p">),</span>
					<span class="n">psli</span><span class="o">-&gt;</span><span class="n">sli_flag</span><span class="p">,</span> <span class="n">flag</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">flag</span> <span class="o">==</span> <span class="n">MBX_POLL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_WARNING</span><span class="p">,</span> <span class="n">LOG_MBOX</span> <span class="o">|</span> <span class="n">LOG_SLI</span><span class="p">,</span>
				<span class="s">&quot;(%d):2542 Try to issue mailbox command &quot;</span>
				<span class="s">&quot;x%x (x%x/x%x) synchronously ahead of async&quot;</span>
				<span class="s">&quot;mailbox command queue: x%x x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">mboxq</span><span class="o">-&gt;</span><span class="n">vport</span> <span class="o">?</span> <span class="n">mboxq</span><span class="o">-&gt;</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">vpi</span> <span class="o">:</span> <span class="mi">0</span><span class="p">,</span>
				<span class="n">mboxq</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">mb</span><span class="p">.</span><span class="n">mbxCommand</span><span class="p">,</span>
				<span class="n">lpfc_sli_config_mbox_subsys_get</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">mboxq</span><span class="p">),</span>
				<span class="n">lpfc_sli_config_mbox_opcode_get</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">mboxq</span><span class="p">),</span>
				<span class="n">psli</span><span class="o">-&gt;</span><span class="n">sli_flag</span><span class="p">,</span> <span class="n">flag</span><span class="p">);</span>
		<span class="cm">/* Try to block the asynchronous mailbox posting */</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">lpfc_sli4_async_mbox_block</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Successfully blocked, now issue sync mbox cmd */</span>
			<span class="n">rc</span> <span class="o">=</span> <span class="n">lpfc_sli4_post_sync_mbox</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">mboxq</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">!=</span> <span class="n">MBX_SUCCESS</span><span class="p">)</span>
				<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_WARNING</span><span class="p">,</span>
					<span class="n">LOG_MBOX</span> <span class="o">|</span> <span class="n">LOG_SLI</span><span class="p">,</span>
					<span class="s">&quot;(%d):2597 Sync Mailbox command &quot;</span>
					<span class="s">&quot;x%x (x%x/x%x) failure: &quot;</span>
					<span class="s">&quot;mqe_sta: x%x mcqe_sta: x%x/x%x &quot;</span>
					<span class="s">&quot;Data: x%x x%x</span><span class="se">\n</span><span class="s">,&quot;</span><span class="p">,</span>
					<span class="n">mboxq</span><span class="o">-&gt;</span><span class="n">vport</span> <span class="o">?</span> <span class="n">mboxq</span><span class="o">-&gt;</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">vpi</span> <span class="o">:</span> <span class="mi">0</span><span class="p">,</span>
					<span class="n">mboxq</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">mb</span><span class="p">.</span><span class="n">mbxCommand</span><span class="p">,</span>
					<span class="n">lpfc_sli_config_mbox_subsys_get</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span>
									<span class="n">mboxq</span><span class="p">),</span>
					<span class="n">lpfc_sli_config_mbox_opcode_get</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span>
									<span class="n">mboxq</span><span class="p">),</span>
					<span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_mqe_status</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mboxq</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">mqe</span><span class="p">),</span>
					<span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_mcqe_status</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mboxq</span><span class="o">-&gt;</span><span class="n">mcqe</span><span class="p">),</span>
					<span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_mcqe_ext_status</span><span class="p">,</span>
					       <span class="o">&amp;</span><span class="n">mboxq</span><span class="o">-&gt;</span><span class="n">mcqe</span><span class="p">),</span>
					<span class="n">psli</span><span class="o">-&gt;</span><span class="n">sli_flag</span><span class="p">,</span> <span class="n">flag</span><span class="p">);</span>
			<span class="cm">/* Unblock the async mailbox posting afterward */</span>
			<span class="n">lpfc_sli4_async_mbox_unblock</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Now, interrupt mode asynchrous mailbox command */</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">lpfc_mbox_cmd_check</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">mboxq</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_MBOX</span> <span class="o">|</span> <span class="n">LOG_SLI</span><span class="p">,</span>
				<span class="s">&quot;(%d):2543 Mailbox command x%x (x%x/x%x) &quot;</span>
				<span class="s">&quot;cannot issue Data: x%x x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">mboxq</span><span class="o">-&gt;</span><span class="n">vport</span> <span class="o">?</span> <span class="n">mboxq</span><span class="o">-&gt;</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">vpi</span> <span class="o">:</span> <span class="mi">0</span><span class="p">,</span>
				<span class="n">mboxq</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">mb</span><span class="p">.</span><span class="n">mbxCommand</span><span class="p">,</span>
				<span class="n">lpfc_sli_config_mbox_subsys_get</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">mboxq</span><span class="p">),</span>
				<span class="n">lpfc_sli_config_mbox_opcode_get</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">mboxq</span><span class="p">),</span>
				<span class="n">psli</span><span class="o">-&gt;</span><span class="n">sli_flag</span><span class="p">,</span> <span class="n">flag</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_not_finished</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Put the mailbox command to the driver internal FIFO */</span>
	<span class="n">psli</span><span class="o">-&gt;</span><span class="n">slistat</span><span class="p">.</span><span class="n">mbox_busy</span><span class="o">++</span><span class="p">;</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">,</span> <span class="n">iflags</span><span class="p">);</span>
	<span class="n">lpfc_mbox_put</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">mboxq</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">,</span> <span class="n">iflags</span><span class="p">);</span>
	<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_INFO</span><span class="p">,</span> <span class="n">LOG_MBOX</span> <span class="o">|</span> <span class="n">LOG_SLI</span><span class="p">,</span>
			<span class="s">&quot;(%d):0354 Mbox cmd issue - Enqueue Data: &quot;</span>
			<span class="s">&quot;x%x (x%x/x%x) x%x x%x x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">mboxq</span><span class="o">-&gt;</span><span class="n">vport</span> <span class="o">?</span> <span class="n">mboxq</span><span class="o">-&gt;</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">vpi</span> <span class="o">:</span> <span class="mh">0xffffff</span><span class="p">,</span>
			<span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_mqe_command</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mboxq</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">mqe</span><span class="p">),</span>
			<span class="n">lpfc_sli_config_mbox_subsys_get</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">mboxq</span><span class="p">),</span>
			<span class="n">lpfc_sli_config_mbox_opcode_get</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">mboxq</span><span class="p">),</span>
			<span class="n">phba</span><span class="o">-&gt;</span><span class="n">pport</span><span class="o">-&gt;</span><span class="n">port_state</span><span class="p">,</span>
			<span class="n">psli</span><span class="o">-&gt;</span><span class="n">sli_flag</span><span class="p">,</span> <span class="n">MBX_NOWAIT</span><span class="p">);</span>
	<span class="cm">/* Wake up worker thread to transport mailbox command from head */</span>
	<span class="n">lpfc_worker_wake_up</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">MBX_BUSY</span><span class="p">;</span>

<span class="nl">out_not_finished:</span>
	<span class="k">return</span> <span class="n">MBX_NOT_FINISHED</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_sli4_post_async_mbox - Post an SLI4 mailbox command to device</span>
<span class="cm"> * @phba: Pointer to HBA context object.</span>
<span class="cm"> *</span>
<span class="cm"> * This function is called by worker thread to send a mailbox command to</span>
<span class="cm"> * SLI4 HBA firmware.</span>
<span class="cm"> *</span>
<span class="cm"> **/</span>
<span class="kt">int</span>
<span class="nf">lpfc_sli4_post_async_mbox</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpfc_sli</span> <span class="o">*</span><span class="n">psli</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli</span><span class="p">;</span>
	<span class="n">LPFC_MBOXQ_t</span> <span class="o">*</span><span class="n">mboxq</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="n">MBX_SUCCESS</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">iflags</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_mqe</span> <span class="o">*</span><span class="n">mqe</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">mbx_cmnd</span><span class="p">;</span>

	<span class="cm">/* Check interrupt mode before post async mailbox command */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">intr_enable</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">MBX_NOT_FINISHED</span><span class="p">;</span>

	<span class="cm">/* Check for mailbox command service token */</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">,</span> <span class="n">iflags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">psli</span><span class="o">-&gt;</span><span class="n">sli_flag</span> <span class="o">&amp;</span> <span class="n">LPFC_SLI_ASYNC_MBX_BLK</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">,</span> <span class="n">iflags</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">MBX_NOT_FINISHED</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">psli</span><span class="o">-&gt;</span><span class="n">sli_flag</span> <span class="o">&amp;</span> <span class="n">LPFC_SLI_MBOX_ACTIVE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">,</span> <span class="n">iflags</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">MBX_NOT_FINISHED</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli</span><span class="p">.</span><span class="n">mbox_active</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">,</span> <span class="n">iflags</span><span class="p">);</span>
		<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_MBOX</span> <span class="o">|</span> <span class="n">LOG_SLI</span><span class="p">,</span>
				<span class="s">&quot;0384 There is pending active mailbox cmd</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">MBX_NOT_FINISHED</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* Take the mailbox command service token */</span>
	<span class="n">psli</span><span class="o">-&gt;</span><span class="n">sli_flag</span> <span class="o">|=</span> <span class="n">LPFC_SLI_MBOX_ACTIVE</span><span class="p">;</span>

	<span class="cm">/* Get the next mailbox command from head of queue */</span>
	<span class="n">mboxq</span> <span class="o">=</span> <span class="n">lpfc_mbox_get</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>

	<span class="cm">/* If no more mailbox command waiting for post, we&#39;re done */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mboxq</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">psli</span><span class="o">-&gt;</span><span class="n">sli_flag</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">LPFC_SLI_MBOX_ACTIVE</span><span class="p">;</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">,</span> <span class="n">iflags</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">MBX_SUCCESS</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli</span><span class="p">.</span><span class="n">mbox_active</span> <span class="o">=</span> <span class="n">mboxq</span><span class="p">;</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">,</span> <span class="n">iflags</span><span class="p">);</span>

	<span class="cm">/* Check device readiness for posting mailbox command */</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">lpfc_mbox_dev_check</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">rc</span><span class="p">))</span>
		<span class="cm">/* Driver clean routine will clean up pending mailbox */</span>
		<span class="k">goto</span> <span class="n">out_not_finished</span><span class="p">;</span>

	<span class="cm">/* Prepare the mbox command to be posted */</span>
	<span class="n">mqe</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">mboxq</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">mqe</span><span class="p">;</span>
	<span class="n">mbx_cmnd</span> <span class="o">=</span> <span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_mqe_command</span><span class="p">,</span> <span class="n">mqe</span><span class="p">);</span>

	<span class="cm">/* Start timer for the mbox_tmo and log some mailbox post messages */</span>
	<span class="n">mod_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">psli</span><span class="o">-&gt;</span><span class="n">mbox_tmo</span><span class="p">,</span> <span class="p">(</span><span class="n">jiffies</span> <span class="o">+</span>
		  <span class="p">(</span><span class="n">HZ</span> <span class="o">*</span> <span class="n">lpfc_mbox_tmo_val</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">mboxq</span><span class="p">))));</span>

	<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_INFO</span><span class="p">,</span> <span class="n">LOG_MBOX</span> <span class="o">|</span> <span class="n">LOG_SLI</span><span class="p">,</span>
			<span class="s">&quot;(%d):0355 Mailbox cmd x%x (x%x/x%x) issue Data: &quot;</span>
			<span class="s">&quot;x%x x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">mboxq</span><span class="o">-&gt;</span><span class="n">vport</span> <span class="o">?</span> <span class="n">mboxq</span><span class="o">-&gt;</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">vpi</span> <span class="o">:</span> <span class="mi">0</span><span class="p">,</span> <span class="n">mbx_cmnd</span><span class="p">,</span>
			<span class="n">lpfc_sli_config_mbox_subsys_get</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">mboxq</span><span class="p">),</span>
			<span class="n">lpfc_sli_config_mbox_opcode_get</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">mboxq</span><span class="p">),</span>
			<span class="n">phba</span><span class="o">-&gt;</span><span class="n">pport</span><span class="o">-&gt;</span><span class="n">port_state</span><span class="p">,</span> <span class="n">psli</span><span class="o">-&gt;</span><span class="n">sli_flag</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">mbx_cmnd</span> <span class="o">!=</span> <span class="n">MBX_HEARTBEAT</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">mboxq</span><span class="o">-&gt;</span><span class="n">vport</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">lpfc_debugfs_disc_trc</span><span class="p">(</span><span class="n">mboxq</span><span class="o">-&gt;</span><span class="n">vport</span><span class="p">,</span>
				<span class="n">LPFC_DISC_TRC_MBOX_VPORT</span><span class="p">,</span>
				<span class="s">&quot;MBOX Send vport: cmd:x%x mb:x%x x%x&quot;</span><span class="p">,</span>
				<span class="n">mbx_cmnd</span><span class="p">,</span> <span class="n">mqe</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">mb_words</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
				<span class="n">mqe</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">mb_words</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">lpfc_debugfs_disc_trc</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">pport</span><span class="p">,</span>
				<span class="n">LPFC_DISC_TRC_MBOX</span><span class="p">,</span>
				<span class="s">&quot;MBOX Send: cmd:x%x mb:x%x x%x&quot;</span><span class="p">,</span>
				<span class="n">mbx_cmnd</span><span class="p">,</span> <span class="n">mqe</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">mb_words</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
				<span class="n">mqe</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">mb_words</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">psli</span><span class="o">-&gt;</span><span class="n">slistat</span><span class="p">.</span><span class="n">mbox_cmd</span><span class="o">++</span><span class="p">;</span>

	<span class="cm">/* Post the mailbox command to the port */</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">lpfc_sli4_mq_put</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">mbx_wq</span><span class="p">,</span> <span class="n">mqe</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">!=</span> <span class="n">MBX_SUCCESS</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_MBOX</span> <span class="o">|</span> <span class="n">LOG_SLI</span><span class="p">,</span>
				<span class="s">&quot;(%d):2533 Mailbox command x%x (x%x/x%x) &quot;</span>
				<span class="s">&quot;cannot issue Data: x%x x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">mboxq</span><span class="o">-&gt;</span><span class="n">vport</span> <span class="o">?</span> <span class="n">mboxq</span><span class="o">-&gt;</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">vpi</span> <span class="o">:</span> <span class="mi">0</span><span class="p">,</span>
				<span class="n">mboxq</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">mb</span><span class="p">.</span><span class="n">mbxCommand</span><span class="p">,</span>
				<span class="n">lpfc_sli_config_mbox_subsys_get</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">mboxq</span><span class="p">),</span>
				<span class="n">lpfc_sli_config_mbox_opcode_get</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">mboxq</span><span class="p">),</span>
				<span class="n">psli</span><span class="o">-&gt;</span><span class="n">sli_flag</span><span class="p">,</span> <span class="n">MBX_NOWAIT</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_not_finished</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>

<span class="nl">out_not_finished:</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">,</span> <span class="n">iflags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli</span><span class="p">.</span><span class="n">mbox_active</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mboxq</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">mb</span><span class="p">.</span><span class="n">mbxStatus</span> <span class="o">=</span> <span class="n">MBX_NOT_FINISHED</span><span class="p">;</span>
		<span class="n">__lpfc_mbox_cmpl_put</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">mboxq</span><span class="p">);</span>
		<span class="cm">/* Release the token */</span>
		<span class="n">psli</span><span class="o">-&gt;</span><span class="n">sli_flag</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">LPFC_SLI_MBOX_ACTIVE</span><span class="p">;</span>
		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli</span><span class="p">.</span><span class="n">mbox_active</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">,</span> <span class="n">iflags</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">MBX_NOT_FINISHED</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_sli_issue_mbox - Wrapper func for issuing mailbox command</span>
<span class="cm"> * @phba: Pointer to HBA context object.</span>
<span class="cm"> * @pmbox: Pointer to mailbox object.</span>
<span class="cm"> * @flag: Flag indicating how the mailbox need to be processed.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine wraps the actual SLI3 or SLI4 mailbox issuing routine from</span>
<span class="cm"> * the API jump table function pointer from the lpfc_hba struct.</span>
<span class="cm"> *</span>
<span class="cm"> * Return codes the caller owns the mailbox command after the return of the</span>
<span class="cm"> * function.</span>
<span class="cm"> **/</span>
<span class="kt">int</span>
<span class="nf">lpfc_sli_issue_mbox</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">,</span> <span class="n">LPFC_MBOXQ_t</span> <span class="o">*</span><span class="n">pmbox</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">flag</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">lpfc_sli_issue_mbox</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">pmbox</span><span class="p">,</span> <span class="n">flag</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_mbox_api_table_setup - Set up mbox api function jump table</span>
<span class="cm"> * @phba: The hba struct for which this call is being executed.</span>
<span class="cm"> * @dev_grp: The HBA PCI-Device group number.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine sets up the mbox interface API function jump table in @phba</span>
<span class="cm"> * struct.</span>
<span class="cm"> * Returns: 0 - success, -ENODEV - failure.</span>
<span class="cm"> **/</span>
<span class="kt">int</span>
<span class="nf">lpfc_mbox_api_table_setup</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="n">dev_grp</span><span class="p">)</span>
<span class="p">{</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">dev_grp</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">LPFC_PCI_DEV_LP</span>:
		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">lpfc_sli_issue_mbox</span> <span class="o">=</span> <span class="n">lpfc_sli_issue_mbox_s3</span><span class="p">;</span>
		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">lpfc_sli_handle_slow_ring_event</span> <span class="o">=</span>
				<span class="n">lpfc_sli_handle_slow_ring_event_s3</span><span class="p">;</span>
		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">lpfc_sli_hbq_to_firmware</span> <span class="o">=</span> <span class="n">lpfc_sli_hbq_to_firmware_s3</span><span class="p">;</span>
		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">lpfc_sli_brdrestart</span> <span class="o">=</span> <span class="n">lpfc_sli_brdrestart_s3</span><span class="p">;</span>
		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">lpfc_sli_brdready</span> <span class="o">=</span> <span class="n">lpfc_sli_brdready_s3</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">LPFC_PCI_DEV_OC</span>:
		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">lpfc_sli_issue_mbox</span> <span class="o">=</span> <span class="n">lpfc_sli_issue_mbox_s4</span><span class="p">;</span>
		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">lpfc_sli_handle_slow_ring_event</span> <span class="o">=</span>
				<span class="n">lpfc_sli_handle_slow_ring_event_s4</span><span class="p">;</span>
		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">lpfc_sli_hbq_to_firmware</span> <span class="o">=</span> <span class="n">lpfc_sli_hbq_to_firmware_s4</span><span class="p">;</span>
		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">lpfc_sli_brdrestart</span> <span class="o">=</span> <span class="n">lpfc_sli_brdrestart_s4</span><span class="p">;</span>
		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">lpfc_sli_brdready</span> <span class="o">=</span> <span class="n">lpfc_sli_brdready_s4</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_INIT</span><span class="p">,</span>
				<span class="s">&quot;1420 Invalid HBA PCI-device group: 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">dev_grp</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * __lpfc_sli_ringtx_put - Add an iocb to the txq</span>
<span class="cm"> * @phba: Pointer to HBA context object.</span>
<span class="cm"> * @pring: Pointer to driver SLI ring object.</span>
<span class="cm"> * @piocb: Pointer to address of newly added command iocb.</span>
<span class="cm"> *</span>
<span class="cm"> * This function is called with hbalock held to add a command</span>
<span class="cm"> * iocb to the txq when SLI layer cannot submit the command iocb</span>
<span class="cm"> * to the ring.</span>
<span class="cm"> **/</span>
<span class="kt">void</span>
<span class="nf">__lpfc_sli_ringtx_put</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">,</span> <span class="k">struct</span> <span class="n">lpfc_sli_ring</span> <span class="o">*</span><span class="n">pring</span><span class="p">,</span>
		    <span class="k">struct</span> <span class="n">lpfc_iocbq</span> <span class="o">*</span><span class="n">piocb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Insert the caller&#39;s iocb in the txq tail for later processing. */</span>
	<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">piocb</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pring</span><span class="o">-&gt;</span><span class="n">txq</span><span class="p">);</span>
	<span class="n">pring</span><span class="o">-&gt;</span><span class="n">txq_cnt</span><span class="o">++</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_sli_next_iocb - Get the next iocb in the txq</span>
<span class="cm"> * @phba: Pointer to HBA context object.</span>
<span class="cm"> * @pring: Pointer to driver SLI ring object.</span>
<span class="cm"> * @piocb: Pointer to address of newly added command iocb.</span>
<span class="cm"> *</span>
<span class="cm"> * This function is called with hbalock held before a new</span>
<span class="cm"> * iocb is submitted to the firmware. This function checks</span>
<span class="cm"> * txq to flush the iocbs in txq to Firmware before</span>
<span class="cm"> * submitting new iocbs to the Firmware.</span>
<span class="cm"> * If there are iocbs in the txq which need to be submitted</span>
<span class="cm"> * to firmware, lpfc_sli_next_iocb returns the first element</span>
<span class="cm"> * of the txq after dequeuing it from txq.</span>
<span class="cm"> * If there is no iocb in the txq then the function will return</span>
<span class="cm"> * *piocb and *piocb is set to NULL. Caller needs to check</span>
<span class="cm"> * *piocb to find if there are more commands in the txq.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">lpfc_iocbq</span> <span class="o">*</span>
<span class="nf">lpfc_sli_next_iocb</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">,</span> <span class="k">struct</span> <span class="n">lpfc_sli_ring</span> <span class="o">*</span><span class="n">pring</span><span class="p">,</span>
		   <span class="k">struct</span> <span class="n">lpfc_iocbq</span> <span class="o">**</span><span class="n">piocb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpfc_iocbq</span> <span class="o">*</span> <span class="n">nextiocb</span><span class="p">;</span>

	<span class="n">nextiocb</span> <span class="o">=</span> <span class="n">lpfc_sli_ringtx_get</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">pring</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">nextiocb</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">nextiocb</span> <span class="o">=</span> <span class="o">*</span><span class="n">piocb</span><span class="p">;</span>
		<span class="o">*</span><span class="n">piocb</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">nextiocb</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * __lpfc_sli_issue_iocb_s3 - SLI3 device lockless ver of lpfc_sli_issue_iocb</span>
<span class="cm"> * @phba: Pointer to HBA context object.</span>
<span class="cm"> * @ring_number: SLI ring number to issue iocb on.</span>
<span class="cm"> * @piocb: Pointer to command iocb.</span>
<span class="cm"> * @flag: Flag indicating if this command can be put into txq.</span>
<span class="cm"> *</span>
<span class="cm"> * __lpfc_sli_issue_iocb_s3 is used by other functions in the driver to issue</span>
<span class="cm"> * an iocb command to an HBA with SLI-3 interface spec. If the PCI slot is</span>
<span class="cm"> * recovering from error state, if HBA is resetting or if LPFC_STOP_IOCB_EVENT</span>
<span class="cm"> * flag is turned on, the function returns IOCB_ERROR. When the link is down,</span>
<span class="cm"> * this function allows only iocbs for posting buffers. This function finds</span>
<span class="cm"> * next available slot in the command ring and posts the command to the</span>
<span class="cm"> * available slot and writes the port attention register to request HBA start</span>
<span class="cm"> * processing new iocb. If there is no slot available in the ring and</span>
<span class="cm"> * flag &amp; SLI_IOCB_RET_IOCB is set, the new iocb is added to the txq, otherwise</span>
<span class="cm"> * the function returns IOCB_BUSY.</span>
<span class="cm"> *</span>
<span class="cm"> * This function is called with hbalock held. The function will return success</span>
<span class="cm"> * after it successfully submit the iocb to firmware or after adding to the</span>
<span class="cm"> * txq.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">__lpfc_sli_issue_iocb_s3</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">ring_number</span><span class="p">,</span>
		    <span class="k">struct</span> <span class="n">lpfc_iocbq</span> <span class="o">*</span><span class="n">piocb</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">flag</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpfc_iocbq</span> <span class="o">*</span><span class="n">nextiocb</span><span class="p">;</span>
	<span class="n">IOCB_t</span> <span class="o">*</span><span class="n">iocb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_sli_ring</span> <span class="o">*</span><span class="n">pring</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli</span><span class="p">.</span><span class="n">ring</span><span class="p">[</span><span class="n">ring_number</span><span class="p">];</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">piocb</span><span class="o">-&gt;</span><span class="n">iocb_cmpl</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="o">!</span><span class="n">piocb</span><span class="o">-&gt;</span><span class="n">vport</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	   <span class="p">(</span><span class="n">piocb</span><span class="o">-&gt;</span><span class="n">iocb</span><span class="p">.</span><span class="n">ulpCommand</span> <span class="o">!=</span> <span class="n">CMD_ABORT_XRI_CN</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	   <span class="p">(</span><span class="n">piocb</span><span class="o">-&gt;</span><span class="n">iocb</span><span class="p">.</span><span class="n">ulpCommand</span> <span class="o">!=</span> <span class="n">CMD_CLOSE_XRI_CN</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span>
				<span class="n">LOG_SLI</span> <span class="o">|</span> <span class="n">LOG_VPORT</span><span class="p">,</span>
				<span class="s">&quot;1807 IOCB x%x failed. No vport</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">piocb</span><span class="o">-&gt;</span><span class="n">iocb</span><span class="p">.</span><span class="n">ulpCommand</span><span class="p">);</span>
		<span class="n">dump_stack</span><span class="p">();</span>
		<span class="k">return</span> <span class="n">IOCB_ERROR</span><span class="p">;</span>
	<span class="p">}</span>


	<span class="cm">/* If the PCI channel is in offline state, do not post iocbs. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">pci_channel_offline</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">pcidev</span><span class="p">)))</span>
		<span class="k">return</span> <span class="n">IOCB_ERROR</span><span class="p">;</span>

	<span class="cm">/* If HBA has a deferred error attention, fail the iocb. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hba_flag</span> <span class="o">&amp;</span> <span class="n">DEFER_ERATT</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">IOCB_ERROR</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * We should never get an IOCB if we are in a &lt; LINK_DOWN state</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">link_state</span> <span class="o">&lt;</span> <span class="n">LPFC_LINK_DOWN</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">IOCB_ERROR</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Check to see if we are blocking IOCB processing because of a</span>
<span class="cm">	 * outstanding event.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">pring</span><span class="o">-&gt;</span><span class="n">flag</span> <span class="o">&amp;</span> <span class="n">LPFC_STOP_IOCB_EVENT</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">iocb_busy</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">link_state</span> <span class="o">==</span> <span class="n">LPFC_LINK_DOWN</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Only CREATE_XRI, CLOSE_XRI, and QUE_RING_BUF</span>
<span class="cm">		 * can be issued if the link is not up.</span>
<span class="cm">		 */</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">piocb</span><span class="o">-&gt;</span><span class="n">iocb</span><span class="p">.</span><span class="n">ulpCommand</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">CMD_GEN_REQUEST64_CR</span>:
		<span class="k">case</span> <span class="n">CMD_GEN_REQUEST64_CX</span>:
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli</span><span class="p">.</span><span class="n">sli_flag</span> <span class="o">&amp;</span> <span class="n">LPFC_MENLO_MAINT</span><span class="p">)</span> <span class="o">||</span>
				<span class="p">(</span><span class="n">piocb</span><span class="o">-&gt;</span><span class="n">iocb</span><span class="p">.</span><span class="n">un</span><span class="p">.</span><span class="n">genreq64</span><span class="p">.</span><span class="n">w5</span><span class="p">.</span><span class="n">hcsw</span><span class="p">.</span><span class="n">Rctl</span> <span class="o">!=</span>
					<span class="n">FC_RCTL_DD_UNSOL_CMD</span><span class="p">)</span> <span class="o">||</span>
				<span class="p">(</span><span class="n">piocb</span><span class="o">-&gt;</span><span class="n">iocb</span><span class="p">.</span><span class="n">un</span><span class="p">.</span><span class="n">genreq64</span><span class="p">.</span><span class="n">w5</span><span class="p">.</span><span class="n">hcsw</span><span class="p">.</span><span class="n">Type</span> <span class="o">!=</span>
					<span class="n">MENLO_TRANSPORT_TYPE</span><span class="p">))</span>

				<span class="k">goto</span> <span class="n">iocb_busy</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">CMD_QUE_RING_BUF_CN</span>:
		<span class="k">case</span> <span class="n">CMD_QUE_RING_BUF64_CN</span>:
			<span class="cm">/*</span>
<span class="cm">			 * For IOCBs, like QUE_RING_BUF, that have no rsp ring</span>
<span class="cm">			 * completion, iocb_cmpl MUST be 0.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">piocb</span><span class="o">-&gt;</span><span class="n">iocb_cmpl</span><span class="p">)</span>
				<span class="n">piocb</span><span class="o">-&gt;</span><span class="n">iocb_cmpl</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="cm">/*FALLTHROUGH*/</span>
		<span class="k">case</span> <span class="n">CMD_CREATE_XRI_CR</span>:
		<span class="k">case</span> <span class="n">CMD_CLOSE_XRI_CN</span>:
		<span class="k">case</span> <span class="n">CMD_CLOSE_XRI_CX</span>:
			<span class="k">break</span><span class="p">;</span>
		<span class="nl">default:</span>
			<span class="k">goto</span> <span class="n">iocb_busy</span><span class="p">;</span>
		<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * For FCP commands, we must be in a state where we can process link</span>
<span class="cm">	 * attention events.</span>
<span class="cm">	 */</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">pring</span><span class="o">-&gt;</span><span class="n">ringno</span> <span class="o">==</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli</span><span class="p">.</span><span class="n">fcp_ring</span> <span class="o">&amp;&amp;</span>
			    <span class="o">!</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli</span><span class="p">.</span><span class="n">sli_flag</span> <span class="o">&amp;</span> <span class="n">LPFC_PROCESS_LA</span><span class="p">)))</span> <span class="p">{</span>
		<span class="k">goto</span> <span class="n">iocb_busy</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">while</span> <span class="p">((</span><span class="n">iocb</span> <span class="o">=</span> <span class="n">lpfc_sli_next_iocb_slot</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">pring</span><span class="p">))</span> <span class="o">&amp;&amp;</span>
	       <span class="p">(</span><span class="n">nextiocb</span> <span class="o">=</span> <span class="n">lpfc_sli_next_iocb</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">pring</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">piocb</span><span class="p">)))</span>
		<span class="n">lpfc_sli_submit_iocb</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">pring</span><span class="p">,</span> <span class="n">iocb</span><span class="p">,</span> <span class="n">nextiocb</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">iocb</span><span class="p">)</span>
		<span class="n">lpfc_sli_update_ring</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">pring</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">lpfc_sli_update_full_ring</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">pring</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">piocb</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">IOCB_SUCCESS</span><span class="p">;</span>

	<span class="k">goto</span> <span class="n">out_busy</span><span class="p">;</span>

 <span class="nl">iocb_busy:</span>
	<span class="n">pring</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">iocb_cmd_delay</span><span class="o">++</span><span class="p">;</span>

 <span class="nl">out_busy:</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">flag</span> <span class="o">&amp;</span> <span class="n">SLI_IOCB_RET_IOCB</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">__lpfc_sli_ringtx_put</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">pring</span><span class="p">,</span> <span class="n">piocb</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">IOCB_SUCCESS</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">IOCB_BUSY</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_sli4_bpl2sgl - Convert the bpl/bde to a sgl.</span>
<span class="cm"> * @phba: Pointer to HBA context object.</span>
<span class="cm"> * @piocb: Pointer to command iocb.</span>
<span class="cm"> * @sglq: Pointer to the scatter gather queue object.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine converts the bpl or bde that is in the IOCB</span>
<span class="cm"> * to a sgl list for the sli4 hardware. The physical address</span>
<span class="cm"> * of the bpl/bde is converted back to a virtual address.</span>
<span class="cm"> * If the IOCB contains a BPL then the list of BDE&#39;s is</span>
<span class="cm"> * converted to sli4_sge&#39;s. If the IOCB contains a single</span>
<span class="cm"> * BDE then it is converted to a single sli_sge.</span>
<span class="cm"> * The IOCB is still in cpu endianess so the contents of</span>
<span class="cm"> * the bpl can be used without byte swapping.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns valid XRI = Success, NO_XRI = Failure.</span>
<span class="cm">**/</span>
<span class="k">static</span> <span class="kt">uint16_t</span>
<span class="nf">lpfc_sli4_bpl2sgl</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">,</span> <span class="k">struct</span> <span class="n">lpfc_iocbq</span> <span class="o">*</span><span class="n">piocbq</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">lpfc_sglq</span> <span class="o">*</span><span class="n">sglq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">uint16_t</span> <span class="n">xritag</span> <span class="o">=</span> <span class="n">NO_XRI</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ulp_bde64</span> <span class="o">*</span><span class="n">bpl</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ulp_bde64</span> <span class="n">bde</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sli4_sge</span> <span class="o">*</span><span class="n">sgl</span>  <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_dmabuf</span> <span class="o">*</span><span class="n">dmabuf</span><span class="p">;</span>
	<span class="n">IOCB_t</span> <span class="o">*</span><span class="n">icmd</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">numBdes</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="cm">/* accumulated offset in the sg request list */</span>
	<span class="kt">int</span> <span class="n">inbound</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="cm">/* number of sg reply entries inbound from firmware */</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">piocbq</span> <span class="o">||</span> <span class="o">!</span><span class="n">sglq</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">xritag</span><span class="p">;</span>

	<span class="n">sgl</span>  <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sli4_sge</span> <span class="o">*</span><span class="p">)</span><span class="n">sglq</span><span class="o">-&gt;</span><span class="n">sgl</span><span class="p">;</span>
	<span class="n">icmd</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">piocbq</span><span class="o">-&gt;</span><span class="n">iocb</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">icmd</span><span class="o">-&gt;</span><span class="n">ulpCommand</span> <span class="o">==</span> <span class="n">CMD_XMIT_BLS_RSP64_CX</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">sglq</span><span class="o">-&gt;</span><span class="n">sli4_xritag</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">icmd</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">genreq64</span><span class="p">.</span><span class="n">bdl</span><span class="p">.</span><span class="n">bdeFlags</span> <span class="o">==</span> <span class="n">BUFF_TYPE_BLP_64</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">numBdes</span> <span class="o">=</span> <span class="n">icmd</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">genreq64</span><span class="p">.</span><span class="n">bdl</span><span class="p">.</span><span class="n">bdeSize</span> <span class="o">/</span>
				<span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ulp_bde64</span><span class="p">);</span>
		<span class="cm">/* The addrHigh and addrLow fields within the IOCB</span>
<span class="cm">		 * have not been byteswapped yet so there is no</span>
<span class="cm">		 * need to swap them back.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">piocbq</span><span class="o">-&gt;</span><span class="n">context3</span><span class="p">)</span>
			<span class="n">dmabuf</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_dmabuf</span> <span class="o">*</span><span class="p">)</span><span class="n">piocbq</span><span class="o">-&gt;</span><span class="n">context3</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="k">return</span> <span class="n">xritag</span><span class="p">;</span>

		<span class="n">bpl</span>  <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ulp_bde64</span> <span class="o">*</span><span class="p">)</span><span class="n">dmabuf</span><span class="o">-&gt;</span><span class="n">virt</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bpl</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">xritag</span><span class="p">;</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">numBdes</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Should already be byte swapped. */</span>
			<span class="n">sgl</span><span class="o">-&gt;</span><span class="n">addr_hi</span> <span class="o">=</span> <span class="n">bpl</span><span class="o">-&gt;</span><span class="n">addrHigh</span><span class="p">;</span>
			<span class="n">sgl</span><span class="o">-&gt;</span><span class="n">addr_lo</span> <span class="o">=</span> <span class="n">bpl</span><span class="o">-&gt;</span><span class="n">addrLow</span><span class="p">;</span>

			<span class="n">sgl</span><span class="o">-&gt;</span><span class="n">word2</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">sgl</span><span class="o">-&gt;</span><span class="n">word2</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="n">numBdes</span><span class="p">)</span>
				<span class="n">bf_set</span><span class="p">(</span><span class="n">lpfc_sli4_sge_last</span><span class="p">,</span> <span class="n">sgl</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
			<span class="k">else</span>
				<span class="n">bf_set</span><span class="p">(</span><span class="n">lpfc_sli4_sge_last</span><span class="p">,</span> <span class="n">sgl</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
			<span class="cm">/* swap the size field back to the cpu so we</span>
<span class="cm">			 * can assign it to the sgl.</span>
<span class="cm">			 */</span>
			<span class="n">bde</span><span class="p">.</span><span class="n">tus</span><span class="p">.</span><span class="n">w</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">bpl</span><span class="o">-&gt;</span><span class="n">tus</span><span class="p">.</span><span class="n">w</span><span class="p">);</span>
			<span class="n">sgl</span><span class="o">-&gt;</span><span class="n">sge_len</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">bde</span><span class="p">.</span><span class="n">tus</span><span class="p">.</span><span class="n">f</span><span class="p">.</span><span class="n">bdeSize</span><span class="p">);</span>
			<span class="cm">/* The offsets in the sgl need to be accumulated</span>
<span class="cm">			 * separately for the request and reply lists.</span>
<span class="cm">			 * The request is always first, the reply follows.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">piocbq</span><span class="o">-&gt;</span><span class="n">iocb</span><span class="p">.</span><span class="n">ulpCommand</span> <span class="o">==</span> <span class="n">CMD_GEN_REQUEST64_CR</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/* add up the reply sg entries */</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">bpl</span><span class="o">-&gt;</span><span class="n">tus</span><span class="p">.</span><span class="n">f</span><span class="p">.</span><span class="n">bdeFlags</span> <span class="o">==</span> <span class="n">BUFF_TYPE_BDE_64I</span><span class="p">)</span>
					<span class="n">inbound</span><span class="o">++</span><span class="p">;</span>
				<span class="cm">/* first inbound? reset the offset */</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">inbound</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
					<span class="n">offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
				<span class="n">bf_set</span><span class="p">(</span><span class="n">lpfc_sli4_sge_offset</span><span class="p">,</span> <span class="n">sgl</span><span class="p">,</span> <span class="n">offset</span><span class="p">);</span>
				<span class="n">bf_set</span><span class="p">(</span><span class="n">lpfc_sli4_sge_type</span><span class="p">,</span> <span class="n">sgl</span><span class="p">,</span>
					<span class="n">LPFC_SGE_TYPE_DATA</span><span class="p">);</span>
				<span class="n">offset</span> <span class="o">+=</span> <span class="n">bde</span><span class="p">.</span><span class="n">tus</span><span class="p">.</span><span class="n">f</span><span class="p">.</span><span class="n">bdeSize</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">sgl</span><span class="o">-&gt;</span><span class="n">word2</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">sgl</span><span class="o">-&gt;</span><span class="n">word2</span><span class="p">);</span>
			<span class="n">bpl</span><span class="o">++</span><span class="p">;</span>
			<span class="n">sgl</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">icmd</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">genreq64</span><span class="p">.</span><span class="n">bdl</span><span class="p">.</span><span class="n">bdeFlags</span> <span class="o">==</span> <span class="n">BUFF_TYPE_BDE_64</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* The addrHigh and addrLow fields of the BDE have not</span>
<span class="cm">			 * been byteswapped yet so they need to be swapped</span>
<span class="cm">			 * before putting them in the sgl.</span>
<span class="cm">			 */</span>
			<span class="n">sgl</span><span class="o">-&gt;</span><span class="n">addr_hi</span> <span class="o">=</span>
				<span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">icmd</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">genreq64</span><span class="p">.</span><span class="n">bdl</span><span class="p">.</span><span class="n">addrHigh</span><span class="p">);</span>
			<span class="n">sgl</span><span class="o">-&gt;</span><span class="n">addr_lo</span> <span class="o">=</span>
				<span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">icmd</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">genreq64</span><span class="p">.</span><span class="n">bdl</span><span class="p">.</span><span class="n">addrLow</span><span class="p">);</span>
			<span class="n">sgl</span><span class="o">-&gt;</span><span class="n">word2</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">sgl</span><span class="o">-&gt;</span><span class="n">word2</span><span class="p">);</span>
			<span class="n">bf_set</span><span class="p">(</span><span class="n">lpfc_sli4_sge_last</span><span class="p">,</span> <span class="n">sgl</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
			<span class="n">sgl</span><span class="o">-&gt;</span><span class="n">word2</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">sgl</span><span class="o">-&gt;</span><span class="n">word2</span><span class="p">);</span>
			<span class="n">sgl</span><span class="o">-&gt;</span><span class="n">sge_len</span> <span class="o">=</span>
				<span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">icmd</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">genreq64</span><span class="p">.</span><span class="n">bdl</span><span class="p">.</span><span class="n">bdeSize</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">sglq</span><span class="o">-&gt;</span><span class="n">sli4_xritag</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_sli4_scmd_to_wqidx_distr - scsi command to SLI4 WQ index distribution</span>
<span class="cm"> * @phba: Pointer to HBA context object.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine performs a roundrobin SCSI command to SLI4 FCP WQ index</span>
<span class="cm"> * distribution.  This is called by __lpfc_sli_issue_iocb_s4() with the hbalock</span>
<span class="cm"> * held.</span>
<span class="cm"> *</span>
<span class="cm"> * Return: index into SLI4 fast-path FCP queue index.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">uint32_t</span>
<span class="nf">lpfc_sli4_scmd_to_wqidx_distr</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">)</span>
<span class="p">{</span>
	<span class="o">++</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">fcp_qidx</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">fcp_qidx</span> <span class="o">&gt;=</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">cfg_fcp_wq_count</span><span class="p">)</span>
		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">fcp_qidx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">fcp_qidx</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_sli_iocb2wqe - Convert the IOCB to a work queue entry.</span>
<span class="cm"> * @phba: Pointer to HBA context object.</span>
<span class="cm"> * @piocb: Pointer to command iocb.</span>
<span class="cm"> * @wqe: Pointer to the work queue entry.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine converts the iocb command to its Work Queue Entry</span>
<span class="cm"> * equivalent. The wqe pointer should not have any fields set when</span>
<span class="cm"> * this routine is called because it will memcpy over them.</span>
<span class="cm"> * This routine does not set the CQ_ID or the WQEC bits in the</span>
<span class="cm"> * wqe.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns: 0 = Success, IOCB_ERROR = Failure.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">lpfc_sli4_iocb2wqe</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">,</span> <span class="k">struct</span> <span class="n">lpfc_iocbq</span> <span class="o">*</span><span class="n">iocbq</span><span class="p">,</span>
		<span class="k">union</span> <span class="n">lpfc_wqe</span> <span class="o">*</span><span class="n">wqe</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">uint32_t</span> <span class="n">xmit_len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">total_len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">uint8_t</span> <span class="n">ct</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">fip</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">abort_tag</span><span class="p">;</span>
	<span class="kt">uint8_t</span> <span class="n">command_type</span> <span class="o">=</span> <span class="n">ELS_COMMAND_NON_FIP</span><span class="p">;</span>
	<span class="kt">uint8_t</span> <span class="n">cmnd</span><span class="p">;</span>
	<span class="kt">uint16_t</span> <span class="n">xritag</span><span class="p">;</span>
	<span class="kt">uint16_t</span> <span class="n">abrt_iotag</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_iocbq</span> <span class="o">*</span><span class="n">abrtiocbq</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ulp_bde64</span> <span class="o">*</span><span class="n">bpl</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">els_id</span> <span class="o">=</span> <span class="n">LPFC_ELS_ID_DEFAULT</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">numBdes</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ulp_bde64</span> <span class="n">bde</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_nodelist</span> <span class="o">*</span><span class="n">ndlp</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="o">*</span><span class="n">pcmd</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">if_type</span><span class="p">;</span>

	<span class="n">fip</span> <span class="o">=</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">hba_flag</span> <span class="o">&amp;</span> <span class="n">HBA_FIP_SUPPORT</span><span class="p">;</span>
	<span class="cm">/* The fcp commands will set command type */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">iocbq</span><span class="o">-&gt;</span><span class="n">iocb_flag</span> <span class="o">&amp;</span>  <span class="n">LPFC_IO_FCP</span><span class="p">)</span>
		<span class="n">command_type</span> <span class="o">=</span> <span class="n">FCP_COMMAND</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">fip</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">iocbq</span><span class="o">-&gt;</span><span class="n">iocb_flag</span> <span class="o">&amp;</span> <span class="n">LPFC_FIP_ELS_ID_MASK</span><span class="p">))</span>
		<span class="n">command_type</span> <span class="o">=</span> <span class="n">ELS_COMMAND_FIP</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">command_type</span> <span class="o">=</span> <span class="n">ELS_COMMAND_NON_FIP</span><span class="p">;</span>

	<span class="cm">/* Some of the fields are in the right position already */</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">wqe</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">iocbq</span><span class="o">-&gt;</span><span class="n">iocb</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">union</span> <span class="n">lpfc_wqe</span><span class="p">));</span>
	<span class="n">abort_tag</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint32_t</span><span class="p">)</span> <span class="n">iocbq</span><span class="o">-&gt;</span><span class="n">iotag</span><span class="p">;</span>
	<span class="n">xritag</span> <span class="o">=</span> <span class="n">iocbq</span><span class="o">-&gt;</span><span class="n">sli4_xritag</span><span class="p">;</span>
	<span class="n">wqe</span><span class="o">-&gt;</span><span class="n">generic</span><span class="p">.</span><span class="n">wqe_com</span><span class="p">.</span><span class="n">word7</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="cm">/* The ct field has moved so reset */</span>
	<span class="cm">/* words0-2 bpl convert bde */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">iocbq</span><span class="o">-&gt;</span><span class="n">iocb</span><span class="p">.</span><span class="n">un</span><span class="p">.</span><span class="n">genreq64</span><span class="p">.</span><span class="n">bdl</span><span class="p">.</span><span class="n">bdeFlags</span> <span class="o">==</span> <span class="n">BUFF_TYPE_BLP_64</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">numBdes</span> <span class="o">=</span> <span class="n">iocbq</span><span class="o">-&gt;</span><span class="n">iocb</span><span class="p">.</span><span class="n">un</span><span class="p">.</span><span class="n">genreq64</span><span class="p">.</span><span class="n">bdl</span><span class="p">.</span><span class="n">bdeSize</span> <span class="o">/</span>
				<span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ulp_bde64</span><span class="p">);</span>
		<span class="n">bpl</span>  <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ulp_bde64</span> <span class="o">*</span><span class="p">)</span>
			<span class="p">((</span><span class="k">struct</span> <span class="n">lpfc_dmabuf</span> <span class="o">*</span><span class="p">)</span><span class="n">iocbq</span><span class="o">-&gt;</span><span class="n">context3</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">virt</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bpl</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">IOCB_ERROR</span><span class="p">;</span>

		<span class="cm">/* Should already be byte swapped. */</span>
		<span class="n">wqe</span><span class="o">-&gt;</span><span class="n">generic</span><span class="p">.</span><span class="n">bde</span><span class="p">.</span><span class="n">addrHigh</span> <span class="o">=</span>  <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">bpl</span><span class="o">-&gt;</span><span class="n">addrHigh</span><span class="p">);</span>
		<span class="n">wqe</span><span class="o">-&gt;</span><span class="n">generic</span><span class="p">.</span><span class="n">bde</span><span class="p">.</span><span class="n">addrLow</span> <span class="o">=</span>  <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">bpl</span><span class="o">-&gt;</span><span class="n">addrLow</span><span class="p">);</span>
		<span class="cm">/* swap the size field back to the cpu so we</span>
<span class="cm">		 * can assign it to the sgl.</span>
<span class="cm">		 */</span>
		<span class="n">wqe</span><span class="o">-&gt;</span><span class="n">generic</span><span class="p">.</span><span class="n">bde</span><span class="p">.</span><span class="n">tus</span><span class="p">.</span><span class="n">w</span>  <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">bpl</span><span class="o">-&gt;</span><span class="n">tus</span><span class="p">.</span><span class="n">w</span><span class="p">);</span>
		<span class="n">xmit_len</span> <span class="o">=</span> <span class="n">wqe</span><span class="o">-&gt;</span><span class="n">generic</span><span class="p">.</span><span class="n">bde</span><span class="p">.</span><span class="n">tus</span><span class="p">.</span><span class="n">f</span><span class="p">.</span><span class="n">bdeSize</span><span class="p">;</span>
		<span class="n">total_len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">numBdes</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">bde</span><span class="p">.</span><span class="n">tus</span><span class="p">.</span><span class="n">w</span>  <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">bpl</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">tus</span><span class="p">.</span><span class="n">w</span><span class="p">);</span>
			<span class="n">total_len</span> <span class="o">+=</span> <span class="n">bde</span><span class="p">.</span><span class="n">tus</span><span class="p">.</span><span class="n">f</span><span class="p">.</span><span class="n">bdeSize</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">xmit_len</span> <span class="o">=</span> <span class="n">iocbq</span><span class="o">-&gt;</span><span class="n">iocb</span><span class="p">.</span><span class="n">un</span><span class="p">.</span><span class="n">fcpi64</span><span class="p">.</span><span class="n">bdl</span><span class="p">.</span><span class="n">bdeSize</span><span class="p">;</span>

	<span class="n">iocbq</span><span class="o">-&gt;</span><span class="n">iocb</span><span class="p">.</span><span class="n">ulpIoTag</span> <span class="o">=</span> <span class="n">iocbq</span><span class="o">-&gt;</span><span class="n">iotag</span><span class="p">;</span>
	<span class="n">cmnd</span> <span class="o">=</span> <span class="n">iocbq</span><span class="o">-&gt;</span><span class="n">iocb</span><span class="p">.</span><span class="n">ulpCommand</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">iocbq</span><span class="o">-&gt;</span><span class="n">iocb</span><span class="p">.</span><span class="n">ulpCommand</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">CMD_ELS_REQUEST64_CR</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">iocbq</span><span class="o">-&gt;</span><span class="n">iocb_flag</span> <span class="o">&amp;</span> <span class="n">LPFC_IO_LIBDFC</span><span class="p">)</span>
			<span class="n">ndlp</span> <span class="o">=</span> <span class="n">iocbq</span><span class="o">-&gt;</span><span class="n">context_un</span><span class="p">.</span><span class="n">ndlp</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">ndlp</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_nodelist</span> <span class="o">*</span><span class="p">)</span><span class="n">iocbq</span><span class="o">-&gt;</span><span class="n">context1</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">iocbq</span><span class="o">-&gt;</span><span class="n">iocb</span><span class="p">.</span><span class="n">ulpLe</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_SLI</span><span class="p">,</span>
				<span class="s">&quot;2007 Only Limited Edition cmd Format&quot;</span>
				<span class="s">&quot; supported 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">iocbq</span><span class="o">-&gt;</span><span class="n">iocb</span><span class="p">.</span><span class="n">ulpCommand</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">IOCB_ERROR</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">wqe</span><span class="o">-&gt;</span><span class="n">els_req</span><span class="p">.</span><span class="n">payload_len</span> <span class="o">=</span> <span class="n">xmit_len</span><span class="p">;</span>
		<span class="cm">/* Els_reguest64 has a TMO */</span>
		<span class="n">bf_set</span><span class="p">(</span><span class="n">wqe_tmo</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wqe</span><span class="o">-&gt;</span><span class="n">els_req</span><span class="p">.</span><span class="n">wqe_com</span><span class="p">,</span>
			<span class="n">iocbq</span><span class="o">-&gt;</span><span class="n">iocb</span><span class="p">.</span><span class="n">ulpTimeout</span><span class="p">);</span>
		<span class="cm">/* Need a VF for word 4 set the vf bit*/</span>
		<span class="n">bf_set</span><span class="p">(</span><span class="n">els_req64_vf</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wqe</span><span class="o">-&gt;</span><span class="n">els_req</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="cm">/* And a VFID for word 12 */</span>
		<span class="n">bf_set</span><span class="p">(</span><span class="n">els_req64_vfid</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wqe</span><span class="o">-&gt;</span><span class="n">els_req</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">ct</span> <span class="o">=</span> <span class="p">((</span><span class="n">iocbq</span><span class="o">-&gt;</span><span class="n">iocb</span><span class="p">.</span><span class="n">ulpCt_h</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">|</span> <span class="n">iocbq</span><span class="o">-&gt;</span><span class="n">iocb</span><span class="p">.</span><span class="n">ulpCt_l</span><span class="p">);</span>
		<span class="n">bf_set</span><span class="p">(</span><span class="n">wqe_ctxt_tag</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wqe</span><span class="o">-&gt;</span><span class="n">els_req</span><span class="p">.</span><span class="n">wqe_com</span><span class="p">,</span>
		       <span class="n">iocbq</span><span class="o">-&gt;</span><span class="n">iocb</span><span class="p">.</span><span class="n">ulpContext</span><span class="p">);</span>
		<span class="n">bf_set</span><span class="p">(</span><span class="n">wqe_ct</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wqe</span><span class="o">-&gt;</span><span class="n">els_req</span><span class="p">.</span><span class="n">wqe_com</span><span class="p">,</span> <span class="n">ct</span><span class="p">);</span>
		<span class="n">bf_set</span><span class="p">(</span><span class="n">wqe_pu</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wqe</span><span class="o">-&gt;</span><span class="n">els_req</span><span class="p">.</span><span class="n">wqe_com</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="cm">/* CCP CCPE PV PRI in word10 were set in the memcpy */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">command_type</span> <span class="o">==</span> <span class="n">ELS_COMMAND_FIP</span><span class="p">)</span>
			<span class="n">els_id</span> <span class="o">=</span> <span class="p">((</span><span class="n">iocbq</span><span class="o">-&gt;</span><span class="n">iocb_flag</span> <span class="o">&amp;</span> <span class="n">LPFC_FIP_ELS_ID_MASK</span><span class="p">)</span>
					<span class="o">&gt;&gt;</span> <span class="n">LPFC_FIP_ELS_ID_SHIFT</span><span class="p">);</span>
		<span class="n">pcmd</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint32_t</span> <span class="o">*</span><span class="p">)</span> <span class="p">(((</span><span class="k">struct</span> <span class="n">lpfc_dmabuf</span> <span class="o">*</span><span class="p">)</span>
					<span class="n">iocbq</span><span class="o">-&gt;</span><span class="n">context2</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">virt</span><span class="p">);</span>
		<span class="n">if_type</span> <span class="o">=</span> <span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_sli_intf_if_type</span><span class="p">,</span>
					<span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">sli_intf</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">if_type</span> <span class="o">==</span> <span class="n">LPFC_SLI_INTF_IF_TYPE_2</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">pcmd</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="o">*</span><span class="n">pcmd</span> <span class="o">==</span> <span class="n">ELS_CMD_FLOGI</span> <span class="o">||</span>
				<span class="o">*</span><span class="n">pcmd</span> <span class="o">==</span> <span class="n">ELS_CMD_SCR</span> <span class="o">||</span>
				<span class="o">*</span><span class="n">pcmd</span> <span class="o">==</span> <span class="n">ELS_CMD_FDISC</span> <span class="o">||</span>
				<span class="o">*</span><span class="n">pcmd</span> <span class="o">==</span> <span class="n">ELS_CMD_LOGO</span> <span class="o">||</span>
				<span class="o">*</span><span class="n">pcmd</span> <span class="o">==</span> <span class="n">ELS_CMD_PLOGI</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">bf_set</span><span class="p">(</span><span class="n">els_req64_sp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wqe</span><span class="o">-&gt;</span><span class="n">els_req</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
				<span class="n">bf_set</span><span class="p">(</span><span class="n">els_req64_sid</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wqe</span><span class="o">-&gt;</span><span class="n">els_req</span><span class="p">,</span>
					<span class="n">iocbq</span><span class="o">-&gt;</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_myDID</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">((</span><span class="o">*</span><span class="n">pcmd</span> <span class="o">==</span> <span class="n">ELS_CMD_FLOGI</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
					<span class="o">!</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">fc_topology</span> <span class="o">==</span>
						<span class="n">LPFC_TOPOLOGY_LOOP</span><span class="p">))</span>
					<span class="n">bf_set</span><span class="p">(</span><span class="n">els_req64_sid</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wqe</span><span class="o">-&gt;</span><span class="n">els_req</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
				<span class="n">bf_set</span><span class="p">(</span><span class="n">wqe_ct</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wqe</span><span class="o">-&gt;</span><span class="n">els_req</span><span class="p">.</span><span class="n">wqe_com</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
				<span class="n">bf_set</span><span class="p">(</span><span class="n">wqe_ctxt_tag</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wqe</span><span class="o">-&gt;</span><span class="n">els_req</span><span class="p">.</span><span class="n">wqe_com</span><span class="p">,</span>
					<span class="n">phba</span><span class="o">-&gt;</span><span class="n">vpi_ids</span><span class="p">[</span><span class="n">iocbq</span><span class="o">-&gt;</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">vpi</span><span class="p">]);</span>
			<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">pcmd</span> <span class="o">&amp;&amp;</span> <span class="n">iocbq</span><span class="o">-&gt;</span><span class="n">context1</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">bf_set</span><span class="p">(</span><span class="n">wqe_ct</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wqe</span><span class="o">-&gt;</span><span class="n">els_req</span><span class="p">.</span><span class="n">wqe_com</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
				<span class="n">bf_set</span><span class="p">(</span><span class="n">wqe_ctxt_tag</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wqe</span><span class="o">-&gt;</span><span class="n">els_req</span><span class="p">.</span><span class="n">wqe_com</span><span class="p">,</span>
					<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">rpi_ids</span><span class="p">[</span><span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_rpi</span><span class="p">]);</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="n">bf_set</span><span class="p">(</span><span class="n">wqe_temp_rpi</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wqe</span><span class="o">-&gt;</span><span class="n">els_req</span><span class="p">.</span><span class="n">wqe_com</span><span class="p">,</span>
		       <span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">rpi_ids</span><span class="p">[</span><span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_rpi</span><span class="p">]);</span>
		<span class="n">bf_set</span><span class="p">(</span><span class="n">wqe_els_id</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wqe</span><span class="o">-&gt;</span><span class="n">els_req</span><span class="p">.</span><span class="n">wqe_com</span><span class="p">,</span> <span class="n">els_id</span><span class="p">);</span>
		<span class="n">bf_set</span><span class="p">(</span><span class="n">wqe_dbde</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wqe</span><span class="o">-&gt;</span><span class="n">els_req</span><span class="p">.</span><span class="n">wqe_com</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">bf_set</span><span class="p">(</span><span class="n">wqe_iod</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wqe</span><span class="o">-&gt;</span><span class="n">els_req</span><span class="p">.</span><span class="n">wqe_com</span><span class="p">,</span> <span class="n">LPFC_WQE_IOD_READ</span><span class="p">);</span>
		<span class="n">bf_set</span><span class="p">(</span><span class="n">wqe_qosd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wqe</span><span class="o">-&gt;</span><span class="n">els_req</span><span class="p">.</span><span class="n">wqe_com</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">bf_set</span><span class="p">(</span><span class="n">wqe_lenloc</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wqe</span><span class="o">-&gt;</span><span class="n">els_req</span><span class="p">.</span><span class="n">wqe_com</span><span class="p">,</span> <span class="n">LPFC_WQE_LENLOC_NONE</span><span class="p">);</span>
		<span class="n">bf_set</span><span class="p">(</span><span class="n">wqe_ebde_cnt</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wqe</span><span class="o">-&gt;</span><span class="n">els_req</span><span class="p">.</span><span class="n">wqe_com</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">CMD_XMIT_SEQUENCE64_CX</span>:
		<span class="n">bf_set</span><span class="p">(</span><span class="n">wqe_ctxt_tag</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wqe</span><span class="o">-&gt;</span><span class="n">xmit_sequence</span><span class="p">.</span><span class="n">wqe_com</span><span class="p">,</span>
		       <span class="n">iocbq</span><span class="o">-&gt;</span><span class="n">iocb</span><span class="p">.</span><span class="n">un</span><span class="p">.</span><span class="n">ulpWord</span><span class="p">[</span><span class="mi">3</span><span class="p">]);</span>
		<span class="n">bf_set</span><span class="p">(</span><span class="n">wqe_rcvoxid</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wqe</span><span class="o">-&gt;</span><span class="n">xmit_sequence</span><span class="p">.</span><span class="n">wqe_com</span><span class="p">,</span>
		       <span class="n">iocbq</span><span class="o">-&gt;</span><span class="n">iocb</span><span class="p">.</span><span class="n">unsli3</span><span class="p">.</span><span class="n">rcvsli3</span><span class="p">.</span><span class="n">ox_id</span><span class="p">);</span>
		<span class="cm">/* The entire sequence is transmitted for this IOCB */</span>
		<span class="n">xmit_len</span> <span class="o">=</span> <span class="n">total_len</span><span class="p">;</span>
		<span class="n">cmnd</span> <span class="o">=</span> <span class="n">CMD_XMIT_SEQUENCE64_CR</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">link_flag</span> <span class="o">&amp;</span> <span class="n">LS_LOOPBACK_MODE</span><span class="p">)</span>
			<span class="n">bf_set</span><span class="p">(</span><span class="n">wqe_xo</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wqe</span><span class="o">-&gt;</span><span class="n">xmit_sequence</span><span class="p">.</span><span class="n">wge_ctl</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">case</span> <span class="n">CMD_XMIT_SEQUENCE64_CR</span>:
		<span class="cm">/* word3 iocb=io_tag32 wqe=reserved */</span>
		<span class="n">wqe</span><span class="o">-&gt;</span><span class="n">xmit_sequence</span><span class="p">.</span><span class="n">rsvd3</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="cm">/* word4 relative_offset memcpy */</span>
		<span class="cm">/* word5 r_ctl/df_ctl memcpy */</span>
		<span class="n">bf_set</span><span class="p">(</span><span class="n">wqe_pu</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wqe</span><span class="o">-&gt;</span><span class="n">xmit_sequence</span><span class="p">.</span><span class="n">wqe_com</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">bf_set</span><span class="p">(</span><span class="n">wqe_dbde</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wqe</span><span class="o">-&gt;</span><span class="n">xmit_sequence</span><span class="p">.</span><span class="n">wqe_com</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">bf_set</span><span class="p">(</span><span class="n">wqe_iod</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wqe</span><span class="o">-&gt;</span><span class="n">xmit_sequence</span><span class="p">.</span><span class="n">wqe_com</span><span class="p">,</span>
		       <span class="n">LPFC_WQE_IOD_WRITE</span><span class="p">);</span>
		<span class="n">bf_set</span><span class="p">(</span><span class="n">wqe_lenloc</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wqe</span><span class="o">-&gt;</span><span class="n">xmit_sequence</span><span class="p">.</span><span class="n">wqe_com</span><span class="p">,</span>
		       <span class="n">LPFC_WQE_LENLOC_WORD12</span><span class="p">);</span>
		<span class="n">bf_set</span><span class="p">(</span><span class="n">wqe_ebde_cnt</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wqe</span><span class="o">-&gt;</span><span class="n">xmit_sequence</span><span class="p">.</span><span class="n">wqe_com</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">wqe</span><span class="o">-&gt;</span><span class="n">xmit_sequence</span><span class="p">.</span><span class="n">xmit_len</span> <span class="o">=</span> <span class="n">xmit_len</span><span class="p">;</span>
		<span class="n">command_type</span> <span class="o">=</span> <span class="n">OTHER_COMMAND</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">CMD_XMIT_BCAST64_CN</span>:
		<span class="cm">/* word3 iocb=iotag32 wqe=seq_payload_len */</span>
		<span class="n">wqe</span><span class="o">-&gt;</span><span class="n">xmit_bcast64</span><span class="p">.</span><span class="n">seq_payload_len</span> <span class="o">=</span> <span class="n">xmit_len</span><span class="p">;</span>
		<span class="cm">/* word4 iocb=rsvd wqe=rsvd */</span>
		<span class="cm">/* word5 iocb=rctl/type/df_ctl wqe=rctl/type/df_ctl memcpy */</span>
		<span class="cm">/* word6 iocb=ctxt_tag/io_tag wqe=ctxt_tag/xri */</span>
		<span class="n">bf_set</span><span class="p">(</span><span class="n">wqe_ct</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wqe</span><span class="o">-&gt;</span><span class="n">xmit_bcast64</span><span class="p">.</span><span class="n">wqe_com</span><span class="p">,</span>
			<span class="p">((</span><span class="n">iocbq</span><span class="o">-&gt;</span><span class="n">iocb</span><span class="p">.</span><span class="n">ulpCt_h</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">|</span> <span class="n">iocbq</span><span class="o">-&gt;</span><span class="n">iocb</span><span class="p">.</span><span class="n">ulpCt_l</span><span class="p">));</span>
		<span class="n">bf_set</span><span class="p">(</span><span class="n">wqe_dbde</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wqe</span><span class="o">-&gt;</span><span class="n">xmit_bcast64</span><span class="p">.</span><span class="n">wqe_com</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">bf_set</span><span class="p">(</span><span class="n">wqe_iod</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wqe</span><span class="o">-&gt;</span><span class="n">xmit_bcast64</span><span class="p">.</span><span class="n">wqe_com</span><span class="p">,</span> <span class="n">LPFC_WQE_IOD_WRITE</span><span class="p">);</span>
		<span class="n">bf_set</span><span class="p">(</span><span class="n">wqe_lenloc</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wqe</span><span class="o">-&gt;</span><span class="n">xmit_bcast64</span><span class="p">.</span><span class="n">wqe_com</span><span class="p">,</span>
		       <span class="n">LPFC_WQE_LENLOC_WORD3</span><span class="p">);</span>
		<span class="n">bf_set</span><span class="p">(</span><span class="n">wqe_ebde_cnt</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wqe</span><span class="o">-&gt;</span><span class="n">xmit_bcast64</span><span class="p">.</span><span class="n">wqe_com</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">CMD_FCP_IWRITE64_CR</span>:
		<span class="n">command_type</span> <span class="o">=</span> <span class="n">FCP_COMMAND_DATA_OUT</span><span class="p">;</span>
		<span class="cm">/* word3 iocb=iotag wqe=payload_offset_len */</span>
		<span class="cm">/* Add the FCP_CMD and FCP_RSP sizes to get the offset */</span>
		<span class="n">wqe</span><span class="o">-&gt;</span><span class="n">fcp_iwrite</span><span class="p">.</span><span class="n">payload_offset_len</span> <span class="o">=</span>
			<span class="n">xmit_len</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">fcp_rsp</span><span class="p">);</span>
		<span class="cm">/* word4 iocb=parameter wqe=total_xfer_length memcpy */</span>
		<span class="cm">/* word5 iocb=initial_xfer_len wqe=initial_xfer_len memcpy */</span>
		<span class="n">bf_set</span><span class="p">(</span><span class="n">wqe_erp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wqe</span><span class="o">-&gt;</span><span class="n">fcp_iwrite</span><span class="p">.</span><span class="n">wqe_com</span><span class="p">,</span>
		       <span class="n">iocbq</span><span class="o">-&gt;</span><span class="n">iocb</span><span class="p">.</span><span class="n">ulpFCP2Rcvy</span><span class="p">);</span>
		<span class="n">bf_set</span><span class="p">(</span><span class="n">wqe_lnk</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wqe</span><span class="o">-&gt;</span><span class="n">fcp_iwrite</span><span class="p">.</span><span class="n">wqe_com</span><span class="p">,</span> <span class="n">iocbq</span><span class="o">-&gt;</span><span class="n">iocb</span><span class="p">.</span><span class="n">ulpXS</span><span class="p">);</span>
		<span class="cm">/* Always open the exchange */</span>
		<span class="n">bf_set</span><span class="p">(</span><span class="n">wqe_xc</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wqe</span><span class="o">-&gt;</span><span class="n">fcp_iwrite</span><span class="p">.</span><span class="n">wqe_com</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">bf_set</span><span class="p">(</span><span class="n">wqe_iod</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wqe</span><span class="o">-&gt;</span><span class="n">fcp_iwrite</span><span class="p">.</span><span class="n">wqe_com</span><span class="p">,</span> <span class="n">LPFC_WQE_IOD_WRITE</span><span class="p">);</span>
		<span class="n">bf_set</span><span class="p">(</span><span class="n">wqe_lenloc</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wqe</span><span class="o">-&gt;</span><span class="n">fcp_iwrite</span><span class="p">.</span><span class="n">wqe_com</span><span class="p">,</span>
		       <span class="n">LPFC_WQE_LENLOC_WORD4</span><span class="p">);</span>
		<span class="n">bf_set</span><span class="p">(</span><span class="n">wqe_ebde_cnt</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wqe</span><span class="o">-&gt;</span><span class="n">fcp_iwrite</span><span class="p">.</span><span class="n">wqe_com</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">bf_set</span><span class="p">(</span><span class="n">wqe_pu</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wqe</span><span class="o">-&gt;</span><span class="n">fcp_iwrite</span><span class="p">.</span><span class="n">wqe_com</span><span class="p">,</span> <span class="n">iocbq</span><span class="o">-&gt;</span><span class="n">iocb</span><span class="p">.</span><span class="n">ulpPU</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">iocbq</span><span class="o">-&gt;</span><span class="n">iocb_flag</span> <span class="o">&amp;</span> <span class="n">LPFC_IO_DIF</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">iocbq</span><span class="o">-&gt;</span><span class="n">iocb_flag</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">LPFC_IO_DIF</span><span class="p">;</span>
			<span class="n">bf_set</span><span class="p">(</span><span class="n">wqe_dif</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wqe</span><span class="o">-&gt;</span><span class="n">generic</span><span class="p">.</span><span class="n">wqe_com</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">bf_set</span><span class="p">(</span><span class="n">wqe_dbde</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wqe</span><span class="o">-&gt;</span><span class="n">fcp_iwrite</span><span class="p">.</span><span class="n">wqe_com</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">CMD_FCP_IREAD64_CR</span>:
		<span class="cm">/* word3 iocb=iotag wqe=payload_offset_len */</span>
		<span class="cm">/* Add the FCP_CMD and FCP_RSP sizes to get the offset */</span>
		<span class="n">wqe</span><span class="o">-&gt;</span><span class="n">fcp_iread</span><span class="p">.</span><span class="n">payload_offset_len</span> <span class="o">=</span>
			<span class="n">xmit_len</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">fcp_rsp</span><span class="p">);</span>
		<span class="cm">/* word4 iocb=parameter wqe=total_xfer_length memcpy */</span>
		<span class="cm">/* word5 iocb=initial_xfer_len wqe=initial_xfer_len memcpy */</span>
		<span class="n">bf_set</span><span class="p">(</span><span class="n">wqe_erp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wqe</span><span class="o">-&gt;</span><span class="n">fcp_iread</span><span class="p">.</span><span class="n">wqe_com</span><span class="p">,</span>
		       <span class="n">iocbq</span><span class="o">-&gt;</span><span class="n">iocb</span><span class="p">.</span><span class="n">ulpFCP2Rcvy</span><span class="p">);</span>
		<span class="n">bf_set</span><span class="p">(</span><span class="n">wqe_lnk</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wqe</span><span class="o">-&gt;</span><span class="n">fcp_iread</span><span class="p">.</span><span class="n">wqe_com</span><span class="p">,</span> <span class="n">iocbq</span><span class="o">-&gt;</span><span class="n">iocb</span><span class="p">.</span><span class="n">ulpXS</span><span class="p">);</span>
		<span class="cm">/* Always open the exchange */</span>
		<span class="n">bf_set</span><span class="p">(</span><span class="n">wqe_xc</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wqe</span><span class="o">-&gt;</span><span class="n">fcp_iread</span><span class="p">.</span><span class="n">wqe_com</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">bf_set</span><span class="p">(</span><span class="n">wqe_iod</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wqe</span><span class="o">-&gt;</span><span class="n">fcp_iread</span><span class="p">.</span><span class="n">wqe_com</span><span class="p">,</span> <span class="n">LPFC_WQE_IOD_READ</span><span class="p">);</span>
		<span class="n">bf_set</span><span class="p">(</span><span class="n">wqe_lenloc</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wqe</span><span class="o">-&gt;</span><span class="n">fcp_iread</span><span class="p">.</span><span class="n">wqe_com</span><span class="p">,</span>
		       <span class="n">LPFC_WQE_LENLOC_WORD4</span><span class="p">);</span>
		<span class="n">bf_set</span><span class="p">(</span><span class="n">wqe_ebde_cnt</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wqe</span><span class="o">-&gt;</span><span class="n">fcp_iread</span><span class="p">.</span><span class="n">wqe_com</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">bf_set</span><span class="p">(</span><span class="n">wqe_pu</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wqe</span><span class="o">-&gt;</span><span class="n">fcp_iread</span><span class="p">.</span><span class="n">wqe_com</span><span class="p">,</span> <span class="n">iocbq</span><span class="o">-&gt;</span><span class="n">iocb</span><span class="p">.</span><span class="n">ulpPU</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">iocbq</span><span class="o">-&gt;</span><span class="n">iocb_flag</span> <span class="o">&amp;</span> <span class="n">LPFC_IO_DIF</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">iocbq</span><span class="o">-&gt;</span><span class="n">iocb_flag</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">LPFC_IO_DIF</span><span class="p">;</span>
			<span class="n">bf_set</span><span class="p">(</span><span class="n">wqe_dif</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wqe</span><span class="o">-&gt;</span><span class="n">generic</span><span class="p">.</span><span class="n">wqe_com</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">bf_set</span><span class="p">(</span><span class="n">wqe_dbde</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wqe</span><span class="o">-&gt;</span><span class="n">fcp_iread</span><span class="p">.</span><span class="n">wqe_com</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">CMD_FCP_ICMND64_CR</span>:
		<span class="cm">/* word3 iocb=IO_TAG wqe=reserved */</span>
		<span class="n">wqe</span><span class="o">-&gt;</span><span class="n">fcp_icmd</span><span class="p">.</span><span class="n">rsrvd3</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">bf_set</span><span class="p">(</span><span class="n">wqe_pu</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wqe</span><span class="o">-&gt;</span><span class="n">fcp_icmd</span><span class="p">.</span><span class="n">wqe_com</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="cm">/* Always open the exchange */</span>
		<span class="n">bf_set</span><span class="p">(</span><span class="n">wqe_xc</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wqe</span><span class="o">-&gt;</span><span class="n">fcp_icmd</span><span class="p">.</span><span class="n">wqe_com</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">bf_set</span><span class="p">(</span><span class="n">wqe_dbde</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wqe</span><span class="o">-&gt;</span><span class="n">fcp_icmd</span><span class="p">.</span><span class="n">wqe_com</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">bf_set</span><span class="p">(</span><span class="n">wqe_iod</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wqe</span><span class="o">-&gt;</span><span class="n">fcp_icmd</span><span class="p">.</span><span class="n">wqe_com</span><span class="p">,</span> <span class="n">LPFC_WQE_IOD_WRITE</span><span class="p">);</span>
		<span class="n">bf_set</span><span class="p">(</span><span class="n">wqe_qosd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wqe</span><span class="o">-&gt;</span><span class="n">fcp_icmd</span><span class="p">.</span><span class="n">wqe_com</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">bf_set</span><span class="p">(</span><span class="n">wqe_lenloc</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wqe</span><span class="o">-&gt;</span><span class="n">fcp_icmd</span><span class="p">.</span><span class="n">wqe_com</span><span class="p">,</span>
		       <span class="n">LPFC_WQE_LENLOC_NONE</span><span class="p">);</span>
		<span class="n">bf_set</span><span class="p">(</span><span class="n">wqe_ebde_cnt</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wqe</span><span class="o">-&gt;</span><span class="n">fcp_icmd</span><span class="p">.</span><span class="n">wqe_com</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">CMD_GEN_REQUEST64_CR</span>:
		<span class="cm">/* For this command calculate the xmit length of the</span>
<span class="cm">		 * request bde.</span>
<span class="cm">		 */</span>
		<span class="n">xmit_len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">numBdes</span> <span class="o">=</span> <span class="n">iocbq</span><span class="o">-&gt;</span><span class="n">iocb</span><span class="p">.</span><span class="n">un</span><span class="p">.</span><span class="n">genreq64</span><span class="p">.</span><span class="n">bdl</span><span class="p">.</span><span class="n">bdeSize</span> <span class="o">/</span>
			<span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ulp_bde64</span><span class="p">);</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">numBdes</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">bde</span><span class="p">.</span><span class="n">tus</span><span class="p">.</span><span class="n">w</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">bpl</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">tus</span><span class="p">.</span><span class="n">w</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">bde</span><span class="p">.</span><span class="n">tus</span><span class="p">.</span><span class="n">f</span><span class="p">.</span><span class="n">bdeFlags</span> <span class="o">!=</span> <span class="n">BUFF_TYPE_BDE_64</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="n">xmit_len</span> <span class="o">+=</span> <span class="n">bde</span><span class="p">.</span><span class="n">tus</span><span class="p">.</span><span class="n">f</span><span class="p">.</span><span class="n">bdeSize</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/* word3 iocb=IO_TAG wqe=request_payload_len */</span>
		<span class="n">wqe</span><span class="o">-&gt;</span><span class="n">gen_req</span><span class="p">.</span><span class="n">request_payload_len</span> <span class="o">=</span> <span class="n">xmit_len</span><span class="p">;</span>
		<span class="cm">/* word4 iocb=parameter wqe=relative_offset memcpy */</span>
		<span class="cm">/* word5 [rctl, type, df_ctl, la] copied in memcpy */</span>
		<span class="cm">/* word6 context tag copied in memcpy */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">iocbq</span><span class="o">-&gt;</span><span class="n">iocb</span><span class="p">.</span><span class="n">ulpCt_h</span>  <span class="o">||</span> <span class="n">iocbq</span><span class="o">-&gt;</span><span class="n">iocb</span><span class="p">.</span><span class="n">ulpCt_l</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ct</span> <span class="o">=</span> <span class="p">((</span><span class="n">iocbq</span><span class="o">-&gt;</span><span class="n">iocb</span><span class="p">.</span><span class="n">ulpCt_h</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">|</span> <span class="n">iocbq</span><span class="o">-&gt;</span><span class="n">iocb</span><span class="p">.</span><span class="n">ulpCt_l</span><span class="p">);</span>
			<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_SLI</span><span class="p">,</span>
				<span class="s">&quot;2015 Invalid CT %x command 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">ct</span><span class="p">,</span> <span class="n">iocbq</span><span class="o">-&gt;</span><span class="n">iocb</span><span class="p">.</span><span class="n">ulpCommand</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">IOCB_ERROR</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">bf_set</span><span class="p">(</span><span class="n">wqe_ct</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wqe</span><span class="o">-&gt;</span><span class="n">gen_req</span><span class="p">.</span><span class="n">wqe_com</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">bf_set</span><span class="p">(</span><span class="n">wqe_tmo</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wqe</span><span class="o">-&gt;</span><span class="n">gen_req</span><span class="p">.</span><span class="n">wqe_com</span><span class="p">,</span> <span class="n">iocbq</span><span class="o">-&gt;</span><span class="n">iocb</span><span class="p">.</span><span class="n">ulpTimeout</span><span class="p">);</span>
		<span class="n">bf_set</span><span class="p">(</span><span class="n">wqe_pu</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wqe</span><span class="o">-&gt;</span><span class="n">gen_req</span><span class="p">.</span><span class="n">wqe_com</span><span class="p">,</span> <span class="n">iocbq</span><span class="o">-&gt;</span><span class="n">iocb</span><span class="p">.</span><span class="n">ulpPU</span><span class="p">);</span>
		<span class="n">bf_set</span><span class="p">(</span><span class="n">wqe_dbde</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wqe</span><span class="o">-&gt;</span><span class="n">gen_req</span><span class="p">.</span><span class="n">wqe_com</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">bf_set</span><span class="p">(</span><span class="n">wqe_iod</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wqe</span><span class="o">-&gt;</span><span class="n">gen_req</span><span class="p">.</span><span class="n">wqe_com</span><span class="p">,</span> <span class="n">LPFC_WQE_IOD_READ</span><span class="p">);</span>
		<span class="n">bf_set</span><span class="p">(</span><span class="n">wqe_qosd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wqe</span><span class="o">-&gt;</span><span class="n">gen_req</span><span class="p">.</span><span class="n">wqe_com</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">bf_set</span><span class="p">(</span><span class="n">wqe_lenloc</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wqe</span><span class="o">-&gt;</span><span class="n">gen_req</span><span class="p">.</span><span class="n">wqe_com</span><span class="p">,</span> <span class="n">LPFC_WQE_LENLOC_NONE</span><span class="p">);</span>
		<span class="n">bf_set</span><span class="p">(</span><span class="n">wqe_ebde_cnt</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wqe</span><span class="o">-&gt;</span><span class="n">gen_req</span><span class="p">.</span><span class="n">wqe_com</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">command_type</span> <span class="o">=</span> <span class="n">OTHER_COMMAND</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">CMD_XMIT_ELS_RSP64_CX</span>:
		<span class="n">ndlp</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_nodelist</span> <span class="o">*</span><span class="p">)</span><span class="n">iocbq</span><span class="o">-&gt;</span><span class="n">context1</span><span class="p">;</span>
		<span class="cm">/* words0-2 BDE memcpy */</span>
		<span class="cm">/* word3 iocb=iotag32 wqe=response_payload_len */</span>
		<span class="n">wqe</span><span class="o">-&gt;</span><span class="n">xmit_els_rsp</span><span class="p">.</span><span class="n">response_payload_len</span> <span class="o">=</span> <span class="n">xmit_len</span><span class="p">;</span>
		<span class="cm">/* word4 */</span>
		<span class="n">wqe</span><span class="o">-&gt;</span><span class="n">xmit_els_rsp</span><span class="p">.</span><span class="n">word4</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="cm">/* word5 iocb=rsvd wge=did */</span>
		<span class="n">bf_set</span><span class="p">(</span><span class="n">wqe_els_did</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wqe</span><span class="o">-&gt;</span><span class="n">xmit_els_rsp</span><span class="p">.</span><span class="n">wqe_dest</span><span class="p">,</span>
			 <span class="n">iocbq</span><span class="o">-&gt;</span><span class="n">iocb</span><span class="p">.</span><span class="n">un</span><span class="p">.</span><span class="n">xseq64</span><span class="p">.</span><span class="n">xmit_els_remoteID</span><span class="p">);</span>

		<span class="n">if_type</span> <span class="o">=</span> <span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_sli_intf_if_type</span><span class="p">,</span>
					<span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">sli_intf</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">if_type</span> <span class="o">==</span> <span class="n">LPFC_SLI_INTF_IF_TYPE_2</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">iocbq</span><span class="o">-&gt;</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_flag</span> <span class="o">&amp;</span> <span class="n">FC_PT2PT</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">bf_set</span><span class="p">(</span><span class="n">els_rsp64_sp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wqe</span><span class="o">-&gt;</span><span class="n">xmit_els_rsp</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
				<span class="n">bf_set</span><span class="p">(</span><span class="n">els_rsp64_sid</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wqe</span><span class="o">-&gt;</span><span class="n">xmit_els_rsp</span><span class="p">,</span>
					<span class="n">iocbq</span><span class="o">-&gt;</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_myDID</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">iocbq</span><span class="o">-&gt;</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_myDID</span> <span class="o">==</span> <span class="n">Fabric_DID</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">bf_set</span><span class="p">(</span><span class="n">wqe_els_did</span><span class="p">,</span>
						<span class="o">&amp;</span><span class="n">wqe</span><span class="o">-&gt;</span><span class="n">xmit_els_rsp</span><span class="p">.</span><span class="n">wqe_dest</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
				<span class="p">}</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="n">bf_set</span><span class="p">(</span><span class="n">wqe_ct</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wqe</span><span class="o">-&gt;</span><span class="n">xmit_els_rsp</span><span class="p">.</span><span class="n">wqe_com</span><span class="p">,</span>
		       <span class="p">((</span><span class="n">iocbq</span><span class="o">-&gt;</span><span class="n">iocb</span><span class="p">.</span><span class="n">ulpCt_h</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">|</span> <span class="n">iocbq</span><span class="o">-&gt;</span><span class="n">iocb</span><span class="p">.</span><span class="n">ulpCt_l</span><span class="p">));</span>
		<span class="n">bf_set</span><span class="p">(</span><span class="n">wqe_pu</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wqe</span><span class="o">-&gt;</span><span class="n">xmit_els_rsp</span><span class="p">.</span><span class="n">wqe_com</span><span class="p">,</span> <span class="n">iocbq</span><span class="o">-&gt;</span><span class="n">iocb</span><span class="p">.</span><span class="n">ulpPU</span><span class="p">);</span>
		<span class="n">bf_set</span><span class="p">(</span><span class="n">wqe_rcvoxid</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wqe</span><span class="o">-&gt;</span><span class="n">xmit_els_rsp</span><span class="p">.</span><span class="n">wqe_com</span><span class="p">,</span>
		       <span class="n">iocbq</span><span class="o">-&gt;</span><span class="n">iocb</span><span class="p">.</span><span class="n">unsli3</span><span class="p">.</span><span class="n">rcvsli3</span><span class="p">.</span><span class="n">ox_id</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">iocbq</span><span class="o">-&gt;</span><span class="n">iocb</span><span class="p">.</span><span class="n">ulpCt_h</span> <span class="o">&amp;&amp;</span> <span class="n">iocbq</span><span class="o">-&gt;</span><span class="n">iocb</span><span class="p">.</span><span class="n">ulpCt_l</span><span class="p">)</span>
			<span class="n">bf_set</span><span class="p">(</span><span class="n">wqe_ctxt_tag</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wqe</span><span class="o">-&gt;</span><span class="n">xmit_els_rsp</span><span class="p">.</span><span class="n">wqe_com</span><span class="p">,</span>
			       <span class="n">phba</span><span class="o">-&gt;</span><span class="n">vpi_ids</span><span class="p">[</span><span class="n">iocbq</span><span class="o">-&gt;</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">vpi</span><span class="p">]);</span>
		<span class="n">bf_set</span><span class="p">(</span><span class="n">wqe_dbde</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wqe</span><span class="o">-&gt;</span><span class="n">xmit_els_rsp</span><span class="p">.</span><span class="n">wqe_com</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">bf_set</span><span class="p">(</span><span class="n">wqe_iod</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wqe</span><span class="o">-&gt;</span><span class="n">xmit_els_rsp</span><span class="p">.</span><span class="n">wqe_com</span><span class="p">,</span> <span class="n">LPFC_WQE_IOD_WRITE</span><span class="p">);</span>
		<span class="n">bf_set</span><span class="p">(</span><span class="n">wqe_qosd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wqe</span><span class="o">-&gt;</span><span class="n">xmit_els_rsp</span><span class="p">.</span><span class="n">wqe_com</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">bf_set</span><span class="p">(</span><span class="n">wqe_lenloc</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wqe</span><span class="o">-&gt;</span><span class="n">xmit_els_rsp</span><span class="p">.</span><span class="n">wqe_com</span><span class="p">,</span>
		       <span class="n">LPFC_WQE_LENLOC_WORD3</span><span class="p">);</span>
		<span class="n">bf_set</span><span class="p">(</span><span class="n">wqe_ebde_cnt</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wqe</span><span class="o">-&gt;</span><span class="n">xmit_els_rsp</span><span class="p">.</span><span class="n">wqe_com</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">bf_set</span><span class="p">(</span><span class="n">wqe_rsp_temp_rpi</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wqe</span><span class="o">-&gt;</span><span class="n">xmit_els_rsp</span><span class="p">,</span>
		       <span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">rpi_ids</span><span class="p">[</span><span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_rpi</span><span class="p">]);</span>
		<span class="n">pcmd</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint32_t</span> <span class="o">*</span><span class="p">)</span> <span class="p">(((</span><span class="k">struct</span> <span class="n">lpfc_dmabuf</span> <span class="o">*</span><span class="p">)</span>
					<span class="n">iocbq</span><span class="o">-&gt;</span><span class="n">context2</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">virt</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">fc_topology</span> <span class="o">==</span> <span class="n">LPFC_TOPOLOGY_LOOP</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">bf_set</span><span class="p">(</span><span class="n">els_rsp64_sp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wqe</span><span class="o">-&gt;</span><span class="n">xmit_els_rsp</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
				<span class="n">bf_set</span><span class="p">(</span><span class="n">els_rsp64_sid</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wqe</span><span class="o">-&gt;</span><span class="n">xmit_els_rsp</span><span class="p">,</span>
					<span class="n">iocbq</span><span class="o">-&gt;</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_myDID</span><span class="p">);</span>
				<span class="n">bf_set</span><span class="p">(</span><span class="n">wqe_ct</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wqe</span><span class="o">-&gt;</span><span class="n">xmit_els_rsp</span><span class="p">.</span><span class="n">wqe_com</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
				<span class="n">bf_set</span><span class="p">(</span><span class="n">wqe_ctxt_tag</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wqe</span><span class="o">-&gt;</span><span class="n">xmit_els_rsp</span><span class="p">.</span><span class="n">wqe_com</span><span class="p">,</span>
					<span class="n">phba</span><span class="o">-&gt;</span><span class="n">vpi_ids</span><span class="p">[</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">pport</span><span class="o">-&gt;</span><span class="n">vpi</span><span class="p">]);</span>
		<span class="p">}</span>
		<span class="n">command_type</span> <span class="o">=</span> <span class="n">OTHER_COMMAND</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">CMD_CLOSE_XRI_CN</span>:
	<span class="k">case</span> <span class="n">CMD_ABORT_XRI_CN</span>:
	<span class="k">case</span> <span class="n">CMD_ABORT_XRI_CX</span>:
		<span class="cm">/* words 0-2 memcpy should be 0 rserved */</span>
		<span class="cm">/* port will send abts */</span>
		<span class="n">abrt_iotag</span> <span class="o">=</span> <span class="n">iocbq</span><span class="o">-&gt;</span><span class="n">iocb</span><span class="p">.</span><span class="n">un</span><span class="p">.</span><span class="n">acxri</span><span class="p">.</span><span class="n">abortContextTag</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">abrt_iotag</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">abrt_iotag</span> <span class="o">&lt;=</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli</span><span class="p">.</span><span class="n">last_iotag</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">abrtiocbq</span> <span class="o">=</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli</span><span class="p">.</span><span class="n">iocbq_lookup</span><span class="p">[</span><span class="n">abrt_iotag</span><span class="p">];</span>
			<span class="n">fip</span> <span class="o">=</span> <span class="n">abrtiocbq</span><span class="o">-&gt;</span><span class="n">iocb_flag</span> <span class="o">&amp;</span> <span class="n">LPFC_FIP_ELS_ID_MASK</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="n">fip</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">((</span><span class="n">iocbq</span><span class="o">-&gt;</span><span class="n">iocb</span><span class="p">.</span><span class="n">ulpCommand</span> <span class="o">==</span> <span class="n">CMD_CLOSE_XRI_CN</span><span class="p">)</span> <span class="o">||</span> <span class="n">fip</span><span class="p">)</span>
			<span class="cm">/*</span>
<span class="cm">			 * The link is down, or the command was ELS_FIP</span>
<span class="cm">			 * so the fw does not need to send abts</span>
<span class="cm">			 * on the wire.</span>
<span class="cm">			 */</span>
			<span class="n">bf_set</span><span class="p">(</span><span class="n">abort_cmd_ia</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wqe</span><span class="o">-&gt;</span><span class="n">abort_cmd</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">bf_set</span><span class="p">(</span><span class="n">abort_cmd_ia</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wqe</span><span class="o">-&gt;</span><span class="n">abort_cmd</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">bf_set</span><span class="p">(</span><span class="n">abort_cmd_criteria</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wqe</span><span class="o">-&gt;</span><span class="n">abort_cmd</span><span class="p">,</span> <span class="n">T_XRI_TAG</span><span class="p">);</span>
		<span class="cm">/* word5 iocb=CONTEXT_TAG|IO_TAG wqe=reserved */</span>
		<span class="n">wqe</span><span class="o">-&gt;</span><span class="n">abort_cmd</span><span class="p">.</span><span class="n">rsrvd5</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">bf_set</span><span class="p">(</span><span class="n">wqe_ct</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wqe</span><span class="o">-&gt;</span><span class="n">abort_cmd</span><span class="p">.</span><span class="n">wqe_com</span><span class="p">,</span>
			<span class="p">((</span><span class="n">iocbq</span><span class="o">-&gt;</span><span class="n">iocb</span><span class="p">.</span><span class="n">ulpCt_h</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">|</span> <span class="n">iocbq</span><span class="o">-&gt;</span><span class="n">iocb</span><span class="p">.</span><span class="n">ulpCt_l</span><span class="p">));</span>
		<span class="n">abort_tag</span> <span class="o">=</span> <span class="n">iocbq</span><span class="o">-&gt;</span><span class="n">iocb</span><span class="p">.</span><span class="n">un</span><span class="p">.</span><span class="n">acxri</span><span class="p">.</span><span class="n">abortIoTag</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * The abort handler will send us CMD_ABORT_XRI_CN or</span>
<span class="cm">		 * CMD_CLOSE_XRI_CN and the fw only accepts CMD_ABORT_XRI_CX</span>
<span class="cm">		 */</span>
		<span class="n">bf_set</span><span class="p">(</span><span class="n">wqe_cmnd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wqe</span><span class="o">-&gt;</span><span class="n">abort_cmd</span><span class="p">.</span><span class="n">wqe_com</span><span class="p">,</span> <span class="n">CMD_ABORT_XRI_CX</span><span class="p">);</span>
		<span class="n">bf_set</span><span class="p">(</span><span class="n">wqe_qosd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wqe</span><span class="o">-&gt;</span><span class="n">abort_cmd</span><span class="p">.</span><span class="n">wqe_com</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">bf_set</span><span class="p">(</span><span class="n">wqe_lenloc</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wqe</span><span class="o">-&gt;</span><span class="n">abort_cmd</span><span class="p">.</span><span class="n">wqe_com</span><span class="p">,</span>
		       <span class="n">LPFC_WQE_LENLOC_NONE</span><span class="p">);</span>
		<span class="n">cmnd</span> <span class="o">=</span> <span class="n">CMD_ABORT_XRI_CX</span><span class="p">;</span>
		<span class="n">command_type</span> <span class="o">=</span> <span class="n">OTHER_COMMAND</span><span class="p">;</span>
		<span class="n">xritag</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">CMD_XMIT_BLS_RSP64_CX</span>:
		<span class="n">ndlp</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_nodelist</span> <span class="o">*</span><span class="p">)</span><span class="n">iocbq</span><span class="o">-&gt;</span><span class="n">context1</span><span class="p">;</span>
		<span class="cm">/* As BLS ABTS RSP WQE is very different from other WQEs,</span>
<span class="cm">		 * we re-construct this WQE here based on information in</span>
<span class="cm">		 * iocbq from scratch.</span>
<span class="cm">		 */</span>
		<span class="n">memset</span><span class="p">(</span><span class="n">wqe</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">union</span> <span class="n">lpfc_wqe</span><span class="p">));</span>
		<span class="cm">/* OX_ID is invariable to who sent ABTS to CT exchange */</span>
		<span class="n">bf_set</span><span class="p">(</span><span class="n">xmit_bls_rsp64_oxid</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wqe</span><span class="o">-&gt;</span><span class="n">xmit_bls_rsp</span><span class="p">,</span>
		       <span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_abts_oxid</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">iocbq</span><span class="o">-&gt;</span><span class="n">iocb</span><span class="p">.</span><span class="n">un</span><span class="p">.</span><span class="n">bls_rsp</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_abts_orig</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">iocbq</span><span class="o">-&gt;</span><span class="n">iocb</span><span class="p">.</span><span class="n">un</span><span class="p">.</span><span class="n">bls_rsp</span><span class="p">)</span> <span class="o">==</span>
		    <span class="n">LPFC_ABTS_UNSOL_INT</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* ABTS sent by initiator to CT exchange, the</span>
<span class="cm">			 * RX_ID field will be filled with the newly</span>
<span class="cm">			 * allocated responder XRI.</span>
<span class="cm">			 */</span>
			<span class="n">bf_set</span><span class="p">(</span><span class="n">xmit_bls_rsp64_rxid</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wqe</span><span class="o">-&gt;</span><span class="n">xmit_bls_rsp</span><span class="p">,</span>
			       <span class="n">iocbq</span><span class="o">-&gt;</span><span class="n">sli4_xritag</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/* ABTS sent by responder to CT exchange, the</span>
<span class="cm">			 * RX_ID field will be filled with the responder</span>
<span class="cm">			 * RX_ID from ABTS.</span>
<span class="cm">			 */</span>
			<span class="n">bf_set</span><span class="p">(</span><span class="n">xmit_bls_rsp64_rxid</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wqe</span><span class="o">-&gt;</span><span class="n">xmit_bls_rsp</span><span class="p">,</span>
			       <span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_abts_rxid</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">iocbq</span><span class="o">-&gt;</span><span class="n">iocb</span><span class="p">.</span><span class="n">un</span><span class="p">.</span><span class="n">bls_rsp</span><span class="p">));</span>
		<span class="p">}</span>
		<span class="n">bf_set</span><span class="p">(</span><span class="n">xmit_bls_rsp64_seqcnthi</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wqe</span><span class="o">-&gt;</span><span class="n">xmit_bls_rsp</span><span class="p">,</span> <span class="mh">0xffff</span><span class="p">);</span>
		<span class="n">bf_set</span><span class="p">(</span><span class="n">wqe_xmit_bls_pt</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wqe</span><span class="o">-&gt;</span><span class="n">xmit_bls_rsp</span><span class="p">.</span><span class="n">wqe_dest</span><span class="p">,</span> <span class="mh">0x1</span><span class="p">);</span>

		<span class="cm">/* Use CT=VPI */</span>
		<span class="n">bf_set</span><span class="p">(</span><span class="n">wqe_els_did</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wqe</span><span class="o">-&gt;</span><span class="n">xmit_bls_rsp</span><span class="p">.</span><span class="n">wqe_dest</span><span class="p">,</span>
			<span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_DID</span><span class="p">);</span>
		<span class="n">bf_set</span><span class="p">(</span><span class="n">xmit_bls_rsp64_temprpi</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wqe</span><span class="o">-&gt;</span><span class="n">xmit_bls_rsp</span><span class="p">,</span>
			<span class="n">iocbq</span><span class="o">-&gt;</span><span class="n">iocb</span><span class="p">.</span><span class="n">ulpContext</span><span class="p">);</span>
		<span class="n">bf_set</span><span class="p">(</span><span class="n">wqe_ct</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wqe</span><span class="o">-&gt;</span><span class="n">xmit_bls_rsp</span><span class="p">.</span><span class="n">wqe_com</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">bf_set</span><span class="p">(</span><span class="n">wqe_ctxt_tag</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wqe</span><span class="o">-&gt;</span><span class="n">xmit_bls_rsp</span><span class="p">.</span><span class="n">wqe_com</span><span class="p">,</span>
			<span class="n">phba</span><span class="o">-&gt;</span><span class="n">vpi_ids</span><span class="p">[</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">pport</span><span class="o">-&gt;</span><span class="n">vpi</span><span class="p">]);</span>
		<span class="n">bf_set</span><span class="p">(</span><span class="n">wqe_qosd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wqe</span><span class="o">-&gt;</span><span class="n">xmit_bls_rsp</span><span class="p">.</span><span class="n">wqe_com</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">bf_set</span><span class="p">(</span><span class="n">wqe_lenloc</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wqe</span><span class="o">-&gt;</span><span class="n">xmit_bls_rsp</span><span class="p">.</span><span class="n">wqe_com</span><span class="p">,</span>
		       <span class="n">LPFC_WQE_LENLOC_NONE</span><span class="p">);</span>
		<span class="cm">/* Overwrite the pre-set comnd type with OTHER_COMMAND */</span>
		<span class="n">command_type</span> <span class="o">=</span> <span class="n">OTHER_COMMAND</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">iocbq</span><span class="o">-&gt;</span><span class="n">iocb</span><span class="p">.</span><span class="n">un</span><span class="p">.</span><span class="n">xseq64</span><span class="p">.</span><span class="n">w5</span><span class="p">.</span><span class="n">hcsw</span><span class="p">.</span><span class="n">Rctl</span> <span class="o">==</span> <span class="n">FC_RCTL_BA_RJT</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">bf_set</span><span class="p">(</span><span class="n">xmit_bls_rsp64_rjt_vspec</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wqe</span><span class="o">-&gt;</span><span class="n">xmit_bls_rsp</span><span class="p">,</span>
			       <span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_vndr_code</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">iocbq</span><span class="o">-&gt;</span><span class="n">iocb</span><span class="p">.</span><span class="n">un</span><span class="p">.</span><span class="n">bls_rsp</span><span class="p">));</span>
			<span class="n">bf_set</span><span class="p">(</span><span class="n">xmit_bls_rsp64_rjt_expc</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wqe</span><span class="o">-&gt;</span><span class="n">xmit_bls_rsp</span><span class="p">,</span>
			       <span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_rsn_expln</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">iocbq</span><span class="o">-&gt;</span><span class="n">iocb</span><span class="p">.</span><span class="n">un</span><span class="p">.</span><span class="n">bls_rsp</span><span class="p">));</span>
			<span class="n">bf_set</span><span class="p">(</span><span class="n">xmit_bls_rsp64_rjt_rsnc</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wqe</span><span class="o">-&gt;</span><span class="n">xmit_bls_rsp</span><span class="p">,</span>
			       <span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_rsn_code</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">iocbq</span><span class="o">-&gt;</span><span class="n">iocb</span><span class="p">.</span><span class="n">un</span><span class="p">.</span><span class="n">bls_rsp</span><span class="p">));</span>
		<span class="p">}</span>

		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">CMD_XRI_ABORTED_CX</span>:
	<span class="k">case</span> <span class="n">CMD_CREATE_XRI_CR</span>: <span class="cm">/* Do we expect to use this? */</span>
	<span class="k">case</span> <span class="n">CMD_IOCB_FCP_IBIDIR64_CR</span>: <span class="cm">/* bidirectional xfer */</span>
	<span class="k">case</span> <span class="n">CMD_FCP_TSEND64_CX</span>: <span class="cm">/* Target mode send xfer-ready */</span>
	<span class="k">case</span> <span class="n">CMD_FCP_TRSP64_CX</span>: <span class="cm">/* Target mode rcv */</span>
	<span class="k">case</span> <span class="n">CMD_FCP_AUTO_TRSP_CX</span>: <span class="cm">/* Auto target rsp */</span>
	<span class="nl">default:</span>
		<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_SLI</span><span class="p">,</span>
				<span class="s">&quot;2014 Invalid command 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">iocbq</span><span class="o">-&gt;</span><span class="n">iocb</span><span class="p">.</span><span class="n">ulpCommand</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">IOCB_ERROR</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">bf_set</span><span class="p">(</span><span class="n">wqe_xri_tag</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wqe</span><span class="o">-&gt;</span><span class="n">generic</span><span class="p">.</span><span class="n">wqe_com</span><span class="p">,</span> <span class="n">xritag</span><span class="p">);</span>
	<span class="n">bf_set</span><span class="p">(</span><span class="n">wqe_reqtag</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wqe</span><span class="o">-&gt;</span><span class="n">generic</span><span class="p">.</span><span class="n">wqe_com</span><span class="p">,</span> <span class="n">iocbq</span><span class="o">-&gt;</span><span class="n">iotag</span><span class="p">);</span>
	<span class="n">wqe</span><span class="o">-&gt;</span><span class="n">generic</span><span class="p">.</span><span class="n">wqe_com</span><span class="p">.</span><span class="n">abort_tag</span> <span class="o">=</span> <span class="n">abort_tag</span><span class="p">;</span>
	<span class="n">bf_set</span><span class="p">(</span><span class="n">wqe_cmd_type</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wqe</span><span class="o">-&gt;</span><span class="n">generic</span><span class="p">.</span><span class="n">wqe_com</span><span class="p">,</span> <span class="n">command_type</span><span class="p">);</span>
	<span class="n">bf_set</span><span class="p">(</span><span class="n">wqe_cmnd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wqe</span><span class="o">-&gt;</span><span class="n">generic</span><span class="p">.</span><span class="n">wqe_com</span><span class="p">,</span> <span class="n">cmnd</span><span class="p">);</span>
	<span class="n">bf_set</span><span class="p">(</span><span class="n">wqe_class</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wqe</span><span class="o">-&gt;</span><span class="n">generic</span><span class="p">.</span><span class="n">wqe_com</span><span class="p">,</span> <span class="n">iocbq</span><span class="o">-&gt;</span><span class="n">iocb</span><span class="p">.</span><span class="n">ulpClass</span><span class="p">);</span>
	<span class="n">bf_set</span><span class="p">(</span><span class="n">wqe_cqid</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wqe</span><span class="o">-&gt;</span><span class="n">generic</span><span class="p">.</span><span class="n">wqe_com</span><span class="p">,</span> <span class="n">LPFC_WQE_CQ_ID_DEFAULT</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * __lpfc_sli_issue_iocb_s4 - SLI4 device lockless ver of lpfc_sli_issue_iocb</span>
<span class="cm"> * @phba: Pointer to HBA context object.</span>
<span class="cm"> * @ring_number: SLI ring number to issue iocb on.</span>
<span class="cm"> * @piocb: Pointer to command iocb.</span>
<span class="cm"> * @flag: Flag indicating if this command can be put into txq.</span>
<span class="cm"> *</span>
<span class="cm"> * __lpfc_sli_issue_iocb_s4 is used by other functions in the driver to issue</span>
<span class="cm"> * an iocb command to an HBA with SLI-4 interface spec.</span>
<span class="cm"> *</span>
<span class="cm"> * This function is called with hbalock held. The function will return success</span>
<span class="cm"> * after it successfully submit the iocb to firmware or after adding to the</span>
<span class="cm"> * txq.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">__lpfc_sli_issue_iocb_s4</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">ring_number</span><span class="p">,</span>
			 <span class="k">struct</span> <span class="n">lpfc_iocbq</span> <span class="o">*</span><span class="n">piocb</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">flag</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpfc_sglq</span> <span class="o">*</span><span class="n">sglq</span><span class="p">;</span>
	<span class="k">union</span> <span class="n">lpfc_wqe</span> <span class="n">wqe</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_sli_ring</span> <span class="o">*</span><span class="n">pring</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli</span><span class="p">.</span><span class="n">ring</span><span class="p">[</span><span class="n">ring_number</span><span class="p">];</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">piocb</span><span class="o">-&gt;</span><span class="n">sli4_xritag</span> <span class="o">==</span> <span class="n">NO_XRI</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">piocb</span><span class="o">-&gt;</span><span class="n">iocb</span><span class="p">.</span><span class="n">ulpCommand</span> <span class="o">==</span> <span class="n">CMD_ABORT_XRI_CN</span> <span class="o">||</span>
		    <span class="n">piocb</span><span class="o">-&gt;</span><span class="n">iocb</span><span class="p">.</span><span class="n">ulpCommand</span> <span class="o">==</span> <span class="n">CMD_CLOSE_XRI_CN</span><span class="p">)</span>
			<span class="n">sglq</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="k">else</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">pring</span><span class="o">-&gt;</span><span class="n">txq_cnt</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">flag</span> <span class="o">&amp;</span> <span class="n">SLI_IOCB_RET_IOCB</span><span class="p">))</span> <span class="p">{</span>
					<span class="n">__lpfc_sli_ringtx_put</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span>
						<span class="n">pring</span><span class="p">,</span> <span class="n">piocb</span><span class="p">);</span>
					<span class="k">return</span> <span class="n">IOCB_SUCCESS</span><span class="p">;</span>
				<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
					<span class="k">return</span> <span class="n">IOCB_BUSY</span><span class="p">;</span>
				<span class="p">}</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="n">sglq</span> <span class="o">=</span> <span class="n">__lpfc_sli_get_sglq</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">piocb</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sglq</span><span class="p">)</span> <span class="p">{</span>
					<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">flag</span> <span class="o">&amp;</span> <span class="n">SLI_IOCB_RET_IOCB</span><span class="p">))</span> <span class="p">{</span>
						<span class="n">__lpfc_sli_ringtx_put</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span>
								<span class="n">pring</span><span class="p">,</span>
								<span class="n">piocb</span><span class="p">);</span>
						<span class="k">return</span> <span class="n">IOCB_SUCCESS</span><span class="p">;</span>
					<span class="p">}</span> <span class="k">else</span>
						<span class="k">return</span> <span class="n">IOCB_BUSY</span><span class="p">;</span>
				<span class="p">}</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">piocb</span><span class="o">-&gt;</span><span class="n">iocb_flag</span> <span class="o">&amp;</span>  <span class="n">LPFC_IO_FCP</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* These IO&#39;s already have an XRI and a mapped sgl. */</span>
		<span class="n">sglq</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * This is a continuation of a commandi,(CX) so this</span>
<span class="cm">		 * sglq is on the active list</span>
<span class="cm">		 */</span>
		<span class="n">sglq</span> <span class="o">=</span> <span class="n">__lpfc_get_active_sglq</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">piocb</span><span class="o">-&gt;</span><span class="n">sli4_xritag</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sglq</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">IOCB_ERROR</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sglq</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">piocb</span><span class="o">-&gt;</span><span class="n">sli4_lxritag</span> <span class="o">=</span> <span class="n">sglq</span><span class="o">-&gt;</span><span class="n">sli4_lxritag</span><span class="p">;</span>
		<span class="n">piocb</span><span class="o">-&gt;</span><span class="n">sli4_xritag</span> <span class="o">=</span> <span class="n">sglq</span><span class="o">-&gt;</span><span class="n">sli4_xritag</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">NO_XRI</span> <span class="o">==</span> <span class="n">lpfc_sli4_bpl2sgl</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">piocb</span><span class="p">,</span> <span class="n">sglq</span><span class="p">))</span>
			<span class="k">return</span> <span class="n">IOCB_ERROR</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">lpfc_sli4_iocb2wqe</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">piocb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wqe</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">IOCB_ERROR</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">piocb</span><span class="o">-&gt;</span><span class="n">iocb_flag</span> <span class="o">&amp;</span> <span class="n">LPFC_IO_FCP</span><span class="p">)</span> <span class="o">||</span>
		<span class="p">(</span><span class="n">piocb</span><span class="o">-&gt;</span><span class="n">iocb_flag</span> <span class="o">&amp;</span> <span class="n">LPFC_USE_FCPWQIDX</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * For FCP command IOCB, get a new WQ index to distribute</span>
<span class="cm">		 * WQE across the WQsr. On the other hand, for abort IOCB,</span>
<span class="cm">		 * it carries the same WQ index to the original command</span>
<span class="cm">		 * IOCB.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">piocb</span><span class="o">-&gt;</span><span class="n">iocb_flag</span> <span class="o">&amp;</span> <span class="n">LPFC_IO_FCP</span><span class="p">)</span>
			<span class="n">piocb</span><span class="o">-&gt;</span><span class="n">fcp_wqidx</span> <span class="o">=</span> <span class="n">lpfc_sli4_scmd_to_wqidx_distr</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">fcp_wq</span><span class="p">))</span>
			<span class="k">return</span> <span class="n">IOCB_ERROR</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">lpfc_sli4_wq_put</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">fcp_wq</span><span class="p">[</span><span class="n">piocb</span><span class="o">-&gt;</span><span class="n">fcp_wqidx</span><span class="p">],</span>
				     <span class="o">&amp;</span><span class="n">wqe</span><span class="p">))</span>
			<span class="k">return</span> <span class="n">IOCB_ERROR</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">lpfc_sli4_wq_put</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">els_wq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wqe</span><span class="p">))</span>
			<span class="k">return</span> <span class="n">IOCB_ERROR</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">lpfc_sli_ringtxcmpl_put</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">pring</span><span class="p">,</span> <span class="n">piocb</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * __lpfc_sli_issue_iocb - Wrapper func of lockless version for issuing iocb</span>
<span class="cm"> *</span>
<span class="cm"> * This routine wraps the actual lockless version for issusing IOCB function</span>
<span class="cm"> * pointer from the lpfc_hba struct.</span>
<span class="cm"> *</span>
<span class="cm"> * Return codes:</span>
<span class="cm"> * 	IOCB_ERROR - Error</span>
<span class="cm"> * 	IOCB_SUCCESS - Success</span>
<span class="cm"> * 	IOCB_BUSY - Busy</span>
<span class="cm"> **/</span>
<span class="kt">int</span>
<span class="nf">__lpfc_sli_issue_iocb</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">ring_number</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">lpfc_iocbq</span> <span class="o">*</span><span class="n">piocb</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">flag</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">__lpfc_sli_issue_iocb</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">ring_number</span><span class="p">,</span> <span class="n">piocb</span><span class="p">,</span> <span class="n">flag</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_sli_api_table_setup - Set up sli api function jump table</span>
<span class="cm"> * @phba: The hba struct for which this call is being executed.</span>
<span class="cm"> * @dev_grp: The HBA PCI-Device group number.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine sets up the SLI interface API function jump table in @phba</span>
<span class="cm"> * struct.</span>
<span class="cm"> * Returns: 0 - success, -ENODEV - failure.</span>
<span class="cm"> **/</span>
<span class="kt">int</span>
<span class="nf">lpfc_sli_api_table_setup</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="n">dev_grp</span><span class="p">)</span>
<span class="p">{</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">dev_grp</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">LPFC_PCI_DEV_LP</span>:
		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">__lpfc_sli_issue_iocb</span> <span class="o">=</span> <span class="n">__lpfc_sli_issue_iocb_s3</span><span class="p">;</span>
		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">__lpfc_sli_release_iocbq</span> <span class="o">=</span> <span class="n">__lpfc_sli_release_iocbq_s3</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">LPFC_PCI_DEV_OC</span>:
		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">__lpfc_sli_issue_iocb</span> <span class="o">=</span> <span class="n">__lpfc_sli_issue_iocb_s4</span><span class="p">;</span>
		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">__lpfc_sli_release_iocbq</span> <span class="o">=</span> <span class="n">__lpfc_sli_release_iocbq_s4</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_INIT</span><span class="p">,</span>
				<span class="s">&quot;1419 Invalid HBA PCI-device group: 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">dev_grp</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">lpfc_get_iocb_from_iocbq</span> <span class="o">=</span> <span class="n">lpfc_get_iocb_from_iocbq</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_sli_issue_iocb - Wrapper function for __lpfc_sli_issue_iocb</span>
<span class="cm"> * @phba: Pointer to HBA context object.</span>
<span class="cm"> * @pring: Pointer to driver SLI ring object.</span>
<span class="cm"> * @piocb: Pointer to command iocb.</span>
<span class="cm"> * @flag: Flag indicating if this command can be put into txq.</span>
<span class="cm"> *</span>
<span class="cm"> * lpfc_sli_issue_iocb is a wrapper around __lpfc_sli_issue_iocb</span>
<span class="cm"> * function. This function gets the hbalock and calls</span>
<span class="cm"> * __lpfc_sli_issue_iocb function and will return the error returned</span>
<span class="cm"> * by __lpfc_sli_issue_iocb function. This wrapper is used by</span>
<span class="cm"> * functions which do not hold hbalock.</span>
<span class="cm"> **/</span>
<span class="kt">int</span>
<span class="nf">lpfc_sli_issue_iocb</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">ring_number</span><span class="p">,</span>
		    <span class="k">struct</span> <span class="n">lpfc_iocbq</span> <span class="o">*</span><span class="n">piocb</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">flag</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">iflags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">,</span> <span class="n">iflags</span><span class="p">);</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">__lpfc_sli_issue_iocb</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">ring_number</span><span class="p">,</span> <span class="n">piocb</span><span class="p">,</span> <span class="n">flag</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">,</span> <span class="n">iflags</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_extra_ring_setup - Extra ring setup function</span>
<span class="cm"> * @phba: Pointer to HBA context object.</span>
<span class="cm"> *</span>
<span class="cm"> * This function is called while driver attaches with the</span>
<span class="cm"> * HBA to setup the extra ring. The extra ring is used</span>
<span class="cm"> * only when driver needs to support target mode functionality</span>
<span class="cm"> * or IP over FC functionalities.</span>
<span class="cm"> *</span>
<span class="cm"> * This function is called with no lock held.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">lpfc_extra_ring_setup</span><span class="p">(</span> <span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpfc_sli</span> <span class="o">*</span><span class="n">psli</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_sli_ring</span> <span class="o">*</span><span class="n">pring</span><span class="p">;</span>

	<span class="n">psli</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli</span><span class="p">;</span>

	<span class="cm">/* Adjust cmd/rsp ring iocb entries more evenly */</span>

	<span class="cm">/* Take some away from the FCP ring */</span>
	<span class="n">pring</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">psli</span><span class="o">-&gt;</span><span class="n">ring</span><span class="p">[</span><span class="n">psli</span><span class="o">-&gt;</span><span class="n">fcp_ring</span><span class="p">];</span>
	<span class="n">pring</span><span class="o">-&gt;</span><span class="n">numCiocb</span> <span class="o">-=</span> <span class="n">SLI2_IOCB_CMD_R1XTRA_ENTRIES</span><span class="p">;</span>
	<span class="n">pring</span><span class="o">-&gt;</span><span class="n">numRiocb</span> <span class="o">-=</span> <span class="n">SLI2_IOCB_RSP_R1XTRA_ENTRIES</span><span class="p">;</span>
	<span class="n">pring</span><span class="o">-&gt;</span><span class="n">numCiocb</span> <span class="o">-=</span> <span class="n">SLI2_IOCB_CMD_R3XTRA_ENTRIES</span><span class="p">;</span>
	<span class="n">pring</span><span class="o">-&gt;</span><span class="n">numRiocb</span> <span class="o">-=</span> <span class="n">SLI2_IOCB_RSP_R3XTRA_ENTRIES</span><span class="p">;</span>

	<span class="cm">/* and give them to the extra ring */</span>
	<span class="n">pring</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">psli</span><span class="o">-&gt;</span><span class="n">ring</span><span class="p">[</span><span class="n">psli</span><span class="o">-&gt;</span><span class="n">extra_ring</span><span class="p">];</span>

	<span class="n">pring</span><span class="o">-&gt;</span><span class="n">numCiocb</span> <span class="o">+=</span> <span class="n">SLI2_IOCB_CMD_R1XTRA_ENTRIES</span><span class="p">;</span>
	<span class="n">pring</span><span class="o">-&gt;</span><span class="n">numRiocb</span> <span class="o">+=</span> <span class="n">SLI2_IOCB_RSP_R1XTRA_ENTRIES</span><span class="p">;</span>
	<span class="n">pring</span><span class="o">-&gt;</span><span class="n">numCiocb</span> <span class="o">+=</span> <span class="n">SLI2_IOCB_CMD_R3XTRA_ENTRIES</span><span class="p">;</span>
	<span class="n">pring</span><span class="o">-&gt;</span><span class="n">numRiocb</span> <span class="o">+=</span> <span class="n">SLI2_IOCB_RSP_R3XTRA_ENTRIES</span><span class="p">;</span>

	<span class="cm">/* Setup default profile for this ring */</span>
	<span class="n">pring</span><span class="o">-&gt;</span><span class="n">iotag_max</span> <span class="o">=</span> <span class="mi">4096</span><span class="p">;</span>
	<span class="n">pring</span><span class="o">-&gt;</span><span class="n">num_mask</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">pring</span><span class="o">-&gt;</span><span class="n">prt</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">profile</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>      <span class="cm">/* Mask 0 */</span>
	<span class="n">pring</span><span class="o">-&gt;</span><span class="n">prt</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">rctl</span> <span class="o">=</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">cfg_multi_ring_rctl</span><span class="p">;</span>
	<span class="n">pring</span><span class="o">-&gt;</span><span class="n">prt</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">type</span> <span class="o">=</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">cfg_multi_ring_type</span><span class="p">;</span>
	<span class="n">pring</span><span class="o">-&gt;</span><span class="n">prt</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">lpfc_sli_rcv_unsol_event</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* lpfc_sli_abts_recover_port - Recover a port that failed an ABTS.</span>
<span class="cm"> * @vport: pointer to virtual port object.</span>
<span class="cm"> * @ndlp: nodelist pointer for the impacted rport.</span>
<span class="cm"> *</span>
<span class="cm"> * The driver calls this routine in response to a XRI ABORT CQE</span>
<span class="cm"> * event from the port.  In this event, the driver is required to</span>
<span class="cm"> * recover its login to the rport even though its login may be valid</span>
<span class="cm"> * from the driver&#39;s perspective.  The failed ABTS notice from the</span>
<span class="cm"> * port indicates the rport is not responding.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">lpfc_sli_abts_recover_port</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="n">vport</span><span class="p">,</span>
			   <span class="k">struct</span> <span class="n">lpfc_nodelist</span> <span class="o">*</span><span class="n">ndlp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">shost</span> <span class="o">=</span> <span class="n">lpfc_shost_from_vport</span><span class="p">(</span><span class="n">vport</span><span class="p">);</span>
	<span class="n">phba</span> <span class="o">=</span> <span class="n">vport</span><span class="o">-&gt;</span><span class="n">phba</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_state</span> <span class="o">!=</span> <span class="n">NLP_STE_MAPPED_NODE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_INFO</span><span class="p">,</span>
			<span class="n">LOG_SLI</span><span class="p">,</span> <span class="s">&quot;3093 No rport recovery needed. &quot;</span>
			<span class="s">&quot;rport in state 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_state</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_SLI</span><span class="p">,</span>
			<span class="s">&quot;3094 Start rport recovery on shost id 0x%x &quot;</span>
			<span class="s">&quot;fc_id 0x%06x vpi 0x%x rpi 0x%x state 0x%x &quot;</span>
			<span class="s">&quot;flags 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_no</span><span class="p">,</span> <span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_DID</span><span class="p">,</span>
			<span class="n">vport</span><span class="o">-&gt;</span><span class="n">vpi</span><span class="p">,</span> <span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_rpi</span><span class="p">,</span> <span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_state</span><span class="p">,</span>
			<span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_flag</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * The rport is not responding.  Don&#39;t attempt ADISC recovery.</span>
<span class="cm">	 * Remove the FCP-2 flag to force a PLOGI.</span>
<span class="cm">	 */</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_fcp_info</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">NLP_FCP_2_DEVICE</span><span class="p">;</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">lpfc_disc_state_machine</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">ndlp</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span>
				<span class="n">NLP_EVT_DEVICE_RECOVERY</span><span class="p">);</span>
	<span class="n">lpfc_cancel_retry_delay_tmo</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">ndlp</span><span class="p">);</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_flag</span> <span class="o">|=</span> <span class="n">NLP_NPR_2B_DISC</span><span class="p">;</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">lpfc_disc_start</span><span class="p">(</span><span class="n">vport</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* lpfc_sli_abts_err_handler - handle a failed ABTS request from an SLI3 port.</span>
<span class="cm"> * @phba: Pointer to HBA context object.</span>
<span class="cm"> * @iocbq: Pointer to iocb object.</span>
<span class="cm"> *</span>
<span class="cm"> * The async_event handler calls this routine when it receives</span>
<span class="cm"> * an ASYNC_STATUS_CN event from the port.  The port generates</span>
<span class="cm"> * this event when an Abort Sequence request to an rport fails</span>
<span class="cm"> * twice in succession.  The abort could be originated by the</span>
<span class="cm"> * driver or by the port.  The ABTS could have been for an ELS</span>
<span class="cm"> * or FCP IO.  The port only generates this event when an ABTS</span>
<span class="cm"> * fails to complete after one retry.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">lpfc_sli_abts_err_handler</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">,</span>
			  <span class="k">struct</span> <span class="n">lpfc_iocbq</span> <span class="o">*</span><span class="n">iocbq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpfc_nodelist</span> <span class="o">*</span><span class="n">ndlp</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">uint16_t</span> <span class="n">rpi</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">vpi</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="n">vport</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="cm">/* The rpi in the ulpContext is vport-sensitive. */</span>
	<span class="n">vpi</span> <span class="o">=</span> <span class="n">iocbq</span><span class="o">-&gt;</span><span class="n">iocb</span><span class="p">.</span><span class="n">un</span><span class="p">.</span><span class="n">asyncstat</span><span class="p">.</span><span class="n">sub_ctxt_tag</span><span class="p">;</span>
	<span class="n">rpi</span> <span class="o">=</span> <span class="n">iocbq</span><span class="o">-&gt;</span><span class="n">iocb</span><span class="p">.</span><span class="n">ulpContext</span><span class="p">;</span>

	<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_WARNING</span><span class="p">,</span> <span class="n">LOG_SLI</span><span class="p">,</span>
			<span class="s">&quot;3092 Port generated ABTS async event &quot;</span>
			<span class="s">&quot;on vpi %d rpi %d status 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">vpi</span><span class="p">,</span> <span class="n">rpi</span><span class="p">,</span> <span class="n">iocbq</span><span class="o">-&gt;</span><span class="n">iocb</span><span class="p">.</span><span class="n">ulpStatus</span><span class="p">);</span>

	<span class="n">vport</span> <span class="o">=</span> <span class="n">lpfc_find_vport_by_vpid</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">vpi</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">vport</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err_exit</span><span class="p">;</span>
	<span class="n">ndlp</span> <span class="o">=</span> <span class="n">lpfc_findnode_rpi</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">rpi</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ndlp</span> <span class="o">||</span> <span class="o">!</span><span class="n">NLP_CHK_NODE_ACT</span><span class="p">(</span><span class="n">ndlp</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">err_exit</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">iocbq</span><span class="o">-&gt;</span><span class="n">iocb</span><span class="p">.</span><span class="n">ulpStatus</span> <span class="o">==</span> <span class="n">IOSTAT_LOCAL_REJECT</span><span class="p">)</span>
		<span class="n">lpfc_sli_abts_recover_port</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">ndlp</span><span class="p">);</span>
	<span class="k">return</span><span class="p">;</span>

 <span class="nl">err_exit:</span>
	<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_INFO</span><span class="p">,</span> <span class="n">LOG_SLI</span><span class="p">,</span>
			<span class="s">&quot;3095 Event Context not found, no &quot;</span>
			<span class="s">&quot;action on vpi %d rpi %d status 0x%x, reason 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">iocbq</span><span class="o">-&gt;</span><span class="n">iocb</span><span class="p">.</span><span class="n">ulpContext</span><span class="p">,</span> <span class="n">iocbq</span><span class="o">-&gt;</span><span class="n">iocb</span><span class="p">.</span><span class="n">ulpStatus</span><span class="p">,</span>
			<span class="n">vpi</span><span class="p">,</span> <span class="n">rpi</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* lpfc_sli4_abts_err_handler - handle a failed ABTS request from an SLI4 port.</span>
<span class="cm"> * @phba: pointer to HBA context object.</span>
<span class="cm"> * @ndlp: nodelist pointer for the impacted rport.</span>
<span class="cm"> * @axri: pointer to the wcqe containing the failed exchange.</span>
<span class="cm"> *</span>
<span class="cm"> * The driver calls this routine when it receives an ABORT_XRI_FCP CQE from the</span>
<span class="cm"> * port.  The port generates this event when an abort exchange request to an</span>
<span class="cm"> * rport fails twice in succession with no reply.  The abort could be originated</span>
<span class="cm"> * by the driver or by the port.  The ABTS could have been for an ELS or FCP IO.</span>
<span class="cm"> */</span>
<span class="kt">void</span>
<span class="nf">lpfc_sli4_abts_err_handler</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">,</span>
			   <span class="k">struct</span> <span class="n">lpfc_nodelist</span> <span class="o">*</span><span class="n">ndlp</span><span class="p">,</span>
			   <span class="k">struct</span> <span class="n">sli4_wcqe_xri_aborted</span> <span class="o">*</span><span class="n">axri</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="n">vport</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">ext_status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ndlp</span> <span class="o">||</span> <span class="o">!</span><span class="n">NLP_CHK_NODE_ACT</span><span class="p">(</span><span class="n">ndlp</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_INFO</span><span class="p">,</span> <span class="n">LOG_SLI</span><span class="p">,</span>
				<span class="s">&quot;3115 Node Context not found, driver &quot;</span>
				<span class="s">&quot;ignoring abts err event</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">vport</span> <span class="o">=</span> <span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">vport</span><span class="p">;</span>
	<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_WARNING</span><span class="p">,</span> <span class="n">LOG_SLI</span><span class="p">,</span>
			<span class="s">&quot;3116 Port generated FCP XRI ABORT event on &quot;</span>
			<span class="s">&quot;vpi %d rpi %d xri x%x status 0x%x parameter x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">vpi</span><span class="p">,</span> <span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_rpi</span><span class="p">,</span>
			<span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_wcqe_xa_xri</span><span class="p">,</span> <span class="n">axri</span><span class="p">),</span>
			<span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_wcqe_xa_status</span><span class="p">,</span> <span class="n">axri</span><span class="p">),</span>
			<span class="n">axri</span><span class="o">-&gt;</span><span class="n">parameter</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Catch the ABTS protocol failure case.  Older OCe FW releases returned</span>
<span class="cm">	 * LOCAL_REJECT and 0 for a failed ABTS exchange and later OCe and</span>
<span class="cm">	 * LPe FW releases returned LOCAL_REJECT and SEQUENCE_TIMEOUT.</span>
<span class="cm">	 */</span>
	<span class="n">ext_status</span> <span class="o">=</span> <span class="n">axri</span><span class="o">-&gt;</span><span class="n">parameter</span> <span class="o">&amp;</span> <span class="n">WCQE_PARAM_MASK</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_wcqe_xa_status</span><span class="p">,</span> <span class="n">axri</span><span class="p">)</span> <span class="o">==</span> <span class="n">IOSTAT_LOCAL_REJECT</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="p">((</span><span class="n">ext_status</span> <span class="o">==</span> <span class="n">IOERR_SEQUENCE_TIMEOUT</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">ext_status</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)))</span>
		<span class="n">lpfc_sli_abts_recover_port</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">ndlp</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_sli_async_event_handler - ASYNC iocb handler function</span>
<span class="cm"> * @phba: Pointer to HBA context object.</span>
<span class="cm"> * @pring: Pointer to driver SLI ring object.</span>
<span class="cm"> * @iocbq: Pointer to iocb object.</span>
<span class="cm"> *</span>
<span class="cm"> * This function is called by the slow ring event handler</span>
<span class="cm"> * function when there is an ASYNC event iocb in the ring.</span>
<span class="cm"> * This function is called with no lock held.</span>
<span class="cm"> * Currently this function handles only temperature related</span>
<span class="cm"> * ASYNC events. The function decodes the temperature sensor</span>
<span class="cm"> * event message and posts events for the management applications.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">lpfc_sli_async_event_handler</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span> <span class="n">phba</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">lpfc_sli_ring</span> <span class="o">*</span> <span class="n">pring</span><span class="p">,</span> <span class="k">struct</span> <span class="n">lpfc_iocbq</span> <span class="o">*</span> <span class="n">iocbq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">IOCB_t</span> <span class="o">*</span><span class="n">icmd</span><span class="p">;</span>
	<span class="kt">uint16_t</span> <span class="n">evt_code</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">temp_event</span> <span class="n">temp_event_data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="o">*</span><span class="n">iocb_w</span><span class="p">;</span>

	<span class="n">icmd</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">iocbq</span><span class="o">-&gt;</span><span class="n">iocb</span><span class="p">;</span>
	<span class="n">evt_code</span> <span class="o">=</span> <span class="n">icmd</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">asyncstat</span><span class="p">.</span><span class="n">evt_code</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">evt_code</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">ASYNC_TEMP_WARN</span>:
	<span class="k">case</span> <span class="n">ASYNC_TEMP_SAFE</span>:
		<span class="n">temp_event_data</span><span class="p">.</span><span class="n">data</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint32_t</span><span class="p">)</span> <span class="n">icmd</span><span class="o">-&gt;</span><span class="n">ulpContext</span><span class="p">;</span>
		<span class="n">temp_event_data</span><span class="p">.</span><span class="n">event_type</span> <span class="o">=</span> <span class="n">FC_REG_TEMPERATURE_EVENT</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">evt_code</span> <span class="o">==</span> <span class="n">ASYNC_TEMP_WARN</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">temp_event_data</span><span class="p">.</span><span class="n">event_code</span> <span class="o">=</span> <span class="n">LPFC_THRESHOLD_TEMP</span><span class="p">;</span>
			<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_TEMP</span><span class="p">,</span>
				<span class="s">&quot;0347 Adapter is very hot, please take &quot;</span>
				<span class="s">&quot;corrective action. temperature : %d Celsius</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="p">(</span><span class="kt">uint32_t</span><span class="p">)</span> <span class="n">icmd</span><span class="o">-&gt;</span><span class="n">ulpContext</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">temp_event_data</span><span class="p">.</span><span class="n">event_code</span> <span class="o">=</span> <span class="n">LPFC_NORMAL_TEMP</span><span class="p">;</span>
			<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_TEMP</span><span class="p">,</span>
				<span class="s">&quot;0340 Adapter temperature is OK now. &quot;</span>
				<span class="s">&quot;temperature : %d Celsius</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="p">(</span><span class="kt">uint32_t</span><span class="p">)</span> <span class="n">icmd</span><span class="o">-&gt;</span><span class="n">ulpContext</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="cm">/* Send temperature change event to applications */</span>
		<span class="n">shost</span> <span class="o">=</span> <span class="n">lpfc_shost_from_vport</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">pport</span><span class="p">);</span>
		<span class="n">fc_host_post_vendor_event</span><span class="p">(</span><span class="n">shost</span><span class="p">,</span> <span class="n">fc_get_event_number</span><span class="p">(),</span>
			<span class="k">sizeof</span><span class="p">(</span><span class="n">temp_event_data</span><span class="p">),</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">temp_event_data</span><span class="p">,</span>
			<span class="n">LPFC_NL_VENDOR_ID</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">ASYNC_STATUS_CN</span>:
		<span class="n">lpfc_sli_abts_err_handler</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">iocbq</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">iocb_w</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint32_t</span> <span class="o">*</span><span class="p">)</span> <span class="n">icmd</span><span class="p">;</span>
		<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_SLI</span><span class="p">,</span>
			<span class="s">&quot;0346 Ring %d handler: unexpected ASYNC_STATUS&quot;</span>
			<span class="s">&quot; evt_code 0x%x</span><span class="se">\n</span><span class="s">&quot;</span>
			<span class="s">&quot;W0  0x%08x W1  0x%08x W2  0x%08x W3  0x%08x</span><span class="se">\n</span><span class="s">&quot;</span>
			<span class="s">&quot;W4  0x%08x W5  0x%08x W6  0x%08x W7  0x%08x</span><span class="se">\n</span><span class="s">&quot;</span>
			<span class="s">&quot;W8  0x%08x W9  0x%08x W10 0x%08x W11 0x%08x</span><span class="se">\n</span><span class="s">&quot;</span>
			<span class="s">&quot;W12 0x%08x W13 0x%08x W14 0x%08x W15 0x%08x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">pring</span><span class="o">-&gt;</span><span class="n">ringno</span><span class="p">,</span> <span class="n">icmd</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">asyncstat</span><span class="p">.</span><span class="n">evt_code</span><span class="p">,</span>
			<span class="n">iocb_w</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">iocb_w</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">iocb_w</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">iocb_w</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span>
			<span class="n">iocb_w</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span> <span class="n">iocb_w</span><span class="p">[</span><span class="mi">5</span><span class="p">],</span> <span class="n">iocb_w</span><span class="p">[</span><span class="mi">6</span><span class="p">],</span> <span class="n">iocb_w</span><span class="p">[</span><span class="mi">7</span><span class="p">],</span>
			<span class="n">iocb_w</span><span class="p">[</span><span class="mi">8</span><span class="p">],</span> <span class="n">iocb_w</span><span class="p">[</span><span class="mi">9</span><span class="p">],</span> <span class="n">iocb_w</span><span class="p">[</span><span class="mi">10</span><span class="p">],</span> <span class="n">iocb_w</span><span class="p">[</span><span class="mi">11</span><span class="p">],</span>
			<span class="n">iocb_w</span><span class="p">[</span><span class="mi">12</span><span class="p">],</span> <span class="n">iocb_w</span><span class="p">[</span><span class="mi">13</span><span class="p">],</span> <span class="n">iocb_w</span><span class="p">[</span><span class="mi">14</span><span class="p">],</span> <span class="n">iocb_w</span><span class="p">[</span><span class="mi">15</span><span class="p">]);</span>

		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>


<span class="cm">/**</span>
<span class="cm"> * lpfc_sli_setup - SLI ring setup function</span>
<span class="cm"> * @phba: Pointer to HBA context object.</span>
<span class="cm"> *</span>
<span class="cm"> * lpfc_sli_setup sets up rings of the SLI interface with</span>
<span class="cm"> * number of iocbs per ring and iotags. This function is</span>
<span class="cm"> * called while driver attach to the HBA and before the</span>
<span class="cm"> * interrupts are enabled. So there is no need for locking.</span>
<span class="cm"> *</span>
<span class="cm"> * This function always returns 0.</span>
<span class="cm"> **/</span>
<span class="kt">int</span>
<span class="nf">lpfc_sli_setup</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">totiocbsize</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_sli</span> <span class="o">*</span><span class="n">psli</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_sli_ring</span> <span class="o">*</span><span class="n">pring</span><span class="p">;</span>

	<span class="n">psli</span><span class="o">-&gt;</span><span class="n">num_rings</span> <span class="o">=</span> <span class="n">MAX_CONFIGURED_RINGS</span><span class="p">;</span>
	<span class="n">psli</span><span class="o">-&gt;</span><span class="n">sli_flag</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">psli</span><span class="o">-&gt;</span><span class="n">fcp_ring</span> <span class="o">=</span> <span class="n">LPFC_FCP_RING</span><span class="p">;</span>
	<span class="n">psli</span><span class="o">-&gt;</span><span class="n">next_ring</span> <span class="o">=</span> <span class="n">LPFC_FCP_NEXT_RING</span><span class="p">;</span>
	<span class="n">psli</span><span class="o">-&gt;</span><span class="n">extra_ring</span> <span class="o">=</span> <span class="n">LPFC_EXTRA_RING</span><span class="p">;</span>

	<span class="n">psli</span><span class="o">-&gt;</span><span class="n">iocbq_lookup</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">psli</span><span class="o">-&gt;</span><span class="n">iocbq_lookup_len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">psli</span><span class="o">-&gt;</span><span class="n">last_iotag</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">psli</span><span class="o">-&gt;</span><span class="n">num_rings</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pring</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">psli</span><span class="o">-&gt;</span><span class="n">ring</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">LPFC_FCP_RING</span>:	<span class="cm">/* ring 0 - FCP */</span>
			<span class="cm">/* numCiocb and numRiocb are used in config_port */</span>
			<span class="n">pring</span><span class="o">-&gt;</span><span class="n">numCiocb</span> <span class="o">=</span> <span class="n">SLI2_IOCB_CMD_R0_ENTRIES</span><span class="p">;</span>
			<span class="n">pring</span><span class="o">-&gt;</span><span class="n">numRiocb</span> <span class="o">=</span> <span class="n">SLI2_IOCB_RSP_R0_ENTRIES</span><span class="p">;</span>
			<span class="n">pring</span><span class="o">-&gt;</span><span class="n">numCiocb</span> <span class="o">+=</span> <span class="n">SLI2_IOCB_CMD_R1XTRA_ENTRIES</span><span class="p">;</span>
			<span class="n">pring</span><span class="o">-&gt;</span><span class="n">numRiocb</span> <span class="o">+=</span> <span class="n">SLI2_IOCB_RSP_R1XTRA_ENTRIES</span><span class="p">;</span>
			<span class="n">pring</span><span class="o">-&gt;</span><span class="n">numCiocb</span> <span class="o">+=</span> <span class="n">SLI2_IOCB_CMD_R3XTRA_ENTRIES</span><span class="p">;</span>
			<span class="n">pring</span><span class="o">-&gt;</span><span class="n">numRiocb</span> <span class="o">+=</span> <span class="n">SLI2_IOCB_RSP_R3XTRA_ENTRIES</span><span class="p">;</span>
			<span class="n">pring</span><span class="o">-&gt;</span><span class="n">sizeCiocb</span> <span class="o">=</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli_rev</span> <span class="o">==</span> <span class="mi">3</span><span class="p">)</span> <span class="o">?</span>
							<span class="n">SLI3_IOCB_CMD_SIZE</span> <span class="o">:</span>
							<span class="n">SLI2_IOCB_CMD_SIZE</span><span class="p">;</span>
			<span class="n">pring</span><span class="o">-&gt;</span><span class="n">sizeRiocb</span> <span class="o">=</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli_rev</span> <span class="o">==</span> <span class="mi">3</span><span class="p">)</span> <span class="o">?</span>
							<span class="n">SLI3_IOCB_RSP_SIZE</span> <span class="o">:</span>
							<span class="n">SLI2_IOCB_RSP_SIZE</span><span class="p">;</span>
			<span class="n">pring</span><span class="o">-&gt;</span><span class="n">iotag_ctr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">pring</span><span class="o">-&gt;</span><span class="n">iotag_max</span> <span class="o">=</span>
			    <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">cfg_hba_queue_depth</span> <span class="o">*</span> <span class="mi">2</span><span class="p">);</span>
			<span class="n">pring</span><span class="o">-&gt;</span><span class="n">fast_iotag</span> <span class="o">=</span> <span class="n">pring</span><span class="o">-&gt;</span><span class="n">iotag_max</span><span class="p">;</span>
			<span class="n">pring</span><span class="o">-&gt;</span><span class="n">num_mask</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">LPFC_EXTRA_RING</span>:	<span class="cm">/* ring 1 - EXTRA */</span>
			<span class="cm">/* numCiocb and numRiocb are used in config_port */</span>
			<span class="n">pring</span><span class="o">-&gt;</span><span class="n">numCiocb</span> <span class="o">=</span> <span class="n">SLI2_IOCB_CMD_R1_ENTRIES</span><span class="p">;</span>
			<span class="n">pring</span><span class="o">-&gt;</span><span class="n">numRiocb</span> <span class="o">=</span> <span class="n">SLI2_IOCB_RSP_R1_ENTRIES</span><span class="p">;</span>
			<span class="n">pring</span><span class="o">-&gt;</span><span class="n">sizeCiocb</span> <span class="o">=</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli_rev</span> <span class="o">==</span> <span class="mi">3</span><span class="p">)</span> <span class="o">?</span>
							<span class="n">SLI3_IOCB_CMD_SIZE</span> <span class="o">:</span>
							<span class="n">SLI2_IOCB_CMD_SIZE</span><span class="p">;</span>
			<span class="n">pring</span><span class="o">-&gt;</span><span class="n">sizeRiocb</span> <span class="o">=</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli_rev</span> <span class="o">==</span> <span class="mi">3</span><span class="p">)</span> <span class="o">?</span>
							<span class="n">SLI3_IOCB_RSP_SIZE</span> <span class="o">:</span>
							<span class="n">SLI2_IOCB_RSP_SIZE</span><span class="p">;</span>
			<span class="n">pring</span><span class="o">-&gt;</span><span class="n">iotag_max</span> <span class="o">=</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">cfg_hba_queue_depth</span><span class="p">;</span>
			<span class="n">pring</span><span class="o">-&gt;</span><span class="n">num_mask</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">LPFC_ELS_RING</span>:	<span class="cm">/* ring 2 - ELS / CT */</span>
			<span class="cm">/* numCiocb and numRiocb are used in config_port */</span>
			<span class="n">pring</span><span class="o">-&gt;</span><span class="n">numCiocb</span> <span class="o">=</span> <span class="n">SLI2_IOCB_CMD_R2_ENTRIES</span><span class="p">;</span>
			<span class="n">pring</span><span class="o">-&gt;</span><span class="n">numRiocb</span> <span class="o">=</span> <span class="n">SLI2_IOCB_RSP_R2_ENTRIES</span><span class="p">;</span>
			<span class="n">pring</span><span class="o">-&gt;</span><span class="n">sizeCiocb</span> <span class="o">=</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli_rev</span> <span class="o">==</span> <span class="mi">3</span><span class="p">)</span> <span class="o">?</span>
							<span class="n">SLI3_IOCB_CMD_SIZE</span> <span class="o">:</span>
							<span class="n">SLI2_IOCB_CMD_SIZE</span><span class="p">;</span>
			<span class="n">pring</span><span class="o">-&gt;</span><span class="n">sizeRiocb</span> <span class="o">=</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli_rev</span> <span class="o">==</span> <span class="mi">3</span><span class="p">)</span> <span class="o">?</span>
							<span class="n">SLI3_IOCB_RSP_SIZE</span> <span class="o">:</span>
							<span class="n">SLI2_IOCB_RSP_SIZE</span><span class="p">;</span>
			<span class="n">pring</span><span class="o">-&gt;</span><span class="n">fast_iotag</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">pring</span><span class="o">-&gt;</span><span class="n">iotag_ctr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">pring</span><span class="o">-&gt;</span><span class="n">iotag_max</span> <span class="o">=</span> <span class="mi">4096</span><span class="p">;</span>
			<span class="n">pring</span><span class="o">-&gt;</span><span class="n">lpfc_sli_rcv_async_status</span> <span class="o">=</span>
				<span class="n">lpfc_sli_async_event_handler</span><span class="p">;</span>
			<span class="n">pring</span><span class="o">-&gt;</span><span class="n">num_mask</span> <span class="o">=</span> <span class="n">LPFC_MAX_RING_MASK</span><span class="p">;</span>
			<span class="n">pring</span><span class="o">-&gt;</span><span class="n">prt</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">profile</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>	<span class="cm">/* Mask 0 */</span>
			<span class="n">pring</span><span class="o">-&gt;</span><span class="n">prt</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">rctl</span> <span class="o">=</span> <span class="n">FC_RCTL_ELS_REQ</span><span class="p">;</span>
			<span class="n">pring</span><span class="o">-&gt;</span><span class="n">prt</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">type</span> <span class="o">=</span> <span class="n">FC_TYPE_ELS</span><span class="p">;</span>
			<span class="n">pring</span><span class="o">-&gt;</span><span class="n">prt</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">lpfc_sli_rcv_unsol_event</span> <span class="o">=</span>
			    <span class="n">lpfc_els_unsol_event</span><span class="p">;</span>
			<span class="n">pring</span><span class="o">-&gt;</span><span class="n">prt</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">profile</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>	<span class="cm">/* Mask 1 */</span>
			<span class="n">pring</span><span class="o">-&gt;</span><span class="n">prt</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">rctl</span> <span class="o">=</span> <span class="n">FC_RCTL_ELS_REP</span><span class="p">;</span>
			<span class="n">pring</span><span class="o">-&gt;</span><span class="n">prt</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">type</span> <span class="o">=</span> <span class="n">FC_TYPE_ELS</span><span class="p">;</span>
			<span class="n">pring</span><span class="o">-&gt;</span><span class="n">prt</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">lpfc_sli_rcv_unsol_event</span> <span class="o">=</span>
			    <span class="n">lpfc_els_unsol_event</span><span class="p">;</span>
			<span class="n">pring</span><span class="o">-&gt;</span><span class="n">prt</span><span class="p">[</span><span class="mi">2</span><span class="p">].</span><span class="n">profile</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>	<span class="cm">/* Mask 2 */</span>
			<span class="cm">/* NameServer Inquiry */</span>
			<span class="n">pring</span><span class="o">-&gt;</span><span class="n">prt</span><span class="p">[</span><span class="mi">2</span><span class="p">].</span><span class="n">rctl</span> <span class="o">=</span> <span class="n">FC_RCTL_DD_UNSOL_CTL</span><span class="p">;</span>
			<span class="cm">/* NameServer */</span>
			<span class="n">pring</span><span class="o">-&gt;</span><span class="n">prt</span><span class="p">[</span><span class="mi">2</span><span class="p">].</span><span class="n">type</span> <span class="o">=</span> <span class="n">FC_TYPE_CT</span><span class="p">;</span>
			<span class="n">pring</span><span class="o">-&gt;</span><span class="n">prt</span><span class="p">[</span><span class="mi">2</span><span class="p">].</span><span class="n">lpfc_sli_rcv_unsol_event</span> <span class="o">=</span>
			    <span class="n">lpfc_ct_unsol_event</span><span class="p">;</span>
			<span class="n">pring</span><span class="o">-&gt;</span><span class="n">prt</span><span class="p">[</span><span class="mi">3</span><span class="p">].</span><span class="n">profile</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>	<span class="cm">/* Mask 3 */</span>
			<span class="cm">/* NameServer response */</span>
			<span class="n">pring</span><span class="o">-&gt;</span><span class="n">prt</span><span class="p">[</span><span class="mi">3</span><span class="p">].</span><span class="n">rctl</span> <span class="o">=</span> <span class="n">FC_RCTL_DD_SOL_CTL</span><span class="p">;</span>
			<span class="cm">/* NameServer */</span>
			<span class="n">pring</span><span class="o">-&gt;</span><span class="n">prt</span><span class="p">[</span><span class="mi">3</span><span class="p">].</span><span class="n">type</span> <span class="o">=</span> <span class="n">FC_TYPE_CT</span><span class="p">;</span>
			<span class="n">pring</span><span class="o">-&gt;</span><span class="n">prt</span><span class="p">[</span><span class="mi">3</span><span class="p">].</span><span class="n">lpfc_sli_rcv_unsol_event</span> <span class="o">=</span>
			    <span class="n">lpfc_ct_unsol_event</span><span class="p">;</span>
			<span class="cm">/* abort unsolicited sequence */</span>
			<span class="n">pring</span><span class="o">-&gt;</span><span class="n">prt</span><span class="p">[</span><span class="mi">4</span><span class="p">].</span><span class="n">profile</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>	<span class="cm">/* Mask 4 */</span>
			<span class="n">pring</span><span class="o">-&gt;</span><span class="n">prt</span><span class="p">[</span><span class="mi">4</span><span class="p">].</span><span class="n">rctl</span> <span class="o">=</span> <span class="n">FC_RCTL_BA_ABTS</span><span class="p">;</span>
			<span class="n">pring</span><span class="o">-&gt;</span><span class="n">prt</span><span class="p">[</span><span class="mi">4</span><span class="p">].</span><span class="n">type</span> <span class="o">=</span> <span class="n">FC_TYPE_BLS</span><span class="p">;</span>
			<span class="n">pring</span><span class="o">-&gt;</span><span class="n">prt</span><span class="p">[</span><span class="mi">4</span><span class="p">].</span><span class="n">lpfc_sli_rcv_unsol_event</span> <span class="o">=</span>
			    <span class="n">lpfc_sli4_ct_abort_unsol_event</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">totiocbsize</span> <span class="o">+=</span> <span class="p">(</span><span class="n">pring</span><span class="o">-&gt;</span><span class="n">numCiocb</span> <span class="o">*</span> <span class="n">pring</span><span class="o">-&gt;</span><span class="n">sizeCiocb</span><span class="p">)</span> <span class="o">+</span>
				<span class="p">(</span><span class="n">pring</span><span class="o">-&gt;</span><span class="n">numRiocb</span> <span class="o">*</span> <span class="n">pring</span><span class="o">-&gt;</span><span class="n">sizeRiocb</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">totiocbsize</span> <span class="o">&gt;</span> <span class="n">MAX_SLIM_IOCB_SIZE</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Too many cmd / rsp ring entries in SLI2 SLIM */</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;%d:0462 Too many cmd / rsp ring entries in &quot;</span>
		       <span class="s">&quot;SLI2 SLIM Data: x%x x%lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">phba</span><span class="o">-&gt;</span><span class="n">brd_no</span><span class="p">,</span> <span class="n">totiocbsize</span><span class="p">,</span>
		       <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">MAX_SLIM_IOCB_SIZE</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">cfg_multi_ring_support</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span>
		<span class="n">lpfc_extra_ring_setup</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_sli_queue_setup - Queue initialization function</span>
<span class="cm"> * @phba: Pointer to HBA context object.</span>
<span class="cm"> *</span>
<span class="cm"> * lpfc_sli_queue_setup sets up mailbox queues and iocb queues for each</span>
<span class="cm"> * ring. This function also initializes ring indices of each ring.</span>
<span class="cm"> * This function is called during the initialization of the SLI</span>
<span class="cm"> * interface of an HBA.</span>
<span class="cm"> * This function is called with no lock held and always returns</span>
<span class="cm"> * 1.</span>
<span class="cm"> **/</span>
<span class="kt">int</span>
<span class="nf">lpfc_sli_queue_setup</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpfc_sli</span> <span class="o">*</span><span class="n">psli</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_sli_ring</span> <span class="o">*</span><span class="n">pring</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">psli</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli</span><span class="p">;</span>
	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">psli</span><span class="o">-&gt;</span><span class="n">mboxq</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">psli</span><span class="o">-&gt;</span><span class="n">mboxq_cmpl</span><span class="p">);</span>
	<span class="cm">/* Initialize list headers for txq and txcmplq as double linked lists */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">psli</span><span class="o">-&gt;</span><span class="n">num_rings</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pring</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">psli</span><span class="o">-&gt;</span><span class="n">ring</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="n">pring</span><span class="o">-&gt;</span><span class="n">ringno</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
		<span class="n">pring</span><span class="o">-&gt;</span><span class="n">next_cmdidx</span>  <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">pring</span><span class="o">-&gt;</span><span class="n">local_getidx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">pring</span><span class="o">-&gt;</span><span class="n">cmdidx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pring</span><span class="o">-&gt;</span><span class="n">txq</span><span class="p">);</span>
		<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pring</span><span class="o">-&gt;</span><span class="n">txcmplq</span><span class="p">);</span>
		<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pring</span><span class="o">-&gt;</span><span class="n">iocb_continueq</span><span class="p">);</span>
		<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pring</span><span class="o">-&gt;</span><span class="n">iocb_continue_saveq</span><span class="p">);</span>
		<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pring</span><span class="o">-&gt;</span><span class="n">postbufq</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_sli_mbox_sys_flush - Flush mailbox command sub-system</span>
<span class="cm"> * @phba: Pointer to HBA context object.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine flushes the mailbox command subsystem. It will unconditionally</span>
<span class="cm"> * flush all the mailbox commands in the three possible stages in the mailbox</span>
<span class="cm"> * command sub-system: pending mailbox command queue; the outstanding mailbox</span>
<span class="cm"> * command; and completed mailbox command queue. It is caller&#39;s responsibility</span>
<span class="cm"> * to make sure that the driver is in the proper state to flush the mailbox</span>
<span class="cm"> * command sub-system. Namely, the posting of mailbox commands into the</span>
<span class="cm"> * pending mailbox command queue from the various clients must be stopped;</span>
<span class="cm"> * either the HBA is in a state that it will never works on the outstanding</span>
<span class="cm"> * mailbox command (such as in EEH or ERATT conditions) or the outstanding</span>
<span class="cm"> * mailbox command has been completed.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">lpfc_sli_mbox_sys_flush</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">LIST_HEAD</span><span class="p">(</span><span class="n">completions</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">lpfc_sli</span> <span class="o">*</span><span class="n">psli</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli</span><span class="p">;</span>
	<span class="n">LPFC_MBOXQ_t</span> <span class="o">*</span><span class="n">pmb</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">iflag</span><span class="p">;</span>

	<span class="cm">/* Flush all the mailbox commands in the mbox system */</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">,</span> <span class="n">iflag</span><span class="p">);</span>
	<span class="cm">/* The pending mailbox command queue */</span>
	<span class="n">list_splice_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli</span><span class="p">.</span><span class="n">mboxq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">completions</span><span class="p">);</span>
	<span class="cm">/* The outstanding active mailbox command */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">psli</span><span class="o">-&gt;</span><span class="n">mbox_active</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">psli</span><span class="o">-&gt;</span><span class="n">mbox_active</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">completions</span><span class="p">);</span>
		<span class="n">psli</span><span class="o">-&gt;</span><span class="n">mbox_active</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">psli</span><span class="o">-&gt;</span><span class="n">sli_flag</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">LPFC_SLI_MBOX_ACTIVE</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* The completed mailbox command queue */</span>
	<span class="n">list_splice_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli</span><span class="p">.</span><span class="n">mboxq_cmpl</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">completions</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">,</span> <span class="n">iflag</span><span class="p">);</span>

	<span class="cm">/* Return all flushed mailbox commands with MBX_NOT_FINISHED status */</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">completions</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">list_remove_head</span><span class="p">(</span><span class="o">&amp;</span><span class="n">completions</span><span class="p">,</span> <span class="n">pmb</span><span class="p">,</span> <span class="n">LPFC_MBOXQ_t</span><span class="p">,</span> <span class="n">list</span><span class="p">);</span>
		<span class="n">pmb</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">mb</span><span class="p">.</span><span class="n">mbxStatus</span> <span class="o">=</span> <span class="n">MBX_NOT_FINISHED</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pmb</span><span class="o">-&gt;</span><span class="n">mbox_cmpl</span><span class="p">)</span>
			<span class="n">pmb</span><span class="o">-&gt;</span><span class="n">mbox_cmpl</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">pmb</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_sli_host_down - Vport cleanup function</span>
<span class="cm"> * @vport: Pointer to virtual port object.</span>
<span class="cm"> *</span>
<span class="cm"> * lpfc_sli_host_down is called to clean up the resources</span>
<span class="cm"> * associated with a vport before destroying virtual</span>
<span class="cm"> * port data structures.</span>
<span class="cm"> * This function does following operations:</span>
<span class="cm"> * - Free discovery resources associated with this virtual</span>
<span class="cm"> *   port.</span>
<span class="cm"> * - Free iocbs associated with this virtual port in</span>
<span class="cm"> *   the txq.</span>
<span class="cm"> * - Send abort for all iocb commands associated with this</span>
<span class="cm"> *   vport in txcmplq.</span>
<span class="cm"> *</span>
<span class="cm"> * This function is called with no lock held and always returns 1.</span>
<span class="cm"> **/</span>
<span class="kt">int</span>
<span class="nf">lpfc_sli_host_down</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="n">vport</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">LIST_HEAD</span><span class="p">(</span><span class="n">completions</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span> <span class="o">=</span> <span class="n">vport</span><span class="o">-&gt;</span><span class="n">phba</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_sli</span> <span class="o">*</span><span class="n">psli</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_sli_ring</span> <span class="o">*</span><span class="n">pring</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_iocbq</span> <span class="o">*</span><span class="n">iocb</span><span class="p">,</span> <span class="o">*</span><span class="n">next_iocb</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">uint16_t</span> <span class="n">prev_pring_flag</span><span class="p">;</span>

	<span class="n">lpfc_cleanup_discovery_resources</span><span class="p">(</span><span class="n">vport</span><span class="p">);</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">psli</span><span class="o">-&gt;</span><span class="n">num_rings</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pring</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">psli</span><span class="o">-&gt;</span><span class="n">ring</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="n">prev_pring_flag</span> <span class="o">=</span> <span class="n">pring</span><span class="o">-&gt;</span><span class="n">flag</span><span class="p">;</span>
		<span class="cm">/* Only slow rings */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pring</span><span class="o">-&gt;</span><span class="n">ringno</span> <span class="o">==</span> <span class="n">LPFC_ELS_RING</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pring</span><span class="o">-&gt;</span><span class="n">flag</span> <span class="o">|=</span> <span class="n">LPFC_DEFERRED_RING_EVENT</span><span class="p">;</span>
			<span class="cm">/* Set the lpfc data pending flag */</span>
			<span class="n">set_bit</span><span class="p">(</span><span class="n">LPFC_DATA_READY</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">data_flags</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="cm">/*</span>
<span class="cm">		 * Error everything on the txq since these iocbs have not been</span>
<span class="cm">		 * given to the FW yet.</span>
<span class="cm">		 */</span>
		<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">iocb</span><span class="p">,</span> <span class="n">next_iocb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pring</span><span class="o">-&gt;</span><span class="n">txq</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">iocb</span><span class="o">-&gt;</span><span class="n">vport</span> <span class="o">!=</span> <span class="n">vport</span><span class="p">)</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="n">list_move_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iocb</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">completions</span><span class="p">);</span>
			<span class="n">pring</span><span class="o">-&gt;</span><span class="n">txq_cnt</span><span class="o">--</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* Next issue ABTS for everything on the txcmplq */</span>
		<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">iocb</span><span class="p">,</span> <span class="n">next_iocb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pring</span><span class="o">-&gt;</span><span class="n">txcmplq</span><span class="p">,</span>
									<span class="n">list</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">iocb</span><span class="o">-&gt;</span><span class="n">vport</span> <span class="o">!=</span> <span class="n">vport</span><span class="p">)</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="n">lpfc_sli_issue_abort_iotag</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">pring</span><span class="p">,</span> <span class="n">iocb</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="n">pring</span><span class="o">-&gt;</span><span class="n">flag</span> <span class="o">=</span> <span class="n">prev_pring_flag</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="cm">/* Cancel all the IOCBs from the completions list */</span>
	<span class="n">lpfc_sli_cancel_iocbs</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">completions</span><span class="p">,</span> <span class="n">IOSTAT_LOCAL_REJECT</span><span class="p">,</span>
			      <span class="n">IOERR_SLI_DOWN</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_sli_hba_down - Resource cleanup function for the HBA</span>
<span class="cm"> * @phba: Pointer to HBA context object.</span>
<span class="cm"> *</span>
<span class="cm"> * This function cleans up all iocb, buffers, mailbox commands</span>
<span class="cm"> * while shutting down the HBA. This function is called with no</span>
<span class="cm"> * lock held and always returns 1.</span>
<span class="cm"> * This function does the following to cleanup driver resources:</span>
<span class="cm"> * - Free discovery resources for each virtual port</span>
<span class="cm"> * - Cleanup any pending fabric iocbs</span>
<span class="cm"> * - Iterate through the iocb txq and free each entry</span>
<span class="cm"> *   in the list.</span>
<span class="cm"> * - Free up any buffer posted to the HBA</span>
<span class="cm"> * - Free mailbox commands in the mailbox queue.</span>
<span class="cm"> **/</span>
<span class="kt">int</span>
<span class="nf">lpfc_sli_hba_down</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">LIST_HEAD</span><span class="p">(</span><span class="n">completions</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">lpfc_sli</span> <span class="o">*</span><span class="n">psli</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_sli_ring</span> <span class="o">*</span><span class="n">pring</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_dmabuf</span> <span class="o">*</span><span class="n">buf_ptr</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="cm">/* Shutdown the mailbox command sub-system */</span>
	<span class="n">lpfc_sli_mbox_sys_shutdown</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>

	<span class="n">lpfc_hba_down_prep</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>

	<span class="n">lpfc_fabric_abort_hba</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">psli</span><span class="o">-&gt;</span><span class="n">num_rings</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pring</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">psli</span><span class="o">-&gt;</span><span class="n">ring</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="cm">/* Only slow rings */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pring</span><span class="o">-&gt;</span><span class="n">ringno</span> <span class="o">==</span> <span class="n">LPFC_ELS_RING</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pring</span><span class="o">-&gt;</span><span class="n">flag</span> <span class="o">|=</span> <span class="n">LPFC_DEFERRED_RING_EVENT</span><span class="p">;</span>
			<span class="cm">/* Set the lpfc data pending flag */</span>
			<span class="n">set_bit</span><span class="p">(</span><span class="n">LPFC_DATA_READY</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">data_flags</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 * Error everything on the txq since these iocbs have not been</span>
<span class="cm">		 * given to the FW yet.</span>
<span class="cm">		 */</span>
		<span class="n">list_splice_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pring</span><span class="o">-&gt;</span><span class="n">txq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">completions</span><span class="p">);</span>
		<span class="n">pring</span><span class="o">-&gt;</span><span class="n">txq_cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="p">}</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="cm">/* Cancel all the IOCBs from the completions list */</span>
	<span class="n">lpfc_sli_cancel_iocbs</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">completions</span><span class="p">,</span> <span class="n">IOSTAT_LOCAL_REJECT</span><span class="p">,</span>
			      <span class="n">IOERR_SLI_DOWN</span><span class="p">);</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">list_splice_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">elsbuf</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">completions</span><span class="p">);</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">elsbuf_cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">elsbuf_prev_cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">completions</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">list_remove_head</span><span class="p">(</span><span class="o">&amp;</span><span class="n">completions</span><span class="p">,</span> <span class="n">buf_ptr</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">lpfc_dmabuf</span><span class="p">,</span> <span class="n">list</span><span class="p">);</span>
		<span class="n">lpfc_mbuf_free</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">buf_ptr</span><span class="o">-&gt;</span><span class="n">virt</span><span class="p">,</span> <span class="n">buf_ptr</span><span class="o">-&gt;</span><span class="n">phys</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">buf_ptr</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Return any active mbox cmds */</span>
	<span class="n">del_timer_sync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">psli</span><span class="o">-&gt;</span><span class="n">mbox_tmo</span><span class="p">);</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">pport</span><span class="o">-&gt;</span><span class="n">work_port_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">pport</span><span class="o">-&gt;</span><span class="n">work_port_events</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">WORKER_MBOX_TMO</span><span class="p">;</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">pport</span><span class="o">-&gt;</span><span class="n">work_port_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_sli_pcimem_bcopy - SLI memory copy function</span>
<span class="cm"> * @srcp: Source memory pointer.</span>
<span class="cm"> * @destp: Destination memory pointer.</span>
<span class="cm"> * @cnt: Number of words required to be copied.</span>
<span class="cm"> *</span>
<span class="cm"> * This function is used for copying data between driver memory</span>
<span class="cm"> * and the SLI memory. This function also changes the endianness</span>
<span class="cm"> * of each word if native endianness is different from SLI</span>
<span class="cm"> * endianness. This function can be called with or without</span>
<span class="cm"> * lock.</span>
<span class="cm"> **/</span>
<span class="kt">void</span>
<span class="nf">lpfc_sli_pcimem_bcopy</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">srcp</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">destp</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">cnt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">uint32_t</span> <span class="o">*</span><span class="n">src</span> <span class="o">=</span> <span class="n">srcp</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="o">*</span><span class="n">dest</span> <span class="o">=</span> <span class="n">destp</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">ldata</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">cnt</span><span class="p">;</span> <span class="n">i</span> <span class="o">+=</span> <span class="k">sizeof</span> <span class="p">(</span><span class="kt">uint32_t</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ldata</span> <span class="o">=</span> <span class="o">*</span><span class="n">src</span><span class="p">;</span>
		<span class="n">ldata</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">ldata</span><span class="p">);</span>
		<span class="o">*</span><span class="n">dest</span> <span class="o">=</span> <span class="n">ldata</span><span class="p">;</span>
		<span class="n">src</span><span class="o">++</span><span class="p">;</span>
		<span class="n">dest</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>


<span class="cm">/**</span>
<span class="cm"> * lpfc_sli_bemem_bcopy - SLI memory copy function</span>
<span class="cm"> * @srcp: Source memory pointer.</span>
<span class="cm"> * @destp: Destination memory pointer.</span>
<span class="cm"> * @cnt: Number of words required to be copied.</span>
<span class="cm"> *</span>
<span class="cm"> * This function is used for copying data between a data structure</span>
<span class="cm"> * with big endian representation to local endianness.</span>
<span class="cm"> * This function can be called with or without lock.</span>
<span class="cm"> **/</span>
<span class="kt">void</span>
<span class="nf">lpfc_sli_bemem_bcopy</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">srcp</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">destp</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">cnt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">uint32_t</span> <span class="o">*</span><span class="n">src</span> <span class="o">=</span> <span class="n">srcp</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="o">*</span><span class="n">dest</span> <span class="o">=</span> <span class="n">destp</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">ldata</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">cnt</span><span class="p">;</span> <span class="n">i</span> <span class="o">+=</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">uint32_t</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ldata</span> <span class="o">=</span> <span class="o">*</span><span class="n">src</span><span class="p">;</span>
		<span class="n">ldata</span> <span class="o">=</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">ldata</span><span class="p">);</span>
		<span class="o">*</span><span class="n">dest</span> <span class="o">=</span> <span class="n">ldata</span><span class="p">;</span>
		<span class="n">src</span><span class="o">++</span><span class="p">;</span>
		<span class="n">dest</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_sli_ringpostbuf_put - Function to add a buffer to postbufq</span>
<span class="cm"> * @phba: Pointer to HBA context object.</span>
<span class="cm"> * @pring: Pointer to driver SLI ring object.</span>
<span class="cm"> * @mp: Pointer to driver buffer object.</span>
<span class="cm"> *</span>
<span class="cm"> * This function is called with no lock held.</span>
<span class="cm"> * It always return zero after adding the buffer to the postbufq</span>
<span class="cm"> * buffer list.</span>
<span class="cm"> **/</span>
<span class="kt">int</span>
<span class="nf">lpfc_sli_ringpostbuf_put</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">,</span> <span class="k">struct</span> <span class="n">lpfc_sli_ring</span> <span class="o">*</span><span class="n">pring</span><span class="p">,</span>
			 <span class="k">struct</span> <span class="n">lpfc_dmabuf</span> <span class="o">*</span><span class="n">mp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Stick struct lpfc_dmabuf at end of postbufq so driver can look it up</span>
<span class="cm">	   later */</span>
	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>
	<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pring</span><span class="o">-&gt;</span><span class="n">postbufq</span><span class="p">);</span>
	<span class="n">pring</span><span class="o">-&gt;</span><span class="n">postbufq_cnt</span><span class="o">++</span><span class="p">;</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_sli_get_buffer_tag - allocates a tag for a CMD_QUE_XRI64_CX buffer</span>
<span class="cm"> * @phba: Pointer to HBA context object.</span>
<span class="cm"> *</span>
<span class="cm"> * When HBQ is enabled, buffers are searched based on tags. This function</span>
<span class="cm"> * allocates a tag for buffer posted using CMD_QUE_XRI64_CX iocb. The</span>
<span class="cm"> * tag is bit wise or-ed with QUE_BUFTAG_BIT to make sure that the tag</span>
<span class="cm"> * does not conflict with tags of buffer posted for unsolicited events.</span>
<span class="cm"> * The function returns the allocated tag. The function is called with</span>
<span class="cm"> * no locks held.</span>
<span class="cm"> **/</span>
<span class="kt">uint32_t</span>
<span class="nf">lpfc_sli_get_buffer_tag</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">buffer_tag_count</span><span class="o">++</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * Always set the QUE_BUFTAG_BIT to distiguish between</span>
<span class="cm">	 * a tag assigned by HBQ.</span>
<span class="cm">	 */</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">buffer_tag_count</span> <span class="o">|=</span> <span class="n">QUE_BUFTAG_BIT</span><span class="p">;</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">buffer_tag_count</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_sli_ring_taggedbuf_get - find HBQ buffer associated with given tag</span>
<span class="cm"> * @phba: Pointer to HBA context object.</span>
<span class="cm"> * @pring: Pointer to driver SLI ring object.</span>
<span class="cm"> * @tag: Buffer tag.</span>
<span class="cm"> *</span>
<span class="cm"> * Buffers posted using CMD_QUE_XRI64_CX iocb are in pring-&gt;postbufq</span>
<span class="cm"> * list. After HBA DMA data to these buffers, CMD_IOCB_RET_XRI64_CX</span>
<span class="cm"> * iocb is posted to the response ring with the tag of the buffer.</span>
<span class="cm"> * This function searches the pring-&gt;postbufq list using the tag</span>
<span class="cm"> * to find buffer associated with CMD_IOCB_RET_XRI64_CX</span>
<span class="cm"> * iocb. If the buffer is found then lpfc_dmabuf object of the</span>
<span class="cm"> * buffer is returned to the caller else NULL is returned.</span>
<span class="cm"> * This function is called with no lock held.</span>
<span class="cm"> **/</span>
<span class="k">struct</span> <span class="n">lpfc_dmabuf</span> <span class="o">*</span>
<span class="nf">lpfc_sli_ring_taggedbuf_get</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">,</span> <span class="k">struct</span> <span class="n">lpfc_sli_ring</span> <span class="o">*</span><span class="n">pring</span><span class="p">,</span>
			<span class="kt">uint32_t</span> <span class="n">tag</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpfc_dmabuf</span> <span class="o">*</span><span class="n">mp</span><span class="p">,</span> <span class="o">*</span><span class="n">next_mp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">slp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">pring</span><span class="o">-&gt;</span><span class="n">postbufq</span><span class="p">;</span>

	<span class="cm">/* Search postbufq, from the beginning, looking for a match on tag */</span>
	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>
	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">next_mp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pring</span><span class="o">-&gt;</span><span class="n">postbufq</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">buffer_tag</span> <span class="o">==</span> <span class="n">tag</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
			<span class="n">pring</span><span class="o">-&gt;</span><span class="n">postbufq_cnt</span><span class="o">--</span><span class="p">;</span>
			<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">mp</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>
	<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_INIT</span><span class="p">,</span>
			<span class="s">&quot;0402 Cannot find virtual addr for buffer tag on &quot;</span>
			<span class="s">&quot;ring %d Data x%lx x%p x%p x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">pring</span><span class="o">-&gt;</span><span class="n">ringno</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">tag</span><span class="p">,</span>
			<span class="n">slp</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">,</span> <span class="n">slp</span><span class="o">-&gt;</span><span class="n">prev</span><span class="p">,</span> <span class="n">pring</span><span class="o">-&gt;</span><span class="n">postbufq_cnt</span><span class="p">);</span>

	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_sli_ringpostbuf_get - search buffers for unsolicited CT and ELS events</span>
<span class="cm"> * @phba: Pointer to HBA context object.</span>
<span class="cm"> * @pring: Pointer to driver SLI ring object.</span>
<span class="cm"> * @phys: DMA address of the buffer.</span>
<span class="cm"> *</span>
<span class="cm"> * This function searches the buffer list using the dma_address</span>
<span class="cm"> * of unsolicited event to find the driver&#39;s lpfc_dmabuf object</span>
<span class="cm"> * corresponding to the dma_address. The function returns the</span>
<span class="cm"> * lpfc_dmabuf object if a buffer is found else it returns NULL.</span>
<span class="cm"> * This function is called by the ct and els unsolicited event</span>
<span class="cm"> * handlers to get the buffer associated with the unsolicited</span>
<span class="cm"> * event.</span>
<span class="cm"> *</span>
<span class="cm"> * This function is called with no lock held.</span>
<span class="cm"> **/</span>
<span class="k">struct</span> <span class="n">lpfc_dmabuf</span> <span class="o">*</span>
<span class="nf">lpfc_sli_ringpostbuf_get</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">,</span> <span class="k">struct</span> <span class="n">lpfc_sli_ring</span> <span class="o">*</span><span class="n">pring</span><span class="p">,</span>
			 <span class="n">dma_addr_t</span> <span class="n">phys</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpfc_dmabuf</span> <span class="o">*</span><span class="n">mp</span><span class="p">,</span> <span class="o">*</span><span class="n">next_mp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">slp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">pring</span><span class="o">-&gt;</span><span class="n">postbufq</span><span class="p">;</span>

	<span class="cm">/* Search postbufq, from the beginning, looking for a match on phys */</span>
	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>
	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">next_mp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pring</span><span class="o">-&gt;</span><span class="n">postbufq</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">phys</span> <span class="o">==</span> <span class="n">phys</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
			<span class="n">pring</span><span class="o">-&gt;</span><span class="n">postbufq_cnt</span><span class="o">--</span><span class="p">;</span>
			<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">mp</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>
	<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_INIT</span><span class="p">,</span>
			<span class="s">&quot;0410 Cannot find virtual addr for mapped buf on &quot;</span>
			<span class="s">&quot;ring %d Data x%llx x%p x%p x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">pring</span><span class="o">-&gt;</span><span class="n">ringno</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">phys</span><span class="p">,</span>
			<span class="n">slp</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">,</span> <span class="n">slp</span><span class="o">-&gt;</span><span class="n">prev</span><span class="p">,</span> <span class="n">pring</span><span class="o">-&gt;</span><span class="n">postbufq_cnt</span><span class="p">);</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_sli_abort_els_cmpl - Completion handler for the els abort iocbs</span>
<span class="cm"> * @phba: Pointer to HBA context object.</span>
<span class="cm"> * @cmdiocb: Pointer to driver command iocb object.</span>
<span class="cm"> * @rspiocb: Pointer to driver response iocb object.</span>
<span class="cm"> *</span>
<span class="cm"> * This function is the completion handler for the abort iocbs for</span>
<span class="cm"> * ELS commands. This function is called from the ELS ring event</span>
<span class="cm"> * handler with no lock held. This function frees memory resources</span>
<span class="cm"> * associated with the abort iocb.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">lpfc_sli_abort_els_cmpl</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">,</span> <span class="k">struct</span> <span class="n">lpfc_iocbq</span> <span class="o">*</span><span class="n">cmdiocb</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">lpfc_iocbq</span> <span class="o">*</span><span class="n">rspiocb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">IOCB_t</span> <span class="o">*</span><span class="n">irsp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">rspiocb</span><span class="o">-&gt;</span><span class="n">iocb</span><span class="p">;</span>
	<span class="kt">uint16_t</span> <span class="n">abort_iotag</span><span class="p">,</span> <span class="n">abort_context</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_iocbq</span> <span class="o">*</span><span class="n">abort_iocb</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">irsp</span><span class="o">-&gt;</span><span class="n">ulpStatus</span><span class="p">)</span> <span class="p">{</span>

		<span class="cm">/*</span>
<span class="cm">		 * Assume that the port already completed and returned, or</span>
<span class="cm">		 * will return the iocb. Just Log the message.</span>
<span class="cm">		 */</span>
		<span class="n">abort_context</span> <span class="o">=</span> <span class="n">cmdiocb</span><span class="o">-&gt;</span><span class="n">iocb</span><span class="p">.</span><span class="n">un</span><span class="p">.</span><span class="n">acxri</span><span class="p">.</span><span class="n">abortContextTag</span><span class="p">;</span>
		<span class="n">abort_iotag</span> <span class="o">=</span> <span class="n">cmdiocb</span><span class="o">-&gt;</span><span class="n">iocb</span><span class="p">.</span><span class="n">un</span><span class="p">.</span><span class="n">acxri</span><span class="p">.</span><span class="n">abortIoTag</span><span class="p">;</span>

		<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli_rev</span> <span class="o">&lt;</span> <span class="n">LPFC_SLI_REV4</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">abort_iotag</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span>
				<span class="n">abort_iotag</span> <span class="o">&lt;=</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli</span><span class="p">.</span><span class="n">last_iotag</span><span class="p">)</span>
				<span class="n">abort_iocb</span> <span class="o">=</span>
					<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli</span><span class="p">.</span><span class="n">iocbq_lookup</span><span class="p">[</span><span class="n">abort_iotag</span><span class="p">];</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="cm">/* For sli4 the abort_tag is the XRI,</span>
<span class="cm">			 * so the abort routine puts the iotag  of the iocb</span>
<span class="cm">			 * being aborted in the context field of the abort</span>
<span class="cm">			 * IOCB.</span>
<span class="cm">			 */</span>
			<span class="n">abort_iocb</span> <span class="o">=</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli</span><span class="p">.</span><span class="n">iocbq_lookup</span><span class="p">[</span><span class="n">abort_context</span><span class="p">];</span>

		<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_WARNING</span><span class="p">,</span> <span class="n">LOG_ELS</span> <span class="o">|</span> <span class="n">LOG_SLI</span><span class="p">,</span>
				<span class="s">&quot;0327 Cannot abort els iocb %p &quot;</span>
				<span class="s">&quot;with tag %x context %x, abort status %x, &quot;</span>
				<span class="s">&quot;abort code %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">abort_iocb</span><span class="p">,</span> <span class="n">abort_iotag</span><span class="p">,</span> <span class="n">abort_context</span><span class="p">,</span>
				<span class="n">irsp</span><span class="o">-&gt;</span><span class="n">ulpStatus</span><span class="p">,</span> <span class="n">irsp</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">ulpWord</span><span class="p">[</span><span class="mi">4</span><span class="p">]);</span>

		<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">lpfc_sli_release_iocbq</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">cmdiocb</span><span class="p">);</span>
	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_ignore_els_cmpl - Completion handler for aborted ELS command</span>
<span class="cm"> * @phba: Pointer to HBA context object.</span>
<span class="cm"> * @cmdiocb: Pointer to driver command iocb object.</span>
<span class="cm"> * @rspiocb: Pointer to driver response iocb object.</span>
<span class="cm"> *</span>
<span class="cm"> * The function is called from SLI ring event handler with no</span>
<span class="cm"> * lock held. This function is the completion handler for ELS commands</span>
<span class="cm"> * which are aborted. The function frees memory resources used for</span>
<span class="cm"> * the aborted ELS commands.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">lpfc_ignore_els_cmpl</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">,</span> <span class="k">struct</span> <span class="n">lpfc_iocbq</span> <span class="o">*</span><span class="n">cmdiocb</span><span class="p">,</span>
		     <span class="k">struct</span> <span class="n">lpfc_iocbq</span> <span class="o">*</span><span class="n">rspiocb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">IOCB_t</span> <span class="o">*</span><span class="n">irsp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">rspiocb</span><span class="o">-&gt;</span><span class="n">iocb</span><span class="p">;</span>

	<span class="cm">/* ELS cmd tag &lt;ulpIoTag&gt; completes */</span>
	<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_INFO</span><span class="p">,</span> <span class="n">LOG_ELS</span><span class="p">,</span>
			<span class="s">&quot;0139 Ignoring ELS cmd tag x%x completion Data: &quot;</span>
			<span class="s">&quot;x%x x%x x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">irsp</span><span class="o">-&gt;</span><span class="n">ulpIoTag</span><span class="p">,</span> <span class="n">irsp</span><span class="o">-&gt;</span><span class="n">ulpStatus</span><span class="p">,</span>
			<span class="n">irsp</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">ulpWord</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span> <span class="n">irsp</span><span class="o">-&gt;</span><span class="n">ulpTimeout</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cmdiocb</span><span class="o">-&gt;</span><span class="n">iocb</span><span class="p">.</span><span class="n">ulpCommand</span> <span class="o">==</span> <span class="n">CMD_GEN_REQUEST64_CR</span><span class="p">)</span>
		<span class="n">lpfc_ct_free_iocb</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">cmdiocb</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">lpfc_els_free_iocb</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">cmdiocb</span><span class="p">);</span>
	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_sli_abort_iotag_issue - Issue abort for a command iocb</span>
<span class="cm"> * @phba: Pointer to HBA context object.</span>
<span class="cm"> * @pring: Pointer to driver SLI ring object.</span>
<span class="cm"> * @cmdiocb: Pointer to driver command iocb object.</span>
<span class="cm"> *</span>
<span class="cm"> * This function issues an abort iocb for the provided command iocb down to</span>
<span class="cm"> * the port. Other than the case the outstanding command iocb is an abort</span>
<span class="cm"> * request, this function issues abort out unconditionally. This function is</span>
<span class="cm"> * called with hbalock held. The function returns 0 when it fails due to</span>
<span class="cm"> * memory allocation failure or when the command iocb is an abort request.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">lpfc_sli_abort_iotag_issue</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">,</span> <span class="k">struct</span> <span class="n">lpfc_sli_ring</span> <span class="o">*</span><span class="n">pring</span><span class="p">,</span>
			   <span class="k">struct</span> <span class="n">lpfc_iocbq</span> <span class="o">*</span><span class="n">cmdiocb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="n">vport</span> <span class="o">=</span> <span class="n">cmdiocb</span><span class="o">-&gt;</span><span class="n">vport</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_iocbq</span> <span class="o">*</span><span class="n">abtsiocbp</span><span class="p">;</span>
	<span class="n">IOCB_t</span> <span class="o">*</span><span class="n">icmd</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">IOCB_t</span> <span class="o">*</span><span class="n">iabt</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">retval</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * There are certain command types we don&#39;t want to abort.  And we</span>
<span class="cm">	 * don&#39;t want to abort commands that are already in the process of</span>
<span class="cm">	 * being aborted.</span>
<span class="cm">	 */</span>
	<span class="n">icmd</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">cmdiocb</span><span class="o">-&gt;</span><span class="n">iocb</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">icmd</span><span class="o">-&gt;</span><span class="n">ulpCommand</span> <span class="o">==</span> <span class="n">CMD_ABORT_XRI_CN</span> <span class="o">||</span>
	    <span class="n">icmd</span><span class="o">-&gt;</span><span class="n">ulpCommand</span> <span class="o">==</span> <span class="n">CMD_CLOSE_XRI_CN</span> <span class="o">||</span>
	    <span class="p">(</span><span class="n">cmdiocb</span><span class="o">-&gt;</span><span class="n">iocb_flag</span> <span class="o">&amp;</span> <span class="n">LPFC_DRIVER_ABORTED</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* issue ABTS for this IOCB based on iotag */</span>
	<span class="n">abtsiocbp</span> <span class="o">=</span> <span class="n">__lpfc_sli_get_iocbq</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">abtsiocbp</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* This signals the response to set the correct status</span>
<span class="cm">	 * before calling the completion handler</span>
<span class="cm">	 */</span>
	<span class="n">cmdiocb</span><span class="o">-&gt;</span><span class="n">iocb_flag</span> <span class="o">|=</span> <span class="n">LPFC_DRIVER_ABORTED</span><span class="p">;</span>

	<span class="n">iabt</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">abtsiocbp</span><span class="o">-&gt;</span><span class="n">iocb</span><span class="p">;</span>
	<span class="n">iabt</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">acxri</span><span class="p">.</span><span class="n">abortType</span> <span class="o">=</span> <span class="n">ABORT_TYPE_ABTS</span><span class="p">;</span>
	<span class="n">iabt</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">acxri</span><span class="p">.</span><span class="n">abortContextTag</span> <span class="o">=</span> <span class="n">icmd</span><span class="o">-&gt;</span><span class="n">ulpContext</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli_rev</span> <span class="o">==</span> <span class="n">LPFC_SLI_REV4</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">iabt</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">acxri</span><span class="p">.</span><span class="n">abortIoTag</span> <span class="o">=</span> <span class="n">cmdiocb</span><span class="o">-&gt;</span><span class="n">sli4_xritag</span><span class="p">;</span>
		<span class="n">iabt</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">acxri</span><span class="p">.</span><span class="n">abortContextTag</span> <span class="o">=</span> <span class="n">cmdiocb</span><span class="o">-&gt;</span><span class="n">iotag</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">else</span>
		<span class="n">iabt</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">acxri</span><span class="p">.</span><span class="n">abortIoTag</span> <span class="o">=</span> <span class="n">icmd</span><span class="o">-&gt;</span><span class="n">ulpIoTag</span><span class="p">;</span>
	<span class="n">iabt</span><span class="o">-&gt;</span><span class="n">ulpLe</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">iabt</span><span class="o">-&gt;</span><span class="n">ulpClass</span> <span class="o">=</span> <span class="n">icmd</span><span class="o">-&gt;</span><span class="n">ulpClass</span><span class="p">;</span>

	<span class="cm">/* ABTS WQE must go to the same WQ as the WQE to be aborted */</span>
	<span class="n">abtsiocbp</span><span class="o">-&gt;</span><span class="n">fcp_wqidx</span> <span class="o">=</span> <span class="n">cmdiocb</span><span class="o">-&gt;</span><span class="n">fcp_wqidx</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cmdiocb</span><span class="o">-&gt;</span><span class="n">iocb_flag</span> <span class="o">&amp;</span> <span class="n">LPFC_IO_FCP</span><span class="p">)</span>
		<span class="n">abtsiocbp</span><span class="o">-&gt;</span><span class="n">iocb_flag</span> <span class="o">|=</span> <span class="n">LPFC_USE_FCPWQIDX</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">link_state</span> <span class="o">&gt;=</span> <span class="n">LPFC_LINK_UP</span><span class="p">)</span>
		<span class="n">iabt</span><span class="o">-&gt;</span><span class="n">ulpCommand</span> <span class="o">=</span> <span class="n">CMD_ABORT_XRI_CN</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">iabt</span><span class="o">-&gt;</span><span class="n">ulpCommand</span> <span class="o">=</span> <span class="n">CMD_CLOSE_XRI_CN</span><span class="p">;</span>

	<span class="n">abtsiocbp</span><span class="o">-&gt;</span><span class="n">iocb_cmpl</span> <span class="o">=</span> <span class="n">lpfc_sli_abort_els_cmpl</span><span class="p">;</span>

	<span class="n">lpfc_printf_vlog</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">KERN_INFO</span><span class="p">,</span> <span class="n">LOG_SLI</span><span class="p">,</span>
			 <span class="s">&quot;0339 Abort xri x%x, original iotag x%x, &quot;</span>
			 <span class="s">&quot;abort cmd iotag x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			 <span class="n">iabt</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">acxri</span><span class="p">.</span><span class="n">abortIoTag</span><span class="p">,</span>
			 <span class="n">iabt</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">acxri</span><span class="p">.</span><span class="n">abortContextTag</span><span class="p">,</span>
			 <span class="n">abtsiocbp</span><span class="o">-&gt;</span><span class="n">iotag</span><span class="p">);</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="n">__lpfc_sli_issue_iocb</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">pring</span><span class="o">-&gt;</span><span class="n">ringno</span><span class="p">,</span> <span class="n">abtsiocbp</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span><span class="p">)</span>
		<span class="n">__lpfc_sli_release_iocbq</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">abtsiocbp</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Caller to this routine should check for IOCB_ERROR</span>
<span class="cm">	 * and handle it properly.  This routine no longer removes</span>
<span class="cm">	 * iocb off txcmplq and call compl in case of IOCB_ERROR.</span>
<span class="cm">	 */</span>
	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_sli_issue_abort_iotag - Abort function for a command iocb</span>
<span class="cm"> * @phba: Pointer to HBA context object.</span>
<span class="cm"> * @pring: Pointer to driver SLI ring object.</span>
<span class="cm"> * @cmdiocb: Pointer to driver command iocb object.</span>
<span class="cm"> *</span>
<span class="cm"> * This function issues an abort iocb for the provided command iocb. In case</span>
<span class="cm"> * of unloading, the abort iocb will not be issued to commands on the ELS</span>
<span class="cm"> * ring. Instead, the callback function shall be changed to those commands</span>
<span class="cm"> * so that nothing happens when them finishes. This function is called with</span>
<span class="cm"> * hbalock held. The function returns 0 when the command iocb is an abort</span>
<span class="cm"> * request.</span>
<span class="cm"> **/</span>
<span class="kt">int</span>
<span class="nf">lpfc_sli_issue_abort_iotag</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">,</span> <span class="k">struct</span> <span class="n">lpfc_sli_ring</span> <span class="o">*</span><span class="n">pring</span><span class="p">,</span>
			   <span class="k">struct</span> <span class="n">lpfc_iocbq</span> <span class="o">*</span><span class="n">cmdiocb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="n">vport</span> <span class="o">=</span> <span class="n">cmdiocb</span><span class="o">-&gt;</span><span class="n">vport</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">retval</span> <span class="o">=</span> <span class="n">IOCB_ERROR</span><span class="p">;</span>
	<span class="n">IOCB_t</span> <span class="o">*</span><span class="n">icmd</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * There are certain command types we don&#39;t want to abort.  And we</span>
<span class="cm">	 * don&#39;t want to abort commands that are already in the process of</span>
<span class="cm">	 * being aborted.</span>
<span class="cm">	 */</span>
	<span class="n">icmd</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">cmdiocb</span><span class="o">-&gt;</span><span class="n">iocb</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">icmd</span><span class="o">-&gt;</span><span class="n">ulpCommand</span> <span class="o">==</span> <span class="n">CMD_ABORT_XRI_CN</span> <span class="o">||</span>
	    <span class="n">icmd</span><span class="o">-&gt;</span><span class="n">ulpCommand</span> <span class="o">==</span> <span class="n">CMD_CLOSE_XRI_CN</span> <span class="o">||</span>
	    <span class="p">(</span><span class="n">cmdiocb</span><span class="o">-&gt;</span><span class="n">iocb_flag</span> <span class="o">&amp;</span> <span class="n">LPFC_DRIVER_ABORTED</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * If we&#39;re unloading, don&#39;t abort iocb on the ELS ring, but change</span>
<span class="cm">	 * the callback so that nothing happens when it finishes.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">load_flag</span> <span class="o">&amp;</span> <span class="n">FC_UNLOADING</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">pring</span><span class="o">-&gt;</span><span class="n">ringno</span> <span class="o">==</span> <span class="n">LPFC_ELS_RING</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cmdiocb</span><span class="o">-&gt;</span><span class="n">iocb_flag</span> <span class="o">&amp;</span> <span class="n">LPFC_IO_FABRIC</span><span class="p">)</span>
			<span class="n">cmdiocb</span><span class="o">-&gt;</span><span class="n">fabric_iocb_cmpl</span> <span class="o">=</span> <span class="n">lpfc_ignore_els_cmpl</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">cmdiocb</span><span class="o">-&gt;</span><span class="n">iocb_cmpl</span> <span class="o">=</span> <span class="n">lpfc_ignore_els_cmpl</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">abort_iotag_exit</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Now, we try to issue the abort to the cmdiocb out */</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="n">lpfc_sli_abort_iotag_issue</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">pring</span><span class="p">,</span> <span class="n">cmdiocb</span><span class="p">);</span>

<span class="nl">abort_iotag_exit:</span>
	<span class="cm">/*</span>
<span class="cm">	 * Caller to this routine should check for IOCB_ERROR</span>
<span class="cm">	 * and handle it properly.  This routine no longer removes</span>
<span class="cm">	 * iocb off txcmplq and call compl in case of IOCB_ERROR.</span>
<span class="cm">	 */</span>
	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_sli_iocb_ring_abort - Unconditionally abort all iocbs on an iocb ring</span>
<span class="cm"> * @phba: Pointer to HBA context object.</span>
<span class="cm"> * @pring: Pointer to driver SLI ring object.</span>
<span class="cm"> *</span>
<span class="cm"> * This function aborts all iocbs in the given ring and frees all the iocb</span>
<span class="cm"> * objects in txq. This function issues abort iocbs unconditionally for all</span>
<span class="cm"> * the iocb commands in txcmplq. The iocbs in the txcmplq is not guaranteed</span>
<span class="cm"> * to complete before the return of this function. The caller is not required</span>
<span class="cm"> * to hold any locks.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">lpfc_sli_iocb_ring_abort</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">,</span> <span class="k">struct</span> <span class="n">lpfc_sli_ring</span> <span class="o">*</span><span class="n">pring</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">LIST_HEAD</span><span class="p">(</span><span class="n">completions</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">lpfc_iocbq</span> <span class="o">*</span><span class="n">iocb</span><span class="p">,</span> <span class="o">*</span><span class="n">next_iocb</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pring</span><span class="o">-&gt;</span><span class="n">ringno</span> <span class="o">==</span> <span class="n">LPFC_ELS_RING</span><span class="p">)</span>
		<span class="n">lpfc_fabric_abort_hba</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>

	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>

	<span class="cm">/* Take off all the iocbs on txq for cancelling */</span>
	<span class="n">list_splice_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pring</span><span class="o">-&gt;</span><span class="n">txq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">completions</span><span class="p">);</span>
	<span class="n">pring</span><span class="o">-&gt;</span><span class="n">txq_cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Next issue ABTS for everything on the txcmplq */</span>
	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">iocb</span><span class="p">,</span> <span class="n">next_iocb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pring</span><span class="o">-&gt;</span><span class="n">txcmplq</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span>
		<span class="n">lpfc_sli_abort_iotag_issue</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">pring</span><span class="p">,</span> <span class="n">iocb</span><span class="p">);</span>

	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>

	<span class="cm">/* Cancel all the IOCBs from the completions list */</span>
	<span class="n">lpfc_sli_cancel_iocbs</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">completions</span><span class="p">,</span> <span class="n">IOSTAT_LOCAL_REJECT</span><span class="p">,</span>
			      <span class="n">IOERR_SLI_ABORTED</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_sli_hba_iocb_abort - Abort all iocbs to an hba.</span>
<span class="cm"> * @phba: pointer to lpfc HBA data structure.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine will abort all pending and outstanding iocbs to an HBA.</span>
<span class="cm"> **/</span>
<span class="kt">void</span>
<span class="nf">lpfc_sli_hba_iocb_abort</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpfc_sli</span> <span class="o">*</span><span class="n">psli</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_sli_ring</span> <span class="o">*</span><span class="n">pring</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">psli</span><span class="o">-&gt;</span><span class="n">num_rings</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pring</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">psli</span><span class="o">-&gt;</span><span class="n">ring</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="n">lpfc_sli_iocb_ring_abort</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">pring</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_sli_validate_fcp_iocb - find commands associated with a vport or LUN</span>
<span class="cm"> * @iocbq: Pointer to driver iocb object.</span>
<span class="cm"> * @vport: Pointer to driver virtual port object.</span>
<span class="cm"> * @tgt_id: SCSI ID of the target.</span>
<span class="cm"> * @lun_id: LUN ID of the scsi device.</span>
<span class="cm"> * @ctx_cmd: LPFC_CTX_LUN/LPFC_CTX_TGT/LPFC_CTX_HOST</span>
<span class="cm"> *</span>
<span class="cm"> * This function acts as an iocb filter for functions which abort or count</span>
<span class="cm"> * all FCP iocbs pending on a lun/SCSI target/SCSI host. It will return</span>
<span class="cm"> * 0 if the filtering criteria is met for the given iocb and will return</span>
<span class="cm"> * 1 if the filtering criteria is not met.</span>
<span class="cm"> * If ctx_cmd == LPFC_CTX_LUN, the function returns 0 only if the</span>
<span class="cm"> * given iocb is for the SCSI device specified by vport, tgt_id and</span>
<span class="cm"> * lun_id parameter.</span>
<span class="cm"> * If ctx_cmd == LPFC_CTX_TGT,  the function returns 0 only if the</span>
<span class="cm"> * given iocb is for the SCSI target specified by vport and tgt_id</span>
<span class="cm"> * parameters.</span>
<span class="cm"> * If ctx_cmd == LPFC_CTX_HOST, the function returns 0 only if the</span>
<span class="cm"> * given iocb is for the SCSI host associated with the given vport.</span>
<span class="cm"> * This function is called with no locks held.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">lpfc_sli_validate_fcp_iocb</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_iocbq</span> <span class="o">*</span><span class="n">iocbq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="n">vport</span><span class="p">,</span>
			   <span class="kt">uint16_t</span> <span class="n">tgt_id</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="n">lun_id</span><span class="p">,</span>
			   <span class="n">lpfc_ctx_cmd</span> <span class="n">ctx_cmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpfc_scsi_buf</span> <span class="o">*</span><span class="n">lpfc_cmd</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">iocbq</span><span class="o">-&gt;</span><span class="n">iocb_flag</span> <span class="o">&amp;</span>  <span class="n">LPFC_IO_FCP</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">iocbq</span><span class="o">-&gt;</span><span class="n">vport</span> <span class="o">!=</span> <span class="n">vport</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">lpfc_cmd</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">iocbq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">lpfc_scsi_buf</span><span class="p">,</span> <span class="n">cur_iocbq</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">lpfc_cmd</span><span class="o">-&gt;</span><span class="n">pCmd</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">ctx_cmd</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">LPFC_CTX_LUN</span>:
		<span class="k">if</span> <span class="p">((</span><span class="n">lpfc_cmd</span><span class="o">-&gt;</span><span class="n">rdata</span><span class="o">-&gt;</span><span class="n">pnode</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="p">(</span><span class="n">lpfc_cmd</span><span class="o">-&gt;</span><span class="n">rdata</span><span class="o">-&gt;</span><span class="n">pnode</span><span class="o">-&gt;</span><span class="n">nlp_sid</span> <span class="o">==</span> <span class="n">tgt_id</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="p">(</span><span class="n">scsilun_to_int</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lpfc_cmd</span><span class="o">-&gt;</span><span class="n">fcp_cmnd</span><span class="o">-&gt;</span><span class="n">fcp_lun</span><span class="p">)</span> <span class="o">==</span> <span class="n">lun_id</span><span class="p">))</span>
			<span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">LPFC_CTX_TGT</span>:
		<span class="k">if</span> <span class="p">((</span><span class="n">lpfc_cmd</span><span class="o">-&gt;</span><span class="n">rdata</span><span class="o">-&gt;</span><span class="n">pnode</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="p">(</span><span class="n">lpfc_cmd</span><span class="o">-&gt;</span><span class="n">rdata</span><span class="o">-&gt;</span><span class="n">pnode</span><span class="o">-&gt;</span><span class="n">nlp_sid</span> <span class="o">==</span> <span class="n">tgt_id</span><span class="p">))</span>
			<span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">LPFC_CTX_HOST</span>:
		<span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;%s: Unknown context cmd type, value %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">__func__</span><span class="p">,</span> <span class="n">ctx_cmd</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_sli_sum_iocb - Function to count the number of FCP iocbs pending</span>
<span class="cm"> * @vport: Pointer to virtual port.</span>
<span class="cm"> * @tgt_id: SCSI ID of the target.</span>
<span class="cm"> * @lun_id: LUN ID of the scsi device.</span>
<span class="cm"> * @ctx_cmd: LPFC_CTX_LUN/LPFC_CTX_TGT/LPFC_CTX_HOST.</span>
<span class="cm"> *</span>
<span class="cm"> * This function returns number of FCP commands pending for the vport.</span>
<span class="cm"> * When ctx_cmd == LPFC_CTX_LUN, the function returns number of FCP</span>
<span class="cm"> * commands pending on the vport associated with SCSI device specified</span>
<span class="cm"> * by tgt_id and lun_id parameters.</span>
<span class="cm"> * When ctx_cmd == LPFC_CTX_TGT, the function returns number of FCP</span>
<span class="cm"> * commands pending on the vport associated with SCSI target specified</span>
<span class="cm"> * by tgt_id parameter.</span>
<span class="cm"> * When ctx_cmd == LPFC_CTX_HOST, the function returns number of FCP</span>
<span class="cm"> * commands pending on the vport.</span>
<span class="cm"> * This function returns the number of iocbs which satisfy the filter.</span>
<span class="cm"> * This function is called without any lock held.</span>
<span class="cm"> **/</span>
<span class="kt">int</span>
<span class="nf">lpfc_sli_sum_iocb</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="n">vport</span><span class="p">,</span> <span class="kt">uint16_t</span> <span class="n">tgt_id</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="n">lun_id</span><span class="p">,</span>
		  <span class="n">lpfc_ctx_cmd</span> <span class="n">ctx_cmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span> <span class="o">=</span> <span class="n">vport</span><span class="o">-&gt;</span><span class="n">phba</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_iocbq</span> <span class="o">*</span><span class="n">iocbq</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">sum</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli</span><span class="p">.</span><span class="n">last_iotag</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">iocbq</span> <span class="o">=</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli</span><span class="p">.</span><span class="n">iocbq_lookup</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">lpfc_sli_validate_fcp_iocb</span> <span class="p">(</span><span class="n">iocbq</span><span class="p">,</span> <span class="n">vport</span><span class="p">,</span> <span class="n">tgt_id</span><span class="p">,</span> <span class="n">lun_id</span><span class="p">,</span>
						<span class="n">ctx_cmd</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">sum</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">sum</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_sli_abort_fcp_cmpl - Completion handler function for aborted FCP IOCBs</span>
<span class="cm"> * @phba: Pointer to HBA context object</span>
<span class="cm"> * @cmdiocb: Pointer to command iocb object.</span>
<span class="cm"> * @rspiocb: Pointer to response iocb object.</span>
<span class="cm"> *</span>
<span class="cm"> * This function is called when an aborted FCP iocb completes. This</span>
<span class="cm"> * function is called by the ring event handler with no lock held.</span>
<span class="cm"> * This function frees the iocb.</span>
<span class="cm"> **/</span>
<span class="kt">void</span>
<span class="nf">lpfc_sli_abort_fcp_cmpl</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">,</span> <span class="k">struct</span> <span class="n">lpfc_iocbq</span> <span class="o">*</span><span class="n">cmdiocb</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">lpfc_iocbq</span> <span class="o">*</span><span class="n">rspiocb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_INFO</span><span class="p">,</span> <span class="n">LOG_SLI</span><span class="p">,</span>
			<span class="s">&quot;3096 ABORT_XRI_CN completing on xri x%x &quot;</span>
			<span class="s">&quot;original iotag x%x, abort cmd iotag x%x &quot;</span>
			<span class="s">&quot;status 0x%x, reason 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">cmdiocb</span><span class="o">-&gt;</span><span class="n">iocb</span><span class="p">.</span><span class="n">un</span><span class="p">.</span><span class="n">acxri</span><span class="p">.</span><span class="n">abortContextTag</span><span class="p">,</span>
			<span class="n">cmdiocb</span><span class="o">-&gt;</span><span class="n">iocb</span><span class="p">.</span><span class="n">un</span><span class="p">.</span><span class="n">acxri</span><span class="p">.</span><span class="n">abortIoTag</span><span class="p">,</span>
			<span class="n">cmdiocb</span><span class="o">-&gt;</span><span class="n">iotag</span><span class="p">,</span> <span class="n">rspiocb</span><span class="o">-&gt;</span><span class="n">iocb</span><span class="p">.</span><span class="n">ulpStatus</span><span class="p">,</span>
			<span class="n">rspiocb</span><span class="o">-&gt;</span><span class="n">iocb</span><span class="p">.</span><span class="n">un</span><span class="p">.</span><span class="n">ulpWord</span><span class="p">[</span><span class="mi">4</span><span class="p">]);</span>
	<span class="n">lpfc_sli_release_iocbq</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">cmdiocb</span><span class="p">);</span>
	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_sli_abort_iocb - issue abort for all commands on a host/target/LUN</span>
<span class="cm"> * @vport: Pointer to virtual port.</span>
<span class="cm"> * @pring: Pointer to driver SLI ring object.</span>
<span class="cm"> * @tgt_id: SCSI ID of the target.</span>
<span class="cm"> * @lun_id: LUN ID of the scsi device.</span>
<span class="cm"> * @abort_cmd: LPFC_CTX_LUN/LPFC_CTX_TGT/LPFC_CTX_HOST.</span>
<span class="cm"> *</span>
<span class="cm"> * This function sends an abort command for every SCSI command</span>
<span class="cm"> * associated with the given virtual port pending on the ring</span>
<span class="cm"> * filtered by lpfc_sli_validate_fcp_iocb function.</span>
<span class="cm"> * When abort_cmd == LPFC_CTX_LUN, the function sends abort only to the</span>
<span class="cm"> * FCP iocbs associated with lun specified by tgt_id and lun_id</span>
<span class="cm"> * parameters</span>
<span class="cm"> * When abort_cmd == LPFC_CTX_TGT, the function sends abort only to the</span>
<span class="cm"> * FCP iocbs associated with SCSI target specified by tgt_id parameter.</span>
<span class="cm"> * When abort_cmd == LPFC_CTX_HOST, the function sends abort to all</span>
<span class="cm"> * FCP iocbs associated with virtual port.</span>
<span class="cm"> * This function returns number of iocbs it failed to abort.</span>
<span class="cm"> * This function is called with no locks held.</span>
<span class="cm"> **/</span>
<span class="kt">int</span>
<span class="nf">lpfc_sli_abort_iocb</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="n">vport</span><span class="p">,</span> <span class="k">struct</span> <span class="n">lpfc_sli_ring</span> <span class="o">*</span><span class="n">pring</span><span class="p">,</span>
		    <span class="kt">uint16_t</span> <span class="n">tgt_id</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="n">lun_id</span><span class="p">,</span> <span class="n">lpfc_ctx_cmd</span> <span class="n">abort_cmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span> <span class="o">=</span> <span class="n">vport</span><span class="o">-&gt;</span><span class="n">phba</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_iocbq</span> <span class="o">*</span><span class="n">iocbq</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_iocbq</span> <span class="o">*</span><span class="n">abtsiocb</span><span class="p">;</span>
	<span class="n">IOCB_t</span> <span class="o">*</span><span class="n">cmd</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">errcnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">ret_val</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli</span><span class="p">.</span><span class="n">last_iotag</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">iocbq</span> <span class="o">=</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli</span><span class="p">.</span><span class="n">iocbq_lookup</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">lpfc_sli_validate_fcp_iocb</span><span class="p">(</span><span class="n">iocbq</span><span class="p">,</span> <span class="n">vport</span><span class="p">,</span> <span class="n">tgt_id</span><span class="p">,</span> <span class="n">lun_id</span><span class="p">,</span>
					       <span class="n">abort_cmd</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="cm">/* issue ABTS for this IOCB based on iotag */</span>
		<span class="n">abtsiocb</span> <span class="o">=</span> <span class="n">lpfc_sli_get_iocbq</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">abtsiocb</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">errcnt</span><span class="o">++</span><span class="p">;</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">cmd</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">iocbq</span><span class="o">-&gt;</span><span class="n">iocb</span><span class="p">;</span>
		<span class="n">abtsiocb</span><span class="o">-&gt;</span><span class="n">iocb</span><span class="p">.</span><span class="n">un</span><span class="p">.</span><span class="n">acxri</span><span class="p">.</span><span class="n">abortType</span> <span class="o">=</span> <span class="n">ABORT_TYPE_ABTS</span><span class="p">;</span>
		<span class="n">abtsiocb</span><span class="o">-&gt;</span><span class="n">iocb</span><span class="p">.</span><span class="n">un</span><span class="p">.</span><span class="n">acxri</span><span class="p">.</span><span class="n">abortContextTag</span> <span class="o">=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">ulpContext</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli_rev</span> <span class="o">==</span> <span class="n">LPFC_SLI_REV4</span><span class="p">)</span>
			<span class="n">abtsiocb</span><span class="o">-&gt;</span><span class="n">iocb</span><span class="p">.</span><span class="n">un</span><span class="p">.</span><span class="n">acxri</span><span class="p">.</span><span class="n">abortIoTag</span> <span class="o">=</span> <span class="n">iocbq</span><span class="o">-&gt;</span><span class="n">sli4_xritag</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">abtsiocb</span><span class="o">-&gt;</span><span class="n">iocb</span><span class="p">.</span><span class="n">un</span><span class="p">.</span><span class="n">acxri</span><span class="p">.</span><span class="n">abortIoTag</span> <span class="o">=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">ulpIoTag</span><span class="p">;</span>
		<span class="n">abtsiocb</span><span class="o">-&gt;</span><span class="n">iocb</span><span class="p">.</span><span class="n">ulpLe</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">abtsiocb</span><span class="o">-&gt;</span><span class="n">iocb</span><span class="p">.</span><span class="n">ulpClass</span> <span class="o">=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">ulpClass</span><span class="p">;</span>
		<span class="n">abtsiocb</span><span class="o">-&gt;</span><span class="n">vport</span> <span class="o">=</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">pport</span><span class="p">;</span>

		<span class="cm">/* ABTS WQE must go to the same WQ as the WQE to be aborted */</span>
		<span class="n">abtsiocb</span><span class="o">-&gt;</span><span class="n">fcp_wqidx</span> <span class="o">=</span> <span class="n">iocbq</span><span class="o">-&gt;</span><span class="n">fcp_wqidx</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">iocbq</span><span class="o">-&gt;</span><span class="n">iocb_flag</span> <span class="o">&amp;</span> <span class="n">LPFC_IO_FCP</span><span class="p">)</span>
			<span class="n">abtsiocb</span><span class="o">-&gt;</span><span class="n">iocb_flag</span> <span class="o">|=</span> <span class="n">LPFC_USE_FCPWQIDX</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">lpfc_is_link_up</span><span class="p">(</span><span class="n">phba</span><span class="p">))</span>
			<span class="n">abtsiocb</span><span class="o">-&gt;</span><span class="n">iocb</span><span class="p">.</span><span class="n">ulpCommand</span> <span class="o">=</span> <span class="n">CMD_ABORT_XRI_CN</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">abtsiocb</span><span class="o">-&gt;</span><span class="n">iocb</span><span class="p">.</span><span class="n">ulpCommand</span> <span class="o">=</span> <span class="n">CMD_CLOSE_XRI_CN</span><span class="p">;</span>

		<span class="cm">/* Setup callback routine and issue the command. */</span>
		<span class="n">abtsiocb</span><span class="o">-&gt;</span><span class="n">iocb_cmpl</span> <span class="o">=</span> <span class="n">lpfc_sli_abort_fcp_cmpl</span><span class="p">;</span>
		<span class="n">ret_val</span> <span class="o">=</span> <span class="n">lpfc_sli_issue_iocb</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">pring</span><span class="o">-&gt;</span><span class="n">ringno</span><span class="p">,</span>
					      <span class="n">abtsiocb</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret_val</span> <span class="o">==</span> <span class="n">IOCB_ERROR</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">lpfc_sli_release_iocbq</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">abtsiocb</span><span class="p">);</span>
			<span class="n">errcnt</span><span class="o">++</span><span class="p">;</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">errcnt</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_sli_wake_iocb_wait - lpfc_sli_issue_iocb_wait&#39;s completion handler</span>
<span class="cm"> * @phba: Pointer to HBA context object.</span>
<span class="cm"> * @cmdiocbq: Pointer to command iocb.</span>
<span class="cm"> * @rspiocbq: Pointer to response iocb.</span>
<span class="cm"> *</span>
<span class="cm"> * This function is the completion handler for iocbs issued using</span>
<span class="cm"> * lpfc_sli_issue_iocb_wait function. This function is called by the</span>
<span class="cm"> * ring event handler function without any lock held. This function</span>
<span class="cm"> * can be called from both worker thread context and interrupt</span>
<span class="cm"> * context. This function also can be called from other thread which</span>
<span class="cm"> * cleans up the SLI layer objects.</span>
<span class="cm"> * This function copy the contents of the response iocb to the</span>
<span class="cm"> * response iocb memory object provided by the caller of</span>
<span class="cm"> * lpfc_sli_issue_iocb_wait and then wakes up the thread which</span>
<span class="cm"> * sleeps for the iocb completion.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">lpfc_sli_wake_iocb_wait</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">lpfc_iocbq</span> <span class="o">*</span><span class="n">cmdiocbq</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">lpfc_iocbq</span> <span class="o">*</span><span class="n">rspiocbq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">wait_queue_head_t</span> <span class="o">*</span><span class="n">pdone_q</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">iflags</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_scsi_buf</span> <span class="o">*</span><span class="n">lpfc_cmd</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">,</span> <span class="n">iflags</span><span class="p">);</span>
	<span class="n">cmdiocbq</span><span class="o">-&gt;</span><span class="n">iocb_flag</span> <span class="o">|=</span> <span class="n">LPFC_IO_WAKE</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cmdiocbq</span><span class="o">-&gt;</span><span class="n">context2</span> <span class="o">&amp;&amp;</span> <span class="n">rspiocbq</span><span class="p">)</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="p">((</span><span class="k">struct</span> <span class="n">lpfc_iocbq</span> <span class="o">*</span><span class="p">)</span><span class="n">cmdiocbq</span><span class="o">-&gt;</span><span class="n">context2</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">iocb</span><span class="p">,</span>
		       <span class="o">&amp;</span><span class="n">rspiocbq</span><span class="o">-&gt;</span><span class="n">iocb</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">IOCB_t</span><span class="p">));</span>

	<span class="cm">/* Set the exchange busy flag for task management commands */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">cmdiocbq</span><span class="o">-&gt;</span><span class="n">iocb_flag</span> <span class="o">&amp;</span> <span class="n">LPFC_IO_FCP</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		<span class="o">!</span><span class="p">(</span><span class="n">cmdiocbq</span><span class="o">-&gt;</span><span class="n">iocb_flag</span> <span class="o">&amp;</span> <span class="n">LPFC_IO_LIBDFC</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">lpfc_cmd</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">cmdiocbq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">lpfc_scsi_buf</span><span class="p">,</span>
			<span class="n">cur_iocbq</span><span class="p">);</span>
		<span class="n">lpfc_cmd</span><span class="o">-&gt;</span><span class="n">exch_busy</span> <span class="o">=</span> <span class="n">rspiocbq</span><span class="o">-&gt;</span><span class="n">iocb_flag</span> <span class="o">&amp;</span> <span class="n">LPFC_EXCHANGE_BUSY</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">pdone_q</span> <span class="o">=</span> <span class="n">cmdiocbq</span><span class="o">-&gt;</span><span class="n">context_un</span><span class="p">.</span><span class="n">wait_queue</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pdone_q</span><span class="p">)</span>
		<span class="n">wake_up</span><span class="p">(</span><span class="n">pdone_q</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">,</span> <span class="n">iflags</span><span class="p">);</span>
	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_chk_iocb_flg - Test IOCB flag with lock held.</span>
<span class="cm"> * @phba: Pointer to HBA context object..</span>
<span class="cm"> * @piocbq: Pointer to command iocb.</span>
<span class="cm"> * @flag: Flag to test.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine grabs the hbalock and then test the iocb_flag to</span>
<span class="cm"> * see if the passed in flag is set.</span>
<span class="cm"> * Returns:</span>
<span class="cm"> * 1 if flag is set.</span>
<span class="cm"> * 0 if flag is not set.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">lpfc_chk_iocb_flg</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">,</span>
		 <span class="k">struct</span> <span class="n">lpfc_iocbq</span> <span class="o">*</span><span class="n">piocbq</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">flag</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">iflags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">,</span> <span class="n">iflags</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">piocbq</span><span class="o">-&gt;</span><span class="n">iocb_flag</span> <span class="o">&amp;</span> <span class="n">flag</span><span class="p">;</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">,</span> <span class="n">iflags</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_sli_issue_iocb_wait - Synchronous function to issue iocb commands</span>
<span class="cm"> * @phba: Pointer to HBA context object..</span>
<span class="cm"> * @pring: Pointer to sli ring.</span>
<span class="cm"> * @piocb: Pointer to command iocb.</span>
<span class="cm"> * @prspiocbq: Pointer to response iocb.</span>
<span class="cm"> * @timeout: Timeout in number of seconds.</span>
<span class="cm"> *</span>
<span class="cm"> * This function issues the iocb to firmware and waits for the</span>
<span class="cm"> * iocb to complete. If the iocb command is not</span>
<span class="cm"> * completed within timeout seconds, it returns IOCB_TIMEDOUT.</span>
<span class="cm"> * Caller should not free the iocb resources if this function</span>
<span class="cm"> * returns IOCB_TIMEDOUT.</span>
<span class="cm"> * The function waits for the iocb completion using an</span>
<span class="cm"> * non-interruptible wait.</span>
<span class="cm"> * This function will sleep while waiting for iocb completion.</span>
<span class="cm"> * So, this function should not be called from any context which</span>
<span class="cm"> * does not allow sleeping. Due to the same reason, this function</span>
<span class="cm"> * cannot be called with interrupt disabled.</span>
<span class="cm"> * This function assumes that the iocb completions occur while</span>
<span class="cm"> * this function sleep. So, this function cannot be called from</span>
<span class="cm"> * the thread which process iocb completion for this ring.</span>
<span class="cm"> * This function clears the iocb_flag of the iocb object before</span>
<span class="cm"> * issuing the iocb and the iocb completion handler sets this</span>
<span class="cm"> * flag and wakes this thread when the iocb completes.</span>
<span class="cm"> * The contents of the response iocb will be copied to prspiocbq</span>
<span class="cm"> * by the completion handler when the command completes.</span>
<span class="cm"> * This function returns IOCB_SUCCESS when success.</span>
<span class="cm"> * This function is called with no lock held.</span>
<span class="cm"> **/</span>
<span class="kt">int</span>
<span class="nf">lpfc_sli_issue_iocb_wait</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">,</span>
			 <span class="kt">uint32_t</span> <span class="n">ring_number</span><span class="p">,</span>
			 <span class="k">struct</span> <span class="n">lpfc_iocbq</span> <span class="o">*</span><span class="n">piocb</span><span class="p">,</span>
			 <span class="k">struct</span> <span class="n">lpfc_iocbq</span> <span class="o">*</span><span class="n">prspiocbq</span><span class="p">,</span>
			 <span class="kt">uint32_t</span> <span class="n">timeout</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">DECLARE_WAIT_QUEUE_HEAD_ONSTACK</span><span class="p">(</span><span class="n">done_q</span><span class="p">);</span>
	<span class="kt">long</span> <span class="n">timeleft</span><span class="p">,</span> <span class="n">timeout_req</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">retval</span> <span class="o">=</span> <span class="n">IOCB_SUCCESS</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">creg_val</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_sli_ring</span> <span class="o">*</span><span class="n">pring</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli</span><span class="p">.</span><span class="n">ring</span><span class="p">[</span><span class="n">LPFC_ELS_RING</span><span class="p">];</span>
	<span class="cm">/*</span>
<span class="cm">	 * If the caller has provided a response iocbq buffer, then context2</span>
<span class="cm">	 * is NULL or its an error.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">prspiocbq</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">piocb</span><span class="o">-&gt;</span><span class="n">context2</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">IOCB_ERROR</span><span class="p">;</span>
		<span class="n">piocb</span><span class="o">-&gt;</span><span class="n">context2</span> <span class="o">=</span> <span class="n">prspiocbq</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">piocb</span><span class="o">-&gt;</span><span class="n">iocb_cmpl</span> <span class="o">=</span> <span class="n">lpfc_sli_wake_iocb_wait</span><span class="p">;</span>
	<span class="n">piocb</span><span class="o">-&gt;</span><span class="n">context_un</span><span class="p">.</span><span class="n">wait_queue</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">done_q</span><span class="p">;</span>
	<span class="n">piocb</span><span class="o">-&gt;</span><span class="n">iocb_flag</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">LPFC_IO_WAKE</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">cfg_poll</span> <span class="o">&amp;</span> <span class="n">DISABLE_FCP_RING_INT</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">lpfc_readl</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">HCregaddr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">creg_val</span><span class="p">))</span>
			<span class="k">return</span> <span class="n">IOCB_ERROR</span><span class="p">;</span>
		<span class="n">creg_val</span> <span class="o">|=</span> <span class="p">(</span><span class="n">HC_R0INT_ENA</span> <span class="o">&lt;&lt;</span> <span class="n">LPFC_FCP_RING</span><span class="p">);</span>
		<span class="n">writel</span><span class="p">(</span><span class="n">creg_val</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">HCregaddr</span><span class="p">);</span>
		<span class="n">readl</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">HCregaddr</span><span class="p">);</span> <span class="cm">/* flush */</span>
	<span class="p">}</span>

	<span class="n">retval</span> <span class="o">=</span> <span class="n">lpfc_sli_issue_iocb</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">ring_number</span><span class="p">,</span> <span class="n">piocb</span><span class="p">,</span>
				     <span class="n">SLI_IOCB_RET_IOCB</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span> <span class="o">==</span> <span class="n">IOCB_SUCCESS</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">timeout_req</span> <span class="o">=</span> <span class="n">timeout</span> <span class="o">*</span> <span class="n">HZ</span><span class="p">;</span>
		<span class="n">timeleft</span> <span class="o">=</span> <span class="n">wait_event_timeout</span><span class="p">(</span><span class="n">done_q</span><span class="p">,</span>
				<span class="n">lpfc_chk_iocb_flg</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">piocb</span><span class="p">,</span> <span class="n">LPFC_IO_WAKE</span><span class="p">),</span>
				<span class="n">timeout_req</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">piocb</span><span class="o">-&gt;</span><span class="n">iocb_flag</span> <span class="o">&amp;</span> <span class="n">LPFC_IO_WAKE</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_INFO</span><span class="p">,</span> <span class="n">LOG_SLI</span><span class="p">,</span>
					<span class="s">&quot;0331 IOCB wake signaled</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">timeleft</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_SLI</span><span class="p">,</span>
					<span class="s">&quot;0338 IOCB wait timeout error - no &quot;</span>
					<span class="s">&quot;wake response Data x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">timeout</span><span class="p">);</span>
			<span class="n">retval</span> <span class="o">=</span> <span class="n">IOCB_TIMEDOUT</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_SLI</span><span class="p">,</span>
					<span class="s">&quot;0330 IOCB wake NOT set, &quot;</span>
					<span class="s">&quot;Data x%x x%lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">timeout</span><span class="p">,</span> <span class="p">(</span><span class="n">timeleft</span> <span class="o">/</span> <span class="n">jiffies</span><span class="p">));</span>
			<span class="n">retval</span> <span class="o">=</span> <span class="n">IOCB_TIMEDOUT</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">retval</span> <span class="o">==</span> <span class="n">IOCB_BUSY</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_INFO</span><span class="p">,</span> <span class="n">LOG_SLI</span><span class="p">,</span>
			<span class="s">&quot;2818 Max IOCBs %d txq cnt %d txcmplq cnt %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">phba</span><span class="o">-&gt;</span><span class="n">iocb_cnt</span><span class="p">,</span> <span class="n">pring</span><span class="o">-&gt;</span><span class="n">txq_cnt</span><span class="p">,</span> <span class="n">pring</span><span class="o">-&gt;</span><span class="n">txcmplq_cnt</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_INFO</span><span class="p">,</span> <span class="n">LOG_SLI</span><span class="p">,</span>
				<span class="s">&quot;0332 IOCB wait issue failed, Data x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">retval</span><span class="p">);</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="n">IOCB_ERROR</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">cfg_poll</span> <span class="o">&amp;</span> <span class="n">DISABLE_FCP_RING_INT</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">lpfc_readl</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">HCregaddr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">creg_val</span><span class="p">))</span>
			<span class="k">return</span> <span class="n">IOCB_ERROR</span><span class="p">;</span>
		<span class="n">creg_val</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">HC_R0INT_ENA</span> <span class="o">&lt;&lt;</span> <span class="n">LPFC_FCP_RING</span><span class="p">);</span>
		<span class="n">writel</span><span class="p">(</span><span class="n">creg_val</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">HCregaddr</span><span class="p">);</span>
		<span class="n">readl</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">HCregaddr</span><span class="p">);</span> <span class="cm">/* flush */</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">prspiocbq</span><span class="p">)</span>
		<span class="n">piocb</span><span class="o">-&gt;</span><span class="n">context2</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">piocb</span><span class="o">-&gt;</span><span class="n">context_un</span><span class="p">.</span><span class="n">wait_queue</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">piocb</span><span class="o">-&gt;</span><span class="n">iocb_cmpl</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_sli_issue_mbox_wait - Synchronous function to issue mailbox</span>
<span class="cm"> * @phba: Pointer to HBA context object.</span>
<span class="cm"> * @pmboxq: Pointer to driver mailbox object.</span>
<span class="cm"> * @timeout: Timeout in number of seconds.</span>
<span class="cm"> *</span>
<span class="cm"> * This function issues the mailbox to firmware and waits for the</span>
<span class="cm"> * mailbox command to complete. If the mailbox command is not</span>
<span class="cm"> * completed within timeout seconds, it returns MBX_TIMEOUT.</span>
<span class="cm"> * The function waits for the mailbox completion using an</span>
<span class="cm"> * interruptible wait. If the thread is woken up due to a</span>
<span class="cm"> * signal, MBX_TIMEOUT error is returned to the caller. Caller</span>
<span class="cm"> * should not free the mailbox resources, if this function returns</span>
<span class="cm"> * MBX_TIMEOUT.</span>
<span class="cm"> * This function will sleep while waiting for mailbox completion.</span>
<span class="cm"> * So, this function should not be called from any context which</span>
<span class="cm"> * does not allow sleeping. Due to the same reason, this function</span>
<span class="cm"> * cannot be called with interrupt disabled.</span>
<span class="cm"> * This function assumes that the mailbox completion occurs while</span>
<span class="cm"> * this function sleep. So, this function cannot be called from</span>
<span class="cm"> * the worker thread which processes mailbox completion.</span>
<span class="cm"> * This function is called in the context of HBA management</span>
<span class="cm"> * applications.</span>
<span class="cm"> * This function returns MBX_SUCCESS when successful.</span>
<span class="cm"> * This function is called with no lock held.</span>
<span class="cm"> **/</span>
<span class="kt">int</span>
<span class="nf">lpfc_sli_issue_mbox_wait</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">,</span> <span class="n">LPFC_MBOXQ_t</span> <span class="o">*</span><span class="n">pmboxq</span><span class="p">,</span>
			 <span class="kt">uint32_t</span> <span class="n">timeout</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">DECLARE_WAIT_QUEUE_HEAD_ONSTACK</span><span class="p">(</span><span class="n">done_q</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">retval</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flag</span><span class="p">;</span>

	<span class="cm">/* The caller must leave context1 empty. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pmboxq</span><span class="o">-&gt;</span><span class="n">context1</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">MBX_NOT_FINISHED</span><span class="p">;</span>

	<span class="n">pmboxq</span><span class="o">-&gt;</span><span class="n">mbox_flag</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">LPFC_MBX_WAKE</span><span class="p">;</span>
	<span class="cm">/* setup wake call as IOCB callback */</span>
	<span class="n">pmboxq</span><span class="o">-&gt;</span><span class="n">mbox_cmpl</span> <span class="o">=</span> <span class="n">lpfc_sli_wake_mbox_wait</span><span class="p">;</span>
	<span class="cm">/* setup context field to pass wait_queue pointer to wake function  */</span>
	<span class="n">pmboxq</span><span class="o">-&gt;</span><span class="n">context1</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">done_q</span><span class="p">;</span>

	<span class="cm">/* now issue the command */</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="n">lpfc_sli_issue_mbox</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">pmboxq</span><span class="p">,</span> <span class="n">MBX_NOWAIT</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span> <span class="o">==</span> <span class="n">MBX_BUSY</span> <span class="o">||</span> <span class="n">retval</span> <span class="o">==</span> <span class="n">MBX_SUCCESS</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">wait_event_interruptible_timeout</span><span class="p">(</span><span class="n">done_q</span><span class="p">,</span>
				<span class="n">pmboxq</span><span class="o">-&gt;</span><span class="n">mbox_flag</span> <span class="o">&amp;</span> <span class="n">LPFC_MBX_WAKE</span><span class="p">,</span>
				<span class="n">timeout</span> <span class="o">*</span> <span class="n">HZ</span><span class="p">);</span>

		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">,</span> <span class="n">flag</span><span class="p">);</span>
		<span class="n">pmboxq</span><span class="o">-&gt;</span><span class="n">context1</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * if LPFC_MBX_WAKE flag is set the mailbox is completed</span>
<span class="cm">		 * else do not free the resources.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pmboxq</span><span class="o">-&gt;</span><span class="n">mbox_flag</span> <span class="o">&amp;</span> <span class="n">LPFC_MBX_WAKE</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">retval</span> <span class="o">=</span> <span class="n">MBX_SUCCESS</span><span class="p">;</span>
			<span class="n">lpfc_sli4_swap_str</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">pmboxq</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">retval</span> <span class="o">=</span> <span class="n">MBX_TIMEOUT</span><span class="p">;</span>
			<span class="n">pmboxq</span><span class="o">-&gt;</span><span class="n">mbox_cmpl</span> <span class="o">=</span> <span class="n">lpfc_sli_def_mbox_cmpl</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">,</span> <span class="n">flag</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_sli_mbox_sys_shutdown - shutdown mailbox command sub-system</span>
<span class="cm"> * @phba: Pointer to HBA context.</span>
<span class="cm"> *</span>
<span class="cm"> * This function is called to shutdown the driver&#39;s mailbox sub-system.</span>
<span class="cm"> * It first marks the mailbox sub-system is in a block state to prevent</span>
<span class="cm"> * the asynchronous mailbox command from issued off the pending mailbox</span>
<span class="cm"> * command queue. If the mailbox command sub-system shutdown is due to</span>
<span class="cm"> * HBA error conditions such as EEH or ERATT, this routine shall invoke</span>
<span class="cm"> * the mailbox sub-system flush routine to forcefully bring down the</span>
<span class="cm"> * mailbox sub-system. Otherwise, if it is due to normal condition (such</span>
<span class="cm"> * as with offline or HBA function reset), this routine will wait for the</span>
<span class="cm"> * outstanding mailbox command to complete before invoking the mailbox</span>
<span class="cm"> * sub-system flush routine to gracefully bring down mailbox sub-system.</span>
<span class="cm"> **/</span>
<span class="kt">void</span>
<span class="nf">lpfc_sli_mbox_sys_shutdown</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpfc_sli</span> <span class="o">*</span><span class="n">psli</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">timeout</span><span class="p">;</span>

	<span class="n">timeout</span> <span class="o">=</span> <span class="n">msecs_to_jiffies</span><span class="p">(</span><span class="n">LPFC_MBOX_TMO</span> <span class="o">*</span> <span class="mi">1000</span><span class="p">)</span> <span class="o">+</span> <span class="n">jiffies</span><span class="p">;</span>

	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>
	<span class="n">psli</span><span class="o">-&gt;</span><span class="n">sli_flag</span> <span class="o">|=</span> <span class="n">LPFC_SLI_ASYNC_MBX_BLK</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">psli</span><span class="o">-&gt;</span><span class="n">sli_flag</span> <span class="o">&amp;</span> <span class="n">LPFC_SLI_ACTIVE</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Determine how long we might wait for the active mailbox</span>
<span class="cm">		 * command to be gracefully completed by firmware.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli</span><span class="p">.</span><span class="n">mbox_active</span><span class="p">)</span>
			<span class="n">timeout</span> <span class="o">=</span> <span class="n">msecs_to_jiffies</span><span class="p">(</span><span class="n">lpfc_mbox_tmo_val</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span>
						<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli</span><span class="p">.</span><span class="n">mbox_active</span><span class="p">)</span> <span class="o">*</span>
						<span class="mi">1000</span><span class="p">)</span> <span class="o">+</span> <span class="n">jiffies</span><span class="p">;</span>
		<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>

		<span class="k">while</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli</span><span class="p">.</span><span class="n">mbox_active</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Check active mailbox complete status every 2ms */</span>
			<span class="n">msleep</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">time_after</span><span class="p">(</span><span class="n">jiffies</span><span class="p">,</span> <span class="n">timeout</span><span class="p">))</span>
				<span class="cm">/* Timeout, let the mailbox flush routine to</span>
<span class="cm">				 * forcefully release active mailbox command</span>
<span class="cm">				 */</span>
				<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>

	<span class="n">lpfc_sli_mbox_sys_flush</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_sli_eratt_read - read sli-3 error attention events</span>
<span class="cm"> * @phba: Pointer to HBA context.</span>
<span class="cm"> *</span>
<span class="cm"> * This function is called to read the SLI3 device error attention registers</span>
<span class="cm"> * for possible error attention events. The caller must hold the hostlock</span>
<span class="cm"> * with spin_lock_irq().</span>
<span class="cm"> *</span>
<span class="cm"> * This function returns 1 when there is Error Attention in the Host Attention</span>
<span class="cm"> * Register and returns 0 otherwise.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">lpfc_sli_eratt_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">uint32_t</span> <span class="n">ha_copy</span><span class="p">;</span>

	<span class="cm">/* Read chip Host Attention (HA) register */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">lpfc_readl</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">HAregaddr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ha_copy</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">unplug_err</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ha_copy</span> <span class="o">&amp;</span> <span class="n">HA_ERATT</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Read host status register to retrieve error event */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">lpfc_sli_read_hs</span><span class="p">(</span><span class="n">phba</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">unplug_err</span><span class="p">;</span>

		<span class="cm">/* Check if there is a deferred error condition is active */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">HS_FFER1</span> <span class="o">&amp;</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">work_hs</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="p">((</span><span class="n">HS_FFER2</span> <span class="o">|</span> <span class="n">HS_FFER3</span> <span class="o">|</span> <span class="n">HS_FFER4</span> <span class="o">|</span> <span class="n">HS_FFER5</span> <span class="o">|</span>
		      <span class="n">HS_FFER6</span> <span class="o">|</span> <span class="n">HS_FFER7</span> <span class="o">|</span> <span class="n">HS_FFER8</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">work_hs</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">phba</span><span class="o">-&gt;</span><span class="n">hba_flag</span> <span class="o">|=</span> <span class="n">DEFER_ERATT</span><span class="p">;</span>
			<span class="cm">/* Clear all interrupt enable conditions */</span>
			<span class="n">writel</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">HCregaddr</span><span class="p">);</span>
			<span class="n">readl</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">HCregaddr</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="cm">/* Set the driver HA work bitmap */</span>
		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">work_ha</span> <span class="o">|=</span> <span class="n">HA_ERATT</span><span class="p">;</span>
		<span class="cm">/* Indicate polling handles this ERATT */</span>
		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">hba_flag</span> <span class="o">|=</span> <span class="n">HBA_ERATT_HANDLED</span><span class="p">;</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">unplug_err:</span>
	<span class="cm">/* Set the driver HS work bitmap */</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">work_hs</span> <span class="o">|=</span> <span class="n">UNPLUG_ERR</span><span class="p">;</span>
	<span class="cm">/* Set the driver HA work bitmap */</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">work_ha</span> <span class="o">|=</span> <span class="n">HA_ERATT</span><span class="p">;</span>
	<span class="cm">/* Indicate polling handles this ERATT */</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">hba_flag</span> <span class="o">|=</span> <span class="n">HBA_ERATT_HANDLED</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_sli4_eratt_read - read sli-4 error attention events</span>
<span class="cm"> * @phba: Pointer to HBA context.</span>
<span class="cm"> *</span>
<span class="cm"> * This function is called to read the SLI4 device error attention registers</span>
<span class="cm"> * for possible error attention events. The caller must hold the hostlock</span>
<span class="cm"> * with spin_lock_irq().</span>
<span class="cm"> *</span>
<span class="cm"> * This function returns 1 when there is Error Attention in the Host Attention</span>
<span class="cm"> * Register and returns 0 otherwise.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">lpfc_sli4_eratt_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">uint32_t</span> <span class="n">uerr_sta_hi</span><span class="p">,</span> <span class="n">uerr_sta_lo</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">if_type</span><span class="p">,</span> <span class="n">portsmphr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_register</span> <span class="n">portstat_reg</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * For now, use the SLI4 device internal unrecoverable error</span>
<span class="cm">	 * registers for error attention. This can be changed later.</span>
<span class="cm">	 */</span>
	<span class="n">if_type</span> <span class="o">=</span> <span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_sli_intf_if_type</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">sli_intf</span><span class="p">);</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">if_type</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">LPFC_SLI_INTF_IF_TYPE_0</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">lpfc_readl</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">u</span><span class="p">.</span><span class="n">if_type0</span><span class="p">.</span><span class="n">UERRLOregaddr</span><span class="p">,</span>
			<span class="o">&amp;</span><span class="n">uerr_sta_lo</span><span class="p">)</span> <span class="o">||</span>
			<span class="n">lpfc_readl</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">u</span><span class="p">.</span><span class="n">if_type0</span><span class="p">.</span><span class="n">UERRHIregaddr</span><span class="p">,</span>
			<span class="o">&amp;</span><span class="n">uerr_sta_hi</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">phba</span><span class="o">-&gt;</span><span class="n">work_hs</span> <span class="o">|=</span> <span class="n">UNPLUG_ERR</span><span class="p">;</span>
			<span class="n">phba</span><span class="o">-&gt;</span><span class="n">work_ha</span> <span class="o">|=</span> <span class="n">HA_ERATT</span><span class="p">;</span>
			<span class="n">phba</span><span class="o">-&gt;</span><span class="n">hba_flag</span> <span class="o">|=</span> <span class="n">HBA_ERATT_HANDLED</span><span class="p">;</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">((</span><span class="o">~</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">ue_mask_lo</span> <span class="o">&amp;</span> <span class="n">uerr_sta_lo</span><span class="p">)</span> <span class="o">||</span>
		    <span class="p">(</span><span class="o">~</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">ue_mask_hi</span> <span class="o">&amp;</span> <span class="n">uerr_sta_hi</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_INIT</span><span class="p">,</span>
					<span class="s">&quot;1423 HBA Unrecoverable error: &quot;</span>
					<span class="s">&quot;uerr_lo_reg=0x%x, uerr_hi_reg=0x%x, &quot;</span>
					<span class="s">&quot;ue_mask_lo_reg=0x%x, &quot;</span>
					<span class="s">&quot;ue_mask_hi_reg=0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">uerr_sta_lo</span><span class="p">,</span> <span class="n">uerr_sta_hi</span><span class="p">,</span>
					<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">ue_mask_lo</span><span class="p">,</span>
					<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">ue_mask_hi</span><span class="p">);</span>
			<span class="n">phba</span><span class="o">-&gt;</span><span class="n">work_status</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">uerr_sta_lo</span><span class="p">;</span>
			<span class="n">phba</span><span class="o">-&gt;</span><span class="n">work_status</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">uerr_sta_hi</span><span class="p">;</span>
			<span class="n">phba</span><span class="o">-&gt;</span><span class="n">work_ha</span> <span class="o">|=</span> <span class="n">HA_ERATT</span><span class="p">;</span>
			<span class="n">phba</span><span class="o">-&gt;</span><span class="n">hba_flag</span> <span class="o">|=</span> <span class="n">HBA_ERATT_HANDLED</span><span class="p">;</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">LPFC_SLI_INTF_IF_TYPE_2</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">lpfc_readl</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">u</span><span class="p">.</span><span class="n">if_type2</span><span class="p">.</span><span class="n">STATUSregaddr</span><span class="p">,</span>
			<span class="o">&amp;</span><span class="n">portstat_reg</span><span class="p">.</span><span class="n">word0</span><span class="p">)</span> <span class="o">||</span>
			<span class="n">lpfc_readl</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">PSMPHRregaddr</span><span class="p">,</span>
			<span class="o">&amp;</span><span class="n">portsmphr</span><span class="p">)){</span>
			<span class="n">phba</span><span class="o">-&gt;</span><span class="n">work_hs</span> <span class="o">|=</span> <span class="n">UNPLUG_ERR</span><span class="p">;</span>
			<span class="n">phba</span><span class="o">-&gt;</span><span class="n">work_ha</span> <span class="o">|=</span> <span class="n">HA_ERATT</span><span class="p">;</span>
			<span class="n">phba</span><span class="o">-&gt;</span><span class="n">hba_flag</span> <span class="o">|=</span> <span class="n">HBA_ERATT_HANDLED</span><span class="p">;</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_sliport_status_err</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">portstat_reg</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">phba</span><span class="o">-&gt;</span><span class="n">work_status</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span>
				<span class="n">readl</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">u</span><span class="p">.</span><span class="n">if_type2</span><span class="p">.</span><span class="n">ERR1regaddr</span><span class="p">);</span>
			<span class="n">phba</span><span class="o">-&gt;</span><span class="n">work_status</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span>
				<span class="n">readl</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">u</span><span class="p">.</span><span class="n">if_type2</span><span class="p">.</span><span class="n">ERR2regaddr</span><span class="p">);</span>
			<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_INIT</span><span class="p">,</span>
					<span class="s">&quot;2885 Port Status Event: &quot;</span>
					<span class="s">&quot;port status reg 0x%x, &quot;</span>
					<span class="s">&quot;port smphr reg 0x%x, &quot;</span>
					<span class="s">&quot;error 1=0x%x, error 2=0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">portstat_reg</span><span class="p">.</span><span class="n">word0</span><span class="p">,</span>
					<span class="n">portsmphr</span><span class="p">,</span>
					<span class="n">phba</span><span class="o">-&gt;</span><span class="n">work_status</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
					<span class="n">phba</span><span class="o">-&gt;</span><span class="n">work_status</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
			<span class="n">phba</span><span class="o">-&gt;</span><span class="n">work_ha</span> <span class="o">|=</span> <span class="n">HA_ERATT</span><span class="p">;</span>
			<span class="n">phba</span><span class="o">-&gt;</span><span class="n">hba_flag</span> <span class="o">|=</span> <span class="n">HBA_ERATT_HANDLED</span><span class="p">;</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">LPFC_SLI_INTF_IF_TYPE_1</span>:
	<span class="nl">default:</span>
		<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_INIT</span><span class="p">,</span>
				<span class="s">&quot;2886 HBA Error Attention on unsupported &quot;</span>
				<span class="s">&quot;if type %d.&quot;</span><span class="p">,</span> <span class="n">if_type</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_sli_check_eratt - check error attention events</span>
<span class="cm"> * @phba: Pointer to HBA context.</span>
<span class="cm"> *</span>
<span class="cm"> * This function is called from timer soft interrupt context to check HBA&#39;s</span>
<span class="cm"> * error attention register bit for error attention events.</span>
<span class="cm"> *</span>
<span class="cm"> * This function returns 1 when there is Error Attention in the Host Attention</span>
<span class="cm"> * Register and returns 0 otherwise.</span>
<span class="cm"> **/</span>
<span class="kt">int</span>
<span class="nf">lpfc_sli_check_eratt</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">uint32_t</span> <span class="n">ha_copy</span><span class="p">;</span>

	<span class="cm">/* If somebody is waiting to handle an eratt, don&#39;t process it</span>
<span class="cm">	 * here. The brdkill function will do this.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">link_flag</span> <span class="o">&amp;</span> <span class="n">LS_IGNORE_ERATT</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Check if interrupt handler handles this ERATT */</span>
	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hba_flag</span> <span class="o">&amp;</span> <span class="n">HBA_ERATT_HANDLED</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Interrupt handler has handled ERATT */</span>
		<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * If there is deferred error attention, do not check for error</span>
<span class="cm">	 * attention</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hba_flag</span> <span class="o">&amp;</span> <span class="n">DEFER_ERATT</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* If PCI channel is offline, don&#39;t process it */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">pci_channel_offline</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">pcidev</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli_rev</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">LPFC_SLI_REV2</span>:
	<span class="k">case</span> <span class="n">LPFC_SLI_REV3</span>:
		<span class="cm">/* Read chip Host Attention (HA) register */</span>
		<span class="n">ha_copy</span> <span class="o">=</span> <span class="n">lpfc_sli_eratt_read</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">LPFC_SLI_REV4</span>:
		<span class="cm">/* Read device Uncoverable Error (UERR) registers */</span>
		<span class="n">ha_copy</span> <span class="o">=</span> <span class="n">lpfc_sli4_eratt_read</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_INIT</span><span class="p">,</span>
				<span class="s">&quot;0299 Invalid SLI revision (%d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli_rev</span><span class="p">);</span>
		<span class="n">ha_copy</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ha_copy</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_intr_state_check - Check device state for interrupt handling</span>
<span class="cm"> * @phba: Pointer to HBA context.</span>
<span class="cm"> *</span>
<span class="cm"> * This inline routine checks whether a device or its PCI slot is in a state</span>
<span class="cm"> * that the interrupt should be handled.</span>
<span class="cm"> *</span>
<span class="cm"> * This function returns 0 if the device or the PCI slot is in a state that</span>
<span class="cm"> * interrupt should be handled, otherwise -EIO.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span>
<span class="nf">lpfc_intr_state_check</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* If the pci channel is offline, ignore all the interrupts */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">pci_channel_offline</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">pcidev</span><span class="p">)))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>

	<span class="cm">/* Update device level interrupt statistics */</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli</span><span class="p">.</span><span class="n">slistat</span><span class="p">.</span><span class="n">sli_intr</span><span class="o">++</span><span class="p">;</span>

	<span class="cm">/* Ignore all interrupts during initialization. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">link_state</span> <span class="o">&lt;</span> <span class="n">LPFC_LINK_DOWN</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_sli_sp_intr_handler - Slow-path interrupt handler to SLI-3 device</span>
<span class="cm"> * @irq: Interrupt number.</span>
<span class="cm"> * @dev_id: The device context pointer.</span>
<span class="cm"> *</span>
<span class="cm"> * This function is directly called from the PCI layer as an interrupt</span>
<span class="cm"> * service routine when device with SLI-3 interface spec is enabled with</span>
<span class="cm"> * MSI-X multi-message interrupt mode and there are slow-path events in</span>
<span class="cm"> * the HBA. However, when the device is enabled with either MSI or Pin-IRQ</span>
<span class="cm"> * interrupt mode, this function is called as part of the device-level</span>
<span class="cm"> * interrupt handler. When the PCI slot is in error recovery or the HBA</span>
<span class="cm"> * is undergoing initialization, the interrupt handler will not process</span>
<span class="cm"> * the interrupt. The link attention and ELS ring attention events are</span>
<span class="cm"> * handled by the worker thread. The interrupt handler signals the worker</span>
<span class="cm"> * thread and returns for these events. This function is called without</span>
<span class="cm"> * any lock held. It gets the hbalock to access and update SLI data</span>
<span class="cm"> * structures.</span>
<span class="cm"> *</span>
<span class="cm"> * This function returns IRQ_HANDLED when interrupt is handled else it</span>
<span class="cm"> * returns IRQ_NONE.</span>
<span class="cm"> **/</span>
<span class="n">irqreturn_t</span>
<span class="nf">lpfc_sli_sp_intr_handler</span><span class="p">(</span><span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">dev_id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpfc_hba</span>  <span class="o">*</span><span class="n">phba</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">ha_copy</span><span class="p">,</span> <span class="n">hc_copy</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">work_ha_copy</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">status</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">iflag</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">control</span><span class="p">;</span>

	<span class="n">MAILBOX_t</span> <span class="o">*</span><span class="n">mbox</span><span class="p">,</span> <span class="o">*</span><span class="n">pmbox</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="n">vport</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_nodelist</span> <span class="o">*</span><span class="n">ndlp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_dmabuf</span> <span class="o">*</span><span class="n">mp</span><span class="p">;</span>
	<span class="n">LPFC_MBOXQ_t</span> <span class="o">*</span><span class="n">pmb</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Get the driver&#39;s phba structure from the dev_id and</span>
<span class="cm">	 * assume the HBA is not interrupting.</span>
<span class="cm">	 */</span>
	<span class="n">phba</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="p">)</span><span class="n">dev_id</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">phba</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">IRQ_NONE</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Stuff needs to be attented to when this function is invoked as an</span>
<span class="cm">	 * individual interrupt handler in MSI-X multi-message interrupt mode</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">intr_type</span> <span class="o">==</span> <span class="n">MSIX</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Check device state for handling interrupt */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">lpfc_intr_state_check</span><span class="p">(</span><span class="n">phba</span><span class="p">))</span>
			<span class="k">return</span> <span class="n">IRQ_NONE</span><span class="p">;</span>
		<span class="cm">/* Need to read HA REG for slow-path events */</span>
		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">,</span> <span class="n">iflag</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">lpfc_readl</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">HAregaddr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ha_copy</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">unplug_error</span><span class="p">;</span>
		<span class="cm">/* If somebody is waiting to handle an eratt don&#39;t process it</span>
<span class="cm">		 * here. The brdkill function will do this.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">link_flag</span> <span class="o">&amp;</span> <span class="n">LS_IGNORE_ERATT</span><span class="p">)</span>
			<span class="n">ha_copy</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">HA_ERATT</span><span class="p">;</span>
		<span class="cm">/* Check the need for handling ERATT in interrupt handler */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ha_copy</span> <span class="o">&amp;</span> <span class="n">HA_ERATT</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hba_flag</span> <span class="o">&amp;</span> <span class="n">HBA_ERATT_HANDLED</span><span class="p">)</span>
				<span class="cm">/* ERATT polling has handled ERATT */</span>
				<span class="n">ha_copy</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">HA_ERATT</span><span class="p">;</span>
			<span class="k">else</span>
				<span class="cm">/* Indicate interrupt handler handles ERATT */</span>
				<span class="n">phba</span><span class="o">-&gt;</span><span class="n">hba_flag</span> <span class="o">|=</span> <span class="n">HBA_ERATT_HANDLED</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 * If there is deferred error attention, do not check for any</span>
<span class="cm">		 * interrupt.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hba_flag</span> <span class="o">&amp;</span> <span class="n">DEFER_ERATT</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">,</span> <span class="n">iflag</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">IRQ_NONE</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* Clear up only attention source related to slow-path */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">lpfc_readl</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">HCregaddr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hc_copy</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">unplug_error</span><span class="p">;</span>

		<span class="n">writel</span><span class="p">(</span><span class="n">hc_copy</span> <span class="o">&amp;</span> <span class="o">~</span><span class="p">(</span><span class="n">HC_MBINT_ENA</span> <span class="o">|</span> <span class="n">HC_R2INT_ENA</span> <span class="o">|</span>
			<span class="n">HC_LAINT_ENA</span> <span class="o">|</span> <span class="n">HC_ERINT_ENA</span><span class="p">),</span>
			<span class="n">phba</span><span class="o">-&gt;</span><span class="n">HCregaddr</span><span class="p">);</span>
		<span class="n">writel</span><span class="p">((</span><span class="n">ha_copy</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">HA_MBATT</span> <span class="o">|</span> <span class="n">HA_R2_CLR_MSK</span><span class="p">)),</span>
			<span class="n">phba</span><span class="o">-&gt;</span><span class="n">HAregaddr</span><span class="p">);</span>
		<span class="n">writel</span><span class="p">(</span><span class="n">hc_copy</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">HCregaddr</span><span class="p">);</span>
		<span class="n">readl</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">HAregaddr</span><span class="p">);</span> <span class="cm">/* flush */</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">,</span> <span class="n">iflag</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">ha_copy</span> <span class="o">=</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">ha_copy</span><span class="p">;</span>

	<span class="n">work_ha_copy</span> <span class="o">=</span> <span class="n">ha_copy</span> <span class="o">&amp;</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">work_ha_mask</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">work_ha_copy</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">work_ha_copy</span> <span class="o">&amp;</span> <span class="n">HA_LATT</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli</span><span class="p">.</span><span class="n">sli_flag</span> <span class="o">&amp;</span> <span class="n">LPFC_PROCESS_LA</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/*</span>
<span class="cm">				 * Turn off Link Attention interrupts</span>
<span class="cm">				 * until CLEAR_LA done</span>
<span class="cm">				 */</span>
				<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">,</span> <span class="n">iflag</span><span class="p">);</span>
				<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli</span><span class="p">.</span><span class="n">sli_flag</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">LPFC_PROCESS_LA</span><span class="p">;</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">lpfc_readl</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">HCregaddr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">control</span><span class="p">))</span>
					<span class="k">goto</span> <span class="n">unplug_error</span><span class="p">;</span>
				<span class="n">control</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">HC_LAINT_ENA</span><span class="p">;</span>
				<span class="n">writel</span><span class="p">(</span><span class="n">control</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">HCregaddr</span><span class="p">);</span>
				<span class="n">readl</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">HCregaddr</span><span class="p">);</span> <span class="cm">/* flush */</span>
				<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">,</span> <span class="n">iflag</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="k">else</span>
				<span class="n">work_ha_copy</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">HA_LATT</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">work_ha_copy</span> <span class="o">&amp;</span> <span class="o">~</span><span class="p">(</span><span class="n">HA_ERATT</span> <span class="o">|</span> <span class="n">HA_MBATT</span> <span class="o">|</span> <span class="n">HA_LATT</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * Turn off Slow Rings interrupts, LPFC_ELS_RING is</span>
<span class="cm">			 * the only slow ring.</span>
<span class="cm">			 */</span>
			<span class="n">status</span> <span class="o">=</span> <span class="p">(</span><span class="n">work_ha_copy</span> <span class="o">&amp;</span>
				<span class="p">(</span><span class="n">HA_RXMASK</span>  <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="mi">4</span><span class="o">*</span><span class="n">LPFC_ELS_RING</span><span class="p">)));</span>
			<span class="n">status</span> <span class="o">&gt;&gt;=</span> <span class="p">(</span><span class="mi">4</span><span class="o">*</span><span class="n">LPFC_ELS_RING</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">HA_RXMASK</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">,</span> <span class="n">iflag</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">lpfc_readl</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">HCregaddr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">control</span><span class="p">))</span>
					<span class="k">goto</span> <span class="n">unplug_error</span><span class="p">;</span>

				<span class="n">lpfc_debugfs_slow_ring_trc</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span>
				<span class="s">&quot;ISR slow ring:   ctl:x%x stat:x%x isrcnt:x%x&quot;</span><span class="p">,</span>
				<span class="n">control</span><span class="p">,</span> <span class="n">status</span><span class="p">,</span>
				<span class="p">(</span><span class="kt">uint32_t</span><span class="p">)</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli</span><span class="p">.</span><span class="n">slistat</span><span class="p">.</span><span class="n">sli_intr</span><span class="p">);</span>

				<span class="k">if</span> <span class="p">(</span><span class="n">control</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">HC_R0INT_ENA</span> <span class="o">&lt;&lt;</span> <span class="n">LPFC_ELS_RING</span><span class="p">))</span> <span class="p">{</span>
					<span class="n">lpfc_debugfs_slow_ring_trc</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span>
						<span class="s">&quot;ISR Disable ring:&quot;</span>
						<span class="s">&quot;pwork:x%x hawork:x%x wait:x%x&quot;</span><span class="p">,</span>
						<span class="n">phba</span><span class="o">-&gt;</span><span class="n">work_ha</span><span class="p">,</span> <span class="n">work_ha_copy</span><span class="p">,</span>
						<span class="p">(</span><span class="kt">uint32_t</span><span class="p">)((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span>
						<span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">work_waitq</span><span class="p">));</span>

					<span class="n">control</span> <span class="o">&amp;=</span>
					    <span class="o">~</span><span class="p">(</span><span class="n">HC_R0INT_ENA</span> <span class="o">&lt;&lt;</span> <span class="n">LPFC_ELS_RING</span><span class="p">);</span>
					<span class="n">writel</span><span class="p">(</span><span class="n">control</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">HCregaddr</span><span class="p">);</span>
					<span class="n">readl</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">HCregaddr</span><span class="p">);</span> <span class="cm">/* flush */</span>
				<span class="p">}</span>
				<span class="k">else</span> <span class="p">{</span>
					<span class="n">lpfc_debugfs_slow_ring_trc</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span>
						<span class="s">&quot;ISR slow ring:   pwork:&quot;</span>
						<span class="s">&quot;x%x hawork:x%x wait:x%x&quot;</span><span class="p">,</span>
						<span class="n">phba</span><span class="o">-&gt;</span><span class="n">work_ha</span><span class="p">,</span> <span class="n">work_ha_copy</span><span class="p">,</span>
						<span class="p">(</span><span class="kt">uint32_t</span><span class="p">)((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span>
						<span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">work_waitq</span><span class="p">));</span>
				<span class="p">}</span>
				<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">,</span> <span class="n">iflag</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">,</span> <span class="n">iflag</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">work_ha_copy</span> <span class="o">&amp;</span> <span class="n">HA_ERATT</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">lpfc_sli_read_hs</span><span class="p">(</span><span class="n">phba</span><span class="p">))</span>
				<span class="k">goto</span> <span class="n">unplug_error</span><span class="p">;</span>
			<span class="cm">/*</span>
<span class="cm">			 * Check if there is a deferred error condition</span>
<span class="cm">			 * is active</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">HS_FFER1</span> <span class="o">&amp;</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">work_hs</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
				<span class="p">((</span><span class="n">HS_FFER2</span> <span class="o">|</span> <span class="n">HS_FFER3</span> <span class="o">|</span> <span class="n">HS_FFER4</span> <span class="o">|</span> <span class="n">HS_FFER5</span> <span class="o">|</span>
				  <span class="n">HS_FFER6</span> <span class="o">|</span> <span class="n">HS_FFER7</span> <span class="o">|</span> <span class="n">HS_FFER8</span><span class="p">)</span> <span class="o">&amp;</span>
				  <span class="n">phba</span><span class="o">-&gt;</span><span class="n">work_hs</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">phba</span><span class="o">-&gt;</span><span class="n">hba_flag</span> <span class="o">|=</span> <span class="n">DEFER_ERATT</span><span class="p">;</span>
				<span class="cm">/* Clear all interrupt enable conditions */</span>
				<span class="n">writel</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">HCregaddr</span><span class="p">);</span>
				<span class="n">readl</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">HCregaddr</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">((</span><span class="n">work_ha_copy</span> <span class="o">&amp;</span> <span class="n">HA_MBATT</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli</span><span class="p">.</span><span class="n">mbox_active</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">pmb</span> <span class="o">=</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli</span><span class="p">.</span><span class="n">mbox_active</span><span class="p">;</span>
			<span class="n">pmbox</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">pmb</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">mb</span><span class="p">;</span>
			<span class="n">mbox</span> <span class="o">=</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">mbox</span><span class="p">;</span>
			<span class="n">vport</span> <span class="o">=</span> <span class="n">pmb</span><span class="o">-&gt;</span><span class="n">vport</span><span class="p">;</span>

			<span class="cm">/* First check out the status word */</span>
			<span class="n">lpfc_sli_pcimem_bcopy</span><span class="p">(</span><span class="n">mbox</span><span class="p">,</span> <span class="n">pmbox</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">uint32_t</span><span class="p">));</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">pmbox</span><span class="o">-&gt;</span><span class="n">mbxOwner</span> <span class="o">!=</span> <span class="n">OWN_HOST</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">,</span> <span class="n">iflag</span><span class="p">);</span>
				<span class="cm">/*</span>
<span class="cm">				 * Stray Mailbox Interrupt, mbxCommand &lt;cmd&gt;</span>
<span class="cm">				 * mbxStatus &lt;status&gt;</span>
<span class="cm">				 */</span>
				<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_MBOX</span> <span class="o">|</span>
						<span class="n">LOG_SLI</span><span class="p">,</span>
						<span class="s">&quot;(%d):0304 Stray Mailbox &quot;</span>
						<span class="s">&quot;Interrupt mbxCommand x%x &quot;</span>
						<span class="s">&quot;mbxStatus x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
						<span class="p">(</span><span class="n">vport</span> <span class="o">?</span> <span class="n">vport</span><span class="o">-&gt;</span><span class="n">vpi</span> <span class="o">:</span> <span class="mi">0</span><span class="p">),</span>
						<span class="n">pmbox</span><span class="o">-&gt;</span><span class="n">mbxCommand</span><span class="p">,</span>
						<span class="n">pmbox</span><span class="o">-&gt;</span><span class="n">mbxStatus</span><span class="p">);</span>
				<span class="cm">/* clear mailbox attention bit */</span>
				<span class="n">work_ha_copy</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">HA_MBATT</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli</span><span class="p">.</span><span class="n">mbox_active</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
				<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">,</span> <span class="n">iflag</span><span class="p">);</span>
				<span class="n">phba</span><span class="o">-&gt;</span><span class="n">last_completion_time</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span>
				<span class="n">del_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli</span><span class="p">.</span><span class="n">mbox_tmo</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">pmb</span><span class="o">-&gt;</span><span class="n">mbox_cmpl</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">lpfc_sli_pcimem_bcopy</span><span class="p">(</span><span class="n">mbox</span><span class="p">,</span> <span class="n">pmbox</span><span class="p">,</span>
							<span class="n">MAILBOX_CMD_SIZE</span><span class="p">);</span>
					<span class="k">if</span> <span class="p">(</span><span class="n">pmb</span><span class="o">-&gt;</span><span class="n">out_ext_byte_len</span> <span class="o">&amp;&amp;</span>
						<span class="n">pmb</span><span class="o">-&gt;</span><span class="n">context2</span><span class="p">)</span>
						<span class="n">lpfc_sli_pcimem_bcopy</span><span class="p">(</span>
						<span class="n">phba</span><span class="o">-&gt;</span><span class="n">mbox_ext</span><span class="p">,</span>
						<span class="n">pmb</span><span class="o">-&gt;</span><span class="n">context2</span><span class="p">,</span>
						<span class="n">pmb</span><span class="o">-&gt;</span><span class="n">out_ext_byte_len</span><span class="p">);</span>
				<span class="p">}</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">pmb</span><span class="o">-&gt;</span><span class="n">mbox_flag</span> <span class="o">&amp;</span> <span class="n">LPFC_MBX_IMED_UNREG</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">pmb</span><span class="o">-&gt;</span><span class="n">mbox_flag</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">LPFC_MBX_IMED_UNREG</span><span class="p">;</span>

					<span class="n">lpfc_debugfs_disc_trc</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span>
						<span class="n">LPFC_DISC_TRC_MBOX_VPORT</span><span class="p">,</span>
						<span class="s">&quot;MBOX dflt rpi: : &quot;</span>
						<span class="s">&quot;status:x%x rpi:x%x&quot;</span><span class="p">,</span>
						<span class="p">(</span><span class="kt">uint32_t</span><span class="p">)</span><span class="n">pmbox</span><span class="o">-&gt;</span><span class="n">mbxStatus</span><span class="p">,</span>
						<span class="n">pmbox</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">varWords</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">0</span><span class="p">);</span>

					<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pmbox</span><span class="o">-&gt;</span><span class="n">mbxStatus</span><span class="p">)</span> <span class="p">{</span>
						<span class="n">mp</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_dmabuf</span> <span class="o">*</span><span class="p">)</span>
							<span class="p">(</span><span class="n">pmb</span><span class="o">-&gt;</span><span class="n">context1</span><span class="p">);</span>
						<span class="n">ndlp</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_nodelist</span> <span class="o">*</span><span class="p">)</span>
							<span class="n">pmb</span><span class="o">-&gt;</span><span class="n">context2</span><span class="p">;</span>

						<span class="cm">/* Reg_LOGIN of dflt RPI was</span>
<span class="cm">						 * successful. new lets get</span>
<span class="cm">						 * rid of the RPI using the</span>
<span class="cm">						 * same mbox buffer.</span>
<span class="cm">						 */</span>
						<span class="n">lpfc_unreg_login</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span>
							<span class="n">vport</span><span class="o">-&gt;</span><span class="n">vpi</span><span class="p">,</span>
							<span class="n">pmbox</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">varWords</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
							<span class="n">pmb</span><span class="p">);</span>
						<span class="n">pmb</span><span class="o">-&gt;</span><span class="n">mbox_cmpl</span> <span class="o">=</span>
							<span class="n">lpfc_mbx_cmpl_dflt_rpi</span><span class="p">;</span>
						<span class="n">pmb</span><span class="o">-&gt;</span><span class="n">context1</span> <span class="o">=</span> <span class="n">mp</span><span class="p">;</span>
						<span class="n">pmb</span><span class="o">-&gt;</span><span class="n">context2</span> <span class="o">=</span> <span class="n">ndlp</span><span class="p">;</span>
						<span class="n">pmb</span><span class="o">-&gt;</span><span class="n">vport</span> <span class="o">=</span> <span class="n">vport</span><span class="p">;</span>
						<span class="n">rc</span> <span class="o">=</span> <span class="n">lpfc_sli_issue_mbox</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span>
								<span class="n">pmb</span><span class="p">,</span>
								<span class="n">MBX_NOWAIT</span><span class="p">);</span>
						<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">!=</span> <span class="n">MBX_BUSY</span><span class="p">)</span>
							<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span>
							<span class="n">KERN_ERR</span><span class="p">,</span>
							<span class="n">LOG_MBOX</span> <span class="o">|</span> <span class="n">LOG_SLI</span><span class="p">,</span>
							<span class="s">&quot;0350 rc should have&quot;</span>
							<span class="s">&quot;been MBX_BUSY</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
						<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">!=</span> <span class="n">MBX_NOT_FINISHED</span><span class="p">)</span>
							<span class="k">goto</span> <span class="n">send_current_mbox</span><span class="p">;</span>
					<span class="p">}</span>
				<span class="p">}</span>
				<span class="n">spin_lock_irqsave</span><span class="p">(</span>
						<span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">pport</span><span class="o">-&gt;</span><span class="n">work_port_lock</span><span class="p">,</span>
						<span class="n">iflag</span><span class="p">);</span>
				<span class="n">phba</span><span class="o">-&gt;</span><span class="n">pport</span><span class="o">-&gt;</span><span class="n">work_port_events</span> <span class="o">&amp;=</span>
					<span class="o">~</span><span class="n">WORKER_MBOX_TMO</span><span class="p">;</span>
				<span class="n">spin_unlock_irqrestore</span><span class="p">(</span>
						<span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">pport</span><span class="o">-&gt;</span><span class="n">work_port_lock</span><span class="p">,</span>
						<span class="n">iflag</span><span class="p">);</span>
				<span class="n">lpfc_mbox_cmpl_put</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">pmb</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">,</span> <span class="n">iflag</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">((</span><span class="n">work_ha_copy</span> <span class="o">&amp;</span> <span class="n">HA_MBATT</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli</span><span class="p">.</span><span class="n">mbox_active</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">))</span> <span class="p">{</span>
<span class="nl">send_current_mbox:</span>
			<span class="cm">/* Process next mailbox command if there is one */</span>
			<span class="k">do</span> <span class="p">{</span>
				<span class="n">rc</span> <span class="o">=</span> <span class="n">lpfc_sli_issue_mbox</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span>
							 <span class="n">MBX_NOWAIT</span><span class="p">);</span>
			<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">rc</span> <span class="o">==</span> <span class="n">MBX_NOT_FINISHED</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">!=</span> <span class="n">MBX_SUCCESS</span><span class="p">)</span>
				<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_MBOX</span> <span class="o">|</span>
						<span class="n">LOG_SLI</span><span class="p">,</span> <span class="s">&quot;0349 rc should be &quot;</span>
						<span class="s">&quot;MBX_SUCCESS</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">,</span> <span class="n">iflag</span><span class="p">);</span>
		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">work_ha</span> <span class="o">|=</span> <span class="n">work_ha_copy</span><span class="p">;</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">,</span> <span class="n">iflag</span><span class="p">);</span>
		<span class="n">lpfc_worker_wake_up</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">IRQ_HANDLED</span><span class="p">;</span>
<span class="nl">unplug_error:</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">,</span> <span class="n">iflag</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">IRQ_HANDLED</span><span class="p">;</span>

<span class="p">}</span> <span class="cm">/* lpfc_sli_sp_intr_handler */</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_sli_fp_intr_handler - Fast-path interrupt handler to SLI-3 device.</span>
<span class="cm"> * @irq: Interrupt number.</span>
<span class="cm"> * @dev_id: The device context pointer.</span>
<span class="cm"> *</span>
<span class="cm"> * This function is directly called from the PCI layer as an interrupt</span>
<span class="cm"> * service routine when device with SLI-3 interface spec is enabled with</span>
<span class="cm"> * MSI-X multi-message interrupt mode and there is a fast-path FCP IOCB</span>
<span class="cm"> * ring event in the HBA. However, when the device is enabled with either</span>
<span class="cm"> * MSI or Pin-IRQ interrupt mode, this function is called as part of the</span>
<span class="cm"> * device-level interrupt handler. When the PCI slot is in error recovery</span>
<span class="cm"> * or the HBA is undergoing initialization, the interrupt handler will not</span>
<span class="cm"> * process the interrupt. The SCSI FCP fast-path ring event are handled in</span>
<span class="cm"> * the intrrupt context. This function is called without any lock held.</span>
<span class="cm"> * It gets the hbalock to access and update SLI data structures.</span>
<span class="cm"> *</span>
<span class="cm"> * This function returns IRQ_HANDLED when interrupt is handled else it</span>
<span class="cm"> * returns IRQ_NONE.</span>
<span class="cm"> **/</span>
<span class="n">irqreturn_t</span>
<span class="nf">lpfc_sli_fp_intr_handler</span><span class="p">(</span><span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">dev_id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpfc_hba</span>  <span class="o">*</span><span class="n">phba</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">ha_copy</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">status</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">iflag</span><span class="p">;</span>

	<span class="cm">/* Get the driver&#39;s phba structure from the dev_id and</span>
<span class="cm">	 * assume the HBA is not interrupting.</span>
<span class="cm">	 */</span>
	<span class="n">phba</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="p">)</span> <span class="n">dev_id</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">phba</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">IRQ_NONE</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Stuff needs to be attented to when this function is invoked as an</span>
<span class="cm">	 * individual interrupt handler in MSI-X multi-message interrupt mode</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">intr_type</span> <span class="o">==</span> <span class="n">MSIX</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Check device state for handling interrupt */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">lpfc_intr_state_check</span><span class="p">(</span><span class="n">phba</span><span class="p">))</span>
			<span class="k">return</span> <span class="n">IRQ_NONE</span><span class="p">;</span>
		<span class="cm">/* Need to read HA REG for FCP ring and other ring events */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">lpfc_readl</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">HAregaddr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ha_copy</span><span class="p">))</span>
			<span class="k">return</span> <span class="n">IRQ_HANDLED</span><span class="p">;</span>
		<span class="cm">/* Clear up only attention source related to fast-path */</span>
		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">,</span> <span class="n">iflag</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * If there is deferred error attention, do not check for</span>
<span class="cm">		 * any interrupt.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hba_flag</span> <span class="o">&amp;</span> <span class="n">DEFER_ERATT</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">,</span> <span class="n">iflag</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">IRQ_NONE</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">writel</span><span class="p">((</span><span class="n">ha_copy</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">HA_R0_CLR_MSK</span> <span class="o">|</span> <span class="n">HA_R1_CLR_MSK</span><span class="p">)),</span>
			<span class="n">phba</span><span class="o">-&gt;</span><span class="n">HAregaddr</span><span class="p">);</span>
		<span class="n">readl</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">HAregaddr</span><span class="p">);</span> <span class="cm">/* flush */</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">,</span> <span class="n">iflag</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">ha_copy</span> <span class="o">=</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">ha_copy</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Process all events on FCP ring. Take the optimized path for FCP IO.</span>
<span class="cm">	 */</span>
	<span class="n">ha_copy</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">work_ha_mask</span><span class="p">);</span>

	<span class="n">status</span> <span class="o">=</span> <span class="p">(</span><span class="n">ha_copy</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">HA_RXMASK</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="mi">4</span><span class="o">*</span><span class="n">LPFC_FCP_RING</span><span class="p">)));</span>
	<span class="n">status</span> <span class="o">&gt;&gt;=</span> <span class="p">(</span><span class="mi">4</span><span class="o">*</span><span class="n">LPFC_FCP_RING</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">HA_RXMASK</span><span class="p">)</span>
		<span class="n">lpfc_sli_handle_fast_ring_event</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span>
						<span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli</span><span class="p">.</span><span class="n">ring</span><span class="p">[</span><span class="n">LPFC_FCP_RING</span><span class="p">],</span>
						<span class="n">status</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">cfg_multi_ring_support</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Process all events on extra ring. Take the optimized path</span>
<span class="cm">		 * for extra ring IO.</span>
<span class="cm">		 */</span>
		<span class="n">status</span> <span class="o">=</span> <span class="p">(</span><span class="n">ha_copy</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">HA_RXMASK</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="mi">4</span><span class="o">*</span><span class="n">LPFC_EXTRA_RING</span><span class="p">)));</span>
		<span class="n">status</span> <span class="o">&gt;&gt;=</span> <span class="p">(</span><span class="mi">4</span><span class="o">*</span><span class="n">LPFC_EXTRA_RING</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">HA_RXMASK</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">lpfc_sli_handle_fast_ring_event</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span>
					<span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli</span><span class="p">.</span><span class="n">ring</span><span class="p">[</span><span class="n">LPFC_EXTRA_RING</span><span class="p">],</span>
					<span class="n">status</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">IRQ_HANDLED</span><span class="p">;</span>
<span class="p">}</span>  <span class="cm">/* lpfc_sli_fp_intr_handler */</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_sli_intr_handler - Device-level interrupt handler to SLI-3 device</span>
<span class="cm"> * @irq: Interrupt number.</span>
<span class="cm"> * @dev_id: The device context pointer.</span>
<span class="cm"> *</span>
<span class="cm"> * This function is the HBA device-level interrupt handler to device with</span>
<span class="cm"> * SLI-3 interface spec, called from the PCI layer when either MSI or</span>
<span class="cm"> * Pin-IRQ interrupt mode is enabled and there is an event in the HBA which</span>
<span class="cm"> * requires driver attention. This function invokes the slow-path interrupt</span>
<span class="cm"> * attention handling function and fast-path interrupt attention handling</span>
<span class="cm"> * function in turn to process the relevant HBA attention events. This</span>
<span class="cm"> * function is called without any lock held. It gets the hbalock to access</span>
<span class="cm"> * and update SLI data structures.</span>
<span class="cm"> *</span>
<span class="cm"> * This function returns IRQ_HANDLED when interrupt is handled, else it</span>
<span class="cm"> * returns IRQ_NONE.</span>
<span class="cm"> **/</span>
<span class="n">irqreturn_t</span>
<span class="nf">lpfc_sli_intr_handler</span><span class="p">(</span><span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">dev_id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpfc_hba</span>  <span class="o">*</span><span class="n">phba</span><span class="p">;</span>
	<span class="n">irqreturn_t</span> <span class="n">sp_irq_rc</span><span class="p">,</span> <span class="n">fp_irq_rc</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">status1</span><span class="p">,</span> <span class="n">status2</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">hc_copy</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Get the driver&#39;s phba structure from the dev_id and</span>
<span class="cm">	 * assume the HBA is not interrupting.</span>
<span class="cm">	 */</span>
	<span class="n">phba</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="p">)</span> <span class="n">dev_id</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">phba</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">IRQ_NONE</span><span class="p">;</span>

	<span class="cm">/* Check device state for handling interrupt */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">lpfc_intr_state_check</span><span class="p">(</span><span class="n">phba</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">IRQ_NONE</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">lpfc_readl</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">HAregaddr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">ha_copy</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">IRQ_HANDLED</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">ha_copy</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">IRQ_NONE</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">ha_copy</span> <span class="o">&amp;</span> <span class="n">HA_ERATT</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hba_flag</span> <span class="o">&amp;</span> <span class="n">HBA_ERATT_HANDLED</span><span class="p">)</span>
			<span class="cm">/* ERATT polling has handled ERATT */</span>
			<span class="n">phba</span><span class="o">-&gt;</span><span class="n">ha_copy</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">HA_ERATT</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="cm">/* Indicate interrupt handler handles ERATT */</span>
			<span class="n">phba</span><span class="o">-&gt;</span><span class="n">hba_flag</span> <span class="o">|=</span> <span class="n">HBA_ERATT_HANDLED</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * If there is deferred error attention, do not check for any interrupt.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hba_flag</span> <span class="o">&amp;</span> <span class="n">DEFER_ERATT</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">IRQ_NONE</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Clear attention sources except link and error attentions */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">lpfc_readl</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">HCregaddr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hc_copy</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">IRQ_HANDLED</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">hc_copy</span> <span class="o">&amp;</span> <span class="o">~</span><span class="p">(</span><span class="n">HC_MBINT_ENA</span> <span class="o">|</span> <span class="n">HC_R0INT_ENA</span> <span class="o">|</span> <span class="n">HC_R1INT_ENA</span>
		<span class="o">|</span> <span class="n">HC_R2INT_ENA</span> <span class="o">|</span> <span class="n">HC_LAINT_ENA</span> <span class="o">|</span> <span class="n">HC_ERINT_ENA</span><span class="p">),</span>
		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">HCregaddr</span><span class="p">);</span>
	<span class="n">writel</span><span class="p">((</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">ha_copy</span> <span class="o">&amp;</span> <span class="o">~</span><span class="p">(</span><span class="n">HA_LATT</span> <span class="o">|</span> <span class="n">HA_ERATT</span><span class="p">)),</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">HAregaddr</span><span class="p">);</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">hc_copy</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">HCregaddr</span><span class="p">);</span>
	<span class="n">readl</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">HAregaddr</span><span class="p">);</span> <span class="cm">/* flush */</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Invokes slow-path host attention interrupt handling as appropriate.</span>
<span class="cm">	 */</span>

	<span class="cm">/* status of events with mailbox and link attention */</span>
	<span class="n">status1</span> <span class="o">=</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">ha_copy</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">HA_MBATT</span> <span class="o">|</span> <span class="n">HA_LATT</span> <span class="o">|</span> <span class="n">HA_ERATT</span><span class="p">);</span>

	<span class="cm">/* status of events with ELS ring */</span>
	<span class="n">status2</span> <span class="o">=</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">ha_copy</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">HA_RXMASK</span>  <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="mi">4</span><span class="o">*</span><span class="n">LPFC_ELS_RING</span><span class="p">)));</span>
	<span class="n">status2</span> <span class="o">&gt;&gt;=</span> <span class="p">(</span><span class="mi">4</span><span class="o">*</span><span class="n">LPFC_ELS_RING</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">status1</span> <span class="o">||</span> <span class="p">(</span><span class="n">status2</span> <span class="o">&amp;</span> <span class="n">HA_RXMASK</span><span class="p">))</span>
		<span class="n">sp_irq_rc</span> <span class="o">=</span> <span class="n">lpfc_sli_sp_intr_handler</span><span class="p">(</span><span class="n">irq</span><span class="p">,</span> <span class="n">dev_id</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">sp_irq_rc</span> <span class="o">=</span> <span class="n">IRQ_NONE</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Invoke fast-path host attention interrupt handling as appropriate.</span>
<span class="cm">	 */</span>

	<span class="cm">/* status of events with FCP ring */</span>
	<span class="n">status1</span> <span class="o">=</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">ha_copy</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">HA_RXMASK</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="mi">4</span><span class="o">*</span><span class="n">LPFC_FCP_RING</span><span class="p">)));</span>
	<span class="n">status1</span> <span class="o">&gt;&gt;=</span> <span class="p">(</span><span class="mi">4</span><span class="o">*</span><span class="n">LPFC_FCP_RING</span><span class="p">);</span>

	<span class="cm">/* status of events with extra ring */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">cfg_multi_ring_support</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">status2</span> <span class="o">=</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">ha_copy</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">HA_RXMASK</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="mi">4</span><span class="o">*</span><span class="n">LPFC_EXTRA_RING</span><span class="p">)));</span>
		<span class="n">status2</span> <span class="o">&gt;&gt;=</span> <span class="p">(</span><span class="mi">4</span><span class="o">*</span><span class="n">LPFC_EXTRA_RING</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">status2</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">status1</span> <span class="o">&amp;</span> <span class="n">HA_RXMASK</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">status2</span> <span class="o">&amp;</span> <span class="n">HA_RXMASK</span><span class="p">))</span>
		<span class="n">fp_irq_rc</span> <span class="o">=</span> <span class="n">lpfc_sli_fp_intr_handler</span><span class="p">(</span><span class="n">irq</span><span class="p">,</span> <span class="n">dev_id</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">fp_irq_rc</span> <span class="o">=</span> <span class="n">IRQ_NONE</span><span class="p">;</span>

	<span class="cm">/* Return device-level interrupt handling status */</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">sp_irq_rc</span> <span class="o">==</span> <span class="n">IRQ_HANDLED</span><span class="p">)</span> <span class="o">?</span> <span class="n">sp_irq_rc</span> <span class="o">:</span> <span class="n">fp_irq_rc</span><span class="p">;</span>
<span class="p">}</span>  <span class="cm">/* lpfc_sli_intr_handler */</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_sli4_fcp_xri_abort_event_proc - Process fcp xri abort event</span>
<span class="cm"> * @phba: pointer to lpfc hba data structure.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine is invoked by the worker thread to process all the pending</span>
<span class="cm"> * SLI4 FCP abort XRI events.</span>
<span class="cm"> **/</span>
<span class="kt">void</span> <span class="nf">lpfc_sli4_fcp_xri_abort_event_proc</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpfc_cq_event</span> <span class="o">*</span><span class="n">cq_event</span><span class="p">;</span>

	<span class="cm">/* First, declare the fcp xri abort event has been handled */</span>
	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">hba_flag</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">FCP_XRI_ABORT_EVENT</span><span class="p">;</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>
	<span class="cm">/* Now, handle all the fcp xri abort events */</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">sp_fcp_xri_aborted_work_queue</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* Get the first event from the head of the event queue */</span>
		<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>
		<span class="n">list_remove_head</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">sp_fcp_xri_aborted_work_queue</span><span class="p">,</span>
				 <span class="n">cq_event</span><span class="p">,</span> <span class="k">struct</span> <span class="n">lpfc_cq_event</span><span class="p">,</span> <span class="n">list</span><span class="p">);</span>
		<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>
		<span class="cm">/* Notify aborted XRI for FCP work queue */</span>
		<span class="n">lpfc_sli4_fcp_xri_aborted</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cq_event</span><span class="o">-&gt;</span><span class="n">cqe</span><span class="p">.</span><span class="n">wcqe_axri</span><span class="p">);</span>
		<span class="cm">/* Free the event processed back to the free pool */</span>
		<span class="n">lpfc_sli4_cq_event_release</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">cq_event</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_sli4_els_xri_abort_event_proc - Process els xri abort event</span>
<span class="cm"> * @phba: pointer to lpfc hba data structure.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine is invoked by the worker thread to process all the pending</span>
<span class="cm"> * SLI4 els abort xri events.</span>
<span class="cm"> **/</span>
<span class="kt">void</span> <span class="nf">lpfc_sli4_els_xri_abort_event_proc</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpfc_cq_event</span> <span class="o">*</span><span class="n">cq_event</span><span class="p">;</span>

	<span class="cm">/* First, declare the els xri abort event has been handled */</span>
	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">hba_flag</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">ELS_XRI_ABORT_EVENT</span><span class="p">;</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>
	<span class="cm">/* Now, handle all the els xri abort events */</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">sp_els_xri_aborted_work_queue</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* Get the first event from the head of the event queue */</span>
		<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>
		<span class="n">list_remove_head</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">sp_els_xri_aborted_work_queue</span><span class="p">,</span>
				 <span class="n">cq_event</span><span class="p">,</span> <span class="k">struct</span> <span class="n">lpfc_cq_event</span><span class="p">,</span> <span class="n">list</span><span class="p">);</span>
		<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>
		<span class="cm">/* Notify aborted XRI for ELS work queue */</span>
		<span class="n">lpfc_sli4_els_xri_aborted</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cq_event</span><span class="o">-&gt;</span><span class="n">cqe</span><span class="p">.</span><span class="n">wcqe_axri</span><span class="p">);</span>
		<span class="cm">/* Free the event processed back to the free pool */</span>
		<span class="n">lpfc_sli4_cq_event_release</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">cq_event</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_sli4_iocb_param_transfer - Transfer pIocbOut and cmpl status to pIocbIn</span>
<span class="cm"> * @phba: pointer to lpfc hba data structure</span>
<span class="cm"> * @pIocbIn: pointer to the rspiocbq</span>
<span class="cm"> * @pIocbOut: pointer to the cmdiocbq</span>
<span class="cm"> * @wcqe: pointer to the complete wcqe</span>
<span class="cm"> *</span>
<span class="cm"> * This routine transfers the fields of a command iocbq to a response iocbq</span>
<span class="cm"> * by copying all the IOCB fields from command iocbq and transferring the</span>
<span class="cm"> * completion status information from the complete wcqe.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">lpfc_sli4_iocb_param_transfer</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">lpfc_iocbq</span> <span class="o">*</span><span class="n">pIocbIn</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">lpfc_iocbq</span> <span class="o">*</span><span class="n">pIocbOut</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">lpfc_wcqe_complete</span> <span class="o">*</span><span class="n">wcqe</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">iflags</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">status</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">offset</span> <span class="o">=</span> <span class="n">offsetof</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_iocbq</span><span class="p">,</span> <span class="n">iocb</span><span class="p">);</span>

	<span class="n">memcpy</span><span class="p">((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">pIocbIn</span> <span class="o">+</span> <span class="n">offset</span><span class="p">,</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">pIocbOut</span> <span class="o">+</span> <span class="n">offset</span><span class="p">,</span>
	       <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_iocbq</span><span class="p">)</span> <span class="o">-</span> <span class="n">offset</span><span class="p">);</span>
	<span class="cm">/* Map WCQE parameters into irspiocb parameters */</span>
	<span class="n">status</span> <span class="o">=</span> <span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_wcqe_c_status</span><span class="p">,</span> <span class="n">wcqe</span><span class="p">);</span>
	<span class="n">pIocbIn</span><span class="o">-&gt;</span><span class="n">iocb</span><span class="p">.</span><span class="n">ulpStatus</span> <span class="o">=</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">LPFC_IOCB_STATUS_MASK</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pIocbOut</span><span class="o">-&gt;</span><span class="n">iocb_flag</span> <span class="o">&amp;</span> <span class="n">LPFC_IO_FCP</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pIocbIn</span><span class="o">-&gt;</span><span class="n">iocb</span><span class="p">.</span><span class="n">ulpStatus</span> <span class="o">==</span> <span class="n">IOSTAT_FCP_RSP_ERROR</span><span class="p">)</span>
			<span class="n">pIocbIn</span><span class="o">-&gt;</span><span class="n">iocb</span><span class="p">.</span><span class="n">un</span><span class="p">.</span><span class="n">fcpi</span><span class="p">.</span><span class="n">fcpi_parm</span> <span class="o">=</span>
					<span class="n">pIocbOut</span><span class="o">-&gt;</span><span class="n">iocb</span><span class="p">.</span><span class="n">un</span><span class="p">.</span><span class="n">fcpi</span><span class="p">.</span><span class="n">fcpi_parm</span> <span class="o">-</span>
					<span class="n">wcqe</span><span class="o">-&gt;</span><span class="n">total_data_placed</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">pIocbIn</span><span class="o">-&gt;</span><span class="n">iocb</span><span class="p">.</span><span class="n">un</span><span class="p">.</span><span class="n">ulpWord</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="n">wcqe</span><span class="o">-&gt;</span><span class="n">parameter</span><span class="p">;</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="n">pIocbIn</span><span class="o">-&gt;</span><span class="n">iocb</span><span class="p">.</span><span class="n">un</span><span class="p">.</span><span class="n">ulpWord</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="n">wcqe</span><span class="o">-&gt;</span><span class="n">parameter</span><span class="p">;</span>
		<span class="n">pIocbIn</span><span class="o">-&gt;</span><span class="n">iocb</span><span class="p">.</span><span class="n">un</span><span class="p">.</span><span class="n">genreq64</span><span class="p">.</span><span class="n">bdl</span><span class="p">.</span><span class="n">bdeSize</span> <span class="o">=</span> <span class="n">wcqe</span><span class="o">-&gt;</span><span class="n">total_data_placed</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Convert BG errors for completion status */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">==</span> <span class="n">CQE_STATUS_DI_ERROR</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pIocbIn</span><span class="o">-&gt;</span><span class="n">iocb</span><span class="p">.</span><span class="n">ulpStatus</span> <span class="o">=</span> <span class="n">IOSTAT_LOCAL_REJECT</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_wcqe_c_bg_edir</span><span class="p">,</span> <span class="n">wcqe</span><span class="p">))</span>
			<span class="n">pIocbIn</span><span class="o">-&gt;</span><span class="n">iocb</span><span class="p">.</span><span class="n">un</span><span class="p">.</span><span class="n">ulpWord</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="n">IOERR_RX_DMA_FAILED</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">pIocbIn</span><span class="o">-&gt;</span><span class="n">iocb</span><span class="p">.</span><span class="n">un</span><span class="p">.</span><span class="n">ulpWord</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="n">IOERR_TX_DMA_FAILED</span><span class="p">;</span>

		<span class="n">pIocbIn</span><span class="o">-&gt;</span><span class="n">iocb</span><span class="p">.</span><span class="n">unsli3</span><span class="p">.</span><span class="n">sli3_bg</span><span class="p">.</span><span class="n">bgstat</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_wcqe_c_bg_ge</span><span class="p">,</span> <span class="n">wcqe</span><span class="p">))</span> <span class="cm">/* Guard Check failed */</span>
			<span class="n">pIocbIn</span><span class="o">-&gt;</span><span class="n">iocb</span><span class="p">.</span><span class="n">unsli3</span><span class="p">.</span><span class="n">sli3_bg</span><span class="p">.</span><span class="n">bgstat</span> <span class="o">|=</span>
				<span class="n">BGS_GUARD_ERR_MASK</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_wcqe_c_bg_ae</span><span class="p">,</span> <span class="n">wcqe</span><span class="p">))</span> <span class="cm">/* App Tag Check failed */</span>
			<span class="n">pIocbIn</span><span class="o">-&gt;</span><span class="n">iocb</span><span class="p">.</span><span class="n">unsli3</span><span class="p">.</span><span class="n">sli3_bg</span><span class="p">.</span><span class="n">bgstat</span> <span class="o">|=</span>
				<span class="n">BGS_APPTAG_ERR_MASK</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_wcqe_c_bg_re</span><span class="p">,</span> <span class="n">wcqe</span><span class="p">))</span> <span class="cm">/* Ref Tag Check failed */</span>
			<span class="n">pIocbIn</span><span class="o">-&gt;</span><span class="n">iocb</span><span class="p">.</span><span class="n">unsli3</span><span class="p">.</span><span class="n">sli3_bg</span><span class="p">.</span><span class="n">bgstat</span> <span class="o">|=</span>
				<span class="n">BGS_REFTAG_ERR_MASK</span><span class="p">;</span>

		<span class="cm">/* Check to see if there was any good data before the error */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_wcqe_c_bg_tdpv</span><span class="p">,</span> <span class="n">wcqe</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">pIocbIn</span><span class="o">-&gt;</span><span class="n">iocb</span><span class="p">.</span><span class="n">unsli3</span><span class="p">.</span><span class="n">sli3_bg</span><span class="p">.</span><span class="n">bgstat</span> <span class="o">|=</span>
				<span class="n">BGS_HI_WATER_MARK_PRESENT_MASK</span><span class="p">;</span>
			<span class="n">pIocbIn</span><span class="o">-&gt;</span><span class="n">iocb</span><span class="p">.</span><span class="n">unsli3</span><span class="p">.</span><span class="n">sli3_bg</span><span class="p">.</span><span class="n">bghm</span> <span class="o">=</span>
				<span class="n">wcqe</span><span class="o">-&gt;</span><span class="n">total_data_placed</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		* Set ALL the error bits to indicate we don&#39;t know what</span>
<span class="cm">		* type of error it is.</span>
<span class="cm">		*/</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pIocbIn</span><span class="o">-&gt;</span><span class="n">iocb</span><span class="p">.</span><span class="n">unsli3</span><span class="p">.</span><span class="n">sli3_bg</span><span class="p">.</span><span class="n">bgstat</span><span class="p">)</span>
			<span class="n">pIocbIn</span><span class="o">-&gt;</span><span class="n">iocb</span><span class="p">.</span><span class="n">unsli3</span><span class="p">.</span><span class="n">sli3_bg</span><span class="p">.</span><span class="n">bgstat</span> <span class="o">|=</span>
				<span class="p">(</span><span class="n">BGS_REFTAG_ERR_MASK</span> <span class="o">|</span> <span class="n">BGS_APPTAG_ERR_MASK</span> <span class="o">|</span>
				<span class="n">BGS_GUARD_ERR_MASK</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Pick up HBA exchange busy condition */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_wcqe_c_xb</span><span class="p">,</span> <span class="n">wcqe</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">,</span> <span class="n">iflags</span><span class="p">);</span>
		<span class="n">pIocbIn</span><span class="o">-&gt;</span><span class="n">iocb_flag</span> <span class="o">|=</span> <span class="n">LPFC_EXCHANGE_BUSY</span><span class="p">;</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">,</span> <span class="n">iflags</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_sli4_els_wcqe_to_rspiocbq - Get response iocbq from els wcqe</span>
<span class="cm"> * @phba: Pointer to HBA context object.</span>
<span class="cm"> * @wcqe: Pointer to work-queue completion queue entry.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine handles an ELS work-queue completion event and construct</span>
<span class="cm"> * a pseudo response ELS IODBQ from the SLI4 ELS WCQE for the common</span>
<span class="cm"> * discovery engine to handle.</span>
<span class="cm"> *</span>
<span class="cm"> * Return: Pointer to the receive IOCBQ, NULL otherwise.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">lpfc_iocbq</span> <span class="o">*</span>
<span class="nf">lpfc_sli4_els_wcqe_to_rspiocbq</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">lpfc_iocbq</span> <span class="o">*</span><span class="n">irspiocbq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpfc_sli_ring</span> <span class="o">*</span><span class="n">pring</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli</span><span class="p">.</span><span class="n">ring</span><span class="p">[</span><span class="n">LPFC_ELS_RING</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">lpfc_iocbq</span> <span class="o">*</span><span class="n">cmdiocbq</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_wcqe_complete</span> <span class="o">*</span><span class="n">wcqe</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">iflags</span><span class="p">;</span>

	<span class="n">wcqe</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">irspiocbq</span><span class="o">-&gt;</span><span class="n">cq_event</span><span class="p">.</span><span class="n">cqe</span><span class="p">.</span><span class="n">wcqe_cmpl</span><span class="p">;</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">,</span> <span class="n">iflags</span><span class="p">);</span>
	<span class="n">pring</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">iocb_event</span><span class="o">++</span><span class="p">;</span>
	<span class="cm">/* Look up the ELS command IOCB and create pseudo response IOCB */</span>
	<span class="n">cmdiocbq</span> <span class="o">=</span> <span class="n">lpfc_sli_iocbq_lookup_by_tag</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">pring</span><span class="p">,</span>
				<span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_wcqe_c_request_tag</span><span class="p">,</span> <span class="n">wcqe</span><span class="p">));</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">,</span> <span class="n">iflags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">cmdiocbq</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_WARNING</span><span class="p">,</span> <span class="n">LOG_SLI</span><span class="p">,</span>
				<span class="s">&quot;0386 ELS complete with no corresponding &quot;</span>
				<span class="s">&quot;cmdiocb: iotag (%d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_wcqe_c_request_tag</span><span class="p">,</span> <span class="n">wcqe</span><span class="p">));</span>
		<span class="n">lpfc_sli_release_iocbq</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">irspiocbq</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Fake the irspiocbq and copy necessary response information */</span>
	<span class="n">lpfc_sli4_iocb_param_transfer</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">irspiocbq</span><span class="p">,</span> <span class="n">cmdiocbq</span><span class="p">,</span> <span class="n">wcqe</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">irspiocbq</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_sli4_sp_handle_async_event - Handle an asynchroous event</span>
<span class="cm"> * @phba: Pointer to HBA context object.</span>
<span class="cm"> * @cqe: Pointer to mailbox completion queue entry.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine process a mailbox completion queue entry with asynchrous</span>
<span class="cm"> * event.</span>
<span class="cm"> *</span>
<span class="cm"> * Return: true if work posted to worker thread, otherwise false.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="n">bool</span>
<span class="nf">lpfc_sli4_sp_handle_async_event</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">,</span> <span class="k">struct</span> <span class="n">lpfc_mcqe</span> <span class="o">*</span><span class="n">mcqe</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpfc_cq_event</span> <span class="o">*</span><span class="n">cq_event</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">iflags</span><span class="p">;</span>

	<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_INFO</span><span class="p">,</span> <span class="n">LOG_SLI</span><span class="p">,</span>
			<span class="s">&quot;0392 Async Event: word0:x%x, word1:x%x, &quot;</span>
			<span class="s">&quot;word2:x%x, word3:x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">mcqe</span><span class="o">-&gt;</span><span class="n">word0</span><span class="p">,</span>
			<span class="n">mcqe</span><span class="o">-&gt;</span><span class="n">mcqe_tag0</span><span class="p">,</span> <span class="n">mcqe</span><span class="o">-&gt;</span><span class="n">mcqe_tag1</span><span class="p">,</span> <span class="n">mcqe</span><span class="o">-&gt;</span><span class="n">trailer</span><span class="p">);</span>

	<span class="cm">/* Allocate a new internal CQ_EVENT entry */</span>
	<span class="n">cq_event</span> <span class="o">=</span> <span class="n">lpfc_sli4_cq_event_alloc</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cq_event</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_SLI</span><span class="p">,</span>
				<span class="s">&quot;0394 Failed to allocate CQ_EVENT entry</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Move the CQE into an asynchronous event entry */</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cq_event</span><span class="o">-&gt;</span><span class="n">cqe</span><span class="p">,</span> <span class="n">mcqe</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_mcqe</span><span class="p">));</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">,</span> <span class="n">iflags</span><span class="p">);</span>
	<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cq_event</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">sp_asynce_work_queue</span><span class="p">);</span>
	<span class="cm">/* Set the async event flag */</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">hba_flag</span> <span class="o">|=</span> <span class="n">ASYNC_EVENT</span><span class="p">;</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">,</span> <span class="n">iflags</span><span class="p">);</span>

	<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_sli4_sp_handle_mbox_event - Handle a mailbox completion event</span>
<span class="cm"> * @phba: Pointer to HBA context object.</span>
<span class="cm"> * @cqe: Pointer to mailbox completion queue entry.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine process a mailbox completion queue entry with mailbox</span>
<span class="cm"> * completion event.</span>
<span class="cm"> *</span>
<span class="cm"> * Return: true if work posted to worker thread, otherwise false.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="n">bool</span>
<span class="nf">lpfc_sli4_sp_handle_mbox_event</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">,</span> <span class="k">struct</span> <span class="n">lpfc_mcqe</span> <span class="o">*</span><span class="n">mcqe</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">uint32_t</span> <span class="n">mcqe_status</span><span class="p">;</span>
	<span class="n">MAILBOX_t</span> <span class="o">*</span><span class="n">mbox</span><span class="p">,</span> <span class="o">*</span><span class="n">pmbox</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_mqe</span> <span class="o">*</span><span class="n">mqe</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="n">vport</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_nodelist</span> <span class="o">*</span><span class="n">ndlp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_dmabuf</span> <span class="o">*</span><span class="n">mp</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">iflags</span><span class="p">;</span>
	<span class="n">LPFC_MBOXQ_t</span> <span class="o">*</span><span class="n">pmb</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">workposted</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="cm">/* If not a mailbox complete MCQE, out by checking mailbox consume */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_trailer_completed</span><span class="p">,</span> <span class="n">mcqe</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out_no_mqe_complete</span><span class="p">;</span>

	<span class="cm">/* Get the reference to the active mbox command */</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">,</span> <span class="n">iflags</span><span class="p">);</span>
	<span class="n">pmb</span> <span class="o">=</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli</span><span class="p">.</span><span class="n">mbox_active</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">pmb</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_MBOX</span><span class="p">,</span>
				<span class="s">&quot;1832 No pending MBOX command to handle</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">,</span> <span class="n">iflags</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_no_mqe_complete</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">,</span> <span class="n">iflags</span><span class="p">);</span>
	<span class="n">mqe</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">pmb</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">mqe</span><span class="p">;</span>
	<span class="n">pmbox</span> <span class="o">=</span> <span class="p">(</span><span class="n">MAILBOX_t</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">pmb</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">mqe</span><span class="p">;</span>
	<span class="n">mbox</span> <span class="o">=</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">mbox</span><span class="p">;</span>
	<span class="n">vport</span> <span class="o">=</span> <span class="n">pmb</span><span class="o">-&gt;</span><span class="n">vport</span><span class="p">;</span>

	<span class="cm">/* Reset heartbeat timer */</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">last_completion_time</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span>
	<span class="n">del_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli</span><span class="p">.</span><span class="n">mbox_tmo</span><span class="p">);</span>

	<span class="cm">/* Move mbox data to caller&#39;s mailbox region, do endian swapping */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pmb</span><span class="o">-&gt;</span><span class="n">mbox_cmpl</span> <span class="o">&amp;&amp;</span> <span class="n">mbox</span><span class="p">)</span>
		<span class="n">lpfc_sli_pcimem_bcopy</span><span class="p">(</span><span class="n">mbox</span><span class="p">,</span> <span class="n">mqe</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_mqe</span><span class="p">));</span>

	<span class="cm">/*</span>
<span class="cm">	 * For mcqe errors, conditionally move a modified error code to</span>
<span class="cm">	 * the mbox so that the error will not be missed.</span>
<span class="cm">	 */</span>
	<span class="n">mcqe_status</span> <span class="o">=</span> <span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_mcqe_status</span><span class="p">,</span> <span class="n">mcqe</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mcqe_status</span> <span class="o">!=</span> <span class="n">MB_CQE_STATUS_SUCCESS</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_mqe_status</span><span class="p">,</span> <span class="n">mqe</span><span class="p">)</span> <span class="o">==</span> <span class="n">MBX_SUCCESS</span><span class="p">)</span>
			<span class="n">bf_set</span><span class="p">(</span><span class="n">lpfc_mqe_status</span><span class="p">,</span> <span class="n">mqe</span><span class="p">,</span>
			       <span class="p">(</span><span class="n">LPFC_MBX_ERROR_RANGE</span> <span class="o">|</span> <span class="n">mcqe_status</span><span class="p">));</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pmb</span><span class="o">-&gt;</span><span class="n">mbox_flag</span> <span class="o">&amp;</span> <span class="n">LPFC_MBX_IMED_UNREG</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pmb</span><span class="o">-&gt;</span><span class="n">mbox_flag</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">LPFC_MBX_IMED_UNREG</span><span class="p">;</span>
		<span class="n">lpfc_debugfs_disc_trc</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">LPFC_DISC_TRC_MBOX_VPORT</span><span class="p">,</span>
				      <span class="s">&quot;MBOX dflt rpi: status:x%x rpi:x%x&quot;</span><span class="p">,</span>
				      <span class="n">mcqe_status</span><span class="p">,</span>
				      <span class="n">pmbox</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">varWords</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">mcqe_status</span> <span class="o">==</span> <span class="n">MB_CQE_STATUS_SUCCESS</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">mp</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_dmabuf</span> <span class="o">*</span><span class="p">)(</span><span class="n">pmb</span><span class="o">-&gt;</span><span class="n">context1</span><span class="p">);</span>
			<span class="n">ndlp</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_nodelist</span> <span class="o">*</span><span class="p">)</span><span class="n">pmb</span><span class="o">-&gt;</span><span class="n">context2</span><span class="p">;</span>
			<span class="cm">/* Reg_LOGIN of dflt RPI was successful. Now lets get</span>
<span class="cm">			 * RID of the PPI using the same mbox buffer.</span>
<span class="cm">			 */</span>
			<span class="n">lpfc_unreg_login</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">vport</span><span class="o">-&gt;</span><span class="n">vpi</span><span class="p">,</span>
					 <span class="n">pmbox</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">varWords</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">pmb</span><span class="p">);</span>
			<span class="n">pmb</span><span class="o">-&gt;</span><span class="n">mbox_cmpl</span> <span class="o">=</span> <span class="n">lpfc_mbx_cmpl_dflt_rpi</span><span class="p">;</span>
			<span class="n">pmb</span><span class="o">-&gt;</span><span class="n">context1</span> <span class="o">=</span> <span class="n">mp</span><span class="p">;</span>
			<span class="n">pmb</span><span class="o">-&gt;</span><span class="n">context2</span> <span class="o">=</span> <span class="n">ndlp</span><span class="p">;</span>
			<span class="n">pmb</span><span class="o">-&gt;</span><span class="n">vport</span> <span class="o">=</span> <span class="n">vport</span><span class="p">;</span>
			<span class="n">rc</span> <span class="o">=</span> <span class="n">lpfc_sli_issue_mbox</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">pmb</span><span class="p">,</span> <span class="n">MBX_NOWAIT</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">!=</span> <span class="n">MBX_BUSY</span><span class="p">)</span>
				<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_MBOX</span> <span class="o">|</span>
						<span class="n">LOG_SLI</span><span class="p">,</span> <span class="s">&quot;0385 rc should &quot;</span>
						<span class="s">&quot;have been MBX_BUSY</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">!=</span> <span class="n">MBX_NOT_FINISHED</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">send_current_mbox</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">pport</span><span class="o">-&gt;</span><span class="n">work_port_lock</span><span class="p">,</span> <span class="n">iflags</span><span class="p">);</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">pport</span><span class="o">-&gt;</span><span class="n">work_port_events</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">WORKER_MBOX_TMO</span><span class="p">;</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">pport</span><span class="o">-&gt;</span><span class="n">work_port_lock</span><span class="p">,</span> <span class="n">iflags</span><span class="p">);</span>

	<span class="cm">/* There is mailbox completion work to do */</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">,</span> <span class="n">iflags</span><span class="p">);</span>
	<span class="n">__lpfc_mbox_cmpl_put</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">pmb</span><span class="p">);</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">work_ha</span> <span class="o">|=</span> <span class="n">HA_MBATT</span><span class="p">;</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">,</span> <span class="n">iflags</span><span class="p">);</span>
	<span class="n">workposted</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>

<span class="nl">send_current_mbox:</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">,</span> <span class="n">iflags</span><span class="p">);</span>
	<span class="cm">/* Release the mailbox command posting token */</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli</span><span class="p">.</span><span class="n">sli_flag</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">LPFC_SLI_MBOX_ACTIVE</span><span class="p">;</span>
	<span class="cm">/* Setting active mailbox pointer need to be in sync to flag clear */</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli</span><span class="p">.</span><span class="n">mbox_active</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">,</span> <span class="n">iflags</span><span class="p">);</span>
	<span class="cm">/* Wake up worker thread to post the next pending mailbox command */</span>
	<span class="n">lpfc_worker_wake_up</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
<span class="nl">out_no_mqe_complete:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_trailer_consumed</span><span class="p">,</span> <span class="n">mcqe</span><span class="p">))</span>
		<span class="n">lpfc_sli4_mq_release</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">mbx_wq</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">workposted</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_sli4_sp_handle_mcqe - Process a mailbox completion queue entry</span>
<span class="cm"> * @phba: Pointer to HBA context object.</span>
<span class="cm"> * @cqe: Pointer to mailbox completion queue entry.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine process a mailbox completion queue entry, it invokes the</span>
<span class="cm"> * proper mailbox complete handling or asynchrous event handling routine</span>
<span class="cm"> * according to the MCQE&#39;s async bit.</span>
<span class="cm"> *</span>
<span class="cm"> * Return: true if work posted to worker thread, otherwise false.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="n">bool</span>
<span class="nf">lpfc_sli4_sp_handle_mcqe</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">,</span> <span class="k">struct</span> <span class="n">lpfc_cqe</span> <span class="o">*</span><span class="n">cqe</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpfc_mcqe</span> <span class="n">mcqe</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">workposted</span><span class="p">;</span>

	<span class="cm">/* Copy the mailbox MCQE and convert endian order as needed */</span>
	<span class="n">lpfc_sli_pcimem_bcopy</span><span class="p">(</span><span class="n">cqe</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mcqe</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_mcqe</span><span class="p">));</span>

	<span class="cm">/* Invoke the proper event handling routine */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_trailer_async</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mcqe</span><span class="p">))</span>
		<span class="n">workposted</span> <span class="o">=</span> <span class="n">lpfc_sli4_sp_handle_mbox_event</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mcqe</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">workposted</span> <span class="o">=</span> <span class="n">lpfc_sli4_sp_handle_async_event</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mcqe</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">workposted</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_sli4_sp_handle_els_wcqe - Handle els work-queue completion event</span>
<span class="cm"> * @phba: Pointer to HBA context object.</span>
<span class="cm"> * @wcqe: Pointer to work-queue completion queue entry.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine handles an ELS work-queue completion event.</span>
<span class="cm"> *</span>
<span class="cm"> * Return: true if work posted to worker thread, otherwise false.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="n">bool</span>
<span class="nf">lpfc_sli4_sp_handle_els_wcqe</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">lpfc_wcqe_complete</span> <span class="o">*</span><span class="n">wcqe</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpfc_iocbq</span> <span class="o">*</span><span class="n">irspiocbq</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">iflags</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_sli_ring</span> <span class="o">*</span><span class="n">pring</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli</span><span class="p">.</span><span class="n">ring</span><span class="p">[</span><span class="n">LPFC_FCP_RING</span><span class="p">];</span>

	<span class="cm">/* Get an irspiocbq for later ELS response processing use */</span>
	<span class="n">irspiocbq</span> <span class="o">=</span> <span class="n">lpfc_sli_get_iocbq</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">irspiocbq</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_SLI</span><span class="p">,</span>
			<span class="s">&quot;0387 NO IOCBQ data: txq_cnt=%d iocb_cnt=%d &quot;</span>
			<span class="s">&quot;fcp_txcmplq_cnt=%d, els_txcmplq_cnt=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">pring</span><span class="o">-&gt;</span><span class="n">txq_cnt</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">iocb_cnt</span><span class="p">,</span>
			<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli</span><span class="p">.</span><span class="n">ring</span><span class="p">[</span><span class="n">LPFC_FCP_RING</span><span class="p">].</span><span class="n">txcmplq_cnt</span><span class="p">,</span>
			<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli</span><span class="p">.</span><span class="n">ring</span><span class="p">[</span><span class="n">LPFC_ELS_RING</span><span class="p">].</span><span class="n">txcmplq_cnt</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Save off the slow-path queue event for work thread to process */</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">irspiocbq</span><span class="o">-&gt;</span><span class="n">cq_event</span><span class="p">.</span><span class="n">cqe</span><span class="p">.</span><span class="n">wcqe_cmpl</span><span class="p">,</span> <span class="n">wcqe</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">wcqe</span><span class="p">));</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">,</span> <span class="n">iflags</span><span class="p">);</span>
	<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">irspiocbq</span><span class="o">-&gt;</span><span class="n">cq_event</span><span class="p">.</span><span class="n">list</span><span class="p">,</span>
		      <span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">sp_queue_event</span><span class="p">);</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">hba_flag</span> <span class="o">|=</span> <span class="n">HBA_SP_QUEUE_EVT</span><span class="p">;</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">,</span> <span class="n">iflags</span><span class="p">);</span>

	<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_sli4_sp_handle_rel_wcqe - Handle slow-path WQ entry consumed event</span>
<span class="cm"> * @phba: Pointer to HBA context object.</span>
<span class="cm"> * @wcqe: Pointer to work-queue completion queue entry.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine handles slow-path WQ entry comsumed event by invoking the</span>
<span class="cm"> * proper WQ release routine to the slow-path WQ.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">lpfc_sli4_sp_handle_rel_wcqe</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">lpfc_wcqe_release</span> <span class="o">*</span><span class="n">wcqe</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* sanity check on queue memory */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">els_wq</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="cm">/* Check for the slow-path ELS work queue */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_wcqe_r_wq_id</span><span class="p">,</span> <span class="n">wcqe</span><span class="p">)</span> <span class="o">==</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">els_wq</span><span class="o">-&gt;</span><span class="n">queue_id</span><span class="p">)</span>
		<span class="n">lpfc_sli4_wq_release</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">els_wq</span><span class="p">,</span>
				     <span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_wcqe_r_wqe_index</span><span class="p">,</span> <span class="n">wcqe</span><span class="p">));</span>
	<span class="k">else</span>
		<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_WARNING</span><span class="p">,</span> <span class="n">LOG_SLI</span><span class="p">,</span>
				<span class="s">&quot;2579 Slow-path wqe consume event carries &quot;</span>
				<span class="s">&quot;miss-matched qid: wcqe-qid=x%x, sp-qid=x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_wcqe_r_wqe_index</span><span class="p">,</span> <span class="n">wcqe</span><span class="p">),</span>
				<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">els_wq</span><span class="o">-&gt;</span><span class="n">queue_id</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_sli4_sp_handle_abort_xri_wcqe - Handle a xri abort event</span>
<span class="cm"> * @phba: Pointer to HBA context object.</span>
<span class="cm"> * @cq: Pointer to a WQ completion queue.</span>
<span class="cm"> * @wcqe: Pointer to work-queue completion queue entry.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine handles an XRI abort event.</span>
<span class="cm"> *</span>
<span class="cm"> * Return: true if work posted to worker thread, otherwise false.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="n">bool</span>
<span class="nf">lpfc_sli4_sp_handle_abort_xri_wcqe</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">lpfc_queue</span> <span class="o">*</span><span class="n">cq</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">sli4_wcqe_xri_aborted</span> <span class="o">*</span><span class="n">wcqe</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">bool</span> <span class="n">workposted</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_cq_event</span> <span class="o">*</span><span class="n">cq_event</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">iflags</span><span class="p">;</span>

	<span class="cm">/* Allocate a new internal CQ_EVENT entry */</span>
	<span class="n">cq_event</span> <span class="o">=</span> <span class="n">lpfc_sli4_cq_event_alloc</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cq_event</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_SLI</span><span class="p">,</span>
				<span class="s">&quot;0602 Failed to allocate CQ_EVENT entry</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Move the CQE into the proper xri abort event list */</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cq_event</span><span class="o">-&gt;</span><span class="n">cqe</span><span class="p">,</span> <span class="n">wcqe</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sli4_wcqe_xri_aborted</span><span class="p">));</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">cq</span><span class="o">-&gt;</span><span class="n">subtype</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">LPFC_FCP</span>:
		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">,</span> <span class="n">iflags</span><span class="p">);</span>
		<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cq_event</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span>
			      <span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">sp_fcp_xri_aborted_work_queue</span><span class="p">);</span>
		<span class="cm">/* Set the fcp xri abort event flag */</span>
		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">hba_flag</span> <span class="o">|=</span> <span class="n">FCP_XRI_ABORT_EVENT</span><span class="p">;</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">,</span> <span class="n">iflags</span><span class="p">);</span>
		<span class="n">workposted</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">LPFC_ELS</span>:
		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">,</span> <span class="n">iflags</span><span class="p">);</span>
		<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cq_event</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span>
			      <span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">sp_els_xri_aborted_work_queue</span><span class="p">);</span>
		<span class="cm">/* Set the els xri abort event flag */</span>
		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">hba_flag</span> <span class="o">|=</span> <span class="n">ELS_XRI_ABORT_EVENT</span><span class="p">;</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">,</span> <span class="n">iflags</span><span class="p">);</span>
		<span class="n">workposted</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_SLI</span><span class="p">,</span>
				<span class="s">&quot;0603 Invalid work queue CQE subtype (x%x)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">cq</span><span class="o">-&gt;</span><span class="n">subtype</span><span class="p">);</span>
		<span class="n">workposted</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">workposted</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_sli4_sp_handle_rcqe - Process a receive-queue completion queue entry</span>
<span class="cm"> * @phba: Pointer to HBA context object.</span>
<span class="cm"> * @rcqe: Pointer to receive-queue completion queue entry.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine process a receive-queue completion queue entry.</span>
<span class="cm"> *</span>
<span class="cm"> * Return: true if work posted to worker thread, otherwise false.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="n">bool</span>
<span class="nf">lpfc_sli4_sp_handle_rcqe</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">,</span> <span class="k">struct</span> <span class="n">lpfc_rcqe</span> <span class="o">*</span><span class="n">rcqe</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">bool</span> <span class="n">workposted</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_queue</span> <span class="o">*</span><span class="n">hrq</span> <span class="o">=</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">hdr_rq</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_queue</span> <span class="o">*</span><span class="n">drq</span> <span class="o">=</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">dat_rq</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hbq_dmabuf</span> <span class="o">*</span><span class="n">dma_buf</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">status</span><span class="p">,</span> <span class="n">rq_id</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">iflags</span><span class="p">;</span>

	<span class="cm">/* sanity check on queue memory */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">hrq</span><span class="p">)</span> <span class="o">||</span> <span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">drq</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">workposted</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_cqe_code</span><span class="p">,</span> <span class="n">rcqe</span><span class="p">)</span> <span class="o">==</span> <span class="n">CQE_CODE_RECEIVE_V1</span><span class="p">)</span>
		<span class="n">rq_id</span> <span class="o">=</span> <span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_rcqe_rq_id_v1</span><span class="p">,</span> <span class="n">rcqe</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">rq_id</span> <span class="o">=</span> <span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_rcqe_rq_id</span><span class="p">,</span> <span class="n">rcqe</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rq_id</span> <span class="o">!=</span> <span class="n">hrq</span><span class="o">-&gt;</span><span class="n">queue_id</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">status</span> <span class="o">=</span> <span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_rcqe_status</span><span class="p">,</span> <span class="n">rcqe</span><span class="p">);</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">status</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">FC_STATUS_RQ_BUF_LEN_EXCEEDED</span>:
		<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_SLI</span><span class="p">,</span>
				<span class="s">&quot;2537 Receive Frame Truncated!!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">case</span> <span class="n">FC_STATUS_RQ_SUCCESS</span>:
		<span class="n">lpfc_sli4_rq_release</span><span class="p">(</span><span class="n">hrq</span><span class="p">,</span> <span class="n">drq</span><span class="p">);</span>
		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">,</span> <span class="n">iflags</span><span class="p">);</span>
		<span class="n">dma_buf</span> <span class="o">=</span> <span class="n">lpfc_sli_hbqbuf_get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbqs</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">hbq_buffer_list</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dma_buf</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">,</span> <span class="n">iflags</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dma_buf</span><span class="o">-&gt;</span><span class="n">cq_event</span><span class="p">.</span><span class="n">cqe</span><span class="p">.</span><span class="n">rcqe_cmpl</span><span class="p">,</span> <span class="n">rcqe</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">rcqe</span><span class="p">));</span>
		<span class="cm">/* save off the frame for the word thread to process */</span>
		<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dma_buf</span><span class="o">-&gt;</span><span class="n">cq_event</span><span class="p">.</span><span class="n">list</span><span class="p">,</span>
			      <span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">sp_queue_event</span><span class="p">);</span>
		<span class="cm">/* Frame received */</span>
		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">hba_flag</span> <span class="o">|=</span> <span class="n">HBA_SP_QUEUE_EVT</span><span class="p">;</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">,</span> <span class="n">iflags</span><span class="p">);</span>
		<span class="n">workposted</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">FC_STATUS_INSUFF_BUF_NEED_BUF</span>:
	<span class="k">case</span> <span class="n">FC_STATUS_INSUFF_BUF_FRM_DISC</span>:
		<span class="cm">/* Post more buffers if possible */</span>
		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">,</span> <span class="n">iflags</span><span class="p">);</span>
		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">hba_flag</span> <span class="o">|=</span> <span class="n">HBA_POST_RECEIVE_BUFFER</span><span class="p">;</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">,</span> <span class="n">iflags</span><span class="p">);</span>
		<span class="n">workposted</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">workposted</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_sli4_sp_handle_cqe - Process a slow path completion queue entry</span>
<span class="cm"> * @phba: Pointer to HBA context object.</span>
<span class="cm"> * @cq: Pointer to the completion queue.</span>
<span class="cm"> * @wcqe: Pointer to a completion queue entry.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine process a slow-path work-queue or receive queue completion queue</span>
<span class="cm"> * entry.</span>
<span class="cm"> *</span>
<span class="cm"> * Return: true if work posted to worker thread, otherwise false.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="n">bool</span>
<span class="nf">lpfc_sli4_sp_handle_cqe</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">,</span> <span class="k">struct</span> <span class="n">lpfc_queue</span> <span class="o">*</span><span class="n">cq</span><span class="p">,</span>
			 <span class="k">struct</span> <span class="n">lpfc_cqe</span> <span class="o">*</span><span class="n">cqe</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpfc_cqe</span> <span class="n">cqevt</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">workposted</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

	<span class="cm">/* Copy the work queue CQE and convert endian order if needed */</span>
	<span class="n">lpfc_sli_pcimem_bcopy</span><span class="p">(</span><span class="n">cqe</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cqevt</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_cqe</span><span class="p">));</span>

	<span class="cm">/* Check and process for different type of WCQE and dispatch */</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_cqe_code</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cqevt</span><span class="p">))</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">CQE_CODE_COMPL_WQE</span>:
		<span class="cm">/* Process the WQ/RQ complete event */</span>
		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">last_completion_time</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span>
		<span class="n">workposted</span> <span class="o">=</span> <span class="n">lpfc_sli4_sp_handle_els_wcqe</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span>
				<span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_wcqe_complete</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">cqevt</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">CQE_CODE_RELEASE_WQE</span>:
		<span class="cm">/* Process the WQ release event */</span>
		<span class="n">lpfc_sli4_sp_handle_rel_wcqe</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span>
				<span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_wcqe_release</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">cqevt</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">CQE_CODE_XRI_ABORTED</span>:
		<span class="cm">/* Process the WQ XRI abort event */</span>
		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">last_completion_time</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span>
		<span class="n">workposted</span> <span class="o">=</span> <span class="n">lpfc_sli4_sp_handle_abort_xri_wcqe</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">cq</span><span class="p">,</span>
				<span class="p">(</span><span class="k">struct</span> <span class="n">sli4_wcqe_xri_aborted</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">cqevt</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">CQE_CODE_RECEIVE</span>:
	<span class="k">case</span> <span class="n">CQE_CODE_RECEIVE_V1</span>:
		<span class="cm">/* Process the RQ event */</span>
		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">last_completion_time</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span>
		<span class="n">workposted</span> <span class="o">=</span> <span class="n">lpfc_sli4_sp_handle_rcqe</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span>
				<span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_rcqe</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">cqevt</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_SLI</span><span class="p">,</span>
				<span class="s">&quot;0388 Not a valid WCQE code: x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_cqe_code</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cqevt</span><span class="p">));</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">workposted</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_sli4_sp_handle_eqe - Process a slow-path event queue entry</span>
<span class="cm"> * @phba: Pointer to HBA context object.</span>
<span class="cm"> * @eqe: Pointer to fast-path event queue entry.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine process a event queue entry from the slow-path event queue.</span>
<span class="cm"> * It will check the MajorCode and MinorCode to determine this is for a</span>
<span class="cm"> * completion event on a completion queue, if not, an error shall be logged</span>
<span class="cm"> * and just return. Otherwise, it will get to the corresponding completion</span>
<span class="cm"> * queue and process all the entries on that completion queue, rearm the</span>
<span class="cm"> * completion queue, and then return.</span>
<span class="cm"> *</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">lpfc_sli4_sp_handle_eqe</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">,</span> <span class="k">struct</span> <span class="n">lpfc_eqe</span> <span class="o">*</span><span class="n">eqe</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpfc_queue</span> <span class="o">*</span><span class="n">cq</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">*</span><span class="n">childq</span><span class="p">,</span> <span class="o">*</span><span class="n">speq</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_cqe</span> <span class="o">*</span><span class="n">cqe</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">workposted</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ecount</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">uint16_t</span> <span class="n">cqid</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">bf_get_le32</span><span class="p">(</span><span class="n">lpfc_eqe_major_code</span><span class="p">,</span> <span class="n">eqe</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_SLI</span><span class="p">,</span>
				<span class="s">&quot;0359 Not a valid slow-path completion &quot;</span>
				<span class="s">&quot;event: majorcode=x%x, minorcode=x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">bf_get_le32</span><span class="p">(</span><span class="n">lpfc_eqe_major_code</span><span class="p">,</span> <span class="n">eqe</span><span class="p">),</span>
				<span class="n">bf_get_le32</span><span class="p">(</span><span class="n">lpfc_eqe_minor_code</span><span class="p">,</span> <span class="n">eqe</span><span class="p">));</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Get the reference to the corresponding CQ */</span>
	<span class="n">cqid</span> <span class="o">=</span> <span class="n">bf_get_le32</span><span class="p">(</span><span class="n">lpfc_eqe_resource_id</span><span class="p">,</span> <span class="n">eqe</span><span class="p">);</span>

	<span class="cm">/* Search for completion queue pointer matching this cqid */</span>
	<span class="n">speq</span> <span class="o">=</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">sp_eq</span><span class="p">;</span>
	<span class="cm">/* sanity check on queue memory */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">speq</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">childq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">speq</span><span class="o">-&gt;</span><span class="n">child_list</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">childq</span><span class="o">-&gt;</span><span class="n">queue_id</span> <span class="o">==</span> <span class="n">cqid</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">cq</span> <span class="o">=</span> <span class="n">childq</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">cq</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli</span><span class="p">.</span><span class="n">sli_flag</span> <span class="o">&amp;</span> <span class="n">LPFC_SLI_ACTIVE</span><span class="p">)</span>
			<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_SLI</span><span class="p">,</span>
					<span class="s">&quot;0365 Slow-path CQ identifier &quot;</span>
					<span class="s">&quot;(%d) does not exist</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">cqid</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Process all the entries to the CQ */</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">cq</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">LPFC_MCQ</span>:
		<span class="k">while</span> <span class="p">((</span><span class="n">cqe</span> <span class="o">=</span> <span class="n">lpfc_sli4_cq_get</span><span class="p">(</span><span class="n">cq</span><span class="p">)))</span> <span class="p">{</span>
			<span class="n">workposted</span> <span class="o">|=</span> <span class="n">lpfc_sli4_sp_handle_mcqe</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">cqe</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="o">++</span><span class="n">ecount</span> <span class="o">%</span> <span class="n">cq</span><span class="o">-&gt;</span><span class="n">entry_repost</span><span class="p">))</span>
				<span class="n">lpfc_sli4_cq_release</span><span class="p">(</span><span class="n">cq</span><span class="p">,</span> <span class="n">LPFC_QUEUE_NOARM</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">LPFC_WCQ</span>:
		<span class="k">while</span> <span class="p">((</span><span class="n">cqe</span> <span class="o">=</span> <span class="n">lpfc_sli4_cq_get</span><span class="p">(</span><span class="n">cq</span><span class="p">)))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">cq</span><span class="o">-&gt;</span><span class="n">subtype</span> <span class="o">==</span> <span class="n">LPFC_FCP</span><span class="p">)</span>
				<span class="n">workposted</span> <span class="o">|=</span> <span class="n">lpfc_sli4_fp_handle_wcqe</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">cq</span><span class="p">,</span>
								       <span class="n">cqe</span><span class="p">);</span>
			<span class="k">else</span>
				<span class="n">workposted</span> <span class="o">|=</span> <span class="n">lpfc_sli4_sp_handle_cqe</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">cq</span><span class="p">,</span>
								      <span class="n">cqe</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="o">++</span><span class="n">ecount</span> <span class="o">%</span> <span class="n">cq</span><span class="o">-&gt;</span><span class="n">entry_repost</span><span class="p">))</span>
				<span class="n">lpfc_sli4_cq_release</span><span class="p">(</span><span class="n">cq</span><span class="p">,</span> <span class="n">LPFC_QUEUE_NOARM</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_SLI</span><span class="p">,</span>
				<span class="s">&quot;0370 Invalid completion queue type (%d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">cq</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Catch the no cq entry condition, log an error */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">ecount</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span>
		<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_SLI</span><span class="p">,</span>
				<span class="s">&quot;0371 No entry from the CQ: identifier &quot;</span>
				<span class="s">&quot;(x%x), type (%d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">cq</span><span class="o">-&gt;</span><span class="n">queue_id</span><span class="p">,</span> <span class="n">cq</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">);</span>

	<span class="cm">/* In any case, flash and re-arm the RCQ */</span>
	<span class="n">lpfc_sli4_cq_release</span><span class="p">(</span><span class="n">cq</span><span class="p">,</span> <span class="n">LPFC_QUEUE_REARM</span><span class="p">);</span>

	<span class="cm">/* wake up worker thread if there are works to be done */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">workposted</span><span class="p">)</span>
		<span class="n">lpfc_worker_wake_up</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_sli4_fp_handle_fcp_wcqe - Process fast-path work queue completion entry</span>
<span class="cm"> * @eqe: Pointer to fast-path completion queue entry.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine process a fast-path work queue completion entry from fast-path</span>
<span class="cm"> * event queue for FCP command response completion.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">lpfc_sli4_fp_handle_fcp_wcqe</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">lpfc_wcqe_complete</span> <span class="o">*</span><span class="n">wcqe</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpfc_sli_ring</span> <span class="o">*</span><span class="n">pring</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli</span><span class="p">.</span><span class="n">ring</span><span class="p">[</span><span class="n">LPFC_FCP_RING</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">lpfc_iocbq</span> <span class="o">*</span><span class="n">cmdiocbq</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_iocbq</span> <span class="n">irspiocbq</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">iflags</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">,</span> <span class="n">iflags</span><span class="p">);</span>
	<span class="n">pring</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">iocb_event</span><span class="o">++</span><span class="p">;</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">,</span> <span class="n">iflags</span><span class="p">);</span>

	<span class="cm">/* Check for response status */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_wcqe_c_status</span><span class="p">,</span> <span class="n">wcqe</span><span class="p">)))</span> <span class="p">{</span>
		<span class="cm">/* If resource errors reported from HBA, reduce queue</span>
<span class="cm">		 * depth of the SCSI device.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_wcqe_c_status</span><span class="p">,</span> <span class="n">wcqe</span><span class="p">)</span> <span class="o">==</span>
		     <span class="n">IOSTAT_LOCAL_REJECT</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="p">(</span><span class="n">wcqe</span><span class="o">-&gt;</span><span class="n">parameter</span> <span class="o">==</span> <span class="n">IOERR_NO_RESOURCES</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">phba</span><span class="o">-&gt;</span><span class="n">lpfc_rampdown_queue_depth</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="cm">/* Log the error status */</span>
		<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_WARNING</span><span class="p">,</span> <span class="n">LOG_SLI</span><span class="p">,</span>
				<span class="s">&quot;0373 FCP complete error: status=x%x, &quot;</span>
				<span class="s">&quot;hw_status=x%x, total_data_specified=%d, &quot;</span>
				<span class="s">&quot;parameter=x%x, word3=x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_wcqe_c_status</span><span class="p">,</span> <span class="n">wcqe</span><span class="p">),</span>
				<span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_wcqe_c_hw_status</span><span class="p">,</span> <span class="n">wcqe</span><span class="p">),</span>
				<span class="n">wcqe</span><span class="o">-&gt;</span><span class="n">total_data_placed</span><span class="p">,</span> <span class="n">wcqe</span><span class="o">-&gt;</span><span class="n">parameter</span><span class="p">,</span>
				<span class="n">wcqe</span><span class="o">-&gt;</span><span class="n">word3</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Look up the FCP command IOCB and create pseudo response IOCB */</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">,</span> <span class="n">iflags</span><span class="p">);</span>
	<span class="n">cmdiocbq</span> <span class="o">=</span> <span class="n">lpfc_sli_iocbq_lookup_by_tag</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">pring</span><span class="p">,</span>
				<span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_wcqe_c_request_tag</span><span class="p">,</span> <span class="n">wcqe</span><span class="p">));</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">,</span> <span class="n">iflags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">cmdiocbq</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_WARNING</span><span class="p">,</span> <span class="n">LOG_SLI</span><span class="p">,</span>
				<span class="s">&quot;0374 FCP complete with no corresponding &quot;</span>
				<span class="s">&quot;cmdiocb: iotag (%d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_wcqe_c_request_tag</span><span class="p">,</span> <span class="n">wcqe</span><span class="p">));</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">cmdiocbq</span><span class="o">-&gt;</span><span class="n">iocb_cmpl</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_WARNING</span><span class="p">,</span> <span class="n">LOG_SLI</span><span class="p">,</span>
				<span class="s">&quot;0375 FCP cmdiocb not callback function &quot;</span>
				<span class="s">&quot;iotag: (%d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_wcqe_c_request_tag</span><span class="p">,</span> <span class="n">wcqe</span><span class="p">));</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Fake the irspiocb and copy necessary response information */</span>
	<span class="n">lpfc_sli4_iocb_param_transfer</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">irspiocbq</span><span class="p">,</span> <span class="n">cmdiocbq</span><span class="p">,</span> <span class="n">wcqe</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cmdiocbq</span><span class="o">-&gt;</span><span class="n">iocb_flag</span> <span class="o">&amp;</span> <span class="n">LPFC_DRIVER_ABORTED</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">,</span> <span class="n">iflags</span><span class="p">);</span>
		<span class="n">cmdiocbq</span><span class="o">-&gt;</span><span class="n">iocb_flag</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">LPFC_DRIVER_ABORTED</span><span class="p">;</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">,</span> <span class="n">iflags</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Pass the cmd_iocb and the rsp state to the upper layer */</span>
	<span class="p">(</span><span class="n">cmdiocbq</span><span class="o">-&gt;</span><span class="n">iocb_cmpl</span><span class="p">)(</span><span class="n">phba</span><span class="p">,</span> <span class="n">cmdiocbq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">irspiocbq</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_sli4_fp_handle_rel_wcqe - Handle fast-path WQ entry consumed event</span>
<span class="cm"> * @phba: Pointer to HBA context object.</span>
<span class="cm"> * @cq: Pointer to completion queue.</span>
<span class="cm"> * @wcqe: Pointer to work-queue completion queue entry.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine handles an fast-path WQ entry comsumed event by invoking the</span>
<span class="cm"> * proper WQ release routine to the slow-path WQ.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">lpfc_sli4_fp_handle_rel_wcqe</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">,</span> <span class="k">struct</span> <span class="n">lpfc_queue</span> <span class="o">*</span><span class="n">cq</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">lpfc_wcqe_release</span> <span class="o">*</span><span class="n">wcqe</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpfc_queue</span> <span class="o">*</span><span class="n">childwq</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">wqid_matched</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="kt">uint16_t</span> <span class="n">fcp_wqid</span><span class="p">;</span>

	<span class="cm">/* Check for fast-path FCP work queue release */</span>
	<span class="n">fcp_wqid</span> <span class="o">=</span> <span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_wcqe_r_wq_id</span><span class="p">,</span> <span class="n">wcqe</span><span class="p">);</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">childwq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cq</span><span class="o">-&gt;</span><span class="n">child_list</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">childwq</span><span class="o">-&gt;</span><span class="n">queue_id</span> <span class="o">==</span> <span class="n">fcp_wqid</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">lpfc_sli4_wq_release</span><span class="p">(</span><span class="n">childwq</span><span class="p">,</span>
					<span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_wcqe_r_wqe_index</span><span class="p">,</span> <span class="n">wcqe</span><span class="p">));</span>
			<span class="n">wqid_matched</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="cm">/* Report warning log message if no match found */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">wqid_matched</span> <span class="o">!=</span> <span class="nb">true</span><span class="p">)</span>
		<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_WARNING</span><span class="p">,</span> <span class="n">LOG_SLI</span><span class="p">,</span>
				<span class="s">&quot;2580 Fast-path wqe consume event carries &quot;</span>
				<span class="s">&quot;miss-matched qid: wcqe-qid=x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">fcp_wqid</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_sli4_fp_handle_wcqe - Process fast-path work queue completion entry</span>
<span class="cm"> * @cq: Pointer to the completion queue.</span>
<span class="cm"> * @eqe: Pointer to fast-path completion queue entry.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine process a fast-path work queue completion entry from fast-path</span>
<span class="cm"> * event queue for FCP command response completion.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">lpfc_sli4_fp_handle_wcqe</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">,</span> <span class="k">struct</span> <span class="n">lpfc_queue</span> <span class="o">*</span><span class="n">cq</span><span class="p">,</span>
			 <span class="k">struct</span> <span class="n">lpfc_cqe</span> <span class="o">*</span><span class="n">cqe</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpfc_wcqe_release</span> <span class="n">wcqe</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">workposted</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

	<span class="cm">/* Copy the work queue CQE and convert endian order if needed */</span>
	<span class="n">lpfc_sli_pcimem_bcopy</span><span class="p">(</span><span class="n">cqe</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wcqe</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_cqe</span><span class="p">));</span>

	<span class="cm">/* Check and process for different type of WCQE and dispatch */</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_wcqe_c_code</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wcqe</span><span class="p">))</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">CQE_CODE_COMPL_WQE</span>:
		<span class="cm">/* Process the WQ complete event */</span>
		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">last_completion_time</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span>
		<span class="n">lpfc_sli4_fp_handle_fcp_wcqe</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span>
				<span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_wcqe_complete</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">wcqe</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">CQE_CODE_RELEASE_WQE</span>:
		<span class="cm">/* Process the WQ release event */</span>
		<span class="n">lpfc_sli4_fp_handle_rel_wcqe</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">cq</span><span class="p">,</span>
				<span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_wcqe_release</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">wcqe</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">CQE_CODE_XRI_ABORTED</span>:
		<span class="cm">/* Process the WQ XRI abort event */</span>
		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">last_completion_time</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span>
		<span class="n">workposted</span> <span class="o">=</span> <span class="n">lpfc_sli4_sp_handle_abort_xri_wcqe</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">cq</span><span class="p">,</span>
				<span class="p">(</span><span class="k">struct</span> <span class="n">sli4_wcqe_xri_aborted</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">wcqe</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_SLI</span><span class="p">,</span>
				<span class="s">&quot;0144 Not a valid WCQE code: x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_wcqe_c_code</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wcqe</span><span class="p">));</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">workposted</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_sli4_fp_handle_eqe - Process a fast-path event queue entry</span>
<span class="cm"> * @phba: Pointer to HBA context object.</span>
<span class="cm"> * @eqe: Pointer to fast-path event queue entry.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine process a event queue entry from the fast-path event queue.</span>
<span class="cm"> * It will check the MajorCode and MinorCode to determine this is for a</span>
<span class="cm"> * completion event on a completion queue, if not, an error shall be logged</span>
<span class="cm"> * and just return. Otherwise, it will get to the corresponding completion</span>
<span class="cm"> * queue and process all the entries on the completion queue, rearm the</span>
<span class="cm"> * completion queue, and then return.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">lpfc_sli4_fp_handle_eqe</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">,</span> <span class="k">struct</span> <span class="n">lpfc_eqe</span> <span class="o">*</span><span class="n">eqe</span><span class="p">,</span>
			<span class="kt">uint32_t</span> <span class="n">fcp_cqidx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpfc_queue</span> <span class="o">*</span><span class="n">cq</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_cqe</span> <span class="o">*</span><span class="n">cqe</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">workposted</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="kt">uint16_t</span> <span class="n">cqid</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ecount</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">bf_get_le32</span><span class="p">(</span><span class="n">lpfc_eqe_major_code</span><span class="p">,</span> <span class="n">eqe</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_SLI</span><span class="p">,</span>
				<span class="s">&quot;0366 Not a valid fast-path completion &quot;</span>
				<span class="s">&quot;event: majorcode=x%x, minorcode=x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">bf_get_le32</span><span class="p">(</span><span class="n">lpfc_eqe_major_code</span><span class="p">,</span> <span class="n">eqe</span><span class="p">),</span>
				<span class="n">bf_get_le32</span><span class="p">(</span><span class="n">lpfc_eqe_minor_code</span><span class="p">,</span> <span class="n">eqe</span><span class="p">));</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">fcp_cq</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_WARNING</span><span class="p">,</span> <span class="n">LOG_SLI</span><span class="p">,</span>
				<span class="s">&quot;3146 Fast-path completion queues &quot;</span>
				<span class="s">&quot;does not exist</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">cq</span> <span class="o">=</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">fcp_cq</span><span class="p">[</span><span class="n">fcp_cqidx</span><span class="p">];</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">cq</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli</span><span class="p">.</span><span class="n">sli_flag</span> <span class="o">&amp;</span> <span class="n">LPFC_SLI_ACTIVE</span><span class="p">)</span>
			<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_SLI</span><span class="p">,</span>
					<span class="s">&quot;0367 Fast-path completion queue &quot;</span>
					<span class="s">&quot;(%d) does not exist</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">fcp_cqidx</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Get the reference to the corresponding CQ */</span>
	<span class="n">cqid</span> <span class="o">=</span> <span class="n">bf_get_le32</span><span class="p">(</span><span class="n">lpfc_eqe_resource_id</span><span class="p">,</span> <span class="n">eqe</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">cqid</span> <span class="o">!=</span> <span class="n">cq</span><span class="o">-&gt;</span><span class="n">queue_id</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_SLI</span><span class="p">,</span>
				<span class="s">&quot;0368 Miss-matched fast-path completion &quot;</span>
				<span class="s">&quot;queue identifier: eqcqid=%d, fcpcqid=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">cqid</span><span class="p">,</span> <span class="n">cq</span><span class="o">-&gt;</span><span class="n">queue_id</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Process all the entries to the CQ */</span>
	<span class="k">while</span> <span class="p">((</span><span class="n">cqe</span> <span class="o">=</span> <span class="n">lpfc_sli4_cq_get</span><span class="p">(</span><span class="n">cq</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">workposted</span> <span class="o">|=</span> <span class="n">lpfc_sli4_fp_handle_wcqe</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">cq</span><span class="p">,</span> <span class="n">cqe</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="o">++</span><span class="n">ecount</span> <span class="o">%</span> <span class="n">cq</span><span class="o">-&gt;</span><span class="n">entry_repost</span><span class="p">))</span>
			<span class="n">lpfc_sli4_cq_release</span><span class="p">(</span><span class="n">cq</span><span class="p">,</span> <span class="n">LPFC_QUEUE_NOARM</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Catch the no cq entry condition */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">ecount</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span>
		<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_SLI</span><span class="p">,</span>
				<span class="s">&quot;0369 No entry from fast-path completion &quot;</span>
				<span class="s">&quot;queue fcpcqid=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">cq</span><span class="o">-&gt;</span><span class="n">queue_id</span><span class="p">);</span>

	<span class="cm">/* In any case, flash and re-arm the CQ */</span>
	<span class="n">lpfc_sli4_cq_release</span><span class="p">(</span><span class="n">cq</span><span class="p">,</span> <span class="n">LPFC_QUEUE_REARM</span><span class="p">);</span>

	<span class="cm">/* wake up worker thread if there are works to be done */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">workposted</span><span class="p">)</span>
		<span class="n">lpfc_worker_wake_up</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">lpfc_sli4_eq_flush</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">,</span> <span class="k">struct</span> <span class="n">lpfc_queue</span> <span class="o">*</span><span class="n">eq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpfc_eqe</span> <span class="o">*</span><span class="n">eqe</span><span class="p">;</span>

	<span class="cm">/* walk all the EQ entries and drop on the floor */</span>
	<span class="k">while</span> <span class="p">((</span><span class="n">eqe</span> <span class="o">=</span> <span class="n">lpfc_sli4_eq_get</span><span class="p">(</span><span class="n">eq</span><span class="p">)))</span>
		<span class="p">;</span>

	<span class="cm">/* Clear and re-arm the EQ */</span>
	<span class="n">lpfc_sli4_eq_release</span><span class="p">(</span><span class="n">eq</span><span class="p">,</span> <span class="n">LPFC_QUEUE_REARM</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_sli4_sp_intr_handler - Slow-path interrupt handler to SLI-4 device</span>
<span class="cm"> * @irq: Interrupt number.</span>
<span class="cm"> * @dev_id: The device context pointer.</span>
<span class="cm"> *</span>
<span class="cm"> * This function is directly called from the PCI layer as an interrupt</span>
<span class="cm"> * service routine when device with SLI-4 interface spec is enabled with</span>
<span class="cm"> * MSI-X multi-message interrupt mode and there are slow-path events in</span>
<span class="cm"> * the HBA. However, when the device is enabled with either MSI or Pin-IRQ</span>
<span class="cm"> * interrupt mode, this function is called as part of the device-level</span>
<span class="cm"> * interrupt handler. When the PCI slot is in error recovery or the HBA is</span>
<span class="cm"> * undergoing initialization, the interrupt handler will not process the</span>
<span class="cm"> * interrupt. The link attention and ELS ring attention events are handled</span>
<span class="cm"> * by the worker thread. The interrupt handler signals the worker thread</span>
<span class="cm"> * and returns for these events. This function is called without any lock</span>
<span class="cm"> * held. It gets the hbalock to access and update SLI data structures.</span>
<span class="cm"> *</span>
<span class="cm"> * This function returns IRQ_HANDLED when interrupt is handled else it</span>
<span class="cm"> * returns IRQ_NONE.</span>
<span class="cm"> **/</span>
<span class="n">irqreturn_t</span>
<span class="nf">lpfc_sli4_sp_intr_handler</span><span class="p">(</span><span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">dev_id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_queue</span> <span class="o">*</span><span class="n">speq</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_eqe</span> <span class="o">*</span><span class="n">eqe</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">iflag</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ecount</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Get the driver&#39;s phba structure from the dev_id</span>
<span class="cm">	 */</span>
	<span class="n">phba</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="p">)</span><span class="n">dev_id</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">phba</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">IRQ_NONE</span><span class="p">;</span>

	<span class="cm">/* Get to the EQ struct associated with this vector */</span>
	<span class="n">speq</span> <span class="o">=</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">sp_eq</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">speq</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">IRQ_NONE</span><span class="p">;</span>

	<span class="cm">/* Check device state for handling interrupt */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">lpfc_intr_state_check</span><span class="p">(</span><span class="n">phba</span><span class="p">)))</span> <span class="p">{</span>
		<span class="cm">/* Check again for link_state with lock held */</span>
		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">,</span> <span class="n">iflag</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">link_state</span> <span class="o">&lt;</span> <span class="n">LPFC_LINK_DOWN</span><span class="p">)</span>
			<span class="cm">/* Flush, clear interrupt, and rearm the EQ */</span>
			<span class="n">lpfc_sli4_eq_flush</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">speq</span><span class="p">);</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">,</span> <span class="n">iflag</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">IRQ_NONE</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Process all the event on FCP slow-path EQ</span>
<span class="cm">	 */</span>
	<span class="k">while</span> <span class="p">((</span><span class="n">eqe</span> <span class="o">=</span> <span class="n">lpfc_sli4_eq_get</span><span class="p">(</span><span class="n">speq</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">lpfc_sli4_sp_handle_eqe</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">eqe</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="o">++</span><span class="n">ecount</span> <span class="o">%</span> <span class="n">speq</span><span class="o">-&gt;</span><span class="n">entry_repost</span><span class="p">))</span>
			<span class="n">lpfc_sli4_eq_release</span><span class="p">(</span><span class="n">speq</span><span class="p">,</span> <span class="n">LPFC_QUEUE_NOARM</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Always clear and re-arm the slow-path EQ */</span>
	<span class="n">lpfc_sli4_eq_release</span><span class="p">(</span><span class="n">speq</span><span class="p">,</span> <span class="n">LPFC_QUEUE_REARM</span><span class="p">);</span>

	<span class="cm">/* Catch the no cq entry condition */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">ecount</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">intr_type</span> <span class="o">==</span> <span class="n">MSIX</span><span class="p">)</span>
			<span class="cm">/* MSI-X treated interrupt served as no EQ share INT */</span>
			<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_WARNING</span><span class="p">,</span> <span class="n">LOG_SLI</span><span class="p">,</span>
					<span class="s">&quot;0357 MSI-X interrupt with no EQE</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="cm">/* Non MSI-X treated on interrupt as EQ share INT */</span>
			<span class="k">return</span> <span class="n">IRQ_NONE</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">IRQ_HANDLED</span><span class="p">;</span>
<span class="p">}</span> <span class="cm">/* lpfc_sli4_sp_intr_handler */</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_sli4_fp_intr_handler - Fast-path interrupt handler to SLI-4 device</span>
<span class="cm"> * @irq: Interrupt number.</span>
<span class="cm"> * @dev_id: The device context pointer.</span>
<span class="cm"> *</span>
<span class="cm"> * This function is directly called from the PCI layer as an interrupt</span>
<span class="cm"> * service routine when device with SLI-4 interface spec is enabled with</span>
<span class="cm"> * MSI-X multi-message interrupt mode and there is a fast-path FCP IOCB</span>
<span class="cm"> * ring event in the HBA. However, when the device is enabled with either</span>
<span class="cm"> * MSI or Pin-IRQ interrupt mode, this function is called as part of the</span>
<span class="cm"> * device-level interrupt handler. When the PCI slot is in error recovery</span>
<span class="cm"> * or the HBA is undergoing initialization, the interrupt handler will not</span>
<span class="cm"> * process the interrupt. The SCSI FCP fast-path ring event are handled in</span>
<span class="cm"> * the intrrupt context. This function is called without any lock held.</span>
<span class="cm"> * It gets the hbalock to access and update SLI data structures. Note that,</span>
<span class="cm"> * the FCP EQ to FCP CQ are one-to-one map such that the FCP EQ index is</span>
<span class="cm"> * equal to that of FCP CQ index.</span>
<span class="cm"> *</span>
<span class="cm"> * This function returns IRQ_HANDLED when interrupt is handled else it</span>
<span class="cm"> * returns IRQ_NONE.</span>
<span class="cm"> **/</span>
<span class="n">irqreturn_t</span>
<span class="nf">lpfc_sli4_fp_intr_handler</span><span class="p">(</span><span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">dev_id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_fcp_eq_hdl</span> <span class="o">*</span><span class="n">fcp_eq_hdl</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_queue</span> <span class="o">*</span><span class="n">fpeq</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_eqe</span> <span class="o">*</span><span class="n">eqe</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">iflag</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ecount</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">fcp_eqidx</span><span class="p">;</span>

	<span class="cm">/* Get the driver&#39;s phba structure from the dev_id */</span>
	<span class="n">fcp_eq_hdl</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_fcp_eq_hdl</span> <span class="o">*</span><span class="p">)</span><span class="n">dev_id</span><span class="p">;</span>
	<span class="n">phba</span> <span class="o">=</span> <span class="n">fcp_eq_hdl</span><span class="o">-&gt;</span><span class="n">phba</span><span class="p">;</span>
	<span class="n">fcp_eqidx</span> <span class="o">=</span> <span class="n">fcp_eq_hdl</span><span class="o">-&gt;</span><span class="n">idx</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">phba</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">IRQ_NONE</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">fp_eq</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">IRQ_NONE</span><span class="p">;</span>

	<span class="cm">/* Get to the EQ struct associated with this vector */</span>
	<span class="n">fpeq</span> <span class="o">=</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">fp_eq</span><span class="p">[</span><span class="n">fcp_eqidx</span><span class="p">];</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">fpeq</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">IRQ_NONE</span><span class="p">;</span>

	<span class="cm">/* Check device state for handling interrupt */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">lpfc_intr_state_check</span><span class="p">(</span><span class="n">phba</span><span class="p">)))</span> <span class="p">{</span>
		<span class="cm">/* Check again for link_state with lock held */</span>
		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">,</span> <span class="n">iflag</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">link_state</span> <span class="o">&lt;</span> <span class="n">LPFC_LINK_DOWN</span><span class="p">)</span>
			<span class="cm">/* Flush, clear interrupt, and rearm the EQ */</span>
			<span class="n">lpfc_sli4_eq_flush</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">fpeq</span><span class="p">);</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">,</span> <span class="n">iflag</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">IRQ_NONE</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Process all the event on FCP fast-path EQ</span>
<span class="cm">	 */</span>
	<span class="k">while</span> <span class="p">((</span><span class="n">eqe</span> <span class="o">=</span> <span class="n">lpfc_sli4_eq_get</span><span class="p">(</span><span class="n">fpeq</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">lpfc_sli4_fp_handle_eqe</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">eqe</span><span class="p">,</span> <span class="n">fcp_eqidx</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="o">++</span><span class="n">ecount</span> <span class="o">%</span> <span class="n">fpeq</span><span class="o">-&gt;</span><span class="n">entry_repost</span><span class="p">))</span>
			<span class="n">lpfc_sli4_eq_release</span><span class="p">(</span><span class="n">fpeq</span><span class="p">,</span> <span class="n">LPFC_QUEUE_NOARM</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Always clear and re-arm the fast-path EQ */</span>
	<span class="n">lpfc_sli4_eq_release</span><span class="p">(</span><span class="n">fpeq</span><span class="p">,</span> <span class="n">LPFC_QUEUE_REARM</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">ecount</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">intr_type</span> <span class="o">==</span> <span class="n">MSIX</span><span class="p">)</span>
			<span class="cm">/* MSI-X treated interrupt served as no EQ share INT */</span>
			<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_WARNING</span><span class="p">,</span> <span class="n">LOG_SLI</span><span class="p">,</span>
					<span class="s">&quot;0358 MSI-X interrupt with no EQE</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="cm">/* Non MSI-X treated on interrupt as EQ share INT */</span>
			<span class="k">return</span> <span class="n">IRQ_NONE</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">IRQ_HANDLED</span><span class="p">;</span>
<span class="p">}</span> <span class="cm">/* lpfc_sli4_fp_intr_handler */</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_sli4_intr_handler - Device-level interrupt handler for SLI-4 device</span>
<span class="cm"> * @irq: Interrupt number.</span>
<span class="cm"> * @dev_id: The device context pointer.</span>
<span class="cm"> *</span>
<span class="cm"> * This function is the device-level interrupt handler to device with SLI-4</span>
<span class="cm"> * interface spec, called from the PCI layer when either MSI or Pin-IRQ</span>
<span class="cm"> * interrupt mode is enabled and there is an event in the HBA which requires</span>
<span class="cm"> * driver attention. This function invokes the slow-path interrupt attention</span>
<span class="cm"> * handling function and fast-path interrupt attention handling function in</span>
<span class="cm"> * turn to process the relevant HBA attention events. This function is called</span>
<span class="cm"> * without any lock held. It gets the hbalock to access and update SLI data</span>
<span class="cm"> * structures.</span>
<span class="cm"> *</span>
<span class="cm"> * This function returns IRQ_HANDLED when interrupt is handled, else it</span>
<span class="cm"> * returns IRQ_NONE.</span>
<span class="cm"> **/</span>
<span class="n">irqreturn_t</span>
<span class="nf">lpfc_sli4_intr_handler</span><span class="p">(</span><span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">dev_id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpfc_hba</span>  <span class="o">*</span><span class="n">phba</span><span class="p">;</span>
	<span class="n">irqreturn_t</span> <span class="n">sp_irq_rc</span><span class="p">,</span> <span class="n">fp_irq_rc</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">fp_handled</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">fcp_eqidx</span><span class="p">;</span>

	<span class="cm">/* Get the driver&#39;s phba structure from the dev_id */</span>
	<span class="n">phba</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="p">)</span><span class="n">dev_id</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">phba</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">IRQ_NONE</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Invokes slow-path host attention interrupt handling as appropriate.</span>
<span class="cm">	 */</span>
	<span class="n">sp_irq_rc</span> <span class="o">=</span> <span class="n">lpfc_sli4_sp_intr_handler</span><span class="p">(</span><span class="n">irq</span><span class="p">,</span> <span class="n">dev_id</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Invoke fast-path host attention interrupt handling as appropriate.</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">fcp_eqidx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">fcp_eqidx</span> <span class="o">&lt;</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">cfg_fcp_eq_count</span><span class="p">;</span> <span class="n">fcp_eqidx</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">fp_irq_rc</span> <span class="o">=</span> <span class="n">lpfc_sli4_fp_intr_handler</span><span class="p">(</span><span class="n">irq</span><span class="p">,</span>
					<span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">fcp_eq_hdl</span><span class="p">[</span><span class="n">fcp_eqidx</span><span class="p">]);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">fp_irq_rc</span> <span class="o">==</span> <span class="n">IRQ_HANDLED</span><span class="p">)</span>
			<span class="n">fp_handled</span> <span class="o">|=</span> <span class="nb">true</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="p">(</span><span class="n">fp_handled</span> <span class="o">==</span> <span class="nb">true</span><span class="p">)</span> <span class="o">?</span> <span class="n">IRQ_HANDLED</span> <span class="o">:</span> <span class="n">sp_irq_rc</span><span class="p">;</span>
<span class="p">}</span> <span class="cm">/* lpfc_sli4_intr_handler */</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_sli4_queue_free - free a queue structure and associated memory</span>
<span class="cm"> * @queue: The queue structure to free.</span>
<span class="cm"> *</span>
<span class="cm"> * This function frees a queue structure and the DMAable memory used for</span>
<span class="cm"> * the host resident queue. This function must be called after destroying the</span>
<span class="cm"> * queue on the HBA.</span>
<span class="cm"> **/</span>
<span class="kt">void</span>
<span class="nf">lpfc_sli4_queue_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_queue</span> <span class="o">*</span><span class="n">queue</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpfc_dmabuf</span> <span class="o">*</span><span class="n">dmabuf</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">queue</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">queue</span><span class="o">-&gt;</span><span class="n">page_list</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">list_remove_head</span><span class="p">(</span><span class="o">&amp;</span><span class="n">queue</span><span class="o">-&gt;</span><span class="n">page_list</span><span class="p">,</span> <span class="n">dmabuf</span><span class="p">,</span> <span class="k">struct</span> <span class="n">lpfc_dmabuf</span><span class="p">,</span>
				 <span class="n">list</span><span class="p">);</span>
		<span class="n">dma_free_coherent</span><span class="p">(</span><span class="o">&amp;</span><span class="n">queue</span><span class="o">-&gt;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">pcidev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">SLI4_PAGE_SIZE</span><span class="p">,</span>
				  <span class="n">dmabuf</span><span class="o">-&gt;</span><span class="n">virt</span><span class="p">,</span> <span class="n">dmabuf</span><span class="o">-&gt;</span><span class="n">phys</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">dmabuf</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">queue</span><span class="p">);</span>
	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_sli4_queue_alloc - Allocate and initialize a queue structure</span>
<span class="cm"> * @phba: The HBA that this queue is being created on.</span>
<span class="cm"> * @entry_size: The size of each queue entry for this queue.</span>
<span class="cm"> * @entry count: The number of entries that this queue will handle.</span>
<span class="cm"> *</span>
<span class="cm"> * This function allocates a queue structure and the DMAable memory used for</span>
<span class="cm"> * the host resident queue. This function must be called before creating the</span>
<span class="cm"> * queue on the HBA.</span>
<span class="cm"> **/</span>
<span class="k">struct</span> <span class="n">lpfc_queue</span> <span class="o">*</span>
<span class="nf">lpfc_sli4_queue_alloc</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">entry_size</span><span class="p">,</span>
		      <span class="kt">uint32_t</span> <span class="n">entry_count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpfc_queue</span> <span class="o">*</span><span class="n">queue</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_dmabuf</span> <span class="o">*</span><span class="n">dmabuf</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="n">total_qe_count</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">dma_pointer</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">hw_page_size</span> <span class="o">=</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">pc_sli4_params</span><span class="p">.</span><span class="n">if_page_sz</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">pc_sli4_params</span><span class="p">.</span><span class="n">supported</span><span class="p">)</span>
		<span class="n">hw_page_size</span> <span class="o">=</span> <span class="n">SLI4_PAGE_SIZE</span><span class="p">;</span>

	<span class="n">queue</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_queue</span><span class="p">)</span> <span class="o">+</span>
			<span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">union</span> <span class="n">sli4_qe</span><span class="p">)</span> <span class="o">*</span> <span class="n">entry_count</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">queue</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">queue</span><span class="o">-&gt;</span><span class="n">page_count</span> <span class="o">=</span> <span class="p">(</span><span class="n">ALIGN</span><span class="p">(</span><span class="n">entry_size</span> <span class="o">*</span> <span class="n">entry_count</span><span class="p">,</span>
			<span class="n">hw_page_size</span><span class="p">))</span><span class="o">/</span><span class="n">hw_page_size</span><span class="p">;</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">queue</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">queue</span><span class="o">-&gt;</span><span class="n">page_list</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">queue</span><span class="o">-&gt;</span><span class="n">child_list</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">total_qe_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="n">queue</span><span class="o">-&gt;</span><span class="n">page_count</span><span class="p">;</span> <span class="n">x</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dmabuf</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_dmabuf</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dmabuf</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out_fail</span><span class="p">;</span>
		<span class="n">dmabuf</span><span class="o">-&gt;</span><span class="n">virt</span> <span class="o">=</span> <span class="n">dma_alloc_coherent</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">pcidev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
						  <span class="n">hw_page_size</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dmabuf</span><span class="o">-&gt;</span><span class="n">phys</span><span class="p">,</span>
						  <span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dmabuf</span><span class="o">-&gt;</span><span class="n">virt</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">kfree</span><span class="p">(</span><span class="n">dmabuf</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">out_fail</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">memset</span><span class="p">(</span><span class="n">dmabuf</span><span class="o">-&gt;</span><span class="n">virt</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">hw_page_size</span><span class="p">);</span>
		<span class="n">dmabuf</span><span class="o">-&gt;</span><span class="n">buffer_tag</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>
		<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dmabuf</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">queue</span><span class="o">-&gt;</span><span class="n">page_list</span><span class="p">);</span>
		<span class="cm">/* initialize queue&#39;s entry array */</span>
		<span class="n">dma_pointer</span> <span class="o">=</span> <span class="n">dmabuf</span><span class="o">-&gt;</span><span class="n">virt</span><span class="p">;</span>
		<span class="k">for</span> <span class="p">(;</span> <span class="n">total_qe_count</span> <span class="o">&lt;</span> <span class="n">entry_count</span> <span class="o">&amp;&amp;</span>
		     <span class="n">dma_pointer</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">hw_page_size</span> <span class="o">+</span> <span class="n">dmabuf</span><span class="o">-&gt;</span><span class="n">virt</span><span class="p">);</span>
		     <span class="n">total_qe_count</span><span class="o">++</span><span class="p">,</span> <span class="n">dma_pointer</span> <span class="o">+=</span> <span class="n">entry_size</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">queue</span><span class="o">-&gt;</span><span class="n">qe</span><span class="p">[</span><span class="n">total_qe_count</span><span class="p">].</span><span class="n">address</span> <span class="o">=</span> <span class="n">dma_pointer</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">queue</span><span class="o">-&gt;</span><span class="n">entry_size</span> <span class="o">=</span> <span class="n">entry_size</span><span class="p">;</span>
	<span class="n">queue</span><span class="o">-&gt;</span><span class="n">entry_count</span> <span class="o">=</span> <span class="n">entry_count</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * entry_repost is calculated based on the number of entries in the</span>
<span class="cm">	 * queue. This works out except for RQs. If buffers are NOT initially</span>
<span class="cm">	 * posted for every RQE, entry_repost should be adjusted accordingly.</span>
<span class="cm">	 */</span>
	<span class="n">queue</span><span class="o">-&gt;</span><span class="n">entry_repost</span> <span class="o">=</span> <span class="p">(</span><span class="n">entry_count</span> <span class="o">&gt;&gt;</span> <span class="mi">3</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">queue</span><span class="o">-&gt;</span><span class="n">entry_repost</span> <span class="o">&lt;</span> <span class="n">LPFC_QUEUE_MIN_REPOST</span><span class="p">)</span>
		<span class="n">queue</span><span class="o">-&gt;</span><span class="n">entry_repost</span> <span class="o">=</span> <span class="n">LPFC_QUEUE_MIN_REPOST</span><span class="p">;</span>
	<span class="n">queue</span><span class="o">-&gt;</span><span class="n">phba</span> <span class="o">=</span> <span class="n">phba</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">queue</span><span class="p">;</span>
<span class="nl">out_fail:</span>
	<span class="n">lpfc_sli4_queue_free</span><span class="p">(</span><span class="n">queue</span><span class="p">);</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_eq_create - Create an Event Queue on the HBA</span>
<span class="cm"> * @phba: HBA structure that indicates port to create a queue on.</span>
<span class="cm"> * @eq: The queue structure to use to create the event queue.</span>
<span class="cm"> * @imax: The maximum interrupt per second limit.</span>
<span class="cm"> *</span>
<span class="cm"> * This function creates an event queue, as detailed in @eq, on a port,</span>
<span class="cm"> * described by @phba by sending an EQ_CREATE mailbox command to the HBA.</span>
<span class="cm"> *</span>
<span class="cm"> * The @phba struct is used to send mailbox command to HBA. The @eq struct</span>
<span class="cm"> * is used to get the entry count and entry size that are necessary to</span>
<span class="cm"> * determine the number of pages to allocate and use for this queue. This</span>
<span class="cm"> * function will send the EQ_CREATE mailbox command to the HBA to setup the</span>
<span class="cm"> * event queue. This function is asynchronous and will wait for the mailbox</span>
<span class="cm"> * command to finish before continuing.</span>
<span class="cm"> *</span>
<span class="cm"> * On success this function will return a zero. If unable to allocate enough</span>
<span class="cm"> * memory this function will return -ENOMEM. If the queue create mailbox command</span>
<span class="cm"> * fails this function will return -ENXIO.</span>
<span class="cm"> **/</span>
<span class="kt">uint32_t</span>
<span class="nf">lpfc_eq_create</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">,</span> <span class="k">struct</span> <span class="n">lpfc_queue</span> <span class="o">*</span><span class="n">eq</span><span class="p">,</span> <span class="kt">uint16_t</span> <span class="n">imax</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpfc_mbx_eq_create</span> <span class="o">*</span><span class="n">eq_create</span><span class="p">;</span>
	<span class="n">LPFC_MBOXQ_t</span> <span class="o">*</span><span class="n">mbox</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">,</span> <span class="n">length</span><span class="p">,</span> <span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_dmabuf</span> <span class="o">*</span><span class="n">dmabuf</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">shdr_status</span><span class="p">,</span> <span class="n">shdr_add_status</span><span class="p">;</span>
	<span class="k">union</span> <span class="n">lpfc_sli4_cfg_shdr</span> <span class="o">*</span><span class="n">shdr</span><span class="p">;</span>
	<span class="kt">uint16_t</span> <span class="n">dmult</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">hw_page_size</span> <span class="o">=</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">pc_sli4_params</span><span class="p">.</span><span class="n">if_page_sz</span><span class="p">;</span>

	<span class="cm">/* sanity check on queue memory */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">eq</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">pc_sli4_params</span><span class="p">.</span><span class="n">supported</span><span class="p">)</span>
		<span class="n">hw_page_size</span> <span class="o">=</span> <span class="n">SLI4_PAGE_SIZE</span><span class="p">;</span>

	<span class="n">mbox</span> <span class="o">=</span> <span class="n">mempool_alloc</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">mbox_mem_pool</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mbox</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="n">length</span> <span class="o">=</span> <span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_mbx_eq_create</span><span class="p">)</span> <span class="o">-</span>
		  <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_sli4_cfg_mhdr</span><span class="p">));</span>
	<span class="n">lpfc_sli4_config</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">mbox</span><span class="p">,</span> <span class="n">LPFC_MBOX_SUBSYSTEM_COMMON</span><span class="p">,</span>
			 <span class="n">LPFC_MBOX_OPCODE_EQ_CREATE</span><span class="p">,</span>
			 <span class="n">length</span><span class="p">,</span> <span class="n">LPFC_SLI4_MBX_EMBED</span><span class="p">);</span>
	<span class="n">eq_create</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">mbox</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">mqe</span><span class="p">.</span><span class="n">un</span><span class="p">.</span><span class="n">eq_create</span><span class="p">;</span>
	<span class="n">bf_set</span><span class="p">(</span><span class="n">lpfc_mbx_eq_create_num_pages</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">eq_create</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">request</span><span class="p">,</span>
	       <span class="n">eq</span><span class="o">-&gt;</span><span class="n">page_count</span><span class="p">);</span>
	<span class="n">bf_set</span><span class="p">(</span><span class="n">lpfc_eq_context_size</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">eq_create</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">request</span><span class="p">.</span><span class="n">context</span><span class="p">,</span>
	       <span class="n">LPFC_EQE_SIZE</span><span class="p">);</span>
	<span class="n">bf_set</span><span class="p">(</span><span class="n">lpfc_eq_context_valid</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">eq_create</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">request</span><span class="p">.</span><span class="n">context</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="cm">/* Calculate delay multiper from maximum interrupt per second */</span>
	<span class="n">dmult</span> <span class="o">=</span> <span class="n">LPFC_DMULT_CONST</span><span class="o">/</span><span class="n">imax</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">bf_set</span><span class="p">(</span><span class="n">lpfc_eq_context_delay_multi</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">eq_create</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">request</span><span class="p">.</span><span class="n">context</span><span class="p">,</span>
	       <span class="n">dmult</span><span class="p">);</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">eq</span><span class="o">-&gt;</span><span class="n">entry_count</span><span class="p">)</span> <span class="p">{</span>
	<span class="nl">default:</span>
		<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_SLI</span><span class="p">,</span>
				<span class="s">&quot;0360 Unsupported EQ count. (%d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">eq</span><span class="o">-&gt;</span><span class="n">entry_count</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">eq</span><span class="o">-&gt;</span><span class="n">entry_count</span> <span class="o">&lt;</span> <span class="mi">256</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="cm">/* otherwise default to smallest count (drop through) */</span>
	<span class="k">case</span> <span class="mi">256</span>:
		<span class="n">bf_set</span><span class="p">(</span><span class="n">lpfc_eq_context_count</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">eq_create</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">request</span><span class="p">.</span><span class="n">context</span><span class="p">,</span>
		       <span class="n">LPFC_EQ_CNT_256</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">512</span>:
		<span class="n">bf_set</span><span class="p">(</span><span class="n">lpfc_eq_context_count</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">eq_create</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">request</span><span class="p">.</span><span class="n">context</span><span class="p">,</span>
		       <span class="n">LPFC_EQ_CNT_512</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">1024</span>:
		<span class="n">bf_set</span><span class="p">(</span><span class="n">lpfc_eq_context_count</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">eq_create</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">request</span><span class="p">.</span><span class="n">context</span><span class="p">,</span>
		       <span class="n">LPFC_EQ_CNT_1024</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">2048</span>:
		<span class="n">bf_set</span><span class="p">(</span><span class="n">lpfc_eq_context_count</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">eq_create</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">request</span><span class="p">.</span><span class="n">context</span><span class="p">,</span>
		       <span class="n">LPFC_EQ_CNT_2048</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">4096</span>:
		<span class="n">bf_set</span><span class="p">(</span><span class="n">lpfc_eq_context_count</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">eq_create</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">request</span><span class="p">.</span><span class="n">context</span><span class="p">,</span>
		       <span class="n">LPFC_EQ_CNT_4096</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">dmabuf</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">eq</span><span class="o">-&gt;</span><span class="n">page_list</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">memset</span><span class="p">(</span><span class="n">dmabuf</span><span class="o">-&gt;</span><span class="n">virt</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">hw_page_size</span><span class="p">);</span>
		<span class="n">eq_create</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">request</span><span class="p">.</span><span class="n">page</span><span class="p">[</span><span class="n">dmabuf</span><span class="o">-&gt;</span><span class="n">buffer_tag</span><span class="p">].</span><span class="n">addr_lo</span> <span class="o">=</span>
					<span class="n">putPaddrLow</span><span class="p">(</span><span class="n">dmabuf</span><span class="o">-&gt;</span><span class="n">phys</span><span class="p">);</span>
		<span class="n">eq_create</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">request</span><span class="p">.</span><span class="n">page</span><span class="p">[</span><span class="n">dmabuf</span><span class="o">-&gt;</span><span class="n">buffer_tag</span><span class="p">].</span><span class="n">addr_hi</span> <span class="o">=</span>
					<span class="n">putPaddrHigh</span><span class="p">(</span><span class="n">dmabuf</span><span class="o">-&gt;</span><span class="n">phys</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">mbox</span><span class="o">-&gt;</span><span class="n">vport</span> <span class="o">=</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">pport</span><span class="p">;</span>
	<span class="n">mbox</span><span class="o">-&gt;</span><span class="n">mbox_cmpl</span> <span class="o">=</span> <span class="n">lpfc_sli_def_mbox_cmpl</span><span class="p">;</span>
	<span class="n">mbox</span><span class="o">-&gt;</span><span class="n">context1</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">lpfc_sli_issue_mbox</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">mbox</span><span class="p">,</span> <span class="n">MBX_POLL</span><span class="p">);</span>
	<span class="n">shdr</span> <span class="o">=</span> <span class="p">(</span><span class="k">union</span> <span class="n">lpfc_sli4_cfg_shdr</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">eq_create</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">cfg_shdr</span><span class="p">;</span>
	<span class="n">shdr_status</span> <span class="o">=</span> <span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_mbox_hdr_status</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">shdr</span><span class="o">-&gt;</span><span class="n">response</span><span class="p">);</span>
	<span class="n">shdr_add_status</span> <span class="o">=</span> <span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_mbox_hdr_add_status</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">shdr</span><span class="o">-&gt;</span><span class="n">response</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">shdr_status</span> <span class="o">||</span> <span class="n">shdr_add_status</span> <span class="o">||</span> <span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_INIT</span><span class="p">,</span>
				<span class="s">&quot;2500 EQ_CREATE mailbox failed with &quot;</span>
				<span class="s">&quot;status x%x add_status x%x, mbx status x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">shdr_status</span><span class="p">,</span> <span class="n">shdr_add_status</span><span class="p">,</span> <span class="n">rc</span><span class="p">);</span>
		<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENXIO</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">eq</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">=</span> <span class="n">LPFC_EQ</span><span class="p">;</span>
	<span class="n">eq</span><span class="o">-&gt;</span><span class="n">subtype</span> <span class="o">=</span> <span class="n">LPFC_NONE</span><span class="p">;</span>
	<span class="n">eq</span><span class="o">-&gt;</span><span class="n">queue_id</span> <span class="o">=</span> <span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_mbx_eq_create_q_id</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">eq_create</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">response</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">eq</span><span class="o">-&gt;</span><span class="n">queue_id</span> <span class="o">==</span> <span class="mh">0xFFFF</span><span class="p">)</span>
		<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENXIO</span><span class="p">;</span>
	<span class="n">eq</span><span class="o">-&gt;</span><span class="n">host_index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">eq</span><span class="o">-&gt;</span><span class="n">hba_index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">mempool_free</span><span class="p">(</span><span class="n">mbox</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">mbox_mem_pool</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_cq_create - Create a Completion Queue on the HBA</span>
<span class="cm"> * @phba: HBA structure that indicates port to create a queue on.</span>
<span class="cm"> * @cq: The queue structure to use to create the completion queue.</span>
<span class="cm"> * @eq: The event queue to bind this completion queue to.</span>
<span class="cm"> *</span>
<span class="cm"> * This function creates a completion queue, as detailed in @wq, on a port,</span>
<span class="cm"> * described by @phba by sending a CQ_CREATE mailbox command to the HBA.</span>
<span class="cm"> *</span>
<span class="cm"> * The @phba struct is used to send mailbox command to HBA. The @cq struct</span>
<span class="cm"> * is used to get the entry count and entry size that are necessary to</span>
<span class="cm"> * determine the number of pages to allocate and use for this queue. The @eq</span>
<span class="cm"> * is used to indicate which event queue to bind this completion queue to. This</span>
<span class="cm"> * function will send the CQ_CREATE mailbox command to the HBA to setup the</span>
<span class="cm"> * completion queue. This function is asynchronous and will wait for the mailbox</span>
<span class="cm"> * command to finish before continuing.</span>
<span class="cm"> *</span>
<span class="cm"> * On success this function will return a zero. If unable to allocate enough</span>
<span class="cm"> * memory this function will return -ENOMEM. If the queue create mailbox command</span>
<span class="cm"> * fails this function will return -ENXIO.</span>
<span class="cm"> **/</span>
<span class="kt">uint32_t</span>
<span class="nf">lpfc_cq_create</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">,</span> <span class="k">struct</span> <span class="n">lpfc_queue</span> <span class="o">*</span><span class="n">cq</span><span class="p">,</span>
	       <span class="k">struct</span> <span class="n">lpfc_queue</span> <span class="o">*</span><span class="n">eq</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">type</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">subtype</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpfc_mbx_cq_create</span> <span class="o">*</span><span class="n">cq_create</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_dmabuf</span> <span class="o">*</span><span class="n">dmabuf</span><span class="p">;</span>
	<span class="n">LPFC_MBOXQ_t</span> <span class="o">*</span><span class="n">mbox</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">,</span> <span class="n">length</span><span class="p">,</span> <span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">shdr_status</span><span class="p">,</span> <span class="n">shdr_add_status</span><span class="p">;</span>
	<span class="k">union</span> <span class="n">lpfc_sli4_cfg_shdr</span> <span class="o">*</span><span class="n">shdr</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">hw_page_size</span> <span class="o">=</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">pc_sli4_params</span><span class="p">.</span><span class="n">if_page_sz</span><span class="p">;</span>

	<span class="cm">/* sanity check on queue memory */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cq</span> <span class="o">||</span> <span class="o">!</span><span class="n">eq</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">pc_sli4_params</span><span class="p">.</span><span class="n">supported</span><span class="p">)</span>
		<span class="n">hw_page_size</span> <span class="o">=</span> <span class="n">SLI4_PAGE_SIZE</span><span class="p">;</span>

	<span class="n">mbox</span> <span class="o">=</span> <span class="n">mempool_alloc</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">mbox_mem_pool</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mbox</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="n">length</span> <span class="o">=</span> <span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_mbx_cq_create</span><span class="p">)</span> <span class="o">-</span>
		  <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_sli4_cfg_mhdr</span><span class="p">));</span>
	<span class="n">lpfc_sli4_config</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">mbox</span><span class="p">,</span> <span class="n">LPFC_MBOX_SUBSYSTEM_COMMON</span><span class="p">,</span>
			 <span class="n">LPFC_MBOX_OPCODE_CQ_CREATE</span><span class="p">,</span>
			 <span class="n">length</span><span class="p">,</span> <span class="n">LPFC_SLI4_MBX_EMBED</span><span class="p">);</span>
	<span class="n">cq_create</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">mbox</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">mqe</span><span class="p">.</span><span class="n">un</span><span class="p">.</span><span class="n">cq_create</span><span class="p">;</span>
	<span class="n">shdr</span> <span class="o">=</span> <span class="p">(</span><span class="k">union</span> <span class="n">lpfc_sli4_cfg_shdr</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">cq_create</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">cfg_shdr</span><span class="p">;</span>
	<span class="n">bf_set</span><span class="p">(</span><span class="n">lpfc_mbx_cq_create_num_pages</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cq_create</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">request</span><span class="p">,</span>
		    <span class="n">cq</span><span class="o">-&gt;</span><span class="n">page_count</span><span class="p">);</span>
	<span class="n">bf_set</span><span class="p">(</span><span class="n">lpfc_cq_context_event</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cq_create</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">request</span><span class="p">.</span><span class="n">context</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">bf_set</span><span class="p">(</span><span class="n">lpfc_cq_context_valid</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cq_create</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">request</span><span class="p">.</span><span class="n">context</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">bf_set</span><span class="p">(</span><span class="n">lpfc_mbox_hdr_version</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">shdr</span><span class="o">-&gt;</span><span class="n">request</span><span class="p">,</span>
	       <span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">pc_sli4_params</span><span class="p">.</span><span class="n">cqv</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">pc_sli4_params</span><span class="p">.</span><span class="n">cqv</span> <span class="o">==</span> <span class="n">LPFC_Q_CREATE_VERSION_2</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* FW only supports 1. Should be PAGE_SIZE/SLI4_PAGE_SIZE */</span>
		<span class="n">bf_set</span><span class="p">(</span><span class="n">lpfc_mbx_cq_create_page_size</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cq_create</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">request</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">bf_set</span><span class="p">(</span><span class="n">lpfc_cq_eq_id_2</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cq_create</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">request</span><span class="p">.</span><span class="n">context</span><span class="p">,</span>
		       <span class="n">eq</span><span class="o">-&gt;</span><span class="n">queue_id</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">bf_set</span><span class="p">(</span><span class="n">lpfc_cq_eq_id</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cq_create</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">request</span><span class="p">.</span><span class="n">context</span><span class="p">,</span>
		       <span class="n">eq</span><span class="o">-&gt;</span><span class="n">queue_id</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">cq</span><span class="o">-&gt;</span><span class="n">entry_count</span><span class="p">)</span> <span class="p">{</span>
	<span class="nl">default:</span>
		<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_SLI</span><span class="p">,</span>
				<span class="s">&quot;0361 Unsupported CQ count. (%d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">cq</span><span class="o">-&gt;</span><span class="n">entry_count</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cq</span><span class="o">-&gt;</span><span class="n">entry_count</span> <span class="o">&lt;</span> <span class="mi">256</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="cm">/* otherwise default to smallest count (drop through) */</span>
	<span class="k">case</span> <span class="mi">256</span>:
		<span class="n">bf_set</span><span class="p">(</span><span class="n">lpfc_cq_context_count</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cq_create</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">request</span><span class="p">.</span><span class="n">context</span><span class="p">,</span>
		       <span class="n">LPFC_CQ_CNT_256</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">512</span>:
		<span class="n">bf_set</span><span class="p">(</span><span class="n">lpfc_cq_context_count</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cq_create</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">request</span><span class="p">.</span><span class="n">context</span><span class="p">,</span>
		       <span class="n">LPFC_CQ_CNT_512</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">1024</span>:
		<span class="n">bf_set</span><span class="p">(</span><span class="n">lpfc_cq_context_count</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cq_create</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">request</span><span class="p">.</span><span class="n">context</span><span class="p">,</span>
		       <span class="n">LPFC_CQ_CNT_1024</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">dmabuf</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cq</span><span class="o">-&gt;</span><span class="n">page_list</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">memset</span><span class="p">(</span><span class="n">dmabuf</span><span class="o">-&gt;</span><span class="n">virt</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">hw_page_size</span><span class="p">);</span>
		<span class="n">cq_create</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">request</span><span class="p">.</span><span class="n">page</span><span class="p">[</span><span class="n">dmabuf</span><span class="o">-&gt;</span><span class="n">buffer_tag</span><span class="p">].</span><span class="n">addr_lo</span> <span class="o">=</span>
					<span class="n">putPaddrLow</span><span class="p">(</span><span class="n">dmabuf</span><span class="o">-&gt;</span><span class="n">phys</span><span class="p">);</span>
		<span class="n">cq_create</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">request</span><span class="p">.</span><span class="n">page</span><span class="p">[</span><span class="n">dmabuf</span><span class="o">-&gt;</span><span class="n">buffer_tag</span><span class="p">].</span><span class="n">addr_hi</span> <span class="o">=</span>
					<span class="n">putPaddrHigh</span><span class="p">(</span><span class="n">dmabuf</span><span class="o">-&gt;</span><span class="n">phys</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">lpfc_sli_issue_mbox</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">mbox</span><span class="p">,</span> <span class="n">MBX_POLL</span><span class="p">);</span>

	<span class="cm">/* The IOCTL status is embedded in the mailbox subheader. */</span>
	<span class="n">shdr_status</span> <span class="o">=</span> <span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_mbox_hdr_status</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">shdr</span><span class="o">-&gt;</span><span class="n">response</span><span class="p">);</span>
	<span class="n">shdr_add_status</span> <span class="o">=</span> <span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_mbox_hdr_add_status</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">shdr</span><span class="o">-&gt;</span><span class="n">response</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">shdr_status</span> <span class="o">||</span> <span class="n">shdr_add_status</span> <span class="o">||</span> <span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_INIT</span><span class="p">,</span>
				<span class="s">&quot;2501 CQ_CREATE mailbox failed with &quot;</span>
				<span class="s">&quot;status x%x add_status x%x, mbx status x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">shdr_status</span><span class="p">,</span> <span class="n">shdr_add_status</span><span class="p">,</span> <span class="n">rc</span><span class="p">);</span>
		<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENXIO</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">cq</span><span class="o">-&gt;</span><span class="n">queue_id</span> <span class="o">=</span> <span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_mbx_cq_create_q_id</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cq_create</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">response</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cq</span><span class="o">-&gt;</span><span class="n">queue_id</span> <span class="o">==</span> <span class="mh">0xFFFF</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENXIO</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* link the cq onto the parent eq child list */</span>
	<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cq</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">eq</span><span class="o">-&gt;</span><span class="n">child_list</span><span class="p">);</span>
	<span class="cm">/* Set up completion queue&#39;s type and subtype */</span>
	<span class="n">cq</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">=</span> <span class="n">type</span><span class="p">;</span>
	<span class="n">cq</span><span class="o">-&gt;</span><span class="n">subtype</span> <span class="o">=</span> <span class="n">subtype</span><span class="p">;</span>
	<span class="n">cq</span><span class="o">-&gt;</span><span class="n">queue_id</span> <span class="o">=</span> <span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_mbx_cq_create_q_id</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cq_create</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">response</span><span class="p">);</span>
	<span class="n">cq</span><span class="o">-&gt;</span><span class="n">assoc_qid</span> <span class="o">=</span> <span class="n">eq</span><span class="o">-&gt;</span><span class="n">queue_id</span><span class="p">;</span>
	<span class="n">cq</span><span class="o">-&gt;</span><span class="n">host_index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">cq</span><span class="o">-&gt;</span><span class="n">hba_index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">out:</span>
	<span class="n">mempool_free</span><span class="p">(</span><span class="n">mbox</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">mbox_mem_pool</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_mq_create_fb_init - Send MCC_CREATE without async events registration</span>
<span class="cm"> * @phba: HBA structure that indicates port to create a queue on.</span>
<span class="cm"> * @mq: The queue structure to use to create the mailbox queue.</span>
<span class="cm"> * @mbox: An allocated pointer to type LPFC_MBOXQ_t</span>
<span class="cm"> * @cq: The completion queue to associate with this cq.</span>
<span class="cm"> *</span>
<span class="cm"> * This function provides failback (fb) functionality when the</span>
<span class="cm"> * mq_create_ext fails on older FW generations.  It&#39;s purpose is identical</span>
<span class="cm"> * to mq_create_ext otherwise.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine cannot fail as all attributes were previously accessed and</span>
<span class="cm"> * initialized in mq_create_ext.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">lpfc_mq_create_fb_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">,</span> <span class="k">struct</span> <span class="n">lpfc_queue</span> <span class="o">*</span><span class="n">mq</span><span class="p">,</span>
		       <span class="n">LPFC_MBOXQ_t</span> <span class="o">*</span><span class="n">mbox</span><span class="p">,</span> <span class="k">struct</span> <span class="n">lpfc_queue</span> <span class="o">*</span><span class="n">cq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpfc_mbx_mq_create</span> <span class="o">*</span><span class="n">mq_create</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_dmabuf</span> <span class="o">*</span><span class="n">dmabuf</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">length</span><span class="p">;</span>

	<span class="n">length</span> <span class="o">=</span> <span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_mbx_mq_create</span><span class="p">)</span> <span class="o">-</span>
		  <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_sli4_cfg_mhdr</span><span class="p">));</span>
	<span class="n">lpfc_sli4_config</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">mbox</span><span class="p">,</span> <span class="n">LPFC_MBOX_SUBSYSTEM_COMMON</span><span class="p">,</span>
			 <span class="n">LPFC_MBOX_OPCODE_MQ_CREATE</span><span class="p">,</span>
			 <span class="n">length</span><span class="p">,</span> <span class="n">LPFC_SLI4_MBX_EMBED</span><span class="p">);</span>
	<span class="n">mq_create</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">mbox</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">mqe</span><span class="p">.</span><span class="n">un</span><span class="p">.</span><span class="n">mq_create</span><span class="p">;</span>
	<span class="n">bf_set</span><span class="p">(</span><span class="n">lpfc_mbx_mq_create_num_pages</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mq_create</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">request</span><span class="p">,</span>
	       <span class="n">mq</span><span class="o">-&gt;</span><span class="n">page_count</span><span class="p">);</span>
	<span class="n">bf_set</span><span class="p">(</span><span class="n">lpfc_mq_context_cq_id</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mq_create</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">request</span><span class="p">.</span><span class="n">context</span><span class="p">,</span>
	       <span class="n">cq</span><span class="o">-&gt;</span><span class="n">queue_id</span><span class="p">);</span>
	<span class="n">bf_set</span><span class="p">(</span><span class="n">lpfc_mq_context_valid</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mq_create</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">request</span><span class="p">.</span><span class="n">context</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">mq</span><span class="o">-&gt;</span><span class="n">entry_count</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="mi">16</span>:
		<span class="n">bf_set</span><span class="p">(</span><span class="n">lpfc_mq_context_ring_size</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mq_create</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">request</span><span class="p">.</span><span class="n">context</span><span class="p">,</span>
		       <span class="n">LPFC_MQ_RING_SIZE_16</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">32</span>:
		<span class="n">bf_set</span><span class="p">(</span><span class="n">lpfc_mq_context_ring_size</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mq_create</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">request</span><span class="p">.</span><span class="n">context</span><span class="p">,</span>
		       <span class="n">LPFC_MQ_RING_SIZE_32</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">64</span>:
		<span class="n">bf_set</span><span class="p">(</span><span class="n">lpfc_mq_context_ring_size</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mq_create</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">request</span><span class="p">.</span><span class="n">context</span><span class="p">,</span>
		       <span class="n">LPFC_MQ_RING_SIZE_64</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">128</span>:
		<span class="n">bf_set</span><span class="p">(</span><span class="n">lpfc_mq_context_ring_size</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mq_create</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">request</span><span class="p">.</span><span class="n">context</span><span class="p">,</span>
		       <span class="n">LPFC_MQ_RING_SIZE_128</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">dmabuf</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mq</span><span class="o">-&gt;</span><span class="n">page_list</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mq_create</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">request</span><span class="p">.</span><span class="n">page</span><span class="p">[</span><span class="n">dmabuf</span><span class="o">-&gt;</span><span class="n">buffer_tag</span><span class="p">].</span><span class="n">addr_lo</span> <span class="o">=</span>
			<span class="n">putPaddrLow</span><span class="p">(</span><span class="n">dmabuf</span><span class="o">-&gt;</span><span class="n">phys</span><span class="p">);</span>
		<span class="n">mq_create</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">request</span><span class="p">.</span><span class="n">page</span><span class="p">[</span><span class="n">dmabuf</span><span class="o">-&gt;</span><span class="n">buffer_tag</span><span class="p">].</span><span class="n">addr_hi</span> <span class="o">=</span>
			<span class="n">putPaddrHigh</span><span class="p">(</span><span class="n">dmabuf</span><span class="o">-&gt;</span><span class="n">phys</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_mq_create - Create a mailbox Queue on the HBA</span>
<span class="cm"> * @phba: HBA structure that indicates port to create a queue on.</span>
<span class="cm"> * @mq: The queue structure to use to create the mailbox queue.</span>
<span class="cm"> * @cq: The completion queue to associate with this cq.</span>
<span class="cm"> * @subtype: The queue&#39;s subtype.</span>
<span class="cm"> *</span>
<span class="cm"> * This function creates a mailbox queue, as detailed in @mq, on a port,</span>
<span class="cm"> * described by @phba by sending a MQ_CREATE mailbox command to the HBA.</span>
<span class="cm"> *</span>
<span class="cm"> * The @phba struct is used to send mailbox command to HBA. The @cq struct</span>
<span class="cm"> * is used to get the entry count and entry size that are necessary to</span>
<span class="cm"> * determine the number of pages to allocate and use for this queue. This</span>
<span class="cm"> * function will send the MQ_CREATE mailbox command to the HBA to setup the</span>
<span class="cm"> * mailbox queue. This function is asynchronous and will wait for the mailbox</span>
<span class="cm"> * command to finish before continuing.</span>
<span class="cm"> *</span>
<span class="cm"> * On success this function will return a zero. If unable to allocate enough</span>
<span class="cm"> * memory this function will return -ENOMEM. If the queue create mailbox command</span>
<span class="cm"> * fails this function will return -ENXIO.</span>
<span class="cm"> **/</span>
<span class="kt">int32_t</span>
<span class="nf">lpfc_mq_create</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">,</span> <span class="k">struct</span> <span class="n">lpfc_queue</span> <span class="o">*</span><span class="n">mq</span><span class="p">,</span>
	       <span class="k">struct</span> <span class="n">lpfc_queue</span> <span class="o">*</span><span class="n">cq</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">subtype</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpfc_mbx_mq_create</span> <span class="o">*</span><span class="n">mq_create</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_mbx_mq_create_ext</span> <span class="o">*</span><span class="n">mq_create_ext</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_dmabuf</span> <span class="o">*</span><span class="n">dmabuf</span><span class="p">;</span>
	<span class="n">LPFC_MBOXQ_t</span> <span class="o">*</span><span class="n">mbox</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">,</span> <span class="n">length</span><span class="p">,</span> <span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">shdr_status</span><span class="p">,</span> <span class="n">shdr_add_status</span><span class="p">;</span>
	<span class="k">union</span> <span class="n">lpfc_sli4_cfg_shdr</span> <span class="o">*</span><span class="n">shdr</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">hw_page_size</span> <span class="o">=</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">pc_sli4_params</span><span class="p">.</span><span class="n">if_page_sz</span><span class="p">;</span>

	<span class="cm">/* sanity check on queue memory */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mq</span> <span class="o">||</span> <span class="o">!</span><span class="n">cq</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">pc_sli4_params</span><span class="p">.</span><span class="n">supported</span><span class="p">)</span>
		<span class="n">hw_page_size</span> <span class="o">=</span> <span class="n">SLI4_PAGE_SIZE</span><span class="p">;</span>

	<span class="n">mbox</span> <span class="o">=</span> <span class="n">mempool_alloc</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">mbox_mem_pool</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mbox</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="n">length</span> <span class="o">=</span> <span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_mbx_mq_create_ext</span><span class="p">)</span> <span class="o">-</span>
		  <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_sli4_cfg_mhdr</span><span class="p">));</span>
	<span class="n">lpfc_sli4_config</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">mbox</span><span class="p">,</span> <span class="n">LPFC_MBOX_SUBSYSTEM_COMMON</span><span class="p">,</span>
			 <span class="n">LPFC_MBOX_OPCODE_MQ_CREATE_EXT</span><span class="p">,</span>
			 <span class="n">length</span><span class="p">,</span> <span class="n">LPFC_SLI4_MBX_EMBED</span><span class="p">);</span>

	<span class="n">mq_create_ext</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">mbox</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">mqe</span><span class="p">.</span><span class="n">un</span><span class="p">.</span><span class="n">mq_create_ext</span><span class="p">;</span>
	<span class="n">shdr</span> <span class="o">=</span> <span class="p">(</span><span class="k">union</span> <span class="n">lpfc_sli4_cfg_shdr</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">mq_create_ext</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">cfg_shdr</span><span class="p">;</span>
	<span class="n">bf_set</span><span class="p">(</span><span class="n">lpfc_mbx_mq_create_ext_num_pages</span><span class="p">,</span>
	       <span class="o">&amp;</span><span class="n">mq_create_ext</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">request</span><span class="p">,</span> <span class="n">mq</span><span class="o">-&gt;</span><span class="n">page_count</span><span class="p">);</span>
	<span class="n">bf_set</span><span class="p">(</span><span class="n">lpfc_mbx_mq_create_ext_async_evt_link</span><span class="p">,</span>
	       <span class="o">&amp;</span><span class="n">mq_create_ext</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">request</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">bf_set</span><span class="p">(</span><span class="n">lpfc_mbx_mq_create_ext_async_evt_fip</span><span class="p">,</span>
	       <span class="o">&amp;</span><span class="n">mq_create_ext</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">request</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">bf_set</span><span class="p">(</span><span class="n">lpfc_mbx_mq_create_ext_async_evt_group5</span><span class="p">,</span>
	       <span class="o">&amp;</span><span class="n">mq_create_ext</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">request</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">bf_set</span><span class="p">(</span><span class="n">lpfc_mbx_mq_create_ext_async_evt_fc</span><span class="p">,</span>
	       <span class="o">&amp;</span><span class="n">mq_create_ext</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">request</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">bf_set</span><span class="p">(</span><span class="n">lpfc_mbx_mq_create_ext_async_evt_sli</span><span class="p">,</span>
	       <span class="o">&amp;</span><span class="n">mq_create_ext</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">request</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">bf_set</span><span class="p">(</span><span class="n">lpfc_mq_context_valid</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mq_create_ext</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">request</span><span class="p">.</span><span class="n">context</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">bf_set</span><span class="p">(</span><span class="n">lpfc_mbox_hdr_version</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">shdr</span><span class="o">-&gt;</span><span class="n">request</span><span class="p">,</span>
	       <span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">pc_sli4_params</span><span class="p">.</span><span class="n">mqv</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">pc_sli4_params</span><span class="p">.</span><span class="n">mqv</span> <span class="o">==</span> <span class="n">LPFC_Q_CREATE_VERSION_1</span><span class="p">)</span>
		<span class="n">bf_set</span><span class="p">(</span><span class="n">lpfc_mbx_mq_create_ext_cq_id</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mq_create_ext</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">request</span><span class="p">,</span>
		       <span class="n">cq</span><span class="o">-&gt;</span><span class="n">queue_id</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">bf_set</span><span class="p">(</span><span class="n">lpfc_mq_context_cq_id</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mq_create_ext</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">request</span><span class="p">.</span><span class="n">context</span><span class="p">,</span>
		       <span class="n">cq</span><span class="o">-&gt;</span><span class="n">queue_id</span><span class="p">);</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">mq</span><span class="o">-&gt;</span><span class="n">entry_count</span><span class="p">)</span> <span class="p">{</span>
	<span class="nl">default:</span>
		<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_SLI</span><span class="p">,</span>
				<span class="s">&quot;0362 Unsupported MQ count. (%d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">mq</span><span class="o">-&gt;</span><span class="n">entry_count</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">mq</span><span class="o">-&gt;</span><span class="n">entry_count</span> <span class="o">&lt;</span> <span class="mi">16</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="cm">/* otherwise default to smallest count (drop through) */</span>
	<span class="k">case</span> <span class="mi">16</span>:
		<span class="n">bf_set</span><span class="p">(</span><span class="n">lpfc_mq_context_ring_size</span><span class="p">,</span>
		       <span class="o">&amp;</span><span class="n">mq_create_ext</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">request</span><span class="p">.</span><span class="n">context</span><span class="p">,</span>
		       <span class="n">LPFC_MQ_RING_SIZE_16</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">32</span>:
		<span class="n">bf_set</span><span class="p">(</span><span class="n">lpfc_mq_context_ring_size</span><span class="p">,</span>
		       <span class="o">&amp;</span><span class="n">mq_create_ext</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">request</span><span class="p">.</span><span class="n">context</span><span class="p">,</span>
		       <span class="n">LPFC_MQ_RING_SIZE_32</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">64</span>:
		<span class="n">bf_set</span><span class="p">(</span><span class="n">lpfc_mq_context_ring_size</span><span class="p">,</span>
		       <span class="o">&amp;</span><span class="n">mq_create_ext</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">request</span><span class="p">.</span><span class="n">context</span><span class="p">,</span>
		       <span class="n">LPFC_MQ_RING_SIZE_64</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">128</span>:
		<span class="n">bf_set</span><span class="p">(</span><span class="n">lpfc_mq_context_ring_size</span><span class="p">,</span>
		       <span class="o">&amp;</span><span class="n">mq_create_ext</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">request</span><span class="p">.</span><span class="n">context</span><span class="p">,</span>
		       <span class="n">LPFC_MQ_RING_SIZE_128</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">dmabuf</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mq</span><span class="o">-&gt;</span><span class="n">page_list</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">memset</span><span class="p">(</span><span class="n">dmabuf</span><span class="o">-&gt;</span><span class="n">virt</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">hw_page_size</span><span class="p">);</span>
		<span class="n">mq_create_ext</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">request</span><span class="p">.</span><span class="n">page</span><span class="p">[</span><span class="n">dmabuf</span><span class="o">-&gt;</span><span class="n">buffer_tag</span><span class="p">].</span><span class="n">addr_lo</span> <span class="o">=</span>
					<span class="n">putPaddrLow</span><span class="p">(</span><span class="n">dmabuf</span><span class="o">-&gt;</span><span class="n">phys</span><span class="p">);</span>
		<span class="n">mq_create_ext</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">request</span><span class="p">.</span><span class="n">page</span><span class="p">[</span><span class="n">dmabuf</span><span class="o">-&gt;</span><span class="n">buffer_tag</span><span class="p">].</span><span class="n">addr_hi</span> <span class="o">=</span>
					<span class="n">putPaddrHigh</span><span class="p">(</span><span class="n">dmabuf</span><span class="o">-&gt;</span><span class="n">phys</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">lpfc_sli_issue_mbox</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">mbox</span><span class="p">,</span> <span class="n">MBX_POLL</span><span class="p">);</span>
	<span class="n">mq</span><span class="o">-&gt;</span><span class="n">queue_id</span> <span class="o">=</span> <span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_mbx_mq_create_q_id</span><span class="p">,</span>
			      <span class="o">&amp;</span><span class="n">mq_create_ext</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">response</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">!=</span> <span class="n">MBX_SUCCESS</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_INFO</span><span class="p">,</span> <span class="n">LOG_INIT</span><span class="p">,</span>
				<span class="s">&quot;2795 MQ_CREATE_EXT failed with &quot;</span>
				<span class="s">&quot;status x%x. Failback to MQ_CREATE.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">rc</span><span class="p">);</span>
		<span class="n">lpfc_mq_create_fb_init</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">mq</span><span class="p">,</span> <span class="n">mbox</span><span class="p">,</span> <span class="n">cq</span><span class="p">);</span>
		<span class="n">mq_create</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">mbox</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">mqe</span><span class="p">.</span><span class="n">un</span><span class="p">.</span><span class="n">mq_create</span><span class="p">;</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">lpfc_sli_issue_mbox</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">mbox</span><span class="p">,</span> <span class="n">MBX_POLL</span><span class="p">);</span>
		<span class="n">shdr</span> <span class="o">=</span> <span class="p">(</span><span class="k">union</span> <span class="n">lpfc_sli4_cfg_shdr</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">mq_create</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">cfg_shdr</span><span class="p">;</span>
		<span class="n">mq</span><span class="o">-&gt;</span><span class="n">queue_id</span> <span class="o">=</span> <span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_mbx_mq_create_q_id</span><span class="p">,</span>
				      <span class="o">&amp;</span><span class="n">mq_create</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">response</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* The IOCTL status is embedded in the mailbox subheader. */</span>
	<span class="n">shdr_status</span> <span class="o">=</span> <span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_mbox_hdr_status</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">shdr</span><span class="o">-&gt;</span><span class="n">response</span><span class="p">);</span>
	<span class="n">shdr_add_status</span> <span class="o">=</span> <span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_mbox_hdr_add_status</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">shdr</span><span class="o">-&gt;</span><span class="n">response</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">shdr_status</span> <span class="o">||</span> <span class="n">shdr_add_status</span> <span class="o">||</span> <span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_INIT</span><span class="p">,</span>
				<span class="s">&quot;2502 MQ_CREATE mailbox failed with &quot;</span>
				<span class="s">&quot;status x%x add_status x%x, mbx status x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">shdr_status</span><span class="p">,</span> <span class="n">shdr_add_status</span><span class="p">,</span> <span class="n">rc</span><span class="p">);</span>
		<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENXIO</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mq</span><span class="o">-&gt;</span><span class="n">queue_id</span> <span class="o">==</span> <span class="mh">0xFFFF</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENXIO</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">mq</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">=</span> <span class="n">LPFC_MQ</span><span class="p">;</span>
	<span class="n">mq</span><span class="o">-&gt;</span><span class="n">assoc_qid</span> <span class="o">=</span> <span class="n">cq</span><span class="o">-&gt;</span><span class="n">queue_id</span><span class="p">;</span>
	<span class="n">mq</span><span class="o">-&gt;</span><span class="n">subtype</span> <span class="o">=</span> <span class="n">subtype</span><span class="p">;</span>
	<span class="n">mq</span><span class="o">-&gt;</span><span class="n">host_index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">mq</span><span class="o">-&gt;</span><span class="n">hba_index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* link the mq onto the parent cq child list */</span>
	<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mq</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cq</span><span class="o">-&gt;</span><span class="n">child_list</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="n">mempool_free</span><span class="p">(</span><span class="n">mbox</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">mbox_mem_pool</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_wq_create - Create a Work Queue on the HBA</span>
<span class="cm"> * @phba: HBA structure that indicates port to create a queue on.</span>
<span class="cm"> * @wq: The queue structure to use to create the work queue.</span>
<span class="cm"> * @cq: The completion queue to bind this work queue to.</span>
<span class="cm"> * @subtype: The subtype of the work queue indicating its functionality.</span>
<span class="cm"> *</span>
<span class="cm"> * This function creates a work queue, as detailed in @wq, on a port, described</span>
<span class="cm"> * by @phba by sending a WQ_CREATE mailbox command to the HBA.</span>
<span class="cm"> *</span>
<span class="cm"> * The @phba struct is used to send mailbox command to HBA. The @wq struct</span>
<span class="cm"> * is used to get the entry count and entry size that are necessary to</span>
<span class="cm"> * determine the number of pages to allocate and use for this queue. The @cq</span>
<span class="cm"> * is used to indicate which completion queue to bind this work queue to. This</span>
<span class="cm"> * function will send the WQ_CREATE mailbox command to the HBA to setup the</span>
<span class="cm"> * work queue. This function is asynchronous and will wait for the mailbox</span>
<span class="cm"> * command to finish before continuing.</span>
<span class="cm"> *</span>
<span class="cm"> * On success this function will return a zero. If unable to allocate enough</span>
<span class="cm"> * memory this function will return -ENOMEM. If the queue create mailbox command</span>
<span class="cm"> * fails this function will return -ENXIO.</span>
<span class="cm"> **/</span>
<span class="kt">uint32_t</span>
<span class="nf">lpfc_wq_create</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">,</span> <span class="k">struct</span> <span class="n">lpfc_queue</span> <span class="o">*</span><span class="n">wq</span><span class="p">,</span>
	       <span class="k">struct</span> <span class="n">lpfc_queue</span> <span class="o">*</span><span class="n">cq</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">subtype</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpfc_mbx_wq_create</span> <span class="o">*</span><span class="n">wq_create</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_dmabuf</span> <span class="o">*</span><span class="n">dmabuf</span><span class="p">;</span>
	<span class="n">LPFC_MBOXQ_t</span> <span class="o">*</span><span class="n">mbox</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">,</span> <span class="n">length</span><span class="p">,</span> <span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">shdr_status</span><span class="p">,</span> <span class="n">shdr_add_status</span><span class="p">;</span>
	<span class="k">union</span> <span class="n">lpfc_sli4_cfg_shdr</span> <span class="o">*</span><span class="n">shdr</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">hw_page_size</span> <span class="o">=</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">pc_sli4_params</span><span class="p">.</span><span class="n">if_page_sz</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dma_address</span> <span class="o">*</span><span class="n">page</span><span class="p">;</span>

	<span class="cm">/* sanity check on queue memory */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">wq</span> <span class="o">||</span> <span class="o">!</span><span class="n">cq</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">pc_sli4_params</span><span class="p">.</span><span class="n">supported</span><span class="p">)</span>
		<span class="n">hw_page_size</span> <span class="o">=</span> <span class="n">SLI4_PAGE_SIZE</span><span class="p">;</span>

	<span class="n">mbox</span> <span class="o">=</span> <span class="n">mempool_alloc</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">mbox_mem_pool</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mbox</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="n">length</span> <span class="o">=</span> <span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_mbx_wq_create</span><span class="p">)</span> <span class="o">-</span>
		  <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_sli4_cfg_mhdr</span><span class="p">));</span>
	<span class="n">lpfc_sli4_config</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">mbox</span><span class="p">,</span> <span class="n">LPFC_MBOX_SUBSYSTEM_FCOE</span><span class="p">,</span>
			 <span class="n">LPFC_MBOX_OPCODE_FCOE_WQ_CREATE</span><span class="p">,</span>
			 <span class="n">length</span><span class="p">,</span> <span class="n">LPFC_SLI4_MBX_EMBED</span><span class="p">);</span>
	<span class="n">wq_create</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">mbox</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">mqe</span><span class="p">.</span><span class="n">un</span><span class="p">.</span><span class="n">wq_create</span><span class="p">;</span>
	<span class="n">shdr</span> <span class="o">=</span> <span class="p">(</span><span class="k">union</span> <span class="n">lpfc_sli4_cfg_shdr</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">wq_create</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">cfg_shdr</span><span class="p">;</span>
	<span class="n">bf_set</span><span class="p">(</span><span class="n">lpfc_mbx_wq_create_num_pages</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wq_create</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">request</span><span class="p">,</span>
		    <span class="n">wq</span><span class="o">-&gt;</span><span class="n">page_count</span><span class="p">);</span>
	<span class="n">bf_set</span><span class="p">(</span><span class="n">lpfc_mbx_wq_create_cq_id</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wq_create</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">request</span><span class="p">,</span>
		    <span class="n">cq</span><span class="o">-&gt;</span><span class="n">queue_id</span><span class="p">);</span>
	<span class="n">bf_set</span><span class="p">(</span><span class="n">lpfc_mbox_hdr_version</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">shdr</span><span class="o">-&gt;</span><span class="n">request</span><span class="p">,</span>
	       <span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">pc_sli4_params</span><span class="p">.</span><span class="n">wqv</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">pc_sli4_params</span><span class="p">.</span><span class="n">wqv</span> <span class="o">==</span> <span class="n">LPFC_Q_CREATE_VERSION_1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">bf_set</span><span class="p">(</span><span class="n">lpfc_mbx_wq_create_wqe_count</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wq_create</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">request_1</span><span class="p">,</span>
		       <span class="n">wq</span><span class="o">-&gt;</span><span class="n">entry_count</span><span class="p">);</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">wq</span><span class="o">-&gt;</span><span class="n">entry_size</span><span class="p">)</span> <span class="p">{</span>
		<span class="nl">default:</span>
		<span class="k">case</span> <span class="mi">64</span>:
			<span class="n">bf_set</span><span class="p">(</span><span class="n">lpfc_mbx_wq_create_wqe_size</span><span class="p">,</span>
			       <span class="o">&amp;</span><span class="n">wq_create</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">request_1</span><span class="p">,</span>
			       <span class="n">LPFC_WQ_WQE_SIZE_64</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="mi">128</span>:
			<span class="n">bf_set</span><span class="p">(</span><span class="n">lpfc_mbx_wq_create_wqe_size</span><span class="p">,</span>
			       <span class="o">&amp;</span><span class="n">wq_create</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">request_1</span><span class="p">,</span>
			       <span class="n">LPFC_WQ_WQE_SIZE_128</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">bf_set</span><span class="p">(</span><span class="n">lpfc_mbx_wq_create_page_size</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wq_create</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">request_1</span><span class="p">,</span>
		       <span class="p">(</span><span class="n">PAGE_SIZE</span><span class="o">/</span><span class="n">SLI4_PAGE_SIZE</span><span class="p">));</span>
		<span class="n">page</span> <span class="o">=</span> <span class="n">wq_create</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">request_1</span><span class="p">.</span><span class="n">page</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">page</span> <span class="o">=</span> <span class="n">wq_create</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">request</span><span class="p">.</span><span class="n">page</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">dmabuf</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wq</span><span class="o">-&gt;</span><span class="n">page_list</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">memset</span><span class="p">(</span><span class="n">dmabuf</span><span class="o">-&gt;</span><span class="n">virt</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">hw_page_size</span><span class="p">);</span>
		<span class="n">page</span><span class="p">[</span><span class="n">dmabuf</span><span class="o">-&gt;</span><span class="n">buffer_tag</span><span class="p">].</span><span class="n">addr_lo</span> <span class="o">=</span> <span class="n">putPaddrLow</span><span class="p">(</span><span class="n">dmabuf</span><span class="o">-&gt;</span><span class="n">phys</span><span class="p">);</span>
		<span class="n">page</span><span class="p">[</span><span class="n">dmabuf</span><span class="o">-&gt;</span><span class="n">buffer_tag</span><span class="p">].</span><span class="n">addr_hi</span> <span class="o">=</span> <span class="n">putPaddrHigh</span><span class="p">(</span><span class="n">dmabuf</span><span class="o">-&gt;</span><span class="n">phys</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">lpfc_sli_issue_mbox</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">mbox</span><span class="p">,</span> <span class="n">MBX_POLL</span><span class="p">);</span>
	<span class="cm">/* The IOCTL status is embedded in the mailbox subheader. */</span>
	<span class="n">shdr_status</span> <span class="o">=</span> <span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_mbox_hdr_status</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">shdr</span><span class="o">-&gt;</span><span class="n">response</span><span class="p">);</span>
	<span class="n">shdr_add_status</span> <span class="o">=</span> <span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_mbox_hdr_add_status</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">shdr</span><span class="o">-&gt;</span><span class="n">response</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">shdr_status</span> <span class="o">||</span> <span class="n">shdr_add_status</span> <span class="o">||</span> <span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_INIT</span><span class="p">,</span>
				<span class="s">&quot;2503 WQ_CREATE mailbox failed with &quot;</span>
				<span class="s">&quot;status x%x add_status x%x, mbx status x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">shdr_status</span><span class="p">,</span> <span class="n">shdr_add_status</span><span class="p">,</span> <span class="n">rc</span><span class="p">);</span>
		<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENXIO</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">wq</span><span class="o">-&gt;</span><span class="n">queue_id</span> <span class="o">=</span> <span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_mbx_wq_create_q_id</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wq_create</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">response</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">wq</span><span class="o">-&gt;</span><span class="n">queue_id</span> <span class="o">==</span> <span class="mh">0xFFFF</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENXIO</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">wq</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">=</span> <span class="n">LPFC_WQ</span><span class="p">;</span>
	<span class="n">wq</span><span class="o">-&gt;</span><span class="n">assoc_qid</span> <span class="o">=</span> <span class="n">cq</span><span class="o">-&gt;</span><span class="n">queue_id</span><span class="p">;</span>
	<span class="n">wq</span><span class="o">-&gt;</span><span class="n">subtype</span> <span class="o">=</span> <span class="n">subtype</span><span class="p">;</span>
	<span class="n">wq</span><span class="o">-&gt;</span><span class="n">host_index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">wq</span><span class="o">-&gt;</span><span class="n">hba_index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">wq</span><span class="o">-&gt;</span><span class="n">entry_repost</span> <span class="o">=</span> <span class="n">LPFC_RELEASE_NOTIFICATION_INTERVAL</span><span class="p">;</span>

	<span class="cm">/* link the wq onto the parent cq child list */</span>
	<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wq</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cq</span><span class="o">-&gt;</span><span class="n">child_list</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="n">mempool_free</span><span class="p">(</span><span class="n">mbox</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">mbox_mem_pool</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_rq_adjust_repost - Adjust entry_repost for an RQ</span>
<span class="cm"> * @phba: HBA structure that indicates port to create a queue on.</span>
<span class="cm"> * @rq:   The queue structure to use for the receive queue.</span>
<span class="cm"> * @qno:  The associated HBQ number</span>
<span class="cm"> *</span>
<span class="cm"> *</span>
<span class="cm"> * For SLI4 we need to adjust the RQ repost value based on</span>
<span class="cm"> * the number of buffers that are initially posted to the RQ.</span>
<span class="cm"> */</span>
<span class="kt">void</span>
<span class="nf">lpfc_rq_adjust_repost</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">,</span> <span class="k">struct</span> <span class="n">lpfc_queue</span> <span class="o">*</span><span class="n">rq</span><span class="p">,</span> <span class="kt">int</span> <span class="n">qno</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">uint32_t</span> <span class="n">cnt</span><span class="p">;</span>

	<span class="cm">/* sanity check on queue memory */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rq</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">cnt</span> <span class="o">=</span> <span class="n">lpfc_hbq_defs</span><span class="p">[</span><span class="n">qno</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">entry_count</span><span class="p">;</span>

	<span class="cm">/* Recalc repost for RQs based on buffers initially posted */</span>
	<span class="n">cnt</span> <span class="o">=</span> <span class="p">(</span><span class="n">cnt</span> <span class="o">&gt;&gt;</span> <span class="mi">3</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cnt</span> <span class="o">&lt;</span> <span class="n">LPFC_QUEUE_MIN_REPOST</span><span class="p">)</span>
		<span class="n">cnt</span> <span class="o">=</span> <span class="n">LPFC_QUEUE_MIN_REPOST</span><span class="p">;</span>

	<span class="n">rq</span><span class="o">-&gt;</span><span class="n">entry_repost</span> <span class="o">=</span> <span class="n">cnt</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_rq_create - Create a Receive Queue on the HBA</span>
<span class="cm"> * @phba: HBA structure that indicates port to create a queue on.</span>
<span class="cm"> * @hrq: The queue structure to use to create the header receive queue.</span>
<span class="cm"> * @drq: The queue structure to use to create the data receive queue.</span>
<span class="cm"> * @cq: The completion queue to bind this work queue to.</span>
<span class="cm"> *</span>
<span class="cm"> * This function creates a receive buffer queue pair , as detailed in @hrq and</span>
<span class="cm"> * @drq, on a port, described by @phba by sending a RQ_CREATE mailbox command</span>
<span class="cm"> * to the HBA.</span>
<span class="cm"> *</span>
<span class="cm"> * The @phba struct is used to send mailbox command to HBA. The @drq and @hrq</span>
<span class="cm"> * struct is used to get the entry count that is necessary to determine the</span>
<span class="cm"> * number of pages to use for this queue. The @cq is used to indicate which</span>
<span class="cm"> * completion queue to bind received buffers that are posted to these queues to.</span>
<span class="cm"> * This function will send the RQ_CREATE mailbox command to the HBA to setup the</span>
<span class="cm"> * receive queue pair. This function is asynchronous and will wait for the</span>
<span class="cm"> * mailbox command to finish before continuing.</span>
<span class="cm"> *</span>
<span class="cm"> * On success this function will return a zero. If unable to allocate enough</span>
<span class="cm"> * memory this function will return -ENOMEM. If the queue create mailbox command</span>
<span class="cm"> * fails this function will return -ENXIO.</span>
<span class="cm"> **/</span>
<span class="kt">uint32_t</span>
<span class="nf">lpfc_rq_create</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">,</span> <span class="k">struct</span> <span class="n">lpfc_queue</span> <span class="o">*</span><span class="n">hrq</span><span class="p">,</span>
	       <span class="k">struct</span> <span class="n">lpfc_queue</span> <span class="o">*</span><span class="n">drq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">lpfc_queue</span> <span class="o">*</span><span class="n">cq</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">subtype</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpfc_mbx_rq_create</span> <span class="o">*</span><span class="n">rq_create</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_dmabuf</span> <span class="o">*</span><span class="n">dmabuf</span><span class="p">;</span>
	<span class="n">LPFC_MBOXQ_t</span> <span class="o">*</span><span class="n">mbox</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">,</span> <span class="n">length</span><span class="p">,</span> <span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">shdr_status</span><span class="p">,</span> <span class="n">shdr_add_status</span><span class="p">;</span>
	<span class="k">union</span> <span class="n">lpfc_sli4_cfg_shdr</span> <span class="o">*</span><span class="n">shdr</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">hw_page_size</span> <span class="o">=</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">pc_sli4_params</span><span class="p">.</span><span class="n">if_page_sz</span><span class="p">;</span>

	<span class="cm">/* sanity check on queue memory */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hrq</span> <span class="o">||</span> <span class="o">!</span><span class="n">drq</span> <span class="o">||</span> <span class="o">!</span><span class="n">cq</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">pc_sli4_params</span><span class="p">.</span><span class="n">supported</span><span class="p">)</span>
		<span class="n">hw_page_size</span> <span class="o">=</span> <span class="n">SLI4_PAGE_SIZE</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">hrq</span><span class="o">-&gt;</span><span class="n">entry_count</span> <span class="o">!=</span> <span class="n">drq</span><span class="o">-&gt;</span><span class="n">entry_count</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="n">mbox</span> <span class="o">=</span> <span class="n">mempool_alloc</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">mbox_mem_pool</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mbox</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="n">length</span> <span class="o">=</span> <span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_mbx_rq_create</span><span class="p">)</span> <span class="o">-</span>
		  <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_sli4_cfg_mhdr</span><span class="p">));</span>
	<span class="n">lpfc_sli4_config</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">mbox</span><span class="p">,</span> <span class="n">LPFC_MBOX_SUBSYSTEM_FCOE</span><span class="p">,</span>
			 <span class="n">LPFC_MBOX_OPCODE_FCOE_RQ_CREATE</span><span class="p">,</span>
			 <span class="n">length</span><span class="p">,</span> <span class="n">LPFC_SLI4_MBX_EMBED</span><span class="p">);</span>
	<span class="n">rq_create</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">mbox</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">mqe</span><span class="p">.</span><span class="n">un</span><span class="p">.</span><span class="n">rq_create</span><span class="p">;</span>
	<span class="n">shdr</span> <span class="o">=</span> <span class="p">(</span><span class="k">union</span> <span class="n">lpfc_sli4_cfg_shdr</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">rq_create</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">cfg_shdr</span><span class="p">;</span>
	<span class="n">bf_set</span><span class="p">(</span><span class="n">lpfc_mbox_hdr_version</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">shdr</span><span class="o">-&gt;</span><span class="n">request</span><span class="p">,</span>
	       <span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">pc_sli4_params</span><span class="p">.</span><span class="n">rqv</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">pc_sli4_params</span><span class="p">.</span><span class="n">rqv</span> <span class="o">==</span> <span class="n">LPFC_Q_CREATE_VERSION_1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">bf_set</span><span class="p">(</span><span class="n">lpfc_rq_context_rqe_count_1</span><span class="p">,</span>
		       <span class="o">&amp;</span><span class="n">rq_create</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">request</span><span class="p">.</span><span class="n">context</span><span class="p">,</span>
		       <span class="n">hrq</span><span class="o">-&gt;</span><span class="n">entry_count</span><span class="p">);</span>
		<span class="n">rq_create</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">request</span><span class="p">.</span><span class="n">context</span><span class="p">.</span><span class="n">buffer_size</span> <span class="o">=</span> <span class="n">LPFC_HDR_BUF_SIZE</span><span class="p">;</span>
		<span class="n">bf_set</span><span class="p">(</span><span class="n">lpfc_rq_context_rqe_size</span><span class="p">,</span>
		       <span class="o">&amp;</span><span class="n">rq_create</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">request</span><span class="p">.</span><span class="n">context</span><span class="p">,</span>
		       <span class="n">LPFC_RQE_SIZE_8</span><span class="p">);</span>
		<span class="n">bf_set</span><span class="p">(</span><span class="n">lpfc_rq_context_page_size</span><span class="p">,</span>
		       <span class="o">&amp;</span><span class="n">rq_create</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">request</span><span class="p">.</span><span class="n">context</span><span class="p">,</span>
		       <span class="p">(</span><span class="n">PAGE_SIZE</span><span class="o">/</span><span class="n">SLI4_PAGE_SIZE</span><span class="p">));</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">hrq</span><span class="o">-&gt;</span><span class="n">entry_count</span><span class="p">)</span> <span class="p">{</span>
		<span class="nl">default:</span>
			<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_SLI</span><span class="p">,</span>
					<span class="s">&quot;2535 Unsupported RQ count. (%d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">hrq</span><span class="o">-&gt;</span><span class="n">entry_count</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">hrq</span><span class="o">-&gt;</span><span class="n">entry_count</span> <span class="o">&lt;</span> <span class="mi">512</span><span class="p">)</span>
				<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
			<span class="cm">/* otherwise default to smallest count (drop through) */</span>
		<span class="k">case</span> <span class="mi">512</span>:
			<span class="n">bf_set</span><span class="p">(</span><span class="n">lpfc_rq_context_rqe_count</span><span class="p">,</span>
			       <span class="o">&amp;</span><span class="n">rq_create</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">request</span><span class="p">.</span><span class="n">context</span><span class="p">,</span>
			       <span class="n">LPFC_RQ_RING_SIZE_512</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="mi">1024</span>:
			<span class="n">bf_set</span><span class="p">(</span><span class="n">lpfc_rq_context_rqe_count</span><span class="p">,</span>
			       <span class="o">&amp;</span><span class="n">rq_create</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">request</span><span class="p">.</span><span class="n">context</span><span class="p">,</span>
			       <span class="n">LPFC_RQ_RING_SIZE_1024</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="mi">2048</span>:
			<span class="n">bf_set</span><span class="p">(</span><span class="n">lpfc_rq_context_rqe_count</span><span class="p">,</span>
			       <span class="o">&amp;</span><span class="n">rq_create</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">request</span><span class="p">.</span><span class="n">context</span><span class="p">,</span>
			       <span class="n">LPFC_RQ_RING_SIZE_2048</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="mi">4096</span>:
			<span class="n">bf_set</span><span class="p">(</span><span class="n">lpfc_rq_context_rqe_count</span><span class="p">,</span>
			       <span class="o">&amp;</span><span class="n">rq_create</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">request</span><span class="p">.</span><span class="n">context</span><span class="p">,</span>
			       <span class="n">LPFC_RQ_RING_SIZE_4096</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">bf_set</span><span class="p">(</span><span class="n">lpfc_rq_context_buf_size</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rq_create</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">request</span><span class="p">.</span><span class="n">context</span><span class="p">,</span>
		       <span class="n">LPFC_HDR_BUF_SIZE</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">bf_set</span><span class="p">(</span><span class="n">lpfc_rq_context_cq_id</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rq_create</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">request</span><span class="p">.</span><span class="n">context</span><span class="p">,</span>
	       <span class="n">cq</span><span class="o">-&gt;</span><span class="n">queue_id</span><span class="p">);</span>
	<span class="n">bf_set</span><span class="p">(</span><span class="n">lpfc_mbx_rq_create_num_pages</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rq_create</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">request</span><span class="p">,</span>
	       <span class="n">hrq</span><span class="o">-&gt;</span><span class="n">page_count</span><span class="p">);</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">dmabuf</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hrq</span><span class="o">-&gt;</span><span class="n">page_list</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">memset</span><span class="p">(</span><span class="n">dmabuf</span><span class="o">-&gt;</span><span class="n">virt</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">hw_page_size</span><span class="p">);</span>
		<span class="n">rq_create</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">request</span><span class="p">.</span><span class="n">page</span><span class="p">[</span><span class="n">dmabuf</span><span class="o">-&gt;</span><span class="n">buffer_tag</span><span class="p">].</span><span class="n">addr_lo</span> <span class="o">=</span>
					<span class="n">putPaddrLow</span><span class="p">(</span><span class="n">dmabuf</span><span class="o">-&gt;</span><span class="n">phys</span><span class="p">);</span>
		<span class="n">rq_create</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">request</span><span class="p">.</span><span class="n">page</span><span class="p">[</span><span class="n">dmabuf</span><span class="o">-&gt;</span><span class="n">buffer_tag</span><span class="p">].</span><span class="n">addr_hi</span> <span class="o">=</span>
					<span class="n">putPaddrHigh</span><span class="p">(</span><span class="n">dmabuf</span><span class="o">-&gt;</span><span class="n">phys</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">lpfc_sli_issue_mbox</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">mbox</span><span class="p">,</span> <span class="n">MBX_POLL</span><span class="p">);</span>
	<span class="cm">/* The IOCTL status is embedded in the mailbox subheader. */</span>
	<span class="n">shdr_status</span> <span class="o">=</span> <span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_mbox_hdr_status</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">shdr</span><span class="o">-&gt;</span><span class="n">response</span><span class="p">);</span>
	<span class="n">shdr_add_status</span> <span class="o">=</span> <span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_mbox_hdr_add_status</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">shdr</span><span class="o">-&gt;</span><span class="n">response</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">shdr_status</span> <span class="o">||</span> <span class="n">shdr_add_status</span> <span class="o">||</span> <span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_INIT</span><span class="p">,</span>
				<span class="s">&quot;2504 RQ_CREATE mailbox failed with &quot;</span>
				<span class="s">&quot;status x%x add_status x%x, mbx status x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">shdr_status</span><span class="p">,</span> <span class="n">shdr_add_status</span><span class="p">,</span> <span class="n">rc</span><span class="p">);</span>
		<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENXIO</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">hrq</span><span class="o">-&gt;</span><span class="n">queue_id</span> <span class="o">=</span> <span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_mbx_rq_create_q_id</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rq_create</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">response</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hrq</span><span class="o">-&gt;</span><span class="n">queue_id</span> <span class="o">==</span> <span class="mh">0xFFFF</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENXIO</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">hrq</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">=</span> <span class="n">LPFC_HRQ</span><span class="p">;</span>
	<span class="n">hrq</span><span class="o">-&gt;</span><span class="n">assoc_qid</span> <span class="o">=</span> <span class="n">cq</span><span class="o">-&gt;</span><span class="n">queue_id</span><span class="p">;</span>
	<span class="n">hrq</span><span class="o">-&gt;</span><span class="n">subtype</span> <span class="o">=</span> <span class="n">subtype</span><span class="p">;</span>
	<span class="n">hrq</span><span class="o">-&gt;</span><span class="n">host_index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">hrq</span><span class="o">-&gt;</span><span class="n">hba_index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* now create the data queue */</span>
	<span class="n">lpfc_sli4_config</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">mbox</span><span class="p">,</span> <span class="n">LPFC_MBOX_SUBSYSTEM_FCOE</span><span class="p">,</span>
			 <span class="n">LPFC_MBOX_OPCODE_FCOE_RQ_CREATE</span><span class="p">,</span>
			 <span class="n">length</span><span class="p">,</span> <span class="n">LPFC_SLI4_MBX_EMBED</span><span class="p">);</span>
	<span class="n">bf_set</span><span class="p">(</span><span class="n">lpfc_mbox_hdr_version</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">shdr</span><span class="o">-&gt;</span><span class="n">request</span><span class="p">,</span>
	       <span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">pc_sli4_params</span><span class="p">.</span><span class="n">rqv</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">pc_sli4_params</span><span class="p">.</span><span class="n">rqv</span> <span class="o">==</span> <span class="n">LPFC_Q_CREATE_VERSION_1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">bf_set</span><span class="p">(</span><span class="n">lpfc_rq_context_rqe_count_1</span><span class="p">,</span>
		       <span class="o">&amp;</span><span class="n">rq_create</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">request</span><span class="p">.</span><span class="n">context</span><span class="p">,</span> <span class="n">hrq</span><span class="o">-&gt;</span><span class="n">entry_count</span><span class="p">);</span>
		<span class="n">rq_create</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">request</span><span class="p">.</span><span class="n">context</span><span class="p">.</span><span class="n">buffer_size</span> <span class="o">=</span> <span class="n">LPFC_DATA_BUF_SIZE</span><span class="p">;</span>
		<span class="n">bf_set</span><span class="p">(</span><span class="n">lpfc_rq_context_rqe_size</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rq_create</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">request</span><span class="p">.</span><span class="n">context</span><span class="p">,</span>
		       <span class="n">LPFC_RQE_SIZE_8</span><span class="p">);</span>
		<span class="n">bf_set</span><span class="p">(</span><span class="n">lpfc_rq_context_page_size</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rq_create</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">request</span><span class="p">.</span><span class="n">context</span><span class="p">,</span>
		       <span class="p">(</span><span class="n">PAGE_SIZE</span><span class="o">/</span><span class="n">SLI4_PAGE_SIZE</span><span class="p">));</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">drq</span><span class="o">-&gt;</span><span class="n">entry_count</span><span class="p">)</span> <span class="p">{</span>
		<span class="nl">default:</span>
			<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_SLI</span><span class="p">,</span>
					<span class="s">&quot;2536 Unsupported RQ count. (%d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">drq</span><span class="o">-&gt;</span><span class="n">entry_count</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">drq</span><span class="o">-&gt;</span><span class="n">entry_count</span> <span class="o">&lt;</span> <span class="mi">512</span><span class="p">)</span>
				<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
			<span class="cm">/* otherwise default to smallest count (drop through) */</span>
		<span class="k">case</span> <span class="mi">512</span>:
			<span class="n">bf_set</span><span class="p">(</span><span class="n">lpfc_rq_context_rqe_count</span><span class="p">,</span>
			       <span class="o">&amp;</span><span class="n">rq_create</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">request</span><span class="p">.</span><span class="n">context</span><span class="p">,</span>
			       <span class="n">LPFC_RQ_RING_SIZE_512</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="mi">1024</span>:
			<span class="n">bf_set</span><span class="p">(</span><span class="n">lpfc_rq_context_rqe_count</span><span class="p">,</span>
			       <span class="o">&amp;</span><span class="n">rq_create</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">request</span><span class="p">.</span><span class="n">context</span><span class="p">,</span>
			       <span class="n">LPFC_RQ_RING_SIZE_1024</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="mi">2048</span>:
			<span class="n">bf_set</span><span class="p">(</span><span class="n">lpfc_rq_context_rqe_count</span><span class="p">,</span>
			       <span class="o">&amp;</span><span class="n">rq_create</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">request</span><span class="p">.</span><span class="n">context</span><span class="p">,</span>
			       <span class="n">LPFC_RQ_RING_SIZE_2048</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="mi">4096</span>:
			<span class="n">bf_set</span><span class="p">(</span><span class="n">lpfc_rq_context_rqe_count</span><span class="p">,</span>
			       <span class="o">&amp;</span><span class="n">rq_create</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">request</span><span class="p">.</span><span class="n">context</span><span class="p">,</span>
			       <span class="n">LPFC_RQ_RING_SIZE_4096</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">bf_set</span><span class="p">(</span><span class="n">lpfc_rq_context_buf_size</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rq_create</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">request</span><span class="p">.</span><span class="n">context</span><span class="p">,</span>
		       <span class="n">LPFC_DATA_BUF_SIZE</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">bf_set</span><span class="p">(</span><span class="n">lpfc_rq_context_cq_id</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rq_create</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">request</span><span class="p">.</span><span class="n">context</span><span class="p">,</span>
	       <span class="n">cq</span><span class="o">-&gt;</span><span class="n">queue_id</span><span class="p">);</span>
	<span class="n">bf_set</span><span class="p">(</span><span class="n">lpfc_mbx_rq_create_num_pages</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rq_create</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">request</span><span class="p">,</span>
	       <span class="n">drq</span><span class="o">-&gt;</span><span class="n">page_count</span><span class="p">);</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">dmabuf</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">drq</span><span class="o">-&gt;</span><span class="n">page_list</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rq_create</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">request</span><span class="p">.</span><span class="n">page</span><span class="p">[</span><span class="n">dmabuf</span><span class="o">-&gt;</span><span class="n">buffer_tag</span><span class="p">].</span><span class="n">addr_lo</span> <span class="o">=</span>
					<span class="n">putPaddrLow</span><span class="p">(</span><span class="n">dmabuf</span><span class="o">-&gt;</span><span class="n">phys</span><span class="p">);</span>
		<span class="n">rq_create</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">request</span><span class="p">.</span><span class="n">page</span><span class="p">[</span><span class="n">dmabuf</span><span class="o">-&gt;</span><span class="n">buffer_tag</span><span class="p">].</span><span class="n">addr_hi</span> <span class="o">=</span>
					<span class="n">putPaddrHigh</span><span class="p">(</span><span class="n">dmabuf</span><span class="o">-&gt;</span><span class="n">phys</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">lpfc_sli_issue_mbox</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">mbox</span><span class="p">,</span> <span class="n">MBX_POLL</span><span class="p">);</span>
	<span class="cm">/* The IOCTL status is embedded in the mailbox subheader. */</span>
	<span class="n">shdr</span> <span class="o">=</span> <span class="p">(</span><span class="k">union</span> <span class="n">lpfc_sli4_cfg_shdr</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">rq_create</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">cfg_shdr</span><span class="p">;</span>
	<span class="n">shdr_status</span> <span class="o">=</span> <span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_mbox_hdr_status</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">shdr</span><span class="o">-&gt;</span><span class="n">response</span><span class="p">);</span>
	<span class="n">shdr_add_status</span> <span class="o">=</span> <span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_mbox_hdr_add_status</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">shdr</span><span class="o">-&gt;</span><span class="n">response</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">shdr_status</span> <span class="o">||</span> <span class="n">shdr_add_status</span> <span class="o">||</span> <span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENXIO</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">drq</span><span class="o">-&gt;</span><span class="n">queue_id</span> <span class="o">=</span> <span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_mbx_rq_create_q_id</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rq_create</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">response</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">drq</span><span class="o">-&gt;</span><span class="n">queue_id</span> <span class="o">==</span> <span class="mh">0xFFFF</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENXIO</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">drq</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">=</span> <span class="n">LPFC_DRQ</span><span class="p">;</span>
	<span class="n">drq</span><span class="o">-&gt;</span><span class="n">assoc_qid</span> <span class="o">=</span> <span class="n">cq</span><span class="o">-&gt;</span><span class="n">queue_id</span><span class="p">;</span>
	<span class="n">drq</span><span class="o">-&gt;</span><span class="n">subtype</span> <span class="o">=</span> <span class="n">subtype</span><span class="p">;</span>
	<span class="n">drq</span><span class="o">-&gt;</span><span class="n">host_index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">drq</span><span class="o">-&gt;</span><span class="n">hba_index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* link the header and data RQs onto the parent cq child list */</span>
	<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hrq</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cq</span><span class="o">-&gt;</span><span class="n">child_list</span><span class="p">);</span>
	<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">drq</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cq</span><span class="o">-&gt;</span><span class="n">child_list</span><span class="p">);</span>

<span class="nl">out:</span>
	<span class="n">mempool_free</span><span class="p">(</span><span class="n">mbox</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">mbox_mem_pool</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_eq_destroy - Destroy an event Queue on the HBA</span>
<span class="cm"> * @eq: The queue structure associated with the queue to destroy.</span>
<span class="cm"> *</span>
<span class="cm"> * This function destroys a queue, as detailed in @eq by sending an mailbox</span>
<span class="cm"> * command, specific to the type of queue, to the HBA.</span>
<span class="cm"> *</span>
<span class="cm"> * The @eq struct is used to get the queue ID of the queue to destroy.</span>
<span class="cm"> *</span>
<span class="cm"> * On success this function will return a zero. If the queue destroy mailbox</span>
<span class="cm"> * command fails this function will return -ENXIO.</span>
<span class="cm"> **/</span>
<span class="kt">uint32_t</span>
<span class="nf">lpfc_eq_destroy</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">,</span> <span class="k">struct</span> <span class="n">lpfc_queue</span> <span class="o">*</span><span class="n">eq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">LPFC_MBOXQ_t</span> <span class="o">*</span><span class="n">mbox</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">,</span> <span class="n">length</span><span class="p">,</span> <span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">shdr_status</span><span class="p">,</span> <span class="n">shdr_add_status</span><span class="p">;</span>
	<span class="k">union</span> <span class="n">lpfc_sli4_cfg_shdr</span> <span class="o">*</span><span class="n">shdr</span><span class="p">;</span>

	<span class="cm">/* sanity check on queue memory */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">eq</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
	<span class="n">mbox</span> <span class="o">=</span> <span class="n">mempool_alloc</span><span class="p">(</span><span class="n">eq</span><span class="o">-&gt;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">mbox_mem_pool</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mbox</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="n">length</span> <span class="o">=</span> <span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_mbx_eq_destroy</span><span class="p">)</span> <span class="o">-</span>
		  <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_sli4_cfg_mhdr</span><span class="p">));</span>
	<span class="n">lpfc_sli4_config</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">mbox</span><span class="p">,</span> <span class="n">LPFC_MBOX_SUBSYSTEM_COMMON</span><span class="p">,</span>
			 <span class="n">LPFC_MBOX_OPCODE_EQ_DESTROY</span><span class="p">,</span>
			 <span class="n">length</span><span class="p">,</span> <span class="n">LPFC_SLI4_MBX_EMBED</span><span class="p">);</span>
	<span class="n">bf_set</span><span class="p">(</span><span class="n">lpfc_mbx_eq_destroy_q_id</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mbox</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">mqe</span><span class="p">.</span><span class="n">un</span><span class="p">.</span><span class="n">eq_destroy</span><span class="p">.</span><span class="n">u</span><span class="p">.</span><span class="n">request</span><span class="p">,</span>
	       <span class="n">eq</span><span class="o">-&gt;</span><span class="n">queue_id</span><span class="p">);</span>
	<span class="n">mbox</span><span class="o">-&gt;</span><span class="n">vport</span> <span class="o">=</span> <span class="n">eq</span><span class="o">-&gt;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">pport</span><span class="p">;</span>
	<span class="n">mbox</span><span class="o">-&gt;</span><span class="n">mbox_cmpl</span> <span class="o">=</span> <span class="n">lpfc_sli_def_mbox_cmpl</span><span class="p">;</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">lpfc_sli_issue_mbox</span><span class="p">(</span><span class="n">eq</span><span class="o">-&gt;</span><span class="n">phba</span><span class="p">,</span> <span class="n">mbox</span><span class="p">,</span> <span class="n">MBX_POLL</span><span class="p">);</span>
	<span class="cm">/* The IOCTL status is embedded in the mailbox subheader. */</span>
	<span class="n">shdr</span> <span class="o">=</span> <span class="p">(</span><span class="k">union</span> <span class="n">lpfc_sli4_cfg_shdr</span> <span class="o">*</span><span class="p">)</span>
		<span class="o">&amp;</span><span class="n">mbox</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">mqe</span><span class="p">.</span><span class="n">un</span><span class="p">.</span><span class="n">eq_destroy</span><span class="p">.</span><span class="n">header</span><span class="p">.</span><span class="n">cfg_shdr</span><span class="p">;</span>
	<span class="n">shdr_status</span> <span class="o">=</span> <span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_mbox_hdr_status</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">shdr</span><span class="o">-&gt;</span><span class="n">response</span><span class="p">);</span>
	<span class="n">shdr_add_status</span> <span class="o">=</span> <span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_mbox_hdr_add_status</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">shdr</span><span class="o">-&gt;</span><span class="n">response</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">shdr_status</span> <span class="o">||</span> <span class="n">shdr_add_status</span> <span class="o">||</span> <span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_INIT</span><span class="p">,</span>
				<span class="s">&quot;2505 EQ_DESTROY mailbox failed with &quot;</span>
				<span class="s">&quot;status x%x add_status x%x, mbx status x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">shdr_status</span><span class="p">,</span> <span class="n">shdr_add_status</span><span class="p">,</span> <span class="n">rc</span><span class="p">);</span>
		<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENXIO</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Remove eq from any list */</span>
	<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">eq</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
	<span class="n">mempool_free</span><span class="p">(</span><span class="n">mbox</span><span class="p">,</span> <span class="n">eq</span><span class="o">-&gt;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">mbox_mem_pool</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_cq_destroy - Destroy a Completion Queue on the HBA</span>
<span class="cm"> * @cq: The queue structure associated with the queue to destroy.</span>
<span class="cm"> *</span>
<span class="cm"> * This function destroys a queue, as detailed in @cq by sending an mailbox</span>
<span class="cm"> * command, specific to the type of queue, to the HBA.</span>
<span class="cm"> *</span>
<span class="cm"> * The @cq struct is used to get the queue ID of the queue to destroy.</span>
<span class="cm"> *</span>
<span class="cm"> * On success this function will return a zero. If the queue destroy mailbox</span>
<span class="cm"> * command fails this function will return -ENXIO.</span>
<span class="cm"> **/</span>
<span class="kt">uint32_t</span>
<span class="nf">lpfc_cq_destroy</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">,</span> <span class="k">struct</span> <span class="n">lpfc_queue</span> <span class="o">*</span><span class="n">cq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">LPFC_MBOXQ_t</span> <span class="o">*</span><span class="n">mbox</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">,</span> <span class="n">length</span><span class="p">,</span> <span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">shdr_status</span><span class="p">,</span> <span class="n">shdr_add_status</span><span class="p">;</span>
	<span class="k">union</span> <span class="n">lpfc_sli4_cfg_shdr</span> <span class="o">*</span><span class="n">shdr</span><span class="p">;</span>

	<span class="cm">/* sanity check on queue memory */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cq</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
	<span class="n">mbox</span> <span class="o">=</span> <span class="n">mempool_alloc</span><span class="p">(</span><span class="n">cq</span><span class="o">-&gt;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">mbox_mem_pool</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mbox</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="n">length</span> <span class="o">=</span> <span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_mbx_cq_destroy</span><span class="p">)</span> <span class="o">-</span>
		  <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_sli4_cfg_mhdr</span><span class="p">));</span>
	<span class="n">lpfc_sli4_config</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">mbox</span><span class="p">,</span> <span class="n">LPFC_MBOX_SUBSYSTEM_COMMON</span><span class="p">,</span>
			 <span class="n">LPFC_MBOX_OPCODE_CQ_DESTROY</span><span class="p">,</span>
			 <span class="n">length</span><span class="p">,</span> <span class="n">LPFC_SLI4_MBX_EMBED</span><span class="p">);</span>
	<span class="n">bf_set</span><span class="p">(</span><span class="n">lpfc_mbx_cq_destroy_q_id</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mbox</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">mqe</span><span class="p">.</span><span class="n">un</span><span class="p">.</span><span class="n">cq_destroy</span><span class="p">.</span><span class="n">u</span><span class="p">.</span><span class="n">request</span><span class="p">,</span>
	       <span class="n">cq</span><span class="o">-&gt;</span><span class="n">queue_id</span><span class="p">);</span>
	<span class="n">mbox</span><span class="o">-&gt;</span><span class="n">vport</span> <span class="o">=</span> <span class="n">cq</span><span class="o">-&gt;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">pport</span><span class="p">;</span>
	<span class="n">mbox</span><span class="o">-&gt;</span><span class="n">mbox_cmpl</span> <span class="o">=</span> <span class="n">lpfc_sli_def_mbox_cmpl</span><span class="p">;</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">lpfc_sli_issue_mbox</span><span class="p">(</span><span class="n">cq</span><span class="o">-&gt;</span><span class="n">phba</span><span class="p">,</span> <span class="n">mbox</span><span class="p">,</span> <span class="n">MBX_POLL</span><span class="p">);</span>
	<span class="cm">/* The IOCTL status is embedded in the mailbox subheader. */</span>
	<span class="n">shdr</span> <span class="o">=</span> <span class="p">(</span><span class="k">union</span> <span class="n">lpfc_sli4_cfg_shdr</span> <span class="o">*</span><span class="p">)</span>
		<span class="o">&amp;</span><span class="n">mbox</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">mqe</span><span class="p">.</span><span class="n">un</span><span class="p">.</span><span class="n">wq_create</span><span class="p">.</span><span class="n">header</span><span class="p">.</span><span class="n">cfg_shdr</span><span class="p">;</span>
	<span class="n">shdr_status</span> <span class="o">=</span> <span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_mbox_hdr_status</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">shdr</span><span class="o">-&gt;</span><span class="n">response</span><span class="p">);</span>
	<span class="n">shdr_add_status</span> <span class="o">=</span> <span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_mbox_hdr_add_status</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">shdr</span><span class="o">-&gt;</span><span class="n">response</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">shdr_status</span> <span class="o">||</span> <span class="n">shdr_add_status</span> <span class="o">||</span> <span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_INIT</span><span class="p">,</span>
				<span class="s">&quot;2506 CQ_DESTROY mailbox failed with &quot;</span>
				<span class="s">&quot;status x%x add_status x%x, mbx status x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">shdr_status</span><span class="p">,</span> <span class="n">shdr_add_status</span><span class="p">,</span> <span class="n">rc</span><span class="p">);</span>
		<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENXIO</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* Remove cq from any list */</span>
	<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cq</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
	<span class="n">mempool_free</span><span class="p">(</span><span class="n">mbox</span><span class="p">,</span> <span class="n">cq</span><span class="o">-&gt;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">mbox_mem_pool</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_mq_destroy - Destroy a Mailbox Queue on the HBA</span>
<span class="cm"> * @qm: The queue structure associated with the queue to destroy.</span>
<span class="cm"> *</span>
<span class="cm"> * This function destroys a queue, as detailed in @mq by sending an mailbox</span>
<span class="cm"> * command, specific to the type of queue, to the HBA.</span>
<span class="cm"> *</span>
<span class="cm"> * The @mq struct is used to get the queue ID of the queue to destroy.</span>
<span class="cm"> *</span>
<span class="cm"> * On success this function will return a zero. If the queue destroy mailbox</span>
<span class="cm"> * command fails this function will return -ENXIO.</span>
<span class="cm"> **/</span>
<span class="kt">uint32_t</span>
<span class="nf">lpfc_mq_destroy</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">,</span> <span class="k">struct</span> <span class="n">lpfc_queue</span> <span class="o">*</span><span class="n">mq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">LPFC_MBOXQ_t</span> <span class="o">*</span><span class="n">mbox</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">,</span> <span class="n">length</span><span class="p">,</span> <span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">shdr_status</span><span class="p">,</span> <span class="n">shdr_add_status</span><span class="p">;</span>
	<span class="k">union</span> <span class="n">lpfc_sli4_cfg_shdr</span> <span class="o">*</span><span class="n">shdr</span><span class="p">;</span>

	<span class="cm">/* sanity check on queue memory */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mq</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
	<span class="n">mbox</span> <span class="o">=</span> <span class="n">mempool_alloc</span><span class="p">(</span><span class="n">mq</span><span class="o">-&gt;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">mbox_mem_pool</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mbox</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="n">length</span> <span class="o">=</span> <span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_mbx_mq_destroy</span><span class="p">)</span> <span class="o">-</span>
		  <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_sli4_cfg_mhdr</span><span class="p">));</span>
	<span class="n">lpfc_sli4_config</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">mbox</span><span class="p">,</span> <span class="n">LPFC_MBOX_SUBSYSTEM_COMMON</span><span class="p">,</span>
			 <span class="n">LPFC_MBOX_OPCODE_MQ_DESTROY</span><span class="p">,</span>
			 <span class="n">length</span><span class="p">,</span> <span class="n">LPFC_SLI4_MBX_EMBED</span><span class="p">);</span>
	<span class="n">bf_set</span><span class="p">(</span><span class="n">lpfc_mbx_mq_destroy_q_id</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mbox</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">mqe</span><span class="p">.</span><span class="n">un</span><span class="p">.</span><span class="n">mq_destroy</span><span class="p">.</span><span class="n">u</span><span class="p">.</span><span class="n">request</span><span class="p">,</span>
	       <span class="n">mq</span><span class="o">-&gt;</span><span class="n">queue_id</span><span class="p">);</span>
	<span class="n">mbox</span><span class="o">-&gt;</span><span class="n">vport</span> <span class="o">=</span> <span class="n">mq</span><span class="o">-&gt;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">pport</span><span class="p">;</span>
	<span class="n">mbox</span><span class="o">-&gt;</span><span class="n">mbox_cmpl</span> <span class="o">=</span> <span class="n">lpfc_sli_def_mbox_cmpl</span><span class="p">;</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">lpfc_sli_issue_mbox</span><span class="p">(</span><span class="n">mq</span><span class="o">-&gt;</span><span class="n">phba</span><span class="p">,</span> <span class="n">mbox</span><span class="p">,</span> <span class="n">MBX_POLL</span><span class="p">);</span>
	<span class="cm">/* The IOCTL status is embedded in the mailbox subheader. */</span>
	<span class="n">shdr</span> <span class="o">=</span> <span class="p">(</span><span class="k">union</span> <span class="n">lpfc_sli4_cfg_shdr</span> <span class="o">*</span><span class="p">)</span>
		<span class="o">&amp;</span><span class="n">mbox</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">mqe</span><span class="p">.</span><span class="n">un</span><span class="p">.</span><span class="n">mq_destroy</span><span class="p">.</span><span class="n">header</span><span class="p">.</span><span class="n">cfg_shdr</span><span class="p">;</span>
	<span class="n">shdr_status</span> <span class="o">=</span> <span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_mbox_hdr_status</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">shdr</span><span class="o">-&gt;</span><span class="n">response</span><span class="p">);</span>
	<span class="n">shdr_add_status</span> <span class="o">=</span> <span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_mbox_hdr_add_status</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">shdr</span><span class="o">-&gt;</span><span class="n">response</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">shdr_status</span> <span class="o">||</span> <span class="n">shdr_add_status</span> <span class="o">||</span> <span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_INIT</span><span class="p">,</span>
				<span class="s">&quot;2507 MQ_DESTROY mailbox failed with &quot;</span>
				<span class="s">&quot;status x%x add_status x%x, mbx status x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">shdr_status</span><span class="p">,</span> <span class="n">shdr_add_status</span><span class="p">,</span> <span class="n">rc</span><span class="p">);</span>
		<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENXIO</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* Remove mq from any list */</span>
	<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mq</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
	<span class="n">mempool_free</span><span class="p">(</span><span class="n">mbox</span><span class="p">,</span> <span class="n">mq</span><span class="o">-&gt;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">mbox_mem_pool</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_wq_destroy - Destroy a Work Queue on the HBA</span>
<span class="cm"> * @wq: The queue structure associated with the queue to destroy.</span>
<span class="cm"> *</span>
<span class="cm"> * This function destroys a queue, as detailed in @wq by sending an mailbox</span>
<span class="cm"> * command, specific to the type of queue, to the HBA.</span>
<span class="cm"> *</span>
<span class="cm"> * The @wq struct is used to get the queue ID of the queue to destroy.</span>
<span class="cm"> *</span>
<span class="cm"> * On success this function will return a zero. If the queue destroy mailbox</span>
<span class="cm"> * command fails this function will return -ENXIO.</span>
<span class="cm"> **/</span>
<span class="kt">uint32_t</span>
<span class="nf">lpfc_wq_destroy</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">,</span> <span class="k">struct</span> <span class="n">lpfc_queue</span> <span class="o">*</span><span class="n">wq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">LPFC_MBOXQ_t</span> <span class="o">*</span><span class="n">mbox</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">,</span> <span class="n">length</span><span class="p">,</span> <span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">shdr_status</span><span class="p">,</span> <span class="n">shdr_add_status</span><span class="p">;</span>
	<span class="k">union</span> <span class="n">lpfc_sli4_cfg_shdr</span> <span class="o">*</span><span class="n">shdr</span><span class="p">;</span>

	<span class="cm">/* sanity check on queue memory */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">wq</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
	<span class="n">mbox</span> <span class="o">=</span> <span class="n">mempool_alloc</span><span class="p">(</span><span class="n">wq</span><span class="o">-&gt;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">mbox_mem_pool</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mbox</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="n">length</span> <span class="o">=</span> <span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_mbx_wq_destroy</span><span class="p">)</span> <span class="o">-</span>
		  <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_sli4_cfg_mhdr</span><span class="p">));</span>
	<span class="n">lpfc_sli4_config</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">mbox</span><span class="p">,</span> <span class="n">LPFC_MBOX_SUBSYSTEM_FCOE</span><span class="p">,</span>
			 <span class="n">LPFC_MBOX_OPCODE_FCOE_WQ_DESTROY</span><span class="p">,</span>
			 <span class="n">length</span><span class="p">,</span> <span class="n">LPFC_SLI4_MBX_EMBED</span><span class="p">);</span>
	<span class="n">bf_set</span><span class="p">(</span><span class="n">lpfc_mbx_wq_destroy_q_id</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mbox</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">mqe</span><span class="p">.</span><span class="n">un</span><span class="p">.</span><span class="n">wq_destroy</span><span class="p">.</span><span class="n">u</span><span class="p">.</span><span class="n">request</span><span class="p">,</span>
	       <span class="n">wq</span><span class="o">-&gt;</span><span class="n">queue_id</span><span class="p">);</span>
	<span class="n">mbox</span><span class="o">-&gt;</span><span class="n">vport</span> <span class="o">=</span> <span class="n">wq</span><span class="o">-&gt;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">pport</span><span class="p">;</span>
	<span class="n">mbox</span><span class="o">-&gt;</span><span class="n">mbox_cmpl</span> <span class="o">=</span> <span class="n">lpfc_sli_def_mbox_cmpl</span><span class="p">;</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">lpfc_sli_issue_mbox</span><span class="p">(</span><span class="n">wq</span><span class="o">-&gt;</span><span class="n">phba</span><span class="p">,</span> <span class="n">mbox</span><span class="p">,</span> <span class="n">MBX_POLL</span><span class="p">);</span>
	<span class="n">shdr</span> <span class="o">=</span> <span class="p">(</span><span class="k">union</span> <span class="n">lpfc_sli4_cfg_shdr</span> <span class="o">*</span><span class="p">)</span>
		<span class="o">&amp;</span><span class="n">mbox</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">mqe</span><span class="p">.</span><span class="n">un</span><span class="p">.</span><span class="n">wq_destroy</span><span class="p">.</span><span class="n">header</span><span class="p">.</span><span class="n">cfg_shdr</span><span class="p">;</span>
	<span class="n">shdr_status</span> <span class="o">=</span> <span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_mbox_hdr_status</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">shdr</span><span class="o">-&gt;</span><span class="n">response</span><span class="p">);</span>
	<span class="n">shdr_add_status</span> <span class="o">=</span> <span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_mbox_hdr_add_status</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">shdr</span><span class="o">-&gt;</span><span class="n">response</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">shdr_status</span> <span class="o">||</span> <span class="n">shdr_add_status</span> <span class="o">||</span> <span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_INIT</span><span class="p">,</span>
				<span class="s">&quot;2508 WQ_DESTROY mailbox failed with &quot;</span>
				<span class="s">&quot;status x%x add_status x%x, mbx status x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">shdr_status</span><span class="p">,</span> <span class="n">shdr_add_status</span><span class="p">,</span> <span class="n">rc</span><span class="p">);</span>
		<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENXIO</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* Remove wq from any list */</span>
	<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wq</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
	<span class="n">mempool_free</span><span class="p">(</span><span class="n">mbox</span><span class="p">,</span> <span class="n">wq</span><span class="o">-&gt;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">mbox_mem_pool</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_rq_destroy - Destroy a Receive Queue on the HBA</span>
<span class="cm"> * @rq: The queue structure associated with the queue to destroy.</span>
<span class="cm"> *</span>
<span class="cm"> * This function destroys a queue, as detailed in @rq by sending an mailbox</span>
<span class="cm"> * command, specific to the type of queue, to the HBA.</span>
<span class="cm"> *</span>
<span class="cm"> * The @rq struct is used to get the queue ID of the queue to destroy.</span>
<span class="cm"> *</span>
<span class="cm"> * On success this function will return a zero. If the queue destroy mailbox</span>
<span class="cm"> * command fails this function will return -ENXIO.</span>
<span class="cm"> **/</span>
<span class="kt">uint32_t</span>
<span class="nf">lpfc_rq_destroy</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">,</span> <span class="k">struct</span> <span class="n">lpfc_queue</span> <span class="o">*</span><span class="n">hrq</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">lpfc_queue</span> <span class="o">*</span><span class="n">drq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">LPFC_MBOXQ_t</span> <span class="o">*</span><span class="n">mbox</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">,</span> <span class="n">length</span><span class="p">,</span> <span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">shdr_status</span><span class="p">,</span> <span class="n">shdr_add_status</span><span class="p">;</span>
	<span class="k">union</span> <span class="n">lpfc_sli4_cfg_shdr</span> <span class="o">*</span><span class="n">shdr</span><span class="p">;</span>

	<span class="cm">/* sanity check on queue memory */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hrq</span> <span class="o">||</span> <span class="o">!</span><span class="n">drq</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
	<span class="n">mbox</span> <span class="o">=</span> <span class="n">mempool_alloc</span><span class="p">(</span><span class="n">hrq</span><span class="o">-&gt;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">mbox_mem_pool</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mbox</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="n">length</span> <span class="o">=</span> <span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_mbx_rq_destroy</span><span class="p">)</span> <span class="o">-</span>
		  <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_sli4_cfg_mhdr</span><span class="p">));</span>
	<span class="n">lpfc_sli4_config</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">mbox</span><span class="p">,</span> <span class="n">LPFC_MBOX_SUBSYSTEM_FCOE</span><span class="p">,</span>
			 <span class="n">LPFC_MBOX_OPCODE_FCOE_RQ_DESTROY</span><span class="p">,</span>
			 <span class="n">length</span><span class="p">,</span> <span class="n">LPFC_SLI4_MBX_EMBED</span><span class="p">);</span>
	<span class="n">bf_set</span><span class="p">(</span><span class="n">lpfc_mbx_rq_destroy_q_id</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mbox</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">mqe</span><span class="p">.</span><span class="n">un</span><span class="p">.</span><span class="n">rq_destroy</span><span class="p">.</span><span class="n">u</span><span class="p">.</span><span class="n">request</span><span class="p">,</span>
	       <span class="n">hrq</span><span class="o">-&gt;</span><span class="n">queue_id</span><span class="p">);</span>
	<span class="n">mbox</span><span class="o">-&gt;</span><span class="n">vport</span> <span class="o">=</span> <span class="n">hrq</span><span class="o">-&gt;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">pport</span><span class="p">;</span>
	<span class="n">mbox</span><span class="o">-&gt;</span><span class="n">mbox_cmpl</span> <span class="o">=</span> <span class="n">lpfc_sli_def_mbox_cmpl</span><span class="p">;</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">lpfc_sli_issue_mbox</span><span class="p">(</span><span class="n">hrq</span><span class="o">-&gt;</span><span class="n">phba</span><span class="p">,</span> <span class="n">mbox</span><span class="p">,</span> <span class="n">MBX_POLL</span><span class="p">);</span>
	<span class="cm">/* The IOCTL status is embedded in the mailbox subheader. */</span>
	<span class="n">shdr</span> <span class="o">=</span> <span class="p">(</span><span class="k">union</span> <span class="n">lpfc_sli4_cfg_shdr</span> <span class="o">*</span><span class="p">)</span>
		<span class="o">&amp;</span><span class="n">mbox</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">mqe</span><span class="p">.</span><span class="n">un</span><span class="p">.</span><span class="n">rq_destroy</span><span class="p">.</span><span class="n">header</span><span class="p">.</span><span class="n">cfg_shdr</span><span class="p">;</span>
	<span class="n">shdr_status</span> <span class="o">=</span> <span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_mbox_hdr_status</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">shdr</span><span class="o">-&gt;</span><span class="n">response</span><span class="p">);</span>
	<span class="n">shdr_add_status</span> <span class="o">=</span> <span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_mbox_hdr_add_status</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">shdr</span><span class="o">-&gt;</span><span class="n">response</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">shdr_status</span> <span class="o">||</span> <span class="n">shdr_add_status</span> <span class="o">||</span> <span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_INIT</span><span class="p">,</span>
				<span class="s">&quot;2509 RQ_DESTROY mailbox failed with &quot;</span>
				<span class="s">&quot;status x%x add_status x%x, mbx status x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">shdr_status</span><span class="p">,</span> <span class="n">shdr_add_status</span><span class="p">,</span> <span class="n">rc</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">!=</span> <span class="n">MBX_TIMEOUT</span><span class="p">)</span>
			<span class="n">mempool_free</span><span class="p">(</span><span class="n">mbox</span><span class="p">,</span> <span class="n">hrq</span><span class="o">-&gt;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">mbox_mem_pool</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENXIO</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">bf_set</span><span class="p">(</span><span class="n">lpfc_mbx_rq_destroy_q_id</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mbox</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">mqe</span><span class="p">.</span><span class="n">un</span><span class="p">.</span><span class="n">rq_destroy</span><span class="p">.</span><span class="n">u</span><span class="p">.</span><span class="n">request</span><span class="p">,</span>
	       <span class="n">drq</span><span class="o">-&gt;</span><span class="n">queue_id</span><span class="p">);</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">lpfc_sli_issue_mbox</span><span class="p">(</span><span class="n">drq</span><span class="o">-&gt;</span><span class="n">phba</span><span class="p">,</span> <span class="n">mbox</span><span class="p">,</span> <span class="n">MBX_POLL</span><span class="p">);</span>
	<span class="n">shdr</span> <span class="o">=</span> <span class="p">(</span><span class="k">union</span> <span class="n">lpfc_sli4_cfg_shdr</span> <span class="o">*</span><span class="p">)</span>
		<span class="o">&amp;</span><span class="n">mbox</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">mqe</span><span class="p">.</span><span class="n">un</span><span class="p">.</span><span class="n">rq_destroy</span><span class="p">.</span><span class="n">header</span><span class="p">.</span><span class="n">cfg_shdr</span><span class="p">;</span>
	<span class="n">shdr_status</span> <span class="o">=</span> <span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_mbox_hdr_status</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">shdr</span><span class="o">-&gt;</span><span class="n">response</span><span class="p">);</span>
	<span class="n">shdr_add_status</span> <span class="o">=</span> <span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_mbox_hdr_add_status</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">shdr</span><span class="o">-&gt;</span><span class="n">response</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">shdr_status</span> <span class="o">||</span> <span class="n">shdr_add_status</span> <span class="o">||</span> <span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_INIT</span><span class="p">,</span>
				<span class="s">&quot;2510 RQ_DESTROY mailbox failed with &quot;</span>
				<span class="s">&quot;status x%x add_status x%x, mbx status x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">shdr_status</span><span class="p">,</span> <span class="n">shdr_add_status</span><span class="p">,</span> <span class="n">rc</span><span class="p">);</span>
		<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENXIO</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hrq</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
	<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">drq</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
	<span class="n">mempool_free</span><span class="p">(</span><span class="n">mbox</span><span class="p">,</span> <span class="n">hrq</span><span class="o">-&gt;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">mbox_mem_pool</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_sli4_post_sgl - Post scatter gather list for an XRI to HBA</span>
<span class="cm"> * @phba: The virtual port for which this call being executed.</span>
<span class="cm"> * @pdma_phys_addr0: Physical address of the 1st SGL page.</span>
<span class="cm"> * @pdma_phys_addr1: Physical address of the 2nd SGL page.</span>
<span class="cm"> * @xritag: the xritag that ties this io to the SGL pages.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine will post the sgl pages for the IO that has the xritag</span>
<span class="cm"> * that is in the iocbq structure. The xritag is assigned during iocbq</span>
<span class="cm"> * creation and persists for as long as the driver is loaded.</span>
<span class="cm"> * if the caller has fewer than 256 scatter gather segments to map then</span>
<span class="cm"> * pdma_phys_addr1 should be 0.</span>
<span class="cm"> * If the caller needs to map more than 256 scatter gather segment then</span>
<span class="cm"> * pdma_phys_addr1 should be a valid physical address.</span>
<span class="cm"> * physical address for SGLs must be 64 byte aligned.</span>
<span class="cm"> * If you are going to map 2 SGL&#39;s then the first one must have 256 entries</span>
<span class="cm"> * the second sgl can have between 1 and 256 entries.</span>
<span class="cm"> *</span>
<span class="cm"> * Return codes:</span>
<span class="cm"> * 	0 - Success</span>
<span class="cm"> * 	-ENXIO, -ENOMEM - Failure</span>
<span class="cm"> **/</span>
<span class="kt">int</span>
<span class="nf">lpfc_sli4_post_sgl</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">,</span>
		<span class="n">dma_addr_t</span> <span class="n">pdma_phys_addr0</span><span class="p">,</span>
		<span class="n">dma_addr_t</span> <span class="n">pdma_phys_addr1</span><span class="p">,</span>
		<span class="kt">uint16_t</span> <span class="n">xritag</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpfc_mbx_post_sgl_pages</span> <span class="o">*</span><span class="n">post_sgl_pages</span><span class="p">;</span>
	<span class="n">LPFC_MBOXQ_t</span> <span class="o">*</span><span class="n">mbox</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">shdr_status</span><span class="p">,</span> <span class="n">shdr_add_status</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">mbox_tmo</span><span class="p">;</span>
	<span class="k">union</span> <span class="n">lpfc_sli4_cfg_shdr</span> <span class="o">*</span><span class="n">shdr</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">xritag</span> <span class="o">==</span> <span class="n">NO_XRI</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_SLI</span><span class="p">,</span>
				<span class="s">&quot;0364 Invalid param:</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">mbox</span> <span class="o">=</span> <span class="n">mempool_alloc</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">mbox_mem_pool</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mbox</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">lpfc_sli4_config</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">mbox</span><span class="p">,</span> <span class="n">LPFC_MBOX_SUBSYSTEM_FCOE</span><span class="p">,</span>
			<span class="n">LPFC_MBOX_OPCODE_FCOE_POST_SGL_PAGES</span><span class="p">,</span>
			<span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_mbx_post_sgl_pages</span><span class="p">)</span> <span class="o">-</span>
			<span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_sli4_cfg_mhdr</span><span class="p">),</span> <span class="n">LPFC_SLI4_MBX_EMBED</span><span class="p">);</span>

	<span class="n">post_sgl_pages</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_mbx_post_sgl_pages</span> <span class="o">*</span><span class="p">)</span>
				<span class="o">&amp;</span><span class="n">mbox</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">mqe</span><span class="p">.</span><span class="n">un</span><span class="p">.</span><span class="n">post_sgl_pages</span><span class="p">;</span>
	<span class="n">bf_set</span><span class="p">(</span><span class="n">lpfc_post_sgl_pages_xri</span><span class="p">,</span> <span class="n">post_sgl_pages</span><span class="p">,</span> <span class="n">xritag</span><span class="p">);</span>
	<span class="n">bf_set</span><span class="p">(</span><span class="n">lpfc_post_sgl_pages_xricnt</span><span class="p">,</span> <span class="n">post_sgl_pages</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

	<span class="n">post_sgl_pages</span><span class="o">-&gt;</span><span class="n">sgl_pg_pairs</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">sgl_pg0_addr_lo</span>	<span class="o">=</span>
				<span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">putPaddrLow</span><span class="p">(</span><span class="n">pdma_phys_addr0</span><span class="p">));</span>
	<span class="n">post_sgl_pages</span><span class="o">-&gt;</span><span class="n">sgl_pg_pairs</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">sgl_pg0_addr_hi</span> <span class="o">=</span>
				<span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">putPaddrHigh</span><span class="p">(</span><span class="n">pdma_phys_addr0</span><span class="p">));</span>

	<span class="n">post_sgl_pages</span><span class="o">-&gt;</span><span class="n">sgl_pg_pairs</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">sgl_pg1_addr_lo</span>	<span class="o">=</span>
				<span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">putPaddrLow</span><span class="p">(</span><span class="n">pdma_phys_addr1</span><span class="p">));</span>
	<span class="n">post_sgl_pages</span><span class="o">-&gt;</span><span class="n">sgl_pg_pairs</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">sgl_pg1_addr_hi</span> <span class="o">=</span>
				<span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">putPaddrHigh</span><span class="p">(</span><span class="n">pdma_phys_addr1</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">intr_enable</span><span class="p">)</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">lpfc_sli_issue_mbox</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">mbox</span><span class="p">,</span> <span class="n">MBX_POLL</span><span class="p">);</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="n">mbox_tmo</span> <span class="o">=</span> <span class="n">lpfc_mbox_tmo_val</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">mbox</span><span class="p">);</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">lpfc_sli_issue_mbox_wait</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">mbox</span><span class="p">,</span> <span class="n">mbox_tmo</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="cm">/* The IOCTL status is embedded in the mailbox subheader. */</span>
	<span class="n">shdr</span> <span class="o">=</span> <span class="p">(</span><span class="k">union</span> <span class="n">lpfc_sli4_cfg_shdr</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">post_sgl_pages</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">cfg_shdr</span><span class="p">;</span>
	<span class="n">shdr_status</span> <span class="o">=</span> <span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_mbox_hdr_status</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">shdr</span><span class="o">-&gt;</span><span class="n">response</span><span class="p">);</span>
	<span class="n">shdr_add_status</span> <span class="o">=</span> <span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_mbox_hdr_add_status</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">shdr</span><span class="o">-&gt;</span><span class="n">response</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">!=</span> <span class="n">MBX_TIMEOUT</span><span class="p">)</span>
		<span class="n">mempool_free</span><span class="p">(</span><span class="n">mbox</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">mbox_mem_pool</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">shdr_status</span> <span class="o">||</span> <span class="n">shdr_add_status</span> <span class="o">||</span> <span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_INIT</span><span class="p">,</span>
				<span class="s">&quot;2511 POST_SGL mailbox failed with &quot;</span>
				<span class="s">&quot;status x%x add_status x%x, mbx status x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">shdr_status</span><span class="p">,</span> <span class="n">shdr_add_status</span><span class="p">,</span> <span class="n">rc</span><span class="p">);</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENXIO</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_sli4_alloc_xri - Get an available rpi in the device&#39;s range</span>
<span class="cm"> * @phba: pointer to lpfc hba data structure.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine is invoked to post rpi header templates to the</span>
<span class="cm"> * HBA consistent with the SLI-4 interface spec.  This routine</span>
<span class="cm"> * posts a SLI4_PAGE_SIZE memory region to the port to hold up to</span>
<span class="cm"> * SLI4_PAGE_SIZE modulo 64 rpi context headers.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns</span>
<span class="cm"> *	A nonzero rpi defined as rpi_base &lt;= rpi &lt; max_rpi if successful</span>
<span class="cm"> *	LPFC_RPI_ALLOC_ERROR if no rpis are available.</span>
<span class="cm"> **/</span>
<span class="kt">uint16_t</span>
<span class="nf">lpfc_sli4_alloc_xri</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">xri</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Fetch the next logical xri.  Because this index is logical,</span>
<span class="cm">	 * the driver starts at 0 each time.</span>
<span class="cm">	 */</span>
	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>
	<span class="n">xri</span> <span class="o">=</span> <span class="n">find_next_zero_bit</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">xri_bmask</span><span class="p">,</span>
				 <span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">max_cfg_param</span><span class="p">.</span><span class="n">max_xri</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">xri</span> <span class="o">&gt;=</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">max_cfg_param</span><span class="p">.</span><span class="n">max_xri</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">NO_XRI</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">set_bit</span><span class="p">(</span><span class="n">xri</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">xri_bmask</span><span class="p">);</span>
		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">max_cfg_param</span><span class="p">.</span><span class="n">xri_used</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">xri</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_sli4_free_xri - Release an xri for reuse.</span>
<span class="cm"> * @phba: pointer to lpfc hba data structure.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine is invoked to release an xri to the pool of</span>
<span class="cm"> * available rpis maintained by the driver.</span>
<span class="cm"> **/</span>
<span class="kt">void</span>
<span class="nf">__lpfc_sli4_free_xri</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">,</span> <span class="kt">int</span> <span class="n">xri</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">test_and_clear_bit</span><span class="p">(</span><span class="n">xri</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">xri_bmask</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">max_cfg_param</span><span class="p">.</span><span class="n">xri_used</span><span class="o">--</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_sli4_free_xri - Release an xri for reuse.</span>
<span class="cm"> * @phba: pointer to lpfc hba data structure.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine is invoked to release an xri to the pool of</span>
<span class="cm"> * available rpis maintained by the driver.</span>
<span class="cm"> **/</span>
<span class="kt">void</span>
<span class="nf">lpfc_sli4_free_xri</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">,</span> <span class="kt">int</span> <span class="n">xri</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>
	<span class="n">__lpfc_sli4_free_xri</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">xri</span><span class="p">);</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_sli4_next_xritag - Get an xritag for the io</span>
<span class="cm"> * @phba: Pointer to HBA context object.</span>
<span class="cm"> *</span>
<span class="cm"> * This function gets an xritag for the iocb. If there is no unused xritag</span>
<span class="cm"> * it will return 0xffff.</span>
<span class="cm"> * The function returns the allocated xritag if successful, else returns zero.</span>
<span class="cm"> * Zero is not a valid xritag.</span>
<span class="cm"> * The caller is not required to hold any lock.</span>
<span class="cm"> **/</span>
<span class="kt">uint16_t</span>
<span class="nf">lpfc_sli4_next_xritag</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">uint16_t</span> <span class="n">xri_index</span><span class="p">;</span>

	<span class="n">xri_index</span> <span class="o">=</span> <span class="n">lpfc_sli4_alloc_xri</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">xri_index</span> <span class="o">==</span> <span class="n">NO_XRI</span><span class="p">)</span>
		<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_WARNING</span><span class="p">,</span> <span class="n">LOG_SLI</span><span class="p">,</span>
				<span class="s">&quot;2004 Failed to allocate XRI.last XRITAG is %d&quot;</span>
				<span class="s">&quot; Max XRI is %d, Used XRI is %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">xri_index</span><span class="p">,</span>
				<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">max_cfg_param</span><span class="p">.</span><span class="n">max_xri</span><span class="p">,</span>
				<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">max_cfg_param</span><span class="p">.</span><span class="n">xri_used</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">xri_index</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_sli4_post_els_sgl_list - post a block of ELS sgls to the port.</span>
<span class="cm"> * @phba: pointer to lpfc hba data structure.</span>
<span class="cm"> * @post_sgl_list: pointer to els sgl entry list.</span>
<span class="cm"> * @count: number of els sgl entries on the list.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine is invoked to post a block of driver&#39;s sgl pages to the</span>
<span class="cm"> * HBA using non-embedded mailbox command. No Lock is held. This routine</span>
<span class="cm"> * is only called when the driver is loading and after all IO has been</span>
<span class="cm"> * stopped.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">lpfc_sli4_post_els_sgl_list</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">,</span>
			    <span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">post_sgl_list</span><span class="p">,</span>
			    <span class="kt">int</span> <span class="n">post_cnt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpfc_sglq</span> <span class="o">*</span><span class="n">sglq_entry</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">*</span><span class="n">sglq_next</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_mbx_post_uembed_sgl_page1</span> <span class="o">*</span><span class="n">sgl</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sgl_page_pairs</span> <span class="o">*</span><span class="n">sgl_pg_pairs</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">viraddr</span><span class="p">;</span>
	<span class="n">LPFC_MBOXQ_t</span> <span class="o">*</span><span class="n">mbox</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">reqlen</span><span class="p">,</span> <span class="n">alloclen</span><span class="p">,</span> <span class="n">pg_pairs</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">mbox_tmo</span><span class="p">;</span>
	<span class="kt">uint16_t</span> <span class="n">xritag_start</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">shdr_status</span><span class="p">,</span> <span class="n">shdr_add_status</span><span class="p">;</span>
	<span class="k">union</span> <span class="n">lpfc_sli4_cfg_shdr</span> <span class="o">*</span><span class="n">shdr</span><span class="p">;</span>

	<span class="n">reqlen</span> <span class="o">=</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">els_xri_cnt</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sgl_page_pairs</span><span class="p">)</span> <span class="o">+</span>
		 <span class="k">sizeof</span><span class="p">(</span><span class="k">union</span> <span class="n">lpfc_sli4_cfg_shdr</span><span class="p">)</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">uint32_t</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">reqlen</span> <span class="o">&gt;</span> <span class="n">SLI4_PAGE_SIZE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_WARNING</span><span class="p">,</span> <span class="n">LOG_INIT</span><span class="p">,</span>
				<span class="s">&quot;2559 Block sgl registration required DMA &quot;</span>
				<span class="s">&quot;size (%d) great than a page</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">reqlen</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">mbox</span> <span class="o">=</span> <span class="n">mempool_alloc</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">mbox_mem_pool</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mbox</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="cm">/* Allocate DMA memory and set up the non-embedded mailbox command */</span>
	<span class="n">alloclen</span> <span class="o">=</span> <span class="n">lpfc_sli4_config</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">mbox</span><span class="p">,</span> <span class="n">LPFC_MBOX_SUBSYSTEM_FCOE</span><span class="p">,</span>
			 <span class="n">LPFC_MBOX_OPCODE_FCOE_POST_SGL_PAGES</span><span class="p">,</span> <span class="n">reqlen</span><span class="p">,</span>
			 <span class="n">LPFC_SLI4_MBX_NEMBED</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">alloclen</span> <span class="o">&lt;</span> <span class="n">reqlen</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_INIT</span><span class="p">,</span>
				<span class="s">&quot;0285 Allocated DMA memory size (%d) is &quot;</span>
				<span class="s">&quot;less than the requested DMA memory &quot;</span>
				<span class="s">&quot;size (%d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">alloclen</span><span class="p">,</span> <span class="n">reqlen</span><span class="p">);</span>
		<span class="n">lpfc_sli4_mbox_cmd_free</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">mbox</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* Set up the SGL pages in the non-embedded DMA pages */</span>
	<span class="n">viraddr</span> <span class="o">=</span> <span class="n">mbox</span><span class="o">-&gt;</span><span class="n">sge_array</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="n">sgl</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_mbx_post_uembed_sgl_page1</span> <span class="o">*</span><span class="p">)</span><span class="n">viraddr</span><span class="p">;</span>
	<span class="n">sgl_pg_pairs</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">sgl</span><span class="o">-&gt;</span><span class="n">sgl_pg_pairs</span><span class="p">;</span>

	<span class="n">pg_pairs</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">sglq_entry</span><span class="p">,</span> <span class="n">sglq_next</span><span class="p">,</span> <span class="n">post_sgl_list</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Set up the sge entry */</span>
		<span class="n">sgl_pg_pairs</span><span class="o">-&gt;</span><span class="n">sgl_pg0_addr_lo</span> <span class="o">=</span>
				<span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">putPaddrLow</span><span class="p">(</span><span class="n">sglq_entry</span><span class="o">-&gt;</span><span class="n">phys</span><span class="p">));</span>
		<span class="n">sgl_pg_pairs</span><span class="o">-&gt;</span><span class="n">sgl_pg0_addr_hi</span> <span class="o">=</span>
				<span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">putPaddrHigh</span><span class="p">(</span><span class="n">sglq_entry</span><span class="o">-&gt;</span><span class="n">phys</span><span class="p">));</span>
		<span class="n">sgl_pg_pairs</span><span class="o">-&gt;</span><span class="n">sgl_pg1_addr_lo</span> <span class="o">=</span>
				<span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">putPaddrLow</span><span class="p">(</span><span class="mi">0</span><span class="p">));</span>
		<span class="n">sgl_pg_pairs</span><span class="o">-&gt;</span><span class="n">sgl_pg1_addr_hi</span> <span class="o">=</span>
				<span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">putPaddrHigh</span><span class="p">(</span><span class="mi">0</span><span class="p">));</span>

		<span class="cm">/* Keep the first xritag on the list */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pg_pairs</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">xritag_start</span> <span class="o">=</span> <span class="n">sglq_entry</span><span class="o">-&gt;</span><span class="n">sli4_xritag</span><span class="p">;</span>
		<span class="n">sgl_pg_pairs</span><span class="o">++</span><span class="p">;</span>
		<span class="n">pg_pairs</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Complete initialization and perform endian conversion. */</span>
	<span class="n">bf_set</span><span class="p">(</span><span class="n">lpfc_post_sgl_pages_xri</span><span class="p">,</span> <span class="n">sgl</span><span class="p">,</span> <span class="n">xritag_start</span><span class="p">);</span>
	<span class="n">bf_set</span><span class="p">(</span><span class="n">lpfc_post_sgl_pages_xricnt</span><span class="p">,</span> <span class="n">sgl</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">els_xri_cnt</span><span class="p">);</span>
	<span class="n">sgl</span><span class="o">-&gt;</span><span class="n">word0</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">sgl</span><span class="o">-&gt;</span><span class="n">word0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">intr_enable</span><span class="p">)</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">lpfc_sli_issue_mbox</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">mbox</span><span class="p">,</span> <span class="n">MBX_POLL</span><span class="p">);</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="n">mbox_tmo</span> <span class="o">=</span> <span class="n">lpfc_mbox_tmo_val</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">mbox</span><span class="p">);</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">lpfc_sli_issue_mbox_wait</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">mbox</span><span class="p">,</span> <span class="n">mbox_tmo</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">shdr</span> <span class="o">=</span> <span class="p">(</span><span class="k">union</span> <span class="n">lpfc_sli4_cfg_shdr</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">sgl</span><span class="o">-&gt;</span><span class="n">cfg_shdr</span><span class="p">;</span>
	<span class="n">shdr_status</span> <span class="o">=</span> <span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_mbox_hdr_status</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">shdr</span><span class="o">-&gt;</span><span class="n">response</span><span class="p">);</span>
	<span class="n">shdr_add_status</span> <span class="o">=</span> <span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_mbox_hdr_add_status</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">shdr</span><span class="o">-&gt;</span><span class="n">response</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">!=</span> <span class="n">MBX_TIMEOUT</span><span class="p">)</span>
		<span class="n">lpfc_sli4_mbox_cmd_free</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">mbox</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">shdr_status</span> <span class="o">||</span> <span class="n">shdr_add_status</span> <span class="o">||</span> <span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_SLI</span><span class="p">,</span>
				<span class="s">&quot;2513 POST_SGL_BLOCK mailbox command failed &quot;</span>
				<span class="s">&quot;status x%x add_status x%x mbx status x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">shdr_status</span><span class="p">,</span> <span class="n">shdr_add_status</span><span class="p">,</span> <span class="n">rc</span><span class="p">);</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENXIO</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_sli4_post_scsi_sgl_block - post a block of scsi sgl list to firmware</span>
<span class="cm"> * @phba: pointer to lpfc hba data structure.</span>
<span class="cm"> * @sblist: pointer to scsi buffer list.</span>
<span class="cm"> * @count: number of scsi buffers on the list.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine is invoked to post a block of @count scsi sgl pages from a</span>
<span class="cm"> * SCSI buffer list @sblist to the HBA using non-embedded mailbox command.</span>
<span class="cm"> * No Lock is held.</span>
<span class="cm"> *</span>
<span class="cm"> **/</span>
<span class="kt">int</span>
<span class="nf">lpfc_sli4_post_scsi_sgl_block</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">sblist</span><span class="p">,</span>
			      <span class="kt">int</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpfc_scsi_buf</span> <span class="o">*</span><span class="n">psb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_mbx_post_uembed_sgl_page1</span> <span class="o">*</span><span class="n">sgl</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sgl_page_pairs</span> <span class="o">*</span><span class="n">sgl_pg_pairs</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">viraddr</span><span class="p">;</span>
	<span class="n">LPFC_MBOXQ_t</span> <span class="o">*</span><span class="n">mbox</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">reqlen</span><span class="p">,</span> <span class="n">alloclen</span><span class="p">,</span> <span class="n">pg_pairs</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">mbox_tmo</span><span class="p">;</span>
	<span class="kt">uint16_t</span> <span class="n">xritag_start</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">shdr_status</span><span class="p">,</span> <span class="n">shdr_add_status</span><span class="p">;</span>
	<span class="n">dma_addr_t</span> <span class="n">pdma_phys_bpl1</span><span class="p">;</span>
	<span class="k">union</span> <span class="n">lpfc_sli4_cfg_shdr</span> <span class="o">*</span><span class="n">shdr</span><span class="p">;</span>

	<span class="cm">/* Calculate the requested length of the dma memory */</span>
	<span class="n">reqlen</span> <span class="o">=</span> <span class="n">count</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sgl_page_pairs</span><span class="p">)</span> <span class="o">+</span>
		 <span class="k">sizeof</span><span class="p">(</span><span class="k">union</span> <span class="n">lpfc_sli4_cfg_shdr</span><span class="p">)</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">uint32_t</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">reqlen</span> <span class="o">&gt;</span> <span class="n">SLI4_PAGE_SIZE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_WARNING</span><span class="p">,</span> <span class="n">LOG_INIT</span><span class="p">,</span>
				<span class="s">&quot;0217 Block sgl registration required DMA &quot;</span>
				<span class="s">&quot;size (%d) great than a page</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">reqlen</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">mbox</span> <span class="o">=</span> <span class="n">mempool_alloc</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">mbox_mem_pool</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mbox</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_INIT</span><span class="p">,</span>
				<span class="s">&quot;0283 Failed to allocate mbox cmd memory</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Allocate DMA memory and set up the non-embedded mailbox command */</span>
	<span class="n">alloclen</span> <span class="o">=</span> <span class="n">lpfc_sli4_config</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">mbox</span><span class="p">,</span> <span class="n">LPFC_MBOX_SUBSYSTEM_FCOE</span><span class="p">,</span>
				<span class="n">LPFC_MBOX_OPCODE_FCOE_POST_SGL_PAGES</span><span class="p">,</span> <span class="n">reqlen</span><span class="p">,</span>
				<span class="n">LPFC_SLI4_MBX_NEMBED</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">alloclen</span> <span class="o">&lt;</span> <span class="n">reqlen</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_INIT</span><span class="p">,</span>
				<span class="s">&quot;2561 Allocated DMA memory size (%d) is &quot;</span>
				<span class="s">&quot;less than the requested DMA memory &quot;</span>
				<span class="s">&quot;size (%d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">alloclen</span><span class="p">,</span> <span class="n">reqlen</span><span class="p">);</span>
		<span class="n">lpfc_sli4_mbox_cmd_free</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">mbox</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Get the first SGE entry from the non-embedded DMA memory */</span>
	<span class="n">viraddr</span> <span class="o">=</span> <span class="n">mbox</span><span class="o">-&gt;</span><span class="n">sge_array</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>

	<span class="cm">/* Set up the SGL pages in the non-embedded DMA pages */</span>
	<span class="n">sgl</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_mbx_post_uembed_sgl_page1</span> <span class="o">*</span><span class="p">)</span><span class="n">viraddr</span><span class="p">;</span>
	<span class="n">sgl_pg_pairs</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">sgl</span><span class="o">-&gt;</span><span class="n">sgl_pg_pairs</span><span class="p">;</span>

	<span class="n">pg_pairs</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">psb</span><span class="p">,</span> <span class="n">sblist</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Set up the sge entry */</span>
		<span class="n">sgl_pg_pairs</span><span class="o">-&gt;</span><span class="n">sgl_pg0_addr_lo</span> <span class="o">=</span>
			<span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">putPaddrLow</span><span class="p">(</span><span class="n">psb</span><span class="o">-&gt;</span><span class="n">dma_phys_bpl</span><span class="p">));</span>
		<span class="n">sgl_pg_pairs</span><span class="o">-&gt;</span><span class="n">sgl_pg0_addr_hi</span> <span class="o">=</span>
			<span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">putPaddrHigh</span><span class="p">(</span><span class="n">psb</span><span class="o">-&gt;</span><span class="n">dma_phys_bpl</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">cfg_sg_dma_buf_size</span> <span class="o">&gt;</span> <span class="n">SGL_PAGE_SIZE</span><span class="p">)</span>
			<span class="n">pdma_phys_bpl1</span> <span class="o">=</span> <span class="n">psb</span><span class="o">-&gt;</span><span class="n">dma_phys_bpl</span> <span class="o">+</span> <span class="n">SGL_PAGE_SIZE</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">pdma_phys_bpl1</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">sgl_pg_pairs</span><span class="o">-&gt;</span><span class="n">sgl_pg1_addr_lo</span> <span class="o">=</span>
			<span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">putPaddrLow</span><span class="p">(</span><span class="n">pdma_phys_bpl1</span><span class="p">));</span>
		<span class="n">sgl_pg_pairs</span><span class="o">-&gt;</span><span class="n">sgl_pg1_addr_hi</span> <span class="o">=</span>
			<span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">putPaddrHigh</span><span class="p">(</span><span class="n">pdma_phys_bpl1</span><span class="p">));</span>
		<span class="cm">/* Keep the first xritag on the list */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pg_pairs</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">xritag_start</span> <span class="o">=</span> <span class="n">psb</span><span class="o">-&gt;</span><span class="n">cur_iocbq</span><span class="p">.</span><span class="n">sli4_xritag</span><span class="p">;</span>
		<span class="n">sgl_pg_pairs</span><span class="o">++</span><span class="p">;</span>
		<span class="n">pg_pairs</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">bf_set</span><span class="p">(</span><span class="n">lpfc_post_sgl_pages_xri</span><span class="p">,</span> <span class="n">sgl</span><span class="p">,</span> <span class="n">xritag_start</span><span class="p">);</span>
	<span class="n">bf_set</span><span class="p">(</span><span class="n">lpfc_post_sgl_pages_xricnt</span><span class="p">,</span> <span class="n">sgl</span><span class="p">,</span> <span class="n">pg_pairs</span><span class="p">);</span>
	<span class="cm">/* Perform endian conversion if necessary */</span>
	<span class="n">sgl</span><span class="o">-&gt;</span><span class="n">word0</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">sgl</span><span class="o">-&gt;</span><span class="n">word0</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">intr_enable</span><span class="p">)</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">lpfc_sli_issue_mbox</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">mbox</span><span class="p">,</span> <span class="n">MBX_POLL</span><span class="p">);</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="n">mbox_tmo</span> <span class="o">=</span> <span class="n">lpfc_mbox_tmo_val</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">mbox</span><span class="p">);</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">lpfc_sli_issue_mbox_wait</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">mbox</span><span class="p">,</span> <span class="n">mbox_tmo</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">shdr</span> <span class="o">=</span> <span class="p">(</span><span class="k">union</span> <span class="n">lpfc_sli4_cfg_shdr</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">sgl</span><span class="o">-&gt;</span><span class="n">cfg_shdr</span><span class="p">;</span>
	<span class="n">shdr_status</span> <span class="o">=</span> <span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_mbox_hdr_status</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">shdr</span><span class="o">-&gt;</span><span class="n">response</span><span class="p">);</span>
	<span class="n">shdr_add_status</span> <span class="o">=</span> <span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_mbox_hdr_add_status</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">shdr</span><span class="o">-&gt;</span><span class="n">response</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">!=</span> <span class="n">MBX_TIMEOUT</span><span class="p">)</span>
		<span class="n">lpfc_sli4_mbox_cmd_free</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">mbox</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">shdr_status</span> <span class="o">||</span> <span class="n">shdr_add_status</span> <span class="o">||</span> <span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_SLI</span><span class="p">,</span>
				<span class="s">&quot;2564 POST_SGL_BLOCK mailbox command failed &quot;</span>
				<span class="s">&quot;status x%x add_status x%x mbx status x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">shdr_status</span><span class="p">,</span> <span class="n">shdr_add_status</span><span class="p">,</span> <span class="n">rc</span><span class="p">);</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENXIO</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_fc_frame_check - Check that this frame is a valid frame to handle</span>
<span class="cm"> * @phba: pointer to lpfc_hba struct that the frame was received on</span>
<span class="cm"> * @fc_hdr: A pointer to the FC Header data (In Big Endian Format)</span>
<span class="cm"> *</span>
<span class="cm"> * This function checks the fields in the @fc_hdr to see if the FC frame is a</span>
<span class="cm"> * valid type of frame that the LPFC driver will handle. This function will</span>
<span class="cm"> * return a zero if the frame is a valid frame or a non zero value when the</span>
<span class="cm"> * frame does not pass the check.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">lpfc_fc_frame_check</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">,</span> <span class="k">struct</span> <span class="n">fc_frame_header</span> <span class="o">*</span><span class="n">fc_hdr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*  make rctl_names static to save stack space */</span>
	<span class="k">static</span> <span class="kt">char</span> <span class="o">*</span><span class="n">rctl_names</span><span class="p">[]</span> <span class="o">=</span> <span class="n">FC_RCTL_NAMES_INIT</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">type_names</span><span class="p">[]</span> <span class="o">=</span> <span class="n">FC_TYPE_NAMES_INIT</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fc_vft_header</span> <span class="o">*</span><span class="n">fc_vft_hdr</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="o">*</span><span class="n">header</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint32_t</span> <span class="o">*</span><span class="p">)</span> <span class="n">fc_hdr</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">fc_hdr</span><span class="o">-&gt;</span><span class="n">fh_r_ctl</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">FC_RCTL_DD_UNCAT</span>:		<span class="cm">/* uncategorized information */</span>
	<span class="k">case</span> <span class="n">FC_RCTL_DD_SOL_DATA</span>:	<span class="cm">/* solicited data */</span>
	<span class="k">case</span> <span class="n">FC_RCTL_DD_UNSOL_CTL</span>:	<span class="cm">/* unsolicited control */</span>
	<span class="k">case</span> <span class="n">FC_RCTL_DD_SOL_CTL</span>:	<span class="cm">/* solicited control or reply */</span>
	<span class="k">case</span> <span class="n">FC_RCTL_DD_UNSOL_DATA</span>:	<span class="cm">/* unsolicited data */</span>
	<span class="k">case</span> <span class="n">FC_RCTL_DD_DATA_DESC</span>:	<span class="cm">/* data descriptor */</span>
	<span class="k">case</span> <span class="n">FC_RCTL_DD_UNSOL_CMD</span>:	<span class="cm">/* unsolicited command */</span>
	<span class="k">case</span> <span class="n">FC_RCTL_DD_CMD_STATUS</span>:	<span class="cm">/* command status */</span>
	<span class="k">case</span> <span class="n">FC_RCTL_ELS_REQ</span>:	<span class="cm">/* extended link services request */</span>
	<span class="k">case</span> <span class="n">FC_RCTL_ELS_REP</span>:	<span class="cm">/* extended link services reply */</span>
	<span class="k">case</span> <span class="n">FC_RCTL_ELS4_REQ</span>:	<span class="cm">/* FC-4 ELS request */</span>
	<span class="k">case</span> <span class="n">FC_RCTL_ELS4_REP</span>:	<span class="cm">/* FC-4 ELS reply */</span>
	<span class="k">case</span> <span class="n">FC_RCTL_BA_NOP</span>:  	<span class="cm">/* basic link service NOP */</span>
	<span class="k">case</span> <span class="n">FC_RCTL_BA_ABTS</span>: 	<span class="cm">/* basic link service abort */</span>
	<span class="k">case</span> <span class="n">FC_RCTL_BA_RMC</span>: 	<span class="cm">/* remove connection */</span>
	<span class="k">case</span> <span class="n">FC_RCTL_BA_ACC</span>:	<span class="cm">/* basic accept */</span>
	<span class="k">case</span> <span class="n">FC_RCTL_BA_RJT</span>:	<span class="cm">/* basic reject */</span>
	<span class="k">case</span> <span class="n">FC_RCTL_BA_PRMT</span>:
	<span class="k">case</span> <span class="n">FC_RCTL_ACK_1</span>:	<span class="cm">/* acknowledge_1 */</span>
	<span class="k">case</span> <span class="n">FC_RCTL_ACK_0</span>:	<span class="cm">/* acknowledge_0 */</span>
	<span class="k">case</span> <span class="n">FC_RCTL_P_RJT</span>:	<span class="cm">/* port reject */</span>
	<span class="k">case</span> <span class="n">FC_RCTL_F_RJT</span>:	<span class="cm">/* fabric reject */</span>
	<span class="k">case</span> <span class="n">FC_RCTL_P_BSY</span>:	<span class="cm">/* port busy */</span>
	<span class="k">case</span> <span class="n">FC_RCTL_F_BSY</span>:	<span class="cm">/* fabric busy to data frame */</span>
	<span class="k">case</span> <span class="n">FC_RCTL_F_BSYL</span>:	<span class="cm">/* fabric busy to link control frame */</span>
	<span class="k">case</span> <span class="n">FC_RCTL_LCR</span>:	<span class="cm">/* link credit reset */</span>
	<span class="k">case</span> <span class="n">FC_RCTL_END</span>:	<span class="cm">/* end */</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">FC_RCTL_VFTH</span>:	<span class="cm">/* Virtual Fabric tagging Header */</span>
		<span class="n">fc_vft_hdr</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">fc_vft_header</span> <span class="o">*</span><span class="p">)</span><span class="n">fc_hdr</span><span class="p">;</span>
		<span class="n">fc_hdr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">((</span><span class="k">struct</span> <span class="n">fc_frame_header</span> <span class="o">*</span><span class="p">)</span><span class="n">fc_vft_hdr</span><span class="p">)[</span><span class="mi">1</span><span class="p">];</span>
		<span class="k">return</span> <span class="n">lpfc_fc_frame_check</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">fc_hdr</span><span class="p">);</span>
	<span class="nl">default:</span>
		<span class="k">goto</span> <span class="n">drop</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">fc_hdr</span><span class="o">-&gt;</span><span class="n">fh_type</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">FC_TYPE_BLS</span>:
	<span class="k">case</span> <span class="n">FC_TYPE_ELS</span>:
	<span class="k">case</span> <span class="n">FC_TYPE_FCP</span>:
	<span class="k">case</span> <span class="n">FC_TYPE_CT</span>:
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">FC_TYPE_IP</span>:
	<span class="k">case</span> <span class="n">FC_TYPE_ILS</span>:
	<span class="nl">default:</span>
		<span class="k">goto</span> <span class="n">drop</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_INFO</span><span class="p">,</span> <span class="n">LOG_ELS</span><span class="p">,</span>
			<span class="s">&quot;2538 Received frame rctl:%s type:%s &quot;</span>
			<span class="s">&quot;Frame Data:%08x %08x %08x %08x %08x %08x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">rctl_names</span><span class="p">[</span><span class="n">fc_hdr</span><span class="o">-&gt;</span><span class="n">fh_r_ctl</span><span class="p">],</span>
			<span class="n">type_names</span><span class="p">[</span><span class="n">fc_hdr</span><span class="o">-&gt;</span><span class="n">fh_type</span><span class="p">],</span>
			<span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">header</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">header</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span>
			<span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">header</span><span class="p">[</span><span class="mi">2</span><span class="p">]),</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">header</span><span class="p">[</span><span class="mi">3</span><span class="p">]),</span>
			<span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">header</span><span class="p">[</span><span class="mi">4</span><span class="p">]),</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">header</span><span class="p">[</span><span class="mi">5</span><span class="p">]));</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">drop:</span>
	<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_WARNING</span><span class="p">,</span> <span class="n">LOG_ELS</span><span class="p">,</span>
			<span class="s">&quot;2539 Dropped frame rctl:%s type:%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">rctl_names</span><span class="p">[</span><span class="n">fc_hdr</span><span class="o">-&gt;</span><span class="n">fh_r_ctl</span><span class="p">],</span>
			<span class="n">type_names</span><span class="p">[</span><span class="n">fc_hdr</span><span class="o">-&gt;</span><span class="n">fh_type</span><span class="p">]);</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_fc_hdr_get_vfi - Get the VFI from an FC frame</span>
<span class="cm"> * @fc_hdr: A pointer to the FC Header data (In Big Endian Format)</span>
<span class="cm"> *</span>
<span class="cm"> * This function processes the FC header to retrieve the VFI from the VF</span>
<span class="cm"> * header, if one exists. This function will return the VFI if one exists</span>
<span class="cm"> * or 0 if no VSAN Header exists.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">uint32_t</span>
<span class="nf">lpfc_fc_hdr_get_vfi</span><span class="p">(</span><span class="k">struct</span> <span class="n">fc_frame_header</span> <span class="o">*</span><span class="n">fc_hdr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fc_vft_header</span> <span class="o">*</span><span class="n">fc_vft_hdr</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">fc_vft_header</span> <span class="o">*</span><span class="p">)</span><span class="n">fc_hdr</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">fc_hdr</span><span class="o">-&gt;</span><span class="n">fh_r_ctl</span> <span class="o">!=</span> <span class="n">FC_RCTL_VFTH</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">bf_get</span><span class="p">(</span><span class="n">fc_vft_hdr_vf_id</span><span class="p">,</span> <span class="n">fc_vft_hdr</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_fc_frame_to_vport - Finds the vport that a frame is destined to</span>
<span class="cm"> * @phba: Pointer to the HBA structure to search for the vport on</span>
<span class="cm"> * @fc_hdr: A pointer to the FC Header data (In Big Endian Format)</span>
<span class="cm"> * @fcfi: The FC Fabric ID that the frame came from</span>
<span class="cm"> *</span>
<span class="cm"> * This function searches the @phba for a vport that matches the content of the</span>
<span class="cm"> * @fc_hdr passed in and the @fcfi. This function uses the @fc_hdr to fetch the</span>
<span class="cm"> * VFI, if the Virtual Fabric Tagging Header exists, and the DID. This function</span>
<span class="cm"> * returns the matching vport pointer or NULL if unable to match frame to a</span>
<span class="cm"> * vport.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span>
<span class="nf">lpfc_fc_frame_to_vport</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">,</span> <span class="k">struct</span> <span class="n">fc_frame_header</span> <span class="o">*</span><span class="n">fc_hdr</span><span class="p">,</span>
		       <span class="kt">uint16_t</span> <span class="n">fcfi</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">**</span><span class="n">vports</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="n">vport</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">did</span> <span class="o">=</span> <span class="p">(</span><span class="n">fc_hdr</span><span class="o">-&gt;</span><span class="n">fh_d_id</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span> <span class="o">|</span>
			<span class="n">fc_hdr</span><span class="o">-&gt;</span><span class="n">fh_d_id</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span> <span class="o">|</span>
			<span class="n">fc_hdr</span><span class="o">-&gt;</span><span class="n">fh_d_id</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">did</span> <span class="o">==</span> <span class="n">Fabric_DID</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">pport</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">pport</span><span class="o">-&gt;</span><span class="n">fc_flag</span> <span class="o">&amp;</span> <span class="n">FC_PT2PT</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		<span class="o">!</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">link_state</span> <span class="o">==</span> <span class="n">LPFC_HBA_READY</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">pport</span><span class="p">;</span>

	<span class="n">vports</span> <span class="o">=</span> <span class="n">lpfc_create_vport_work_array</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vports</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">max_vpi</span> <span class="o">&amp;&amp;</span> <span class="n">vports</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">fcf</span><span class="p">.</span><span class="n">fcfi</span> <span class="o">==</span> <span class="n">fcfi</span> <span class="o">&amp;&amp;</span>
			    <span class="n">vports</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">vfi</span> <span class="o">==</span> <span class="n">lpfc_fc_hdr_get_vfi</span><span class="p">(</span><span class="n">fc_hdr</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			    <span class="n">vports</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">fc_myDID</span> <span class="o">==</span> <span class="n">did</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">vport</span> <span class="o">=</span> <span class="n">vports</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="n">lpfc_destroy_vport_work_array</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">vports</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">vport</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_update_rcv_time_stamp - Update vport&#39;s rcv seq time stamp</span>
<span class="cm"> * @vport: The vport to work on.</span>
<span class="cm"> *</span>
<span class="cm"> * This function updates the receive sequence time stamp for this vport. The</span>
<span class="cm"> * receive sequence time stamp indicates the time that the last frame of the</span>
<span class="cm"> * the sequence that has been idle for the longest amount of time was received.</span>
<span class="cm"> * the driver uses this time stamp to indicate if any received sequences have</span>
<span class="cm"> * timed out.</span>
<span class="cm"> **/</span>
<span class="kt">void</span>
<span class="nf">lpfc_update_rcv_time_stamp</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="n">vport</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpfc_dmabuf</span> <span class="o">*</span><span class="n">h_buf</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hbq_dmabuf</span> <span class="o">*</span><span class="n">dmabuf</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="cm">/* get the oldest sequence on the rcv list */</span>
	<span class="n">h_buf</span> <span class="o">=</span> <span class="n">list_get_first</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">rcv_buffer_list</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">lpfc_dmabuf</span><span class="p">,</span> <span class="n">list</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">h_buf</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">dmabuf</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">h_buf</span><span class="p">,</span> <span class="k">struct</span> <span class="n">hbq_dmabuf</span><span class="p">,</span> <span class="n">hbuf</span><span class="p">);</span>
	<span class="n">vport</span><span class="o">-&gt;</span><span class="n">rcv_buffer_time_stamp</span> <span class="o">=</span> <span class="n">dmabuf</span><span class="o">-&gt;</span><span class="n">time_stamp</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_cleanup_rcv_buffers - Cleans up all outstanding receive sequences.</span>
<span class="cm"> * @vport: The vport that the received sequences were sent to.</span>
<span class="cm"> *</span>
<span class="cm"> * This function cleans up all outstanding received sequences. This is called</span>
<span class="cm"> * by the driver when a link event or user action invalidates all the received</span>
<span class="cm"> * sequences.</span>
<span class="cm"> **/</span>
<span class="kt">void</span>
<span class="nf">lpfc_cleanup_rcv_buffers</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="n">vport</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpfc_dmabuf</span> <span class="o">*</span><span class="n">h_buf</span><span class="p">,</span> <span class="o">*</span><span class="n">hnext</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_dmabuf</span> <span class="o">*</span><span class="n">d_buf</span><span class="p">,</span> <span class="o">*</span><span class="n">dnext</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hbq_dmabuf</span> <span class="o">*</span><span class="n">dmabuf</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="cm">/* start with the oldest sequence on the rcv list */</span>
	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">h_buf</span><span class="p">,</span> <span class="n">hnext</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">rcv_buffer_list</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dmabuf</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">h_buf</span><span class="p">,</span> <span class="k">struct</span> <span class="n">hbq_dmabuf</span><span class="p">,</span> <span class="n">hbuf</span><span class="p">);</span>
		<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dmabuf</span><span class="o">-&gt;</span><span class="n">hbuf</span><span class="p">.</span><span class="n">list</span><span class="p">);</span>
		<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">d_buf</span><span class="p">,</span> <span class="n">dnext</span><span class="p">,</span>
					 <span class="o">&amp;</span><span class="n">dmabuf</span><span class="o">-&gt;</span><span class="n">dbuf</span><span class="p">.</span><span class="n">list</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">d_buf</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
			<span class="n">lpfc_in_buf_free</span><span class="p">(</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">phba</span><span class="p">,</span> <span class="n">d_buf</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">lpfc_in_buf_free</span><span class="p">(</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">phba</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dmabuf</span><span class="o">-&gt;</span><span class="n">dbuf</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_rcv_seq_check_edtov - Cleans up timed out receive sequences.</span>
<span class="cm"> * @vport: The vport that the received sequences were sent to.</span>
<span class="cm"> *</span>
<span class="cm"> * This function determines whether any received sequences have timed out by</span>
<span class="cm"> * first checking the vport&#39;s rcv_buffer_time_stamp. If this time_stamp</span>
<span class="cm"> * indicates that there is at least one timed out sequence this routine will</span>
<span class="cm"> * go through the received sequences one at a time from most inactive to most</span>
<span class="cm"> * active to determine which ones need to be cleaned up. Once it has determined</span>
<span class="cm"> * that a sequence needs to be cleaned up it will simply free up the resources</span>
<span class="cm"> * without sending an abort.</span>
<span class="cm"> **/</span>
<span class="kt">void</span>
<span class="nf">lpfc_rcv_seq_check_edtov</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="n">vport</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpfc_dmabuf</span> <span class="o">*</span><span class="n">h_buf</span><span class="p">,</span> <span class="o">*</span><span class="n">hnext</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_dmabuf</span> <span class="o">*</span><span class="n">d_buf</span><span class="p">,</span> <span class="o">*</span><span class="n">dnext</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hbq_dmabuf</span> <span class="o">*</span><span class="n">dmabuf</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">timeout</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">abort_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">timeout</span> <span class="o">=</span> <span class="p">(</span><span class="n">msecs_to_jiffies</span><span class="p">(</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">fc_edtov</span><span class="p">)</span> <span class="o">+</span>
		   <span class="n">vport</span><span class="o">-&gt;</span><span class="n">rcv_buffer_time_stamp</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">rcv_buffer_list</span><span class="p">)</span> <span class="o">||</span>
	    <span class="n">time_before</span><span class="p">(</span><span class="n">jiffies</span><span class="p">,</span> <span class="n">timeout</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="cm">/* start with the oldest sequence on the rcv list */</span>
	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">h_buf</span><span class="p">,</span> <span class="n">hnext</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">rcv_buffer_list</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dmabuf</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">h_buf</span><span class="p">,</span> <span class="k">struct</span> <span class="n">hbq_dmabuf</span><span class="p">,</span> <span class="n">hbuf</span><span class="p">);</span>
		<span class="n">timeout</span> <span class="o">=</span> <span class="p">(</span><span class="n">msecs_to_jiffies</span><span class="p">(</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">fc_edtov</span><span class="p">)</span> <span class="o">+</span>
			   <span class="n">dmabuf</span><span class="o">-&gt;</span><span class="n">time_stamp</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">time_before</span><span class="p">(</span><span class="n">jiffies</span><span class="p">,</span> <span class="n">timeout</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">abort_count</span><span class="o">++</span><span class="p">;</span>
		<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dmabuf</span><span class="o">-&gt;</span><span class="n">hbuf</span><span class="p">.</span><span class="n">list</span><span class="p">);</span>
		<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">d_buf</span><span class="p">,</span> <span class="n">dnext</span><span class="p">,</span>
					 <span class="o">&amp;</span><span class="n">dmabuf</span><span class="o">-&gt;</span><span class="n">dbuf</span><span class="p">.</span><span class="n">list</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">d_buf</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
			<span class="n">lpfc_in_buf_free</span><span class="p">(</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">phba</span><span class="p">,</span> <span class="n">d_buf</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">lpfc_in_buf_free</span><span class="p">(</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">phba</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dmabuf</span><span class="o">-&gt;</span><span class="n">dbuf</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">abort_count</span><span class="p">)</span>
		<span class="n">lpfc_update_rcv_time_stamp</span><span class="p">(</span><span class="n">vport</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_fc_frame_add - Adds a frame to the vport&#39;s list of received sequences</span>
<span class="cm"> * @dmabuf: pointer to a dmabuf that describes the hdr and data of the FC frame</span>
<span class="cm"> *</span>
<span class="cm"> * This function searches through the existing incomplete sequences that have</span>
<span class="cm"> * been sent to this @vport. If the frame matches one of the incomplete</span>
<span class="cm"> * sequences then the dbuf in the @dmabuf is added to the list of frames that</span>
<span class="cm"> * make up that sequence. If no sequence is found that matches this frame then</span>
<span class="cm"> * the function will add the hbuf in the @dmabuf to the @vport&#39;s rcv_buffer_list</span>
<span class="cm"> * This function returns a pointer to the first dmabuf in the sequence list that</span>
<span class="cm"> * the frame was linked to.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">hbq_dmabuf</span> <span class="o">*</span>
<span class="nf">lpfc_fc_frame_add</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="n">vport</span><span class="p">,</span> <span class="k">struct</span> <span class="n">hbq_dmabuf</span> <span class="o">*</span><span class="n">dmabuf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fc_frame_header</span> <span class="o">*</span><span class="n">new_hdr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fc_frame_header</span> <span class="o">*</span><span class="n">temp_hdr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_dmabuf</span> <span class="o">*</span><span class="n">d_buf</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_dmabuf</span> <span class="o">*</span><span class="n">h_buf</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hbq_dmabuf</span> <span class="o">*</span><span class="n">seq_dmabuf</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hbq_dmabuf</span> <span class="o">*</span><span class="n">temp_dmabuf</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dmabuf</span><span class="o">-&gt;</span><span class="n">dbuf</span><span class="p">.</span><span class="n">list</span><span class="p">);</span>
	<span class="n">dmabuf</span><span class="o">-&gt;</span><span class="n">time_stamp</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span>
	<span class="n">new_hdr</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">fc_frame_header</span> <span class="o">*</span><span class="p">)</span><span class="n">dmabuf</span><span class="o">-&gt;</span><span class="n">hbuf</span><span class="p">.</span><span class="n">virt</span><span class="p">;</span>
	<span class="cm">/* Use the hdr_buf to find the sequence that this frame belongs to */</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">h_buf</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">rcv_buffer_list</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">temp_hdr</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">fc_frame_header</span> <span class="o">*</span><span class="p">)</span><span class="n">h_buf</span><span class="o">-&gt;</span><span class="n">virt</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">temp_hdr</span><span class="o">-&gt;</span><span class="n">fh_seq_id</span> <span class="o">!=</span> <span class="n">new_hdr</span><span class="o">-&gt;</span><span class="n">fh_seq_id</span><span class="p">)</span> <span class="o">||</span>
		    <span class="p">(</span><span class="n">temp_hdr</span><span class="o">-&gt;</span><span class="n">fh_ox_id</span> <span class="o">!=</span> <span class="n">new_hdr</span><span class="o">-&gt;</span><span class="n">fh_ox_id</span><span class="p">)</span> <span class="o">||</span>
		    <span class="p">(</span><span class="n">memcmp</span><span class="p">(</span><span class="o">&amp;</span><span class="n">temp_hdr</span><span class="o">-&gt;</span><span class="n">fh_s_id</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">new_hdr</span><span class="o">-&gt;</span><span class="n">fh_s_id</span><span class="p">,</span> <span class="mi">3</span><span class="p">)))</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="cm">/* found a pending sequence that matches this frame */</span>
		<span class="n">seq_dmabuf</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">h_buf</span><span class="p">,</span> <span class="k">struct</span> <span class="n">hbq_dmabuf</span><span class="p">,</span> <span class="n">hbuf</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">seq_dmabuf</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * This indicates first frame received for this sequence.</span>
<span class="cm">		 * Queue the buffer on the vport&#39;s rcv_buffer_list.</span>
<span class="cm">		 */</span>
		<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dmabuf</span><span class="o">-&gt;</span><span class="n">hbuf</span><span class="p">.</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">rcv_buffer_list</span><span class="p">);</span>
		<span class="n">lpfc_update_rcv_time_stamp</span><span class="p">(</span><span class="n">vport</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">dmabuf</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">temp_hdr</span> <span class="o">=</span> <span class="n">seq_dmabuf</span><span class="o">-&gt;</span><span class="n">hbuf</span><span class="p">.</span><span class="n">virt</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">new_hdr</span><span class="o">-&gt;</span><span class="n">fh_seq_cnt</span><span class="p">)</span> <span class="o">&lt;</span>
		<span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">temp_hdr</span><span class="o">-&gt;</span><span class="n">fh_seq_cnt</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">seq_dmabuf</span><span class="o">-&gt;</span><span class="n">hbuf</span><span class="p">.</span><span class="n">list</span><span class="p">);</span>
		<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dmabuf</span><span class="o">-&gt;</span><span class="n">hbuf</span><span class="p">.</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">rcv_buffer_list</span><span class="p">);</span>
		<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dmabuf</span><span class="o">-&gt;</span><span class="n">dbuf</span><span class="p">.</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">seq_dmabuf</span><span class="o">-&gt;</span><span class="n">dbuf</span><span class="p">.</span><span class="n">list</span><span class="p">);</span>
		<span class="n">lpfc_update_rcv_time_stamp</span><span class="p">(</span><span class="n">vport</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">dmabuf</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* move this sequence to the tail to indicate a young sequence */</span>
	<span class="n">list_move_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">seq_dmabuf</span><span class="o">-&gt;</span><span class="n">hbuf</span><span class="p">.</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">rcv_buffer_list</span><span class="p">);</span>
	<span class="n">seq_dmabuf</span><span class="o">-&gt;</span><span class="n">time_stamp</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span>
	<span class="n">lpfc_update_rcv_time_stamp</span><span class="p">(</span><span class="n">vport</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">seq_dmabuf</span><span class="o">-&gt;</span><span class="n">dbuf</span><span class="p">.</span><span class="n">list</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">temp_hdr</span> <span class="o">=</span> <span class="n">dmabuf</span><span class="o">-&gt;</span><span class="n">hbuf</span><span class="p">.</span><span class="n">virt</span><span class="p">;</span>
		<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dmabuf</span><span class="o">-&gt;</span><span class="n">dbuf</span><span class="p">.</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">seq_dmabuf</span><span class="o">-&gt;</span><span class="n">dbuf</span><span class="p">.</span><span class="n">list</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">seq_dmabuf</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* find the correct place in the sequence to insert this frame */</span>
	<span class="n">list_for_each_entry_reverse</span><span class="p">(</span><span class="n">d_buf</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">seq_dmabuf</span><span class="o">-&gt;</span><span class="n">dbuf</span><span class="p">.</span><span class="n">list</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">temp_dmabuf</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">d_buf</span><span class="p">,</span> <span class="k">struct</span> <span class="n">hbq_dmabuf</span><span class="p">,</span> <span class="n">dbuf</span><span class="p">);</span>
		<span class="n">temp_hdr</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">fc_frame_header</span> <span class="o">*</span><span class="p">)</span><span class="n">temp_dmabuf</span><span class="o">-&gt;</span><span class="n">hbuf</span><span class="p">.</span><span class="n">virt</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * If the frame&#39;s sequence count is greater than the frame on</span>
<span class="cm">		 * the list then insert the frame right after this frame</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">new_hdr</span><span class="o">-&gt;</span><span class="n">fh_seq_cnt</span><span class="p">)</span> <span class="o">&gt;</span>
			<span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">temp_hdr</span><span class="o">-&gt;</span><span class="n">fh_seq_cnt</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dmabuf</span><span class="o">-&gt;</span><span class="n">dbuf</span><span class="p">.</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">temp_dmabuf</span><span class="o">-&gt;</span><span class="n">dbuf</span><span class="p">.</span><span class="n">list</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">seq_dmabuf</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_sli4_abort_partial_seq - Abort partially assembled unsol sequence</span>
<span class="cm"> * @vport: pointer to a vitural port</span>
<span class="cm"> * @dmabuf: pointer to a dmabuf that describes the FC sequence</span>
<span class="cm"> *</span>
<span class="cm"> * This function tries to abort from the partially assembed sequence, described</span>
<span class="cm"> * by the information from basic abbort @dmabuf. It checks to see whether such</span>
<span class="cm"> * partially assembled sequence held by the driver. If so, it shall free up all</span>
<span class="cm"> * the frames from the partially assembled sequence.</span>
<span class="cm"> *</span>
<span class="cm"> * Return</span>
<span class="cm"> * true  -- if there is matching partially assembled sequence present and all</span>
<span class="cm"> *          the frames freed with the sequence;</span>
<span class="cm"> * false -- if there is no matching partially assembled sequence present so</span>
<span class="cm"> *          nothing got aborted in the lower layer driver</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="n">bool</span>
<span class="nf">lpfc_sli4_abort_partial_seq</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="n">vport</span><span class="p">,</span>
			    <span class="k">struct</span> <span class="n">hbq_dmabuf</span> <span class="o">*</span><span class="n">dmabuf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fc_frame_header</span> <span class="o">*</span><span class="n">new_hdr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fc_frame_header</span> <span class="o">*</span><span class="n">temp_hdr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_dmabuf</span> <span class="o">*</span><span class="n">d_buf</span><span class="p">,</span> <span class="o">*</span><span class="n">n_buf</span><span class="p">,</span> <span class="o">*</span><span class="n">h_buf</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hbq_dmabuf</span> <span class="o">*</span><span class="n">seq_dmabuf</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="cm">/* Use the hdr_buf to find the sequence that matches this frame */</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dmabuf</span><span class="o">-&gt;</span><span class="n">dbuf</span><span class="p">.</span><span class="n">list</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dmabuf</span><span class="o">-&gt;</span><span class="n">hbuf</span><span class="p">.</span><span class="n">list</span><span class="p">);</span>
	<span class="n">new_hdr</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">fc_frame_header</span> <span class="o">*</span><span class="p">)</span><span class="n">dmabuf</span><span class="o">-&gt;</span><span class="n">hbuf</span><span class="p">.</span><span class="n">virt</span><span class="p">;</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">h_buf</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">rcv_buffer_list</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">temp_hdr</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">fc_frame_header</span> <span class="o">*</span><span class="p">)</span><span class="n">h_buf</span><span class="o">-&gt;</span><span class="n">virt</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">temp_hdr</span><span class="o">-&gt;</span><span class="n">fh_seq_id</span> <span class="o">!=</span> <span class="n">new_hdr</span><span class="o">-&gt;</span><span class="n">fh_seq_id</span><span class="p">)</span> <span class="o">||</span>
		    <span class="p">(</span><span class="n">temp_hdr</span><span class="o">-&gt;</span><span class="n">fh_ox_id</span> <span class="o">!=</span> <span class="n">new_hdr</span><span class="o">-&gt;</span><span class="n">fh_ox_id</span><span class="p">)</span> <span class="o">||</span>
		    <span class="p">(</span><span class="n">memcmp</span><span class="p">(</span><span class="o">&amp;</span><span class="n">temp_hdr</span><span class="o">-&gt;</span><span class="n">fh_s_id</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">new_hdr</span><span class="o">-&gt;</span><span class="n">fh_s_id</span><span class="p">,</span> <span class="mi">3</span><span class="p">)))</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="cm">/* found a pending sequence that matches this frame */</span>
		<span class="n">seq_dmabuf</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">h_buf</span><span class="p">,</span> <span class="k">struct</span> <span class="n">hbq_dmabuf</span><span class="p">,</span> <span class="n">hbuf</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Free up all the frames from the partially assembled sequence */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">seq_dmabuf</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">d_buf</span><span class="p">,</span> <span class="n">n_buf</span><span class="p">,</span>
					 <span class="o">&amp;</span><span class="n">seq_dmabuf</span><span class="o">-&gt;</span><span class="n">dbuf</span><span class="p">.</span><span class="n">list</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">d_buf</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
			<span class="n">lpfc_in_buf_free</span><span class="p">(</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">phba</span><span class="p">,</span> <span class="n">d_buf</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_sli4_seq_abort_rsp_cmpl - BLS ABORT RSP seq abort iocb complete handler</span>
<span class="cm"> * @phba: Pointer to HBA context object.</span>
<span class="cm"> * @cmd_iocbq: pointer to the command iocbq structure.</span>
<span class="cm"> * @rsp_iocbq: pointer to the response iocbq structure.</span>
<span class="cm"> *</span>
<span class="cm"> * This function handles the sequence abort response iocb command complete</span>
<span class="cm"> * event. It properly releases the memory allocated to the sequence abort</span>
<span class="cm"> * accept iocb.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">lpfc_sli4_seq_abort_rsp_cmpl</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">lpfc_iocbq</span> <span class="o">*</span><span class="n">cmd_iocbq</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">lpfc_iocbq</span> <span class="o">*</span><span class="n">rsp_iocbq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cmd_iocbq</span><span class="p">)</span>
		<span class="n">lpfc_sli_release_iocbq</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">cmd_iocbq</span><span class="p">);</span>

	<span class="cm">/* Failure means BLS ABORT RSP did not get delivered to remote node*/</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rsp_iocbq</span> <span class="o">&amp;&amp;</span> <span class="n">rsp_iocbq</span><span class="o">-&gt;</span><span class="n">iocb</span><span class="p">.</span><span class="n">ulpStatus</span><span class="p">)</span>
		<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_SLI</span><span class="p">,</span>
			<span class="s">&quot;3154 BLS ABORT RSP failed, data:  x%x/x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">rsp_iocbq</span><span class="o">-&gt;</span><span class="n">iocb</span><span class="p">.</span><span class="n">ulpStatus</span><span class="p">,</span>
			<span class="n">rsp_iocbq</span><span class="o">-&gt;</span><span class="n">iocb</span><span class="p">.</span><span class="n">un</span><span class="p">.</span><span class="n">ulpWord</span><span class="p">[</span><span class="mi">4</span><span class="p">]);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_sli4_xri_inrange - check xri is in range of xris owned by driver.</span>
<span class="cm"> * @phba: Pointer to HBA context object.</span>
<span class="cm"> * @xri: xri id in transaction.</span>
<span class="cm"> *</span>
<span class="cm"> * This function validates the xri maps to the known range of XRIs allocated an</span>
<span class="cm"> * used by the driver.</span>
<span class="cm"> **/</span>
<span class="kt">uint16_t</span>
<span class="nf">lpfc_sli4_xri_inrange</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">,</span>
		      <span class="kt">uint16_t</span> <span class="n">xri</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">max_cfg_param</span><span class="p">.</span><span class="n">max_xri</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">xri</span> <span class="o">==</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">xri_ids</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
			<span class="k">return</span> <span class="n">i</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">NO_XRI</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_sli4_seq_abort_rsp - bls rsp to sequence abort</span>
<span class="cm"> * @phba: Pointer to HBA context object.</span>
<span class="cm"> * @fc_hdr: pointer to a FC frame header.</span>
<span class="cm"> *</span>
<span class="cm"> * This function sends a basic response to a previous unsol sequence abort</span>
<span class="cm"> * event after aborting the sequence handling.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">lpfc_sli4_seq_abort_rsp</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">fc_frame_header</span> <span class="o">*</span><span class="n">fc_hdr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpfc_iocbq</span> <span class="o">*</span><span class="n">ctiocb</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_nodelist</span> <span class="o">*</span><span class="n">ndlp</span><span class="p">;</span>
	<span class="kt">uint16_t</span> <span class="n">oxid</span><span class="p">,</span> <span class="n">rxid</span><span class="p">,</span> <span class="n">xri</span><span class="p">,</span> <span class="n">lxri</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">sid</span><span class="p">,</span> <span class="n">fctl</span><span class="p">;</span>
	<span class="n">IOCB_t</span> <span class="o">*</span><span class="n">icmd</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">lpfc_is_link_up</span><span class="p">(</span><span class="n">phba</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">sid</span> <span class="o">=</span> <span class="n">sli4_sid_from_fc_hdr</span><span class="p">(</span><span class="n">fc_hdr</span><span class="p">);</span>
	<span class="n">oxid</span> <span class="o">=</span> <span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">fc_hdr</span><span class="o">-&gt;</span><span class="n">fh_ox_id</span><span class="p">);</span>
	<span class="n">rxid</span> <span class="o">=</span> <span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">fc_hdr</span><span class="o">-&gt;</span><span class="n">fh_rx_id</span><span class="p">);</span>

	<span class="n">ndlp</span> <span class="o">=</span> <span class="n">lpfc_findnode_did</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">pport</span><span class="p">,</span> <span class="n">sid</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ndlp</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_WARNING</span><span class="p">,</span> <span class="n">LOG_ELS</span><span class="p">,</span>
				<span class="s">&quot;1268 Find ndlp returned NULL for oxid:x%x &quot;</span>
				<span class="s">&quot;SID:x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">oxid</span><span class="p">,</span> <span class="n">sid</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Allocate buffer for rsp iocb */</span>
	<span class="n">ctiocb</span> <span class="o">=</span> <span class="n">lpfc_sli_get_iocbq</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ctiocb</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/* Extract the F_CTL field from FC_HDR */</span>
	<span class="n">fctl</span> <span class="o">=</span> <span class="n">sli4_fctl_from_fc_hdr</span><span class="p">(</span><span class="n">fc_hdr</span><span class="p">);</span>

	<span class="n">icmd</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ctiocb</span><span class="o">-&gt;</span><span class="n">iocb</span><span class="p">;</span>
	<span class="n">icmd</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">xseq64</span><span class="p">.</span><span class="n">bdl</span><span class="p">.</span><span class="n">bdeSize</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">icmd</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">xseq64</span><span class="p">.</span><span class="n">bdl</span><span class="p">.</span><span class="n">ulpIoTag32</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">icmd</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">xseq64</span><span class="p">.</span><span class="n">w5</span><span class="p">.</span><span class="n">hcsw</span><span class="p">.</span><span class="n">Dfctl</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">icmd</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">xseq64</span><span class="p">.</span><span class="n">w5</span><span class="p">.</span><span class="n">hcsw</span><span class="p">.</span><span class="n">Rctl</span> <span class="o">=</span> <span class="n">FC_RCTL_BA_ACC</span><span class="p">;</span>
	<span class="n">icmd</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">xseq64</span><span class="p">.</span><span class="n">w5</span><span class="p">.</span><span class="n">hcsw</span><span class="p">.</span><span class="n">Type</span> <span class="o">=</span> <span class="n">FC_TYPE_BLS</span><span class="p">;</span>

	<span class="cm">/* Fill in the rest of iocb fields */</span>
	<span class="n">icmd</span><span class="o">-&gt;</span><span class="n">ulpCommand</span> <span class="o">=</span> <span class="n">CMD_XMIT_BLS_RSP64_CX</span><span class="p">;</span>
	<span class="n">icmd</span><span class="o">-&gt;</span><span class="n">ulpBdeCount</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">icmd</span><span class="o">-&gt;</span><span class="n">ulpLe</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">icmd</span><span class="o">-&gt;</span><span class="n">ulpClass</span> <span class="o">=</span> <span class="n">CLASS3</span><span class="p">;</span>
	<span class="n">icmd</span><span class="o">-&gt;</span><span class="n">ulpContext</span> <span class="o">=</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">rpi_ids</span><span class="p">[</span><span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_rpi</span><span class="p">];</span>
	<span class="n">ctiocb</span><span class="o">-&gt;</span><span class="n">context1</span> <span class="o">=</span> <span class="n">ndlp</span><span class="p">;</span>

	<span class="n">ctiocb</span><span class="o">-&gt;</span><span class="n">iocb_cmpl</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">ctiocb</span><span class="o">-&gt;</span><span class="n">vport</span> <span class="o">=</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">pport</span><span class="p">;</span>
	<span class="n">ctiocb</span><span class="o">-&gt;</span><span class="n">iocb_cmpl</span> <span class="o">=</span> <span class="n">lpfc_sli4_seq_abort_rsp_cmpl</span><span class="p">;</span>
	<span class="n">ctiocb</span><span class="o">-&gt;</span><span class="n">sli4_lxritag</span> <span class="o">=</span> <span class="n">NO_XRI</span><span class="p">;</span>
	<span class="n">ctiocb</span><span class="o">-&gt;</span><span class="n">sli4_xritag</span> <span class="o">=</span> <span class="n">NO_XRI</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">fctl</span> <span class="o">&amp;</span> <span class="n">FC_FC_EX_CTX</span><span class="p">)</span>
		<span class="cm">/* Exchange responder sent the abort so we</span>
<span class="cm">		 * own the oxid.</span>
<span class="cm">		 */</span>
		<span class="n">xri</span> <span class="o">=</span> <span class="n">oxid</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">xri</span> <span class="o">=</span> <span class="n">rxid</span><span class="p">;</span>
	<span class="n">lxri</span> <span class="o">=</span> <span class="n">lpfc_sli4_xri_inrange</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">xri</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">lxri</span> <span class="o">!=</span> <span class="n">NO_XRI</span><span class="p">)</span>
		<span class="n">lpfc_set_rrq_active</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">ndlp</span><span class="p">,</span> <span class="n">lxri</span><span class="p">,</span>
			<span class="p">(</span><span class="n">xri</span> <span class="o">==</span> <span class="n">oxid</span><span class="p">)</span> <span class="o">?</span> <span class="n">rxid</span> <span class="o">:</span> <span class="n">oxid</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="cm">/* If the oxid maps to the FCP XRI range or if it is out of range,</span>
<span class="cm">	 * send a BLS_RJT.  The driver no longer has that exchange.</span>
<span class="cm">	 * Override the IOCB for a BA_RJT.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">xri</span> <span class="o">&gt;</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">max_cfg_param</span><span class="p">.</span><span class="n">max_xri</span> <span class="o">+</span>
		    <span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">max_cfg_param</span><span class="p">.</span><span class="n">xri_base</span><span class="p">)</span> <span class="o">||</span>
	    <span class="n">xri</span> <span class="o">&gt;</span> <span class="p">(</span><span class="n">lpfc_sli4_get_els_iocb_cnt</span><span class="p">(</span><span class="n">phba</span><span class="p">)</span> <span class="o">+</span>
		    <span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">max_cfg_param</span><span class="p">.</span><span class="n">xri_base</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">icmd</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">xseq64</span><span class="p">.</span><span class="n">w5</span><span class="p">.</span><span class="n">hcsw</span><span class="p">.</span><span class="n">Rctl</span> <span class="o">=</span> <span class="n">FC_RCTL_BA_RJT</span><span class="p">;</span>
		<span class="n">bf_set</span><span class="p">(</span><span class="n">lpfc_vndr_code</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">icmd</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">bls_rsp</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">bf_set</span><span class="p">(</span><span class="n">lpfc_rsn_expln</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">icmd</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">bls_rsp</span><span class="p">,</span> <span class="n">FC_BA_RJT_INV_XID</span><span class="p">);</span>
		<span class="n">bf_set</span><span class="p">(</span><span class="n">lpfc_rsn_code</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">icmd</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">bls_rsp</span><span class="p">,</span> <span class="n">FC_BA_RJT_UNABLE</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">fctl</span> <span class="o">&amp;</span> <span class="n">FC_FC_EX_CTX</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* ABTS sent by responder to CT exchange, construction</span>
<span class="cm">		 * of BA_ACC will use OX_ID from ABTS for the XRI_TAG</span>
<span class="cm">		 * field and RX_ID from ABTS for RX_ID field.</span>
<span class="cm">		 */</span>
		<span class="n">bf_set</span><span class="p">(</span><span class="n">lpfc_abts_orig</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">icmd</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">bls_rsp</span><span class="p">,</span> <span class="n">LPFC_ABTS_UNSOL_RSP</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* ABTS sent by initiator to CT exchange, construction</span>
<span class="cm">		 * of BA_ACC will need to allocate a new XRI as for the</span>
<span class="cm">		 * XRI_TAG field.</span>
<span class="cm">		 */</span>
		<span class="n">bf_set</span><span class="p">(</span><span class="n">lpfc_abts_orig</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">icmd</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">bls_rsp</span><span class="p">,</span> <span class="n">LPFC_ABTS_UNSOL_INT</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">bf_set</span><span class="p">(</span><span class="n">lpfc_abts_rxid</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">icmd</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">bls_rsp</span><span class="p">,</span> <span class="n">rxid</span><span class="p">);</span>
	<span class="n">bf_set</span><span class="p">(</span><span class="n">lpfc_abts_oxid</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">icmd</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">bls_rsp</span><span class="p">,</span> <span class="n">oxid</span><span class="p">);</span>

	<span class="cm">/* Xmit CT abts response on exchange &lt;xid&gt; */</span>
	<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_INFO</span><span class="p">,</span> <span class="n">LOG_ELS</span><span class="p">,</span>
			<span class="s">&quot;1200 Send BLS cmd x%x on oxid x%x Data: x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">icmd</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">xseq64</span><span class="p">.</span><span class="n">w5</span><span class="p">.</span><span class="n">hcsw</span><span class="p">.</span><span class="n">Rctl</span><span class="p">,</span> <span class="n">oxid</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">link_state</span><span class="p">);</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">lpfc_sli_issue_iocb</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">LPFC_ELS_RING</span><span class="p">,</span> <span class="n">ctiocb</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">==</span> <span class="n">IOCB_ERROR</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_ELS</span><span class="p">,</span>
				<span class="s">&quot;2925 Failed to issue CT ABTS RSP x%x on &quot;</span>
				<span class="s">&quot;xri x%x, Data x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">icmd</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">xseq64</span><span class="p">.</span><span class="n">w5</span><span class="p">.</span><span class="n">hcsw</span><span class="p">.</span><span class="n">Rctl</span><span class="p">,</span> <span class="n">oxid</span><span class="p">,</span>
				<span class="n">phba</span><span class="o">-&gt;</span><span class="n">link_state</span><span class="p">);</span>
		<span class="n">lpfc_sli_release_iocbq</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">ctiocb</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_sli4_handle_unsol_abort - Handle sli-4 unsolicited abort event</span>
<span class="cm"> * @vport: Pointer to the vport on which this sequence was received</span>
<span class="cm"> * @dmabuf: pointer to a dmabuf that describes the FC sequence</span>
<span class="cm"> *</span>
<span class="cm"> * This function handles an SLI-4 unsolicited abort event. If the unsolicited</span>
<span class="cm"> * receive sequence is only partially assembed by the driver, it shall abort</span>
<span class="cm"> * the partially assembled frames for the sequence. Otherwise, if the</span>
<span class="cm"> * unsolicited receive sequence has been completely assembled and passed to</span>
<span class="cm"> * the Upper Layer Protocol (UPL), it then mark the per oxid status for the</span>
<span class="cm"> * unsolicited sequence has been aborted. After that, it will issue a basic</span>
<span class="cm"> * accept to accept the abort.</span>
<span class="cm"> **/</span>
<span class="kt">void</span>
<span class="nf">lpfc_sli4_handle_unsol_abort</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="n">vport</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">hbq_dmabuf</span> <span class="o">*</span><span class="n">dmabuf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span> <span class="o">=</span> <span class="n">vport</span><span class="o">-&gt;</span><span class="n">phba</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fc_frame_header</span> <span class="n">fc_hdr</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">fctl</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">abts_par</span><span class="p">;</span>

	<span class="cm">/* Make a copy of fc_hdr before the dmabuf being released */</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fc_hdr</span><span class="p">,</span> <span class="n">dmabuf</span><span class="o">-&gt;</span><span class="n">hbuf</span><span class="p">.</span><span class="n">virt</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">fc_frame_header</span><span class="p">));</span>
	<span class="n">fctl</span> <span class="o">=</span> <span class="n">sli4_fctl_from_fc_hdr</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fc_hdr</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">fctl</span> <span class="o">&amp;</span> <span class="n">FC_FC_EX_CTX</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * ABTS sent by responder to exchange, just free the buffer</span>
<span class="cm">		 */</span>
		<span class="n">lpfc_in_buf_free</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dmabuf</span><span class="o">-&gt;</span><span class="n">dbuf</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * ABTS sent by initiator to exchange, need to do cleanup</span>
<span class="cm">		 */</span>
		<span class="cm">/* Try to abort partially assembled seq */</span>
		<span class="n">abts_par</span> <span class="o">=</span> <span class="n">lpfc_sli4_abort_partial_seq</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">dmabuf</span><span class="p">);</span>

		<span class="cm">/* Send abort to ULP if partially seq abort failed */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">abts_par</span> <span class="o">==</span> <span class="nb">false</span><span class="p">)</span>
			<span class="n">lpfc_sli4_send_seq_to_ulp</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">dmabuf</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">lpfc_in_buf_free</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dmabuf</span><span class="o">-&gt;</span><span class="n">dbuf</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="cm">/* Send basic accept (BA_ACC) to the abort requester */</span>
	<span class="n">lpfc_sli4_seq_abort_rsp</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fc_hdr</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_seq_complete - Indicates if a sequence is complete</span>
<span class="cm"> * @dmabuf: pointer to a dmabuf that describes the FC sequence</span>
<span class="cm"> *</span>
<span class="cm"> * This function checks the sequence, starting with the frame described by</span>
<span class="cm"> * @dmabuf, to see if all the frames associated with this sequence are present.</span>
<span class="cm"> * the frames associated with this sequence are linked to the @dmabuf using the</span>
<span class="cm"> * dbuf list. This function looks for two major things. 1) That the first frame</span>
<span class="cm"> * has a sequence count of zero. 2) There is a frame with last frame of sequence</span>
<span class="cm"> * set. 3) That there are no holes in the sequence count. The function will</span>
<span class="cm"> * return 1 when the sequence is complete, otherwise it will return 0.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">lpfc_seq_complete</span><span class="p">(</span><span class="k">struct</span> <span class="n">hbq_dmabuf</span> <span class="o">*</span><span class="n">dmabuf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fc_frame_header</span> <span class="o">*</span><span class="n">hdr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_dmabuf</span> <span class="o">*</span><span class="n">d_buf</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">hbq_dmabuf</span> <span class="o">*</span><span class="n">seq_dmabuf</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">fctl</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">seq_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">hdr</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">fc_frame_header</span> <span class="o">*</span><span class="p">)</span><span class="n">dmabuf</span><span class="o">-&gt;</span><span class="n">hbuf</span><span class="p">.</span><span class="n">virt</span><span class="p">;</span>
	<span class="cm">/* make sure first fame of sequence has a sequence count of zero */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">fh_seq_cnt</span> <span class="o">!=</span> <span class="n">seq_count</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">fctl</span> <span class="o">=</span> <span class="p">(</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">fh_f_ctl</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span> <span class="o">|</span>
		<span class="n">hdr</span><span class="o">-&gt;</span><span class="n">fh_f_ctl</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span> <span class="o">|</span>
		<span class="n">hdr</span><span class="o">-&gt;</span><span class="n">fh_f_ctl</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span>
	<span class="cm">/* If last frame of sequence we can return success. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">fctl</span> <span class="o">&amp;</span> <span class="n">FC_FC_END_SEQ</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">d_buf</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dmabuf</span><span class="o">-&gt;</span><span class="n">dbuf</span><span class="p">.</span><span class="n">list</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">seq_dmabuf</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">d_buf</span><span class="p">,</span> <span class="k">struct</span> <span class="n">hbq_dmabuf</span><span class="p">,</span> <span class="n">dbuf</span><span class="p">);</span>
		<span class="n">hdr</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">fc_frame_header</span> <span class="o">*</span><span class="p">)</span><span class="n">seq_dmabuf</span><span class="o">-&gt;</span><span class="n">hbuf</span><span class="p">.</span><span class="n">virt</span><span class="p">;</span>
		<span class="cm">/* If there is a hole in the sequence count then fail. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">++</span><span class="n">seq_count</span> <span class="o">!=</span> <span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">fh_seq_cnt</span><span class="p">))</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">fctl</span> <span class="o">=</span> <span class="p">(</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">fh_f_ctl</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span> <span class="o">|</span>
			<span class="n">hdr</span><span class="o">-&gt;</span><span class="n">fh_f_ctl</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span> <span class="o">|</span>
			<span class="n">hdr</span><span class="o">-&gt;</span><span class="n">fh_f_ctl</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span>
		<span class="cm">/* If last frame of sequence we can return success. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">fctl</span> <span class="o">&amp;</span> <span class="n">FC_FC_END_SEQ</span><span class="p">)</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_prep_seq - Prep sequence for ULP processing</span>
<span class="cm"> * @vport: Pointer to the vport on which this sequence was received</span>
<span class="cm"> * @dmabuf: pointer to a dmabuf that describes the FC sequence</span>
<span class="cm"> *</span>
<span class="cm"> * This function takes a sequence, described by a list of frames, and creates</span>
<span class="cm"> * a list of iocbq structures to describe the sequence. This iocbq list will be</span>
<span class="cm"> * used to issue to the generic unsolicited sequence handler. This routine</span>
<span class="cm"> * returns a pointer to the first iocbq in the list. If the function is unable</span>
<span class="cm"> * to allocate an iocbq then it throw out the received frames that were not</span>
<span class="cm"> * able to be described and return a pointer to the first iocbq. If unable to</span>
<span class="cm"> * allocate any iocbqs (including the first) this function will return NULL.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">lpfc_iocbq</span> <span class="o">*</span>
<span class="nf">lpfc_prep_seq</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="n">vport</span><span class="p">,</span> <span class="k">struct</span> <span class="n">hbq_dmabuf</span> <span class="o">*</span><span class="n">seq_dmabuf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">hbq_dmabuf</span> <span class="o">*</span><span class="n">hbq_buf</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_dmabuf</span> <span class="o">*</span><span class="n">d_buf</span><span class="p">,</span> <span class="o">*</span><span class="n">n_buf</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_iocbq</span> <span class="o">*</span><span class="n">first_iocbq</span><span class="p">,</span> <span class="o">*</span><span class="n">iocbq</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fc_frame_header</span> <span class="o">*</span><span class="n">fc_hdr</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">sid</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">len</span><span class="p">,</span> <span class="n">tot_len</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ulp_bde64</span> <span class="o">*</span><span class="n">pbde</span><span class="p">;</span>

	<span class="n">fc_hdr</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">fc_frame_header</span> <span class="o">*</span><span class="p">)</span><span class="n">seq_dmabuf</span><span class="o">-&gt;</span><span class="n">hbuf</span><span class="p">.</span><span class="n">virt</span><span class="p">;</span>
	<span class="cm">/* remove from receive buffer list */</span>
	<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">seq_dmabuf</span><span class="o">-&gt;</span><span class="n">hbuf</span><span class="p">.</span><span class="n">list</span><span class="p">);</span>
	<span class="n">lpfc_update_rcv_time_stamp</span><span class="p">(</span><span class="n">vport</span><span class="p">);</span>
	<span class="cm">/* get the Remote Port&#39;s SID */</span>
	<span class="n">sid</span> <span class="o">=</span> <span class="n">sli4_sid_from_fc_hdr</span><span class="p">(</span><span class="n">fc_hdr</span><span class="p">);</span>
	<span class="n">tot_len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="cm">/* Get an iocbq struct to fill in. */</span>
	<span class="n">first_iocbq</span> <span class="o">=</span> <span class="n">lpfc_sli_get_iocbq</span><span class="p">(</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">phba</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">first_iocbq</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Initialize the first IOCB. */</span>
		<span class="n">first_iocbq</span><span class="o">-&gt;</span><span class="n">iocb</span><span class="p">.</span><span class="n">unsli3</span><span class="p">.</span><span class="n">rcvsli3</span><span class="p">.</span><span class="n">acc_len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">first_iocbq</span><span class="o">-&gt;</span><span class="n">iocb</span><span class="p">.</span><span class="n">ulpStatus</span> <span class="o">=</span> <span class="n">IOSTAT_SUCCESS</span><span class="p">;</span>

		<span class="cm">/* Check FC Header to see what TYPE of frame we are rcv&#39;ing */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sli4_type_from_fc_hdr</span><span class="p">(</span><span class="n">fc_hdr</span><span class="p">)</span> <span class="o">==</span> <span class="n">FC_TYPE_ELS</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">first_iocbq</span><span class="o">-&gt;</span><span class="n">iocb</span><span class="p">.</span><span class="n">ulpCommand</span> <span class="o">=</span> <span class="n">CMD_IOCB_RCV_ELS64_CX</span><span class="p">;</span>
			<span class="n">first_iocbq</span><span class="o">-&gt;</span><span class="n">iocb</span><span class="p">.</span><span class="n">un</span><span class="p">.</span><span class="n">rcvels</span><span class="p">.</span><span class="n">parmRo</span> <span class="o">=</span>
				<span class="n">sli4_did_from_fc_hdr</span><span class="p">(</span><span class="n">fc_hdr</span><span class="p">);</span>
			<span class="n">first_iocbq</span><span class="o">-&gt;</span><span class="n">iocb</span><span class="p">.</span><span class="n">ulpPU</span> <span class="o">=</span> <span class="n">PARM_NPIV_DID</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="n">first_iocbq</span><span class="o">-&gt;</span><span class="n">iocb</span><span class="p">.</span><span class="n">ulpCommand</span> <span class="o">=</span> <span class="n">CMD_IOCB_RCV_SEQ64_CX</span><span class="p">;</span>
		<span class="n">first_iocbq</span><span class="o">-&gt;</span><span class="n">iocb</span><span class="p">.</span><span class="n">ulpContext</span> <span class="o">=</span> <span class="n">NO_XRI</span><span class="p">;</span>
		<span class="n">first_iocbq</span><span class="o">-&gt;</span><span class="n">iocb</span><span class="p">.</span><span class="n">unsli3</span><span class="p">.</span><span class="n">rcvsli3</span><span class="p">.</span><span class="n">ox_id</span> <span class="o">=</span>
			<span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">fc_hdr</span><span class="o">-&gt;</span><span class="n">fh_ox_id</span><span class="p">);</span>
		<span class="cm">/* iocbq is prepped for internal consumption.  Physical vpi. */</span>
		<span class="n">first_iocbq</span><span class="o">-&gt;</span><span class="n">iocb</span><span class="p">.</span><span class="n">unsli3</span><span class="p">.</span><span class="n">rcvsli3</span><span class="p">.</span><span class="n">vpi</span> <span class="o">=</span>
			<span class="n">vport</span><span class="o">-&gt;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">vpi_ids</span><span class="p">[</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">vpi</span><span class="p">];</span>
		<span class="cm">/* put the first buffer into the first IOCBq */</span>
		<span class="n">first_iocbq</span><span class="o">-&gt;</span><span class="n">context2</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">seq_dmabuf</span><span class="o">-&gt;</span><span class="n">dbuf</span><span class="p">;</span>
		<span class="n">first_iocbq</span><span class="o">-&gt;</span><span class="n">context3</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">first_iocbq</span><span class="o">-&gt;</span><span class="n">iocb</span><span class="p">.</span><span class="n">ulpBdeCount</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">first_iocbq</span><span class="o">-&gt;</span><span class="n">iocb</span><span class="p">.</span><span class="n">un</span><span class="p">.</span><span class="n">cont64</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">tus</span><span class="p">.</span><span class="n">f</span><span class="p">.</span><span class="n">bdeSize</span> <span class="o">=</span>
							<span class="n">LPFC_DATA_BUF_SIZE</span><span class="p">;</span>
		<span class="n">first_iocbq</span><span class="o">-&gt;</span><span class="n">iocb</span><span class="p">.</span><span class="n">un</span><span class="p">.</span><span class="n">rcvels</span><span class="p">.</span><span class="n">remoteID</span> <span class="o">=</span> <span class="n">sid</span><span class="p">;</span>
		<span class="n">tot_len</span> <span class="o">=</span> <span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_rcqe_length</span><span class="p">,</span>
				       <span class="o">&amp;</span><span class="n">seq_dmabuf</span><span class="o">-&gt;</span><span class="n">cq_event</span><span class="p">.</span><span class="n">cqe</span><span class="p">.</span><span class="n">rcqe_cmpl</span><span class="p">);</span>
		<span class="n">first_iocbq</span><span class="o">-&gt;</span><span class="n">iocb</span><span class="p">.</span><span class="n">unsli3</span><span class="p">.</span><span class="n">rcvsli3</span><span class="p">.</span><span class="n">acc_len</span> <span class="o">=</span> <span class="n">tot_len</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">iocbq</span> <span class="o">=</span> <span class="n">first_iocbq</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * Each IOCBq can have two Buffers assigned, so go through the list</span>
<span class="cm">	 * of buffers for this sequence and save two buffers in each IOCBq</span>
<span class="cm">	 */</span>
	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">d_buf</span><span class="p">,</span> <span class="n">n_buf</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">seq_dmabuf</span><span class="o">-&gt;</span><span class="n">dbuf</span><span class="p">.</span><span class="n">list</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">iocbq</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">lpfc_in_buf_free</span><span class="p">(</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">phba</span><span class="p">,</span> <span class="n">d_buf</span><span class="p">);</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">iocbq</span><span class="o">-&gt;</span><span class="n">context3</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">iocbq</span><span class="o">-&gt;</span><span class="n">context3</span> <span class="o">=</span> <span class="n">d_buf</span><span class="p">;</span>
			<span class="n">iocbq</span><span class="o">-&gt;</span><span class="n">iocb</span><span class="p">.</span><span class="n">ulpBdeCount</span><span class="o">++</span><span class="p">;</span>
			<span class="n">pbde</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ulp_bde64</span> <span class="o">*</span><span class="p">)</span>
					<span class="o">&amp;</span><span class="n">iocbq</span><span class="o">-&gt;</span><span class="n">iocb</span><span class="p">.</span><span class="n">unsli3</span><span class="p">.</span><span class="n">sli3Words</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
			<span class="n">pbde</span><span class="o">-&gt;</span><span class="n">tus</span><span class="p">.</span><span class="n">f</span><span class="p">.</span><span class="n">bdeSize</span> <span class="o">=</span> <span class="n">LPFC_DATA_BUF_SIZE</span><span class="p">;</span>

			<span class="cm">/* We need to get the size out of the right CQE */</span>
			<span class="n">hbq_buf</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">d_buf</span><span class="p">,</span> <span class="k">struct</span> <span class="n">hbq_dmabuf</span><span class="p">,</span> <span class="n">dbuf</span><span class="p">);</span>
			<span class="n">len</span> <span class="o">=</span> <span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_rcqe_length</span><span class="p">,</span>
				       <span class="o">&amp;</span><span class="n">hbq_buf</span><span class="o">-&gt;</span><span class="n">cq_event</span><span class="p">.</span><span class="n">cqe</span><span class="p">.</span><span class="n">rcqe_cmpl</span><span class="p">);</span>
			<span class="n">iocbq</span><span class="o">-&gt;</span><span class="n">iocb</span><span class="p">.</span><span class="n">unsli3</span><span class="p">.</span><span class="n">rcvsli3</span><span class="p">.</span><span class="n">acc_len</span> <span class="o">+=</span> <span class="n">len</span><span class="p">;</span>
			<span class="n">tot_len</span> <span class="o">+=</span> <span class="n">len</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">iocbq</span> <span class="o">=</span> <span class="n">lpfc_sli_get_iocbq</span><span class="p">(</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">phba</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">iocbq</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">first_iocbq</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">first_iocbq</span><span class="o">-&gt;</span><span class="n">iocb</span><span class="p">.</span><span class="n">ulpStatus</span> <span class="o">=</span>
							<span class="n">IOSTAT_FCP_RSP_ERROR</span><span class="p">;</span>
					<span class="n">first_iocbq</span><span class="o">-&gt;</span><span class="n">iocb</span><span class="p">.</span><span class="n">un</span><span class="p">.</span><span class="n">ulpWord</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span>
							<span class="n">IOERR_NO_RESOURCES</span><span class="p">;</span>
				<span class="p">}</span>
				<span class="n">lpfc_in_buf_free</span><span class="p">(</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">phba</span><span class="p">,</span> <span class="n">d_buf</span><span class="p">);</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">iocbq</span><span class="o">-&gt;</span><span class="n">context2</span> <span class="o">=</span> <span class="n">d_buf</span><span class="p">;</span>
			<span class="n">iocbq</span><span class="o">-&gt;</span><span class="n">context3</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="n">iocbq</span><span class="o">-&gt;</span><span class="n">iocb</span><span class="p">.</span><span class="n">ulpBdeCount</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">iocbq</span><span class="o">-&gt;</span><span class="n">iocb</span><span class="p">.</span><span class="n">un</span><span class="p">.</span><span class="n">cont64</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">tus</span><span class="p">.</span><span class="n">f</span><span class="p">.</span><span class="n">bdeSize</span> <span class="o">=</span>
							<span class="n">LPFC_DATA_BUF_SIZE</span><span class="p">;</span>

			<span class="cm">/* We need to get the size out of the right CQE */</span>
			<span class="n">hbq_buf</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">d_buf</span><span class="p">,</span> <span class="k">struct</span> <span class="n">hbq_dmabuf</span><span class="p">,</span> <span class="n">dbuf</span><span class="p">);</span>
			<span class="n">len</span> <span class="o">=</span> <span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_rcqe_length</span><span class="p">,</span>
				       <span class="o">&amp;</span><span class="n">hbq_buf</span><span class="o">-&gt;</span><span class="n">cq_event</span><span class="p">.</span><span class="n">cqe</span><span class="p">.</span><span class="n">rcqe_cmpl</span><span class="p">);</span>
			<span class="n">tot_len</span> <span class="o">+=</span> <span class="n">len</span><span class="p">;</span>
			<span class="n">iocbq</span><span class="o">-&gt;</span><span class="n">iocb</span><span class="p">.</span><span class="n">unsli3</span><span class="p">.</span><span class="n">rcvsli3</span><span class="p">.</span><span class="n">acc_len</span> <span class="o">=</span> <span class="n">tot_len</span><span class="p">;</span>

			<span class="n">iocbq</span><span class="o">-&gt;</span><span class="n">iocb</span><span class="p">.</span><span class="n">un</span><span class="p">.</span><span class="n">rcvels</span><span class="p">.</span><span class="n">remoteID</span> <span class="o">=</span> <span class="n">sid</span><span class="p">;</span>
			<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iocbq</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">first_iocbq</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">first_iocbq</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">lpfc_sli4_send_seq_to_ulp</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="n">vport</span><span class="p">,</span>
			  <span class="k">struct</span> <span class="n">hbq_dmabuf</span> <span class="o">*</span><span class="n">seq_dmabuf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fc_frame_header</span> <span class="o">*</span><span class="n">fc_hdr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_iocbq</span> <span class="o">*</span><span class="n">iocbq</span><span class="p">,</span> <span class="o">*</span><span class="n">curr_iocb</span><span class="p">,</span> <span class="o">*</span><span class="n">next_iocb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span> <span class="o">=</span> <span class="n">vport</span><span class="o">-&gt;</span><span class="n">phba</span><span class="p">;</span>

	<span class="n">fc_hdr</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">fc_frame_header</span> <span class="o">*</span><span class="p">)</span><span class="n">seq_dmabuf</span><span class="o">-&gt;</span><span class="n">hbuf</span><span class="p">.</span><span class="n">virt</span><span class="p">;</span>
	<span class="n">iocbq</span> <span class="o">=</span> <span class="n">lpfc_prep_seq</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">seq_dmabuf</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">iocbq</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_SLI</span><span class="p">,</span>
				<span class="s">&quot;2707 Ring %d handler: Failed to allocate &quot;</span>
				<span class="s">&quot;iocb Rctl x%x Type x%x received</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">LPFC_ELS_RING</span><span class="p">,</span>
				<span class="n">fc_hdr</span><span class="o">-&gt;</span><span class="n">fh_r_ctl</span><span class="p">,</span> <span class="n">fc_hdr</span><span class="o">-&gt;</span><span class="n">fh_type</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">lpfc_complete_unsol_iocb</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span>
				      <span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli</span><span class="p">.</span><span class="n">ring</span><span class="p">[</span><span class="n">LPFC_ELS_RING</span><span class="p">],</span>
				      <span class="n">iocbq</span><span class="p">,</span> <span class="n">fc_hdr</span><span class="o">-&gt;</span><span class="n">fh_r_ctl</span><span class="p">,</span>
				      <span class="n">fc_hdr</span><span class="o">-&gt;</span><span class="n">fh_type</span><span class="p">))</span>
		<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_SLI</span><span class="p">,</span>
				<span class="s">&quot;2540 Ring %d handler: unexpected Rctl &quot;</span>
				<span class="s">&quot;x%x Type x%x received</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">LPFC_ELS_RING</span><span class="p">,</span>
				<span class="n">fc_hdr</span><span class="o">-&gt;</span><span class="n">fh_r_ctl</span><span class="p">,</span> <span class="n">fc_hdr</span><span class="o">-&gt;</span><span class="n">fh_type</span><span class="p">);</span>

	<span class="cm">/* Free iocb created in lpfc_prep_seq */</span>
	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">curr_iocb</span><span class="p">,</span> <span class="n">next_iocb</span><span class="p">,</span>
		<span class="o">&amp;</span><span class="n">iocbq</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">curr_iocb</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
		<span class="n">lpfc_sli_release_iocbq</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">curr_iocb</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">lpfc_sli_release_iocbq</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">iocbq</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_sli4_handle_received_buffer - Handle received buffers from firmware</span>
<span class="cm"> * @phba: Pointer to HBA context object.</span>
<span class="cm"> *</span>
<span class="cm"> * This function is called with no lock held. This function processes all</span>
<span class="cm"> * the received buffers and gives it to upper layers when a received buffer</span>
<span class="cm"> * indicates that it is the final frame in the sequence. The interrupt</span>
<span class="cm"> * service routine processes received buffers at interrupt contexts and adds</span>
<span class="cm"> * received dma buffers to the rb_pend_list queue and signals the worker thread.</span>
<span class="cm"> * Worker thread calls lpfc_sli4_handle_received_buffer, which will call the</span>
<span class="cm"> * appropriate receive function when the final frame in a sequence is received.</span>
<span class="cm"> **/</span>
<span class="kt">void</span>
<span class="nf">lpfc_sli4_handle_received_buffer</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">hbq_dmabuf</span> <span class="o">*</span><span class="n">dmabuf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">hbq_dmabuf</span> <span class="o">*</span><span class="n">seq_dmabuf</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fc_frame_header</span> <span class="o">*</span><span class="n">fc_hdr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="n">vport</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">fcfi</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">did</span><span class="p">;</span>

	<span class="cm">/* Process each received buffer */</span>
	<span class="n">fc_hdr</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">fc_frame_header</span> <span class="o">*</span><span class="p">)</span><span class="n">dmabuf</span><span class="o">-&gt;</span><span class="n">hbuf</span><span class="p">.</span><span class="n">virt</span><span class="p">;</span>
	<span class="cm">/* check to see if this a valid type of frame */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">lpfc_fc_frame_check</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">fc_hdr</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">lpfc_in_buf_free</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dmabuf</span><span class="o">-&gt;</span><span class="n">dbuf</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_cqe_code</span><span class="p">,</span>
		    <span class="o">&amp;</span><span class="n">dmabuf</span><span class="o">-&gt;</span><span class="n">cq_event</span><span class="p">.</span><span class="n">cqe</span><span class="p">.</span><span class="n">rcqe_cmpl</span><span class="p">)</span> <span class="o">==</span> <span class="n">CQE_CODE_RECEIVE_V1</span><span class="p">))</span>
		<span class="n">fcfi</span> <span class="o">=</span> <span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_rcqe_fcf_id_v1</span><span class="p">,</span>
			      <span class="o">&amp;</span><span class="n">dmabuf</span><span class="o">-&gt;</span><span class="n">cq_event</span><span class="p">.</span><span class="n">cqe</span><span class="p">.</span><span class="n">rcqe_cmpl</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">fcfi</span> <span class="o">=</span> <span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_rcqe_fcf_id</span><span class="p">,</span>
			      <span class="o">&amp;</span><span class="n">dmabuf</span><span class="o">-&gt;</span><span class="n">cq_event</span><span class="p">.</span><span class="n">cqe</span><span class="p">.</span><span class="n">rcqe_cmpl</span><span class="p">);</span>

	<span class="n">vport</span> <span class="o">=</span> <span class="n">lpfc_fc_frame_to_vport</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">fc_hdr</span><span class="p">,</span> <span class="n">fcfi</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">vport</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* throw out the frame */</span>
		<span class="n">lpfc_in_buf_free</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dmabuf</span><span class="o">-&gt;</span><span class="n">dbuf</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* d_id this frame is directed to */</span>
	<span class="n">did</span> <span class="o">=</span> <span class="n">sli4_did_from_fc_hdr</span><span class="p">(</span><span class="n">fc_hdr</span><span class="p">);</span>

	<span class="cm">/* vport is registered unless we rcv a FLOGI directed to Fabric_DID */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">vpi_state</span> <span class="o">&amp;</span> <span class="n">LPFC_VPI_REGISTERED</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		<span class="p">(</span><span class="n">did</span> <span class="o">!=</span> <span class="n">Fabric_DID</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Throw out the frame if we are not pt2pt.</span>
<span class="cm">		 * The pt2pt protocol allows for discovery frames</span>
<span class="cm">		 * to be received without a registered VPI.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_flag</span> <span class="o">&amp;</span> <span class="n">FC_PT2PT</span><span class="p">)</span> <span class="o">||</span>
			<span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">link_state</span> <span class="o">==</span> <span class="n">LPFC_HBA_READY</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">lpfc_in_buf_free</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dmabuf</span><span class="o">-&gt;</span><span class="n">dbuf</span><span class="p">);</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* Handle the basic abort sequence (BA_ABTS) event */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">fc_hdr</span><span class="o">-&gt;</span><span class="n">fh_r_ctl</span> <span class="o">==</span> <span class="n">FC_RCTL_BA_ABTS</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lpfc_sli4_handle_unsol_abort</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">dmabuf</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Link this frame */</span>
	<span class="n">seq_dmabuf</span> <span class="o">=</span> <span class="n">lpfc_fc_frame_add</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">dmabuf</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">seq_dmabuf</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* unable to add frame to vport - throw it out */</span>
		<span class="n">lpfc_in_buf_free</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dmabuf</span><span class="o">-&gt;</span><span class="n">dbuf</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* If not last frame in sequence continue processing frames. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">lpfc_seq_complete</span><span class="p">(</span><span class="n">seq_dmabuf</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/* Send the complete sequence to the upper layer protocol */</span>
	<span class="n">lpfc_sli4_send_seq_to_ulp</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">seq_dmabuf</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_sli4_post_all_rpi_hdrs - Post the rpi header memory region to the port</span>
<span class="cm"> * @phba: pointer to lpfc hba data structure.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine is invoked to post rpi header templates to the</span>
<span class="cm"> * HBA consistent with the SLI-4 interface spec.  This routine</span>
<span class="cm"> * posts a SLI4_PAGE_SIZE memory region to the port to hold up to</span>
<span class="cm"> * SLI4_PAGE_SIZE modulo 64 rpi context headers.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine does not require any locks.  It&#39;s usage is expected</span>
<span class="cm"> * to be driver load or reset recovery when the driver is</span>
<span class="cm"> * sequential.</span>
<span class="cm"> *</span>
<span class="cm"> * Return codes</span>
<span class="cm"> * 	0 - successful</span>
<span class="cm"> *      -EIO - The mailbox failed to complete successfully.</span>
<span class="cm"> * 	When this error occurs, the driver is not guaranteed</span>
<span class="cm"> *	to have any rpi regions posted to the device and</span>
<span class="cm"> *	must either attempt to repost the regions or take a</span>
<span class="cm"> *	fatal error.</span>
<span class="cm"> **/</span>
<span class="kt">int</span>
<span class="nf">lpfc_sli4_post_all_rpi_hdrs</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpfc_rpi_hdr</span> <span class="o">*</span><span class="n">rpi_page</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">uint16_t</span> <span class="n">lrpi</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* SLI4 ports that support extents do not require RPI headers. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">rpi_hdrs_in_use</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">exit</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">extents_in_use</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>

	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">rpi_page</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">lpfc_rpi_hdr_list</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Assign the rpi headers a physical rpi only if the driver</span>
<span class="cm">		 * has not initialized those resources.  A port reset only</span>
<span class="cm">		 * needs the headers posted.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_rpi_rsrc_rdy</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">sli4_flags</span><span class="p">)</span> <span class="o">!=</span>
		    <span class="n">LPFC_RPI_RSRC_RDY</span><span class="p">)</span>
			<span class="n">rpi_page</span><span class="o">-&gt;</span><span class="n">start_rpi</span> <span class="o">=</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">rpi_ids</span><span class="p">[</span><span class="n">lrpi</span><span class="p">];</span>

		<span class="n">rc</span> <span class="o">=</span> <span class="n">lpfc_sli4_post_rpi_hdr</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">rpi_page</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">!=</span> <span class="n">MBX_SUCCESS</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_SLI</span><span class="p">,</span>
					<span class="s">&quot;2008 Error %d posting all rpi &quot;</span>
					<span class="s">&quot;headers</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">rc</span><span class="p">);</span>
			<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

 <span class="nl">exit:</span>
	<span class="n">bf_set</span><span class="p">(</span><span class="n">lpfc_rpi_rsrc_rdy</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">sli4_flags</span><span class="p">,</span>
	       <span class="n">LPFC_RPI_RSRC_RDY</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_sli4_post_rpi_hdr - Post an rpi header memory region to the port</span>
<span class="cm"> * @phba: pointer to lpfc hba data structure.</span>
<span class="cm"> * @rpi_page:  pointer to the rpi memory region.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine is invoked to post a single rpi header to the</span>
<span class="cm"> * HBA consistent with the SLI-4 interface spec.  This memory region</span>
<span class="cm"> * maps up to 64 rpi context regions.</span>
<span class="cm"> *</span>
<span class="cm"> * Return codes</span>
<span class="cm"> * 	0 - successful</span>
<span class="cm"> * 	-ENOMEM - No available memory</span>
<span class="cm"> *      -EIO - The mailbox failed to complete successfully.</span>
<span class="cm"> **/</span>
<span class="kt">int</span>
<span class="nf">lpfc_sli4_post_rpi_hdr</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">,</span> <span class="k">struct</span> <span class="n">lpfc_rpi_hdr</span> <span class="o">*</span><span class="n">rpi_page</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">LPFC_MBOXQ_t</span> <span class="o">*</span><span class="n">mboxq</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_mbx_post_hdr_tmpl</span> <span class="o">*</span><span class="n">hdr_tmpl</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">shdr_status</span><span class="p">,</span> <span class="n">shdr_add_status</span><span class="p">;</span>
	<span class="k">union</span> <span class="n">lpfc_sli4_cfg_shdr</span> <span class="o">*</span><span class="n">shdr</span><span class="p">;</span>

	<span class="cm">/* SLI4 ports that support extents do not require RPI headers. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">rpi_hdrs_in_use</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">extents_in_use</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>

	<span class="cm">/* The port is notified of the header region via a mailbox command. */</span>
	<span class="n">mboxq</span> <span class="o">=</span> <span class="p">(</span><span class="n">LPFC_MBOXQ_t</span> <span class="o">*</span><span class="p">)</span> <span class="n">mempool_alloc</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">mbox_mem_pool</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mboxq</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_SLI</span><span class="p">,</span>
				<span class="s">&quot;2001 Unable to allocate memory for issuing &quot;</span>
				<span class="s">&quot;SLI_CONFIG_SPECIAL mailbox command</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Post all rpi memory regions to the port. */</span>
	<span class="n">hdr_tmpl</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">mboxq</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">mqe</span><span class="p">.</span><span class="n">un</span><span class="p">.</span><span class="n">hdr_tmpl</span><span class="p">;</span>
	<span class="n">lpfc_sli4_config</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">mboxq</span><span class="p">,</span> <span class="n">LPFC_MBOX_SUBSYSTEM_FCOE</span><span class="p">,</span>
			 <span class="n">LPFC_MBOX_OPCODE_FCOE_POST_HDR_TEMPLATE</span><span class="p">,</span>
			 <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_mbx_post_hdr_tmpl</span><span class="p">)</span> <span class="o">-</span>
			 <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_sli4_cfg_mhdr</span><span class="p">),</span>
			 <span class="n">LPFC_SLI4_MBX_EMBED</span><span class="p">);</span>


	<span class="cm">/* Post the physical rpi to the port for this rpi header. */</span>
	<span class="n">bf_set</span><span class="p">(</span><span class="n">lpfc_mbx_post_hdr_tmpl_rpi_offset</span><span class="p">,</span> <span class="n">hdr_tmpl</span><span class="p">,</span>
	       <span class="n">rpi_page</span><span class="o">-&gt;</span><span class="n">start_rpi</span><span class="p">);</span>
	<span class="n">bf_set</span><span class="p">(</span><span class="n">lpfc_mbx_post_hdr_tmpl_page_cnt</span><span class="p">,</span>
	       <span class="n">hdr_tmpl</span><span class="p">,</span> <span class="n">rpi_page</span><span class="o">-&gt;</span><span class="n">page_count</span><span class="p">);</span>

	<span class="n">hdr_tmpl</span><span class="o">-&gt;</span><span class="n">rpi_paddr_lo</span> <span class="o">=</span> <span class="n">putPaddrLow</span><span class="p">(</span><span class="n">rpi_page</span><span class="o">-&gt;</span><span class="n">dmabuf</span><span class="o">-&gt;</span><span class="n">phys</span><span class="p">);</span>
	<span class="n">hdr_tmpl</span><span class="o">-&gt;</span><span class="n">rpi_paddr_hi</span> <span class="o">=</span> <span class="n">putPaddrHigh</span><span class="p">(</span><span class="n">rpi_page</span><span class="o">-&gt;</span><span class="n">dmabuf</span><span class="o">-&gt;</span><span class="n">phys</span><span class="p">);</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">lpfc_sli_issue_mbox</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">mboxq</span><span class="p">,</span> <span class="n">MBX_POLL</span><span class="p">);</span>
	<span class="n">shdr</span> <span class="o">=</span> <span class="p">(</span><span class="k">union</span> <span class="n">lpfc_sli4_cfg_shdr</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">hdr_tmpl</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">cfg_shdr</span><span class="p">;</span>
	<span class="n">shdr_status</span> <span class="o">=</span> <span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_mbox_hdr_status</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">shdr</span><span class="o">-&gt;</span><span class="n">response</span><span class="p">);</span>
	<span class="n">shdr_add_status</span> <span class="o">=</span> <span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_mbox_hdr_add_status</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">shdr</span><span class="o">-&gt;</span><span class="n">response</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">!=</span> <span class="n">MBX_TIMEOUT</span><span class="p">)</span>
		<span class="n">mempool_free</span><span class="p">(</span><span class="n">mboxq</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">mbox_mem_pool</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">shdr_status</span> <span class="o">||</span> <span class="n">shdr_add_status</span> <span class="o">||</span> <span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_INIT</span><span class="p">,</span>
				<span class="s">&quot;2514 POST_RPI_HDR mailbox failed with &quot;</span>
				<span class="s">&quot;status x%x add_status x%x, mbx status x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">shdr_status</span><span class="p">,</span> <span class="n">shdr_add_status</span><span class="p">,</span> <span class="n">rc</span><span class="p">);</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENXIO</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_sli4_alloc_rpi - Get an available rpi in the device&#39;s range</span>
<span class="cm"> * @phba: pointer to lpfc hba data structure.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine is invoked to post rpi header templates to the</span>
<span class="cm"> * HBA consistent with the SLI-4 interface spec.  This routine</span>
<span class="cm"> * posts a SLI4_PAGE_SIZE memory region to the port to hold up to</span>
<span class="cm"> * SLI4_PAGE_SIZE modulo 64 rpi context headers.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns</span>
<span class="cm"> * 	A nonzero rpi defined as rpi_base &lt;= rpi &lt; max_rpi if successful</span>
<span class="cm"> * 	LPFC_RPI_ALLOC_ERROR if no rpis are available.</span>
<span class="cm"> **/</span>
<span class="kt">int</span>
<span class="nf">lpfc_sli4_alloc_rpi</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">rpi</span><span class="p">;</span>
	<span class="kt">uint16_t</span> <span class="n">max_rpi</span><span class="p">,</span> <span class="n">rpi_limit</span><span class="p">;</span>
	<span class="kt">uint16_t</span> <span class="n">rpi_remaining</span><span class="p">,</span> <span class="n">lrpi</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_rpi_hdr</span> <span class="o">*</span><span class="n">rpi_hdr</span><span class="p">;</span>

	<span class="n">max_rpi</span> <span class="o">=</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">max_cfg_param</span><span class="p">.</span><span class="n">max_rpi</span><span class="p">;</span>
	<span class="n">rpi_limit</span> <span class="o">=</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">next_rpi</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Fetch the next logical rpi.  Because this index is logical,</span>
<span class="cm">	 * the  driver starts at 0 each time.</span>
<span class="cm">	 */</span>
	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>
	<span class="n">rpi</span> <span class="o">=</span> <span class="n">find_next_zero_bit</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">rpi_bmask</span><span class="p">,</span> <span class="n">rpi_limit</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rpi</span> <span class="o">&gt;=</span> <span class="n">rpi_limit</span><span class="p">)</span>
		<span class="n">rpi</span> <span class="o">=</span> <span class="n">LPFC_RPI_ALLOC_ERROR</span><span class="p">;</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="n">set_bit</span><span class="p">(</span><span class="n">rpi</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">rpi_bmask</span><span class="p">);</span>
		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">max_cfg_param</span><span class="p">.</span><span class="n">rpi_used</span><span class="o">++</span><span class="p">;</span>
		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">rpi_count</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Don&#39;t try to allocate more rpi header regions if the device limit</span>
<span class="cm">	 * has been exhausted.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">rpi</span> <span class="o">==</span> <span class="n">LPFC_RPI_ALLOC_ERROR</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">rpi_count</span> <span class="o">&gt;=</span> <span class="n">max_rpi</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">rpi</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * RPI header postings are not required for SLI4 ports capable of</span>
<span class="cm">	 * extents.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">rpi_hdrs_in_use</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">rpi</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * If the driver is running low on rpi resources, allocate another</span>
<span class="cm">	 * page now.  Note that the next_rpi value is used because</span>
<span class="cm">	 * it represents how many are actually in use whereas max_rpi notes</span>
<span class="cm">	 * how many are supported max by the device.</span>
<span class="cm">	 */</span>
	<span class="n">rpi_remaining</span> <span class="o">=</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">next_rpi</span> <span class="o">-</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">rpi_count</span><span class="p">;</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rpi_remaining</span> <span class="o">&lt;</span> <span class="n">LPFC_RPI_LOW_WATER_MARK</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rpi_hdr</span> <span class="o">=</span> <span class="n">lpfc_sli4_create_rpi_hdr</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rpi_hdr</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_SLI</span><span class="p">,</span>
					<span class="s">&quot;2002 Error Could not grow rpi &quot;</span>
					<span class="s">&quot;count</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">lrpi</span> <span class="o">=</span> <span class="n">rpi_hdr</span><span class="o">-&gt;</span><span class="n">start_rpi</span><span class="p">;</span>
			<span class="n">rpi_hdr</span><span class="o">-&gt;</span><span class="n">start_rpi</span> <span class="o">=</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">rpi_ids</span><span class="p">[</span><span class="n">lrpi</span><span class="p">];</span>
			<span class="n">lpfc_sli4_post_rpi_hdr</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">rpi_hdr</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">rpi</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_sli4_free_rpi - Release an rpi for reuse.</span>
<span class="cm"> * @phba: pointer to lpfc hba data structure.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine is invoked to release an rpi to the pool of</span>
<span class="cm"> * available rpis maintained by the driver.</span>
<span class="cm"> **/</span>
<span class="kt">void</span>
<span class="nf">__lpfc_sli4_free_rpi</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">,</span> <span class="kt">int</span> <span class="n">rpi</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">test_and_clear_bit</span><span class="p">(</span><span class="n">rpi</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">rpi_bmask</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">rpi_count</span><span class="o">--</span><span class="p">;</span>
		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">max_cfg_param</span><span class="p">.</span><span class="n">rpi_used</span><span class="o">--</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_sli4_free_rpi - Release an rpi for reuse.</span>
<span class="cm"> * @phba: pointer to lpfc hba data structure.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine is invoked to release an rpi to the pool of</span>
<span class="cm"> * available rpis maintained by the driver.</span>
<span class="cm"> **/</span>
<span class="kt">void</span>
<span class="nf">lpfc_sli4_free_rpi</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">,</span> <span class="kt">int</span> <span class="n">rpi</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>
	<span class="n">__lpfc_sli4_free_rpi</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">rpi</span><span class="p">);</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_sli4_remove_rpis - Remove the rpi bitmask region</span>
<span class="cm"> * @phba: pointer to lpfc hba data structure.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine is invoked to remove the memory region that</span>
<span class="cm"> * provided rpi via a bitmask.</span>
<span class="cm"> **/</span>
<span class="kt">void</span>
<span class="nf">lpfc_sli4_remove_rpis</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">rpi_bmask</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">rpi_ids</span><span class="p">);</span>
	<span class="n">bf_set</span><span class="p">(</span><span class="n">lpfc_rpi_rsrc_rdy</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">sli4_flags</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_sli4_resume_rpi - Remove the rpi bitmask region</span>
<span class="cm"> * @phba: pointer to lpfc hba data structure.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine is invoked to remove the memory region that</span>
<span class="cm"> * provided rpi via a bitmask.</span>
<span class="cm"> **/</span>
<span class="kt">int</span>
<span class="nf">lpfc_sli4_resume_rpi</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_nodelist</span> <span class="o">*</span><span class="n">ndlp</span><span class="p">,</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">cmpl</span><span class="p">)(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="p">,</span> <span class="n">LPFC_MBOXQ_t</span> <span class="o">*</span><span class="p">),</span> <span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">LPFC_MBOXQ_t</span> <span class="o">*</span><span class="n">mboxq</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span> <span class="o">=</span> <span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">phba</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="cm">/* The port is notified of the header region via a mailbox command. */</span>
	<span class="n">mboxq</span> <span class="o">=</span> <span class="n">mempool_alloc</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">mbox_mem_pool</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mboxq</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="cm">/* Post all rpi memory regions to the port. */</span>
	<span class="n">lpfc_resume_rpi</span><span class="p">(</span><span class="n">mboxq</span><span class="p">,</span> <span class="n">ndlp</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cmpl</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mboxq</span><span class="o">-&gt;</span><span class="n">mbox_cmpl</span> <span class="o">=</span> <span class="n">cmpl</span><span class="p">;</span>
		<span class="n">mboxq</span><span class="o">-&gt;</span><span class="n">context1</span> <span class="o">=</span> <span class="n">arg</span><span class="p">;</span>
		<span class="n">mboxq</span><span class="o">-&gt;</span><span class="n">context2</span> <span class="o">=</span> <span class="n">ndlp</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">mboxq</span><span class="o">-&gt;</span><span class="n">mbox_cmpl</span> <span class="o">=</span> <span class="n">lpfc_sli_def_mbox_cmpl</span><span class="p">;</span>
	<span class="n">mboxq</span><span class="o">-&gt;</span><span class="n">vport</span> <span class="o">=</span> <span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">vport</span><span class="p">;</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">lpfc_sli_issue_mbox</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">mboxq</span><span class="p">,</span> <span class="n">MBX_NOWAIT</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">==</span> <span class="n">MBX_NOT_FINISHED</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_SLI</span><span class="p">,</span>
				<span class="s">&quot;2010 Resume RPI Mailbox failed &quot;</span>
				<span class="s">&quot;status %d, mbxStatus x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">rc</span><span class="p">,</span>
				<span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_mqe_status</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mboxq</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">mqe</span><span class="p">));</span>
		<span class="n">mempool_free</span><span class="p">(</span><span class="n">mboxq</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">mbox_mem_pool</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_sli4_init_vpi - Initialize a vpi with the port</span>
<span class="cm"> * @vport: Pointer to the vport for which the vpi is being initialized</span>
<span class="cm"> *</span>
<span class="cm"> * This routine is invoked to activate a vpi with the port.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns:</span>
<span class="cm"> *    0 success</span>
<span class="cm"> *    -Evalue otherwise</span>
<span class="cm"> **/</span>
<span class="kt">int</span>
<span class="nf">lpfc_sli4_init_vpi</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="n">vport</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">LPFC_MBOXQ_t</span> <span class="o">*</span><span class="n">mboxq</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">retval</span> <span class="o">=</span> <span class="n">MBX_SUCCESS</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">mbox_tmo</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span> <span class="o">=</span> <span class="n">vport</span><span class="o">-&gt;</span><span class="n">phba</span><span class="p">;</span>
	<span class="n">mboxq</span> <span class="o">=</span> <span class="n">mempool_alloc</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">mbox_mem_pool</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mboxq</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="n">lpfc_init_vpi</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">mboxq</span><span class="p">,</span> <span class="n">vport</span><span class="o">-&gt;</span><span class="n">vpi</span><span class="p">);</span>
	<span class="n">mbox_tmo</span> <span class="o">=</span> <span class="n">lpfc_mbox_tmo_val</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">mboxq</span><span class="p">);</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">lpfc_sli_issue_mbox_wait</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">mboxq</span><span class="p">,</span> <span class="n">mbox_tmo</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">!=</span> <span class="n">MBX_SUCCESS</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lpfc_printf_vlog</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_SLI</span><span class="p">,</span>
				<span class="s">&quot;2022 INIT VPI Mailbox failed &quot;</span>
				<span class="s">&quot;status %d, mbxStatus x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">rc</span><span class="p">,</span>
				<span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_mqe_status</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mboxq</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">mqe</span><span class="p">));</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">!=</span> <span class="n">MBX_TIMEOUT</span><span class="p">)</span>
		<span class="n">mempool_free</span><span class="p">(</span><span class="n">mboxq</span><span class="p">,</span> <span class="n">vport</span><span class="o">-&gt;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">mbox_mem_pool</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_mbx_cmpl_add_fcf_record - add fcf mbox completion handler.</span>
<span class="cm"> * @phba: pointer to lpfc hba data structure.</span>
<span class="cm"> * @mboxq: Pointer to mailbox object.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine is invoked to manually add a single FCF record. The caller</span>
<span class="cm"> * must pass a completely initialized FCF_Record.  This routine takes</span>
<span class="cm"> * care of the nonembedded mailbox operations.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">lpfc_mbx_cmpl_add_fcf_record</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">,</span> <span class="n">LPFC_MBOXQ_t</span> <span class="o">*</span><span class="n">mboxq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">virt_addr</span><span class="p">;</span>
	<span class="k">union</span> <span class="n">lpfc_sli4_cfg_shdr</span> <span class="o">*</span><span class="n">shdr</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">shdr_status</span><span class="p">,</span> <span class="n">shdr_add_status</span><span class="p">;</span>

	<span class="n">virt_addr</span> <span class="o">=</span> <span class="n">mboxq</span><span class="o">-&gt;</span><span class="n">sge_array</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="cm">/* The IOCTL status is embedded in the mailbox subheader. */</span>
	<span class="n">shdr</span> <span class="o">=</span> <span class="p">(</span><span class="k">union</span> <span class="n">lpfc_sli4_cfg_shdr</span> <span class="o">*</span><span class="p">)</span> <span class="n">virt_addr</span><span class="p">;</span>
	<span class="n">shdr_status</span> <span class="o">=</span> <span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_mbox_hdr_status</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">shdr</span><span class="o">-&gt;</span><span class="n">response</span><span class="p">);</span>
	<span class="n">shdr_add_status</span> <span class="o">=</span> <span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_mbox_hdr_add_status</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">shdr</span><span class="o">-&gt;</span><span class="n">response</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">shdr_status</span> <span class="o">||</span> <span class="n">shdr_add_status</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		<span class="p">(</span><span class="n">shdr_status</span> <span class="o">!=</span> <span class="n">STATUS_FCF_IN_USE</span><span class="p">))</span>
		<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_INIT</span><span class="p">,</span>
			<span class="s">&quot;2558 ADD_FCF_RECORD mailbox failed with &quot;</span>
			<span class="s">&quot;status x%x add_status x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">shdr_status</span><span class="p">,</span> <span class="n">shdr_add_status</span><span class="p">);</span>

	<span class="n">lpfc_sli4_mbox_cmd_free</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">mboxq</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_sli4_add_fcf_record - Manually add an FCF Record.</span>
<span class="cm"> * @phba: pointer to lpfc hba data structure.</span>
<span class="cm"> * @fcf_record:  pointer to the initialized fcf record to add.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine is invoked to manually add a single FCF record. The caller</span>
<span class="cm"> * must pass a completely initialized FCF_Record.  This routine takes</span>
<span class="cm"> * care of the nonembedded mailbox operations.</span>
<span class="cm"> **/</span>
<span class="kt">int</span>
<span class="nf">lpfc_sli4_add_fcf_record</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">,</span> <span class="k">struct</span> <span class="n">fcf_record</span> <span class="o">*</span><span class="n">fcf_record</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">LPFC_MBOXQ_t</span> <span class="o">*</span><span class="n">mboxq</span><span class="p">;</span>
	<span class="kt">uint8_t</span> <span class="o">*</span><span class="n">bytep</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">virt_addr</span><span class="p">;</span>
	<span class="n">dma_addr_t</span> <span class="n">phys_addr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_mbx_sge</span> <span class="n">sge</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">alloc_len</span><span class="p">,</span> <span class="n">req_len</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">fcfindex</span><span class="p">;</span>

	<span class="n">mboxq</span> <span class="o">=</span> <span class="n">mempool_alloc</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">mbox_mem_pool</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mboxq</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_INIT</span><span class="p">,</span>
			<span class="s">&quot;2009 Failed to allocate mbox for ADD_FCF cmd</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">req_len</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">fcf_record</span><span class="p">)</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">union</span> <span class="n">lpfc_sli4_cfg_shdr</span><span class="p">)</span> <span class="o">+</span>
		  <span class="k">sizeof</span><span class="p">(</span><span class="kt">uint32_t</span><span class="p">);</span>

	<span class="cm">/* Allocate DMA memory and set up the non-embedded mailbox command */</span>
	<span class="n">alloc_len</span> <span class="o">=</span> <span class="n">lpfc_sli4_config</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">mboxq</span><span class="p">,</span> <span class="n">LPFC_MBOX_SUBSYSTEM_FCOE</span><span class="p">,</span>
				     <span class="n">LPFC_MBOX_OPCODE_FCOE_ADD_FCF</span><span class="p">,</span>
				     <span class="n">req_len</span><span class="p">,</span> <span class="n">LPFC_SLI4_MBX_NEMBED</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">alloc_len</span> <span class="o">&lt;</span> <span class="n">req_len</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_INIT</span><span class="p">,</span>
			<span class="s">&quot;2523 Allocated DMA memory size (x%x) is &quot;</span>
			<span class="s">&quot;less than the requested DMA memory &quot;</span>
			<span class="s">&quot;size (x%x)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">alloc_len</span><span class="p">,</span> <span class="n">req_len</span><span class="p">);</span>
		<span class="n">lpfc_sli4_mbox_cmd_free</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">mboxq</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Get the first SGE entry from the non-embedded DMA memory.  This</span>
<span class="cm">	 * routine only uses a single SGE.</span>
<span class="cm">	 */</span>
	<span class="n">lpfc_sli4_mbx_sge_get</span><span class="p">(</span><span class="n">mboxq</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sge</span><span class="p">);</span>
	<span class="n">phys_addr</span> <span class="o">=</span> <span class="n">getPaddr</span><span class="p">(</span><span class="n">sge</span><span class="p">.</span><span class="n">pa_hi</span><span class="p">,</span> <span class="n">sge</span><span class="p">.</span><span class="n">pa_lo</span><span class="p">);</span>
	<span class="n">virt_addr</span> <span class="o">=</span> <span class="n">mboxq</span><span class="o">-&gt;</span><span class="n">sge_array</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="cm">/*</span>
<span class="cm">	 * Configure the FCF record for FCFI 0.  This is the driver&#39;s</span>
<span class="cm">	 * hardcoded default and gets used in nonFIP mode.</span>
<span class="cm">	 */</span>
	<span class="n">fcfindex</span> <span class="o">=</span> <span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_fcf_record_fcf_index</span><span class="p">,</span> <span class="n">fcf_record</span><span class="p">);</span>
	<span class="n">bytep</span> <span class="o">=</span> <span class="n">virt_addr</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">union</span> <span class="n">lpfc_sli4_cfg_shdr</span><span class="p">);</span>
	<span class="n">lpfc_sli_pcimem_bcopy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fcfindex</span><span class="p">,</span> <span class="n">bytep</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">uint32_t</span><span class="p">));</span>

	<span class="cm">/*</span>
<span class="cm">	 * Copy the fcf_index and the FCF Record Data. The data starts after</span>
<span class="cm">	 * the FCoE header plus word10. The data copy needs to be endian</span>
<span class="cm">	 * correct.</span>
<span class="cm">	 */</span>
	<span class="n">bytep</span> <span class="o">+=</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">uint32_t</span><span class="p">);</span>
	<span class="n">lpfc_sli_pcimem_bcopy</span><span class="p">(</span><span class="n">fcf_record</span><span class="p">,</span> <span class="n">bytep</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">fcf_record</span><span class="p">));</span>
	<span class="n">mboxq</span><span class="o">-&gt;</span><span class="n">vport</span> <span class="o">=</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">pport</span><span class="p">;</span>
	<span class="n">mboxq</span><span class="o">-&gt;</span><span class="n">mbox_cmpl</span> <span class="o">=</span> <span class="n">lpfc_mbx_cmpl_add_fcf_record</span><span class="p">;</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">lpfc_sli_issue_mbox</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">mboxq</span><span class="p">,</span> <span class="n">MBX_NOWAIT</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">==</span> <span class="n">MBX_NOT_FINISHED</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_INIT</span><span class="p">,</span>
			<span class="s">&quot;2515 ADD_FCF_RECORD mailbox failed with &quot;</span>
			<span class="s">&quot;status 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">rc</span><span class="p">);</span>
		<span class="n">lpfc_sli4_mbox_cmd_free</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">mboxq</span><span class="p">);</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_sli4_build_dflt_fcf_record - Build the driver&#39;s default FCF Record.</span>
<span class="cm"> * @phba: pointer to lpfc hba data structure.</span>
<span class="cm"> * @fcf_record:  pointer to the fcf record to write the default data.</span>
<span class="cm"> * @fcf_index: FCF table entry index.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine is invoked to build the driver&#39;s default FCF record.  The</span>
<span class="cm"> * values used are hardcoded.  This routine handles memory initialization.</span>
<span class="cm"> *</span>
<span class="cm"> **/</span>
<span class="kt">void</span>
<span class="nf">lpfc_sli4_build_dflt_fcf_record</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">fcf_record</span> <span class="o">*</span><span class="n">fcf_record</span><span class="p">,</span>
				<span class="kt">uint16_t</span> <span class="n">fcf_index</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">fcf_record</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">fcf_record</span><span class="p">));</span>
	<span class="n">fcf_record</span><span class="o">-&gt;</span><span class="n">max_rcv_size</span> <span class="o">=</span> <span class="n">LPFC_FCOE_MAX_RCV_SIZE</span><span class="p">;</span>
	<span class="n">fcf_record</span><span class="o">-&gt;</span><span class="n">fka_adv_period</span> <span class="o">=</span> <span class="n">LPFC_FCOE_FKA_ADV_PER</span><span class="p">;</span>
	<span class="n">fcf_record</span><span class="o">-&gt;</span><span class="n">fip_priority</span> <span class="o">=</span> <span class="n">LPFC_FCOE_FIP_PRIORITY</span><span class="p">;</span>
	<span class="n">bf_set</span><span class="p">(</span><span class="n">lpfc_fcf_record_mac_0</span><span class="p">,</span> <span class="n">fcf_record</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">fc_map</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
	<span class="n">bf_set</span><span class="p">(</span><span class="n">lpfc_fcf_record_mac_1</span><span class="p">,</span> <span class="n">fcf_record</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">fc_map</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
	<span class="n">bf_set</span><span class="p">(</span><span class="n">lpfc_fcf_record_mac_2</span><span class="p">,</span> <span class="n">fcf_record</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">fc_map</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span>
	<span class="n">bf_set</span><span class="p">(</span><span class="n">lpfc_fcf_record_mac_3</span><span class="p">,</span> <span class="n">fcf_record</span><span class="p">,</span> <span class="n">LPFC_FCOE_FCF_MAC3</span><span class="p">);</span>
	<span class="n">bf_set</span><span class="p">(</span><span class="n">lpfc_fcf_record_mac_4</span><span class="p">,</span> <span class="n">fcf_record</span><span class="p">,</span> <span class="n">LPFC_FCOE_FCF_MAC4</span><span class="p">);</span>
	<span class="n">bf_set</span><span class="p">(</span><span class="n">lpfc_fcf_record_mac_5</span><span class="p">,</span> <span class="n">fcf_record</span><span class="p">,</span> <span class="n">LPFC_FCOE_FCF_MAC5</span><span class="p">);</span>
	<span class="n">bf_set</span><span class="p">(</span><span class="n">lpfc_fcf_record_fc_map_0</span><span class="p">,</span> <span class="n">fcf_record</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">fc_map</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
	<span class="n">bf_set</span><span class="p">(</span><span class="n">lpfc_fcf_record_fc_map_1</span><span class="p">,</span> <span class="n">fcf_record</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">fc_map</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
	<span class="n">bf_set</span><span class="p">(</span><span class="n">lpfc_fcf_record_fc_map_2</span><span class="p">,</span> <span class="n">fcf_record</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">fc_map</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span>
	<span class="n">bf_set</span><span class="p">(</span><span class="n">lpfc_fcf_record_fcf_valid</span><span class="p">,</span> <span class="n">fcf_record</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">bf_set</span><span class="p">(</span><span class="n">lpfc_fcf_record_fcf_avail</span><span class="p">,</span> <span class="n">fcf_record</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">bf_set</span><span class="p">(</span><span class="n">lpfc_fcf_record_fcf_index</span><span class="p">,</span> <span class="n">fcf_record</span><span class="p">,</span> <span class="n">fcf_index</span><span class="p">);</span>
	<span class="n">bf_set</span><span class="p">(</span><span class="n">lpfc_fcf_record_mac_addr_prov</span><span class="p">,</span> <span class="n">fcf_record</span><span class="p">,</span>
		<span class="n">LPFC_FCF_FPMA</span> <span class="o">|</span> <span class="n">LPFC_FCF_SPMA</span><span class="p">);</span>
	<span class="cm">/* Set the VLAN bit map */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">valid_vlan</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">fcf_record</span><span class="o">-&gt;</span><span class="n">vlan_bitmap</span><span class="p">[</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">vlan_id</span> <span class="o">/</span> <span class="mi">8</span><span class="p">]</span>
			<span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">vlan_id</span> <span class="o">%</span> <span class="mi">8</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_sli4_fcf_scan_read_fcf_rec - Read hba fcf record for fcf scan.</span>
<span class="cm"> * @phba: pointer to lpfc hba data structure.</span>
<span class="cm"> * @fcf_index: FCF table entry offset.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine is invoked to scan the entire FCF table by reading FCF</span>
<span class="cm"> * record and processing it one at a time starting from the @fcf_index</span>
<span class="cm"> * for initial FCF discovery or fast FCF failover rediscovery.</span>
<span class="cm"> *</span>
<span class="cm"> * Return 0 if the mailbox command is submitted successfully, none 0</span>
<span class="cm"> * otherwise.</span>
<span class="cm"> **/</span>
<span class="kt">int</span>
<span class="nf">lpfc_sli4_fcf_scan_read_fcf_rec</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">,</span> <span class="kt">uint16_t</span> <span class="n">fcf_index</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">error</span><span class="p">;</span>
	<span class="n">LPFC_MBOXQ_t</span> <span class="o">*</span><span class="n">mboxq</span><span class="p">;</span>

	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">fcoe_eventtag_at_fcf_scan</span> <span class="o">=</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">fcoe_eventtag</span><span class="p">;</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">fcoe_cvl_eventtag_attn</span> <span class="o">=</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">fcoe_cvl_eventtag</span><span class="p">;</span>
	<span class="n">mboxq</span> <span class="o">=</span> <span class="n">mempool_alloc</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">mbox_mem_pool</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mboxq</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_INIT</span><span class="p">,</span>
				<span class="s">&quot;2000 Failed to allocate mbox for &quot;</span>
				<span class="s">&quot;READ_FCF cmd</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">fail_fcf_scan</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* Construct the read FCF record mailbox command */</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">lpfc_sli4_mbx_read_fcf_rec</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">mboxq</span><span class="p">,</span> <span class="n">fcf_index</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">fail_fcf_scan</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* Issue the mailbox command asynchronously */</span>
	<span class="n">mboxq</span><span class="o">-&gt;</span><span class="n">vport</span> <span class="o">=</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">pport</span><span class="p">;</span>
	<span class="n">mboxq</span><span class="o">-&gt;</span><span class="n">mbox_cmpl</span> <span class="o">=</span> <span class="n">lpfc_mbx_cmpl_fcf_scan_read_fcf_rec</span><span class="p">;</span>

	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">hba_flag</span> <span class="o">|=</span> <span class="n">FCF_TS_INPROG</span><span class="p">;</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">lpfc_sli_issue_mbox</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">mboxq</span><span class="p">,</span> <span class="n">MBX_NOWAIT</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">==</span> <span class="n">MBX_NOT_FINISHED</span><span class="p">)</span>
		<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* Reset eligible FCF count for new scan */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">fcf_index</span> <span class="o">==</span> <span class="n">LPFC_FCOE_FCF_GET_FIRST</span><span class="p">)</span>
			<span class="n">phba</span><span class="o">-&gt;</span><span class="n">fcf</span><span class="p">.</span><span class="n">eligible_fcf_cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">error</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
<span class="nl">fail_fcf_scan:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">mboxq</span><span class="p">)</span>
			<span class="n">lpfc_sli4_mbox_cmd_free</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">mboxq</span><span class="p">);</span>
		<span class="cm">/* FCF scan failed, clear FCF_TS_INPROG flag */</span>
		<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>
		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">hba_flag</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">FCF_TS_INPROG</span><span class="p">;</span>
		<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_sli4_fcf_rr_read_fcf_rec - Read hba fcf record for roundrobin fcf.</span>
<span class="cm"> * @phba: pointer to lpfc hba data structure.</span>
<span class="cm"> * @fcf_index: FCF table entry offset.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine is invoked to read an FCF record indicated by @fcf_index</span>
<span class="cm"> * and to use it for FLOGI roundrobin FCF failover.</span>
<span class="cm"> *</span>
<span class="cm"> * Return 0 if the mailbox command is submitted successfully, none 0</span>
<span class="cm"> * otherwise.</span>
<span class="cm"> **/</span>
<span class="kt">int</span>
<span class="nf">lpfc_sli4_fcf_rr_read_fcf_rec</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">,</span> <span class="kt">uint16_t</span> <span class="n">fcf_index</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">error</span><span class="p">;</span>
	<span class="n">LPFC_MBOXQ_t</span> <span class="o">*</span><span class="n">mboxq</span><span class="p">;</span>

	<span class="n">mboxq</span> <span class="o">=</span> <span class="n">mempool_alloc</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">mbox_mem_pool</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mboxq</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_FIP</span> <span class="o">|</span> <span class="n">LOG_INIT</span><span class="p">,</span>
				<span class="s">&quot;2763 Failed to allocate mbox for &quot;</span>
				<span class="s">&quot;READ_FCF cmd</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">fail_fcf_read</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* Construct the read FCF record mailbox command */</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">lpfc_sli4_mbx_read_fcf_rec</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">mboxq</span><span class="p">,</span> <span class="n">fcf_index</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">fail_fcf_read</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* Issue the mailbox command asynchronously */</span>
	<span class="n">mboxq</span><span class="o">-&gt;</span><span class="n">vport</span> <span class="o">=</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">pport</span><span class="p">;</span>
	<span class="n">mboxq</span><span class="o">-&gt;</span><span class="n">mbox_cmpl</span> <span class="o">=</span> <span class="n">lpfc_mbx_cmpl_fcf_rr_read_fcf_rec</span><span class="p">;</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">lpfc_sli_issue_mbox</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">mboxq</span><span class="p">,</span> <span class="n">MBX_NOWAIT</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">==</span> <span class="n">MBX_NOT_FINISHED</span><span class="p">)</span>
		<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">error</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">fail_fcf_read:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span> <span class="o">&amp;&amp;</span> <span class="n">mboxq</span><span class="p">)</span>
		<span class="n">lpfc_sli4_mbox_cmd_free</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">mboxq</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_sli4_read_fcf_rec - Read hba fcf record for update eligible fcf bmask.</span>
<span class="cm"> * @phba: pointer to lpfc hba data structure.</span>
<span class="cm"> * @fcf_index: FCF table entry offset.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine is invoked to read an FCF record indicated by @fcf_index to</span>
<span class="cm"> * determine whether it&#39;s eligible for FLOGI roundrobin failover list.</span>
<span class="cm"> *</span>
<span class="cm"> * Return 0 if the mailbox command is submitted successfully, none 0</span>
<span class="cm"> * otherwise.</span>
<span class="cm"> **/</span>
<span class="kt">int</span>
<span class="nf">lpfc_sli4_read_fcf_rec</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">,</span> <span class="kt">uint16_t</span> <span class="n">fcf_index</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">error</span><span class="p">;</span>
	<span class="n">LPFC_MBOXQ_t</span> <span class="o">*</span><span class="n">mboxq</span><span class="p">;</span>

	<span class="n">mboxq</span> <span class="o">=</span> <span class="n">mempool_alloc</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">mbox_mem_pool</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mboxq</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_FIP</span> <span class="o">|</span> <span class="n">LOG_INIT</span><span class="p">,</span>
				<span class="s">&quot;2758 Failed to allocate mbox for &quot;</span>
				<span class="s">&quot;READ_FCF cmd</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
				<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
				<span class="k">goto</span> <span class="n">fail_fcf_read</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* Construct the read FCF record mailbox command */</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">lpfc_sli4_mbx_read_fcf_rec</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">mboxq</span><span class="p">,</span> <span class="n">fcf_index</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">fail_fcf_read</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* Issue the mailbox command asynchronously */</span>
	<span class="n">mboxq</span><span class="o">-&gt;</span><span class="n">vport</span> <span class="o">=</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">pport</span><span class="p">;</span>
	<span class="n">mboxq</span><span class="o">-&gt;</span><span class="n">mbox_cmpl</span> <span class="o">=</span> <span class="n">lpfc_mbx_cmpl_read_fcf_rec</span><span class="p">;</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">lpfc_sli_issue_mbox</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">mboxq</span><span class="p">,</span> <span class="n">MBX_NOWAIT</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">==</span> <span class="n">MBX_NOT_FINISHED</span><span class="p">)</span>
		<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">error</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">fail_fcf_read:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span> <span class="o">&amp;&amp;</span> <span class="n">mboxq</span><span class="p">)</span>
		<span class="n">lpfc_sli4_mbox_cmd_free</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">mboxq</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_check_next_fcf_pri</span>
<span class="cm"> * phba pointer to the lpfc_hba struct for this port.</span>
<span class="cm"> * This routine is called from the lpfc_sli4_fcf_rr_next_index_get</span>
<span class="cm"> * routine when the rr_bmask is empty. The FCF indecies are put into the</span>
<span class="cm"> * rr_bmask based on their priority level. Starting from the highest priority</span>
<span class="cm"> * to the lowest. The most likely FCF candidate will be in the highest</span>
<span class="cm"> * priority group. When this routine is called it searches the fcf_pri list for</span>
<span class="cm"> * next lowest priority group and repopulates the rr_bmask with only those</span>
<span class="cm"> * fcf_indexes.</span>
<span class="cm"> * returns:</span>
<span class="cm"> * 1=success 0=failure</span>
<span class="cm"> **/</span>
<span class="kt">int</span>
<span class="nf">lpfc_check_next_fcf_pri_level</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">uint16_t</span> <span class="n">next_fcf_pri</span><span class="p">;</span>
	<span class="kt">uint16_t</span> <span class="n">last_index</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_fcf_pri</span> <span class="o">*</span><span class="n">fcf_pri</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">last_index</span> <span class="o">=</span> <span class="n">find_first_bit</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">fcf</span><span class="p">.</span><span class="n">fcf_rr_bmask</span><span class="p">,</span>
			<span class="n">LPFC_SLI4_FCF_TBL_INDX_MAX</span><span class="p">);</span>
	<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_INFO</span><span class="p">,</span> <span class="n">LOG_FIP</span><span class="p">,</span>
			<span class="s">&quot;3060 Last IDX %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">last_index</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">fcf</span><span class="p">.</span><span class="n">fcf_pri_list</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_FIP</span><span class="p">,</span>
			<span class="s">&quot;3061 Last IDX %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">last_index</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span> <span class="cm">/* Empty rr list */</span>
	<span class="p">}</span>
	<span class="n">next_fcf_pri</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * Clear the rr_bmask and set all of the bits that are at this</span>
<span class="cm">	 * priority.</span>
<span class="cm">	 */</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">fcf</span><span class="p">.</span><span class="n">fcf_rr_bmask</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
			<span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">fcf</span><span class="p">.</span><span class="n">fcf_rr_bmask</span><span class="p">));</span>
	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">fcf_pri</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">fcf</span><span class="p">.</span><span class="n">fcf_pri_list</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">fcf_pri</span><span class="o">-&gt;</span><span class="n">fcf_rec</span><span class="p">.</span><span class="n">flag</span> <span class="o">&amp;</span> <span class="n">LPFC_FCF_FLOGI_FAILED</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * the 1st priority that has not FLOGI failed</span>
<span class="cm">		 * will be the highest.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">next_fcf_pri</span><span class="p">)</span>
			<span class="n">next_fcf_pri</span> <span class="o">=</span> <span class="n">fcf_pri</span><span class="o">-&gt;</span><span class="n">fcf_rec</span><span class="p">.</span><span class="n">priority</span><span class="p">;</span>
		<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">fcf_pri</span><span class="o">-&gt;</span><span class="n">fcf_rec</span><span class="p">.</span><span class="n">priority</span> <span class="o">==</span> <span class="n">next_fcf_pri</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">rc</span> <span class="o">=</span> <span class="n">lpfc_sli4_fcf_rr_index_set</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span>
						<span class="n">fcf_pri</span><span class="o">-&gt;</span><span class="n">fcf_rec</span><span class="p">.</span><span class="n">fcf_index</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
				<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * if next_fcf_pri was not set above and the list is not empty then</span>
<span class="cm">	 * we have failed flogis on all of them. So reset flogi failed</span>
<span class="cm">	 * and start at the begining.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">next_fcf_pri</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">fcf</span><span class="p">.</span><span class="n">fcf_pri_list</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">fcf_pri</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">fcf</span><span class="p">.</span><span class="n">fcf_pri_list</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">fcf_pri</span><span class="o">-&gt;</span><span class="n">fcf_rec</span><span class="p">.</span><span class="n">flag</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">LPFC_FCF_FLOGI_FAILED</span><span class="p">;</span>
			<span class="cm">/*</span>
<span class="cm">			 * the 1st priority that has not FLOGI failed</span>
<span class="cm">			 * will be the highest.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">next_fcf_pri</span><span class="p">)</span>
				<span class="n">next_fcf_pri</span> <span class="o">=</span> <span class="n">fcf_pri</span><span class="o">-&gt;</span><span class="n">fcf_rec</span><span class="p">.</span><span class="n">priority</span><span class="p">;</span>
			<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">fcf_pri</span><span class="o">-&gt;</span><span class="n">fcf_rec</span><span class="p">.</span><span class="n">priority</span> <span class="o">==</span> <span class="n">next_fcf_pri</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">rc</span> <span class="o">=</span> <span class="n">lpfc_sli4_fcf_rr_index_set</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span>
						<span class="n">fcf_pri</span><span class="o">-&gt;</span><span class="n">fcf_rec</span><span class="p">.</span><span class="n">fcf_index</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
					<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
<span class="cm">/**</span>
<span class="cm"> * lpfc_sli4_fcf_rr_next_index_get - Get next eligible fcf record index</span>
<span class="cm"> * @phba: pointer to lpfc hba data structure.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine is to get the next eligible FCF record index in a round</span>
<span class="cm"> * robin fashion. If the next eligible FCF record index equals to the</span>
<span class="cm"> * initial roundrobin FCF record index, LPFC_FCOE_FCF_NEXT_NONE (0xFFFF)</span>
<span class="cm"> * shall be returned, otherwise, the next eligible FCF record&#39;s index</span>
<span class="cm"> * shall be returned.</span>
<span class="cm"> **/</span>
<span class="kt">uint16_t</span>
<span class="nf">lpfc_sli4_fcf_rr_next_index_get</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">uint16_t</span> <span class="n">next_fcf_index</span><span class="p">;</span>

	<span class="cm">/* Search start from next bit of currently registered FCF index */</span>
<span class="nl">next_priority:</span>
	<span class="n">next_fcf_index</span> <span class="o">=</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">fcf</span><span class="p">.</span><span class="n">current_rec</span><span class="p">.</span><span class="n">fcf_indx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span>
					<span class="n">LPFC_SLI4_FCF_TBL_INDX_MAX</span><span class="p">;</span>
	<span class="n">next_fcf_index</span> <span class="o">=</span> <span class="n">find_next_bit</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">fcf</span><span class="p">.</span><span class="n">fcf_rr_bmask</span><span class="p">,</span>
				       <span class="n">LPFC_SLI4_FCF_TBL_INDX_MAX</span><span class="p">,</span>
				       <span class="n">next_fcf_index</span><span class="p">);</span>

	<span class="cm">/* Wrap around condition on phba-&gt;fcf.fcf_rr_bmask */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">next_fcf_index</span> <span class="o">&gt;=</span> <span class="n">LPFC_SLI4_FCF_TBL_INDX_MAX</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * If we have wrapped then we need to clear the bits that</span>
<span class="cm">		 * have been tested so that we can detect when we should</span>
<span class="cm">		 * change the priority level.</span>
<span class="cm">		 */</span>
		<span class="n">next_fcf_index</span> <span class="o">=</span> <span class="n">find_next_bit</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">fcf</span><span class="p">.</span><span class="n">fcf_rr_bmask</span><span class="p">,</span>
					       <span class="n">LPFC_SLI4_FCF_TBL_INDX_MAX</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>


	<span class="cm">/* Check roundrobin failover list empty condition */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">next_fcf_index</span> <span class="o">&gt;=</span> <span class="n">LPFC_SLI4_FCF_TBL_INDX_MAX</span> <span class="o">||</span>
		<span class="n">next_fcf_index</span> <span class="o">==</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">fcf</span><span class="p">.</span><span class="n">current_rec</span><span class="p">.</span><span class="n">fcf_indx</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * If next fcf index is not found check if there are lower</span>
<span class="cm">		 * Priority level fcf&#39;s in the fcf_priority list.</span>
<span class="cm">		 * Set up the rr_bmask with all of the avaiable fcf bits</span>
<span class="cm">		 * at that level and continue the selection process.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">lpfc_check_next_fcf_pri_level</span><span class="p">(</span><span class="n">phba</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">next_priority</span><span class="p">;</span>
		<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_WARNING</span><span class="p">,</span> <span class="n">LOG_FIP</span><span class="p">,</span>
				<span class="s">&quot;2844 No roundrobin failover FCF available</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">next_fcf_index</span> <span class="o">&gt;=</span> <span class="n">LPFC_SLI4_FCF_TBL_INDX_MAX</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">LPFC_FCOE_FCF_NEXT_NONE</span><span class="p">;</span>
		<span class="k">else</span> <span class="p">{</span>
			<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_WARNING</span><span class="p">,</span> <span class="n">LOG_FIP</span><span class="p">,</span>
				<span class="s">&quot;3063 Only FCF available idx %d, flag %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">next_fcf_index</span><span class="p">,</span>
			<span class="n">phba</span><span class="o">-&gt;</span><span class="n">fcf</span><span class="p">.</span><span class="n">fcf_pri</span><span class="p">[</span><span class="n">next_fcf_index</span><span class="p">].</span><span class="n">fcf_rec</span><span class="p">.</span><span class="n">flag</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">next_fcf_index</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">next_fcf_index</span> <span class="o">&lt;</span> <span class="n">LPFC_SLI4_FCF_TBL_INDX_MAX</span> <span class="o">&amp;&amp;</span>
		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">fcf</span><span class="p">.</span><span class="n">fcf_pri</span><span class="p">[</span><span class="n">next_fcf_index</span><span class="p">].</span><span class="n">fcf_rec</span><span class="p">.</span><span class="n">flag</span> <span class="o">&amp;</span>
		<span class="n">LPFC_FCF_FLOGI_FAILED</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">next_priority</span><span class="p">;</span>

	<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_INFO</span><span class="p">,</span> <span class="n">LOG_FIP</span><span class="p">,</span>
			<span class="s">&quot;2845 Get next roundrobin failover FCF (x%x)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">next_fcf_index</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">next_fcf_index</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_sli4_fcf_rr_index_set - Set bmask with eligible fcf record index</span>
<span class="cm"> * @phba: pointer to lpfc hba data structure.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine sets the FCF record index in to the eligible bmask for</span>
<span class="cm"> * roundrobin failover search. It checks to make sure that the index</span>
<span class="cm"> * does not go beyond the range of the driver allocated bmask dimension</span>
<span class="cm"> * before setting the bit.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 0 if the index bit successfully set, otherwise, it returns</span>
<span class="cm"> * -EINVAL.</span>
<span class="cm"> **/</span>
<span class="kt">int</span>
<span class="nf">lpfc_sli4_fcf_rr_index_set</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">,</span> <span class="kt">uint16_t</span> <span class="n">fcf_index</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">fcf_index</span> <span class="o">&gt;=</span> <span class="n">LPFC_SLI4_FCF_TBL_INDX_MAX</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_FIP</span><span class="p">,</span>
				<span class="s">&quot;2610 FCF (x%x) reached driver&#39;s book &quot;</span>
				<span class="s">&quot;keeping dimension:x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">fcf_index</span><span class="p">,</span> <span class="n">LPFC_SLI4_FCF_TBL_INDX_MAX</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* Set the eligible FCF record index bmask */</span>
	<span class="n">set_bit</span><span class="p">(</span><span class="n">fcf_index</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">fcf</span><span class="p">.</span><span class="n">fcf_rr_bmask</span><span class="p">);</span>

	<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_INFO</span><span class="p">,</span> <span class="n">LOG_FIP</span><span class="p">,</span>
			<span class="s">&quot;2790 Set FCF (x%x) to roundrobin FCF failover &quot;</span>
			<span class="s">&quot;bmask</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">fcf_index</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_sli4_fcf_rr_index_clear - Clear bmask from eligible fcf record index</span>
<span class="cm"> * @phba: pointer to lpfc hba data structure.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine clears the FCF record index from the eligible bmask for</span>
<span class="cm"> * roundrobin failover search. It checks to make sure that the index</span>
<span class="cm"> * does not go beyond the range of the driver allocated bmask dimension</span>
<span class="cm"> * before clearing the bit.</span>
<span class="cm"> **/</span>
<span class="kt">void</span>
<span class="nf">lpfc_sli4_fcf_rr_index_clear</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">,</span> <span class="kt">uint16_t</span> <span class="n">fcf_index</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpfc_fcf_pri</span> <span class="o">*</span><span class="n">fcf_pri</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">fcf_index</span> <span class="o">&gt;=</span> <span class="n">LPFC_SLI4_FCF_TBL_INDX_MAX</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_FIP</span><span class="p">,</span>
				<span class="s">&quot;2762 FCF (x%x) reached driver&#39;s book &quot;</span>
				<span class="s">&quot;keeping dimension:x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">fcf_index</span><span class="p">,</span> <span class="n">LPFC_SLI4_FCF_TBL_INDX_MAX</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* Clear the eligible FCF record index bmask */</span>
	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">fcf_pri</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">fcf</span><span class="p">.</span><span class="n">fcf_pri_list</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">fcf_pri</span><span class="o">-&gt;</span><span class="n">fcf_rec</span><span class="p">.</span><span class="n">fcf_index</span> <span class="o">==</span> <span class="n">fcf_index</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fcf_pri</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>
	<span class="n">clear_bit</span><span class="p">(</span><span class="n">fcf_index</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">fcf</span><span class="p">.</span><span class="n">fcf_rr_bmask</span><span class="p">);</span>

	<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_INFO</span><span class="p">,</span> <span class="n">LOG_FIP</span><span class="p">,</span>
			<span class="s">&quot;2791 Clear FCF (x%x) from roundrobin failover &quot;</span>
			<span class="s">&quot;bmask</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">fcf_index</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_mbx_cmpl_redisc_fcf_table - completion routine for rediscover FCF table</span>
<span class="cm"> * @phba: pointer to lpfc hba data structure.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine is the completion routine for the rediscover FCF table mailbox</span>
<span class="cm"> * command. If the mailbox command returned failure, it will try to stop the</span>
<span class="cm"> * FCF rediscover wait timer.</span>
<span class="cm"> **/</span>
<span class="kt">void</span>
<span class="nf">lpfc_mbx_cmpl_redisc_fcf_table</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">,</span> <span class="n">LPFC_MBOXQ_t</span> <span class="o">*</span><span class="n">mbox</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpfc_mbx_redisc_fcf_tbl</span> <span class="o">*</span><span class="n">redisc_fcf</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">shdr_status</span><span class="p">,</span> <span class="n">shdr_add_status</span><span class="p">;</span>

	<span class="n">redisc_fcf</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">mbox</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">mqe</span><span class="p">.</span><span class="n">un</span><span class="p">.</span><span class="n">redisc_fcf_tbl</span><span class="p">;</span>

	<span class="n">shdr_status</span> <span class="o">=</span> <span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_mbox_hdr_status</span><span class="p">,</span>
			     <span class="o">&amp;</span><span class="n">redisc_fcf</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">cfg_shdr</span><span class="p">.</span><span class="n">response</span><span class="p">);</span>
	<span class="n">shdr_add_status</span> <span class="o">=</span> <span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_mbox_hdr_add_status</span><span class="p">,</span>
			     <span class="o">&amp;</span><span class="n">redisc_fcf</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">cfg_shdr</span><span class="p">.</span><span class="n">response</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">shdr_status</span> <span class="o">||</span> <span class="n">shdr_add_status</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_FIP</span><span class="p">,</span>
				<span class="s">&quot;2746 Requesting for FCF rediscovery failed &quot;</span>
				<span class="s">&quot;status x%x add_status x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">shdr_status</span><span class="p">,</span> <span class="n">shdr_add_status</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">fcf</span><span class="p">.</span><span class="n">fcf_flag</span> <span class="o">&amp;</span> <span class="n">FCF_ACVL_DISC</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>
			<span class="n">phba</span><span class="o">-&gt;</span><span class="n">fcf</span><span class="p">.</span><span class="n">fcf_flag</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">FCF_ACVL_DISC</span><span class="p">;</span>
			<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>
			<span class="cm">/*</span>
<span class="cm">			 * CVL event triggered FCF rediscover request failed,</span>
<span class="cm">			 * last resort to re-try current registered FCF entry.</span>
<span class="cm">			 */</span>
			<span class="n">lpfc_retry_pport_discovery</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>
			<span class="n">phba</span><span class="o">-&gt;</span><span class="n">fcf</span><span class="p">.</span><span class="n">fcf_flag</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">FCF_DEAD_DISC</span><span class="p">;</span>
			<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>
			<span class="cm">/*</span>
<span class="cm">			 * DEAD FCF event triggered FCF rediscover request</span>
<span class="cm">			 * failed, last resort to fail over as a link down</span>
<span class="cm">			 * to FCF registration.</span>
<span class="cm">			 */</span>
			<span class="n">lpfc_sli4_fcf_dead_failthrough</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_INFO</span><span class="p">,</span> <span class="n">LOG_FIP</span><span class="p">,</span>
				<span class="s">&quot;2775 Start FCF rediscover quiescent timer</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * Start FCF rediscovery wait timer for pending FCF</span>
<span class="cm">		 * before rescan FCF record table.</span>
<span class="cm">		 */</span>
		<span class="n">lpfc_fcf_redisc_wait_start_timer</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">mempool_free</span><span class="p">(</span><span class="n">mbox</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">mbox_mem_pool</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_sli4_redisc_fcf_table - Request to rediscover entire FCF table by port.</span>
<span class="cm"> * @phba: pointer to lpfc hba data structure.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine is invoked to request for rediscovery of the entire FCF table</span>
<span class="cm"> * by the port.</span>
<span class="cm"> **/</span>
<span class="kt">int</span>
<span class="nf">lpfc_sli4_redisc_fcf_table</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">LPFC_MBOXQ_t</span> <span class="o">*</span><span class="n">mbox</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_mbx_redisc_fcf_tbl</span> <span class="o">*</span><span class="n">redisc_fcf</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">,</span> <span class="n">length</span><span class="p">;</span>

	<span class="cm">/* Cancel retry delay timers to all vports before FCF rediscover */</span>
	<span class="n">lpfc_cancel_all_vport_retry_delay_timer</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>

	<span class="n">mbox</span> <span class="o">=</span> <span class="n">mempool_alloc</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">mbox_mem_pool</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mbox</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_SLI</span><span class="p">,</span>
				<span class="s">&quot;2745 Failed to allocate mbox for &quot;</span>
				<span class="s">&quot;requesting FCF rediscover.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">length</span> <span class="o">=</span> <span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_mbx_redisc_fcf_tbl</span><span class="p">)</span> <span class="o">-</span>
		  <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_sli4_cfg_mhdr</span><span class="p">));</span>
	<span class="n">lpfc_sli4_config</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">mbox</span><span class="p">,</span> <span class="n">LPFC_MBOX_SUBSYSTEM_FCOE</span><span class="p">,</span>
			 <span class="n">LPFC_MBOX_OPCODE_FCOE_REDISCOVER_FCF</span><span class="p">,</span>
			 <span class="n">length</span><span class="p">,</span> <span class="n">LPFC_SLI4_MBX_EMBED</span><span class="p">);</span>

	<span class="n">redisc_fcf</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">mbox</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">mqe</span><span class="p">.</span><span class="n">un</span><span class="p">.</span><span class="n">redisc_fcf_tbl</span><span class="p">;</span>
	<span class="cm">/* Set count to 0 for invalidating the entire FCF database */</span>
	<span class="n">bf_set</span><span class="p">(</span><span class="n">lpfc_mbx_redisc_fcf_count</span><span class="p">,</span> <span class="n">redisc_fcf</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="cm">/* Issue the mailbox command asynchronously */</span>
	<span class="n">mbox</span><span class="o">-&gt;</span><span class="n">vport</span> <span class="o">=</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">pport</span><span class="p">;</span>
	<span class="n">mbox</span><span class="o">-&gt;</span><span class="n">mbox_cmpl</span> <span class="o">=</span> <span class="n">lpfc_mbx_cmpl_redisc_fcf_table</span><span class="p">;</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">lpfc_sli_issue_mbox</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">mbox</span><span class="p">,</span> <span class="n">MBX_NOWAIT</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">==</span> <span class="n">MBX_NOT_FINISHED</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mempool_free</span><span class="p">(</span><span class="n">mbox</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">mbox_mem_pool</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_sli4_fcf_dead_failthrough - Failthrough routine to fcf dead event</span>
<span class="cm"> * @phba: pointer to lpfc hba data structure.</span>
<span class="cm"> *</span>
<span class="cm"> * This function is the failover routine as a last resort to the FCF DEAD</span>
<span class="cm"> * event when driver failed to perform fast FCF failover.</span>
<span class="cm"> **/</span>
<span class="kt">void</span>
<span class="nf">lpfc_sli4_fcf_dead_failthrough</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">uint32_t</span> <span class="n">link_state</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Last resort as FCF DEAD event failover will treat this as</span>
<span class="cm">	 * a link down, but save the link state because we don&#39;t want</span>
<span class="cm">	 * it to be changed to Link Down unless it is already down.</span>
<span class="cm">	 */</span>
	<span class="n">link_state</span> <span class="o">=</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">link_state</span><span class="p">;</span>
	<span class="n">lpfc_linkdown</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">link_state</span> <span class="o">=</span> <span class="n">link_state</span><span class="p">;</span>

	<span class="cm">/* Unregister FCF if no devices connected to it */</span>
	<span class="n">lpfc_unregister_unused_fcf</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_sli_get_config_region23 - Get sli3 port region 23 data.</span>
<span class="cm"> * @phba: pointer to lpfc hba data structure.</span>
<span class="cm"> * @rgn23_data: pointer to configure region 23 data.</span>
<span class="cm"> *</span>
<span class="cm"> * This function gets SLI3 port configure region 23 data through memory dump</span>
<span class="cm"> * mailbox command. When it successfully retrieves data, the size of the data</span>
<span class="cm"> * will be returned, otherwise, 0 will be returned.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">uint32_t</span>
<span class="nf">lpfc_sli_get_config_region23</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">rgn23_data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">LPFC_MBOXQ_t</span> <span class="o">*</span><span class="n">pmb</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">MAILBOX_t</span> <span class="o">*</span><span class="n">mb</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rgn23_data</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">pmb</span> <span class="o">=</span> <span class="n">mempool_alloc</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">mbox_mem_pool</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pmb</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_INIT</span><span class="p">,</span>
				<span class="s">&quot;2600 failed to allocate mailbox memory</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">mb</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">pmb</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">mb</span><span class="p">;</span>

	<span class="k">do</span> <span class="p">{</span>
		<span class="n">lpfc_dump_mem</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">pmb</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">DMP_REGION_23</span><span class="p">);</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">lpfc_sli_issue_mbox</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">pmb</span><span class="p">,</span> <span class="n">MBX_POLL</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">!=</span> <span class="n">MBX_SUCCESS</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_INFO</span><span class="p">,</span> <span class="n">LOG_INIT</span><span class="p">,</span>
					<span class="s">&quot;2601 failed to read config &quot;</span>
					<span class="s">&quot;region 23, rc 0x%x Status 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">rc</span><span class="p">,</span> <span class="n">mb</span><span class="o">-&gt;</span><span class="n">mbxStatus</span><span class="p">);</span>
			<span class="n">mb</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">varDmp</span><span class="p">.</span><span class="n">word_cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/*</span>
<span class="cm">		 * dump mem may return a zero when finished or we got a</span>
<span class="cm">		 * mailbox error, either way we are done.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">mb</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">varDmp</span><span class="p">.</span><span class="n">word_cnt</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">mb</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">varDmp</span><span class="p">.</span><span class="n">word_cnt</span> <span class="o">&gt;</span> <span class="n">DMP_RGN23_SIZE</span> <span class="o">-</span> <span class="n">offset</span><span class="p">)</span>
			<span class="n">mb</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">varDmp</span><span class="p">.</span><span class="n">word_cnt</span> <span class="o">=</span> <span class="n">DMP_RGN23_SIZE</span> <span class="o">-</span> <span class="n">offset</span><span class="p">;</span>

		<span class="n">lpfc_sli_pcimem_bcopy</span><span class="p">(((</span><span class="kt">uint8_t</span> <span class="o">*</span><span class="p">)</span><span class="n">mb</span><span class="p">)</span> <span class="o">+</span> <span class="n">DMP_RSP_OFFSET</span><span class="p">,</span>
				       <span class="n">rgn23_data</span> <span class="o">+</span> <span class="n">offset</span><span class="p">,</span>
				       <span class="n">mb</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">varDmp</span><span class="p">.</span><span class="n">word_cnt</span><span class="p">);</span>
		<span class="n">offset</span> <span class="o">+=</span> <span class="n">mb</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">varDmp</span><span class="p">.</span><span class="n">word_cnt</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">mb</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">varDmp</span><span class="p">.</span><span class="n">word_cnt</span> <span class="o">&amp;&amp;</span> <span class="n">offset</span> <span class="o">&lt;</span> <span class="n">DMP_RGN23_SIZE</span><span class="p">);</span>

	<span class="n">mempool_free</span><span class="p">(</span><span class="n">pmb</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">mbox_mem_pool</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">offset</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_sli4_get_config_region23 - Get sli4 port region 23 data.</span>
<span class="cm"> * @phba: pointer to lpfc hba data structure.</span>
<span class="cm"> * @rgn23_data: pointer to configure region 23 data.</span>
<span class="cm"> *</span>
<span class="cm"> * This function gets SLI4 port configure region 23 data through memory dump</span>
<span class="cm"> * mailbox command. When it successfully retrieves data, the size of the data</span>
<span class="cm"> * will be returned, otherwise, 0 will be returned.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">uint32_t</span>
<span class="nf">lpfc_sli4_get_config_region23</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">rgn23_data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">LPFC_MBOXQ_t</span> <span class="o">*</span><span class="n">mboxq</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_dmabuf</span> <span class="o">*</span><span class="n">mp</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_mqe</span> <span class="o">*</span><span class="n">mqe</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">data_length</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rgn23_data</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">mboxq</span> <span class="o">=</span> <span class="n">mempool_alloc</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">mbox_mem_pool</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mboxq</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_INIT</span><span class="p">,</span>
				<span class="s">&quot;3105 failed to allocate mailbox memory</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">lpfc_sli4_dump_cfg_rg23</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">mboxq</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="n">mqe</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">mboxq</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">mqe</span><span class="p">;</span>
	<span class="n">mp</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_dmabuf</span> <span class="o">*</span><span class="p">)</span> <span class="n">mboxq</span><span class="o">-&gt;</span><span class="n">context1</span><span class="p">;</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">lpfc_sli_issue_mbox</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">mboxq</span><span class="p">,</span> <span class="n">MBX_POLL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="n">data_length</span> <span class="o">=</span> <span class="n">mqe</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">mb_words</span><span class="p">[</span><span class="mi">5</span><span class="p">];</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">data_length</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">data_length</span> <span class="o">&gt;</span> <span class="n">DMP_RGN23_SIZE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">data_length</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">lpfc_sli_pcimem_bcopy</span><span class="p">((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">mp</span><span class="o">-&gt;</span><span class="n">virt</span><span class="p">,</span> <span class="n">rgn23_data</span><span class="p">,</span> <span class="n">data_length</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="n">mempool_free</span><span class="p">(</span><span class="n">mboxq</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">mbox_mem_pool</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mp</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lpfc_mbuf_free</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">virt</span><span class="p">,</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">phys</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">mp</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">data_length</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_sli_read_link_ste - Read region 23 to decide if link is disabled.</span>
<span class="cm"> * @phba: pointer to lpfc hba data structure.</span>
<span class="cm"> *</span>
<span class="cm"> * This function read region 23 and parse TLV for port status to</span>
<span class="cm"> * decide if the user disaled the port. If the TLV indicates the</span>
<span class="cm"> * port is disabled, the hba_flag is set accordingly.</span>
<span class="cm"> **/</span>
<span class="kt">void</span>
<span class="nf">lpfc_sli_read_link_ste</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">uint8_t</span> <span class="o">*</span><span class="n">rgn23_data</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">if_type</span><span class="p">,</span> <span class="n">data_size</span><span class="p">,</span> <span class="n">sub_tlv_len</span><span class="p">,</span> <span class="n">tlv_offset</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Get adapter Region 23 data */</span>
	<span class="n">rgn23_data</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="n">DMP_RGN23_SIZE</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rgn23_data</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli_rev</span> <span class="o">&lt;</span> <span class="n">LPFC_SLI_REV4</span><span class="p">)</span>
		<span class="n">data_size</span> <span class="o">=</span> <span class="n">lpfc_sli_get_config_region23</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">rgn23_data</span><span class="p">);</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="n">if_type</span> <span class="o">=</span> <span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_sli_intf_if_type</span><span class="p">,</span>
				 <span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">sli_intf</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">if_type</span> <span class="o">==</span> <span class="n">LPFC_SLI_INTF_IF_TYPE_0</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="n">data_size</span> <span class="o">=</span> <span class="n">lpfc_sli4_get_config_region23</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">rgn23_data</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">data_size</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="cm">/* Check the region signature first */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">memcmp</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rgn23_data</span><span class="p">[</span><span class="n">offset</span><span class="p">],</span> <span class="n">LPFC_REGION23_SIGNATURE</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_INIT</span><span class="p">,</span>
			<span class="s">&quot;2619 Config region 23 has bad signature</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">offset</span> <span class="o">+=</span> <span class="mi">4</span><span class="p">;</span>

	<span class="cm">/* Check the data structure version */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rgn23_data</span><span class="p">[</span><span class="n">offset</span><span class="p">]</span> <span class="o">!=</span> <span class="n">LPFC_REGION23_VERSION</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_INIT</span><span class="p">,</span>
			<span class="s">&quot;2620 Config region 23 has bad version</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">offset</span> <span class="o">+=</span> <span class="mi">4</span><span class="p">;</span>

	<span class="cm">/* Parse TLV entries in the region */</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">offset</span> <span class="o">&lt;</span> <span class="n">data_size</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rgn23_data</span><span class="p">[</span><span class="n">offset</span><span class="p">]</span> <span class="o">==</span> <span class="n">LPFC_REGION23_LAST_REC</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * If the TLV is not driver specific TLV or driver id is</span>
<span class="cm">		 * not linux driver id, skip the record.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">rgn23_data</span><span class="p">[</span><span class="n">offset</span><span class="p">]</span> <span class="o">!=</span> <span class="n">DRIVER_SPECIFIC_TYPE</span><span class="p">)</span> <span class="o">||</span>
		    <span class="p">(</span><span class="n">rgn23_data</span><span class="p">[</span><span class="n">offset</span> <span class="o">+</span> <span class="mi">2</span><span class="p">]</span> <span class="o">!=</span> <span class="n">LINUX_DRIVER_ID</span><span class="p">)</span> <span class="o">||</span>
		    <span class="p">(</span><span class="n">rgn23_data</span><span class="p">[</span><span class="n">offset</span> <span class="o">+</span> <span class="mi">3</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">offset</span> <span class="o">+=</span> <span class="n">rgn23_data</span><span class="p">[</span><span class="n">offset</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="mi">4</span> <span class="o">+</span> <span class="mi">4</span><span class="p">;</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* Driver found a driver specific TLV in the config region */</span>
		<span class="n">sub_tlv_len</span> <span class="o">=</span> <span class="n">rgn23_data</span><span class="p">[</span><span class="n">offset</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="mi">4</span><span class="p">;</span>
		<span class="n">offset</span> <span class="o">+=</span> <span class="mi">4</span><span class="p">;</span>
		<span class="n">tlv_offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * Search for configured port state sub-TLV.</span>
<span class="cm">		 */</span>
		<span class="k">while</span> <span class="p">((</span><span class="n">offset</span> <span class="o">&lt;</span> <span class="n">data_size</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			<span class="p">(</span><span class="n">tlv_offset</span> <span class="o">&lt;</span> <span class="n">sub_tlv_len</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">rgn23_data</span><span class="p">[</span><span class="n">offset</span><span class="p">]</span> <span class="o">==</span> <span class="n">LPFC_REGION23_LAST_REC</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">offset</span> <span class="o">+=</span> <span class="mi">4</span><span class="p">;</span>
				<span class="n">tlv_offset</span> <span class="o">+=</span> <span class="mi">4</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">rgn23_data</span><span class="p">[</span><span class="n">offset</span><span class="p">]</span> <span class="o">!=</span> <span class="n">PORT_STE_TYPE</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">offset</span> <span class="o">+=</span> <span class="n">rgn23_data</span><span class="p">[</span><span class="n">offset</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="mi">4</span> <span class="o">+</span> <span class="mi">4</span><span class="p">;</span>
				<span class="n">tlv_offset</span> <span class="o">+=</span> <span class="n">rgn23_data</span><span class="p">[</span><span class="n">offset</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="mi">4</span> <span class="o">+</span> <span class="mi">4</span><span class="p">;</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="cm">/* This HBA contains PORT_STE configured */</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rgn23_data</span><span class="p">[</span><span class="n">offset</span> <span class="o">+</span> <span class="mi">2</span><span class="p">])</span>
				<span class="n">phba</span><span class="o">-&gt;</span><span class="n">hba_flag</span> <span class="o">|=</span> <span class="n">LINK_DISABLED</span><span class="p">;</span>

			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

<span class="nl">out:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">rgn23_data</span><span class="p">);</span>
	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_wr_object - write an object to the firmware</span>
<span class="cm"> * @phba: HBA structure that indicates port to create a queue on.</span>
<span class="cm"> * @dmabuf_list: list of dmabufs to write to the port.</span>
<span class="cm"> * @size: the total byte value of the objects to write to the port.</span>
<span class="cm"> * @offset: the current offset to be used to start the transfer.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine will create a wr_object mailbox command to send to the port.</span>
<span class="cm"> * the mailbox command will be constructed using the dma buffers described in</span>
<span class="cm"> * @dmabuf_list to create a list of BDEs. This routine will fill in as many</span>
<span class="cm"> * BDEs that the imbedded mailbox can support. The @offset variable will be</span>
<span class="cm"> * used to indicate the starting offset of the transfer and will also return</span>
<span class="cm"> * the offset after the write object mailbox has completed. @size is used to</span>
<span class="cm"> * determine the end of the object and whether the eof bit should be set.</span>
<span class="cm"> *</span>
<span class="cm"> * Return 0 is successful and offset will contain the the new offset to use</span>
<span class="cm"> * for the next write.</span>
<span class="cm"> * Return negative value for error cases.</span>
<span class="cm"> **/</span>
<span class="kt">int</span>
<span class="nf">lpfc_wr_object</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">,</span> <span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">dmabuf_list</span><span class="p">,</span>
	       <span class="kt">uint32_t</span> <span class="n">size</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="o">*</span><span class="n">offset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpfc_mbx_wr_object</span> <span class="o">*</span><span class="n">wr_object</span><span class="p">;</span>
	<span class="n">LPFC_MBOXQ_t</span> <span class="o">*</span><span class="n">mbox</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">shdr_status</span><span class="p">,</span> <span class="n">shdr_add_status</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">mbox_tmo</span><span class="p">;</span>
	<span class="k">union</span> <span class="n">lpfc_sli4_cfg_shdr</span> <span class="o">*</span><span class="n">shdr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_dmabuf</span> <span class="o">*</span><span class="n">dmabuf</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">written</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">mbox</span> <span class="o">=</span> <span class="n">mempool_alloc</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">mbox_mem_pool</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mbox</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">lpfc_sli4_config</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">mbox</span><span class="p">,</span> <span class="n">LPFC_MBOX_SUBSYSTEM_COMMON</span><span class="p">,</span>
			<span class="n">LPFC_MBOX_OPCODE_WRITE_OBJECT</span><span class="p">,</span>
			<span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_mbx_wr_object</span><span class="p">)</span> <span class="o">-</span>
			<span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_sli4_cfg_mhdr</span><span class="p">),</span> <span class="n">LPFC_SLI4_MBX_EMBED</span><span class="p">);</span>

	<span class="n">wr_object</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_mbx_wr_object</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">mbox</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">mqe</span><span class="p">.</span><span class="n">un</span><span class="p">.</span><span class="n">wr_object</span><span class="p">;</span>
	<span class="n">wr_object</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">request</span><span class="p">.</span><span class="n">write_offset</span> <span class="o">=</span> <span class="o">*</span><span class="n">offset</span><span class="p">;</span>
	<span class="n">sprintf</span><span class="p">((</span><span class="kt">uint8_t</span> <span class="o">*</span><span class="p">)</span><span class="n">wr_object</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">request</span><span class="p">.</span><span class="n">object_name</span><span class="p">,</span> <span class="s">&quot;/&quot;</span><span class="p">);</span>
	<span class="n">wr_object</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">request</span><span class="p">.</span><span class="n">object_name</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span>
		<span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">wr_object</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">request</span><span class="p">.</span><span class="n">object_name</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
	<span class="n">bf_set</span><span class="p">(</span><span class="n">lpfc_wr_object_eof</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wr_object</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">request</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">dmabuf</span><span class="p">,</span> <span class="n">dmabuf_list</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&gt;=</span> <span class="n">LPFC_MBX_WR_CONFIG_MAX_BDE</span> <span class="o">||</span> <span class="n">written</span> <span class="o">&gt;=</span> <span class="n">size</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">wr_object</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">request</span><span class="p">.</span><span class="n">bde</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">addrLow</span> <span class="o">=</span> <span class="n">putPaddrLow</span><span class="p">(</span><span class="n">dmabuf</span><span class="o">-&gt;</span><span class="n">phys</span><span class="p">);</span>
		<span class="n">wr_object</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">request</span><span class="p">.</span><span class="n">bde</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">addrHigh</span> <span class="o">=</span>
			<span class="n">putPaddrHigh</span><span class="p">(</span><span class="n">dmabuf</span><span class="o">-&gt;</span><span class="n">phys</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">written</span> <span class="o">+</span> <span class="n">SLI4_PAGE_SIZE</span> <span class="o">&gt;=</span> <span class="n">size</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">wr_object</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">request</span><span class="p">.</span><span class="n">bde</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">tus</span><span class="p">.</span><span class="n">f</span><span class="p">.</span><span class="n">bdeSize</span> <span class="o">=</span>
				<span class="p">(</span><span class="n">size</span> <span class="o">-</span> <span class="n">written</span><span class="p">);</span>
			<span class="n">written</span> <span class="o">+=</span> <span class="p">(</span><span class="n">size</span> <span class="o">-</span> <span class="n">written</span><span class="p">);</span>
			<span class="n">bf_set</span><span class="p">(</span><span class="n">lpfc_wr_object_eof</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wr_object</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">request</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">wr_object</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">request</span><span class="p">.</span><span class="n">bde</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">tus</span><span class="p">.</span><span class="n">f</span><span class="p">.</span><span class="n">bdeSize</span> <span class="o">=</span>
				<span class="n">SLI4_PAGE_SIZE</span><span class="p">;</span>
			<span class="n">written</span> <span class="o">+=</span> <span class="n">SLI4_PAGE_SIZE</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">i</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">wr_object</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">request</span><span class="p">.</span><span class="n">bde_count</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
	<span class="n">bf_set</span><span class="p">(</span><span class="n">lpfc_wr_object_write_length</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wr_object</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">request</span><span class="p">,</span> <span class="n">written</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">intr_enable</span><span class="p">)</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">lpfc_sli_issue_mbox</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">mbox</span><span class="p">,</span> <span class="n">MBX_POLL</span><span class="p">);</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="n">mbox_tmo</span> <span class="o">=</span> <span class="n">lpfc_mbox_tmo_val</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">mbox</span><span class="p">);</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">lpfc_sli_issue_mbox_wait</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">mbox</span><span class="p">,</span> <span class="n">mbox_tmo</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="cm">/* The IOCTL status is embedded in the mailbox subheader. */</span>
	<span class="n">shdr</span> <span class="o">=</span> <span class="p">(</span><span class="k">union</span> <span class="n">lpfc_sli4_cfg_shdr</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">wr_object</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">cfg_shdr</span><span class="p">;</span>
	<span class="n">shdr_status</span> <span class="o">=</span> <span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_mbox_hdr_status</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">shdr</span><span class="o">-&gt;</span><span class="n">response</span><span class="p">);</span>
	<span class="n">shdr_add_status</span> <span class="o">=</span> <span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_mbox_hdr_add_status</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">shdr</span><span class="o">-&gt;</span><span class="n">response</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">!=</span> <span class="n">MBX_TIMEOUT</span><span class="p">)</span>
		<span class="n">mempool_free</span><span class="p">(</span><span class="n">mbox</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">mbox_mem_pool</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">shdr_status</span> <span class="o">||</span> <span class="n">shdr_add_status</span> <span class="o">||</span> <span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_INIT</span><span class="p">,</span>
				<span class="s">&quot;3025 Write Object mailbox failed with &quot;</span>
				<span class="s">&quot;status x%x add_status x%x, mbx status x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">shdr_status</span><span class="p">,</span> <span class="n">shdr_add_status</span><span class="p">,</span> <span class="n">rc</span><span class="p">);</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENXIO</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="o">*</span><span class="n">offset</span> <span class="o">+=</span> <span class="n">wr_object</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">response</span><span class="p">.</span><span class="n">actual_write_length</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_cleanup_pending_mbox - Free up vport discovery mailbox commands.</span>
<span class="cm"> * @vport: pointer to vport data structure.</span>
<span class="cm"> *</span>
<span class="cm"> * This function iterate through the mailboxq and clean up all REG_LOGIN</span>
<span class="cm"> * and REG_VPI mailbox commands associated with the vport. This function</span>
<span class="cm"> * is called when driver want to restart discovery of the vport due to</span>
<span class="cm"> * a Clear Virtual Link event.</span>
<span class="cm"> **/</span>
<span class="kt">void</span>
<span class="nf">lpfc_cleanup_pending_mbox</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="n">vport</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span> <span class="o">=</span> <span class="n">vport</span><span class="o">-&gt;</span><span class="n">phba</span><span class="p">;</span>
	<span class="n">LPFC_MBOXQ_t</span> <span class="o">*</span><span class="n">mb</span><span class="p">,</span> <span class="o">*</span><span class="n">nextmb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_dmabuf</span> <span class="o">*</span><span class="n">mp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_nodelist</span> <span class="o">*</span><span class="n">ndlp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_nodelist</span> <span class="o">*</span><span class="n">act_mbx_ndlp</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span>  <span class="o">*</span><span class="n">shost</span> <span class="o">=</span> <span class="n">lpfc_shost_from_vport</span><span class="p">(</span><span class="n">vport</span><span class="p">);</span>
	<span class="n">LIST_HEAD</span><span class="p">(</span><span class="n">mbox_cmd_list</span><span class="p">);</span>
	<span class="kt">uint8_t</span> <span class="n">restart_loop</span><span class="p">;</span>

	<span class="cm">/* Clean up internally queued mailbox commands with the vport */</span>
	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>
	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">mb</span><span class="p">,</span> <span class="n">nextmb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli</span><span class="p">.</span><span class="n">mboxq</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">mb</span><span class="o">-&gt;</span><span class="n">vport</span> <span class="o">!=</span> <span class="n">vport</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">((</span><span class="n">mb</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">mb</span><span class="p">.</span><span class="n">mbxCommand</span> <span class="o">!=</span> <span class="n">MBX_REG_LOGIN64</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			<span class="p">(</span><span class="n">mb</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">mb</span><span class="p">.</span><span class="n">mbxCommand</span> <span class="o">!=</span> <span class="n">MBX_REG_VPI</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mb</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
		<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mb</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mbox_cmd_list</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="cm">/* Clean up active mailbox command with the vport */</span>
	<span class="n">mb</span> <span class="o">=</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli</span><span class="p">.</span><span class="n">mbox_active</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mb</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">mb</span><span class="o">-&gt;</span><span class="n">vport</span> <span class="o">==</span> <span class="n">vport</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">mb</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">mb</span><span class="p">.</span><span class="n">mbxCommand</span> <span class="o">==</span> <span class="n">MBX_REG_LOGIN64</span><span class="p">)</span> <span class="o">||</span>
			<span class="p">(</span><span class="n">mb</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">mb</span><span class="p">.</span><span class="n">mbxCommand</span> <span class="o">==</span> <span class="n">MBX_REG_VPI</span><span class="p">))</span>
			<span class="n">mb</span><span class="o">-&gt;</span><span class="n">mbox_cmpl</span> <span class="o">=</span> <span class="n">lpfc_sli_def_mbox_cmpl</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">mb</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">mb</span><span class="p">.</span><span class="n">mbxCommand</span> <span class="o">==</span> <span class="n">MBX_REG_LOGIN64</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">act_mbx_ndlp</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_nodelist</span> <span class="o">*</span><span class="p">)</span><span class="n">mb</span><span class="o">-&gt;</span><span class="n">context2</span><span class="p">;</span>
			<span class="cm">/* Put reference count for delayed processing */</span>
			<span class="n">act_mbx_ndlp</span> <span class="o">=</span> <span class="n">lpfc_nlp_get</span><span class="p">(</span><span class="n">act_mbx_ndlp</span><span class="p">);</span>
			<span class="cm">/* Unregister the RPI when mailbox complete */</span>
			<span class="n">mb</span><span class="o">-&gt;</span><span class="n">mbox_flag</span> <span class="o">|=</span> <span class="n">LPFC_MBX_IMED_UNREG</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="cm">/* Cleanup any mailbox completions which are not yet processed */</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="n">restart_loop</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">mb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli</span><span class="p">.</span><span class="n">mboxq_cmpl</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * If this mailox is already processed or it is</span>
<span class="cm">			 * for another vport ignore it.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">mb</span><span class="o">-&gt;</span><span class="n">vport</span> <span class="o">!=</span> <span class="n">vport</span><span class="p">)</span> <span class="o">||</span>
				<span class="p">(</span><span class="n">mb</span><span class="o">-&gt;</span><span class="n">mbox_flag</span> <span class="o">&amp;</span> <span class="n">LPFC_MBX_IMED_UNREG</span><span class="p">))</span>
				<span class="k">continue</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">((</span><span class="n">mb</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">mb</span><span class="p">.</span><span class="n">mbxCommand</span> <span class="o">!=</span> <span class="n">MBX_REG_LOGIN64</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
				<span class="p">(</span><span class="n">mb</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">mb</span><span class="p">.</span><span class="n">mbxCommand</span> <span class="o">!=</span> <span class="n">MBX_REG_VPI</span><span class="p">))</span>
				<span class="k">continue</span><span class="p">;</span>

			<span class="n">mb</span><span class="o">-&gt;</span><span class="n">mbox_cmpl</span> <span class="o">=</span> <span class="n">lpfc_sli_def_mbox_cmpl</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">mb</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">mb</span><span class="p">.</span><span class="n">mbxCommand</span> <span class="o">==</span> <span class="n">MBX_REG_LOGIN64</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">ndlp</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_nodelist</span> <span class="o">*</span><span class="p">)</span><span class="n">mb</span><span class="o">-&gt;</span><span class="n">context2</span><span class="p">;</span>
				<span class="cm">/* Unregister the RPI when mailbox complete */</span>
				<span class="n">mb</span><span class="o">-&gt;</span><span class="n">mbox_flag</span> <span class="o">|=</span> <span class="n">LPFC_MBX_IMED_UNREG</span><span class="p">;</span>
				<span class="n">restart_loop</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
				<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>
				<span class="n">spin_lock</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>
				<span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_flag</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">NLP_IGNR_REG_CMPL</span><span class="p">;</span>
				<span class="n">spin_unlock</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>
				<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">restart_loop</span><span class="p">);</span>

	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>

	<span class="cm">/* Release the cleaned-up mailbox commands */</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mbox_cmd_list</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">list_remove_head</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mbox_cmd_list</span><span class="p">,</span> <span class="n">mb</span><span class="p">,</span> <span class="n">LPFC_MBOXQ_t</span><span class="p">,</span> <span class="n">list</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">mb</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">mb</span><span class="p">.</span><span class="n">mbxCommand</span> <span class="o">==</span> <span class="n">MBX_REG_LOGIN64</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">mp</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_dmabuf</span> <span class="o">*</span><span class="p">)</span> <span class="p">(</span><span class="n">mb</span><span class="o">-&gt;</span><span class="n">context1</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">mp</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">__lpfc_mbuf_free</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">virt</span><span class="p">,</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">phys</span><span class="p">);</span>
				<span class="n">kfree</span><span class="p">(</span><span class="n">mp</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="n">ndlp</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_nodelist</span> <span class="o">*</span><span class="p">)</span> <span class="n">mb</span><span class="o">-&gt;</span><span class="n">context2</span><span class="p">;</span>
			<span class="n">mb</span><span class="o">-&gt;</span><span class="n">context2</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ndlp</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">spin_lock</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>
				<span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_flag</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">NLP_IGNR_REG_CMPL</span><span class="p">;</span>
				<span class="n">spin_unlock</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>
				<span class="n">lpfc_nlp_put</span><span class="p">(</span><span class="n">ndlp</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="n">mempool_free</span><span class="p">(</span><span class="n">mb</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">mbox_mem_pool</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Release the ndlp with the cleaned-up active mailbox command */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">act_mbx_ndlp</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>
		<span class="n">act_mbx_ndlp</span><span class="o">-&gt;</span><span class="n">nlp_flag</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">NLP_IGNR_REG_CMPL</span><span class="p">;</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>
		<span class="n">lpfc_nlp_put</span><span class="p">(</span><span class="n">act_mbx_ndlp</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_drain_txq - Drain the txq</span>
<span class="cm"> * @phba: Pointer to HBA context object.</span>
<span class="cm"> *</span>
<span class="cm"> * This function attempt to submit IOCBs on the txq</span>
<span class="cm"> * to the adapter.  For SLI4 adapters, the txq contains</span>
<span class="cm"> * ELS IOCBs that have been deferred because the there</span>
<span class="cm"> * are no SGLs.  This congestion can occur with large</span>
<span class="cm"> * vport counts during node discovery.</span>
<span class="cm"> **/</span>

<span class="kt">uint32_t</span>
<span class="nf">lpfc_drain_txq</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">LIST_HEAD</span><span class="p">(</span><span class="n">completions</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">lpfc_sli_ring</span> <span class="o">*</span><span class="n">pring</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli</span><span class="p">.</span><span class="n">ring</span><span class="p">[</span><span class="n">LPFC_ELS_RING</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">lpfc_iocbq</span> <span class="o">*</span><span class="n">piocbq</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">iflags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">fail_msg</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_sglq</span> <span class="o">*</span><span class="n">sglq</span><span class="p">;</span>
	<span class="k">union</span> <span class="n">lpfc_wqe</span> <span class="n">wqe</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">,</span> <span class="n">iflags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pring</span><span class="o">-&gt;</span><span class="n">txq_cnt</span> <span class="o">&gt;</span> <span class="n">pring</span><span class="o">-&gt;</span><span class="n">txq_max</span><span class="p">)</span>
		<span class="n">pring</span><span class="o">-&gt;</span><span class="n">txq_max</span> <span class="o">=</span> <span class="n">pring</span><span class="o">-&gt;</span><span class="n">txq_cnt</span><span class="p">;</span>

	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">,</span> <span class="n">iflags</span><span class="p">);</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">pring</span><span class="o">-&gt;</span><span class="n">txq_cnt</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">,</span> <span class="n">iflags</span><span class="p">);</span>

		<span class="n">piocbq</span> <span class="o">=</span> <span class="n">lpfc_sli_ringtx_get</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">pring</span><span class="p">);</span>
		<span class="n">sglq</span> <span class="o">=</span> <span class="n">__lpfc_sli_get_sglq</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">piocbq</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sglq</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">__lpfc_sli_ringtx_put</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">pring</span><span class="p">,</span> <span class="n">piocbq</span><span class="p">);</span>
			<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">,</span> <span class="n">iflags</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">piocbq</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/* The txq_cnt out of sync. This should</span>
<span class="cm">				 * never happen</span>
<span class="cm">				 */</span>
				<span class="n">sglq</span> <span class="o">=</span> <span class="n">__lpfc_clear_active_sglq</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span>
						 <span class="n">sglq</span><span class="o">-&gt;</span><span class="n">sli4_lxritag</span><span class="p">);</span>
				<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">,</span> <span class="n">iflags</span><span class="p">);</span>
				<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_SLI</span><span class="p">,</span>
					<span class="s">&quot;2823 txq empty and txq_cnt is %d</span><span class="se">\n</span><span class="s"> &quot;</span><span class="p">,</span>
					<span class="n">pring</span><span class="o">-&gt;</span><span class="n">txq_cnt</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="cm">/* The xri and iocb resources secured,</span>
<span class="cm">		 * attempt to issue request</span>
<span class="cm">		 */</span>
		<span class="n">piocbq</span><span class="o">-&gt;</span><span class="n">sli4_lxritag</span> <span class="o">=</span> <span class="n">sglq</span><span class="o">-&gt;</span><span class="n">sli4_lxritag</span><span class="p">;</span>
		<span class="n">piocbq</span><span class="o">-&gt;</span><span class="n">sli4_xritag</span> <span class="o">=</span> <span class="n">sglq</span><span class="o">-&gt;</span><span class="n">sli4_xritag</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">NO_XRI</span> <span class="o">==</span> <span class="n">lpfc_sli4_bpl2sgl</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">piocbq</span><span class="p">,</span> <span class="n">sglq</span><span class="p">))</span>
			<span class="n">fail_msg</span> <span class="o">=</span> <span class="s">&quot;to convert bpl to sgl&quot;</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">lpfc_sli4_iocb2wqe</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">piocbq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wqe</span><span class="p">))</span>
			<span class="n">fail_msg</span> <span class="o">=</span> <span class="s">&quot;to convert iocb to wqe&quot;</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">lpfc_sli4_wq_put</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">els_wq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wqe</span><span class="p">))</span>
			<span class="n">fail_msg</span> <span class="o">=</span> <span class="s">&quot; - Wq is full&quot;</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">lpfc_sli_ringtxcmpl_put</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">pring</span><span class="p">,</span> <span class="n">piocbq</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">fail_msg</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Failed means we can&#39;t issue and need to cancel */</span>
			<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_SLI</span><span class="p">,</span>
					<span class="s">&quot;2822 IOCB failed %s iotag 0x%x &quot;</span>
					<span class="s">&quot;xri 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">fail_msg</span><span class="p">,</span>
					<span class="n">piocbq</span><span class="o">-&gt;</span><span class="n">iotag</span><span class="p">,</span> <span class="n">piocbq</span><span class="o">-&gt;</span><span class="n">sli4_xritag</span><span class="p">);</span>
			<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">piocbq</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">completions</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">,</span> <span class="n">iflags</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Cancel all the IOCBs that cannot be issued */</span>
	<span class="n">lpfc_sli_cancel_iocbs</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">completions</span><span class="p">,</span> <span class="n">IOSTAT_LOCAL_REJECT</span><span class="p">,</span>
				<span class="n">IOERR_SLI_ABORTED</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">pring</span><span class="o">-&gt;</span><span class="n">txq_cnt</span><span class="p">;</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
