<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › scsi › lpfc › lpfc_scsi.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>lpfc_scsi.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*******************************************************************</span>
<span class="cm"> * This file is part of the Emulex Linux Device Driver for         *</span>
<span class="cm"> * Fibre Channel Host Bus Adapters.                                *</span>
<span class="cm"> * Copyright (C) 2004-2012 Emulex.  All rights reserved.           *</span>
<span class="cm"> * EMULEX and SLI are trademarks of Emulex.                        *</span>
<span class="cm"> * www.emulex.com                                                  *</span>
<span class="cm"> * Portions Copyright (C) 2004-2005 Christoph Hellwig              *</span>
<span class="cm"> *                                                                 *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or   *</span>
<span class="cm"> * modify it under the terms of version 2 of the GNU General       *</span>
<span class="cm"> * Public License as published by the Free Software Foundation.    *</span>
<span class="cm"> * This program is distributed in the hope that it will be useful. *</span>
<span class="cm"> * ALL EXPRESS OR IMPLIED CONDITIONS, REPRESENTATIONS AND          *</span>
<span class="cm"> * WARRANTIES, INCLUDING ANY IMPLIED WARRANTY OF MERCHANTABILITY,  *</span>
<span class="cm"> * FITNESS FOR A PARTICULAR PURPOSE, OR NON-INFRINGEMENT, ARE      *</span>
<span class="cm"> * DISCLAIMED, EXCEPT TO THE EXTENT THAT SUCH DISCLAIMERS ARE HELD *</span>
<span class="cm"> * TO BE LEGALLY INVALID.  See the GNU General Public License for  *</span>
<span class="cm"> * more details, a copy of which can be found in the file COPYING  *</span>
<span class="cm"> * included with this package.                                     *</span>
<span class="cm"> *******************************************************************/</span>
<span class="cp">#include &lt;linux/pci.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/interrupt.h&gt;</span>
<span class="cp">#include &lt;linux/export.h&gt;</span>
<span class="cp">#include &lt;linux/delay.h&gt;</span>
<span class="cp">#include &lt;asm/unaligned.h&gt;</span>

<span class="cp">#include &lt;scsi/scsi.h&gt;</span>
<span class="cp">#include &lt;scsi/scsi_device.h&gt;</span>
<span class="cp">#include &lt;scsi/scsi_eh.h&gt;</span>
<span class="cp">#include &lt;scsi/scsi_host.h&gt;</span>
<span class="cp">#include &lt;scsi/scsi_tcq.h&gt;</span>
<span class="cp">#include &lt;scsi/scsi_transport_fc.h&gt;</span>

<span class="cp">#include &quot;lpfc_version.h&quot;</span>
<span class="cp">#include &quot;lpfc_hw4.h&quot;</span>
<span class="cp">#include &quot;lpfc_hw.h&quot;</span>
<span class="cp">#include &quot;lpfc_sli.h&quot;</span>
<span class="cp">#include &quot;lpfc_sli4.h&quot;</span>
<span class="cp">#include &quot;lpfc_nl.h&quot;</span>
<span class="cp">#include &quot;lpfc_disc.h&quot;</span>
<span class="cp">#include &quot;lpfc.h&quot;</span>
<span class="cp">#include &quot;lpfc_scsi.h&quot;</span>
<span class="cp">#include &quot;lpfc_logmsg.h&quot;</span>
<span class="cp">#include &quot;lpfc_crtn.h&quot;</span>
<span class="cp">#include &quot;lpfc_vport.h&quot;</span>

<span class="cp">#define LPFC_RESET_WAIT  2</span>
<span class="cp">#define LPFC_ABORT_WAIT  2</span>

<span class="kt">int</span> <span class="n">_dump_buf_done</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">char</span> <span class="o">*</span><span class="n">dif_op_str</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="s">&quot;PROT_NORMAL&quot;</span><span class="p">,</span>
	<span class="s">&quot;PROT_READ_INSERT&quot;</span><span class="p">,</span>
	<span class="s">&quot;PROT_WRITE_STRIP&quot;</span><span class="p">,</span>
	<span class="s">&quot;PROT_READ_STRIP&quot;</span><span class="p">,</span>
	<span class="s">&quot;PROT_WRITE_INSERT&quot;</span><span class="p">,</span>
	<span class="s">&quot;PROT_READ_PASS&quot;</span><span class="p">,</span>
	<span class="s">&quot;PROT_WRITE_PASS&quot;</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">char</span> <span class="o">*</span><span class="n">dif_grd_str</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="s">&quot;NO_GUARD&quot;</span><span class="p">,</span>
	<span class="s">&quot;DIF_CRC&quot;</span><span class="p">,</span>
	<span class="s">&quot;DIX_IP&quot;</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">scsi_dif_tuple</span> <span class="p">{</span>
	<span class="n">__be16</span> <span class="n">guard_tag</span><span class="p">;</span>       <span class="cm">/* Checksum */</span>
	<span class="n">__be16</span> <span class="n">app_tag</span><span class="p">;</span>         <span class="cm">/* Opaque storage */</span>
	<span class="n">__be32</span> <span class="n">ref_tag</span><span class="p">;</span>         <span class="cm">/* Target LBA or indirect LBA */</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="n">lpfc_release_scsi_buf_s4</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">,</span> <span class="k">struct</span> <span class="n">lpfc_scsi_buf</span> <span class="o">*</span><span class="n">psb</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="n">lpfc_release_scsi_buf_s3</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">,</span> <span class="k">struct</span> <span class="n">lpfc_scsi_buf</span> <span class="o">*</span><span class="n">psb</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">lpfc_debug_save_data</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">,</span> <span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="n">cmnd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">src</span><span class="p">,</span> <span class="o">*</span><span class="n">dst</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">scatterlist</span> <span class="o">*</span><span class="n">sgde</span> <span class="o">=</span> <span class="n">scsi_sglist</span><span class="p">(</span><span class="n">cmnd</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">_dump_buf_data</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_BG</span><span class="p">,</span>
			<span class="s">&quot;9050 BLKGRD: ERROR %s _dump_buf_data is NULL</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">__func__</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>


	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sgde</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_BG</span><span class="p">,</span>
			<span class="s">&quot;9051 BLKGRD: ERROR: data scatterlist is null</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">dst</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span> <span class="n">_dump_buf_data</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">sgde</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">src</span> <span class="o">=</span> <span class="n">sg_virt</span><span class="p">(</span><span class="n">sgde</span><span class="p">);</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">dst</span><span class="p">,</span> <span class="n">src</span><span class="p">,</span> <span class="n">sgde</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">);</span>
		<span class="n">dst</span> <span class="o">+=</span> <span class="n">sgde</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">;</span>
		<span class="n">sgde</span> <span class="o">=</span> <span class="n">sg_next</span><span class="p">(</span><span class="n">sgde</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">lpfc_debug_save_dif</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">,</span> <span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="n">cmnd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">src</span><span class="p">,</span> <span class="o">*</span><span class="n">dst</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">scatterlist</span> <span class="o">*</span><span class="n">sgde</span> <span class="o">=</span> <span class="n">scsi_prot_sglist</span><span class="p">(</span><span class="n">cmnd</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">_dump_buf_dif</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_BG</span><span class="p">,</span>
			<span class="s">&quot;9052 BLKGRD: ERROR %s _dump_buf_data is NULL</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">__func__</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sgde</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_BG</span><span class="p">,</span>
			<span class="s">&quot;9053 BLKGRD: ERROR: prot scatterlist is null</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">dst</span> <span class="o">=</span> <span class="n">_dump_buf_dif</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">sgde</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">src</span> <span class="o">=</span> <span class="n">sg_virt</span><span class="p">(</span><span class="n">sgde</span><span class="p">);</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">dst</span><span class="p">,</span> <span class="n">src</span><span class="p">,</span> <span class="n">sgde</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">);</span>
		<span class="n">dst</span> <span class="o">+=</span> <span class="n">sgde</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">;</span>
		<span class="n">sgde</span> <span class="o">=</span> <span class="n">sg_next</span><span class="p">(</span><span class="n">sgde</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_sli4_set_rsp_sgl_last - Set the last bit in the response sge.</span>
<span class="cm"> * @phba: Pointer to HBA object.</span>
<span class="cm"> * @lpfc_cmd: lpfc scsi command object pointer.</span>
<span class="cm"> *</span>
<span class="cm"> * This function is called from the lpfc_prep_task_mgmt_cmd function to</span>
<span class="cm"> * set the last bit in the response sge entry.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">lpfc_sli4_set_rsp_sgl_last</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">lpfc_scsi_buf</span> <span class="o">*</span><span class="n">lpfc_cmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sli4_sge</span> <span class="o">*</span><span class="n">sgl</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sli4_sge</span> <span class="o">*</span><span class="p">)</span><span class="n">lpfc_cmd</span><span class="o">-&gt;</span><span class="n">fcp_bpl</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sgl</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">sgl</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">sgl</span><span class="o">-&gt;</span><span class="n">word2</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">sgl</span><span class="o">-&gt;</span><span class="n">word2</span><span class="p">);</span>
		<span class="n">bf_set</span><span class="p">(</span><span class="n">lpfc_sli4_sge_last</span><span class="p">,</span> <span class="n">sgl</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">sgl</span><span class="o">-&gt;</span><span class="n">word2</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">sgl</span><span class="o">-&gt;</span><span class="n">word2</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_update_stats - Update statistical data for the command completion</span>
<span class="cm"> * @phba: Pointer to HBA object.</span>
<span class="cm"> * @lpfc_cmd: lpfc scsi command object pointer.</span>
<span class="cm"> *</span>
<span class="cm"> * This function is called when there is a command completion and this</span>
<span class="cm"> * function updates the statistical data for the command completion.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">lpfc_update_stats</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">,</span> <span class="k">struct</span>  <span class="n">lpfc_scsi_buf</span> <span class="o">*</span><span class="n">lpfc_cmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpfc_rport_data</span> <span class="o">*</span><span class="n">rdata</span> <span class="o">=</span> <span class="n">lpfc_cmd</span><span class="o">-&gt;</span><span class="n">rdata</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_nodelist</span> <span class="o">*</span><span class="n">pnode</span> <span class="o">=</span> <span class="n">rdata</span><span class="o">-&gt;</span><span class="n">pnode</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="n">cmd</span> <span class="o">=</span> <span class="n">lpfc_cmd</span><span class="o">-&gt;</span><span class="n">pCmd</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span>  <span class="o">*</span><span class="n">shost</span> <span class="o">=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="n">vport</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="p">)</span> <span class="n">shost</span><span class="o">-&gt;</span><span class="n">hostdata</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">latency</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">result</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">latency</span> <span class="o">=</span> <span class="n">jiffies_to_msecs</span><span class="p">((</span><span class="kt">long</span><span class="p">)</span><span class="n">jiffies</span> <span class="o">-</span> <span class="p">(</span><span class="kt">long</span><span class="p">)</span><span class="n">lpfc_cmd</span><span class="o">-&gt;</span><span class="n">start_time</span><span class="p">);</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">stat_data_enabled</span> <span class="o">||</span>
		<span class="n">vport</span><span class="o">-&gt;</span><span class="n">stat_data_blocked</span> <span class="o">||</span>
		<span class="o">!</span><span class="n">pnode</span> <span class="o">||</span>
		<span class="o">!</span><span class="n">pnode</span><span class="o">-&gt;</span><span class="n">lat_data</span> <span class="o">||</span>
		<span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">bucket_type</span> <span class="o">==</span> <span class="n">LPFC_NO_BUCKET</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">bucket_type</span> <span class="o">==</span> <span class="n">LPFC_LINEAR_BUCKET</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">i</span> <span class="o">=</span> <span class="p">(</span><span class="n">latency</span> <span class="o">+</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">bucket_step</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">bucket_base</span><span class="p">)</span><span class="o">/</span>
			<span class="n">phba</span><span class="o">-&gt;</span><span class="n">bucket_step</span><span class="p">;</span>
		<span class="cm">/* check array subscript bounds */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&gt;=</span> <span class="n">LPFC_MAX_BUCKET_COUNT</span><span class="p">)</span>
			<span class="n">i</span> <span class="o">=</span> <span class="n">LPFC_MAX_BUCKET_COUNT</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">LPFC_MAX_BUCKET_COUNT</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">latency</span> <span class="o">&lt;=</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">bucket_base</span> <span class="o">+</span>
				<span class="p">((</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="n">i</span><span class="p">)</span><span class="o">*</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">bucket_step</span><span class="p">)))</span>
				<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">pnode</span><span class="o">-&gt;</span><span class="n">lat_data</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">cmd_count</span><span class="o">++</span><span class="p">;</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_send_sdev_queuedepth_change_event - Posts a queuedepth change event</span>
<span class="cm"> * @phba: Pointer to HBA context object.</span>
<span class="cm"> * @vport: Pointer to vport object.</span>
<span class="cm"> * @ndlp: Pointer to FC node associated with the target.</span>
<span class="cm"> * @lun: Lun number of the scsi device.</span>
<span class="cm"> * @old_val: Old value of the queue depth.</span>
<span class="cm"> * @new_val: New value of the queue depth.</span>
<span class="cm"> *</span>
<span class="cm"> * This function sends an event to the mgmt application indicating</span>
<span class="cm"> * there is a change in the scsi device queue depth.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">lpfc_send_sdev_queuedepth_change_event</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">lpfc_vport</span>  <span class="o">*</span><span class="n">vport</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">lpfc_nodelist</span> <span class="o">*</span><span class="n">ndlp</span><span class="p">,</span>
		<span class="kt">uint32_t</span> <span class="n">lun</span><span class="p">,</span>
		<span class="kt">uint32_t</span> <span class="n">old_val</span><span class="p">,</span>
		<span class="kt">uint32_t</span> <span class="n">new_val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpfc_fast_path_event</span> <span class="o">*</span><span class="n">fast_path_evt</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">fast_path_evt</span> <span class="o">=</span> <span class="n">lpfc_alloc_fast_evt</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">fast_path_evt</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">fast_path_evt</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">queue_depth_evt</span><span class="p">.</span><span class="n">scsi_event</span><span class="p">.</span><span class="n">event_type</span> <span class="o">=</span>
		<span class="n">FC_REG_SCSI_EVENT</span><span class="p">;</span>
	<span class="n">fast_path_evt</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">queue_depth_evt</span><span class="p">.</span><span class="n">scsi_event</span><span class="p">.</span><span class="n">subcategory</span> <span class="o">=</span>
		<span class="n">LPFC_EVENT_VARQUEDEPTH</span><span class="p">;</span>

	<span class="cm">/* Report all luns with change in queue depth */</span>
	<span class="n">fast_path_evt</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">queue_depth_evt</span><span class="p">.</span><span class="n">scsi_event</span><span class="p">.</span><span class="n">lun</span> <span class="o">=</span> <span class="n">lun</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ndlp</span> <span class="o">&amp;&amp;</span> <span class="n">NLP_CHK_NODE_ACT</span><span class="p">(</span><span class="n">ndlp</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fast_path_evt</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">queue_depth_evt</span><span class="p">.</span><span class="n">scsi_event</span><span class="p">.</span><span class="n">wwpn</span><span class="p">,</span>
			<span class="o">&amp;</span><span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_portname</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_name</span><span class="p">));</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fast_path_evt</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">queue_depth_evt</span><span class="p">.</span><span class="n">scsi_event</span><span class="p">.</span><span class="n">wwnn</span><span class="p">,</span>
			<span class="o">&amp;</span><span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_nodename</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_name</span><span class="p">));</span>
	<span class="p">}</span>

	<span class="n">fast_path_evt</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">queue_depth_evt</span><span class="p">.</span><span class="n">oldval</span> <span class="o">=</span> <span class="n">old_val</span><span class="p">;</span>
	<span class="n">fast_path_evt</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">queue_depth_evt</span><span class="p">.</span><span class="n">newval</span> <span class="o">=</span> <span class="n">new_val</span><span class="p">;</span>
	<span class="n">fast_path_evt</span><span class="o">-&gt;</span><span class="n">vport</span> <span class="o">=</span> <span class="n">vport</span><span class="p">;</span>

	<span class="n">fast_path_evt</span><span class="o">-&gt;</span><span class="n">work_evt</span><span class="p">.</span><span class="n">evt</span> <span class="o">=</span> <span class="n">LPFC_EVT_FASTPATH_MGMT_EVT</span><span class="p">;</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fast_path_evt</span><span class="o">-&gt;</span><span class="n">work_evt</span><span class="p">.</span><span class="n">evt_listp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">work_list</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">lpfc_worker_wake_up</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>

	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_change_queue_depth - Alter scsi device queue depth</span>
<span class="cm"> * @sdev: Pointer the scsi device on which to change the queue depth.</span>
<span class="cm"> * @qdepth: New queue depth to set the sdev to.</span>
<span class="cm"> * @reason: The reason for the queue depth change.</span>
<span class="cm"> *</span>
<span class="cm"> * This function is called by the midlayer and the LLD to alter the queue</span>
<span class="cm"> * depth for a scsi device. This function sets the queue depth to the new</span>
<span class="cm"> * value and sends an event out to log the queue depth change.</span>
<span class="cm"> **/</span>
<span class="kt">int</span>
<span class="nf">lpfc_change_queue_depth</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="n">sdev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">qdepth</span><span class="p">,</span> <span class="kt">int</span> <span class="n">reason</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="n">vport</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="p">)</span> <span class="n">sdev</span><span class="o">-&gt;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">hostdata</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_hba</span>   <span class="o">*</span><span class="n">phba</span> <span class="o">=</span> <span class="n">vport</span><span class="o">-&gt;</span><span class="n">phba</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_rport_data</span> <span class="o">*</span><span class="n">rdata</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">new_queue_depth</span><span class="p">,</span> <span class="n">old_queue_depth</span><span class="p">;</span>

	<span class="n">old_queue_depth</span> <span class="o">=</span> <span class="n">sdev</span><span class="o">-&gt;</span><span class="n">queue_depth</span><span class="p">;</span>
	<span class="n">scsi_adjust_queue_depth</span><span class="p">(</span><span class="n">sdev</span><span class="p">,</span> <span class="n">scsi_get_tag_type</span><span class="p">(</span><span class="n">sdev</span><span class="p">),</span> <span class="n">qdepth</span><span class="p">);</span>
	<span class="n">new_queue_depth</span> <span class="o">=</span> <span class="n">sdev</span><span class="o">-&gt;</span><span class="n">queue_depth</span><span class="p">;</span>
	<span class="n">rdata</span> <span class="o">=</span> <span class="n">sdev</span><span class="o">-&gt;</span><span class="n">hostdata</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rdata</span><span class="p">)</span>
		<span class="n">lpfc_send_sdev_queuedepth_change_event</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">vport</span><span class="p">,</span>
						       <span class="n">rdata</span><span class="o">-&gt;</span><span class="n">pnode</span><span class="p">,</span> <span class="n">sdev</span><span class="o">-&gt;</span><span class="n">lun</span><span class="p">,</span>
						       <span class="n">old_queue_depth</span><span class="p">,</span>
						       <span class="n">new_queue_depth</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">sdev</span><span class="o">-&gt;</span><span class="n">queue_depth</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_rampdown_queue_depth - Post RAMP_DOWN_QUEUE event to worker thread</span>
<span class="cm"> * @phba: The Hba for which this call is being executed.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine is called when there is resource error in driver or firmware.</span>
<span class="cm"> * This routine posts WORKER_RAMP_DOWN_QUEUE event for @phba. This routine</span>
<span class="cm"> * posts at most 1 event each second. This routine wakes up worker thread of</span>
<span class="cm"> * @phba to process WORKER_RAM_DOWN_EVENT event.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine should be called with no lock held.</span>
<span class="cm"> **/</span>
<span class="kt">void</span>
<span class="nf">lpfc_rampdown_queue_depth</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">evt_posted</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">num_rsrc_err</span><span class="p">);</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">last_rsrc_error_time</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">last_ramp_down_time</span> <span class="o">+</span> <span class="n">QUEUE_RAMP_DOWN_INTERVAL</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">jiffies</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">last_ramp_down_time</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span>

	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">pport</span><span class="o">-&gt;</span><span class="n">work_port_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">evt_posted</span> <span class="o">=</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">pport</span><span class="o">-&gt;</span><span class="n">work_port_events</span> <span class="o">&amp;</span> <span class="n">WORKER_RAMP_DOWN_QUEUE</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">evt_posted</span><span class="p">)</span>
		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">pport</span><span class="o">-&gt;</span><span class="n">work_port_events</span> <span class="o">|=</span> <span class="n">WORKER_RAMP_DOWN_QUEUE</span><span class="p">;</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">pport</span><span class="o">-&gt;</span><span class="n">work_port_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">evt_posted</span><span class="p">)</span>
		<span class="n">lpfc_worker_wake_up</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_rampup_queue_depth - Post RAMP_UP_QUEUE event for worker thread</span>
<span class="cm"> * @phba: The Hba for which this call is being executed.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine post WORKER_RAMP_UP_QUEUE event for @phba vport. This routine</span>
<span class="cm"> * post at most 1 event every 5 minute after last_ramp_up_time or</span>
<span class="cm"> * last_rsrc_error_time.  This routine wakes up worker thread of @phba</span>
<span class="cm"> * to process WORKER_RAM_DOWN_EVENT event.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine should be called with no lock held.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">lpfc_rampup_queue_depth</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_vport</span>  <span class="o">*</span><span class="n">vport</span><span class="p">,</span>
			<span class="kt">uint32_t</span> <span class="n">queue_depth</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span> <span class="o">=</span> <span class="n">vport</span><span class="o">-&gt;</span><span class="n">phba</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">evt_posted</span><span class="p">;</span>
	<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">num_cmd_success</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">cfg_lun_queue_depth</span> <span class="o">&lt;=</span> <span class="n">queue_depth</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">time_before</span><span class="p">(</span><span class="n">jiffies</span><span class="p">,</span>
			<span class="n">phba</span><span class="o">-&gt;</span><span class="n">last_ramp_up_time</span> <span class="o">+</span> <span class="n">QUEUE_RAMP_UP_INTERVAL</span><span class="p">)</span> <span class="o">||</span>
	    <span class="n">time_before</span><span class="p">(</span><span class="n">jiffies</span><span class="p">,</span>
			<span class="n">phba</span><span class="o">-&gt;</span><span class="n">last_rsrc_error_time</span> <span class="o">+</span> <span class="n">QUEUE_RAMP_UP_INTERVAL</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">last_ramp_up_time</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">pport</span><span class="o">-&gt;</span><span class="n">work_port_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">evt_posted</span> <span class="o">=</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">pport</span><span class="o">-&gt;</span><span class="n">work_port_events</span> <span class="o">&amp;</span> <span class="n">WORKER_RAMP_UP_QUEUE</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">evt_posted</span><span class="p">)</span>
		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">pport</span><span class="o">-&gt;</span><span class="n">work_port_events</span> <span class="o">|=</span> <span class="n">WORKER_RAMP_UP_QUEUE</span><span class="p">;</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">pport</span><span class="o">-&gt;</span><span class="n">work_port_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">evt_posted</span><span class="p">)</span>
		<span class="n">lpfc_worker_wake_up</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_ramp_down_queue_handler - WORKER_RAMP_DOWN_QUEUE event handler</span>
<span class="cm"> * @phba: The Hba for which this call is being executed.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine is called to  process WORKER_RAMP_DOWN_QUEUE event for worker</span>
<span class="cm"> * thread.This routine reduces queue depth for all scsi device on each vport</span>
<span class="cm"> * associated with @phba.</span>
<span class="cm"> **/</span>
<span class="kt">void</span>
<span class="nf">lpfc_ramp_down_queue_handler</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">**</span><span class="n">vports</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span>  <span class="o">*</span><span class="n">shost</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="n">sdev</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">new_queue_depth</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">num_rsrc_err</span><span class="p">,</span> <span class="n">num_cmd_success</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">num_rsrc_err</span> <span class="o">=</span> <span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">num_rsrc_err</span><span class="p">);</span>
	<span class="n">num_cmd_success</span> <span class="o">=</span> <span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">num_cmd_success</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * The error and success command counters are global per</span>
<span class="cm">	 * driver instance.  If another handler has already</span>
<span class="cm">	 * operated on this error event, just exit.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">num_rsrc_err</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">vports</span> <span class="o">=</span> <span class="n">lpfc_create_vport_work_array</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vports</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">max_vports</span> <span class="o">&amp;&amp;</span> <span class="n">vports</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">shost</span> <span class="o">=</span> <span class="n">lpfc_shost_from_vport</span><span class="p">(</span><span class="n">vports</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
			<span class="n">shost_for_each_device</span><span class="p">(</span><span class="n">sdev</span><span class="p">,</span> <span class="n">shost</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">new_queue_depth</span> <span class="o">=</span>
					<span class="n">sdev</span><span class="o">-&gt;</span><span class="n">queue_depth</span> <span class="o">*</span> <span class="n">num_rsrc_err</span> <span class="o">/</span>
					<span class="p">(</span><span class="n">num_rsrc_err</span> <span class="o">+</span> <span class="n">num_cmd_success</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">new_queue_depth</span><span class="p">)</span>
					<span class="n">new_queue_depth</span> <span class="o">=</span> <span class="n">sdev</span><span class="o">-&gt;</span><span class="n">queue_depth</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
				<span class="k">else</span>
					<span class="n">new_queue_depth</span> <span class="o">=</span> <span class="n">sdev</span><span class="o">-&gt;</span><span class="n">queue_depth</span> <span class="o">-</span>
								<span class="n">new_queue_depth</span><span class="p">;</span>
				<span class="n">lpfc_change_queue_depth</span><span class="p">(</span><span class="n">sdev</span><span class="p">,</span> <span class="n">new_queue_depth</span><span class="p">,</span>
							<span class="n">SCSI_QDEPTH_DEFAULT</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="n">lpfc_destroy_vport_work_array</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">vports</span><span class="p">);</span>
	<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">num_rsrc_err</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">num_cmd_success</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_ramp_up_queue_handler - WORKER_RAMP_UP_QUEUE event handler</span>
<span class="cm"> * @phba: The Hba for which this call is being executed.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine is called to  process WORKER_RAMP_UP_QUEUE event for worker</span>
<span class="cm"> * thread.This routine increases queue depth for all scsi device on each vport</span>
<span class="cm"> * associated with @phba by 1. This routine also sets @phba num_rsrc_err and</span>
<span class="cm"> * num_cmd_success to zero.</span>
<span class="cm"> **/</span>
<span class="kt">void</span>
<span class="nf">lpfc_ramp_up_queue_handler</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">**</span><span class="n">vports</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span>  <span class="o">*</span><span class="n">shost</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="n">sdev</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">vports</span> <span class="o">=</span> <span class="n">lpfc_create_vport_work_array</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vports</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">max_vports</span> <span class="o">&amp;&amp;</span> <span class="n">vports</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">shost</span> <span class="o">=</span> <span class="n">lpfc_shost_from_vport</span><span class="p">(</span><span class="n">vports</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
			<span class="n">shost_for_each_device</span><span class="p">(</span><span class="n">sdev</span><span class="p">,</span> <span class="n">shost</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">vports</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">cfg_lun_queue_depth</span> <span class="o">&lt;=</span>
				    <span class="n">sdev</span><span class="o">-&gt;</span><span class="n">queue_depth</span><span class="p">)</span>
					<span class="k">continue</span><span class="p">;</span>
				<span class="n">lpfc_change_queue_depth</span><span class="p">(</span><span class="n">sdev</span><span class="p">,</span>
							<span class="n">sdev</span><span class="o">-&gt;</span><span class="n">queue_depth</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span>
							<span class="n">SCSI_QDEPTH_RAMP_UP</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="n">lpfc_destroy_vport_work_array</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">vports</span><span class="p">);</span>
	<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">num_rsrc_err</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">num_cmd_success</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_scsi_dev_block - set all scsi hosts to block state</span>
<span class="cm"> * @phba: Pointer to HBA context object.</span>
<span class="cm"> *</span>
<span class="cm"> * This function walks vport list and set each SCSI host to block state</span>
<span class="cm"> * by invoking fc_remote_port_delete() routine. This function is invoked</span>
<span class="cm"> * with EEH when device&#39;s PCI slot has been permanently disabled.</span>
<span class="cm"> **/</span>
<span class="kt">void</span>
<span class="nf">lpfc_scsi_dev_block</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">**</span><span class="n">vports</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span>  <span class="o">*</span><span class="n">shost</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="n">sdev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fc_rport</span> <span class="o">*</span><span class="n">rport</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">vports</span> <span class="o">=</span> <span class="n">lpfc_create_vport_work_array</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vports</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">max_vports</span> <span class="o">&amp;&amp;</span> <span class="n">vports</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">shost</span> <span class="o">=</span> <span class="n">lpfc_shost_from_vport</span><span class="p">(</span><span class="n">vports</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
			<span class="n">shost_for_each_device</span><span class="p">(</span><span class="n">sdev</span><span class="p">,</span> <span class="n">shost</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">rport</span> <span class="o">=</span> <span class="n">starget_to_rport</span><span class="p">(</span><span class="n">scsi_target</span><span class="p">(</span><span class="n">sdev</span><span class="p">));</span>
				<span class="n">fc_remote_port_delete</span><span class="p">(</span><span class="n">rport</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="n">lpfc_destroy_vport_work_array</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">vports</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_new_scsi_buf_s3 - Scsi buffer allocator for HBA with SLI3 IF spec</span>
<span class="cm"> * @vport: The virtual port for which this call being executed.</span>
<span class="cm"> * @num_to_allocate: The requested number of buffers to allocate.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine allocates a scsi buffer for device with SLI-3 interface spec,</span>
<span class="cm"> * the scsi buffer contains all the necessary information needed to initiate</span>
<span class="cm"> * a SCSI I/O. The non-DMAable buffer region contains information to build</span>
<span class="cm"> * the IOCB. The DMAable region contains memory for the FCP CMND, FCP RSP,</span>
<span class="cm"> * and the initial BPL. In addition to allocating memory, the FCP CMND and</span>
<span class="cm"> * FCP RSP BDEs are setup in the BPL and the BPL BDE is setup in the IOCB.</span>
<span class="cm"> *</span>
<span class="cm"> * Return codes:</span>
<span class="cm"> *   int - number of scsi buffers that were allocated.</span>
<span class="cm"> *   0 = failure, less than num_to_alloc is a partial failure.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">lpfc_new_scsi_buf_s3</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="n">vport</span><span class="p">,</span> <span class="kt">int</span> <span class="n">num_to_alloc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span> <span class="o">=</span> <span class="n">vport</span><span class="o">-&gt;</span><span class="n">phba</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_scsi_buf</span> <span class="o">*</span><span class="n">psb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ulp_bde64</span> <span class="o">*</span><span class="n">bpl</span><span class="p">;</span>
	<span class="n">IOCB_t</span> <span class="o">*</span><span class="n">iocb</span><span class="p">;</span>
	<span class="n">dma_addr_t</span> <span class="n">pdma_phys_fcp_cmd</span><span class="p">;</span>
	<span class="n">dma_addr_t</span> <span class="n">pdma_phys_fcp_rsp</span><span class="p">;</span>
	<span class="n">dma_addr_t</span> <span class="n">pdma_phys_bpl</span><span class="p">;</span>
	<span class="kt">uint16_t</span> <span class="n">iotag</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">bcnt</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">bcnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">bcnt</span> <span class="o">&lt;</span> <span class="n">num_to_alloc</span><span class="p">;</span> <span class="n">bcnt</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">psb</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_scsi_buf</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">psb</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * Get memory from the pci pool to map the virt space to pci</span>
<span class="cm">		 * bus space for an I/O.  The DMA buffer includes space for the</span>
<span class="cm">		 * struct fcp_cmnd, struct fcp_rsp and the number of bde&#39;s</span>
<span class="cm">		 * necessary to support the sg_tablesize.</span>
<span class="cm">		 */</span>
		<span class="n">psb</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">=</span> <span class="n">pci_pool_alloc</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">lpfc_scsi_dma_buf_pool</span><span class="p">,</span>
					<span class="n">GFP_KERNEL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">psb</span><span class="o">-&gt;</span><span class="n">dma_handle</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">psb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">kfree</span><span class="p">(</span><span class="n">psb</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* Initialize virtual ptrs to dma_buf region. */</span>
		<span class="n">memset</span><span class="p">(</span><span class="n">psb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">cfg_sg_dma_buf_size</span><span class="p">);</span>

		<span class="cm">/* Allocate iotag for psb-&gt;cur_iocbq. */</span>
		<span class="n">iotag</span> <span class="o">=</span> <span class="n">lpfc_sli_next_iotag</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">psb</span><span class="o">-&gt;</span><span class="n">cur_iocbq</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">iotag</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pci_pool_free</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">lpfc_scsi_dma_buf_pool</span><span class="p">,</span>
					<span class="n">psb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span> <span class="n">psb</span><span class="o">-&gt;</span><span class="n">dma_handle</span><span class="p">);</span>
			<span class="n">kfree</span><span class="p">(</span><span class="n">psb</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">psb</span><span class="o">-&gt;</span><span class="n">cur_iocbq</span><span class="p">.</span><span class="n">iocb_flag</span> <span class="o">|=</span> <span class="n">LPFC_IO_FCP</span><span class="p">;</span>

		<span class="n">psb</span><span class="o">-&gt;</span><span class="n">fcp_cmnd</span> <span class="o">=</span> <span class="n">psb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
		<span class="n">psb</span><span class="o">-&gt;</span><span class="n">fcp_rsp</span> <span class="o">=</span> <span class="n">psb</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">fcp_cmnd</span><span class="p">);</span>
		<span class="n">psb</span><span class="o">-&gt;</span><span class="n">fcp_bpl</span> <span class="o">=</span> <span class="n">psb</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">fcp_cmnd</span><span class="p">)</span> <span class="o">+</span>
			<span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">fcp_rsp</span><span class="p">);</span>

		<span class="cm">/* Initialize local short-hand pointers. */</span>
		<span class="n">bpl</span> <span class="o">=</span> <span class="n">psb</span><span class="o">-&gt;</span><span class="n">fcp_bpl</span><span class="p">;</span>
		<span class="n">pdma_phys_fcp_cmd</span> <span class="o">=</span> <span class="n">psb</span><span class="o">-&gt;</span><span class="n">dma_handle</span><span class="p">;</span>
		<span class="n">pdma_phys_fcp_rsp</span> <span class="o">=</span> <span class="n">psb</span><span class="o">-&gt;</span><span class="n">dma_handle</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">fcp_cmnd</span><span class="p">);</span>
		<span class="n">pdma_phys_bpl</span> <span class="o">=</span> <span class="n">psb</span><span class="o">-&gt;</span><span class="n">dma_handle</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">fcp_cmnd</span><span class="p">)</span> <span class="o">+</span>
			<span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">fcp_rsp</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * The first two bdes are the FCP_CMD and FCP_RSP. The balance</span>
<span class="cm">		 * are sg list bdes.  Initialize the first two and leave the</span>
<span class="cm">		 * rest for queuecommand.</span>
<span class="cm">		 */</span>
		<span class="n">bpl</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">addrHigh</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">putPaddrHigh</span><span class="p">(</span><span class="n">pdma_phys_fcp_cmd</span><span class="p">));</span>
		<span class="n">bpl</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">addrLow</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">putPaddrLow</span><span class="p">(</span><span class="n">pdma_phys_fcp_cmd</span><span class="p">));</span>
		<span class="n">bpl</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">tus</span><span class="p">.</span><span class="n">f</span><span class="p">.</span><span class="n">bdeSize</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">fcp_cmnd</span><span class="p">);</span>
		<span class="n">bpl</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">tus</span><span class="p">.</span><span class="n">f</span><span class="p">.</span><span class="n">bdeFlags</span> <span class="o">=</span> <span class="n">BUFF_TYPE_BDE_64</span><span class="p">;</span>
		<span class="n">bpl</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">tus</span><span class="p">.</span><span class="n">w</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">bpl</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">tus</span><span class="p">.</span><span class="n">w</span><span class="p">);</span>

		<span class="cm">/* Setup the physical region for the FCP RSP */</span>
		<span class="n">bpl</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">addrHigh</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">putPaddrHigh</span><span class="p">(</span><span class="n">pdma_phys_fcp_rsp</span><span class="p">));</span>
		<span class="n">bpl</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">addrLow</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">putPaddrLow</span><span class="p">(</span><span class="n">pdma_phys_fcp_rsp</span><span class="p">));</span>
		<span class="n">bpl</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">tus</span><span class="p">.</span><span class="n">f</span><span class="p">.</span><span class="n">bdeSize</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">fcp_rsp</span><span class="p">);</span>
		<span class="n">bpl</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">tus</span><span class="p">.</span><span class="n">f</span><span class="p">.</span><span class="n">bdeFlags</span> <span class="o">=</span> <span class="n">BUFF_TYPE_BDE_64</span><span class="p">;</span>
		<span class="n">bpl</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">tus</span><span class="p">.</span><span class="n">w</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">bpl</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">tus</span><span class="p">.</span><span class="n">w</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * Since the IOCB for the FCP I/O is built into this</span>
<span class="cm">		 * lpfc_scsi_buf, initialize it with all known data now.</span>
<span class="cm">		 */</span>
		<span class="n">iocb</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">psb</span><span class="o">-&gt;</span><span class="n">cur_iocbq</span><span class="p">.</span><span class="n">iocb</span><span class="p">;</span>
		<span class="n">iocb</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">fcpi64</span><span class="p">.</span><span class="n">bdl</span><span class="p">.</span><span class="n">ulpIoTag32</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli_rev</span> <span class="o">==</span> <span class="mi">3</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
				<span class="o">!</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli3_options</span> <span class="o">&amp;</span> <span class="n">LPFC_SLI3_BG_ENABLED</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/* fill in immediate fcp command BDE */</span>
			<span class="n">iocb</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">fcpi64</span><span class="p">.</span><span class="n">bdl</span><span class="p">.</span><span class="n">bdeFlags</span> <span class="o">=</span> <span class="n">BUFF_TYPE_BDE_IMMED</span><span class="p">;</span>
			<span class="n">iocb</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">fcpi64</span><span class="p">.</span><span class="n">bdl</span><span class="p">.</span><span class="n">bdeSize</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">fcp_cmnd</span><span class="p">);</span>
			<span class="n">iocb</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">fcpi64</span><span class="p">.</span><span class="n">bdl</span><span class="p">.</span><span class="n">addrLow</span> <span class="o">=</span> <span class="n">offsetof</span><span class="p">(</span><span class="n">IOCB_t</span><span class="p">,</span>
					<span class="n">unsli3</span><span class="p">.</span><span class="n">fcp_ext</span><span class="p">.</span><span class="n">icd</span><span class="p">);</span>
			<span class="n">iocb</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">fcpi64</span><span class="p">.</span><span class="n">bdl</span><span class="p">.</span><span class="n">addrHigh</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">iocb</span><span class="o">-&gt;</span><span class="n">ulpBdeCount</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">iocb</span><span class="o">-&gt;</span><span class="n">ulpLe</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="cm">/* fill in response BDE */</span>
			<span class="n">iocb</span><span class="o">-&gt;</span><span class="n">unsli3</span><span class="p">.</span><span class="n">fcp_ext</span><span class="p">.</span><span class="n">rbde</span><span class="p">.</span><span class="n">tus</span><span class="p">.</span><span class="n">f</span><span class="p">.</span><span class="n">bdeFlags</span> <span class="o">=</span>
							<span class="n">BUFF_TYPE_BDE_64</span><span class="p">;</span>
			<span class="n">iocb</span><span class="o">-&gt;</span><span class="n">unsli3</span><span class="p">.</span><span class="n">fcp_ext</span><span class="p">.</span><span class="n">rbde</span><span class="p">.</span><span class="n">tus</span><span class="p">.</span><span class="n">f</span><span class="p">.</span><span class="n">bdeSize</span> <span class="o">=</span>
				<span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">fcp_rsp</span><span class="p">);</span>
			<span class="n">iocb</span><span class="o">-&gt;</span><span class="n">unsli3</span><span class="p">.</span><span class="n">fcp_ext</span><span class="p">.</span><span class="n">rbde</span><span class="p">.</span><span class="n">addrLow</span> <span class="o">=</span>
				<span class="n">putPaddrLow</span><span class="p">(</span><span class="n">pdma_phys_fcp_rsp</span><span class="p">);</span>
			<span class="n">iocb</span><span class="o">-&gt;</span><span class="n">unsli3</span><span class="p">.</span><span class="n">fcp_ext</span><span class="p">.</span><span class="n">rbde</span><span class="p">.</span><span class="n">addrHigh</span> <span class="o">=</span>
				<span class="n">putPaddrHigh</span><span class="p">(</span><span class="n">pdma_phys_fcp_rsp</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">iocb</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">fcpi64</span><span class="p">.</span><span class="n">bdl</span><span class="p">.</span><span class="n">bdeFlags</span> <span class="o">=</span> <span class="n">BUFF_TYPE_BLP_64</span><span class="p">;</span>
			<span class="n">iocb</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">fcpi64</span><span class="p">.</span><span class="n">bdl</span><span class="p">.</span><span class="n">bdeSize</span> <span class="o">=</span>
					<span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ulp_bde64</span><span class="p">));</span>
			<span class="n">iocb</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">fcpi64</span><span class="p">.</span><span class="n">bdl</span><span class="p">.</span><span class="n">addrLow</span> <span class="o">=</span>
					<span class="n">putPaddrLow</span><span class="p">(</span><span class="n">pdma_phys_bpl</span><span class="p">);</span>
			<span class="n">iocb</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">fcpi64</span><span class="p">.</span><span class="n">bdl</span><span class="p">.</span><span class="n">addrHigh</span> <span class="o">=</span>
					<span class="n">putPaddrHigh</span><span class="p">(</span><span class="n">pdma_phys_bpl</span><span class="p">);</span>
			<span class="n">iocb</span><span class="o">-&gt;</span><span class="n">ulpBdeCount</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">iocb</span><span class="o">-&gt;</span><span class="n">ulpLe</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">iocb</span><span class="o">-&gt;</span><span class="n">ulpClass</span> <span class="o">=</span> <span class="n">CLASS3</span><span class="p">;</span>
		<span class="n">psb</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">=</span> <span class="n">IOSTAT_SUCCESS</span><span class="p">;</span>
		<span class="cm">/* Put it back into the SCSI buffer list */</span>
		<span class="n">psb</span><span class="o">-&gt;</span><span class="n">cur_iocbq</span><span class="p">.</span><span class="n">context1</span>  <span class="o">=</span> <span class="n">psb</span><span class="p">;</span>
		<span class="n">lpfc_release_scsi_buf_s3</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">psb</span><span class="p">);</span>

	<span class="p">}</span>

	<span class="k">return</span> <span class="n">bcnt</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_sli4_vport_delete_fcp_xri_aborted -Remove all ndlp references for vport</span>
<span class="cm"> * @vport: pointer to lpfc vport data structure.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine is invoked by the vport cleanup for deletions and the cleanup</span>
<span class="cm"> * for an ndlp on removal.</span>
<span class="cm"> **/</span>
<span class="kt">void</span>
<span class="nf">lpfc_sli4_vport_delete_fcp_xri_aborted</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="n">vport</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span> <span class="o">=</span> <span class="n">vport</span><span class="o">-&gt;</span><span class="n">phba</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_scsi_buf</span> <span class="o">*</span><span class="n">psb</span><span class="p">,</span> <span class="o">*</span><span class="n">next_psb</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">iflag</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">,</span> <span class="n">iflag</span><span class="p">);</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">abts_scsi_buf_list_lock</span><span class="p">);</span>
	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">psb</span><span class="p">,</span> <span class="n">next_psb</span><span class="p">,</span>
				<span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">lpfc_abts_scsi_buf_list</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">psb</span><span class="o">-&gt;</span><span class="n">rdata</span> <span class="o">&amp;&amp;</span> <span class="n">psb</span><span class="o">-&gt;</span><span class="n">rdata</span><span class="o">-&gt;</span><span class="n">pnode</span>
			<span class="o">&amp;&amp;</span> <span class="n">psb</span><span class="o">-&gt;</span><span class="n">rdata</span><span class="o">-&gt;</span><span class="n">pnode</span><span class="o">-&gt;</span><span class="n">vport</span> <span class="o">==</span> <span class="n">vport</span><span class="p">)</span>
			<span class="n">psb</span><span class="o">-&gt;</span><span class="n">rdata</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">abts_scsi_buf_list_lock</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">,</span> <span class="n">iflag</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_sli4_fcp_xri_aborted - Fast-path process of fcp xri abort</span>
<span class="cm"> * @phba: pointer to lpfc hba data structure.</span>
<span class="cm"> * @axri: pointer to the fcp xri abort wcqe structure.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine is invoked by the worker thread to process a SLI4 fast-path</span>
<span class="cm"> * FCP aborted xri.</span>
<span class="cm"> **/</span>
<span class="kt">void</span>
<span class="nf">lpfc_sli4_fcp_xri_aborted</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">,</span>
			  <span class="k">struct</span> <span class="n">sli4_wcqe_xri_aborted</span> <span class="o">*</span><span class="n">axri</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">uint16_t</span> <span class="n">xri</span> <span class="o">=</span> <span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_wcqe_xa_xri</span><span class="p">,</span> <span class="n">axri</span><span class="p">);</span>
	<span class="kt">uint16_t</span> <span class="n">rxid</span> <span class="o">=</span> <span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_wcqe_xa_remote_xid</span><span class="p">,</span> <span class="n">axri</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">lpfc_scsi_buf</span> <span class="o">*</span><span class="n">psb</span><span class="p">,</span> <span class="o">*</span><span class="n">next_psb</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">iflag</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_iocbq</span> <span class="o">*</span><span class="n">iocbq</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_nodelist</span> <span class="o">*</span><span class="n">ndlp</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rrq_empty</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_sli_ring</span> <span class="o">*</span><span class="n">pring</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli</span><span class="p">.</span><span class="n">ring</span><span class="p">[</span><span class="n">LPFC_ELS_RING</span><span class="p">];</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">,</span> <span class="n">iflag</span><span class="p">);</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">abts_scsi_buf_list_lock</span><span class="p">);</span>
	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">psb</span><span class="p">,</span> <span class="n">next_psb</span><span class="p">,</span>
		<span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">lpfc_abts_scsi_buf_list</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">psb</span><span class="o">-&gt;</span><span class="n">cur_iocbq</span><span class="p">.</span><span class="n">sli4_xritag</span> <span class="o">==</span> <span class="n">xri</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">psb</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
			<span class="n">psb</span><span class="o">-&gt;</span><span class="n">exch_busy</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">psb</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">=</span> <span class="n">IOSTAT_SUCCESS</span><span class="p">;</span>
			<span class="n">spin_unlock</span><span class="p">(</span>
				<span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">abts_scsi_buf_list_lock</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">psb</span><span class="o">-&gt;</span><span class="n">rdata</span> <span class="o">&amp;&amp;</span> <span class="n">psb</span><span class="o">-&gt;</span><span class="n">rdata</span><span class="o">-&gt;</span><span class="n">pnode</span><span class="p">)</span>
				<span class="n">ndlp</span> <span class="o">=</span> <span class="n">psb</span><span class="o">-&gt;</span><span class="n">rdata</span><span class="o">-&gt;</span><span class="n">pnode</span><span class="p">;</span>
			<span class="k">else</span>
				<span class="n">ndlp</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

			<span class="n">rrq_empty</span> <span class="o">=</span> <span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">active_rrq_list</span><span class="p">);</span>
			<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">,</span> <span class="n">iflag</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ndlp</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">lpfc_set_rrq_active</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">ndlp</span><span class="p">,</span>
					<span class="n">psb</span><span class="o">-&gt;</span><span class="n">cur_iocbq</span><span class="p">.</span><span class="n">sli4_lxritag</span><span class="p">,</span> <span class="n">rxid</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
				<span class="n">lpfc_sli4_abts_err_handler</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">ndlp</span><span class="p">,</span> <span class="n">axri</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="n">lpfc_release_scsi_buf_s4</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">psb</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">rrq_empty</span><span class="p">)</span>
				<span class="n">lpfc_worker_wake_up</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">abts_scsi_buf_list_lock</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli</span><span class="p">.</span><span class="n">last_iotag</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">iocbq</span> <span class="o">=</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli</span><span class="p">.</span><span class="n">iocbq_lookup</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">iocbq</span><span class="o">-&gt;</span><span class="n">iocb_flag</span> <span class="o">&amp;</span>  <span class="n">LPFC_IO_FCP</span><span class="p">)</span> <span class="o">||</span>
			<span class="p">(</span><span class="n">iocbq</span><span class="o">-&gt;</span><span class="n">iocb_flag</span> <span class="o">&amp;</span> <span class="n">LPFC_IO_LIBDFC</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">iocbq</span><span class="o">-&gt;</span><span class="n">sli4_xritag</span> <span class="o">!=</span> <span class="n">xri</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="n">psb</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">iocbq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">lpfc_scsi_buf</span><span class="p">,</span> <span class="n">cur_iocbq</span><span class="p">);</span>
		<span class="n">psb</span><span class="o">-&gt;</span><span class="n">exch_busy</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">,</span> <span class="n">iflag</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pring</span><span class="o">-&gt;</span><span class="n">txq_cnt</span><span class="p">)</span>
			<span class="n">lpfc_worker_wake_up</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="p">}</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">,</span> <span class="n">iflag</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_sli4_post_scsi_sgl_list - Psot blocks of scsi buffer sgls from a list</span>
<span class="cm"> * @phba: pointer to lpfc hba data structure.</span>
<span class="cm"> * @post_sblist: pointer to the scsi buffer list.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine walks a list of scsi buffers that was passed in. It attempts</span>
<span class="cm"> * to construct blocks of scsi buffer sgls which contains contiguous xris and</span>
<span class="cm"> * uses the non-embedded SGL block post mailbox commands to post to the port.</span>
<span class="cm"> * For single SCSI buffer sgl with non-contiguous xri, if any, it shall use</span>
<span class="cm"> * embedded SGL post mailbox command for posting. The @post_sblist passed in</span>
<span class="cm"> * must be local list, thus no lock is needed when manipulate the list.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns: 0 = failure, non-zero number of successfully posted buffers.</span>
<span class="cm"> **/</span>
<span class="kt">int</span>
<span class="nf">lpfc_sli4_post_scsi_sgl_list</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">post_sblist</span><span class="p">,</span> <span class="kt">int</span> <span class="n">sb_count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpfc_scsi_buf</span> <span class="o">*</span><span class="n">psb</span><span class="p">,</span> <span class="o">*</span><span class="n">psb_next</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">status</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">post_cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">block_cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">num_posting</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">num_posted</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">dma_addr_t</span> <span class="n">pdma_phys_bpl1</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">last_xritag</span> <span class="o">=</span> <span class="n">NO_XRI</span><span class="p">;</span>
	<span class="n">LIST_HEAD</span><span class="p">(</span><span class="n">prep_sblist</span><span class="p">);</span>
	<span class="n">LIST_HEAD</span><span class="p">(</span><span class="n">blck_sblist</span><span class="p">);</span>
	<span class="n">LIST_HEAD</span><span class="p">(</span><span class="n">scsi_sblist</span><span class="p">);</span>

	<span class="cm">/* sanity check */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sb_count</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">psb</span><span class="p">,</span> <span class="n">psb_next</span><span class="p">,</span> <span class="n">post_sblist</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">psb</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
		<span class="n">block_cnt</span><span class="o">++</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">last_xritag</span> <span class="o">!=</span> <span class="n">NO_XRI</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="p">(</span><span class="n">psb</span><span class="o">-&gt;</span><span class="n">cur_iocbq</span><span class="p">.</span><span class="n">sli4_xritag</span> <span class="o">!=</span> <span class="n">last_xritag</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/* a hole in xri block, form a sgl posting block */</span>
			<span class="n">list_splice_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">prep_sblist</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">blck_sblist</span><span class="p">);</span>
			<span class="n">post_cnt</span> <span class="o">=</span> <span class="n">block_cnt</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
			<span class="cm">/* prepare list for next posting block */</span>
			<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">psb</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">prep_sblist</span><span class="p">);</span>
			<span class="n">block_cnt</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/* prepare list for next posting block */</span>
			<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">psb</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">prep_sblist</span><span class="p">);</span>
			<span class="cm">/* enough sgls for non-embed sgl mbox command */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">block_cnt</span> <span class="o">==</span> <span class="n">LPFC_NEMBED_MBOX_SGL_CNT</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">list_splice_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">prep_sblist</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">blck_sblist</span><span class="p">);</span>
				<span class="n">post_cnt</span> <span class="o">=</span> <span class="n">block_cnt</span><span class="p">;</span>
				<span class="n">block_cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="n">num_posting</span><span class="o">++</span><span class="p">;</span>
		<span class="n">last_xritag</span> <span class="o">=</span> <span class="n">psb</span><span class="o">-&gt;</span><span class="n">cur_iocbq</span><span class="p">.</span><span class="n">sli4_xritag</span><span class="p">;</span>

		<span class="cm">/* end of repost sgl list condition for SCSI buffers */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">num_posting</span> <span class="o">==</span> <span class="n">sb_count</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">post_cnt</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/* last sgl posting block */</span>
				<span class="n">list_splice_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">prep_sblist</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">blck_sblist</span><span class="p">);</span>
				<span class="n">post_cnt</span> <span class="o">=</span> <span class="n">block_cnt</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">block_cnt</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/* last single sgl with non-contiguous xri */</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">cfg_sg_dma_buf_size</span> <span class="o">&gt;</span> <span class="n">SGL_PAGE_SIZE</span><span class="p">)</span>
					<span class="n">pdma_phys_bpl1</span> <span class="o">=</span> <span class="n">psb</span><span class="o">-&gt;</span><span class="n">dma_phys_bpl</span> <span class="o">+</span>
								<span class="n">SGL_PAGE_SIZE</span><span class="p">;</span>
				<span class="k">else</span>
					<span class="n">pdma_phys_bpl1</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
				<span class="n">status</span> <span class="o">=</span> <span class="n">lpfc_sli4_post_sgl</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span>
						<span class="n">psb</span><span class="o">-&gt;</span><span class="n">dma_phys_bpl</span><span class="p">,</span>
						<span class="n">pdma_phys_bpl1</span><span class="p">,</span>
						<span class="n">psb</span><span class="o">-&gt;</span><span class="n">cur_iocbq</span><span class="p">.</span><span class="n">sli4_xritag</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">status</span><span class="p">)</span> <span class="p">{</span>
					<span class="cm">/* failure, put on abort scsi list */</span>
					<span class="n">psb</span><span class="o">-&gt;</span><span class="n">exch_busy</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
				<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
					<span class="cm">/* success, put on SCSI buffer list */</span>
					<span class="n">psb</span><span class="o">-&gt;</span><span class="n">exch_busy</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
					<span class="n">psb</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">=</span> <span class="n">IOSTAT_SUCCESS</span><span class="p">;</span>
					<span class="n">num_posted</span><span class="o">++</span><span class="p">;</span>
				<span class="p">}</span>
				<span class="cm">/* success, put on SCSI buffer sgl list */</span>
				<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">psb</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">scsi_sblist</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="cm">/* continue until a nembed page worth of sgls */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">post_cnt</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="cm">/* post block of SCSI buffer list sgls */</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">lpfc_sli4_post_scsi_sgl_block</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">blck_sblist</span><span class="p">,</span>
						       <span class="n">post_cnt</span><span class="p">);</span>

		<span class="cm">/* don&#39;t reset xirtag due to hole in xri block */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">block_cnt</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">last_xritag</span> <span class="o">=</span> <span class="n">NO_XRI</span><span class="p">;</span>

		<span class="cm">/* reset SCSI buffer post count for next round of posting */</span>
		<span class="n">post_cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="cm">/* put posted SCSI buffer-sgl posted on SCSI buffer sgl list */</span>
		<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">blck_sblist</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">list_remove_head</span><span class="p">(</span><span class="o">&amp;</span><span class="n">blck_sblist</span><span class="p">,</span> <span class="n">psb</span><span class="p">,</span>
					 <span class="k">struct</span> <span class="n">lpfc_scsi_buf</span><span class="p">,</span> <span class="n">list</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">status</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/* failure, put on abort scsi list */</span>
				<span class="n">psb</span><span class="o">-&gt;</span><span class="n">exch_busy</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="cm">/* success, put on SCSI buffer list */</span>
				<span class="n">psb</span><span class="o">-&gt;</span><span class="n">exch_busy</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
				<span class="n">psb</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">=</span> <span class="n">IOSTAT_SUCCESS</span><span class="p">;</span>
				<span class="n">num_posted</span><span class="o">++</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">psb</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">scsi_sblist</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="cm">/* Push SCSI buffers with sgl posted to the availble list */</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">scsi_sblist</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">list_remove_head</span><span class="p">(</span><span class="o">&amp;</span><span class="n">scsi_sblist</span><span class="p">,</span> <span class="n">psb</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">lpfc_scsi_buf</span><span class="p">,</span> <span class="n">list</span><span class="p">);</span>
		<span class="n">lpfc_release_scsi_buf_s4</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">psb</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">num_posted</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_sli4_repost_scsi_sgl_list - Repsot all the allocated scsi buffer sgls</span>
<span class="cm"> * @phba: pointer to lpfc hba data structure.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine walks the list of scsi buffers that have been allocated and</span>
<span class="cm"> * repost them to the port by using SGL block post. This is needed after a</span>
<span class="cm"> * pci_function_reset/warm_start or start. The lpfc_hba_down_post_s4 routine</span>
<span class="cm"> * is responsible for moving all scsi buffers on the lpfc_abts_scsi_sgl_list</span>
<span class="cm"> * to the lpfc_scsi_buf_list. If the repost fails, reject all scsi buffers.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns: 0 = success, non-zero failure.</span>
<span class="cm"> **/</span>
<span class="kt">int</span>
<span class="nf">lpfc_sli4_repost_scsi_sgl_list</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">LIST_HEAD</span><span class="p">(</span><span class="n">post_sblist</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">num_posted</span><span class="p">,</span> <span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* get all SCSI buffers need to repost to a local list */</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">scsi_buf_list_lock</span><span class="p">);</span>
	<span class="n">list_splice_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">lpfc_scsi_buf_list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">post_sblist</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">scsi_buf_list_lock</span><span class="p">);</span>

	<span class="cm">/* post the list of scsi buffer sgls to port if available */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">post_sblist</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">num_posted</span> <span class="o">=</span> <span class="n">lpfc_sli4_post_scsi_sgl_list</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">post_sblist</span><span class="p">,</span>
						<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">scsi_xri_cnt</span><span class="p">);</span>
		<span class="cm">/* failed to post any scsi buffer, return error */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">num_posted</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_new_scsi_buf_s4 - Scsi buffer allocator for HBA with SLI4 IF spec</span>
<span class="cm"> * @vport: The virtual port for which this call being executed.</span>
<span class="cm"> * @num_to_allocate: The requested number of buffers to allocate.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine allocates scsi buffers for device with SLI-4 interface spec,</span>
<span class="cm"> * the scsi buffer contains all the necessary information needed to initiate</span>
<span class="cm"> * a SCSI I/O. After allocating up to @num_to_allocate SCSI buffers and put</span>
<span class="cm"> * them on a list, it post them to the port by using SGL block post.</span>
<span class="cm"> *</span>
<span class="cm"> * Return codes:</span>
<span class="cm"> *   int - number of scsi buffers that were allocated and posted.</span>
<span class="cm"> *   0 = failure, less than num_to_alloc is a partial failure.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">lpfc_new_scsi_buf_s4</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="n">vport</span><span class="p">,</span> <span class="kt">int</span> <span class="n">num_to_alloc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span> <span class="o">=</span> <span class="n">vport</span><span class="o">-&gt;</span><span class="n">phba</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_scsi_buf</span> <span class="o">*</span><span class="n">psb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sli4_sge</span> <span class="o">*</span><span class="n">sgl</span><span class="p">;</span>
	<span class="n">IOCB_t</span> <span class="o">*</span><span class="n">iocb</span><span class="p">;</span>
	<span class="n">dma_addr_t</span> <span class="n">pdma_phys_fcp_cmd</span><span class="p">;</span>
	<span class="n">dma_addr_t</span> <span class="n">pdma_phys_fcp_rsp</span><span class="p">;</span>
	<span class="n">dma_addr_t</span> <span class="n">pdma_phys_bpl</span><span class="p">,</span> <span class="n">pdma_phys_bpl1</span><span class="p">;</span>
	<span class="kt">uint16_t</span> <span class="n">iotag</span><span class="p">,</span> <span class="n">lxri</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">bcnt</span><span class="p">,</span> <span class="n">num_posted</span><span class="p">;</span>
	<span class="n">LIST_HEAD</span><span class="p">(</span><span class="n">prep_sblist</span><span class="p">);</span>
	<span class="n">LIST_HEAD</span><span class="p">(</span><span class="n">post_sblist</span><span class="p">);</span>
	<span class="n">LIST_HEAD</span><span class="p">(</span><span class="n">scsi_sblist</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">bcnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">bcnt</span> <span class="o">&lt;</span> <span class="n">num_to_alloc</span><span class="p">;</span> <span class="n">bcnt</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">psb</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_scsi_buf</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">psb</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * Get memory from the pci pool to map the virt space to</span>
<span class="cm">		 * pci bus space for an I/O. The DMA buffer includes space</span>
<span class="cm">		 * for the struct fcp_cmnd, struct fcp_rsp and the number</span>
<span class="cm">		 * of bde&#39;s necessary to support the sg_tablesize.</span>
<span class="cm">		 */</span>
		<span class="n">psb</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">=</span> <span class="n">pci_pool_alloc</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">lpfc_scsi_dma_buf_pool</span><span class="p">,</span>
						<span class="n">GFP_KERNEL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">psb</span><span class="o">-&gt;</span><span class="n">dma_handle</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">psb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">kfree</span><span class="p">(</span><span class="n">psb</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">memset</span><span class="p">(</span><span class="n">psb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">cfg_sg_dma_buf_size</span><span class="p">);</span>

		<span class="cm">/* Allocate iotag for psb-&gt;cur_iocbq. */</span>
		<span class="n">iotag</span> <span class="o">=</span> <span class="n">lpfc_sli_next_iotag</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">psb</span><span class="o">-&gt;</span><span class="n">cur_iocbq</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">iotag</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pci_pool_free</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">lpfc_scsi_dma_buf_pool</span><span class="p">,</span>
				<span class="n">psb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span> <span class="n">psb</span><span class="o">-&gt;</span><span class="n">dma_handle</span><span class="p">);</span>
			<span class="n">kfree</span><span class="p">(</span><span class="n">psb</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">lxri</span> <span class="o">=</span> <span class="n">lpfc_sli4_next_xritag</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">lxri</span> <span class="o">==</span> <span class="n">NO_XRI</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pci_pool_free</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">lpfc_scsi_dma_buf_pool</span><span class="p">,</span>
			      <span class="n">psb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span> <span class="n">psb</span><span class="o">-&gt;</span><span class="n">dma_handle</span><span class="p">);</span>
			<span class="n">kfree</span><span class="p">(</span><span class="n">psb</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">psb</span><span class="o">-&gt;</span><span class="n">cur_iocbq</span><span class="p">.</span><span class="n">sli4_lxritag</span> <span class="o">=</span> <span class="n">lxri</span><span class="p">;</span>
		<span class="n">psb</span><span class="o">-&gt;</span><span class="n">cur_iocbq</span><span class="p">.</span><span class="n">sli4_xritag</span> <span class="o">=</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">xri_ids</span><span class="p">[</span><span class="n">lxri</span><span class="p">];</span>
		<span class="n">psb</span><span class="o">-&gt;</span><span class="n">cur_iocbq</span><span class="p">.</span><span class="n">iocb_flag</span> <span class="o">|=</span> <span class="n">LPFC_IO_FCP</span><span class="p">;</span>
		<span class="n">psb</span><span class="o">-&gt;</span><span class="n">fcp_bpl</span> <span class="o">=</span> <span class="n">psb</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
		<span class="n">psb</span><span class="o">-&gt;</span><span class="n">fcp_cmnd</span> <span class="o">=</span> <span class="p">(</span><span class="n">psb</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">+</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">cfg_sg_dma_buf_size</span><span class="p">)</span>
			<span class="o">-</span> <span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">fcp_cmnd</span><span class="p">)</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">fcp_rsp</span><span class="p">));</span>
		<span class="n">psb</span><span class="o">-&gt;</span><span class="n">fcp_rsp</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">fcp_rsp</span> <span class="o">*</span><span class="p">)((</span><span class="kt">uint8_t</span> <span class="o">*</span><span class="p">)</span><span class="n">psb</span><span class="o">-&gt;</span><span class="n">fcp_cmnd</span> <span class="o">+</span>
					<span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">fcp_cmnd</span><span class="p">));</span>

		<span class="cm">/* Initialize local short-hand pointers. */</span>
		<span class="n">sgl</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sli4_sge</span> <span class="o">*</span><span class="p">)</span><span class="n">psb</span><span class="o">-&gt;</span><span class="n">fcp_bpl</span><span class="p">;</span>
		<span class="n">pdma_phys_bpl</span> <span class="o">=</span> <span class="n">psb</span><span class="o">-&gt;</span><span class="n">dma_handle</span><span class="p">;</span>
		<span class="n">pdma_phys_fcp_cmd</span> <span class="o">=</span>
			<span class="p">(</span><span class="n">psb</span><span class="o">-&gt;</span><span class="n">dma_handle</span> <span class="o">+</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">cfg_sg_dma_buf_size</span><span class="p">)</span>
			 <span class="o">-</span> <span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">fcp_cmnd</span><span class="p">)</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">fcp_rsp</span><span class="p">));</span>
		<span class="n">pdma_phys_fcp_rsp</span> <span class="o">=</span> <span class="n">pdma_phys_fcp_cmd</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">fcp_cmnd</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * The first two bdes are the FCP_CMD and FCP_RSP.</span>
<span class="cm">		 * The balance are sg list bdes. Initialize the</span>
<span class="cm">		 * first two and leave the rest for queuecommand.</span>
<span class="cm">		 */</span>
		<span class="n">sgl</span><span class="o">-&gt;</span><span class="n">addr_hi</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">putPaddrHigh</span><span class="p">(</span><span class="n">pdma_phys_fcp_cmd</span><span class="p">));</span>
		<span class="n">sgl</span><span class="o">-&gt;</span><span class="n">addr_lo</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">putPaddrLow</span><span class="p">(</span><span class="n">pdma_phys_fcp_cmd</span><span class="p">));</span>
		<span class="n">sgl</span><span class="o">-&gt;</span><span class="n">word2</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">sgl</span><span class="o">-&gt;</span><span class="n">word2</span><span class="p">);</span>
		<span class="n">bf_set</span><span class="p">(</span><span class="n">lpfc_sli4_sge_last</span><span class="p">,</span> <span class="n">sgl</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">sgl</span><span class="o">-&gt;</span><span class="n">word2</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">sgl</span><span class="o">-&gt;</span><span class="n">word2</span><span class="p">);</span>
		<span class="n">sgl</span><span class="o">-&gt;</span><span class="n">sge_len</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">fcp_cmnd</span><span class="p">));</span>
		<span class="n">sgl</span><span class="o">++</span><span class="p">;</span>

		<span class="cm">/* Setup the physical region for the FCP RSP */</span>
		<span class="n">sgl</span><span class="o">-&gt;</span><span class="n">addr_hi</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">putPaddrHigh</span><span class="p">(</span><span class="n">pdma_phys_fcp_rsp</span><span class="p">));</span>
		<span class="n">sgl</span><span class="o">-&gt;</span><span class="n">addr_lo</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">putPaddrLow</span><span class="p">(</span><span class="n">pdma_phys_fcp_rsp</span><span class="p">));</span>
		<span class="n">sgl</span><span class="o">-&gt;</span><span class="n">word2</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">sgl</span><span class="o">-&gt;</span><span class="n">word2</span><span class="p">);</span>
		<span class="n">bf_set</span><span class="p">(</span><span class="n">lpfc_sli4_sge_last</span><span class="p">,</span> <span class="n">sgl</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">sgl</span><span class="o">-&gt;</span><span class="n">word2</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">sgl</span><span class="o">-&gt;</span><span class="n">word2</span><span class="p">);</span>
		<span class="n">sgl</span><span class="o">-&gt;</span><span class="n">sge_len</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">fcp_rsp</span><span class="p">));</span>

		<span class="cm">/*</span>
<span class="cm">		 * Since the IOCB for the FCP I/O is built into this</span>
<span class="cm">		 * lpfc_scsi_buf, initialize it with all known data now.</span>
<span class="cm">		 */</span>
		<span class="n">iocb</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">psb</span><span class="o">-&gt;</span><span class="n">cur_iocbq</span><span class="p">.</span><span class="n">iocb</span><span class="p">;</span>
		<span class="n">iocb</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">fcpi64</span><span class="p">.</span><span class="n">bdl</span><span class="p">.</span><span class="n">ulpIoTag32</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">iocb</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">fcpi64</span><span class="p">.</span><span class="n">bdl</span><span class="p">.</span><span class="n">bdeFlags</span> <span class="o">=</span> <span class="n">BUFF_TYPE_BDE_64</span><span class="p">;</span>
		<span class="cm">/* setting the BLP size to 2 * sizeof BDE may not be correct.</span>
<span class="cm">		 * We are setting the bpl to point to out sgl. An sgl&#39;s</span>
<span class="cm">		 * entries are 16 bytes, a bpl entries are 12 bytes.</span>
<span class="cm">		 */</span>
		<span class="n">iocb</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">fcpi64</span><span class="p">.</span><span class="n">bdl</span><span class="p">.</span><span class="n">bdeSize</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">fcp_cmnd</span><span class="p">);</span>
		<span class="n">iocb</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">fcpi64</span><span class="p">.</span><span class="n">bdl</span><span class="p">.</span><span class="n">addrLow</span> <span class="o">=</span> <span class="n">putPaddrLow</span><span class="p">(</span><span class="n">pdma_phys_fcp_cmd</span><span class="p">);</span>
		<span class="n">iocb</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">fcpi64</span><span class="p">.</span><span class="n">bdl</span><span class="p">.</span><span class="n">addrHigh</span> <span class="o">=</span> <span class="n">putPaddrHigh</span><span class="p">(</span><span class="n">pdma_phys_fcp_cmd</span><span class="p">);</span>
		<span class="n">iocb</span><span class="o">-&gt;</span><span class="n">ulpBdeCount</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">iocb</span><span class="o">-&gt;</span><span class="n">ulpLe</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">iocb</span><span class="o">-&gt;</span><span class="n">ulpClass</span> <span class="o">=</span> <span class="n">CLASS3</span><span class="p">;</span>
		<span class="n">psb</span><span class="o">-&gt;</span><span class="n">cur_iocbq</span><span class="p">.</span><span class="n">context1</span> <span class="o">=</span> <span class="n">psb</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">cfg_sg_dma_buf_size</span> <span class="o">&gt;</span> <span class="n">SGL_PAGE_SIZE</span><span class="p">)</span>
			<span class="n">pdma_phys_bpl1</span> <span class="o">=</span> <span class="n">pdma_phys_bpl</span> <span class="o">+</span> <span class="n">SGL_PAGE_SIZE</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">pdma_phys_bpl1</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">psb</span><span class="o">-&gt;</span><span class="n">dma_phys_bpl</span> <span class="o">=</span> <span class="n">pdma_phys_bpl</span><span class="p">;</span>

		<span class="cm">/* add the scsi buffer to a post list */</span>
		<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">psb</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">post_sblist</span><span class="p">);</span>
		<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">scsi_buf_list_lock</span><span class="p">);</span>
		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">scsi_xri_cnt</span><span class="o">++</span><span class="p">;</span>
		<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">scsi_buf_list_lock</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_INFO</span><span class="p">,</span> <span class="n">LOG_BG</span><span class="p">,</span>
			<span class="s">&quot;3021 Allocate %d out of %d requested new SCSI &quot;</span>
			<span class="s">&quot;buffers</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">bcnt</span><span class="p">,</span> <span class="n">num_to_alloc</span><span class="p">);</span>

	<span class="cm">/* post the list of scsi buffer sgls to port if available */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">post_sblist</span><span class="p">))</span>
		<span class="n">num_posted</span> <span class="o">=</span> <span class="n">lpfc_sli4_post_scsi_sgl_list</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span>
							  <span class="o">&amp;</span><span class="n">post_sblist</span><span class="p">,</span> <span class="n">bcnt</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">num_posted</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">num_posted</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_new_scsi_buf - Wrapper funciton for scsi buffer allocator</span>
<span class="cm"> * @vport: The virtual port for which this call being executed.</span>
<span class="cm"> * @num_to_allocate: The requested number of buffers to allocate.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine wraps the actual SCSI buffer allocator function pointer from</span>
<span class="cm"> * the lpfc_hba struct.</span>
<span class="cm"> *</span>
<span class="cm"> * Return codes:</span>
<span class="cm"> *   int - number of scsi buffers that were allocated.</span>
<span class="cm"> *   0 = failure, less than num_to_alloc is a partial failure.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span>
<span class="nf">lpfc_new_scsi_buf</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="n">vport</span><span class="p">,</span> <span class="kt">int</span> <span class="n">num_to_alloc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">vport</span><span class="o">-&gt;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">lpfc_new_scsi_buf</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">num_to_alloc</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_get_scsi_buf_s3 - Get a scsi buffer from lpfc_scsi_buf_list of the HBA</span>
<span class="cm"> * @phba: The HBA for which this call is being executed.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine removes a scsi buffer from head of @phba lpfc_scsi_buf_list list</span>
<span class="cm"> * and returns to caller.</span>
<span class="cm"> *</span>
<span class="cm"> * Return codes:</span>
<span class="cm"> *   NULL - Error</span>
<span class="cm"> *   Pointer to lpfc_scsi_buf - Success</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">lpfc_scsi_buf</span><span class="o">*</span>
<span class="nf">lpfc_get_scsi_buf_s3</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">,</span> <span class="k">struct</span> <span class="n">lpfc_nodelist</span> <span class="o">*</span><span class="n">ndlp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span>  <span class="n">lpfc_scsi_buf</span> <span class="o">*</span> <span class="n">lpfc_cmd</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">scsi_buf_list</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">lpfc_scsi_buf_list</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">iflag</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">scsi_buf_list_lock</span><span class="p">,</span> <span class="n">iflag</span><span class="p">);</span>
	<span class="n">list_remove_head</span><span class="p">(</span><span class="n">scsi_buf_list</span><span class="p">,</span> <span class="n">lpfc_cmd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">lpfc_scsi_buf</span><span class="p">,</span> <span class="n">list</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">lpfc_cmd</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lpfc_cmd</span><span class="o">-&gt;</span><span class="n">seg_cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">lpfc_cmd</span><span class="o">-&gt;</span><span class="n">nonsg_phys</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">lpfc_cmd</span><span class="o">-&gt;</span><span class="n">prot_seg_cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">scsi_buf_list_lock</span><span class="p">,</span> <span class="n">iflag</span><span class="p">);</span>
	<span class="k">return</span>  <span class="n">lpfc_cmd</span><span class="p">;</span>
<span class="p">}</span>
<span class="cm">/**</span>
<span class="cm"> * lpfc_get_scsi_buf_s4 - Get a scsi buffer from lpfc_scsi_buf_list of the HBA</span>
<span class="cm"> * @phba: The HBA for which this call is being executed.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine removes a scsi buffer from head of @phba lpfc_scsi_buf_list list</span>
<span class="cm"> * and returns to caller.</span>
<span class="cm"> *</span>
<span class="cm"> * Return codes:</span>
<span class="cm"> *   NULL - Error</span>
<span class="cm"> *   Pointer to lpfc_scsi_buf - Success</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">lpfc_scsi_buf</span><span class="o">*</span>
<span class="nf">lpfc_get_scsi_buf_s4</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">,</span> <span class="k">struct</span> <span class="n">lpfc_nodelist</span> <span class="o">*</span><span class="n">ndlp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpfc_scsi_buf</span> <span class="o">*</span><span class="n">lpfc_cmd</span> <span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">iflag</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">found</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">scsi_buf_list_lock</span><span class="p">,</span> <span class="n">iflag</span><span class="p">);</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">lpfc_cmd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">lpfc_scsi_buf_list</span><span class="p">,</span>
							<span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">lpfc_test_rrq_active</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">ndlp</span><span class="p">,</span>
					 <span class="n">lpfc_cmd</span><span class="o">-&gt;</span><span class="n">cur_iocbq</span><span class="p">.</span><span class="n">sli4_lxritag</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lpfc_cmd</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
		<span class="n">found</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">lpfc_cmd</span><span class="o">-&gt;</span><span class="n">seg_cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">lpfc_cmd</span><span class="o">-&gt;</span><span class="n">nonsg_phys</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">lpfc_cmd</span><span class="o">-&gt;</span><span class="n">prot_seg_cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">scsi_buf_list_lock</span><span class="p">,</span>
						 <span class="n">iflag</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">found</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="k">return</span>  <span class="n">lpfc_cmd</span><span class="p">;</span>
<span class="p">}</span>
<span class="cm">/**</span>
<span class="cm"> * lpfc_get_scsi_buf - Get a scsi buffer from lpfc_scsi_buf_list of the HBA</span>
<span class="cm"> * @phba: The HBA for which this call is being executed.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine removes a scsi buffer from head of @phba lpfc_scsi_buf_list list</span>
<span class="cm"> * and returns to caller.</span>
<span class="cm"> *</span>
<span class="cm"> * Return codes:</span>
<span class="cm"> *   NULL - Error</span>
<span class="cm"> *   Pointer to lpfc_scsi_buf - Success</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">lpfc_scsi_buf</span><span class="o">*</span>
<span class="nf">lpfc_get_scsi_buf</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">,</span> <span class="k">struct</span> <span class="n">lpfc_nodelist</span> <span class="o">*</span><span class="n">ndlp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span>  <span class="n">phba</span><span class="o">-&gt;</span><span class="n">lpfc_get_scsi_buf</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">ndlp</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_release_scsi_buf - Return a scsi buffer back to hba scsi buf list</span>
<span class="cm"> * @phba: The Hba for which this call is being executed.</span>
<span class="cm"> * @psb: The scsi buffer which is being released.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine releases @psb scsi buffer by adding it to tail of @phba</span>
<span class="cm"> * lpfc_scsi_buf_list list.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">lpfc_release_scsi_buf_s3</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">,</span> <span class="k">struct</span> <span class="n">lpfc_scsi_buf</span> <span class="o">*</span><span class="n">psb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">iflag</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">scsi_buf_list_lock</span><span class="p">,</span> <span class="n">iflag</span><span class="p">);</span>
	<span class="n">psb</span><span class="o">-&gt;</span><span class="n">pCmd</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">psb</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">lpfc_scsi_buf_list</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">scsi_buf_list_lock</span><span class="p">,</span> <span class="n">iflag</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_release_scsi_buf_s4: Return a scsi buffer back to hba scsi buf list.</span>
<span class="cm"> * @phba: The Hba for which this call is being executed.</span>
<span class="cm"> * @psb: The scsi buffer which is being released.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine releases @psb scsi buffer by adding it to tail of @phba</span>
<span class="cm"> * lpfc_scsi_buf_list list. For SLI4 XRI&#39;s are tied to the scsi buffer</span>
<span class="cm"> * and cannot be reused for at least RA_TOV amount of time if it was</span>
<span class="cm"> * aborted.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">lpfc_release_scsi_buf_s4</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">,</span> <span class="k">struct</span> <span class="n">lpfc_scsi_buf</span> <span class="o">*</span><span class="n">psb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">iflag</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">psb</span><span class="o">-&gt;</span><span class="n">exch_busy</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">abts_scsi_buf_list_lock</span><span class="p">,</span>
					<span class="n">iflag</span><span class="p">);</span>
		<span class="n">psb</span><span class="o">-&gt;</span><span class="n">pCmd</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">psb</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span>
			<span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">lpfc_abts_scsi_buf_list</span><span class="p">);</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">abts_scsi_buf_list_lock</span><span class="p">,</span>
					<span class="n">iflag</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>

		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">scsi_buf_list_lock</span><span class="p">,</span> <span class="n">iflag</span><span class="p">);</span>
		<span class="n">psb</span><span class="o">-&gt;</span><span class="n">pCmd</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">psb</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">lpfc_scsi_buf_list</span><span class="p">);</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">scsi_buf_list_lock</span><span class="p">,</span> <span class="n">iflag</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_release_scsi_buf: Return a scsi buffer back to hba scsi buf list.</span>
<span class="cm"> * @phba: The Hba for which this call is being executed.</span>
<span class="cm"> * @psb: The scsi buffer which is being released.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine releases @psb scsi buffer by adding it to tail of @phba</span>
<span class="cm"> * lpfc_scsi_buf_list list.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">lpfc_release_scsi_buf</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">,</span> <span class="k">struct</span> <span class="n">lpfc_scsi_buf</span> <span class="o">*</span><span class="n">psb</span><span class="p">)</span>
<span class="p">{</span>

	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">lpfc_release_scsi_buf</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">psb</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_scsi_prep_dma_buf_s3 - DMA mapping for scsi buffer to SLI3 IF spec</span>
<span class="cm"> * @phba: The Hba for which this call is being executed.</span>
<span class="cm"> * @lpfc_cmd: The scsi buffer which is going to be mapped.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine does the pci dma mapping for scatter-gather list of scsi cmnd</span>
<span class="cm"> * field of @lpfc_cmd for device with SLI-3 interface spec. This routine scans</span>
<span class="cm"> * through sg elements and format the bdea. This routine also initializes all</span>
<span class="cm"> * IOCB fields which are dependent on scsi command request buffer.</span>
<span class="cm"> *</span>
<span class="cm"> * Return codes:</span>
<span class="cm"> *   1 - Error</span>
<span class="cm"> *   0 - Success</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">lpfc_scsi_prep_dma_buf_s3</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">,</span> <span class="k">struct</span> <span class="n">lpfc_scsi_buf</span> <span class="o">*</span><span class="n">lpfc_cmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="n">scsi_cmnd</span> <span class="o">=</span> <span class="n">lpfc_cmd</span><span class="o">-&gt;</span><span class="n">pCmd</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">scatterlist</span> <span class="o">*</span><span class="n">sgel</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fcp_cmnd</span> <span class="o">*</span><span class="n">fcp_cmnd</span> <span class="o">=</span> <span class="n">lpfc_cmd</span><span class="o">-&gt;</span><span class="n">fcp_cmnd</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ulp_bde64</span> <span class="o">*</span><span class="n">bpl</span> <span class="o">=</span> <span class="n">lpfc_cmd</span><span class="o">-&gt;</span><span class="n">fcp_bpl</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_iocbq</span> <span class="o">*</span><span class="n">iocbq</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">lpfc_cmd</span><span class="o">-&gt;</span><span class="n">cur_iocbq</span><span class="p">;</span>
	<span class="n">IOCB_t</span> <span class="o">*</span><span class="n">iocb_cmd</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">lpfc_cmd</span><span class="o">-&gt;</span><span class="n">cur_iocbq</span><span class="p">.</span><span class="n">iocb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ulp_bde64</span> <span class="o">*</span><span class="n">data_bde</span> <span class="o">=</span> <span class="n">iocb_cmd</span><span class="o">-&gt;</span><span class="n">unsli3</span><span class="p">.</span><span class="n">fcp_ext</span><span class="p">.</span><span class="n">dbde</span><span class="p">;</span>
	<span class="n">dma_addr_t</span> <span class="n">physaddr</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">num_bde</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">nseg</span><span class="p">,</span> <span class="n">datadir</span> <span class="o">=</span> <span class="n">scsi_cmnd</span><span class="o">-&gt;</span><span class="n">sc_data_direction</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * There are three possibilities here - use scatter-gather segment, use</span>
<span class="cm">	 * the single mapping, or neither.  Start the lpfc command prep by</span>
<span class="cm">	 * bumping the bpl beyond the fcp_cmnd and fcp_rsp regions to the first</span>
<span class="cm">	 * data bde entry.</span>
<span class="cm">	 */</span>
	<span class="n">bpl</span> <span class="o">+=</span> <span class="mi">2</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">scsi_sg_count</span><span class="p">(</span><span class="n">scsi_cmnd</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * The driver stores the segment count returned from pci_map_sg</span>
<span class="cm">		 * because this a count of dma-mappings used to map the use_sg</span>
<span class="cm">		 * pages.  They are not guaranteed to be the same for those</span>
<span class="cm">		 * architectures that implement an IOMMU.</span>
<span class="cm">		 */</span>

		<span class="n">nseg</span> <span class="o">=</span> <span class="n">dma_map_sg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">pcidev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">scsi_sglist</span><span class="p">(</span><span class="n">scsi_cmnd</span><span class="p">),</span>
				  <span class="n">scsi_sg_count</span><span class="p">(</span><span class="n">scsi_cmnd</span><span class="p">),</span> <span class="n">datadir</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">nseg</span><span class="p">))</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

		<span class="n">lpfc_cmd</span><span class="o">-&gt;</span><span class="n">seg_cnt</span> <span class="o">=</span> <span class="n">nseg</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">lpfc_cmd</span><span class="o">-&gt;</span><span class="n">seg_cnt</span> <span class="o">&gt;</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">cfg_sg_seg_cnt</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_BG</span><span class="p">,</span>
				<span class="s">&quot;9064 BLKGRD: %s: Too many sg segments from &quot;</span>
			       <span class="s">&quot;dma_map_sg.  Config %d, seg_cnt %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">__func__</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">cfg_sg_seg_cnt</span><span class="p">,</span>
			       <span class="n">lpfc_cmd</span><span class="o">-&gt;</span><span class="n">seg_cnt</span><span class="p">);</span>
			<span class="n">scsi_dma_unmap</span><span class="p">(</span><span class="n">scsi_cmnd</span><span class="p">);</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 * The driver established a maximum scatter-gather segment count</span>
<span class="cm">		 * during probe that limits the number of sg elements in any</span>
<span class="cm">		 * single scsi command.  Just run through the seg_cnt and format</span>
<span class="cm">		 * the bde&#39;s.</span>
<span class="cm">		 * When using SLI-3 the driver will try to fit all the BDEs into</span>
<span class="cm">		 * the IOCB. If it can&#39;t then the BDEs get added to a BPL as it</span>
<span class="cm">		 * does for SLI-2 mode.</span>
<span class="cm">		 */</span>
		<span class="n">scsi_for_each_sg</span><span class="p">(</span><span class="n">scsi_cmnd</span><span class="p">,</span> <span class="n">sgel</span><span class="p">,</span> <span class="n">nseg</span><span class="p">,</span> <span class="n">num_bde</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">physaddr</span> <span class="o">=</span> <span class="n">sg_dma_address</span><span class="p">(</span><span class="n">sgel</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli_rev</span> <span class="o">==</span> <span class="mi">3</span> <span class="o">&amp;&amp;</span>
			    <span class="o">!</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli3_options</span> <span class="o">&amp;</span> <span class="n">LPFC_SLI3_BG_ENABLED</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			    <span class="o">!</span><span class="p">(</span><span class="n">iocbq</span><span class="o">-&gt;</span><span class="n">iocb_flag</span> <span class="o">&amp;</span> <span class="n">DSS_SECURITY_OP</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			    <span class="n">nseg</span> <span class="o">&lt;=</span> <span class="n">LPFC_EXT_DATA_BDE_COUNT</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">data_bde</span><span class="o">-&gt;</span><span class="n">tus</span><span class="p">.</span><span class="n">f</span><span class="p">.</span><span class="n">bdeFlags</span> <span class="o">=</span> <span class="n">BUFF_TYPE_BDE_64</span><span class="p">;</span>
				<span class="n">data_bde</span><span class="o">-&gt;</span><span class="n">tus</span><span class="p">.</span><span class="n">f</span><span class="p">.</span><span class="n">bdeSize</span> <span class="o">=</span> <span class="n">sg_dma_len</span><span class="p">(</span><span class="n">sgel</span><span class="p">);</span>
				<span class="n">data_bde</span><span class="o">-&gt;</span><span class="n">addrLow</span> <span class="o">=</span> <span class="n">putPaddrLow</span><span class="p">(</span><span class="n">physaddr</span><span class="p">);</span>
				<span class="n">data_bde</span><span class="o">-&gt;</span><span class="n">addrHigh</span> <span class="o">=</span> <span class="n">putPaddrHigh</span><span class="p">(</span><span class="n">physaddr</span><span class="p">);</span>
				<span class="n">data_bde</span><span class="o">++</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="n">bpl</span><span class="o">-&gt;</span><span class="n">tus</span><span class="p">.</span><span class="n">f</span><span class="p">.</span><span class="n">bdeFlags</span> <span class="o">=</span> <span class="n">BUFF_TYPE_BDE_64</span><span class="p">;</span>
				<span class="n">bpl</span><span class="o">-&gt;</span><span class="n">tus</span><span class="p">.</span><span class="n">f</span><span class="p">.</span><span class="n">bdeSize</span> <span class="o">=</span> <span class="n">sg_dma_len</span><span class="p">(</span><span class="n">sgel</span><span class="p">);</span>
				<span class="n">bpl</span><span class="o">-&gt;</span><span class="n">tus</span><span class="p">.</span><span class="n">w</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">bpl</span><span class="o">-&gt;</span><span class="n">tus</span><span class="p">.</span><span class="n">w</span><span class="p">);</span>
				<span class="n">bpl</span><span class="o">-&gt;</span><span class="n">addrLow</span> <span class="o">=</span>
					<span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">putPaddrLow</span><span class="p">(</span><span class="n">physaddr</span><span class="p">));</span>
				<span class="n">bpl</span><span class="o">-&gt;</span><span class="n">addrHigh</span> <span class="o">=</span>
					<span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">putPaddrHigh</span><span class="p">(</span><span class="n">physaddr</span><span class="p">));</span>
				<span class="n">bpl</span><span class="o">++</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Finish initializing those IOCB fields that are dependent on the</span>
<span class="cm">	 * scsi_cmnd request_buffer.  Note that for SLI-2 the bdeSize is</span>
<span class="cm">	 * explicitly reinitialized and for SLI-3 the extended bde count is</span>
<span class="cm">	 * explicitly reinitialized since all iocb memory resources are reused.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli_rev</span> <span class="o">==</span> <span class="mi">3</span> <span class="o">&amp;&amp;</span>
	    <span class="o">!</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli3_options</span> <span class="o">&amp;</span> <span class="n">LPFC_SLI3_BG_ENABLED</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="o">!</span><span class="p">(</span><span class="n">iocbq</span><span class="o">-&gt;</span><span class="n">iocb_flag</span> <span class="o">&amp;</span> <span class="n">DSS_SECURITY_OP</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">num_bde</span> <span class="o">&gt;</span> <span class="n">LPFC_EXT_DATA_BDE_COUNT</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * The extended IOCB format can only fit 3 BDE or a BPL.</span>
<span class="cm">			 * This I/O has more than 3 BDE so the 1st data bde will</span>
<span class="cm">			 * be a BPL that is filled in here.</span>
<span class="cm">			 */</span>
			<span class="n">physaddr</span> <span class="o">=</span> <span class="n">lpfc_cmd</span><span class="o">-&gt;</span><span class="n">dma_handle</span><span class="p">;</span>
			<span class="n">data_bde</span><span class="o">-&gt;</span><span class="n">tus</span><span class="p">.</span><span class="n">f</span><span class="p">.</span><span class="n">bdeFlags</span> <span class="o">=</span> <span class="n">BUFF_TYPE_BLP_64</span><span class="p">;</span>
			<span class="n">data_bde</span><span class="o">-&gt;</span><span class="n">tus</span><span class="p">.</span><span class="n">f</span><span class="p">.</span><span class="n">bdeSize</span> <span class="o">=</span> <span class="p">(</span><span class="n">num_bde</span> <span class="o">*</span>
						   <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ulp_bde64</span><span class="p">));</span>
			<span class="n">physaddr</span> <span class="o">+=</span> <span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">fcp_cmnd</span><span class="p">)</span> <span class="o">+</span>
				     <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">fcp_rsp</span><span class="p">)</span> <span class="o">+</span>
				     <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ulp_bde64</span><span class="p">)));</span>
			<span class="n">data_bde</span><span class="o">-&gt;</span><span class="n">addrHigh</span> <span class="o">=</span> <span class="n">putPaddrHigh</span><span class="p">(</span><span class="n">physaddr</span><span class="p">);</span>
			<span class="n">data_bde</span><span class="o">-&gt;</span><span class="n">addrLow</span> <span class="o">=</span> <span class="n">putPaddrLow</span><span class="p">(</span><span class="n">physaddr</span><span class="p">);</span>
			<span class="cm">/* ebde count includes the response bde and data bpl */</span>
			<span class="n">iocb_cmd</span><span class="o">-&gt;</span><span class="n">unsli3</span><span class="p">.</span><span class="n">fcp_ext</span><span class="p">.</span><span class="n">ebde_count</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/* ebde count includes the response bde and data bdes */</span>
			<span class="n">iocb_cmd</span><span class="o">-&gt;</span><span class="n">unsli3</span><span class="p">.</span><span class="n">fcp_ext</span><span class="p">.</span><span class="n">ebde_count</span> <span class="o">=</span> <span class="p">(</span><span class="n">num_bde</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">iocb_cmd</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">fcpi64</span><span class="p">.</span><span class="n">bdl</span><span class="p">.</span><span class="n">bdeSize</span> <span class="o">=</span>
			<span class="p">((</span><span class="n">num_bde</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ulp_bde64</span><span class="p">));</span>
		<span class="n">iocb_cmd</span><span class="o">-&gt;</span><span class="n">unsli3</span><span class="p">.</span><span class="n">fcp_ext</span><span class="p">.</span><span class="n">ebde_count</span> <span class="o">=</span> <span class="p">(</span><span class="n">num_bde</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">fcp_cmnd</span><span class="o">-&gt;</span><span class="n">fcpDl</span> <span class="o">=</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">scsi_bufflen</span><span class="p">(</span><span class="n">scsi_cmnd</span><span class="p">));</span>

	<span class="cm">/*</span>
<span class="cm">	 * Due to difference in data length between DIF/non-DIF paths,</span>
<span class="cm">	 * we need to set word 4 of IOCB here</span>
<span class="cm">	 */</span>
	<span class="n">iocb_cmd</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">fcpi</span><span class="p">.</span><span class="n">fcpi_parm</span> <span class="o">=</span> <span class="n">scsi_bufflen</span><span class="p">(</span><span class="n">scsi_cmnd</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span>
<span class="nf">lpfc_cmd_blksize</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="n">sc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">sc</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">sector_size</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_SCSI_LPFC_DEBUG_FS</span>

<span class="cm">/* Return if if error injection is detected by Initiator */</span>
<span class="cp">#define BG_ERR_INIT	0x1</span>
<span class="cm">/* Return if if error injection is detected by Target */</span>
<span class="cp">#define BG_ERR_TGT	0x2</span>
<span class="cm">/* Return if if swapping CSUM&lt;--&gt;CRC is required for error injection */</span>
<span class="cp">#define BG_ERR_SWAP	0x10</span>
<span class="cm">/* Return if disabling Guard/Ref/App checking is required for error injection */</span>
<span class="cp">#define BG_ERR_CHECK	0x20</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_bg_err_inject - Determine if we should inject an error</span>
<span class="cm"> * @phba: The Hba for which this call is being executed.</span>
<span class="cm"> * @sc: The SCSI command to examine</span>
<span class="cm"> * @reftag: (out) BlockGuard reference tag for transmitted data</span>
<span class="cm"> * @apptag: (out) BlockGuard application tag for transmitted data</span>
<span class="cm"> * @new_guard (in) Value to replace CRC with if needed</span>
<span class="cm"> *</span>
<span class="cm"> * Returns BG_ERR_* bit mask or 0 if request ignored</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">lpfc_bg_err_inject</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">,</span> <span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="n">sc</span><span class="p">,</span>
		<span class="kt">uint32_t</span> <span class="o">*</span><span class="n">reftag</span><span class="p">,</span> <span class="kt">uint16_t</span> <span class="o">*</span><span class="n">apptag</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">new_guard</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">scatterlist</span> <span class="o">*</span><span class="n">sgpe</span><span class="p">;</span> <span class="cm">/* s/g prot entry */</span>
	<span class="k">struct</span> <span class="n">scatterlist</span> <span class="o">*</span><span class="n">sgde</span><span class="p">;</span> <span class="cm">/* s/g data entry */</span>
	<span class="k">struct</span> <span class="n">lpfc_scsi_buf</span> <span class="o">*</span><span class="n">lpfc_cmd</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">scsi_dif_tuple</span> <span class="o">*</span><span class="n">src</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_nodelist</span> <span class="o">*</span><span class="n">ndlp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_rport_data</span> <span class="o">*</span><span class="n">rdata</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">op</span> <span class="o">=</span> <span class="n">scsi_get_prot_op</span><span class="p">(</span><span class="n">sc</span><span class="p">);</span>
	<span class="kt">uint32_t</span> <span class="n">blksize</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">numblks</span><span class="p">;</span>
	<span class="n">sector_t</span> <span class="n">lba</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">blockoff</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">op</span> <span class="o">==</span> <span class="n">SCSI_PROT_NORMAL</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">sgpe</span> <span class="o">=</span> <span class="n">scsi_prot_sglist</span><span class="p">(</span><span class="n">sc</span><span class="p">);</span>
	<span class="n">sgde</span> <span class="o">=</span> <span class="n">scsi_sglist</span><span class="p">(</span><span class="n">sc</span><span class="p">);</span>
	<span class="n">lba</span> <span class="o">=</span> <span class="n">scsi_get_lba</span><span class="p">(</span><span class="n">sc</span><span class="p">);</span>

	<span class="cm">/* First check if we need to match the LBA */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">lpfc_injerr_lba</span> <span class="o">!=</span> <span class="n">LPFC_INJERR_LBA_OFF</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">blksize</span> <span class="o">=</span> <span class="n">lpfc_cmd_blksize</span><span class="p">(</span><span class="n">sc</span><span class="p">);</span>
		<span class="n">numblks</span> <span class="o">=</span> <span class="p">(</span><span class="n">scsi_bufflen</span><span class="p">(</span><span class="n">sc</span><span class="p">)</span> <span class="o">+</span> <span class="n">blksize</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">blksize</span><span class="p">;</span>

		<span class="cm">/* Make sure we have the right LBA if one is specified */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">lpfc_injerr_lba</span> <span class="o">&lt;</span> <span class="n">lba</span><span class="p">)</span> <span class="o">||</span>
			<span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">lpfc_injerr_lba</span> <span class="o">&gt;=</span> <span class="p">(</span><span class="n">lba</span> <span class="o">+</span> <span class="n">numblks</span><span class="p">)))</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sgpe</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">blockoff</span> <span class="o">=</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">lpfc_injerr_lba</span> <span class="o">-</span> <span class="n">lba</span><span class="p">;</span>
			<span class="n">numblks</span> <span class="o">=</span> <span class="n">sg_dma_len</span><span class="p">(</span><span class="n">sgpe</span><span class="p">)</span> <span class="o">/</span>
				<span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_dif_tuple</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">numblks</span> <span class="o">&lt;</span> <span class="n">blockoff</span><span class="p">)</span>
				<span class="n">blockoff</span> <span class="o">=</span> <span class="n">numblks</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* Next check if we need to match the remote NPortID or WWPN */</span>
	<span class="n">rdata</span> <span class="o">=</span> <span class="n">sc</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">hostdata</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rdata</span> <span class="o">&amp;&amp;</span> <span class="n">rdata</span><span class="o">-&gt;</span><span class="n">pnode</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ndlp</span> <span class="o">=</span> <span class="n">rdata</span><span class="o">-&gt;</span><span class="n">pnode</span><span class="p">;</span>

		<span class="cm">/* Make sure we have the right NPortID if one is specified */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">lpfc_injerr_nportid</span>  <span class="o">&amp;&amp;</span>
			<span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">lpfc_injerr_nportid</span> <span class="o">!=</span> <span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_DID</span><span class="p">))</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * Make sure we have the right WWPN if one is specified.</span>
<span class="cm">		 * wwn[0] should be a non-zero NAA in a good WWPN.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">lpfc_injerr_wwpn</span><span class="p">.</span><span class="n">u</span><span class="p">.</span><span class="n">wwn</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>  <span class="o">&amp;&amp;</span>
			<span class="p">(</span><span class="n">memcmp</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_portname</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">lpfc_injerr_wwpn</span><span class="p">,</span>
				<span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_name</span><span class="p">))</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">))</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Setup a ptr to the protection data if the SCSI host provides it */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sgpe</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">src</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">scsi_dif_tuple</span> <span class="o">*</span><span class="p">)</span><span class="n">sg_virt</span><span class="p">(</span><span class="n">sgpe</span><span class="p">);</span>
		<span class="n">src</span> <span class="o">+=</span> <span class="n">blockoff</span><span class="p">;</span>
		<span class="n">lpfc_cmd</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_scsi_buf</span> <span class="o">*</span><span class="p">)</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">host_scribble</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Should we change the Reference Tag */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">reftag</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">lpfc_injerr_wref_cnt</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">switch</span> <span class="p">(</span><span class="n">op</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">case</span> <span class="n">SCSI_PROT_WRITE_PASS</span>:
				<span class="k">if</span> <span class="p">(</span><span class="n">src</span><span class="p">)</span> <span class="p">{</span>
					<span class="cm">/*</span>
<span class="cm">					 * For WRITE_PASS, force the error</span>
<span class="cm">					 * to be sent on the wire. It should</span>
<span class="cm">					 * be detected by the Target.</span>
<span class="cm">					 * If blockoff != 0 error will be</span>
<span class="cm">					 * inserted in middle of the IO.</span>
<span class="cm">					 */</span>

					<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_BG</span><span class="p">,</span>
					<span class="s">&quot;9076 BLKGRD: Injecting reftag error: &quot;</span>
					<span class="s">&quot;write lba x%lx + x%x oldrefTag x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">lba</span><span class="p">,</span> <span class="n">blockoff</span><span class="p">,</span>
					<span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">src</span><span class="o">-&gt;</span><span class="n">ref_tag</span><span class="p">));</span>

					<span class="cm">/*</span>
<span class="cm">					 * Save the old ref_tag so we can</span>
<span class="cm">					 * restore it on completion.</span>
<span class="cm">					 */</span>
					<span class="k">if</span> <span class="p">(</span><span class="n">lpfc_cmd</span><span class="p">)</span> <span class="p">{</span>
						<span class="n">lpfc_cmd</span><span class="o">-&gt;</span><span class="n">prot_data_type</span> <span class="o">=</span>
							<span class="n">LPFC_INJERR_REFTAG</span><span class="p">;</span>
						<span class="n">lpfc_cmd</span><span class="o">-&gt;</span><span class="n">prot_data_segment</span> <span class="o">=</span>
							<span class="n">src</span><span class="p">;</span>
						<span class="n">lpfc_cmd</span><span class="o">-&gt;</span><span class="n">prot_data</span> <span class="o">=</span>
							<span class="n">src</span><span class="o">-&gt;</span><span class="n">ref_tag</span><span class="p">;</span>
					<span class="p">}</span>
					<span class="n">src</span><span class="o">-&gt;</span><span class="n">ref_tag</span> <span class="o">=</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="mh">0xDEADBEEF</span><span class="p">);</span>
					<span class="n">phba</span><span class="o">-&gt;</span><span class="n">lpfc_injerr_wref_cnt</span><span class="o">--</span><span class="p">;</span>
					<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">lpfc_injerr_wref_cnt</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
						<span class="n">phba</span><span class="o">-&gt;</span><span class="n">lpfc_injerr_nportid</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
						<span class="n">phba</span><span class="o">-&gt;</span><span class="n">lpfc_injerr_lba</span> <span class="o">=</span>
							<span class="n">LPFC_INJERR_LBA_OFF</span><span class="p">;</span>
						<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">lpfc_injerr_wwpn</span><span class="p">,</span>
						  <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_name</span><span class="p">));</span>
					<span class="p">}</span>
					<span class="n">rc</span> <span class="o">=</span> <span class="n">BG_ERR_TGT</span> <span class="o">|</span> <span class="n">BG_ERR_CHECK</span><span class="p">;</span>

					<span class="k">break</span><span class="p">;</span>
				<span class="p">}</span>
				<span class="cm">/* Drop thru */</span>
			<span class="k">case</span> <span class="n">SCSI_PROT_WRITE_INSERT</span>:
				<span class="cm">/*</span>
<span class="cm">				 * For WRITE_INSERT, force the error</span>
<span class="cm">				 * to be sent on the wire. It should be</span>
<span class="cm">				 * detected by the Target.</span>
<span class="cm">				 */</span>
				<span class="cm">/* DEADBEEF will be the reftag on the wire */</span>
				<span class="o">*</span><span class="n">reftag</span> <span class="o">=</span> <span class="mh">0xDEADBEEF</span><span class="p">;</span>
				<span class="n">phba</span><span class="o">-&gt;</span><span class="n">lpfc_injerr_wref_cnt</span><span class="o">--</span><span class="p">;</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">lpfc_injerr_wref_cnt</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">phba</span><span class="o">-&gt;</span><span class="n">lpfc_injerr_nportid</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
					<span class="n">phba</span><span class="o">-&gt;</span><span class="n">lpfc_injerr_lba</span> <span class="o">=</span>
					<span class="n">LPFC_INJERR_LBA_OFF</span><span class="p">;</span>
					<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">lpfc_injerr_wwpn</span><span class="p">,</span>
						<span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_name</span><span class="p">));</span>
				<span class="p">}</span>
				<span class="n">rc</span> <span class="o">=</span> <span class="n">BG_ERR_TGT</span> <span class="o">|</span> <span class="n">BG_ERR_CHECK</span><span class="p">;</span>

				<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_BG</span><span class="p">,</span>
					<span class="s">&quot;9078 BLKGRD: Injecting reftag error: &quot;</span>
					<span class="s">&quot;write lba x%lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">lba</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="k">case</span> <span class="n">SCSI_PROT_WRITE_STRIP</span>:
				<span class="cm">/*</span>
<span class="cm">				 * For WRITE_STRIP and WRITE_PASS,</span>
<span class="cm">				 * force the error on data</span>
<span class="cm">				 * being copied from SLI-Host to SLI-Port.</span>
<span class="cm">				 */</span>
				<span class="o">*</span><span class="n">reftag</span> <span class="o">=</span> <span class="mh">0xDEADBEEF</span><span class="p">;</span>
				<span class="n">phba</span><span class="o">-&gt;</span><span class="n">lpfc_injerr_wref_cnt</span><span class="o">--</span><span class="p">;</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">lpfc_injerr_wref_cnt</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">phba</span><span class="o">-&gt;</span><span class="n">lpfc_injerr_nportid</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
					<span class="n">phba</span><span class="o">-&gt;</span><span class="n">lpfc_injerr_lba</span> <span class="o">=</span>
						<span class="n">LPFC_INJERR_LBA_OFF</span><span class="p">;</span>
					<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">lpfc_injerr_wwpn</span><span class="p">,</span>
						<span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_name</span><span class="p">));</span>
				<span class="p">}</span>
				<span class="n">rc</span> <span class="o">=</span> <span class="n">BG_ERR_INIT</span><span class="p">;</span>

				<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_BG</span><span class="p">,</span>
					<span class="s">&quot;9077 BLKGRD: Injecting reftag error: &quot;</span>
					<span class="s">&quot;write lba x%lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">lba</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">lpfc_injerr_rref_cnt</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">switch</span> <span class="p">(</span><span class="n">op</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">case</span> <span class="n">SCSI_PROT_READ_INSERT</span>:
			<span class="k">case</span> <span class="n">SCSI_PROT_READ_STRIP</span>:
			<span class="k">case</span> <span class="n">SCSI_PROT_READ_PASS</span>:
				<span class="cm">/*</span>
<span class="cm">				 * For READ_STRIP and READ_PASS, force the</span>
<span class="cm">				 * error on data being read off the wire. It</span>
<span class="cm">				 * should force an IO error to the driver.</span>
<span class="cm">				 */</span>
				<span class="o">*</span><span class="n">reftag</span> <span class="o">=</span> <span class="mh">0xDEADBEEF</span><span class="p">;</span>
				<span class="n">phba</span><span class="o">-&gt;</span><span class="n">lpfc_injerr_rref_cnt</span><span class="o">--</span><span class="p">;</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">lpfc_injerr_rref_cnt</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">phba</span><span class="o">-&gt;</span><span class="n">lpfc_injerr_nportid</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
					<span class="n">phba</span><span class="o">-&gt;</span><span class="n">lpfc_injerr_lba</span> <span class="o">=</span>
						<span class="n">LPFC_INJERR_LBA_OFF</span><span class="p">;</span>
					<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">lpfc_injerr_wwpn</span><span class="p">,</span>
						<span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_name</span><span class="p">));</span>
				<span class="p">}</span>
				<span class="n">rc</span> <span class="o">=</span> <span class="n">BG_ERR_INIT</span><span class="p">;</span>

				<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_BG</span><span class="p">,</span>
					<span class="s">&quot;9079 BLKGRD: Injecting reftag error: &quot;</span>
					<span class="s">&quot;read lba x%lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">lba</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* Should we change the Application Tag */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">apptag</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">lpfc_injerr_wapp_cnt</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">switch</span> <span class="p">(</span><span class="n">op</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">case</span> <span class="n">SCSI_PROT_WRITE_PASS</span>:
				<span class="k">if</span> <span class="p">(</span><span class="n">src</span><span class="p">)</span> <span class="p">{</span>
					<span class="cm">/*</span>
<span class="cm">					 * For WRITE_PASS, force the error</span>
<span class="cm">					 * to be sent on the wire. It should</span>
<span class="cm">					 * be detected by the Target.</span>
<span class="cm">					 * If blockoff != 0 error will be</span>
<span class="cm">					 * inserted in middle of the IO.</span>
<span class="cm">					 */</span>

					<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_BG</span><span class="p">,</span>
					<span class="s">&quot;9080 BLKGRD: Injecting apptag error: &quot;</span>
					<span class="s">&quot;write lba x%lx + x%x oldappTag x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">lba</span><span class="p">,</span> <span class="n">blockoff</span><span class="p">,</span>
					<span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">src</span><span class="o">-&gt;</span><span class="n">app_tag</span><span class="p">));</span>

					<span class="cm">/*</span>
<span class="cm">					 * Save the old app_tag so we can</span>
<span class="cm">					 * restore it on completion.</span>
<span class="cm">					 */</span>
					<span class="k">if</span> <span class="p">(</span><span class="n">lpfc_cmd</span><span class="p">)</span> <span class="p">{</span>
						<span class="n">lpfc_cmd</span><span class="o">-&gt;</span><span class="n">prot_data_type</span> <span class="o">=</span>
							<span class="n">LPFC_INJERR_APPTAG</span><span class="p">;</span>
						<span class="n">lpfc_cmd</span><span class="o">-&gt;</span><span class="n">prot_data_segment</span> <span class="o">=</span>
							<span class="n">src</span><span class="p">;</span>
						<span class="n">lpfc_cmd</span><span class="o">-&gt;</span><span class="n">prot_data</span> <span class="o">=</span>
							<span class="n">src</span><span class="o">-&gt;</span><span class="n">app_tag</span><span class="p">;</span>
					<span class="p">}</span>
					<span class="n">src</span><span class="o">-&gt;</span><span class="n">app_tag</span> <span class="o">=</span> <span class="n">cpu_to_be16</span><span class="p">(</span><span class="mh">0xDEAD</span><span class="p">);</span>
					<span class="n">phba</span><span class="o">-&gt;</span><span class="n">lpfc_injerr_wapp_cnt</span><span class="o">--</span><span class="p">;</span>
					<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">lpfc_injerr_wapp_cnt</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
						<span class="n">phba</span><span class="o">-&gt;</span><span class="n">lpfc_injerr_nportid</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
						<span class="n">phba</span><span class="o">-&gt;</span><span class="n">lpfc_injerr_lba</span> <span class="o">=</span>
							<span class="n">LPFC_INJERR_LBA_OFF</span><span class="p">;</span>
						<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">lpfc_injerr_wwpn</span><span class="p">,</span>
						  <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_name</span><span class="p">));</span>
					<span class="p">}</span>
					<span class="n">rc</span> <span class="o">=</span> <span class="n">BG_ERR_TGT</span> <span class="o">|</span> <span class="n">BG_ERR_CHECK</span><span class="p">;</span>
					<span class="k">break</span><span class="p">;</span>
				<span class="p">}</span>
				<span class="cm">/* Drop thru */</span>
			<span class="k">case</span> <span class="n">SCSI_PROT_WRITE_INSERT</span>:
				<span class="cm">/*</span>
<span class="cm">				 * For WRITE_INSERT, force the</span>
<span class="cm">				 * error to be sent on the wire. It should be</span>
<span class="cm">				 * detected by the Target.</span>
<span class="cm">				 */</span>
				<span class="cm">/* DEAD will be the apptag on the wire */</span>
				<span class="o">*</span><span class="n">apptag</span> <span class="o">=</span> <span class="mh">0xDEAD</span><span class="p">;</span>
				<span class="n">phba</span><span class="o">-&gt;</span><span class="n">lpfc_injerr_wapp_cnt</span><span class="o">--</span><span class="p">;</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">lpfc_injerr_wapp_cnt</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">phba</span><span class="o">-&gt;</span><span class="n">lpfc_injerr_nportid</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
					<span class="n">phba</span><span class="o">-&gt;</span><span class="n">lpfc_injerr_lba</span> <span class="o">=</span>
						<span class="n">LPFC_INJERR_LBA_OFF</span><span class="p">;</span>
					<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">lpfc_injerr_wwpn</span><span class="p">,</span>
						<span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_name</span><span class="p">));</span>
				<span class="p">}</span>
				<span class="n">rc</span> <span class="o">=</span> <span class="n">BG_ERR_TGT</span> <span class="o">|</span> <span class="n">BG_ERR_CHECK</span><span class="p">;</span>

				<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_BG</span><span class="p">,</span>
					<span class="s">&quot;0813 BLKGRD: Injecting apptag error: &quot;</span>
					<span class="s">&quot;write lba x%lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">lba</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="k">case</span> <span class="n">SCSI_PROT_WRITE_STRIP</span>:
				<span class="cm">/*</span>
<span class="cm">				 * For WRITE_STRIP and WRITE_PASS,</span>
<span class="cm">				 * force the error on data</span>
<span class="cm">				 * being copied from SLI-Host to SLI-Port.</span>
<span class="cm">				 */</span>
				<span class="o">*</span><span class="n">apptag</span> <span class="o">=</span> <span class="mh">0xDEAD</span><span class="p">;</span>
				<span class="n">phba</span><span class="o">-&gt;</span><span class="n">lpfc_injerr_wapp_cnt</span><span class="o">--</span><span class="p">;</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">lpfc_injerr_wapp_cnt</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">phba</span><span class="o">-&gt;</span><span class="n">lpfc_injerr_nportid</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
					<span class="n">phba</span><span class="o">-&gt;</span><span class="n">lpfc_injerr_lba</span> <span class="o">=</span>
						<span class="n">LPFC_INJERR_LBA_OFF</span><span class="p">;</span>
					<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">lpfc_injerr_wwpn</span><span class="p">,</span>
						<span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_name</span><span class="p">));</span>
				<span class="p">}</span>
				<span class="n">rc</span> <span class="o">=</span> <span class="n">BG_ERR_INIT</span><span class="p">;</span>

				<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_BG</span><span class="p">,</span>
					<span class="s">&quot;0812 BLKGRD: Injecting apptag error: &quot;</span>
					<span class="s">&quot;write lba x%lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">lba</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">lpfc_injerr_rapp_cnt</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">switch</span> <span class="p">(</span><span class="n">op</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">case</span> <span class="n">SCSI_PROT_READ_INSERT</span>:
			<span class="k">case</span> <span class="n">SCSI_PROT_READ_STRIP</span>:
			<span class="k">case</span> <span class="n">SCSI_PROT_READ_PASS</span>:
				<span class="cm">/*</span>
<span class="cm">				 * For READ_STRIP and READ_PASS, force the</span>
<span class="cm">				 * error on data being read off the wire. It</span>
<span class="cm">				 * should force an IO error to the driver.</span>
<span class="cm">				 */</span>
				<span class="o">*</span><span class="n">apptag</span> <span class="o">=</span> <span class="mh">0xDEAD</span><span class="p">;</span>
				<span class="n">phba</span><span class="o">-&gt;</span><span class="n">lpfc_injerr_rapp_cnt</span><span class="o">--</span><span class="p">;</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">lpfc_injerr_rapp_cnt</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">phba</span><span class="o">-&gt;</span><span class="n">lpfc_injerr_nportid</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
					<span class="n">phba</span><span class="o">-&gt;</span><span class="n">lpfc_injerr_lba</span> <span class="o">=</span>
						<span class="n">LPFC_INJERR_LBA_OFF</span><span class="p">;</span>
					<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">lpfc_injerr_wwpn</span><span class="p">,</span>
						<span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_name</span><span class="p">));</span>
				<span class="p">}</span>
				<span class="n">rc</span> <span class="o">=</span> <span class="n">BG_ERR_INIT</span><span class="p">;</span>

				<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_BG</span><span class="p">,</span>
					<span class="s">&quot;0814 BLKGRD: Injecting apptag error: &quot;</span>
					<span class="s">&quot;read lba x%lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">lba</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>


	<span class="cm">/* Should we change the Guard Tag */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">new_guard</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">lpfc_injerr_wgrd_cnt</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">switch</span> <span class="p">(</span><span class="n">op</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">case</span> <span class="n">SCSI_PROT_WRITE_PASS</span>:
				<span class="n">rc</span> <span class="o">=</span> <span class="n">BG_ERR_CHECK</span><span class="p">;</span>
				<span class="cm">/* Drop thru */</span>

			<span class="k">case</span> <span class="n">SCSI_PROT_WRITE_INSERT</span>:
				<span class="cm">/*</span>
<span class="cm">				 * For WRITE_INSERT, force the</span>
<span class="cm">				 * error to be sent on the wire. It should be</span>
<span class="cm">				 * detected by the Target.</span>
<span class="cm">				 */</span>
				<span class="n">phba</span><span class="o">-&gt;</span><span class="n">lpfc_injerr_wgrd_cnt</span><span class="o">--</span><span class="p">;</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">lpfc_injerr_wgrd_cnt</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">phba</span><span class="o">-&gt;</span><span class="n">lpfc_injerr_nportid</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
					<span class="n">phba</span><span class="o">-&gt;</span><span class="n">lpfc_injerr_lba</span> <span class="o">=</span>
						<span class="n">LPFC_INJERR_LBA_OFF</span><span class="p">;</span>
					<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">lpfc_injerr_wwpn</span><span class="p">,</span>
						<span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_name</span><span class="p">));</span>
				<span class="p">}</span>

				<span class="n">rc</span> <span class="o">|=</span> <span class="n">BG_ERR_TGT</span> <span class="o">|</span> <span class="n">BG_ERR_SWAP</span><span class="p">;</span>
				<span class="cm">/* Signals the caller to swap CRC-&gt;CSUM */</span>

				<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_BG</span><span class="p">,</span>
					<span class="s">&quot;0817 BLKGRD: Injecting guard error: &quot;</span>
					<span class="s">&quot;write lba x%lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">lba</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="k">case</span> <span class="n">SCSI_PROT_WRITE_STRIP</span>:
				<span class="cm">/*</span>
<span class="cm">				 * For WRITE_STRIP and WRITE_PASS,</span>
<span class="cm">				 * force the error on data</span>
<span class="cm">				 * being copied from SLI-Host to SLI-Port.</span>
<span class="cm">				 */</span>
				<span class="n">phba</span><span class="o">-&gt;</span><span class="n">lpfc_injerr_wgrd_cnt</span><span class="o">--</span><span class="p">;</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">lpfc_injerr_wgrd_cnt</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">phba</span><span class="o">-&gt;</span><span class="n">lpfc_injerr_nportid</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
					<span class="n">phba</span><span class="o">-&gt;</span><span class="n">lpfc_injerr_lba</span> <span class="o">=</span>
						<span class="n">LPFC_INJERR_LBA_OFF</span><span class="p">;</span>
					<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">lpfc_injerr_wwpn</span><span class="p">,</span>
						<span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_name</span><span class="p">));</span>
				<span class="p">}</span>

				<span class="n">rc</span> <span class="o">=</span> <span class="n">BG_ERR_INIT</span> <span class="o">|</span> <span class="n">BG_ERR_SWAP</span><span class="p">;</span>
				<span class="cm">/* Signals the caller to swap CRC-&gt;CSUM */</span>

				<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_BG</span><span class="p">,</span>
					<span class="s">&quot;0816 BLKGRD: Injecting guard error: &quot;</span>
					<span class="s">&quot;write lba x%lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">lba</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">lpfc_injerr_rgrd_cnt</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">switch</span> <span class="p">(</span><span class="n">op</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">case</span> <span class="n">SCSI_PROT_READ_INSERT</span>:
			<span class="k">case</span> <span class="n">SCSI_PROT_READ_STRIP</span>:
			<span class="k">case</span> <span class="n">SCSI_PROT_READ_PASS</span>:
				<span class="cm">/*</span>
<span class="cm">				 * For READ_STRIP and READ_PASS, force the</span>
<span class="cm">				 * error on data being read off the wire. It</span>
<span class="cm">				 * should force an IO error to the driver.</span>
<span class="cm">				 */</span>
				<span class="n">phba</span><span class="o">-&gt;</span><span class="n">lpfc_injerr_rgrd_cnt</span><span class="o">--</span><span class="p">;</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">lpfc_injerr_rgrd_cnt</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">phba</span><span class="o">-&gt;</span><span class="n">lpfc_injerr_nportid</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
					<span class="n">phba</span><span class="o">-&gt;</span><span class="n">lpfc_injerr_lba</span> <span class="o">=</span>
						<span class="n">LPFC_INJERR_LBA_OFF</span><span class="p">;</span>
					<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">lpfc_injerr_wwpn</span><span class="p">,</span>
						<span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_name</span><span class="p">));</span>
				<span class="p">}</span>

				<span class="n">rc</span> <span class="o">=</span> <span class="n">BG_ERR_INIT</span> <span class="o">|</span> <span class="n">BG_ERR_SWAP</span><span class="p">;</span>
				<span class="cm">/* Signals the caller to swap CRC-&gt;CSUM */</span>

				<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_BG</span><span class="p">,</span>
					<span class="s">&quot;0818 BLKGRD: Injecting guard error: &quot;</span>
					<span class="s">&quot;read lba x%lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">lba</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_sc_to_bg_opcodes - Determine the BlockGuard opcodes to be used with</span>
<span class="cm"> * the specified SCSI command.</span>
<span class="cm"> * @phba: The Hba for which this call is being executed.</span>
<span class="cm"> * @sc: The SCSI command to examine</span>
<span class="cm"> * @txopt: (out) BlockGuard operation for transmitted data</span>
<span class="cm"> * @rxopt: (out) BlockGuard operation for received data</span>
<span class="cm"> *</span>
<span class="cm"> * Returns: zero on success; non-zero if tx and/or rx op cannot be determined</span>
<span class="cm"> *</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">lpfc_sc_to_bg_opcodes</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">,</span> <span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="n">sc</span><span class="p">,</span>
		<span class="kt">uint8_t</span> <span class="o">*</span><span class="n">txop</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">rxop</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">uint8_t</span> <span class="n">guard_type</span> <span class="o">=</span> <span class="n">scsi_host_get_guard</span><span class="p">(</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">);</span>
	<span class="kt">uint8_t</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">guard_type</span> <span class="o">==</span> <span class="n">SHOST_DIX_GUARD_IP</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">scsi_get_prot_op</span><span class="p">(</span><span class="n">sc</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">SCSI_PROT_READ_INSERT</span>:
		<span class="k">case</span> <span class="n">SCSI_PROT_WRITE_STRIP</span>:
			<span class="o">*</span><span class="n">rxop</span> <span class="o">=</span> <span class="n">BG_OP_IN_NODIF_OUT_CSUM</span><span class="p">;</span>
			<span class="o">*</span><span class="n">txop</span> <span class="o">=</span> <span class="n">BG_OP_IN_CSUM_OUT_NODIF</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">SCSI_PROT_READ_STRIP</span>:
		<span class="k">case</span> <span class="n">SCSI_PROT_WRITE_INSERT</span>:
			<span class="o">*</span><span class="n">rxop</span> <span class="o">=</span> <span class="n">BG_OP_IN_CRC_OUT_NODIF</span><span class="p">;</span>
			<span class="o">*</span><span class="n">txop</span> <span class="o">=</span> <span class="n">BG_OP_IN_NODIF_OUT_CRC</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">SCSI_PROT_READ_PASS</span>:
		<span class="k">case</span> <span class="n">SCSI_PROT_WRITE_PASS</span>:
			<span class="o">*</span><span class="n">rxop</span> <span class="o">=</span> <span class="n">BG_OP_IN_CRC_OUT_CSUM</span><span class="p">;</span>
			<span class="o">*</span><span class="n">txop</span> <span class="o">=</span> <span class="n">BG_OP_IN_CSUM_OUT_CRC</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">SCSI_PROT_NORMAL</span>:
		<span class="nl">default:</span>
			<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_BG</span><span class="p">,</span>
				<span class="s">&quot;9063 BLKGRD: Bad op/guard:%d/IP combination</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">scsi_get_prot_op</span><span class="p">(</span><span class="n">sc</span><span class="p">));</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">scsi_get_prot_op</span><span class="p">(</span><span class="n">sc</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">SCSI_PROT_READ_STRIP</span>:
		<span class="k">case</span> <span class="n">SCSI_PROT_WRITE_INSERT</span>:
			<span class="o">*</span><span class="n">rxop</span> <span class="o">=</span> <span class="n">BG_OP_IN_CRC_OUT_NODIF</span><span class="p">;</span>
			<span class="o">*</span><span class="n">txop</span> <span class="o">=</span> <span class="n">BG_OP_IN_NODIF_OUT_CRC</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">SCSI_PROT_READ_PASS</span>:
		<span class="k">case</span> <span class="n">SCSI_PROT_WRITE_PASS</span>:
			<span class="o">*</span><span class="n">rxop</span> <span class="o">=</span> <span class="n">BG_OP_IN_CRC_OUT_CRC</span><span class="p">;</span>
			<span class="o">*</span><span class="n">txop</span> <span class="o">=</span> <span class="n">BG_OP_IN_CRC_OUT_CRC</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">SCSI_PROT_READ_INSERT</span>:
		<span class="k">case</span> <span class="n">SCSI_PROT_WRITE_STRIP</span>:
			<span class="o">*</span><span class="n">rxop</span> <span class="o">=</span> <span class="n">BG_OP_IN_NODIF_OUT_CRC</span><span class="p">;</span>
			<span class="o">*</span><span class="n">txop</span> <span class="o">=</span> <span class="n">BG_OP_IN_CRC_OUT_NODIF</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">SCSI_PROT_NORMAL</span>:
		<span class="nl">default:</span>
			<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_BG</span><span class="p">,</span>
				<span class="s">&quot;9075 BLKGRD: Bad op/guard:%d/CRC combination</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">scsi_get_prot_op</span><span class="p">(</span><span class="n">sc</span><span class="p">));</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_SCSI_LPFC_DEBUG_FS</span>
<span class="cm">/**</span>
<span class="cm"> * lpfc_bg_err_opcodes - reDetermine the BlockGuard opcodes to be used with</span>
<span class="cm"> * the specified SCSI command in order to force a guard tag error.</span>
<span class="cm"> * @phba: The Hba for which this call is being executed.</span>
<span class="cm"> * @sc: The SCSI command to examine</span>
<span class="cm"> * @txopt: (out) BlockGuard operation for transmitted data</span>
<span class="cm"> * @rxopt: (out) BlockGuard operation for received data</span>
<span class="cm"> *</span>
<span class="cm"> * Returns: zero on success; non-zero if tx and/or rx op cannot be determined</span>
<span class="cm"> *</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">lpfc_bg_err_opcodes</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">,</span> <span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="n">sc</span><span class="p">,</span>
		<span class="kt">uint8_t</span> <span class="o">*</span><span class="n">txop</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">rxop</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">uint8_t</span> <span class="n">guard_type</span> <span class="o">=</span> <span class="n">scsi_host_get_guard</span><span class="p">(</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">);</span>
	<span class="kt">uint8_t</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">guard_type</span> <span class="o">==</span> <span class="n">SHOST_DIX_GUARD_IP</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">scsi_get_prot_op</span><span class="p">(</span><span class="n">sc</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">SCSI_PROT_READ_INSERT</span>:
		<span class="k">case</span> <span class="n">SCSI_PROT_WRITE_STRIP</span>:
			<span class="o">*</span><span class="n">rxop</span> <span class="o">=</span> <span class="n">BG_OP_IN_NODIF_OUT_CRC</span><span class="p">;</span>
			<span class="o">*</span><span class="n">txop</span> <span class="o">=</span> <span class="n">BG_OP_IN_CRC_OUT_NODIF</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">SCSI_PROT_READ_STRIP</span>:
		<span class="k">case</span> <span class="n">SCSI_PROT_WRITE_INSERT</span>:
			<span class="o">*</span><span class="n">rxop</span> <span class="o">=</span> <span class="n">BG_OP_IN_CSUM_OUT_NODIF</span><span class="p">;</span>
			<span class="o">*</span><span class="n">txop</span> <span class="o">=</span> <span class="n">BG_OP_IN_NODIF_OUT_CSUM</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">SCSI_PROT_READ_PASS</span>:
		<span class="k">case</span> <span class="n">SCSI_PROT_WRITE_PASS</span>:
			<span class="o">*</span><span class="n">rxop</span> <span class="o">=</span> <span class="n">BG_OP_IN_CSUM_OUT_CRC</span><span class="p">;</span>
			<span class="o">*</span><span class="n">txop</span> <span class="o">=</span> <span class="n">BG_OP_IN_CRC_OUT_CSUM</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">SCSI_PROT_NORMAL</span>:
		<span class="nl">default:</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">scsi_get_prot_op</span><span class="p">(</span><span class="n">sc</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">SCSI_PROT_READ_STRIP</span>:
		<span class="k">case</span> <span class="n">SCSI_PROT_WRITE_INSERT</span>:
			<span class="o">*</span><span class="n">rxop</span> <span class="o">=</span> <span class="n">BG_OP_IN_CSUM_OUT_NODIF</span><span class="p">;</span>
			<span class="o">*</span><span class="n">txop</span> <span class="o">=</span> <span class="n">BG_OP_IN_NODIF_OUT_CSUM</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">SCSI_PROT_READ_PASS</span>:
		<span class="k">case</span> <span class="n">SCSI_PROT_WRITE_PASS</span>:
			<span class="o">*</span><span class="n">rxop</span> <span class="o">=</span> <span class="n">BG_OP_IN_CSUM_OUT_CSUM</span><span class="p">;</span>
			<span class="o">*</span><span class="n">txop</span> <span class="o">=</span> <span class="n">BG_OP_IN_CSUM_OUT_CSUM</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">SCSI_PROT_READ_INSERT</span>:
		<span class="k">case</span> <span class="n">SCSI_PROT_WRITE_STRIP</span>:
			<span class="o">*</span><span class="n">rxop</span> <span class="o">=</span> <span class="n">BG_OP_IN_NODIF_OUT_CSUM</span><span class="p">;</span>
			<span class="o">*</span><span class="n">txop</span> <span class="o">=</span> <span class="n">BG_OP_IN_CSUM_OUT_NODIF</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">SCSI_PROT_NORMAL</span>:
		<span class="nl">default:</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_bg_setup_bpl - Setup BlockGuard BPL with no protection data</span>
<span class="cm"> * @phba: The Hba for which this call is being executed.</span>
<span class="cm"> * @sc: pointer to scsi command we&#39;re working on</span>
<span class="cm"> * @bpl: pointer to buffer list for protection groups</span>
<span class="cm"> * @datacnt: number of segments of data that have been dma mapped</span>
<span class="cm"> *</span>
<span class="cm"> * This function sets up BPL buffer list for protection groups of</span>
<span class="cm"> * type LPFC_PG_TYPE_NO_DIF</span>
<span class="cm"> *</span>
<span class="cm"> * This is usually used when the HBA is instructed to generate</span>
<span class="cm"> * DIFs and insert them into data stream (or strip DIF from</span>
<span class="cm"> * incoming data stream)</span>
<span class="cm"> *</span>
<span class="cm"> * The buffer list consists of just one protection group described</span>
<span class="cm"> * below:</span>
<span class="cm"> *                                +-------------------------+</span>
<span class="cm"> *   start of prot group  --&gt;     |          PDE_5          |</span>
<span class="cm"> *                                +-------------------------+</span>
<span class="cm"> *                                |          PDE_6          |</span>
<span class="cm"> *                                +-------------------------+</span>
<span class="cm"> *                                |         Data BDE        |</span>
<span class="cm"> *                                +-------------------------+</span>
<span class="cm"> *                                |more Data BDE&#39;s ... (opt)|</span>
<span class="cm"> *                                +-------------------------+</span>
<span class="cm"> *</span>
<span class="cm"> *</span>
<span class="cm"> * Note: Data s/g buffers have been dma mapped</span>
<span class="cm"> *</span>
<span class="cm"> * Returns the number of BDEs added to the BPL.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">lpfc_bg_setup_bpl</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">,</span> <span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="n">sc</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">ulp_bde64</span> <span class="o">*</span><span class="n">bpl</span><span class="p">,</span> <span class="kt">int</span> <span class="n">datasegcnt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">scatterlist</span> <span class="o">*</span><span class="n">sgde</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span> <span class="cm">/* s/g data entry */</span>
	<span class="k">struct</span> <span class="n">lpfc_pde5</span> <span class="o">*</span><span class="n">pde5</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_pde6</span> <span class="o">*</span><span class="n">pde6</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">dma_addr_t</span> <span class="n">physaddr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">num_bde</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">status</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">datadir</span> <span class="o">=</span> <span class="n">sc</span><span class="o">-&gt;</span><span class="n">sc_data_direction</span><span class="p">;</span>
<span class="cp">#ifdef CONFIG_SCSI_LPFC_DEBUG_FS</span>
	<span class="kt">uint32_t</span> <span class="n">rc</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="kt">uint32_t</span> <span class="n">checking</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">reftag</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">blksize</span><span class="p">;</span>
	<span class="kt">uint8_t</span> <span class="n">txop</span><span class="p">,</span> <span class="n">rxop</span><span class="p">;</span>

	<span class="n">status</span>  <span class="o">=</span> <span class="n">lpfc_sc_to_bg_opcodes</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">sc</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">txop</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rxop</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="cm">/* extract some info from the scsi command for pde*/</span>
	<span class="n">blksize</span> <span class="o">=</span> <span class="n">lpfc_cmd_blksize</span><span class="p">(</span><span class="n">sc</span><span class="p">);</span>
	<span class="n">reftag</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint32_t</span><span class="p">)</span><span class="n">scsi_get_lba</span><span class="p">(</span><span class="n">sc</span><span class="p">);</span> <span class="cm">/* Truncate LBA */</span>

<span class="cp">#ifdef CONFIG_SCSI_LPFC_DEBUG_FS</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">lpfc_bg_err_inject</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">sc</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">reftag</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">&amp;</span> <span class="n">BG_ERR_SWAP</span><span class="p">)</span>
			<span class="n">lpfc_bg_err_opcodes</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">sc</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">txop</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rxop</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">&amp;</span> <span class="n">BG_ERR_CHECK</span><span class="p">)</span>
			<span class="n">checking</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
<span class="cp">#endif</span>

	<span class="cm">/* setup PDE5 with what we have */</span>
	<span class="n">pde5</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_pde5</span> <span class="o">*</span><span class="p">)</span> <span class="n">bpl</span><span class="p">;</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">pde5</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_pde5</span><span class="p">));</span>
	<span class="n">bf_set</span><span class="p">(</span><span class="n">pde5_type</span><span class="p">,</span> <span class="n">pde5</span><span class="p">,</span> <span class="n">LPFC_PDE5_DESCRIPTOR</span><span class="p">);</span>

	<span class="cm">/* Endianness conversion if necessary for PDE5 */</span>
	<span class="n">pde5</span><span class="o">-&gt;</span><span class="n">word0</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">pde5</span><span class="o">-&gt;</span><span class="n">word0</span><span class="p">);</span>
	<span class="n">pde5</span><span class="o">-&gt;</span><span class="n">reftag</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">reftag</span><span class="p">);</span>

	<span class="cm">/* advance bpl and increment bde count */</span>
	<span class="n">num_bde</span><span class="o">++</span><span class="p">;</span>
	<span class="n">bpl</span><span class="o">++</span><span class="p">;</span>
	<span class="n">pde6</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_pde6</span> <span class="o">*</span><span class="p">)</span> <span class="n">bpl</span><span class="p">;</span>

	<span class="cm">/* setup PDE6 with the rest of the info */</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">pde6</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_pde6</span><span class="p">));</span>
	<span class="n">bf_set</span><span class="p">(</span><span class="n">pde6_type</span><span class="p">,</span> <span class="n">pde6</span><span class="p">,</span> <span class="n">LPFC_PDE6_DESCRIPTOR</span><span class="p">);</span>
	<span class="n">bf_set</span><span class="p">(</span><span class="n">pde6_optx</span><span class="p">,</span> <span class="n">pde6</span><span class="p">,</span> <span class="n">txop</span><span class="p">);</span>
	<span class="n">bf_set</span><span class="p">(</span><span class="n">pde6_oprx</span><span class="p">,</span> <span class="n">pde6</span><span class="p">,</span> <span class="n">rxop</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">datadir</span> <span class="o">==</span> <span class="n">DMA_FROM_DEVICE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">bf_set</span><span class="p">(</span><span class="n">pde6_ce</span><span class="p">,</span> <span class="n">pde6</span><span class="p">,</span> <span class="n">checking</span><span class="p">);</span>
		<span class="n">bf_set</span><span class="p">(</span><span class="n">pde6_re</span><span class="p">,</span> <span class="n">pde6</span><span class="p">,</span> <span class="n">checking</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">bf_set</span><span class="p">(</span><span class="n">pde6_ai</span><span class="p">,</span> <span class="n">pde6</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">bf_set</span><span class="p">(</span><span class="n">pde6_ae</span><span class="p">,</span> <span class="n">pde6</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">bf_set</span><span class="p">(</span><span class="n">pde6_apptagval</span><span class="p">,</span> <span class="n">pde6</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="cm">/* Endianness conversion if necessary for PDE6 */</span>
	<span class="n">pde6</span><span class="o">-&gt;</span><span class="n">word0</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">pde6</span><span class="o">-&gt;</span><span class="n">word0</span><span class="p">);</span>
	<span class="n">pde6</span><span class="o">-&gt;</span><span class="n">word1</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">pde6</span><span class="o">-&gt;</span><span class="n">word1</span><span class="p">);</span>
	<span class="n">pde6</span><span class="o">-&gt;</span><span class="n">word2</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">pde6</span><span class="o">-&gt;</span><span class="n">word2</span><span class="p">);</span>

	<span class="cm">/* advance bpl and increment bde count */</span>
	<span class="n">num_bde</span><span class="o">++</span><span class="p">;</span>
	<span class="n">bpl</span><span class="o">++</span><span class="p">;</span>

	<span class="cm">/* assumption: caller has already run dma_map_sg on command data */</span>
	<span class="n">scsi_for_each_sg</span><span class="p">(</span><span class="n">sc</span><span class="p">,</span> <span class="n">sgde</span><span class="p">,</span> <span class="n">datasegcnt</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">physaddr</span> <span class="o">=</span> <span class="n">sg_dma_address</span><span class="p">(</span><span class="n">sgde</span><span class="p">);</span>
		<span class="n">bpl</span><span class="o">-&gt;</span><span class="n">addrLow</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">putPaddrLow</span><span class="p">(</span><span class="n">physaddr</span><span class="p">));</span>
		<span class="n">bpl</span><span class="o">-&gt;</span><span class="n">addrHigh</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">putPaddrHigh</span><span class="p">(</span><span class="n">physaddr</span><span class="p">));</span>
		<span class="n">bpl</span><span class="o">-&gt;</span><span class="n">tus</span><span class="p">.</span><span class="n">f</span><span class="p">.</span><span class="n">bdeSize</span> <span class="o">=</span> <span class="n">sg_dma_len</span><span class="p">(</span><span class="n">sgde</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">datadir</span> <span class="o">==</span> <span class="n">DMA_TO_DEVICE</span><span class="p">)</span>
			<span class="n">bpl</span><span class="o">-&gt;</span><span class="n">tus</span><span class="p">.</span><span class="n">f</span><span class="p">.</span><span class="n">bdeFlags</span> <span class="o">=</span> <span class="n">BUFF_TYPE_BDE_64</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">bpl</span><span class="o">-&gt;</span><span class="n">tus</span><span class="p">.</span><span class="n">f</span><span class="p">.</span><span class="n">bdeFlags</span> <span class="o">=</span> <span class="n">BUFF_TYPE_BDE_64I</span><span class="p">;</span>
		<span class="n">bpl</span><span class="o">-&gt;</span><span class="n">tus</span><span class="p">.</span><span class="n">w</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">bpl</span><span class="o">-&gt;</span><span class="n">tus</span><span class="p">.</span><span class="n">w</span><span class="p">);</span>
		<span class="n">bpl</span><span class="o">++</span><span class="p">;</span>
		<span class="n">num_bde</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>

<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">num_bde</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_bg_setup_bpl_prot - Setup BlockGuard BPL with protection data</span>
<span class="cm"> * @phba: The Hba for which this call is being executed.</span>
<span class="cm"> * @sc: pointer to scsi command we&#39;re working on</span>
<span class="cm"> * @bpl: pointer to buffer list for protection groups</span>
<span class="cm"> * @datacnt: number of segments of data that have been dma mapped</span>
<span class="cm"> * @protcnt: number of segment of protection data that have been dma mapped</span>
<span class="cm"> *</span>
<span class="cm"> * This function sets up BPL buffer list for protection groups of</span>
<span class="cm"> * type LPFC_PG_TYPE_DIF</span>
<span class="cm"> *</span>
<span class="cm"> * This is usually used when DIFs are in their own buffers,</span>
<span class="cm"> * separate from the data. The HBA can then by instructed</span>
<span class="cm"> * to place the DIFs in the outgoing stream.  For read operations,</span>
<span class="cm"> * The HBA could extract the DIFs and place it in DIF buffers.</span>
<span class="cm"> *</span>
<span class="cm"> * The buffer list for this type consists of one or more of the</span>
<span class="cm"> * protection groups described below:</span>
<span class="cm"> *                                    +-------------------------+</span>
<span class="cm"> *   start of first prot group  --&gt;   |          PDE_5          |</span>
<span class="cm"> *                                    +-------------------------+</span>
<span class="cm"> *                                    |          PDE_6          |</span>
<span class="cm"> *                                    +-------------------------+</span>
<span class="cm"> *                                    |      PDE_7 (Prot BDE)   |</span>
<span class="cm"> *                                    +-------------------------+</span>
<span class="cm"> *                                    |        Data BDE         |</span>
<span class="cm"> *                                    +-------------------------+</span>
<span class="cm"> *                                    |more Data BDE&#39;s ... (opt)|</span>
<span class="cm"> *                                    +-------------------------+</span>
<span class="cm"> *   start of new  prot group  --&gt;    |          PDE_5          |</span>
<span class="cm"> *                                    +-------------------------+</span>
<span class="cm"> *                                    |          ...            |</span>
<span class="cm"> *                                    +-------------------------+</span>
<span class="cm"> *</span>
<span class="cm"> * Note: It is assumed that both data and protection s/g buffers have been</span>
<span class="cm"> *       mapped for DMA</span>
<span class="cm"> *</span>
<span class="cm"> * Returns the number of BDEs added to the BPL.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">lpfc_bg_setup_bpl_prot</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">,</span> <span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="n">sc</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">ulp_bde64</span> <span class="o">*</span><span class="n">bpl</span><span class="p">,</span> <span class="kt">int</span> <span class="n">datacnt</span><span class="p">,</span> <span class="kt">int</span> <span class="n">protcnt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">scatterlist</span> <span class="o">*</span><span class="n">sgde</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span> <span class="cm">/* s/g data entry */</span>
	<span class="k">struct</span> <span class="n">scatterlist</span> <span class="o">*</span><span class="n">sgpe</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span> <span class="cm">/* s/g prot entry */</span>
	<span class="k">struct</span> <span class="n">lpfc_pde5</span> <span class="o">*</span><span class="n">pde5</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_pde6</span> <span class="o">*</span><span class="n">pde6</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_pde7</span> <span class="o">*</span><span class="n">pde7</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">dma_addr_t</span> <span class="n">dataphysaddr</span><span class="p">,</span> <span class="n">protphysaddr</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">curr_data</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">curr_prot</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">split_offset</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">protgroup_len</span><span class="p">,</span> <span class="n">protgroup_offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">protgroup_remainder</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">protgrp_blks</span><span class="p">,</span> <span class="n">protgrp_bytes</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">remainder</span><span class="p">,</span> <span class="n">subtotal</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">status</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">datadir</span> <span class="o">=</span> <span class="n">sc</span><span class="o">-&gt;</span><span class="n">sc_data_direction</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">pgdone</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">alldone</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">blksize</span><span class="p">;</span>
<span class="cp">#ifdef CONFIG_SCSI_LPFC_DEBUG_FS</span>
	<span class="kt">uint32_t</span> <span class="n">rc</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="kt">uint32_t</span> <span class="n">checking</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">reftag</span><span class="p">;</span>
	<span class="kt">uint8_t</span> <span class="n">txop</span><span class="p">,</span> <span class="n">rxop</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">num_bde</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">sgpe</span> <span class="o">=</span> <span class="n">scsi_prot_sglist</span><span class="p">(</span><span class="n">sc</span><span class="p">);</span>
	<span class="n">sgde</span> <span class="o">=</span> <span class="n">scsi_sglist</span><span class="p">(</span><span class="n">sc</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sgpe</span> <span class="o">||</span> <span class="o">!</span><span class="n">sgde</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_FCP</span><span class="p">,</span>
				<span class="s">&quot;9020 Invalid s/g entry: data=0x%p prot=0x%p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">sgpe</span><span class="p">,</span> <span class="n">sgde</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">status</span> <span class="o">=</span> <span class="n">lpfc_sc_to_bg_opcodes</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">sc</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">txop</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rxop</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="cm">/* extract some info from the scsi command */</span>
	<span class="n">blksize</span> <span class="o">=</span> <span class="n">lpfc_cmd_blksize</span><span class="p">(</span><span class="n">sc</span><span class="p">);</span>
	<span class="n">reftag</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint32_t</span><span class="p">)</span><span class="n">scsi_get_lba</span><span class="p">(</span><span class="n">sc</span><span class="p">);</span> <span class="cm">/* Truncate LBA */</span>

<span class="cp">#ifdef CONFIG_SCSI_LPFC_DEBUG_FS</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">lpfc_bg_err_inject</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">sc</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">reftag</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">&amp;</span> <span class="n">BG_ERR_SWAP</span><span class="p">)</span>
			<span class="n">lpfc_bg_err_opcodes</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">sc</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">txop</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rxop</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">&amp;</span> <span class="n">BG_ERR_CHECK</span><span class="p">)</span>
			<span class="n">checking</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
<span class="cp">#endif</span>

	<span class="n">split_offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="cm">/* setup PDE5 with what we have */</span>
		<span class="n">pde5</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_pde5</span> <span class="o">*</span><span class="p">)</span> <span class="n">bpl</span><span class="p">;</span>
		<span class="n">memset</span><span class="p">(</span><span class="n">pde5</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_pde5</span><span class="p">));</span>
		<span class="n">bf_set</span><span class="p">(</span><span class="n">pde5_type</span><span class="p">,</span> <span class="n">pde5</span><span class="p">,</span> <span class="n">LPFC_PDE5_DESCRIPTOR</span><span class="p">);</span>

		<span class="cm">/* Endianness conversion if necessary for PDE5 */</span>
		<span class="n">pde5</span><span class="o">-&gt;</span><span class="n">word0</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">pde5</span><span class="o">-&gt;</span><span class="n">word0</span><span class="p">);</span>
		<span class="n">pde5</span><span class="o">-&gt;</span><span class="n">reftag</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">reftag</span><span class="p">);</span>

		<span class="cm">/* advance bpl and increment bde count */</span>
		<span class="n">num_bde</span><span class="o">++</span><span class="p">;</span>
		<span class="n">bpl</span><span class="o">++</span><span class="p">;</span>
		<span class="n">pde6</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_pde6</span> <span class="o">*</span><span class="p">)</span> <span class="n">bpl</span><span class="p">;</span>

		<span class="cm">/* setup PDE6 with the rest of the info */</span>
		<span class="n">memset</span><span class="p">(</span><span class="n">pde6</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_pde6</span><span class="p">));</span>
		<span class="n">bf_set</span><span class="p">(</span><span class="n">pde6_type</span><span class="p">,</span> <span class="n">pde6</span><span class="p">,</span> <span class="n">LPFC_PDE6_DESCRIPTOR</span><span class="p">);</span>
		<span class="n">bf_set</span><span class="p">(</span><span class="n">pde6_optx</span><span class="p">,</span> <span class="n">pde6</span><span class="p">,</span> <span class="n">txop</span><span class="p">);</span>
		<span class="n">bf_set</span><span class="p">(</span><span class="n">pde6_oprx</span><span class="p">,</span> <span class="n">pde6</span><span class="p">,</span> <span class="n">rxop</span><span class="p">);</span>
		<span class="n">bf_set</span><span class="p">(</span><span class="n">pde6_ce</span><span class="p">,</span> <span class="n">pde6</span><span class="p">,</span> <span class="n">checking</span><span class="p">);</span>
		<span class="n">bf_set</span><span class="p">(</span><span class="n">pde6_re</span><span class="p">,</span> <span class="n">pde6</span><span class="p">,</span> <span class="n">checking</span><span class="p">);</span>
		<span class="n">bf_set</span><span class="p">(</span><span class="n">pde6_ai</span><span class="p">,</span> <span class="n">pde6</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">bf_set</span><span class="p">(</span><span class="n">pde6_ae</span><span class="p">,</span> <span class="n">pde6</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">bf_set</span><span class="p">(</span><span class="n">pde6_apptagval</span><span class="p">,</span> <span class="n">pde6</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

		<span class="cm">/* Endianness conversion if necessary for PDE6 */</span>
		<span class="n">pde6</span><span class="o">-&gt;</span><span class="n">word0</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">pde6</span><span class="o">-&gt;</span><span class="n">word0</span><span class="p">);</span>
		<span class="n">pde6</span><span class="o">-&gt;</span><span class="n">word1</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">pde6</span><span class="o">-&gt;</span><span class="n">word1</span><span class="p">);</span>
		<span class="n">pde6</span><span class="o">-&gt;</span><span class="n">word2</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">pde6</span><span class="o">-&gt;</span><span class="n">word2</span><span class="p">);</span>

		<span class="cm">/* advance bpl and increment bde count */</span>
		<span class="n">num_bde</span><span class="o">++</span><span class="p">;</span>
		<span class="n">bpl</span><span class="o">++</span><span class="p">;</span>

		<span class="cm">/* setup the first BDE that points to protection buffer */</span>
		<span class="n">protphysaddr</span> <span class="o">=</span> <span class="n">sg_dma_address</span><span class="p">(</span><span class="n">sgpe</span><span class="p">)</span> <span class="o">+</span> <span class="n">protgroup_offset</span><span class="p">;</span>
		<span class="n">protgroup_len</span> <span class="o">=</span> <span class="n">sg_dma_len</span><span class="p">(</span><span class="n">sgpe</span><span class="p">)</span> <span class="o">-</span> <span class="n">protgroup_offset</span><span class="p">;</span>

		<span class="cm">/* must be integer multiple of the DIF block length */</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">protgroup_len</span> <span class="o">%</span> <span class="mi">8</span><span class="p">);</span>

		<span class="n">pde7</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_pde7</span> <span class="o">*</span><span class="p">)</span> <span class="n">bpl</span><span class="p">;</span>
		<span class="n">memset</span><span class="p">(</span><span class="n">pde7</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_pde7</span><span class="p">));</span>
		<span class="n">bf_set</span><span class="p">(</span><span class="n">pde7_type</span><span class="p">,</span> <span class="n">pde7</span><span class="p">,</span> <span class="n">LPFC_PDE7_DESCRIPTOR</span><span class="p">);</span>

		<span class="n">pde7</span><span class="o">-&gt;</span><span class="n">addrHigh</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">putPaddrHigh</span><span class="p">(</span><span class="n">protphysaddr</span><span class="p">));</span>
		<span class="n">pde7</span><span class="o">-&gt;</span><span class="n">addrLow</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">putPaddrLow</span><span class="p">(</span><span class="n">protphysaddr</span><span class="p">));</span>

		<span class="n">protgrp_blks</span> <span class="o">=</span> <span class="n">protgroup_len</span> <span class="o">/</span> <span class="mi">8</span><span class="p">;</span>
		<span class="n">protgrp_bytes</span> <span class="o">=</span> <span class="n">protgrp_blks</span> <span class="o">*</span> <span class="n">blksize</span><span class="p">;</span>

		<span class="cm">/* check if this pde is crossing the 4K boundary; if so split */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">pde7</span><span class="o">-&gt;</span><span class="n">addrLow</span> <span class="o">&amp;</span> <span class="mh">0xfff</span><span class="p">)</span> <span class="o">+</span> <span class="n">protgroup_len</span> <span class="o">&gt;</span> <span class="mh">0x1000</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">protgroup_remainder</span> <span class="o">=</span> <span class="mh">0x1000</span> <span class="o">-</span> <span class="p">(</span><span class="n">pde7</span><span class="o">-&gt;</span><span class="n">addrLow</span> <span class="o">&amp;</span> <span class="mh">0xfff</span><span class="p">);</span>
			<span class="n">protgroup_offset</span> <span class="o">+=</span> <span class="n">protgroup_remainder</span><span class="p">;</span>
			<span class="n">protgrp_blks</span> <span class="o">=</span> <span class="n">protgroup_remainder</span> <span class="o">/</span> <span class="mi">8</span><span class="p">;</span>
			<span class="n">protgrp_bytes</span> <span class="o">=</span> <span class="n">protgrp_blks</span> <span class="o">*</span> <span class="n">blksize</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">protgroup_offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">curr_prot</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">num_bde</span><span class="o">++</span><span class="p">;</span>

		<span class="cm">/* setup BDE&#39;s for data blocks associated with DIF data */</span>
		<span class="n">pgdone</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">subtotal</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="cm">/* total bytes processed for current prot grp */</span>
		<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">pgdone</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sgde</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_BG</span><span class="p">,</span>
					<span class="s">&quot;9065 BLKGRD:%s Invalid data segment</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
						<span class="n">__func__</span><span class="p">);</span>
				<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">bpl</span><span class="o">++</span><span class="p">;</span>
			<span class="n">dataphysaddr</span> <span class="o">=</span> <span class="n">sg_dma_address</span><span class="p">(</span><span class="n">sgde</span><span class="p">)</span> <span class="o">+</span> <span class="n">split_offset</span><span class="p">;</span>
			<span class="n">bpl</span><span class="o">-&gt;</span><span class="n">addrLow</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">putPaddrLow</span><span class="p">(</span><span class="n">dataphysaddr</span><span class="p">));</span>
			<span class="n">bpl</span><span class="o">-&gt;</span><span class="n">addrHigh</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">putPaddrHigh</span><span class="p">(</span><span class="n">dataphysaddr</span><span class="p">));</span>

			<span class="n">remainder</span> <span class="o">=</span> <span class="n">sg_dma_len</span><span class="p">(</span><span class="n">sgde</span><span class="p">)</span> <span class="o">-</span> <span class="n">split_offset</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">((</span><span class="n">subtotal</span> <span class="o">+</span> <span class="n">remainder</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">protgrp_bytes</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/* we can use this whole buffer */</span>
				<span class="n">bpl</span><span class="o">-&gt;</span><span class="n">tus</span><span class="p">.</span><span class="n">f</span><span class="p">.</span><span class="n">bdeSize</span> <span class="o">=</span> <span class="n">remainder</span><span class="p">;</span>
				<span class="n">split_offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

				<span class="k">if</span> <span class="p">((</span><span class="n">subtotal</span> <span class="o">+</span> <span class="n">remainder</span><span class="p">)</span> <span class="o">==</span> <span class="n">protgrp_bytes</span><span class="p">)</span>
					<span class="n">pgdone</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="cm">/* must split this buffer with next prot grp */</span>
				<span class="n">bpl</span><span class="o">-&gt;</span><span class="n">tus</span><span class="p">.</span><span class="n">f</span><span class="p">.</span><span class="n">bdeSize</span> <span class="o">=</span> <span class="n">protgrp_bytes</span> <span class="o">-</span> <span class="n">subtotal</span><span class="p">;</span>
				<span class="n">split_offset</span> <span class="o">+=</span> <span class="n">bpl</span><span class="o">-&gt;</span><span class="n">tus</span><span class="p">.</span><span class="n">f</span><span class="p">.</span><span class="n">bdeSize</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="n">subtotal</span> <span class="o">+=</span> <span class="n">bpl</span><span class="o">-&gt;</span><span class="n">tus</span><span class="p">.</span><span class="n">f</span><span class="p">.</span><span class="n">bdeSize</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">datadir</span> <span class="o">==</span> <span class="n">DMA_TO_DEVICE</span><span class="p">)</span>
				<span class="n">bpl</span><span class="o">-&gt;</span><span class="n">tus</span><span class="p">.</span><span class="n">f</span><span class="p">.</span><span class="n">bdeFlags</span> <span class="o">=</span> <span class="n">BUFF_TYPE_BDE_64</span><span class="p">;</span>
			<span class="k">else</span>
				<span class="n">bpl</span><span class="o">-&gt;</span><span class="n">tus</span><span class="p">.</span><span class="n">f</span><span class="p">.</span><span class="n">bdeFlags</span> <span class="o">=</span> <span class="n">BUFF_TYPE_BDE_64I</span><span class="p">;</span>
			<span class="n">bpl</span><span class="o">-&gt;</span><span class="n">tus</span><span class="p">.</span><span class="n">w</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">bpl</span><span class="o">-&gt;</span><span class="n">tus</span><span class="p">.</span><span class="n">w</span><span class="p">);</span>

			<span class="n">num_bde</span><span class="o">++</span><span class="p">;</span>
			<span class="n">curr_data</span><span class="o">++</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">split_offset</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>

			<span class="cm">/* Move to the next s/g segment if possible */</span>
			<span class="n">sgde</span> <span class="o">=</span> <span class="n">sg_next</span><span class="p">(</span><span class="n">sgde</span><span class="p">);</span>

		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">protgroup_offset</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* update the reference tag */</span>
			<span class="n">reftag</span> <span class="o">+=</span> <span class="n">protgrp_blks</span><span class="p">;</span>
			<span class="n">bpl</span><span class="o">++</span><span class="p">;</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* are we done ? */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">curr_prot</span> <span class="o">==</span> <span class="n">protcnt</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">alldone</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">curr_prot</span> <span class="o">&lt;</span> <span class="n">protcnt</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* advance to next prot buffer */</span>
			<span class="n">sgpe</span> <span class="o">=</span> <span class="n">sg_next</span><span class="p">(</span><span class="n">sgpe</span><span class="p">);</span>
			<span class="n">bpl</span><span class="o">++</span><span class="p">;</span>

			<span class="cm">/* update the reference tag */</span>
			<span class="n">reftag</span> <span class="o">+=</span> <span class="n">protgrp_blks</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/* if we&#39;re here, we have a bug */</span>
			<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_BG</span><span class="p">,</span>
				<span class="s">&quot;9054 BLKGRD: bug in %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
		<span class="p">}</span>

	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">alldone</span><span class="p">);</span>
<span class="nl">out:</span>

	<span class="k">return</span> <span class="n">num_bde</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_bg_setup_sgl - Setup BlockGuard SGL with no protection data</span>
<span class="cm"> * @phba: The Hba for which this call is being executed.</span>
<span class="cm"> * @sc: pointer to scsi command we&#39;re working on</span>
<span class="cm"> * @sgl: pointer to buffer list for protection groups</span>
<span class="cm"> * @datacnt: number of segments of data that have been dma mapped</span>
<span class="cm"> *</span>
<span class="cm"> * This function sets up SGL buffer list for protection groups of</span>
<span class="cm"> * type LPFC_PG_TYPE_NO_DIF</span>
<span class="cm"> *</span>
<span class="cm"> * This is usually used when the HBA is instructed to generate</span>
<span class="cm"> * DIFs and insert them into data stream (or strip DIF from</span>
<span class="cm"> * incoming data stream)</span>
<span class="cm"> *</span>
<span class="cm"> * The buffer list consists of just one protection group described</span>
<span class="cm"> * below:</span>
<span class="cm"> *                                +-------------------------+</span>
<span class="cm"> *   start of prot group  --&gt;     |         DI_SEED         |</span>
<span class="cm"> *                                +-------------------------+</span>
<span class="cm"> *                                |         Data SGE        |</span>
<span class="cm"> *                                +-------------------------+</span>
<span class="cm"> *                                |more Data SGE&#39;s ... (opt)|</span>
<span class="cm"> *                                +-------------------------+</span>
<span class="cm"> *</span>
<span class="cm"> *</span>
<span class="cm"> * Note: Data s/g buffers have been dma mapped</span>
<span class="cm"> *</span>
<span class="cm"> * Returns the number of SGEs added to the SGL.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">lpfc_bg_setup_sgl</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">,</span> <span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="n">sc</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">sli4_sge</span> <span class="o">*</span><span class="n">sgl</span><span class="p">,</span> <span class="kt">int</span> <span class="n">datasegcnt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">scatterlist</span> <span class="o">*</span><span class="n">sgde</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span> <span class="cm">/* s/g data entry */</span>
	<span class="k">struct</span> <span class="n">sli4_sge_diseed</span> <span class="o">*</span><span class="n">diseed</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">dma_addr_t</span> <span class="n">physaddr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">num_sge</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">status</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">datadir</span> <span class="o">=</span> <span class="n">sc</span><span class="o">-&gt;</span><span class="n">sc_data_direction</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">reftag</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">blksize</span><span class="p">;</span>
	<span class="kt">uint8_t</span> <span class="n">txop</span><span class="p">,</span> <span class="n">rxop</span><span class="p">;</span>
<span class="cp">#ifdef CONFIG_SCSI_LPFC_DEBUG_FS</span>
	<span class="kt">uint32_t</span> <span class="n">rc</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="kt">uint32_t</span> <span class="n">checking</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">dma_len</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">dma_offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">status</span>  <span class="o">=</span> <span class="n">lpfc_sc_to_bg_opcodes</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">sc</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">txop</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rxop</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="cm">/* extract some info from the scsi command for pde*/</span>
	<span class="n">blksize</span> <span class="o">=</span> <span class="n">lpfc_cmd_blksize</span><span class="p">(</span><span class="n">sc</span><span class="p">);</span>
	<span class="n">reftag</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint32_t</span><span class="p">)</span><span class="n">scsi_get_lba</span><span class="p">(</span><span class="n">sc</span><span class="p">);</span> <span class="cm">/* Truncate LBA */</span>

<span class="cp">#ifdef CONFIG_SCSI_LPFC_DEBUG_FS</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">lpfc_bg_err_inject</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">sc</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">reftag</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">&amp;</span> <span class="n">BG_ERR_SWAP</span><span class="p">)</span>
			<span class="n">lpfc_bg_err_opcodes</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">sc</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">txop</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rxop</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">&amp;</span> <span class="n">BG_ERR_CHECK</span><span class="p">)</span>
			<span class="n">checking</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
<span class="cp">#endif</span>

	<span class="cm">/* setup DISEED with what we have */</span>
	<span class="n">diseed</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sli4_sge_diseed</span> <span class="o">*</span><span class="p">)</span> <span class="n">sgl</span><span class="p">;</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">diseed</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sli4_sge_diseed</span><span class="p">));</span>
	<span class="n">bf_set</span><span class="p">(</span><span class="n">lpfc_sli4_sge_type</span><span class="p">,</span> <span class="n">sgl</span><span class="p">,</span> <span class="n">LPFC_SGE_TYPE_DISEED</span><span class="p">);</span>

	<span class="cm">/* Endianness conversion if necessary */</span>
	<span class="n">diseed</span><span class="o">-&gt;</span><span class="n">ref_tag</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">reftag</span><span class="p">);</span>
	<span class="n">diseed</span><span class="o">-&gt;</span><span class="n">ref_tag_tran</span> <span class="o">=</span> <span class="n">diseed</span><span class="o">-&gt;</span><span class="n">ref_tag</span><span class="p">;</span>

	<span class="cm">/* setup DISEED with the rest of the info */</span>
	<span class="n">bf_set</span><span class="p">(</span><span class="n">lpfc_sli4_sge_dif_optx</span><span class="p">,</span> <span class="n">diseed</span><span class="p">,</span> <span class="n">txop</span><span class="p">);</span>
	<span class="n">bf_set</span><span class="p">(</span><span class="n">lpfc_sli4_sge_dif_oprx</span><span class="p">,</span> <span class="n">diseed</span><span class="p">,</span> <span class="n">rxop</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">datadir</span> <span class="o">==</span> <span class="n">DMA_FROM_DEVICE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">bf_set</span><span class="p">(</span><span class="n">lpfc_sli4_sge_dif_ce</span><span class="p">,</span> <span class="n">diseed</span><span class="p">,</span> <span class="n">checking</span><span class="p">);</span>
		<span class="n">bf_set</span><span class="p">(</span><span class="n">lpfc_sli4_sge_dif_re</span><span class="p">,</span> <span class="n">diseed</span><span class="p">,</span> <span class="n">checking</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">bf_set</span><span class="p">(</span><span class="n">lpfc_sli4_sge_dif_ai</span><span class="p">,</span> <span class="n">diseed</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">bf_set</span><span class="p">(</span><span class="n">lpfc_sli4_sge_dif_me</span><span class="p">,</span> <span class="n">diseed</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="cm">/* Endianness conversion if necessary for DISEED */</span>
	<span class="n">diseed</span><span class="o">-&gt;</span><span class="n">word2</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">diseed</span><span class="o">-&gt;</span><span class="n">word2</span><span class="p">);</span>
	<span class="n">diseed</span><span class="o">-&gt;</span><span class="n">word3</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">diseed</span><span class="o">-&gt;</span><span class="n">word3</span><span class="p">);</span>

	<span class="cm">/* advance bpl and increment sge count */</span>
	<span class="n">num_sge</span><span class="o">++</span><span class="p">;</span>
	<span class="n">sgl</span><span class="o">++</span><span class="p">;</span>

	<span class="cm">/* assumption: caller has already run dma_map_sg on command data */</span>
	<span class="n">scsi_for_each_sg</span><span class="p">(</span><span class="n">sc</span><span class="p">,</span> <span class="n">sgde</span><span class="p">,</span> <span class="n">datasegcnt</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">physaddr</span> <span class="o">=</span> <span class="n">sg_dma_address</span><span class="p">(</span><span class="n">sgde</span><span class="p">);</span>
		<span class="n">dma_len</span> <span class="o">=</span> <span class="n">sg_dma_len</span><span class="p">(</span><span class="n">sgde</span><span class="p">);</span>
		<span class="n">sgl</span><span class="o">-&gt;</span><span class="n">addr_lo</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">putPaddrLow</span><span class="p">(</span><span class="n">physaddr</span><span class="p">));</span>
		<span class="n">sgl</span><span class="o">-&gt;</span><span class="n">addr_hi</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">putPaddrHigh</span><span class="p">(</span><span class="n">physaddr</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="n">datasegcnt</span><span class="p">)</span>
			<span class="n">bf_set</span><span class="p">(</span><span class="n">lpfc_sli4_sge_last</span><span class="p">,</span> <span class="n">sgl</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">bf_set</span><span class="p">(</span><span class="n">lpfc_sli4_sge_last</span><span class="p">,</span> <span class="n">sgl</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">bf_set</span><span class="p">(</span><span class="n">lpfc_sli4_sge_offset</span><span class="p">,</span> <span class="n">sgl</span><span class="p">,</span> <span class="n">dma_offset</span><span class="p">);</span>
		<span class="n">bf_set</span><span class="p">(</span><span class="n">lpfc_sli4_sge_type</span><span class="p">,</span> <span class="n">sgl</span><span class="p">,</span> <span class="n">LPFC_SGE_TYPE_DATA</span><span class="p">);</span>

		<span class="n">sgl</span><span class="o">-&gt;</span><span class="n">sge_len</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">dma_len</span><span class="p">);</span>
		<span class="n">dma_offset</span> <span class="o">+=</span> <span class="n">dma_len</span><span class="p">;</span>

		<span class="n">sgl</span><span class="o">++</span><span class="p">;</span>
		<span class="n">num_sge</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>

<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">num_sge</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_bg_setup_sgl_prot - Setup BlockGuard SGL with protection data</span>
<span class="cm"> * @phba: The Hba for which this call is being executed.</span>
<span class="cm"> * @sc: pointer to scsi command we&#39;re working on</span>
<span class="cm"> * @sgl: pointer to buffer list for protection groups</span>
<span class="cm"> * @datacnt: number of segments of data that have been dma mapped</span>
<span class="cm"> * @protcnt: number of segment of protection data that have been dma mapped</span>
<span class="cm"> *</span>
<span class="cm"> * This function sets up SGL buffer list for protection groups of</span>
<span class="cm"> * type LPFC_PG_TYPE_DIF</span>
<span class="cm"> *</span>
<span class="cm"> * This is usually used when DIFs are in their own buffers,</span>
<span class="cm"> * separate from the data. The HBA can then by instructed</span>
<span class="cm"> * to place the DIFs in the outgoing stream.  For read operations,</span>
<span class="cm"> * The HBA could extract the DIFs and place it in DIF buffers.</span>
<span class="cm"> *</span>
<span class="cm"> * The buffer list for this type consists of one or more of the</span>
<span class="cm"> * protection groups described below:</span>
<span class="cm"> *                                    +-------------------------+</span>
<span class="cm"> *   start of first prot group  --&gt;   |         DISEED          |</span>
<span class="cm"> *                                    +-------------------------+</span>
<span class="cm"> *                                    |      DIF (Prot SGE)     |</span>
<span class="cm"> *                                    +-------------------------+</span>
<span class="cm"> *                                    |        Data SGE         |</span>
<span class="cm"> *                                    +-------------------------+</span>
<span class="cm"> *                                    |more Data SGE&#39;s ... (opt)|</span>
<span class="cm"> *                                    +-------------------------+</span>
<span class="cm"> *   start of new  prot group  --&gt;    |         DISEED          |</span>
<span class="cm"> *                                    +-------------------------+</span>
<span class="cm"> *                                    |          ...            |</span>
<span class="cm"> *                                    +-------------------------+</span>
<span class="cm"> *</span>
<span class="cm"> * Note: It is assumed that both data and protection s/g buffers have been</span>
<span class="cm"> *       mapped for DMA</span>
<span class="cm"> *</span>
<span class="cm"> * Returns the number of SGEs added to the SGL.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">lpfc_bg_setup_sgl_prot</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">,</span> <span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="n">sc</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">sli4_sge</span> <span class="o">*</span><span class="n">sgl</span><span class="p">,</span> <span class="kt">int</span> <span class="n">datacnt</span><span class="p">,</span> <span class="kt">int</span> <span class="n">protcnt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">scatterlist</span> <span class="o">*</span><span class="n">sgde</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span> <span class="cm">/* s/g data entry */</span>
	<span class="k">struct</span> <span class="n">scatterlist</span> <span class="o">*</span><span class="n">sgpe</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span> <span class="cm">/* s/g prot entry */</span>
	<span class="k">struct</span> <span class="n">sli4_sge_diseed</span> <span class="o">*</span><span class="n">diseed</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">dma_addr_t</span> <span class="n">dataphysaddr</span><span class="p">,</span> <span class="n">protphysaddr</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">curr_data</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">curr_prot</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">split_offset</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">protgroup_len</span><span class="p">,</span> <span class="n">protgroup_offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">protgroup_remainder</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">protgrp_blks</span><span class="p">,</span> <span class="n">protgrp_bytes</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">remainder</span><span class="p">,</span> <span class="n">subtotal</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">status</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">pgdone</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">alldone</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">blksize</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">reftag</span><span class="p">;</span>
	<span class="kt">uint8_t</span> <span class="n">txop</span><span class="p">,</span> <span class="n">rxop</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">dma_len</span><span class="p">;</span>
<span class="cp">#ifdef CONFIG_SCSI_LPFC_DEBUG_FS</span>
	<span class="kt">uint32_t</span> <span class="n">rc</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="kt">uint32_t</span> <span class="n">checking</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">dma_offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">num_sge</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">sgpe</span> <span class="o">=</span> <span class="n">scsi_prot_sglist</span><span class="p">(</span><span class="n">sc</span><span class="p">);</span>
	<span class="n">sgde</span> <span class="o">=</span> <span class="n">scsi_sglist</span><span class="p">(</span><span class="n">sc</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sgpe</span> <span class="o">||</span> <span class="o">!</span><span class="n">sgde</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_FCP</span><span class="p">,</span>
				<span class="s">&quot;9082 Invalid s/g entry: data=0x%p prot=0x%p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">sgpe</span><span class="p">,</span> <span class="n">sgde</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">status</span> <span class="o">=</span> <span class="n">lpfc_sc_to_bg_opcodes</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">sc</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">txop</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rxop</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="cm">/* extract some info from the scsi command */</span>
	<span class="n">blksize</span> <span class="o">=</span> <span class="n">lpfc_cmd_blksize</span><span class="p">(</span><span class="n">sc</span><span class="p">);</span>
	<span class="n">reftag</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint32_t</span><span class="p">)</span><span class="n">scsi_get_lba</span><span class="p">(</span><span class="n">sc</span><span class="p">);</span> <span class="cm">/* Truncate LBA */</span>

<span class="cp">#ifdef CONFIG_SCSI_LPFC_DEBUG_FS</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">lpfc_bg_err_inject</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">sc</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">reftag</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">&amp;</span> <span class="n">BG_ERR_SWAP</span><span class="p">)</span>
			<span class="n">lpfc_bg_err_opcodes</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">sc</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">txop</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rxop</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">&amp;</span> <span class="n">BG_ERR_CHECK</span><span class="p">)</span>
			<span class="n">checking</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
<span class="cp">#endif</span>

	<span class="n">split_offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="cm">/* setup DISEED with what we have */</span>
		<span class="n">diseed</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sli4_sge_diseed</span> <span class="o">*</span><span class="p">)</span> <span class="n">sgl</span><span class="p">;</span>
		<span class="n">memset</span><span class="p">(</span><span class="n">diseed</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sli4_sge_diseed</span><span class="p">));</span>
		<span class="n">bf_set</span><span class="p">(</span><span class="n">lpfc_sli4_sge_type</span><span class="p">,</span> <span class="n">sgl</span><span class="p">,</span> <span class="n">LPFC_SGE_TYPE_DISEED</span><span class="p">);</span>

		<span class="cm">/* Endianness conversion if necessary */</span>
		<span class="n">diseed</span><span class="o">-&gt;</span><span class="n">ref_tag</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">reftag</span><span class="p">);</span>
		<span class="n">diseed</span><span class="o">-&gt;</span><span class="n">ref_tag_tran</span> <span class="o">=</span> <span class="n">diseed</span><span class="o">-&gt;</span><span class="n">ref_tag</span><span class="p">;</span>

		<span class="cm">/* setup DISEED with the rest of the info */</span>
		<span class="n">bf_set</span><span class="p">(</span><span class="n">lpfc_sli4_sge_dif_optx</span><span class="p">,</span> <span class="n">diseed</span><span class="p">,</span> <span class="n">txop</span><span class="p">);</span>
		<span class="n">bf_set</span><span class="p">(</span><span class="n">lpfc_sli4_sge_dif_oprx</span><span class="p">,</span> <span class="n">diseed</span><span class="p">,</span> <span class="n">rxop</span><span class="p">);</span>
		<span class="n">bf_set</span><span class="p">(</span><span class="n">lpfc_sli4_sge_dif_ce</span><span class="p">,</span> <span class="n">diseed</span><span class="p">,</span> <span class="n">checking</span><span class="p">);</span>
		<span class="n">bf_set</span><span class="p">(</span><span class="n">lpfc_sli4_sge_dif_re</span><span class="p">,</span> <span class="n">diseed</span><span class="p">,</span> <span class="n">checking</span><span class="p">);</span>
		<span class="n">bf_set</span><span class="p">(</span><span class="n">lpfc_sli4_sge_dif_ai</span><span class="p">,</span> <span class="n">diseed</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">bf_set</span><span class="p">(</span><span class="n">lpfc_sli4_sge_dif_me</span><span class="p">,</span> <span class="n">diseed</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

		<span class="cm">/* Endianness conversion if necessary for DISEED */</span>
		<span class="n">diseed</span><span class="o">-&gt;</span><span class="n">word2</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">diseed</span><span class="o">-&gt;</span><span class="n">word2</span><span class="p">);</span>
		<span class="n">diseed</span><span class="o">-&gt;</span><span class="n">word3</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">diseed</span><span class="o">-&gt;</span><span class="n">word3</span><span class="p">);</span>

		<span class="cm">/* advance sgl and increment bde count */</span>
		<span class="n">num_sge</span><span class="o">++</span><span class="p">;</span>
		<span class="n">sgl</span><span class="o">++</span><span class="p">;</span>

		<span class="cm">/* setup the first BDE that points to protection buffer */</span>
		<span class="n">protphysaddr</span> <span class="o">=</span> <span class="n">sg_dma_address</span><span class="p">(</span><span class="n">sgpe</span><span class="p">)</span> <span class="o">+</span> <span class="n">protgroup_offset</span><span class="p">;</span>
		<span class="n">protgroup_len</span> <span class="o">=</span> <span class="n">sg_dma_len</span><span class="p">(</span><span class="n">sgpe</span><span class="p">)</span> <span class="o">-</span> <span class="n">protgroup_offset</span><span class="p">;</span>

		<span class="cm">/* must be integer multiple of the DIF block length */</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">protgroup_len</span> <span class="o">%</span> <span class="mi">8</span><span class="p">);</span>

		<span class="cm">/* Now setup DIF SGE */</span>
		<span class="n">sgl</span><span class="o">-&gt;</span><span class="n">word2</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">bf_set</span><span class="p">(</span><span class="n">lpfc_sli4_sge_type</span><span class="p">,</span> <span class="n">sgl</span><span class="p">,</span> <span class="n">LPFC_SGE_TYPE_DIF</span><span class="p">);</span>
		<span class="n">sgl</span><span class="o">-&gt;</span><span class="n">addr_hi</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">putPaddrHigh</span><span class="p">(</span><span class="n">protphysaddr</span><span class="p">));</span>
		<span class="n">sgl</span><span class="o">-&gt;</span><span class="n">addr_lo</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">putPaddrLow</span><span class="p">(</span><span class="n">protphysaddr</span><span class="p">));</span>
		<span class="n">sgl</span><span class="o">-&gt;</span><span class="n">word2</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">sgl</span><span class="o">-&gt;</span><span class="n">word2</span><span class="p">);</span>

		<span class="n">protgrp_blks</span> <span class="o">=</span> <span class="n">protgroup_len</span> <span class="o">/</span> <span class="mi">8</span><span class="p">;</span>
		<span class="n">protgrp_bytes</span> <span class="o">=</span> <span class="n">protgrp_blks</span> <span class="o">*</span> <span class="n">blksize</span><span class="p">;</span>

		<span class="cm">/* check if DIF SGE is crossing the 4K boundary; if so split */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">sgl</span><span class="o">-&gt;</span><span class="n">addr_lo</span> <span class="o">&amp;</span> <span class="mh">0xfff</span><span class="p">)</span> <span class="o">+</span> <span class="n">protgroup_len</span> <span class="o">&gt;</span> <span class="mh">0x1000</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">protgroup_remainder</span> <span class="o">=</span> <span class="mh">0x1000</span> <span class="o">-</span> <span class="p">(</span><span class="n">sgl</span><span class="o">-&gt;</span><span class="n">addr_lo</span> <span class="o">&amp;</span> <span class="mh">0xfff</span><span class="p">);</span>
			<span class="n">protgroup_offset</span> <span class="o">+=</span> <span class="n">protgroup_remainder</span><span class="p">;</span>
			<span class="n">protgrp_blks</span> <span class="o">=</span> <span class="n">protgroup_remainder</span> <span class="o">/</span> <span class="mi">8</span><span class="p">;</span>
			<span class="n">protgrp_bytes</span> <span class="o">=</span> <span class="n">protgrp_blks</span> <span class="o">*</span> <span class="n">blksize</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">protgroup_offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">curr_prot</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">num_sge</span><span class="o">++</span><span class="p">;</span>

		<span class="cm">/* setup SGE&#39;s for data blocks associated with DIF data */</span>
		<span class="n">pgdone</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">subtotal</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="cm">/* total bytes processed for current prot grp */</span>
		<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">pgdone</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sgde</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_BG</span><span class="p">,</span>
					<span class="s">&quot;9086 BLKGRD:%s Invalid data segment</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
						<span class="n">__func__</span><span class="p">);</span>
				<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">sgl</span><span class="o">++</span><span class="p">;</span>
			<span class="n">dataphysaddr</span> <span class="o">=</span> <span class="n">sg_dma_address</span><span class="p">(</span><span class="n">sgde</span><span class="p">)</span> <span class="o">+</span> <span class="n">split_offset</span><span class="p">;</span>

			<span class="n">remainder</span> <span class="o">=</span> <span class="n">sg_dma_len</span><span class="p">(</span><span class="n">sgde</span><span class="p">)</span> <span class="o">-</span> <span class="n">split_offset</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">((</span><span class="n">subtotal</span> <span class="o">+</span> <span class="n">remainder</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">protgrp_bytes</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/* we can use this whole buffer */</span>
				<span class="n">dma_len</span> <span class="o">=</span> <span class="n">remainder</span><span class="p">;</span>
				<span class="n">split_offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

				<span class="k">if</span> <span class="p">((</span><span class="n">subtotal</span> <span class="o">+</span> <span class="n">remainder</span><span class="p">)</span> <span class="o">==</span> <span class="n">protgrp_bytes</span><span class="p">)</span>
					<span class="n">pgdone</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="cm">/* must split this buffer with next prot grp */</span>
				<span class="n">dma_len</span> <span class="o">=</span> <span class="n">protgrp_bytes</span> <span class="o">-</span> <span class="n">subtotal</span><span class="p">;</span>
				<span class="n">split_offset</span> <span class="o">+=</span> <span class="n">dma_len</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="n">subtotal</span> <span class="o">+=</span> <span class="n">dma_len</span><span class="p">;</span>

			<span class="n">sgl</span><span class="o">-&gt;</span><span class="n">addr_lo</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">putPaddrLow</span><span class="p">(</span><span class="n">dataphysaddr</span><span class="p">));</span>
			<span class="n">sgl</span><span class="o">-&gt;</span><span class="n">addr_hi</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">putPaddrHigh</span><span class="p">(</span><span class="n">dataphysaddr</span><span class="p">));</span>
			<span class="n">bf_set</span><span class="p">(</span><span class="n">lpfc_sli4_sge_last</span><span class="p">,</span> <span class="n">sgl</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
			<span class="n">bf_set</span><span class="p">(</span><span class="n">lpfc_sli4_sge_offset</span><span class="p">,</span> <span class="n">sgl</span><span class="p">,</span> <span class="n">dma_offset</span><span class="p">);</span>
			<span class="n">bf_set</span><span class="p">(</span><span class="n">lpfc_sli4_sge_type</span><span class="p">,</span> <span class="n">sgl</span><span class="p">,</span> <span class="n">LPFC_SGE_TYPE_DATA</span><span class="p">);</span>

			<span class="n">sgl</span><span class="o">-&gt;</span><span class="n">sge_len</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">dma_len</span><span class="p">);</span>
			<span class="n">dma_offset</span> <span class="o">+=</span> <span class="n">dma_len</span><span class="p">;</span>

			<span class="n">num_sge</span><span class="o">++</span><span class="p">;</span>
			<span class="n">curr_data</span><span class="o">++</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">split_offset</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>

			<span class="cm">/* Move to the next s/g segment if possible */</span>
			<span class="n">sgde</span> <span class="o">=</span> <span class="n">sg_next</span><span class="p">(</span><span class="n">sgde</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">protgroup_offset</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* update the reference tag */</span>
			<span class="n">reftag</span> <span class="o">+=</span> <span class="n">protgrp_blks</span><span class="p">;</span>
			<span class="n">sgl</span><span class="o">++</span><span class="p">;</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* are we done ? */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">curr_prot</span> <span class="o">==</span> <span class="n">protcnt</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">bf_set</span><span class="p">(</span><span class="n">lpfc_sli4_sge_last</span><span class="p">,</span> <span class="n">sgl</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
			<span class="n">alldone</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">curr_prot</span> <span class="o">&lt;</span> <span class="n">protcnt</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* advance to next prot buffer */</span>
			<span class="n">sgpe</span> <span class="o">=</span> <span class="n">sg_next</span><span class="p">(</span><span class="n">sgpe</span><span class="p">);</span>
			<span class="n">sgl</span><span class="o">++</span><span class="p">;</span>

			<span class="cm">/* update the reference tag */</span>
			<span class="n">reftag</span> <span class="o">+=</span> <span class="n">protgrp_blks</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/* if we&#39;re here, we have a bug */</span>
			<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_BG</span><span class="p">,</span>
				<span class="s">&quot;9085 BLKGRD: bug in %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
		<span class="p">}</span>

	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">alldone</span><span class="p">);</span>

<span class="nl">out:</span>

	<span class="k">return</span> <span class="n">num_sge</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_prot_group_type - Get prtotection group type of SCSI command</span>
<span class="cm"> * @phba: The Hba for which this call is being executed.</span>
<span class="cm"> * @sc: pointer to scsi command we&#39;re working on</span>
<span class="cm"> *</span>
<span class="cm"> * Given a SCSI command that supports DIF, determine composition of protection</span>
<span class="cm"> * groups involved in setting up buffer lists</span>
<span class="cm"> *</span>
<span class="cm"> * Returns: Protection group type (with or without DIF)</span>
<span class="cm"> *</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">lpfc_prot_group_type</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">,</span> <span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="n">sc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">LPFC_PG_TYPE_INVALID</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">op</span> <span class="o">=</span> <span class="n">scsi_get_prot_op</span><span class="p">(</span><span class="n">sc</span><span class="p">);</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">op</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">SCSI_PROT_READ_STRIP</span>:
	<span class="k">case</span> <span class="n">SCSI_PROT_WRITE_INSERT</span>:
		<span class="n">ret</span> <span class="o">=</span> <span class="n">LPFC_PG_TYPE_NO_DIF</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SCSI_PROT_READ_INSERT</span>:
	<span class="k">case</span> <span class="n">SCSI_PROT_WRITE_STRIP</span>:
	<span class="k">case</span> <span class="n">SCSI_PROT_READ_PASS</span>:
	<span class="k">case</span> <span class="n">SCSI_PROT_WRITE_PASS</span>:
		<span class="n">ret</span> <span class="o">=</span> <span class="n">LPFC_PG_TYPE_DIF_BUF</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_FCP</span><span class="p">,</span>
				<span class="s">&quot;9021 Unsupported protection op:%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">op</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_bg_scsi_prep_dma_buf_s3 - DMA mapping for scsi buffer to SLI3 IF spec</span>
<span class="cm"> * @phba: The Hba for which this call is being executed.</span>
<span class="cm"> * @lpfc_cmd: The scsi buffer which is going to be prep&#39;ed.</span>
<span class="cm"> *</span>
<span class="cm"> * This is the protection/DIF aware version of</span>
<span class="cm"> * lpfc_scsi_prep_dma_buf(). It may be a good idea to combine the</span>
<span class="cm"> * two functions eventually, but for now, it&#39;s here</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">lpfc_bg_scsi_prep_dma_buf_s3</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">lpfc_scsi_buf</span> <span class="o">*</span><span class="n">lpfc_cmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="n">scsi_cmnd</span> <span class="o">=</span> <span class="n">lpfc_cmd</span><span class="o">-&gt;</span><span class="n">pCmd</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fcp_cmnd</span> <span class="o">*</span><span class="n">fcp_cmnd</span> <span class="o">=</span> <span class="n">lpfc_cmd</span><span class="o">-&gt;</span><span class="n">fcp_cmnd</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ulp_bde64</span> <span class="o">*</span><span class="n">bpl</span> <span class="o">=</span> <span class="n">lpfc_cmd</span><span class="o">-&gt;</span><span class="n">fcp_bpl</span><span class="p">;</span>
	<span class="n">IOCB_t</span> <span class="o">*</span><span class="n">iocb_cmd</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">lpfc_cmd</span><span class="o">-&gt;</span><span class="n">cur_iocbq</span><span class="p">.</span><span class="n">iocb</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">num_bde</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">datasegcnt</span><span class="p">,</span> <span class="n">protsegcnt</span><span class="p">,</span> <span class="n">datadir</span> <span class="o">=</span> <span class="n">scsi_cmnd</span><span class="o">-&gt;</span><span class="n">sc_data_direction</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">prot_group_type</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">diflen</span><span class="p">,</span> <span class="n">fcpdl</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">blksize</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Start the lpfc command prep by bumping the bpl beyond fcp_cmnd</span>
<span class="cm">	 *  fcp_rsp regions to the first data bde entry</span>
<span class="cm">	 */</span>
	<span class="n">bpl</span> <span class="o">+=</span> <span class="mi">2</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">scsi_sg_count</span><span class="p">(</span><span class="n">scsi_cmnd</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * The driver stores the segment count returned from pci_map_sg</span>
<span class="cm">		 * because this a count of dma-mappings used to map the use_sg</span>
<span class="cm">		 * pages.  They are not guaranteed to be the same for those</span>
<span class="cm">		 * architectures that implement an IOMMU.</span>
<span class="cm">		 */</span>
		<span class="n">datasegcnt</span> <span class="o">=</span> <span class="n">dma_map_sg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">pcidev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
					<span class="n">scsi_sglist</span><span class="p">(</span><span class="n">scsi_cmnd</span><span class="p">),</span>
					<span class="n">scsi_sg_count</span><span class="p">(</span><span class="n">scsi_cmnd</span><span class="p">),</span> <span class="n">datadir</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">datasegcnt</span><span class="p">))</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

		<span class="n">lpfc_cmd</span><span class="o">-&gt;</span><span class="n">seg_cnt</span> <span class="o">=</span> <span class="n">datasegcnt</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">lpfc_cmd</span><span class="o">-&gt;</span><span class="n">seg_cnt</span> <span class="o">&gt;</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">cfg_sg_seg_cnt</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_BG</span><span class="p">,</span>
					<span class="s">&quot;9067 BLKGRD: %s: Too many sg segments&quot;</span>
					<span class="s">&quot; from dma_map_sg.  Config %d, seg_cnt&quot;</span>
					<span class="s">&quot; %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">__func__</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">cfg_sg_seg_cnt</span><span class="p">,</span>
					<span class="n">lpfc_cmd</span><span class="o">-&gt;</span><span class="n">seg_cnt</span><span class="p">);</span>
			<span class="n">scsi_dma_unmap</span><span class="p">(</span><span class="n">scsi_cmnd</span><span class="p">);</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">prot_group_type</span> <span class="o">=</span> <span class="n">lpfc_prot_group_type</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">scsi_cmnd</span><span class="p">);</span>

		<span class="k">switch</span> <span class="p">(</span><span class="n">prot_group_type</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">LPFC_PG_TYPE_NO_DIF</span>:
			<span class="n">num_bde</span> <span class="o">=</span> <span class="n">lpfc_bg_setup_bpl</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">scsi_cmnd</span><span class="p">,</span> <span class="n">bpl</span><span class="p">,</span>
					<span class="n">datasegcnt</span><span class="p">);</span>
			<span class="cm">/* we should have 2 or more entries in buffer list */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">num_bde</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">err</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">LPFC_PG_TYPE_DIF_BUF</span>:<span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * This type indicates that protection buffers are</span>
<span class="cm">			 * passed to the driver, so that needs to be prepared</span>
<span class="cm">			 * for DMA</span>
<span class="cm">			 */</span>
			<span class="n">protsegcnt</span> <span class="o">=</span> <span class="n">dma_map_sg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">pcidev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
					<span class="n">scsi_prot_sglist</span><span class="p">(</span><span class="n">scsi_cmnd</span><span class="p">),</span>
					<span class="n">scsi_prot_sg_count</span><span class="p">(</span><span class="n">scsi_cmnd</span><span class="p">),</span> <span class="n">datadir</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">protsegcnt</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">scsi_dma_unmap</span><span class="p">(</span><span class="n">scsi_cmnd</span><span class="p">);</span>
				<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="n">lpfc_cmd</span><span class="o">-&gt;</span><span class="n">prot_seg_cnt</span> <span class="o">=</span> <span class="n">protsegcnt</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">lpfc_cmd</span><span class="o">-&gt;</span><span class="n">prot_seg_cnt</span>
			    <span class="o">&gt;</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">cfg_prot_sg_seg_cnt</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_BG</span><span class="p">,</span>
					<span class="s">&quot;9068 BLKGRD: %s: Too many prot sg &quot;</span>
					<span class="s">&quot;segments from dma_map_sg.  Config %d,&quot;</span>
						<span class="s">&quot;prot_seg_cnt %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span>
						<span class="n">phba</span><span class="o">-&gt;</span><span class="n">cfg_prot_sg_seg_cnt</span><span class="p">,</span>
						<span class="n">lpfc_cmd</span><span class="o">-&gt;</span><span class="n">prot_seg_cnt</span><span class="p">);</span>
				<span class="n">dma_unmap_sg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">pcidev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
					     <span class="n">scsi_prot_sglist</span><span class="p">(</span><span class="n">scsi_cmnd</span><span class="p">),</span>
					     <span class="n">scsi_prot_sg_count</span><span class="p">(</span><span class="n">scsi_cmnd</span><span class="p">),</span>
					     <span class="n">datadir</span><span class="p">);</span>
				<span class="n">scsi_dma_unmap</span><span class="p">(</span><span class="n">scsi_cmnd</span><span class="p">);</span>
				<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="n">num_bde</span> <span class="o">=</span> <span class="n">lpfc_bg_setup_bpl_prot</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">scsi_cmnd</span><span class="p">,</span> <span class="n">bpl</span><span class="p">,</span>
					<span class="n">datasegcnt</span><span class="p">,</span> <span class="n">protsegcnt</span><span class="p">);</span>
			<span class="cm">/* we should have 3 or more entries in buffer list */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">num_bde</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">err</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">case</span> <span class="n">LPFC_PG_TYPE_INVALID</span>:
		<span class="nl">default:</span>
			<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_FCP</span><span class="p">,</span>
					<span class="s">&quot;9022 Unexpected protection group %i</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">prot_group_type</span><span class="p">);</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Finish initializing those IOCB fields that are dependent on the</span>
<span class="cm">	 * scsi_cmnd request_buffer.  Note that the bdeSize is explicitly</span>
<span class="cm">	 * reinitialized since all iocb memory resources are used many times</span>
<span class="cm">	 * for transmit, receive, and continuation bpl&#39;s.</span>
<span class="cm">	 */</span>
	<span class="n">iocb_cmd</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">fcpi64</span><span class="p">.</span><span class="n">bdl</span><span class="p">.</span><span class="n">bdeSize</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ulp_bde64</span><span class="p">));</span>
	<span class="n">iocb_cmd</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">fcpi64</span><span class="p">.</span><span class="n">bdl</span><span class="p">.</span><span class="n">bdeSize</span> <span class="o">+=</span> <span class="p">(</span><span class="n">num_bde</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ulp_bde64</span><span class="p">));</span>
	<span class="n">iocb_cmd</span><span class="o">-&gt;</span><span class="n">ulpBdeCount</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">iocb_cmd</span><span class="o">-&gt;</span><span class="n">ulpLe</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">fcpdl</span> <span class="o">=</span> <span class="n">scsi_bufflen</span><span class="p">(</span><span class="n">scsi_cmnd</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">scsi_get_prot_type</span><span class="p">(</span><span class="n">scsi_cmnd</span><span class="p">)</span> <span class="o">==</span> <span class="n">SCSI_PROT_DIF_TYPE1</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * We are in DIF Type 1 mode</span>
<span class="cm">		 * Every data block has a 8 byte DIF (trailer)</span>
<span class="cm">		 * attached to it.  Must ajust FCP data length</span>
<span class="cm">		 */</span>
		<span class="n">blksize</span> <span class="o">=</span> <span class="n">lpfc_cmd_blksize</span><span class="p">(</span><span class="n">scsi_cmnd</span><span class="p">);</span>
		<span class="n">diflen</span> <span class="o">=</span> <span class="p">(</span><span class="n">fcpdl</span> <span class="o">/</span> <span class="n">blksize</span><span class="p">)</span> <span class="o">*</span> <span class="mi">8</span><span class="p">;</span>
		<span class="n">fcpdl</span> <span class="o">+=</span> <span class="n">diflen</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">fcp_cmnd</span><span class="o">-&gt;</span><span class="n">fcpDl</span> <span class="o">=</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">fcpdl</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Due to difference in data length between DIF/non-DIF paths,</span>
<span class="cm">	 * we need to set word 4 of IOCB here</span>
<span class="cm">	 */</span>
	<span class="n">iocb_cmd</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">fcpi</span><span class="p">.</span><span class="n">fcpi_parm</span> <span class="o">=</span> <span class="n">fcpdl</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">err:</span>
	<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_FCP</span><span class="p">,</span>
			<span class="s">&quot;9023 Could not setup all needed BDE&#39;s&quot;</span>
			<span class="s">&quot;prot_group_type=%d, num_bde=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">prot_group_type</span><span class="p">,</span> <span class="n">num_bde</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * This function checks for BlockGuard errors detected by</span>
<span class="cm"> * the HBA.  In case of errors, the ASC/ASCQ fields in the</span>
<span class="cm"> * sense buffer will be set accordingly, paired with</span>
<span class="cm"> * ILLEGAL_REQUEST to signal to the kernel that the HBA</span>
<span class="cm"> * detected corruption.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns:</span>
<span class="cm"> *  0 - No error found</span>
<span class="cm"> *  1 - BlockGuard error found</span>
<span class="cm"> * -1 - Internal error (bad profile, ...etc)</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">lpfc_parse_bg_err</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">,</span> <span class="k">struct</span> <span class="n">lpfc_scsi_buf</span> <span class="o">*</span><span class="n">lpfc_cmd</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">lpfc_iocbq</span> <span class="o">*</span><span class="n">pIocbOut</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="n">cmd</span> <span class="o">=</span> <span class="n">lpfc_cmd</span><span class="o">-&gt;</span><span class="n">pCmd</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sli3_bg_fields</span> <span class="o">*</span><span class="n">bgf</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">pIocbOut</span><span class="o">-&gt;</span><span class="n">iocb</span><span class="p">.</span><span class="n">unsli3</span><span class="p">.</span><span class="n">sli3_bg</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">bghm</span> <span class="o">=</span> <span class="n">bgf</span><span class="o">-&gt;</span><span class="n">bghm</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">bgstat</span> <span class="o">=</span> <span class="n">bgf</span><span class="o">-&gt;</span><span class="n">bgstat</span><span class="p">;</span>
	<span class="kt">uint64_t</span> <span class="n">failing_sector</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_BG</span><span class="p">,</span> <span class="s">&quot;9069 BLKGRD: BG ERROR in cmd&quot;</span>
			<span class="s">&quot; 0x%x lba 0x%llx blk cnt 0x%x &quot;</span>
			<span class="s">&quot;bgstat=0x%x bghm=0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">scsi_get_lba</span><span class="p">(</span><span class="n">cmd</span><span class="p">),</span>
			<span class="n">blk_rq_sectors</span><span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">request</span><span class="p">),</span> <span class="n">bgstat</span><span class="p">,</span> <span class="n">bghm</span><span class="p">);</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">_dump_buf_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">_dump_buf_done</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_BG</span><span class="p">,</span>  <span class="s">&quot;9070 BLKGRD: Saving&quot;</span>
			<span class="s">&quot; Data for %u blocks to debugfs</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span> <span class="o">|</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">8</span><span class="p">]));</span>
		<span class="n">lpfc_debug_save_data</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">cmd</span><span class="p">);</span>

		<span class="cm">/* If we have a prot sgl, save the DIF buffer */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">lpfc_prot_group_type</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">cmd</span><span class="p">)</span> <span class="o">==</span>
				<span class="n">LPFC_PG_TYPE_DIF_BUF</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_BG</span><span class="p">,</span> <span class="s">&quot;9071 BLKGRD: &quot;</span>
				<span class="s">&quot;Saving DIF for %u blocks to debugfs</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span> <span class="o">|</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">8</span><span class="p">]));</span>
			<span class="n">lpfc_debug_save_dif</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">cmd</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="n">_dump_buf_done</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">_dump_buf_lock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">lpfc_bgs_get_invalid_prof</span><span class="p">(</span><span class="n">bgstat</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">=</span> <span class="n">ScsiResult</span><span class="p">(</span><span class="n">DID_ERROR</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_BG</span><span class="p">,</span> <span class="s">&quot;9072 BLKGRD: Invalid&quot;</span>
			<span class="s">&quot; BlockGuard profile. bgstat:0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">bgstat</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">lpfc_bgs_get_uninit_dif_block</span><span class="p">(</span><span class="n">bgstat</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">=</span> <span class="n">ScsiResult</span><span class="p">(</span><span class="n">DID_ERROR</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_BG</span><span class="p">,</span> <span class="s">&quot;9073 BLKGRD: &quot;</span>
				<span class="s">&quot;Invalid BlockGuard DIF Block. bgstat:0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">bgstat</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">lpfc_bgs_get_guard_err</span><span class="p">(</span><span class="n">bgstat</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

		<span class="n">scsi_build_sense_buffer</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">sense_buffer</span><span class="p">,</span> <span class="n">ILLEGAL_REQUEST</span><span class="p">,</span>
				<span class="mh">0x10</span><span class="p">,</span> <span class="mh">0x1</span><span class="p">);</span>
		<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">=</span> <span class="n">DRIVER_SENSE</span> <span class="o">&lt;&lt;</span> <span class="mi">24</span>
			<span class="o">|</span> <span class="n">ScsiResult</span><span class="p">(</span><span class="n">DID_ABORT</span><span class="p">,</span> <span class="n">SAM_STAT_CHECK_CONDITION</span><span class="p">);</span>
		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">bg_guard_err_cnt</span><span class="o">++</span><span class="p">;</span>
		<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_BG</span><span class="p">,</span>
			<span class="s">&quot;9055 BLKGRD: guard_tag error</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">lpfc_bgs_get_reftag_err</span><span class="p">(</span><span class="n">bgstat</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

		<span class="n">scsi_build_sense_buffer</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">sense_buffer</span><span class="p">,</span> <span class="n">ILLEGAL_REQUEST</span><span class="p">,</span>
				<span class="mh">0x10</span><span class="p">,</span> <span class="mh">0x3</span><span class="p">);</span>
		<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">=</span> <span class="n">DRIVER_SENSE</span> <span class="o">&lt;&lt;</span> <span class="mi">24</span>
			<span class="o">|</span> <span class="n">ScsiResult</span><span class="p">(</span><span class="n">DID_ABORT</span><span class="p">,</span> <span class="n">SAM_STAT_CHECK_CONDITION</span><span class="p">);</span>

		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">bg_reftag_err_cnt</span><span class="o">++</span><span class="p">;</span>
		<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_BG</span><span class="p">,</span>
			<span class="s">&quot;9056 BLKGRD: ref_tag error</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">lpfc_bgs_get_apptag_err</span><span class="p">(</span><span class="n">bgstat</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

		<span class="n">scsi_build_sense_buffer</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">sense_buffer</span><span class="p">,</span> <span class="n">ILLEGAL_REQUEST</span><span class="p">,</span>
				<span class="mh">0x10</span><span class="p">,</span> <span class="mh">0x2</span><span class="p">);</span>
		<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">=</span> <span class="n">DRIVER_SENSE</span> <span class="o">&lt;&lt;</span> <span class="mi">24</span>
			<span class="o">|</span> <span class="n">ScsiResult</span><span class="p">(</span><span class="n">DID_ABORT</span><span class="p">,</span> <span class="n">SAM_STAT_CHECK_CONDITION</span><span class="p">);</span>

		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">bg_apptag_err_cnt</span><span class="o">++</span><span class="p">;</span>
		<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_BG</span><span class="p">,</span>
			<span class="s">&quot;9061 BLKGRD: app_tag error</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">lpfc_bgs_get_hi_water_mark_present</span><span class="p">(</span><span class="n">bgstat</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * setup sense data descriptor 0 per SPC-4 as an information</span>
<span class="cm">		 * field, and put the failing LBA in it.</span>
<span class="cm">		 * This code assumes there was also a guard/app/ref tag error</span>
<span class="cm">		 * indication.</span>
<span class="cm">		 */</span>
		<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">sense_buffer</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0xc</span><span class="p">;</span>   <span class="cm">/* Additional sense length */</span>
		<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">sense_buffer</span><span class="p">[</span><span class="mi">8</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>     <span class="cm">/* Information descriptor type */</span>
		<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">sense_buffer</span><span class="p">[</span><span class="mi">9</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0xa</span><span class="p">;</span>   <span class="cm">/* Additional descriptor length */</span>
		<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">sense_buffer</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x80</span><span class="p">;</span> <span class="cm">/* Validity bit */</span>

		<span class="cm">/* bghm is a &quot;on the wire&quot; FC frame based count */</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">scsi_get_prot_op</span><span class="p">(</span><span class="n">cmd</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">SCSI_PROT_READ_INSERT</span>:
		<span class="k">case</span> <span class="n">SCSI_PROT_WRITE_STRIP</span>:
			<span class="n">bghm</span> <span class="o">/=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">sector_size</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">SCSI_PROT_READ_STRIP</span>:
		<span class="k">case</span> <span class="n">SCSI_PROT_WRITE_INSERT</span>:
		<span class="k">case</span> <span class="n">SCSI_PROT_READ_PASS</span>:
		<span class="k">case</span> <span class="n">SCSI_PROT_WRITE_PASS</span>:
			<span class="n">bghm</span> <span class="o">/=</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">sector_size</span> <span class="o">+</span>
				<span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_dif_tuple</span><span class="p">));</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">failing_sector</span> <span class="o">=</span> <span class="n">scsi_get_lba</span><span class="p">(</span><span class="n">cmd</span><span class="p">);</span>
		<span class="n">failing_sector</span> <span class="o">+=</span> <span class="n">bghm</span><span class="p">;</span>

		<span class="cm">/* Descriptor Information */</span>
		<span class="n">put_unaligned_be64</span><span class="p">(</span><span class="n">failing_sector</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">sense_buffer</span><span class="p">[</span><span class="mi">12</span><span class="p">]);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* No error was reported - problem in FW? */</span>
		<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">=</span> <span class="n">ScsiResult</span><span class="p">(</span><span class="n">DID_ERROR</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_BG</span><span class="p">,</span>
			<span class="s">&quot;9057 BLKGRD: Unknown error reported!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span>

<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_scsi_prep_dma_buf_s4 - DMA mapping for scsi buffer to SLI4 IF spec</span>
<span class="cm"> * @phba: The Hba for which this call is being executed.</span>
<span class="cm"> * @lpfc_cmd: The scsi buffer which is going to be mapped.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine does the pci dma mapping for scatter-gather list of scsi cmnd</span>
<span class="cm"> * field of @lpfc_cmd for device with SLI-4 interface spec.</span>
<span class="cm"> *</span>
<span class="cm"> * Return codes:</span>
<span class="cm"> *	1 - Error</span>
<span class="cm"> *	0 - Success</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">lpfc_scsi_prep_dma_buf_s4</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">,</span> <span class="k">struct</span> <span class="n">lpfc_scsi_buf</span> <span class="o">*</span><span class="n">lpfc_cmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="n">scsi_cmnd</span> <span class="o">=</span> <span class="n">lpfc_cmd</span><span class="o">-&gt;</span><span class="n">pCmd</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">scatterlist</span> <span class="o">*</span><span class="n">sgel</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fcp_cmnd</span> <span class="o">*</span><span class="n">fcp_cmnd</span> <span class="o">=</span> <span class="n">lpfc_cmd</span><span class="o">-&gt;</span><span class="n">fcp_cmnd</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sli4_sge</span> <span class="o">*</span><span class="n">sgl</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sli4_sge</span> <span class="o">*</span><span class="p">)</span><span class="n">lpfc_cmd</span><span class="o">-&gt;</span><span class="n">fcp_bpl</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sli4_sge</span> <span class="o">*</span><span class="n">first_data_sgl</span><span class="p">;</span>
	<span class="n">IOCB_t</span> <span class="o">*</span><span class="n">iocb_cmd</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">lpfc_cmd</span><span class="o">-&gt;</span><span class="n">cur_iocbq</span><span class="p">.</span><span class="n">iocb</span><span class="p">;</span>
	<span class="n">dma_addr_t</span> <span class="n">physaddr</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">num_bde</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">dma_len</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">dma_offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">nseg</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ulp_bde64</span> <span class="o">*</span><span class="n">bde</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * There are three possibilities here - use scatter-gather segment, use</span>
<span class="cm">	 * the single mapping, or neither.  Start the lpfc command prep by</span>
<span class="cm">	 * bumping the bpl beyond the fcp_cmnd and fcp_rsp regions to the first</span>
<span class="cm">	 * data bde entry.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">scsi_sg_count</span><span class="p">(</span><span class="n">scsi_cmnd</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * The driver stores the segment count returned from pci_map_sg</span>
<span class="cm">		 * because this a count of dma-mappings used to map the use_sg</span>
<span class="cm">		 * pages.  They are not guaranteed to be the same for those</span>
<span class="cm">		 * architectures that implement an IOMMU.</span>
<span class="cm">		 */</span>

		<span class="n">nseg</span> <span class="o">=</span> <span class="n">scsi_dma_map</span><span class="p">(</span><span class="n">scsi_cmnd</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">nseg</span><span class="p">))</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">sgl</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="cm">/* clear the last flag in the fcp_rsp map entry */</span>
		<span class="n">sgl</span><span class="o">-&gt;</span><span class="n">word2</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">sgl</span><span class="o">-&gt;</span><span class="n">word2</span><span class="p">);</span>
		<span class="n">bf_set</span><span class="p">(</span><span class="n">lpfc_sli4_sge_last</span><span class="p">,</span> <span class="n">sgl</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">sgl</span><span class="o">-&gt;</span><span class="n">word2</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">sgl</span><span class="o">-&gt;</span><span class="n">word2</span><span class="p">);</span>
		<span class="n">sgl</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">first_data_sgl</span> <span class="o">=</span> <span class="n">sgl</span><span class="p">;</span>
		<span class="n">lpfc_cmd</span><span class="o">-&gt;</span><span class="n">seg_cnt</span> <span class="o">=</span> <span class="n">nseg</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">lpfc_cmd</span><span class="o">-&gt;</span><span class="n">seg_cnt</span> <span class="o">&gt;</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">cfg_sg_seg_cnt</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_BG</span><span class="p">,</span> <span class="s">&quot;9074 BLKGRD:&quot;</span>
				<span class="s">&quot; %s: Too many sg segments from &quot;</span>
				<span class="s">&quot;dma_map_sg.  Config %d, seg_cnt %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">__func__</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">cfg_sg_seg_cnt</span><span class="p">,</span>
			       <span class="n">lpfc_cmd</span><span class="o">-&gt;</span><span class="n">seg_cnt</span><span class="p">);</span>
			<span class="n">scsi_dma_unmap</span><span class="p">(</span><span class="n">scsi_cmnd</span><span class="p">);</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 * The driver established a maximum scatter-gather segment count</span>
<span class="cm">		 * during probe that limits the number of sg elements in any</span>
<span class="cm">		 * single scsi command.  Just run through the seg_cnt and format</span>
<span class="cm">		 * the sge&#39;s.</span>
<span class="cm">		 * When using SLI-3 the driver will try to fit all the BDEs into</span>
<span class="cm">		 * the IOCB. If it can&#39;t then the BDEs get added to a BPL as it</span>
<span class="cm">		 * does for SLI-2 mode.</span>
<span class="cm">		 */</span>
		<span class="n">scsi_for_each_sg</span><span class="p">(</span><span class="n">scsi_cmnd</span><span class="p">,</span> <span class="n">sgel</span><span class="p">,</span> <span class="n">nseg</span><span class="p">,</span> <span class="n">num_bde</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">physaddr</span> <span class="o">=</span> <span class="n">sg_dma_address</span><span class="p">(</span><span class="n">sgel</span><span class="p">);</span>
			<span class="n">dma_len</span> <span class="o">=</span> <span class="n">sg_dma_len</span><span class="p">(</span><span class="n">sgel</span><span class="p">);</span>
			<span class="n">sgl</span><span class="o">-&gt;</span><span class="n">addr_lo</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">putPaddrLow</span><span class="p">(</span><span class="n">physaddr</span><span class="p">));</span>
			<span class="n">sgl</span><span class="o">-&gt;</span><span class="n">addr_hi</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">putPaddrHigh</span><span class="p">(</span><span class="n">physaddr</span><span class="p">));</span>
			<span class="n">sgl</span><span class="o">-&gt;</span><span class="n">word2</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">sgl</span><span class="o">-&gt;</span><span class="n">word2</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">num_bde</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="n">nseg</span><span class="p">)</span>
				<span class="n">bf_set</span><span class="p">(</span><span class="n">lpfc_sli4_sge_last</span><span class="p">,</span> <span class="n">sgl</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
			<span class="k">else</span>
				<span class="n">bf_set</span><span class="p">(</span><span class="n">lpfc_sli4_sge_last</span><span class="p">,</span> <span class="n">sgl</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
			<span class="n">bf_set</span><span class="p">(</span><span class="n">lpfc_sli4_sge_offset</span><span class="p">,</span> <span class="n">sgl</span><span class="p">,</span> <span class="n">dma_offset</span><span class="p">);</span>
			<span class="n">bf_set</span><span class="p">(</span><span class="n">lpfc_sli4_sge_type</span><span class="p">,</span> <span class="n">sgl</span><span class="p">,</span> <span class="n">LPFC_SGE_TYPE_DATA</span><span class="p">);</span>
			<span class="n">sgl</span><span class="o">-&gt;</span><span class="n">word2</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">sgl</span><span class="o">-&gt;</span><span class="n">word2</span><span class="p">);</span>
			<span class="n">sgl</span><span class="o">-&gt;</span><span class="n">sge_len</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">dma_len</span><span class="p">);</span>
			<span class="n">dma_offset</span> <span class="o">+=</span> <span class="n">dma_len</span><span class="p">;</span>
			<span class="n">sgl</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/* setup the performance hint (first data BDE) if enabled */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli3_options</span> <span class="o">&amp;</span> <span class="n">LPFC_SLI4_PERFH_ENABLED</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">bde</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ulp_bde64</span> <span class="o">*</span><span class="p">)</span>
					<span class="o">&amp;</span><span class="p">(</span><span class="n">iocb_cmd</span><span class="o">-&gt;</span><span class="n">unsli3</span><span class="p">.</span><span class="n">sli3Words</span><span class="p">[</span><span class="mi">5</span><span class="p">]);</span>
			<span class="n">bde</span><span class="o">-&gt;</span><span class="n">addrLow</span> <span class="o">=</span> <span class="n">first_data_sgl</span><span class="o">-&gt;</span><span class="n">addr_lo</span><span class="p">;</span>
			<span class="n">bde</span><span class="o">-&gt;</span><span class="n">addrHigh</span> <span class="o">=</span> <span class="n">first_data_sgl</span><span class="o">-&gt;</span><span class="n">addr_hi</span><span class="p">;</span>
			<span class="n">bde</span><span class="o">-&gt;</span><span class="n">tus</span><span class="p">.</span><span class="n">f</span><span class="p">.</span><span class="n">bdeSize</span> <span class="o">=</span>
					<span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">first_data_sgl</span><span class="o">-&gt;</span><span class="n">sge_len</span><span class="p">);</span>
			<span class="n">bde</span><span class="o">-&gt;</span><span class="n">tus</span><span class="p">.</span><span class="n">f</span><span class="p">.</span><span class="n">bdeFlags</span> <span class="o">=</span> <span class="n">BUFF_TYPE_BDE_64</span><span class="p">;</span>
			<span class="n">bde</span><span class="o">-&gt;</span><span class="n">tus</span><span class="p">.</span><span class="n">w</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">bde</span><span class="o">-&gt;</span><span class="n">tus</span><span class="p">.</span><span class="n">w</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">sgl</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="cm">/* clear the last flag in the fcp_rsp map entry */</span>
		<span class="n">sgl</span><span class="o">-&gt;</span><span class="n">word2</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">sgl</span><span class="o">-&gt;</span><span class="n">word2</span><span class="p">);</span>
		<span class="n">bf_set</span><span class="p">(</span><span class="n">lpfc_sli4_sge_last</span><span class="p">,</span> <span class="n">sgl</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">sgl</span><span class="o">-&gt;</span><span class="n">word2</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">sgl</span><span class="o">-&gt;</span><span class="n">word2</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Finish initializing those IOCB fields that are dependent on the</span>
<span class="cm">	 * scsi_cmnd request_buffer.  Note that for SLI-2 the bdeSize is</span>
<span class="cm">	 * explicitly reinitialized.</span>
<span class="cm">	 * all iocb memory resources are reused.</span>
<span class="cm">	 */</span>
	<span class="n">fcp_cmnd</span><span class="o">-&gt;</span><span class="n">fcpDl</span> <span class="o">=</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">scsi_bufflen</span><span class="p">(</span><span class="n">scsi_cmnd</span><span class="p">));</span>

	<span class="cm">/*</span>
<span class="cm">	 * Due to difference in data length between DIF/non-DIF paths,</span>
<span class="cm">	 * we need to set word 4 of IOCB here</span>
<span class="cm">	 */</span>
	<span class="n">iocb_cmd</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">fcpi</span><span class="p">.</span><span class="n">fcpi_parm</span> <span class="o">=</span> <span class="n">scsi_bufflen</span><span class="p">(</span><span class="n">scsi_cmnd</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_bg_scsi_adjust_dl - Adjust SCSI data length for BlockGuard</span>
<span class="cm"> * @phba: The Hba for which this call is being executed.</span>
<span class="cm"> * @lpfc_cmd: The scsi buffer which is going to be adjusted.</span>
<span class="cm"> *</span>
<span class="cm"> * Adjust the data length to account for how much data</span>
<span class="cm"> * is actually on the wire.</span>
<span class="cm"> *</span>
<span class="cm"> * returns the adjusted data length</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">lpfc_bg_scsi_adjust_dl</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">lpfc_scsi_buf</span> <span class="o">*</span><span class="n">lpfc_cmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="n">sc</span> <span class="o">=</span> <span class="n">lpfc_cmd</span><span class="o">-&gt;</span><span class="n">pCmd</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">diflen</span><span class="p">,</span> <span class="n">fcpdl</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">blksize</span><span class="p">;</span>

	<span class="n">fcpdl</span> <span class="o">=</span> <span class="n">scsi_bufflen</span><span class="p">(</span><span class="n">sc</span><span class="p">);</span>

	<span class="cm">/* Check if there is protection data on the wire */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sc</span><span class="o">-&gt;</span><span class="n">sc_data_direction</span> <span class="o">==</span> <span class="n">DMA_FROM_DEVICE</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Read */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">scsi_get_prot_op</span><span class="p">(</span><span class="n">sc</span><span class="p">)</span> <span class="o">==</span>  <span class="n">SCSI_PROT_READ_INSERT</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">fcpdl</span><span class="p">;</span>

	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* Write */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">scsi_get_prot_op</span><span class="p">(</span><span class="n">sc</span><span class="p">)</span> <span class="o">==</span>  <span class="n">SCSI_PROT_WRITE_STRIP</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">fcpdl</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* If protection data on the wire, adjust the count accordingly */</span>
	<span class="n">blksize</span> <span class="o">=</span> <span class="n">lpfc_cmd_blksize</span><span class="p">(</span><span class="n">sc</span><span class="p">);</span>
	<span class="n">diflen</span> <span class="o">=</span> <span class="p">(</span><span class="n">fcpdl</span> <span class="o">/</span> <span class="n">blksize</span><span class="p">)</span> <span class="o">*</span> <span class="mi">8</span><span class="p">;</span>
	<span class="n">fcpdl</span> <span class="o">+=</span> <span class="n">diflen</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">fcpdl</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_bg_scsi_prep_dma_buf_s4 - DMA mapping for scsi buffer to SLI4 IF spec</span>
<span class="cm"> * @phba: The Hba for which this call is being executed.</span>
<span class="cm"> * @lpfc_cmd: The scsi buffer which is going to be mapped.</span>
<span class="cm"> *</span>
<span class="cm"> * This is the protection/DIF aware version of</span>
<span class="cm"> * lpfc_scsi_prep_dma_buf(). It may be a good idea to combine the</span>
<span class="cm"> * two functions eventually, but for now, it&#39;s here</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">lpfc_bg_scsi_prep_dma_buf_s4</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">lpfc_scsi_buf</span> <span class="o">*</span><span class="n">lpfc_cmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="n">scsi_cmnd</span> <span class="o">=</span> <span class="n">lpfc_cmd</span><span class="o">-&gt;</span><span class="n">pCmd</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fcp_cmnd</span> <span class="o">*</span><span class="n">fcp_cmnd</span> <span class="o">=</span> <span class="n">lpfc_cmd</span><span class="o">-&gt;</span><span class="n">fcp_cmnd</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sli4_sge</span> <span class="o">*</span><span class="n">sgl</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sli4_sge</span> <span class="o">*</span><span class="p">)(</span><span class="n">lpfc_cmd</span><span class="o">-&gt;</span><span class="n">fcp_bpl</span><span class="p">);</span>
	<span class="n">IOCB_t</span> <span class="o">*</span><span class="n">iocb_cmd</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">lpfc_cmd</span><span class="o">-&gt;</span><span class="n">cur_iocbq</span><span class="p">.</span><span class="n">iocb</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">num_bde</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">datasegcnt</span><span class="p">,</span> <span class="n">protsegcnt</span><span class="p">,</span> <span class="n">datadir</span> <span class="o">=</span> <span class="n">scsi_cmnd</span><span class="o">-&gt;</span><span class="n">sc_data_direction</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">prot_group_type</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">fcpdl</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Start the lpfc command prep by bumping the sgl beyond fcp_cmnd</span>
<span class="cm">	 *  fcp_rsp regions to the first data bde entry</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">scsi_sg_count</span><span class="p">(</span><span class="n">scsi_cmnd</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * The driver stores the segment count returned from pci_map_sg</span>
<span class="cm">		 * because this a count of dma-mappings used to map the use_sg</span>
<span class="cm">		 * pages.  They are not guaranteed to be the same for those</span>
<span class="cm">		 * architectures that implement an IOMMU.</span>
<span class="cm">		 */</span>
		<span class="n">datasegcnt</span> <span class="o">=</span> <span class="n">dma_map_sg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">pcidev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
					<span class="n">scsi_sglist</span><span class="p">(</span><span class="n">scsi_cmnd</span><span class="p">),</span>
					<span class="n">scsi_sg_count</span><span class="p">(</span><span class="n">scsi_cmnd</span><span class="p">),</span> <span class="n">datadir</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">datasegcnt</span><span class="p">))</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

		<span class="n">sgl</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="cm">/* clear the last flag in the fcp_rsp map entry */</span>
		<span class="n">sgl</span><span class="o">-&gt;</span><span class="n">word2</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">sgl</span><span class="o">-&gt;</span><span class="n">word2</span><span class="p">);</span>
		<span class="n">bf_set</span><span class="p">(</span><span class="n">lpfc_sli4_sge_last</span><span class="p">,</span> <span class="n">sgl</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">sgl</span><span class="o">-&gt;</span><span class="n">word2</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">sgl</span><span class="o">-&gt;</span><span class="n">word2</span><span class="p">);</span>

		<span class="n">sgl</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">lpfc_cmd</span><span class="o">-&gt;</span><span class="n">seg_cnt</span> <span class="o">=</span> <span class="n">datasegcnt</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">lpfc_cmd</span><span class="o">-&gt;</span><span class="n">seg_cnt</span> <span class="o">&gt;</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">cfg_sg_seg_cnt</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_BG</span><span class="p">,</span>
					<span class="s">&quot;9087 BLKGRD: %s: Too many sg segments&quot;</span>
					<span class="s">&quot; from dma_map_sg.  Config %d, seg_cnt&quot;</span>
					<span class="s">&quot; %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">__func__</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">cfg_sg_seg_cnt</span><span class="p">,</span>
					<span class="n">lpfc_cmd</span><span class="o">-&gt;</span><span class="n">seg_cnt</span><span class="p">);</span>
			<span class="n">scsi_dma_unmap</span><span class="p">(</span><span class="n">scsi_cmnd</span><span class="p">);</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">prot_group_type</span> <span class="o">=</span> <span class="n">lpfc_prot_group_type</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">scsi_cmnd</span><span class="p">);</span>

		<span class="k">switch</span> <span class="p">(</span><span class="n">prot_group_type</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">LPFC_PG_TYPE_NO_DIF</span>:
			<span class="n">num_bde</span> <span class="o">=</span> <span class="n">lpfc_bg_setup_sgl</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">scsi_cmnd</span><span class="p">,</span> <span class="n">sgl</span><span class="p">,</span>
					<span class="n">datasegcnt</span><span class="p">);</span>
			<span class="cm">/* we should have 2 or more entries in buffer list */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">num_bde</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">err</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">LPFC_PG_TYPE_DIF_BUF</span>:<span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * This type indicates that protection buffers are</span>
<span class="cm">			 * passed to the driver, so that needs to be prepared</span>
<span class="cm">			 * for DMA</span>
<span class="cm">			 */</span>
			<span class="n">protsegcnt</span> <span class="o">=</span> <span class="n">dma_map_sg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">pcidev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
					<span class="n">scsi_prot_sglist</span><span class="p">(</span><span class="n">scsi_cmnd</span><span class="p">),</span>
					<span class="n">scsi_prot_sg_count</span><span class="p">(</span><span class="n">scsi_cmnd</span><span class="p">),</span> <span class="n">datadir</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">protsegcnt</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">scsi_dma_unmap</span><span class="p">(</span><span class="n">scsi_cmnd</span><span class="p">);</span>
				<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="n">lpfc_cmd</span><span class="o">-&gt;</span><span class="n">prot_seg_cnt</span> <span class="o">=</span> <span class="n">protsegcnt</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">lpfc_cmd</span><span class="o">-&gt;</span><span class="n">prot_seg_cnt</span>
			    <span class="o">&gt;</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">cfg_prot_sg_seg_cnt</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_BG</span><span class="p">,</span>
					<span class="s">&quot;9088 BLKGRD: %s: Too many prot sg &quot;</span>
					<span class="s">&quot;segments from dma_map_sg.  Config %d,&quot;</span>
						<span class="s">&quot;prot_seg_cnt %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span>
						<span class="n">phba</span><span class="o">-&gt;</span><span class="n">cfg_prot_sg_seg_cnt</span><span class="p">,</span>
						<span class="n">lpfc_cmd</span><span class="o">-&gt;</span><span class="n">prot_seg_cnt</span><span class="p">);</span>
				<span class="n">dma_unmap_sg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">pcidev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
					     <span class="n">scsi_prot_sglist</span><span class="p">(</span><span class="n">scsi_cmnd</span><span class="p">),</span>
					     <span class="n">scsi_prot_sg_count</span><span class="p">(</span><span class="n">scsi_cmnd</span><span class="p">),</span>
					     <span class="n">datadir</span><span class="p">);</span>
				<span class="n">scsi_dma_unmap</span><span class="p">(</span><span class="n">scsi_cmnd</span><span class="p">);</span>
				<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="n">num_bde</span> <span class="o">=</span> <span class="n">lpfc_bg_setup_sgl_prot</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">scsi_cmnd</span><span class="p">,</span> <span class="n">sgl</span><span class="p">,</span>
					<span class="n">datasegcnt</span><span class="p">,</span> <span class="n">protsegcnt</span><span class="p">);</span>
			<span class="cm">/* we should have 3 or more entries in buffer list */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">num_bde</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">err</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">case</span> <span class="n">LPFC_PG_TYPE_INVALID</span>:
		<span class="nl">default:</span>
			<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_FCP</span><span class="p">,</span>
					<span class="s">&quot;9083 Unexpected protection group %i</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">prot_group_type</span><span class="p">);</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">fcpdl</span> <span class="o">=</span> <span class="n">lpfc_bg_scsi_adjust_dl</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">lpfc_cmd</span><span class="p">);</span>

	<span class="n">fcp_cmnd</span><span class="o">-&gt;</span><span class="n">fcpDl</span> <span class="o">=</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">fcpdl</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Due to difference in data length between DIF/non-DIF paths,</span>
<span class="cm">	 * we need to set word 4 of IOCB here</span>
<span class="cm">	 */</span>
	<span class="n">iocb_cmd</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">fcpi</span><span class="p">.</span><span class="n">fcpi_parm</span> <span class="o">=</span> <span class="n">fcpdl</span><span class="p">;</span>
	<span class="n">lpfc_cmd</span><span class="o">-&gt;</span><span class="n">cur_iocbq</span><span class="p">.</span><span class="n">iocb_flag</span> <span class="o">|=</span> <span class="n">LPFC_IO_DIF</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">err:</span>
	<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_FCP</span><span class="p">,</span>
			<span class="s">&quot;9084 Could not setup all needed BDE&#39;s&quot;</span>
			<span class="s">&quot;prot_group_type=%d, num_bde=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">prot_group_type</span><span class="p">,</span> <span class="n">num_bde</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_scsi_prep_dma_buf - Wrapper function for DMA mapping of scsi buffer</span>
<span class="cm"> * @phba: The Hba for which this call is being executed.</span>
<span class="cm"> * @lpfc_cmd: The scsi buffer which is going to be mapped.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine wraps the actual DMA mapping function pointer from the</span>
<span class="cm"> * lpfc_hba struct.</span>
<span class="cm"> *</span>
<span class="cm"> * Return codes:</span>
<span class="cm"> *	1 - Error</span>
<span class="cm"> *	0 - Success</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span>
<span class="nf">lpfc_scsi_prep_dma_buf</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">,</span> <span class="k">struct</span> <span class="n">lpfc_scsi_buf</span> <span class="o">*</span><span class="n">lpfc_cmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">lpfc_scsi_prep_dma_buf</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">lpfc_cmd</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_bg_scsi_prep_dma_buf - Wrapper function for DMA mapping of scsi buffer</span>
<span class="cm"> * using BlockGuard.</span>
<span class="cm"> * @phba: The Hba for which this call is being executed.</span>
<span class="cm"> * @lpfc_cmd: The scsi buffer which is going to be mapped.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine wraps the actual DMA mapping function pointer from the</span>
<span class="cm"> * lpfc_hba struct.</span>
<span class="cm"> *</span>
<span class="cm"> * Return codes:</span>
<span class="cm"> *	1 - Error</span>
<span class="cm"> *	0 - Success</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span>
<span class="nf">lpfc_bg_scsi_prep_dma_buf</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">,</span> <span class="k">struct</span> <span class="n">lpfc_scsi_buf</span> <span class="o">*</span><span class="n">lpfc_cmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">lpfc_bg_scsi_prep_dma_buf</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">lpfc_cmd</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_send_scsi_error_event - Posts an event when there is SCSI error</span>
<span class="cm"> * @phba: Pointer to hba context object.</span>
<span class="cm"> * @vport: Pointer to vport object.</span>
<span class="cm"> * @lpfc_cmd: Pointer to lpfc scsi command which reported the error.</span>
<span class="cm"> * @rsp_iocb: Pointer to response iocb object which reported error.</span>
<span class="cm"> *</span>
<span class="cm"> * This function posts an event when there is a SCSI command reporting</span>
<span class="cm"> * error from the scsi device.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">lpfc_send_scsi_error_event</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">,</span> <span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="n">vport</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">lpfc_scsi_buf</span> <span class="o">*</span><span class="n">lpfc_cmd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">lpfc_iocbq</span> <span class="o">*</span><span class="n">rsp_iocb</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="n">cmnd</span> <span class="o">=</span> <span class="n">lpfc_cmd</span><span class="o">-&gt;</span><span class="n">pCmd</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fcp_rsp</span> <span class="o">*</span><span class="n">fcprsp</span> <span class="o">=</span> <span class="n">lpfc_cmd</span><span class="o">-&gt;</span><span class="n">fcp_rsp</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">resp_info</span> <span class="o">=</span> <span class="n">fcprsp</span><span class="o">-&gt;</span><span class="n">rspStatus2</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">scsi_status</span> <span class="o">=</span> <span class="n">fcprsp</span><span class="o">-&gt;</span><span class="n">rspStatus3</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">fcpi_parm</span> <span class="o">=</span> <span class="n">rsp_iocb</span><span class="o">-&gt;</span><span class="n">iocb</span><span class="p">.</span><span class="n">un</span><span class="p">.</span><span class="n">fcpi</span><span class="p">.</span><span class="n">fcpi_parm</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_fast_path_event</span> <span class="o">*</span><span class="n">fast_path_evt</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_nodelist</span> <span class="o">*</span><span class="n">pnode</span> <span class="o">=</span> <span class="n">lpfc_cmd</span><span class="o">-&gt;</span><span class="n">rdata</span><span class="o">-&gt;</span><span class="n">pnode</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pnode</span> <span class="o">||</span> <span class="o">!</span><span class="n">NLP_CHK_NODE_ACT</span><span class="p">(</span><span class="n">pnode</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/* If there is queuefull or busy condition send a scsi event */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">cmnd</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">==</span> <span class="n">SAM_STAT_TASK_SET_FULL</span><span class="p">)</span> <span class="o">||</span>
		<span class="p">(</span><span class="n">cmnd</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">==</span> <span class="n">SAM_STAT_BUSY</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">fast_path_evt</span> <span class="o">=</span> <span class="n">lpfc_alloc_fast_evt</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">fast_path_evt</span><span class="p">)</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="n">fast_path_evt</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">scsi_evt</span><span class="p">.</span><span class="n">event_type</span> <span class="o">=</span>
			<span class="n">FC_REG_SCSI_EVENT</span><span class="p">;</span>
		<span class="n">fast_path_evt</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">scsi_evt</span><span class="p">.</span><span class="n">subcategory</span> <span class="o">=</span>
		<span class="p">(</span><span class="n">cmnd</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">==</span> <span class="n">SAM_STAT_TASK_SET_FULL</span><span class="p">)</span> <span class="o">?</span>
		<span class="n">LPFC_EVENT_QFULL</span> <span class="o">:</span> <span class="n">LPFC_EVENT_DEVBSY</span><span class="p">;</span>
		<span class="n">fast_path_evt</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">scsi_evt</span><span class="p">.</span><span class="n">lun</span> <span class="o">=</span> <span class="n">cmnd</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">lun</span><span class="p">;</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fast_path_evt</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">scsi_evt</span><span class="p">.</span><span class="n">wwpn</span><span class="p">,</span>
			<span class="o">&amp;</span><span class="n">pnode</span><span class="o">-&gt;</span><span class="n">nlp_portname</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_name</span><span class="p">));</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fast_path_evt</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">scsi_evt</span><span class="p">.</span><span class="n">wwnn</span><span class="p">,</span>
			<span class="o">&amp;</span><span class="n">pnode</span><span class="o">-&gt;</span><span class="n">nlp_nodename</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_name</span><span class="p">));</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">resp_info</span> <span class="o">&amp;</span> <span class="n">SNS_LEN_VALID</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">fcprsp</span><span class="o">-&gt;</span><span class="n">rspSnsLen</span> <span class="o">&amp;&amp;</span>
		<span class="p">((</span><span class="n">cmnd</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">READ_10</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">cmnd</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">WRITE_10</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">fast_path_evt</span> <span class="o">=</span> <span class="n">lpfc_alloc_fast_evt</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">fast_path_evt</span><span class="p">)</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="n">fast_path_evt</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">check_cond_evt</span><span class="p">.</span><span class="n">scsi_event</span><span class="p">.</span><span class="n">event_type</span> <span class="o">=</span>
			<span class="n">FC_REG_SCSI_EVENT</span><span class="p">;</span>
		<span class="n">fast_path_evt</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">check_cond_evt</span><span class="p">.</span><span class="n">scsi_event</span><span class="p">.</span><span class="n">subcategory</span> <span class="o">=</span>
			<span class="n">LPFC_EVENT_CHECK_COND</span><span class="p">;</span>
		<span class="n">fast_path_evt</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">check_cond_evt</span><span class="p">.</span><span class="n">scsi_event</span><span class="p">.</span><span class="n">lun</span> <span class="o">=</span>
			<span class="n">cmnd</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">lun</span><span class="p">;</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fast_path_evt</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">check_cond_evt</span><span class="p">.</span><span class="n">scsi_event</span><span class="p">.</span><span class="n">wwpn</span><span class="p">,</span>
			<span class="o">&amp;</span><span class="n">pnode</span><span class="o">-&gt;</span><span class="n">nlp_portname</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_name</span><span class="p">));</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fast_path_evt</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">check_cond_evt</span><span class="p">.</span><span class="n">scsi_event</span><span class="p">.</span><span class="n">wwnn</span><span class="p">,</span>
			<span class="o">&amp;</span><span class="n">pnode</span><span class="o">-&gt;</span><span class="n">nlp_nodename</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_name</span><span class="p">));</span>
		<span class="n">fast_path_evt</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">check_cond_evt</span><span class="p">.</span><span class="n">sense_key</span> <span class="o">=</span>
			<span class="n">cmnd</span><span class="o">-&gt;</span><span class="n">sense_buffer</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0xf</span><span class="p">;</span>
		<span class="n">fast_path_evt</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">check_cond_evt</span><span class="p">.</span><span class="n">asc</span> <span class="o">=</span> <span class="n">cmnd</span><span class="o">-&gt;</span><span class="n">sense_buffer</span><span class="p">[</span><span class="mi">12</span><span class="p">];</span>
		<span class="n">fast_path_evt</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">check_cond_evt</span><span class="p">.</span><span class="n">ascq</span> <span class="o">=</span> <span class="n">cmnd</span><span class="o">-&gt;</span><span class="n">sense_buffer</span><span class="p">[</span><span class="mi">13</span><span class="p">];</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">cmnd</span><span class="o">-&gt;</span><span class="n">sc_data_direction</span> <span class="o">==</span> <span class="n">DMA_FROM_DEVICE</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		     <span class="n">fcpi_parm</span> <span class="o">&amp;&amp;</span>
		     <span class="p">((</span><span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">fcprsp</span><span class="o">-&gt;</span><span class="n">rspResId</span><span class="p">)</span> <span class="o">!=</span> <span class="n">fcpi_parm</span><span class="p">)</span> <span class="o">||</span>
			<span class="p">((</span><span class="n">scsi_status</span> <span class="o">==</span> <span class="n">SAM_STAT_GOOD</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			<span class="o">!</span><span class="p">(</span><span class="n">resp_info</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">RESID_UNDER</span> <span class="o">|</span> <span class="n">RESID_OVER</span><span class="p">)))))</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * If status is good or resid does not match with fcp_param and</span>
<span class="cm">		 * there is valid fcpi_parm, then there is a read_check error</span>
<span class="cm">		 */</span>
		<span class="n">fast_path_evt</span> <span class="o">=</span> <span class="n">lpfc_alloc_fast_evt</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">fast_path_evt</span><span class="p">)</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="n">fast_path_evt</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">read_check_error</span><span class="p">.</span><span class="n">header</span><span class="p">.</span><span class="n">event_type</span> <span class="o">=</span>
			<span class="n">FC_REG_FABRIC_EVENT</span><span class="p">;</span>
		<span class="n">fast_path_evt</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">read_check_error</span><span class="p">.</span><span class="n">header</span><span class="p">.</span><span class="n">subcategory</span> <span class="o">=</span>
			<span class="n">LPFC_EVENT_FCPRDCHKERR</span><span class="p">;</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fast_path_evt</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">read_check_error</span><span class="p">.</span><span class="n">header</span><span class="p">.</span><span class="n">wwpn</span><span class="p">,</span>
			<span class="o">&amp;</span><span class="n">pnode</span><span class="o">-&gt;</span><span class="n">nlp_portname</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_name</span><span class="p">));</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fast_path_evt</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">read_check_error</span><span class="p">.</span><span class="n">header</span><span class="p">.</span><span class="n">wwnn</span><span class="p">,</span>
			<span class="o">&amp;</span><span class="n">pnode</span><span class="o">-&gt;</span><span class="n">nlp_nodename</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_name</span><span class="p">));</span>
		<span class="n">fast_path_evt</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">read_check_error</span><span class="p">.</span><span class="n">lun</span> <span class="o">=</span> <span class="n">cmnd</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">lun</span><span class="p">;</span>
		<span class="n">fast_path_evt</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">read_check_error</span><span class="p">.</span><span class="n">opcode</span> <span class="o">=</span> <span class="n">cmnd</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
		<span class="n">fast_path_evt</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">read_check_error</span><span class="p">.</span><span class="n">fcpiparam</span> <span class="o">=</span>
			<span class="n">fcpi_parm</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">fast_path_evt</span><span class="o">-&gt;</span><span class="n">vport</span> <span class="o">=</span> <span class="n">vport</span><span class="p">;</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fast_path_evt</span><span class="o">-&gt;</span><span class="n">work_evt</span><span class="p">.</span><span class="n">evt_listp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">work_list</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">lpfc_worker_wake_up</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_scsi_unprep_dma_buf - Un-map DMA mapping of SG-list for dev</span>
<span class="cm"> * @phba: The HBA for which this call is being executed.</span>
<span class="cm"> * @psb: The scsi buffer which is going to be un-mapped.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine does DMA un-mapping of scatter gather list of scsi command</span>
<span class="cm"> * field of @lpfc_cmd for device with SLI-3 interface spec.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">lpfc_scsi_unprep_dma_buf</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">,</span> <span class="k">struct</span> <span class="n">lpfc_scsi_buf</span> <span class="o">*</span><span class="n">psb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * There are only two special cases to consider.  (1) the scsi command</span>
<span class="cm">	 * requested scatter-gather usage or (2) the scsi command allocated</span>
<span class="cm">	 * a request buffer, but did not request use_sg.  There is a third</span>
<span class="cm">	 * case, but it does not require resource deallocation.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">psb</span><span class="o">-&gt;</span><span class="n">seg_cnt</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">scsi_dma_unmap</span><span class="p">(</span><span class="n">psb</span><span class="o">-&gt;</span><span class="n">pCmd</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">psb</span><span class="o">-&gt;</span><span class="n">prot_seg_cnt</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">dma_unmap_sg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">pcidev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">scsi_prot_sglist</span><span class="p">(</span><span class="n">psb</span><span class="o">-&gt;</span><span class="n">pCmd</span><span class="p">),</span>
				<span class="n">scsi_prot_sg_count</span><span class="p">(</span><span class="n">psb</span><span class="o">-&gt;</span><span class="n">pCmd</span><span class="p">),</span>
				<span class="n">psb</span><span class="o">-&gt;</span><span class="n">pCmd</span><span class="o">-&gt;</span><span class="n">sc_data_direction</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_handler_fcp_err - FCP response handler</span>
<span class="cm"> * @vport: The virtual port for which this call is being executed.</span>
<span class="cm"> * @lpfc_cmd: Pointer to lpfc_scsi_buf data structure.</span>
<span class="cm"> * @rsp_iocb: The response IOCB which contains FCP error.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine is called to process response IOCB with status field</span>
<span class="cm"> * IOSTAT_FCP_RSP_ERROR. This routine sets result field of scsi command</span>
<span class="cm"> * based upon SCSI and FCP error.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">lpfc_handle_fcp_err</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="n">vport</span><span class="p">,</span> <span class="k">struct</span> <span class="n">lpfc_scsi_buf</span> <span class="o">*</span><span class="n">lpfc_cmd</span><span class="p">,</span>
		    <span class="k">struct</span> <span class="n">lpfc_iocbq</span> <span class="o">*</span><span class="n">rsp_iocb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="n">cmnd</span> <span class="o">=</span> <span class="n">lpfc_cmd</span><span class="o">-&gt;</span><span class="n">pCmd</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fcp_cmnd</span> <span class="o">*</span><span class="n">fcpcmd</span> <span class="o">=</span> <span class="n">lpfc_cmd</span><span class="o">-&gt;</span><span class="n">fcp_cmnd</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fcp_rsp</span> <span class="o">*</span><span class="n">fcprsp</span> <span class="o">=</span> <span class="n">lpfc_cmd</span><span class="o">-&gt;</span><span class="n">fcp_rsp</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">fcpi_parm</span> <span class="o">=</span> <span class="n">rsp_iocb</span><span class="o">-&gt;</span><span class="n">iocb</span><span class="p">.</span><span class="n">un</span><span class="p">.</span><span class="n">fcpi</span><span class="p">.</span><span class="n">fcpi_parm</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">resp_info</span> <span class="o">=</span> <span class="n">fcprsp</span><span class="o">-&gt;</span><span class="n">rspStatus2</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">scsi_status</span> <span class="o">=</span> <span class="n">fcprsp</span><span class="o">-&gt;</span><span class="n">rspStatus3</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="o">*</span><span class="n">lp</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">host_status</span> <span class="o">=</span> <span class="n">DID_OK</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">rsplen</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">logit</span> <span class="o">=</span> <span class="n">LOG_FCP</span> <span class="o">|</span> <span class="n">LOG_FCP_ERROR</span><span class="p">;</span>


	<span class="cm">/*</span>
<span class="cm">	 *  If this is a task management command, there is no</span>
<span class="cm">	 *  scsi packet associated with this lpfc_cmd.  The driver</span>
<span class="cm">	 *  consumes it.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">fcpcmd</span><span class="o">-&gt;</span><span class="n">fcpCntl2</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">scsi_status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">resp_info</span> <span class="o">&amp;</span> <span class="n">RSP_LEN_VALID</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rsplen</span> <span class="o">=</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">fcprsp</span><span class="o">-&gt;</span><span class="n">rspRspLen</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rsplen</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">rsplen</span> <span class="o">!=</span> <span class="mi">4</span> <span class="o">&amp;&amp;</span> <span class="n">rsplen</span> <span class="o">!=</span> <span class="mi">8</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">lpfc_printf_vlog</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_FCP</span><span class="p">,</span>
				 <span class="s">&quot;2719 Invalid response length: &quot;</span>
				 <span class="s">&quot;tgt x%x lun x%x cmnd x%x rsplen x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				 <span class="n">cmnd</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">,</span>
				 <span class="n">cmnd</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">lun</span><span class="p">,</span> <span class="n">cmnd</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
				 <span class="n">rsplen</span><span class="p">);</span>
			<span class="n">host_status</span> <span class="o">=</span> <span class="n">DID_ERROR</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">fcprsp</span><span class="o">-&gt;</span><span class="n">rspInfo3</span> <span class="o">!=</span> <span class="n">RSP_NO_FAILURE</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">lpfc_printf_vlog</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_FCP</span><span class="p">,</span>
				 <span class="s">&quot;2757 Protocol failure detected during &quot;</span>
				 <span class="s">&quot;processing of FCP I/O op: &quot;</span>
				 <span class="s">&quot;tgt x%x lun x%x cmnd x%x rspInfo3 x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				 <span class="n">cmnd</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">,</span>
				 <span class="n">cmnd</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">lun</span><span class="p">,</span> <span class="n">cmnd</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
				 <span class="n">fcprsp</span><span class="o">-&gt;</span><span class="n">rspInfo3</span><span class="p">);</span>
			<span class="n">host_status</span> <span class="o">=</span> <span class="n">DID_ERROR</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">resp_info</span> <span class="o">&amp;</span> <span class="n">SNS_LEN_VALID</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">fcprsp</span><span class="o">-&gt;</span><span class="n">rspSnsLen</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">uint32_t</span> <span class="n">snslen</span> <span class="o">=</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">fcprsp</span><span class="o">-&gt;</span><span class="n">rspSnsLen</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">snslen</span> <span class="o">&gt;</span> <span class="n">SCSI_SENSE_BUFFERSIZE</span><span class="p">)</span>
			<span class="n">snslen</span> <span class="o">=</span> <span class="n">SCSI_SENSE_BUFFERSIZE</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">resp_info</span> <span class="o">&amp;</span> <span class="n">RSP_LEN_VALID</span><span class="p">)</span>
		  <span class="n">rsplen</span> <span class="o">=</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">fcprsp</span><span class="o">-&gt;</span><span class="n">rspRspLen</span><span class="p">);</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">cmnd</span><span class="o">-&gt;</span><span class="n">sense_buffer</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fcprsp</span><span class="o">-&gt;</span><span class="n">rspInfo0</span> <span class="o">+</span> <span class="n">rsplen</span><span class="p">,</span> <span class="n">snslen</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">lp</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint32_t</span> <span class="o">*</span><span class="p">)</span><span class="n">cmnd</span><span class="o">-&gt;</span><span class="n">sense_buffer</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">scsi_status</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">resp_info</span> <span class="o">&amp;</span> <span class="n">RESID_UNDER</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		<span class="n">vport</span><span class="o">-&gt;</span><span class="n">cfg_log_verbose</span> <span class="o">&amp;</span> <span class="n">LOG_FCP_UNDER</span><span class="p">)</span>
		<span class="n">logit</span> <span class="o">=</span> <span class="n">LOG_FCP_UNDER</span><span class="p">;</span>

	<span class="n">lpfc_printf_vlog</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">KERN_WARNING</span><span class="p">,</span> <span class="n">logit</span><span class="p">,</span>
			 <span class="s">&quot;9024 FCP command x%x failed: x%x SNS x%x x%x &quot;</span>
			 <span class="s">&quot;Data: x%x x%x x%x x%x x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			 <span class="n">cmnd</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">scsi_status</span><span class="p">,</span>
			 <span class="n">be32_to_cpu</span><span class="p">(</span><span class="o">*</span><span class="n">lp</span><span class="p">),</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">lp</span> <span class="o">+</span> <span class="mi">3</span><span class="p">)),</span> <span class="n">resp_info</span><span class="p">,</span>
			 <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">fcprsp</span><span class="o">-&gt;</span><span class="n">rspResId</span><span class="p">),</span>
			 <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">fcprsp</span><span class="o">-&gt;</span><span class="n">rspSnsLen</span><span class="p">),</span>
			 <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">fcprsp</span><span class="o">-&gt;</span><span class="n">rspRspLen</span><span class="p">),</span>
			 <span class="n">fcprsp</span><span class="o">-&gt;</span><span class="n">rspInfo3</span><span class="p">);</span>

	<span class="n">scsi_set_resid</span><span class="p">(</span><span class="n">cmnd</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">resp_info</span> <span class="o">&amp;</span> <span class="n">RESID_UNDER</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">scsi_set_resid</span><span class="p">(</span><span class="n">cmnd</span><span class="p">,</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">fcprsp</span><span class="o">-&gt;</span><span class="n">rspResId</span><span class="p">));</span>

		<span class="n">lpfc_printf_vlog</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">KERN_INFO</span><span class="p">,</span> <span class="n">LOG_FCP_UNDER</span><span class="p">,</span>
				 <span class="s">&quot;9025 FCP Read Underrun, expected %d, &quot;</span>
				 <span class="s">&quot;residual %d Data: x%x x%x x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				 <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">fcpcmd</span><span class="o">-&gt;</span><span class="n">fcpDl</span><span class="p">),</span>
				 <span class="n">scsi_get_resid</span><span class="p">(</span><span class="n">cmnd</span><span class="p">),</span> <span class="n">fcpi_parm</span><span class="p">,</span> <span class="n">cmnd</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
				 <span class="n">cmnd</span><span class="o">-&gt;</span><span class="n">underflow</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * If there is an under run check if under run reported by</span>
<span class="cm">		 * storage array is same as the under run reported by HBA.</span>
<span class="cm">		 * If this is not same, there is a dropped frame.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">cmnd</span><span class="o">-&gt;</span><span class="n">sc_data_direction</span> <span class="o">==</span> <span class="n">DMA_FROM_DEVICE</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			<span class="n">fcpi_parm</span> <span class="o">&amp;&amp;</span>
			<span class="p">(</span><span class="n">scsi_get_resid</span><span class="p">(</span><span class="n">cmnd</span><span class="p">)</span> <span class="o">!=</span> <span class="n">fcpi_parm</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">lpfc_printf_vlog</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">KERN_WARNING</span><span class="p">,</span>
					 <span class="n">LOG_FCP</span> <span class="o">|</span> <span class="n">LOG_FCP_ERROR</span><span class="p">,</span>
					 <span class="s">&quot;9026 FCP Read Check Error &quot;</span>
					 <span class="s">&quot;and Underrun Data: x%x x%x x%x x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					 <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">fcpcmd</span><span class="o">-&gt;</span><span class="n">fcpDl</span><span class="p">),</span>
					 <span class="n">scsi_get_resid</span><span class="p">(</span><span class="n">cmnd</span><span class="p">),</span> <span class="n">fcpi_parm</span><span class="p">,</span>
					 <span class="n">cmnd</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
			<span class="n">scsi_set_resid</span><span class="p">(</span><span class="n">cmnd</span><span class="p">,</span> <span class="n">scsi_bufflen</span><span class="p">(</span><span class="n">cmnd</span><span class="p">));</span>
			<span class="n">host_status</span> <span class="o">=</span> <span class="n">DID_ERROR</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/*</span>
<span class="cm">		 * The cmnd-&gt;underflow is the minimum number of bytes that must</span>
<span class="cm">		 * be transferred for this command.  Provided a sense condition</span>
<span class="cm">		 * is not present, make sure the actual amount transferred is at</span>
<span class="cm">		 * least the underflow value or fail.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">resp_info</span> <span class="o">&amp;</span> <span class="n">SNS_LEN_VALID</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="p">(</span><span class="n">scsi_status</span> <span class="o">==</span> <span class="n">SAM_STAT_GOOD</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="p">(</span><span class="n">scsi_bufflen</span><span class="p">(</span><span class="n">cmnd</span><span class="p">)</span> <span class="o">-</span> <span class="n">scsi_get_resid</span><span class="p">(</span><span class="n">cmnd</span><span class="p">)</span>
		     <span class="o">&lt;</span> <span class="n">cmnd</span><span class="o">-&gt;</span><span class="n">underflow</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">lpfc_printf_vlog</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">KERN_INFO</span><span class="p">,</span> <span class="n">LOG_FCP</span><span class="p">,</span>
					 <span class="s">&quot;9027 FCP command x%x residual &quot;</span>
					 <span class="s">&quot;underrun converted to error &quot;</span>
					 <span class="s">&quot;Data: x%x x%x x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					 <span class="n">cmnd</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">scsi_bufflen</span><span class="p">(</span><span class="n">cmnd</span><span class="p">),</span>
					 <span class="n">scsi_get_resid</span><span class="p">(</span><span class="n">cmnd</span><span class="p">),</span> <span class="n">cmnd</span><span class="o">-&gt;</span><span class="n">underflow</span><span class="p">);</span>
			<span class="n">host_status</span> <span class="o">=</span> <span class="n">DID_ERROR</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">resp_info</span> <span class="o">&amp;</span> <span class="n">RESID_OVER</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lpfc_printf_vlog</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">KERN_WARNING</span><span class="p">,</span> <span class="n">LOG_FCP</span><span class="p">,</span>
				 <span class="s">&quot;9028 FCP command x%x residual overrun error. &quot;</span>
				 <span class="s">&quot;Data: x%x x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">cmnd</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
				 <span class="n">scsi_bufflen</span><span class="p">(</span><span class="n">cmnd</span><span class="p">),</span> <span class="n">scsi_get_resid</span><span class="p">(</span><span class="n">cmnd</span><span class="p">));</span>
		<span class="n">host_status</span> <span class="o">=</span> <span class="n">DID_ERROR</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Check SLI validation that all the transfer was actually done</span>
<span class="cm">	 * (fcpi_parm should be zero). Apply check only to reads.</span>
<span class="cm">	 */</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">fcpi_parm</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">cmnd</span><span class="o">-&gt;</span><span class="n">sc_data_direction</span> <span class="o">==</span> <span class="n">DMA_FROM_DEVICE</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">lpfc_printf_vlog</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">KERN_WARNING</span><span class="p">,</span> <span class="n">LOG_FCP</span> <span class="o">|</span> <span class="n">LOG_FCP_ERROR</span><span class="p">,</span>
				 <span class="s">&quot;9029 FCP Read Check Error Data: &quot;</span>
				 <span class="s">&quot;x%x x%x x%x x%x x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				 <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">fcpcmd</span><span class="o">-&gt;</span><span class="n">fcpDl</span><span class="p">),</span>
				 <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">fcprsp</span><span class="o">-&gt;</span><span class="n">rspResId</span><span class="p">),</span>
				 <span class="n">fcpi_parm</span><span class="p">,</span> <span class="n">cmnd</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">scsi_status</span><span class="p">);</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">scsi_status</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">SAM_STAT_GOOD</span>:
		<span class="k">case</span> <span class="n">SAM_STAT_CHECK_CONDITION</span>:
			<span class="cm">/* Fabric dropped a data frame. Fail any successful</span>
<span class="cm">			 * command in which we detected dropped frames.</span>
<span class="cm">			 * A status of good or some check conditions could</span>
<span class="cm">			 * be considered a successful command.</span>
<span class="cm">			 */</span>
			<span class="n">host_status</span> <span class="o">=</span> <span class="n">DID_ERROR</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">scsi_set_resid</span><span class="p">(</span><span class="n">cmnd</span><span class="p">,</span> <span class="n">scsi_bufflen</span><span class="p">(</span><span class="n">cmnd</span><span class="p">));</span>
	<span class="p">}</span>

 <span class="nl">out:</span>
	<span class="n">cmnd</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">=</span> <span class="n">ScsiResult</span><span class="p">(</span><span class="n">host_status</span><span class="p">,</span> <span class="n">scsi_status</span><span class="p">);</span>
	<span class="n">lpfc_send_scsi_error_event</span><span class="p">(</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">phba</span><span class="p">,</span> <span class="n">vport</span><span class="p">,</span> <span class="n">lpfc_cmd</span><span class="p">,</span> <span class="n">rsp_iocb</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_scsi_cmd_iocb_cmpl - Scsi cmnd IOCB completion routine</span>
<span class="cm"> * @phba: The Hba for which this call is being executed.</span>
<span class="cm"> * @pIocbIn: The command IOCBQ for the scsi cmnd.</span>
<span class="cm"> * @pIocbOut: The response IOCBQ for the scsi cmnd.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine assigns scsi command result by looking into response IOCB</span>
<span class="cm"> * status field appropriately. This routine handles QUEUE FULL condition as</span>
<span class="cm"> * well by ramping down device queue depth.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">lpfc_scsi_cmd_iocb_cmpl</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">,</span> <span class="k">struct</span> <span class="n">lpfc_iocbq</span> <span class="o">*</span><span class="n">pIocbIn</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">lpfc_iocbq</span> <span class="o">*</span><span class="n">pIocbOut</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpfc_scsi_buf</span> <span class="o">*</span><span class="n">lpfc_cmd</span> <span class="o">=</span>
		<span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_scsi_buf</span> <span class="o">*</span><span class="p">)</span> <span class="n">pIocbIn</span><span class="o">-&gt;</span><span class="n">context1</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_vport</span>      <span class="o">*</span><span class="n">vport</span> <span class="o">=</span> <span class="n">pIocbIn</span><span class="o">-&gt;</span><span class="n">vport</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_rport_data</span> <span class="o">*</span><span class="n">rdata</span> <span class="o">=</span> <span class="n">lpfc_cmd</span><span class="o">-&gt;</span><span class="n">rdata</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_nodelist</span> <span class="o">*</span><span class="n">pnode</span> <span class="o">=</span> <span class="n">rdata</span><span class="o">-&gt;</span><span class="n">pnode</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">result</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="n">tmp_sdev</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">depth</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_fast_path_event</span> <span class="o">*</span><span class="n">fast_path_evt</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">queue_depth</span><span class="p">,</span> <span class="n">scsi_id</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">logit</span> <span class="o">=</span> <span class="n">LOG_FCP</span><span class="p">;</span>

	<span class="cm">/* Sanity check on return of outstanding command */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">lpfc_cmd</span><span class="o">-&gt;</span><span class="n">pCmd</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">cmd</span> <span class="o">=</span> <span class="n">lpfc_cmd</span><span class="o">-&gt;</span><span class="n">pCmd</span><span class="p">;</span>
	<span class="n">shost</span> <span class="o">=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">;</span>

	<span class="n">lpfc_cmd</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">=</span> <span class="n">pIocbOut</span><span class="o">-&gt;</span><span class="n">iocb</span><span class="p">.</span><span class="n">un</span><span class="p">.</span><span class="n">ulpWord</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
	<span class="n">lpfc_cmd</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">=</span> <span class="n">pIocbOut</span><span class="o">-&gt;</span><span class="n">iocb</span><span class="p">.</span><span class="n">ulpStatus</span><span class="p">;</span>
	<span class="cm">/* pick up SLI4 exhange busy status from HBA */</span>
	<span class="n">lpfc_cmd</span><span class="o">-&gt;</span><span class="n">exch_busy</span> <span class="o">=</span> <span class="n">pIocbOut</span><span class="o">-&gt;</span><span class="n">iocb_flag</span> <span class="o">&amp;</span> <span class="n">LPFC_EXCHANGE_BUSY</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_SCSI_LPFC_DEBUG_FS</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">lpfc_cmd</span><span class="o">-&gt;</span><span class="n">prot_data_type</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">scsi_dif_tuple</span> <span class="o">*</span><span class="n">src</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

		<span class="n">src</span> <span class="o">=</span>  <span class="p">(</span><span class="k">struct</span> <span class="n">scsi_dif_tuple</span> <span class="o">*</span><span class="p">)</span><span class="n">lpfc_cmd</span><span class="o">-&gt;</span><span class="n">prot_data_segment</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * Used to restore any changes to protection</span>
<span class="cm">		 * data for error injection.</span>
<span class="cm">		 */</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">lpfc_cmd</span><span class="o">-&gt;</span><span class="n">prot_data_type</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">LPFC_INJERR_REFTAG</span>:
			<span class="n">src</span><span class="o">-&gt;</span><span class="n">ref_tag</span> <span class="o">=</span>
				<span class="n">lpfc_cmd</span><span class="o">-&gt;</span><span class="n">prot_data</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">LPFC_INJERR_APPTAG</span>:
			<span class="n">src</span><span class="o">-&gt;</span><span class="n">app_tag</span> <span class="o">=</span>
				<span class="p">(</span><span class="kt">uint16_t</span><span class="p">)</span><span class="n">lpfc_cmd</span><span class="o">-&gt;</span><span class="n">prot_data</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">LPFC_INJERR_GUARD</span>:
			<span class="n">src</span><span class="o">-&gt;</span><span class="n">guard_tag</span> <span class="o">=</span>
				<span class="p">(</span><span class="kt">uint16_t</span><span class="p">)</span><span class="n">lpfc_cmd</span><span class="o">-&gt;</span><span class="n">prot_data</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="nl">default:</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">lpfc_cmd</span><span class="o">-&gt;</span><span class="n">prot_data</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">lpfc_cmd</span><span class="o">-&gt;</span><span class="n">prot_data_type</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">lpfc_cmd</span><span class="o">-&gt;</span><span class="n">prot_data_segment</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
<span class="cp">#endif</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pnode</span> <span class="o">&amp;&amp;</span> <span class="n">NLP_CHK_NODE_ACT</span><span class="p">(</span><span class="n">pnode</span><span class="p">))</span>
		<span class="n">atomic_dec</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pnode</span><span class="o">-&gt;</span><span class="n">cmd_pending</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">lpfc_cmd</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">lpfc_cmd</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">==</span> <span class="n">IOSTAT_LOCAL_REJECT</span> <span class="o">&amp;&amp;</span>
		    <span class="p">(</span><span class="n">lpfc_cmd</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">&amp;</span> <span class="n">IOERR_DRVR_MASK</span><span class="p">))</span>
			<span class="n">lpfc_cmd</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">=</span> <span class="n">IOSTAT_DRIVER_REJECT</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">lpfc_cmd</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">&gt;=</span> <span class="n">IOSTAT_CNT</span><span class="p">)</span>
			<span class="n">lpfc_cmd</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">=</span> <span class="n">IOSTAT_DEFAULT</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">lpfc_cmd</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">==</span> <span class="n">IOSTAT_FCP_RSP_ERROR</span>
			<span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">lpfc_cmd</span><span class="o">-&gt;</span><span class="n">fcp_rsp</span><span class="o">-&gt;</span><span class="n">rspStatus3</span>
			<span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">lpfc_cmd</span><span class="o">-&gt;</span><span class="n">fcp_rsp</span><span class="o">-&gt;</span><span class="n">rspStatus2</span> <span class="o">&amp;</span> <span class="n">RESID_UNDER</span><span class="p">)</span>
			<span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">cfg_log_verbose</span> <span class="o">&amp;</span> <span class="n">LOG_FCP_UNDER</span><span class="p">))</span>
			<span class="n">logit</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">logit</span> <span class="o">=</span> <span class="n">LOG_FCP</span> <span class="o">|</span> <span class="n">LOG_FCP_UNDER</span><span class="p">;</span>
		<span class="n">lpfc_printf_vlog</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">KERN_WARNING</span><span class="p">,</span> <span class="n">logit</span><span class="p">,</span>
			 <span class="s">&quot;9030 FCP cmd x%x failed &lt;%d/%d&gt; &quot;</span>
			 <span class="s">&quot;status: x%x result: x%x &quot;</span>
			 <span class="s">&quot;sid: x%x did: x%x oxid: x%x &quot;</span>
			 <span class="s">&quot;Data: x%x x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			 <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
			 <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">device</span> <span class="o">?</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">id</span> <span class="o">:</span> <span class="mh">0xffff</span><span class="p">,</span>
			 <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">device</span> <span class="o">?</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">lun</span> <span class="o">:</span> <span class="mh">0xffff</span><span class="p">,</span>
			 <span class="n">lpfc_cmd</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">,</span> <span class="n">lpfc_cmd</span><span class="o">-&gt;</span><span class="n">result</span><span class="p">,</span>
			 <span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_myDID</span><span class="p">,</span> <span class="n">pnode</span><span class="o">-&gt;</span><span class="n">nlp_DID</span><span class="p">,</span>
			 <span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli_rev</span> <span class="o">==</span> <span class="n">LPFC_SLI_REV4</span> <span class="o">?</span>
			     <span class="n">lpfc_cmd</span><span class="o">-&gt;</span><span class="n">cur_iocbq</span><span class="p">.</span><span class="n">sli4_xritag</span> <span class="o">:</span> <span class="mh">0xffff</span><span class="p">,</span>
			 <span class="n">pIocbOut</span><span class="o">-&gt;</span><span class="n">iocb</span><span class="p">.</span><span class="n">ulpContext</span><span class="p">,</span>
			 <span class="n">lpfc_cmd</span><span class="o">-&gt;</span><span class="n">cur_iocbq</span><span class="p">.</span><span class="n">iocb</span><span class="p">.</span><span class="n">ulpIoTag</span><span class="p">);</span>

		<span class="k">switch</span> <span class="p">(</span><span class="n">lpfc_cmd</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">IOSTAT_FCP_RSP_ERROR</span>:
			<span class="cm">/* Call FCP RSP handler to determine result */</span>
			<span class="n">lpfc_handle_fcp_err</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">lpfc_cmd</span><span class="p">,</span> <span class="n">pIocbOut</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">IOSTAT_NPORT_BSY</span>:
		<span class="k">case</span> <span class="n">IOSTAT_FABRIC_BSY</span>:
			<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">=</span> <span class="n">ScsiResult</span><span class="p">(</span><span class="n">DID_TRANSPORT_DISRUPTED</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
			<span class="n">fast_path_evt</span> <span class="o">=</span> <span class="n">lpfc_alloc_fast_evt</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">fast_path_evt</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="n">fast_path_evt</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">fabric_evt</span><span class="p">.</span><span class="n">event_type</span> <span class="o">=</span>
				<span class="n">FC_REG_FABRIC_EVENT</span><span class="p">;</span>
			<span class="n">fast_path_evt</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">fabric_evt</span><span class="p">.</span><span class="n">subcategory</span> <span class="o">=</span>
				<span class="p">(</span><span class="n">lpfc_cmd</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">==</span> <span class="n">IOSTAT_NPORT_BSY</span><span class="p">)</span> <span class="o">?</span>
				<span class="n">LPFC_EVENT_PORT_BUSY</span> <span class="o">:</span> <span class="n">LPFC_EVENT_FABRIC_BUSY</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">pnode</span> <span class="o">&amp;&amp;</span> <span class="n">NLP_CHK_NODE_ACT</span><span class="p">(</span><span class="n">pnode</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fast_path_evt</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">fabric_evt</span><span class="p">.</span><span class="n">wwpn</span><span class="p">,</span>
					<span class="o">&amp;</span><span class="n">pnode</span><span class="o">-&gt;</span><span class="n">nlp_portname</span><span class="p">,</span>
					<span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_name</span><span class="p">));</span>
				<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fast_path_evt</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">fabric_evt</span><span class="p">.</span><span class="n">wwnn</span><span class="p">,</span>
					<span class="o">&amp;</span><span class="n">pnode</span><span class="o">-&gt;</span><span class="n">nlp_nodename</span><span class="p">,</span>
					<span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_name</span><span class="p">));</span>
			<span class="p">}</span>
			<span class="n">fast_path_evt</span><span class="o">-&gt;</span><span class="n">vport</span> <span class="o">=</span> <span class="n">vport</span><span class="p">;</span>
			<span class="n">fast_path_evt</span><span class="o">-&gt;</span><span class="n">work_evt</span><span class="p">.</span><span class="n">evt</span> <span class="o">=</span>
				<span class="n">LPFC_EVT_FASTPATH_MGMT_EVT</span><span class="p">;</span>
			<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
			<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fast_path_evt</span><span class="o">-&gt;</span><span class="n">work_evt</span><span class="p">.</span><span class="n">evt_listp</span><span class="p">,</span>
				<span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">work_list</span><span class="p">);</span>
			<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
			<span class="n">lpfc_worker_wake_up</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">IOSTAT_LOCAL_REJECT</span>:
		<span class="k">case</span> <span class="n">IOSTAT_REMOTE_STOP</span>:
			<span class="k">if</span> <span class="p">(</span><span class="n">lpfc_cmd</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">==</span> <span class="n">IOERR_ELXSEC_KEY_UNWRAP_ERROR</span> <span class="o">||</span>
			    <span class="n">lpfc_cmd</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">==</span>
					<span class="n">IOERR_ELXSEC_KEY_UNWRAP_COMPARE_ERROR</span> <span class="o">||</span>
			    <span class="n">lpfc_cmd</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">==</span> <span class="n">IOERR_ELXSEC_CRYPTO_ERROR</span> <span class="o">||</span>
			    <span class="n">lpfc_cmd</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">==</span>
					<span class="n">IOERR_ELXSEC_CRYPTO_COMPARE_ERROR</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">=</span> <span class="n">ScsiResult</span><span class="p">(</span><span class="n">DID_NO_CONNECT</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">lpfc_cmd</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">==</span> <span class="n">IOERR_INVALID_RPI</span> <span class="o">||</span>
			    <span class="n">lpfc_cmd</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">==</span> <span class="n">IOERR_NO_RESOURCES</span> <span class="o">||</span>
			    <span class="n">lpfc_cmd</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">==</span> <span class="n">IOERR_ABORT_REQUESTED</span> <span class="o">||</span>
			    <span class="n">lpfc_cmd</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">==</span> <span class="n">IOERR_SLER_CMD_RCV_FAILURE</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">=</span> <span class="n">ScsiResult</span><span class="p">(</span><span class="n">DID_REQUEUE</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">lpfc_cmd</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">==</span> <span class="n">IOERR_RX_DMA_FAILED</span> <span class="o">||</span>
			     <span class="n">lpfc_cmd</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">==</span> <span class="n">IOERR_TX_DMA_FAILED</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			     <span class="n">pIocbOut</span><span class="o">-&gt;</span><span class="n">iocb</span><span class="p">.</span><span class="n">unsli3</span><span class="p">.</span><span class="n">sli3_bg</span><span class="p">.</span><span class="n">bgstat</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">scsi_get_prot_op</span><span class="p">(</span><span class="n">cmd</span><span class="p">)</span> <span class="o">!=</span> <span class="n">SCSI_PROT_NORMAL</span><span class="p">)</span> <span class="p">{</span>
					<span class="cm">/*</span>
<span class="cm">					 * This is a response for a BG enabled</span>
<span class="cm">					 * cmd. Parse BG error</span>
<span class="cm">					 */</span>
					<span class="n">lpfc_parse_bg_err</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">lpfc_cmd</span><span class="p">,</span>
							<span class="n">pIocbOut</span><span class="p">);</span>
					<span class="k">break</span><span class="p">;</span>
				<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
					<span class="n">lpfc_printf_vlog</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">KERN_WARNING</span><span class="p">,</span>
							<span class="n">LOG_BG</span><span class="p">,</span>
							<span class="s">&quot;9031 non-zero BGSTAT &quot;</span>
							<span class="s">&quot;on unprotected cmd</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
				<span class="p">}</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">lpfc_cmd</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">==</span> <span class="n">IOSTAT_REMOTE_STOP</span><span class="p">)</span>
				<span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli_rev</span> <span class="o">==</span> <span class="n">LPFC_SLI_REV4</span><span class="p">)</span>
				<span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">pnode</span> <span class="o">&amp;&amp;</span> <span class="n">NLP_CHK_NODE_ACT</span><span class="p">(</span><span class="n">pnode</span><span class="p">)))</span> <span class="p">{</span>
				<span class="cm">/* This IO was aborted by the target, we don&#39;t</span>
<span class="cm">				 * know the rxid and because we did not send the</span>
<span class="cm">				 * ABTS we cannot generate and RRQ.</span>
<span class="cm">				 */</span>
				<span class="n">lpfc_set_rrq_active</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">pnode</span><span class="p">,</span>
					<span class="n">lpfc_cmd</span><span class="o">-&gt;</span><span class="n">cur_iocbq</span><span class="p">.</span><span class="n">sli4_lxritag</span><span class="p">,</span>
					<span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="cm">/* else: fall through */</span>
		<span class="nl">default:</span>
			<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">=</span> <span class="n">ScsiResult</span><span class="p">(</span><span class="n">DID_ERROR</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pnode</span> <span class="o">||</span> <span class="o">!</span><span class="n">NLP_CHK_NODE_ACT</span><span class="p">(</span><span class="n">pnode</span><span class="p">)</span>
		    <span class="o">||</span> <span class="p">(</span><span class="n">pnode</span><span class="o">-&gt;</span><span class="n">nlp_state</span> <span class="o">!=</span> <span class="n">NLP_STE_MAPPED_NODE</span><span class="p">))</span>
			<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">=</span> <span class="n">ScsiResult</span><span class="p">(</span><span class="n">DID_TRANSPORT_DISRUPTED</span><span class="p">,</span>
						 <span class="n">SAM_STAT_BUSY</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">=</span> <span class="n">ScsiResult</span><span class="p">(</span><span class="n">DID_OK</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">||</span> <span class="n">lpfc_cmd</span><span class="o">-&gt;</span><span class="n">fcp_rsp</span><span class="o">-&gt;</span><span class="n">rspSnsLen</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">uint32_t</span> <span class="o">*</span><span class="n">lp</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint32_t</span> <span class="o">*</span><span class="p">)</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">sense_buffer</span><span class="p">;</span>

		<span class="n">lpfc_printf_vlog</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">KERN_INFO</span><span class="p">,</span> <span class="n">LOG_FCP</span><span class="p">,</span>
				 <span class="s">&quot;0710 Iodone &lt;%d/%d&gt; cmd %p, error &quot;</span>
				 <span class="s">&quot;x%x SNS x%x x%x Data: x%x x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				 <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">,</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">lun</span><span class="p">,</span> <span class="n">cmd</span><span class="p">,</span>
				 <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">result</span><span class="p">,</span> <span class="o">*</span><span class="n">lp</span><span class="p">,</span> <span class="o">*</span><span class="p">(</span><span class="n">lp</span> <span class="o">+</span> <span class="mi">3</span><span class="p">),</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">retries</span><span class="p">,</span>
				 <span class="n">scsi_get_resid</span><span class="p">(</span><span class="n">cmd</span><span class="p">));</span>
	<span class="p">}</span>

	<span class="n">lpfc_update_stats</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">lpfc_cmd</span><span class="p">);</span>
	<span class="n">result</span> <span class="o">=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">result</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">cfg_max_scsicmpl_time</span> <span class="o">&amp;&amp;</span>
	   <span class="n">time_after</span><span class="p">(</span><span class="n">jiffies</span><span class="p">,</span> <span class="n">lpfc_cmd</span><span class="o">-&gt;</span><span class="n">start_time</span> <span class="o">+</span>
		<span class="n">msecs_to_jiffies</span><span class="p">(</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">cfg_max_scsicmpl_time</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pnode</span> <span class="o">&amp;&amp;</span> <span class="n">NLP_CHK_NODE_ACT</span><span class="p">(</span><span class="n">pnode</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">pnode</span><span class="o">-&gt;</span><span class="n">cmd_qdepth</span> <span class="o">&gt;</span>
				<span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pnode</span><span class="o">-&gt;</span><span class="n">cmd_pending</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
				<span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pnode</span><span class="o">-&gt;</span><span class="n">cmd_pending</span><span class="p">)</span> <span class="o">&gt;</span>
				<span class="n">LPFC_MIN_TGT_QDEPTH</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
				<span class="p">((</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">READ_10</span><span class="p">)</span> <span class="o">||</span>
				<span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">WRITE_10</span><span class="p">)))</span>
				<span class="n">pnode</span><span class="o">-&gt;</span><span class="n">cmd_qdepth</span> <span class="o">=</span>
					<span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pnode</span><span class="o">-&gt;</span><span class="n">cmd_pending</span><span class="p">);</span>

			<span class="n">pnode</span><span class="o">-&gt;</span><span class="n">last_change_time</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">pnode</span> <span class="o">&amp;&amp;</span> <span class="n">NLP_CHK_NODE_ACT</span><span class="p">(</span><span class="n">pnode</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">pnode</span><span class="o">-&gt;</span><span class="n">cmd_qdepth</span> <span class="o">&lt;</span> <span class="n">vport</span><span class="o">-&gt;</span><span class="n">cfg_tgt_queue_depth</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		   <span class="n">time_after</span><span class="p">(</span><span class="n">jiffies</span><span class="p">,</span> <span class="n">pnode</span><span class="o">-&gt;</span><span class="n">last_change_time</span> <span class="o">+</span>
			      <span class="n">msecs_to_jiffies</span><span class="p">(</span><span class="n">LPFC_TGTQ_INTERVAL</span><span class="p">)))</span> <span class="p">{</span>
			<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
			<span class="n">depth</span> <span class="o">=</span> <span class="n">pnode</span><span class="o">-&gt;</span><span class="n">cmd_qdepth</span> <span class="o">*</span> <span class="n">LPFC_TGTQ_RAMPUP_PCENT</span>
				<span class="o">/</span> <span class="mi">100</span><span class="p">;</span>
			<span class="n">depth</span> <span class="o">=</span> <span class="n">depth</span> <span class="o">?</span> <span class="n">depth</span> <span class="o">:</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">pnode</span><span class="o">-&gt;</span><span class="n">cmd_qdepth</span> <span class="o">+=</span> <span class="n">depth</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">pnode</span><span class="o">-&gt;</span><span class="n">cmd_qdepth</span> <span class="o">&gt;</span> <span class="n">vport</span><span class="o">-&gt;</span><span class="n">cfg_tgt_queue_depth</span><span class="p">)</span>
				<span class="n">pnode</span><span class="o">-&gt;</span><span class="n">cmd_qdepth</span> <span class="o">=</span> <span class="n">vport</span><span class="o">-&gt;</span><span class="n">cfg_tgt_queue_depth</span><span class="p">;</span>
			<span class="n">pnode</span><span class="o">-&gt;</span><span class="n">last_change_time</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span>
			<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">lpfc_scsi_unprep_dma_buf</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">lpfc_cmd</span><span class="p">);</span>

	<span class="cm">/* The sdev is not guaranteed to be valid post scsi_done upcall. */</span>
	<span class="n">queue_depth</span> <span class="o">=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">queue_depth</span><span class="p">;</span>
	<span class="n">scsi_id</span> <span class="o">=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">;</span>
	<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scsi_done</span><span class="p">(</span><span class="n">cmd</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">cfg_poll</span> <span class="o">&amp;</span> <span class="n">ENABLE_FCP_RING_POLLING</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * If there is a thread waiting for command completion</span>
<span class="cm">		 * wake up the thread.</span>
<span class="cm">		 */</span>
		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="n">lpfc_cmd</span><span class="o">-&gt;</span><span class="n">pCmd</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">lpfc_cmd</span><span class="o">-&gt;</span><span class="n">waitq</span><span class="p">)</span>
			<span class="n">wake_up</span><span class="p">(</span><span class="n">lpfc_cmd</span><span class="o">-&gt;</span><span class="n">waitq</span><span class="p">);</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="n">lpfc_release_scsi_buf</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">lpfc_cmd</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">result</span><span class="p">)</span>
		<span class="n">lpfc_rampup_queue_depth</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">queue_depth</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Check for queue full.  If the lun is reporting queue full, then</span>
<span class="cm">	 * back off the lun queue depth to prevent target overloads.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">==</span> <span class="n">SAM_STAT_TASK_SET_FULL</span> <span class="o">&amp;&amp;</span> <span class="n">pnode</span> <span class="o">&amp;&amp;</span>
	    <span class="n">NLP_CHK_NODE_ACT</span><span class="p">(</span><span class="n">pnode</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">shost_for_each_device</span><span class="p">(</span><span class="n">tmp_sdev</span><span class="p">,</span> <span class="n">shost</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">tmp_sdev</span><span class="o">-&gt;</span><span class="n">id</span> <span class="o">!=</span> <span class="n">scsi_id</span><span class="p">)</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="n">depth</span> <span class="o">=</span> <span class="n">scsi_track_queue_full</span><span class="p">(</span><span class="n">tmp_sdev</span><span class="p">,</span>
						      <span class="n">tmp_sdev</span><span class="o">-&gt;</span><span class="n">queue_depth</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">depth</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="n">lpfc_printf_vlog</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">KERN_WARNING</span><span class="p">,</span> <span class="n">LOG_FCP</span><span class="p">,</span>
					 <span class="s">&quot;0711 detected queue full - lun queue &quot;</span>
					 <span class="s">&quot;depth adjusted to %d.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">depth</span><span class="p">);</span>
			<span class="n">lpfc_send_sdev_queuedepth_change_event</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">vport</span><span class="p">,</span>
							       <span class="n">pnode</span><span class="p">,</span>
							       <span class="n">tmp_sdev</span><span class="o">-&gt;</span><span class="n">lun</span><span class="p">,</span>
							       <span class="n">depth</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">depth</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * If there is a thread waiting for command completion</span>
<span class="cm">	 * wake up the thread.</span>
<span class="cm">	 */</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">lpfc_cmd</span><span class="o">-&gt;</span><span class="n">pCmd</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">lpfc_cmd</span><span class="o">-&gt;</span><span class="n">waitq</span><span class="p">)</span>
		<span class="n">wake_up</span><span class="p">(</span><span class="n">lpfc_cmd</span><span class="o">-&gt;</span><span class="n">waitq</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">lpfc_release_scsi_buf</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">lpfc_cmd</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_fcpcmd_to_iocb - copy the fcp_cmd data into the IOCB</span>
<span class="cm"> * @data: A pointer to the immediate command data portion of the IOCB.</span>
<span class="cm"> * @fcp_cmnd: The FCP Command that is provided by the SCSI layer.</span>
<span class="cm"> *</span>
<span class="cm"> * The routine copies the entire FCP command from @fcp_cmnd to @data while</span>
<span class="cm"> * byte swapping the data to big endian format for transmission on the wire.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">lpfc_fcpcmd_to_iocb</span><span class="p">(</span><span class="kt">uint8_t</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="k">struct</span> <span class="n">fcp_cmnd</span> <span class="o">*</span><span class="n">fcp_cmnd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">fcp_cmnd</span><span class="p">);</span>
	     <span class="n">i</span> <span class="o">+=</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">uint32_t</span><span class="p">),</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="p">((</span><span class="kt">uint32_t</span> <span class="o">*</span><span class="p">)</span><span class="n">data</span><span class="p">)[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">cpu_to_be32</span><span class="p">(((</span><span class="kt">uint32_t</span> <span class="o">*</span><span class="p">)</span><span class="n">fcp_cmnd</span><span class="p">)[</span><span class="n">j</span><span class="p">]);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_scsi_prep_cmnd - Wrapper func for convert scsi cmnd to FCP info unit</span>
<span class="cm"> * @vport: The virtual port for which this call is being executed.</span>
<span class="cm"> * @lpfc_cmd: The scsi command which needs to send.</span>
<span class="cm"> * @pnode: Pointer to lpfc_nodelist.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine initializes fcp_cmnd and iocb data structure from scsi command</span>
<span class="cm"> * to transfer for device with SLI3 interface spec.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">lpfc_scsi_prep_cmnd</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="n">vport</span><span class="p">,</span> <span class="k">struct</span> <span class="n">lpfc_scsi_buf</span> <span class="o">*</span><span class="n">lpfc_cmd</span><span class="p">,</span>
		    <span class="k">struct</span> <span class="n">lpfc_nodelist</span> <span class="o">*</span><span class="n">pnode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span> <span class="o">=</span> <span class="n">vport</span><span class="o">-&gt;</span><span class="n">phba</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="n">scsi_cmnd</span> <span class="o">=</span> <span class="n">lpfc_cmd</span><span class="o">-&gt;</span><span class="n">pCmd</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fcp_cmnd</span> <span class="o">*</span><span class="n">fcp_cmnd</span> <span class="o">=</span> <span class="n">lpfc_cmd</span><span class="o">-&gt;</span><span class="n">fcp_cmnd</span><span class="p">;</span>
	<span class="n">IOCB_t</span> <span class="o">*</span><span class="n">iocb_cmd</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">lpfc_cmd</span><span class="o">-&gt;</span><span class="n">cur_iocbq</span><span class="p">.</span><span class="n">iocb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_iocbq</span> <span class="o">*</span><span class="n">piocbq</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">lpfc_cmd</span><span class="o">-&gt;</span><span class="n">cur_iocbq</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">datadir</span> <span class="o">=</span> <span class="n">scsi_cmnd</span><span class="o">-&gt;</span><span class="n">sc_data_direction</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">tag</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pnode</span> <span class="o">||</span> <span class="o">!</span><span class="n">NLP_CHK_NODE_ACT</span><span class="p">(</span><span class="n">pnode</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">lpfc_cmd</span><span class="o">-&gt;</span><span class="n">fcp_rsp</span><span class="o">-&gt;</span><span class="n">rspSnsLen</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="cm">/* clear task management bits */</span>
	<span class="n">lpfc_cmd</span><span class="o">-&gt;</span><span class="n">fcp_cmnd</span><span class="o">-&gt;</span><span class="n">fcpCntl2</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">int_to_scsilun</span><span class="p">(</span><span class="n">lpfc_cmd</span><span class="o">-&gt;</span><span class="n">pCmd</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">lun</span><span class="p">,</span>
			<span class="o">&amp;</span><span class="n">lpfc_cmd</span><span class="o">-&gt;</span><span class="n">fcp_cmnd</span><span class="o">-&gt;</span><span class="n">fcp_lun</span><span class="p">);</span>

	<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fcp_cmnd</span><span class="o">-&gt;</span><span class="n">fcpCdb</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="n">LPFC_FCP_CDB_LEN</span><span class="p">);</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fcp_cmnd</span><span class="o">-&gt;</span><span class="n">fcpCdb</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">scsi_cmnd</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">,</span> <span class="n">scsi_cmnd</span><span class="o">-&gt;</span><span class="n">cmd_len</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">scsi_populate_tag_msg</span><span class="p">(</span><span class="n">scsi_cmnd</span><span class="p">,</span> <span class="n">tag</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">tag</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">HEAD_OF_QUEUE_TAG</span>:
			<span class="n">fcp_cmnd</span><span class="o">-&gt;</span><span class="n">fcpCntl1</span> <span class="o">=</span> <span class="n">HEAD_OF_Q</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">ORDERED_QUEUE_TAG</span>:
			<span class="n">fcp_cmnd</span><span class="o">-&gt;</span><span class="n">fcpCntl1</span> <span class="o">=</span> <span class="n">ORDERED_Q</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="nl">default:</span>
			<span class="n">fcp_cmnd</span><span class="o">-&gt;</span><span class="n">fcpCntl1</span> <span class="o">=</span> <span class="n">SIMPLE_Q</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">fcp_cmnd</span><span class="o">-&gt;</span><span class="n">fcpCntl1</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * There are three possibilities here - use scatter-gather segment, use</span>
<span class="cm">	 * the single mapping, or neither.  Start the lpfc command prep by</span>
<span class="cm">	 * bumping the bpl beyond the fcp_cmnd and fcp_rsp regions to the first</span>
<span class="cm">	 * data bde entry.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">scsi_sg_count</span><span class="p">(</span><span class="n">scsi_cmnd</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">datadir</span> <span class="o">==</span> <span class="n">DMA_TO_DEVICE</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">iocb_cmd</span><span class="o">-&gt;</span><span class="n">ulpCommand</span> <span class="o">=</span> <span class="n">CMD_FCP_IWRITE64_CR</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli_rev</span> <span class="o">&lt;</span> <span class="n">LPFC_SLI_REV4</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">iocb_cmd</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">fcpi</span><span class="p">.</span><span class="n">fcpi_parm</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
				<span class="n">iocb_cmd</span><span class="o">-&gt;</span><span class="n">ulpPU</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span>
				<span class="n">iocb_cmd</span><span class="o">-&gt;</span><span class="n">ulpPU</span> <span class="o">=</span> <span class="n">PARM_READ_CHECK</span><span class="p">;</span>
			<span class="n">fcp_cmnd</span><span class="o">-&gt;</span><span class="n">fcpCntl3</span> <span class="o">=</span> <span class="n">WRITE_DATA</span><span class="p">;</span>
			<span class="n">phba</span><span class="o">-&gt;</span><span class="n">fc4OutputRequests</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">iocb_cmd</span><span class="o">-&gt;</span><span class="n">ulpCommand</span> <span class="o">=</span> <span class="n">CMD_FCP_IREAD64_CR</span><span class="p">;</span>
			<span class="n">iocb_cmd</span><span class="o">-&gt;</span><span class="n">ulpPU</span> <span class="o">=</span> <span class="n">PARM_READ_CHECK</span><span class="p">;</span>
			<span class="n">fcp_cmnd</span><span class="o">-&gt;</span><span class="n">fcpCntl3</span> <span class="o">=</span> <span class="n">READ_DATA</span><span class="p">;</span>
			<span class="n">phba</span><span class="o">-&gt;</span><span class="n">fc4InputRequests</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">iocb_cmd</span><span class="o">-&gt;</span><span class="n">ulpCommand</span> <span class="o">=</span> <span class="n">CMD_FCP_ICMND64_CR</span><span class="p">;</span>
		<span class="n">iocb_cmd</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">fcpi</span><span class="p">.</span><span class="n">fcpi_parm</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">iocb_cmd</span><span class="o">-&gt;</span><span class="n">ulpPU</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">fcp_cmnd</span><span class="o">-&gt;</span><span class="n">fcpCntl3</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">fc4ControlRequests</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli_rev</span> <span class="o">==</span> <span class="mi">3</span> <span class="o">&amp;&amp;</span>
	    <span class="o">!</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli3_options</span> <span class="o">&amp;</span> <span class="n">LPFC_SLI3_BG_ENABLED</span><span class="p">))</span>
		<span class="n">lpfc_fcpcmd_to_iocb</span><span class="p">(</span><span class="n">iocb_cmd</span><span class="o">-&gt;</span><span class="n">unsli3</span><span class="p">.</span><span class="n">fcp_ext</span><span class="p">.</span><span class="n">icd</span><span class="p">,</span> <span class="n">fcp_cmnd</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * Finish initializing those IOCB fields that are independent</span>
<span class="cm">	 * of the scsi_cmnd request_buffer</span>
<span class="cm">	 */</span>
	<span class="n">piocbq</span><span class="o">-&gt;</span><span class="n">iocb</span><span class="p">.</span><span class="n">ulpContext</span> <span class="o">=</span> <span class="n">pnode</span><span class="o">-&gt;</span><span class="n">nlp_rpi</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli_rev</span> <span class="o">==</span> <span class="n">LPFC_SLI_REV4</span><span class="p">)</span>
		<span class="n">piocbq</span><span class="o">-&gt;</span><span class="n">iocb</span><span class="p">.</span><span class="n">ulpContext</span> <span class="o">=</span>
		  <span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">rpi_ids</span><span class="p">[</span><span class="n">pnode</span><span class="o">-&gt;</span><span class="n">nlp_rpi</span><span class="p">];</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pnode</span><span class="o">-&gt;</span><span class="n">nlp_fcp_info</span> <span class="o">&amp;</span> <span class="n">NLP_FCP_2_DEVICE</span><span class="p">)</span>
		<span class="n">piocbq</span><span class="o">-&gt;</span><span class="n">iocb</span><span class="p">.</span><span class="n">ulpFCP2Rcvy</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">piocbq</span><span class="o">-&gt;</span><span class="n">iocb</span><span class="p">.</span><span class="n">ulpFCP2Rcvy</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">piocbq</span><span class="o">-&gt;</span><span class="n">iocb</span><span class="p">.</span><span class="n">ulpClass</span> <span class="o">=</span> <span class="p">(</span><span class="n">pnode</span><span class="o">-&gt;</span><span class="n">nlp_fcp_info</span> <span class="o">&amp;</span> <span class="mh">0x0f</span><span class="p">);</span>
	<span class="n">piocbq</span><span class="o">-&gt;</span><span class="n">context1</span>  <span class="o">=</span> <span class="n">lpfc_cmd</span><span class="p">;</span>
	<span class="n">piocbq</span><span class="o">-&gt;</span><span class="n">iocb_cmpl</span> <span class="o">=</span> <span class="n">lpfc_scsi_cmd_iocb_cmpl</span><span class="p">;</span>
	<span class="n">piocbq</span><span class="o">-&gt;</span><span class="n">iocb</span><span class="p">.</span><span class="n">ulpTimeout</span> <span class="o">=</span> <span class="n">lpfc_cmd</span><span class="o">-&gt;</span><span class="n">timeout</span><span class="p">;</span>
	<span class="n">piocbq</span><span class="o">-&gt;</span><span class="n">vport</span> <span class="o">=</span> <span class="n">vport</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_scsi_prep_task_mgmt_cmd - Convert SLI3 scsi TM cmd to FCP info unit</span>
<span class="cm"> * @vport: The virtual port for which this call is being executed.</span>
<span class="cm"> * @lpfc_cmd: Pointer to lpfc_scsi_buf data structure.</span>
<span class="cm"> * @lun: Logical unit number.</span>
<span class="cm"> * @task_mgmt_cmd: SCSI task management command.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine creates FCP information unit corresponding to @task_mgmt_cmd</span>
<span class="cm"> * for device with SLI-3 interface spec.</span>
<span class="cm"> *</span>
<span class="cm"> * Return codes:</span>
<span class="cm"> *   0 - Error</span>
<span class="cm"> *   1 - Success</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">lpfc_scsi_prep_task_mgmt_cmd</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="n">vport</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">lpfc_scsi_buf</span> <span class="o">*</span><span class="n">lpfc_cmd</span><span class="p">,</span>
			     <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">lun</span><span class="p">,</span>
			     <span class="kt">uint8_t</span> <span class="n">task_mgmt_cmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpfc_iocbq</span> <span class="o">*</span><span class="n">piocbq</span><span class="p">;</span>
	<span class="n">IOCB_t</span> <span class="o">*</span><span class="n">piocb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fcp_cmnd</span> <span class="o">*</span><span class="n">fcp_cmnd</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_rport_data</span> <span class="o">*</span><span class="n">rdata</span> <span class="o">=</span> <span class="n">lpfc_cmd</span><span class="o">-&gt;</span><span class="n">rdata</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_nodelist</span> <span class="o">*</span><span class="n">ndlp</span> <span class="o">=</span> <span class="n">rdata</span><span class="o">-&gt;</span><span class="n">pnode</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ndlp</span> <span class="o">||</span> <span class="o">!</span><span class="n">NLP_CHK_NODE_ACT</span><span class="p">(</span><span class="n">ndlp</span><span class="p">)</span> <span class="o">||</span>
	    <span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_state</span> <span class="o">!=</span> <span class="n">NLP_STE_MAPPED_NODE</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">piocbq</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">lpfc_cmd</span><span class="o">-&gt;</span><span class="n">cur_iocbq</span><span class="p">);</span>
	<span class="n">piocbq</span><span class="o">-&gt;</span><span class="n">vport</span> <span class="o">=</span> <span class="n">vport</span><span class="p">;</span>

	<span class="n">piocb</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">piocbq</span><span class="o">-&gt;</span><span class="n">iocb</span><span class="p">;</span>

	<span class="n">fcp_cmnd</span> <span class="o">=</span> <span class="n">lpfc_cmd</span><span class="o">-&gt;</span><span class="n">fcp_cmnd</span><span class="p">;</span>
	<span class="cm">/* Clear out any old data in the FCP command area */</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">fcp_cmnd</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">fcp_cmnd</span><span class="p">));</span>
	<span class="n">int_to_scsilun</span><span class="p">(</span><span class="n">lun</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fcp_cmnd</span><span class="o">-&gt;</span><span class="n">fcp_lun</span><span class="p">);</span>
	<span class="n">fcp_cmnd</span><span class="o">-&gt;</span><span class="n">fcpCntl2</span> <span class="o">=</span> <span class="n">task_mgmt_cmd</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli_rev</span> <span class="o">==</span> <span class="mi">3</span> <span class="o">&amp;&amp;</span>
	    <span class="o">!</span><span class="p">(</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli3_options</span> <span class="o">&amp;</span> <span class="n">LPFC_SLI3_BG_ENABLED</span><span class="p">))</span>
		<span class="n">lpfc_fcpcmd_to_iocb</span><span class="p">(</span><span class="n">piocb</span><span class="o">-&gt;</span><span class="n">unsli3</span><span class="p">.</span><span class="n">fcp_ext</span><span class="p">.</span><span class="n">icd</span><span class="p">,</span> <span class="n">fcp_cmnd</span><span class="p">);</span>
	<span class="n">piocb</span><span class="o">-&gt;</span><span class="n">ulpCommand</span> <span class="o">=</span> <span class="n">CMD_FCP_ICMND64_CR</span><span class="p">;</span>
	<span class="n">piocb</span><span class="o">-&gt;</span><span class="n">ulpContext</span> <span class="o">=</span> <span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_rpi</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli_rev</span> <span class="o">==</span> <span class="n">LPFC_SLI_REV4</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">piocb</span><span class="o">-&gt;</span><span class="n">ulpContext</span> <span class="o">=</span>
		  <span class="n">vport</span><span class="o">-&gt;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">rpi_ids</span><span class="p">[</span><span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_rpi</span><span class="p">];</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_fcp_info</span> <span class="o">&amp;</span> <span class="n">NLP_FCP_2_DEVICE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">piocb</span><span class="o">-&gt;</span><span class="n">ulpFCP2Rcvy</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">piocb</span><span class="o">-&gt;</span><span class="n">ulpClass</span> <span class="o">=</span> <span class="p">(</span><span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_fcp_info</span> <span class="o">&amp;</span> <span class="mh">0x0f</span><span class="p">);</span>

	<span class="cm">/* ulpTimeout is only one byte */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">lpfc_cmd</span><span class="o">-&gt;</span><span class="n">timeout</span> <span class="o">&gt;</span> <span class="mh">0xff</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Do not timeout the command at the firmware level.</span>
<span class="cm">		 * The driver will provide the timeout mechanism.</span>
<span class="cm">		 */</span>
		<span class="n">piocb</span><span class="o">-&gt;</span><span class="n">ulpTimeout</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">piocb</span><span class="o">-&gt;</span><span class="n">ulpTimeout</span> <span class="o">=</span> <span class="n">lpfc_cmd</span><span class="o">-&gt;</span><span class="n">timeout</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli_rev</span> <span class="o">==</span> <span class="n">LPFC_SLI_REV4</span><span class="p">)</span>
		<span class="n">lpfc_sli4_set_rsp_sgl_last</span><span class="p">(</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">phba</span><span class="p">,</span> <span class="n">lpfc_cmd</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_scsi_api_table_setup - Set up scsi api function jump table</span>
<span class="cm"> * @phba: The hba struct for which this call is being executed.</span>
<span class="cm"> * @dev_grp: The HBA PCI-Device group number.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine sets up the SCSI interface API function jump table in @phba</span>
<span class="cm"> * struct.</span>
<span class="cm"> * Returns: 0 - success, -ENODEV - failure.</span>
<span class="cm"> **/</span>
<span class="kt">int</span>
<span class="nf">lpfc_scsi_api_table_setup</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="n">dev_grp</span><span class="p">)</span>
<span class="p">{</span>

	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">lpfc_scsi_unprep_dma_buf</span> <span class="o">=</span> <span class="n">lpfc_scsi_unprep_dma_buf</span><span class="p">;</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">lpfc_scsi_prep_cmnd</span> <span class="o">=</span> <span class="n">lpfc_scsi_prep_cmnd</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">dev_grp</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">LPFC_PCI_DEV_LP</span>:
		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">lpfc_new_scsi_buf</span> <span class="o">=</span> <span class="n">lpfc_new_scsi_buf_s3</span><span class="p">;</span>
		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">lpfc_scsi_prep_dma_buf</span> <span class="o">=</span> <span class="n">lpfc_scsi_prep_dma_buf_s3</span><span class="p">;</span>
		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">lpfc_bg_scsi_prep_dma_buf</span> <span class="o">=</span> <span class="n">lpfc_bg_scsi_prep_dma_buf_s3</span><span class="p">;</span>
		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">lpfc_release_scsi_buf</span> <span class="o">=</span> <span class="n">lpfc_release_scsi_buf_s3</span><span class="p">;</span>
		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">lpfc_get_scsi_buf</span> <span class="o">=</span> <span class="n">lpfc_get_scsi_buf_s3</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">LPFC_PCI_DEV_OC</span>:
		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">lpfc_new_scsi_buf</span> <span class="o">=</span> <span class="n">lpfc_new_scsi_buf_s4</span><span class="p">;</span>
		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">lpfc_scsi_prep_dma_buf</span> <span class="o">=</span> <span class="n">lpfc_scsi_prep_dma_buf_s4</span><span class="p">;</span>
		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">lpfc_bg_scsi_prep_dma_buf</span> <span class="o">=</span> <span class="n">lpfc_bg_scsi_prep_dma_buf_s4</span><span class="p">;</span>
		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">lpfc_release_scsi_buf</span> <span class="o">=</span> <span class="n">lpfc_release_scsi_buf_s4</span><span class="p">;</span>
		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">lpfc_get_scsi_buf</span> <span class="o">=</span> <span class="n">lpfc_get_scsi_buf_s4</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_INIT</span><span class="p">,</span>
				<span class="s">&quot;1418 Invalid HBA PCI-device group: 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">dev_grp</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">lpfc_rampdown_queue_depth</span> <span class="o">=</span> <span class="n">lpfc_rampdown_queue_depth</span><span class="p">;</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">lpfc_scsi_cmd_iocb_cmpl</span> <span class="o">=</span> <span class="n">lpfc_scsi_cmd_iocb_cmpl</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_taskmgmt_def_cmpl - IOCB completion routine for task management command</span>
<span class="cm"> * @phba: The Hba for which this call is being executed.</span>
<span class="cm"> * @cmdiocbq: Pointer to lpfc_iocbq data structure.</span>
<span class="cm"> * @rspiocbq: Pointer to lpfc_iocbq data structure.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine is IOCB completion routine for device reset and target reset</span>
<span class="cm"> * routine. This routine release scsi buffer associated with lpfc_cmd.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">lpfc_tskmgmt_def_cmpl</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">lpfc_iocbq</span> <span class="o">*</span><span class="n">cmdiocbq</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">lpfc_iocbq</span> <span class="o">*</span><span class="n">rspiocbq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpfc_scsi_buf</span> <span class="o">*</span><span class="n">lpfc_cmd</span> <span class="o">=</span>
		<span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_scsi_buf</span> <span class="o">*</span><span class="p">)</span> <span class="n">cmdiocbq</span><span class="o">-&gt;</span><span class="n">context1</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">lpfc_cmd</span><span class="p">)</span>
		<span class="n">lpfc_release_scsi_buf</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">lpfc_cmd</span><span class="p">);</span>
	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_info - Info entry point of scsi_host_template data structure</span>
<span class="cm"> * @host: The scsi host for which this call is being executed.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine provides module information about hba.</span>
<span class="cm"> *</span>
<span class="cm"> * Reutrn code:</span>
<span class="cm"> *   Pointer to char - Success.</span>
<span class="cm"> **/</span>
<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span>
<span class="nf">lpfc_info</span><span class="p">(</span><span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">host</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="n">vport</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="p">)</span> <span class="n">host</span><span class="o">-&gt;</span><span class="n">hostdata</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_hba</span>   <span class="o">*</span><span class="n">phba</span> <span class="o">=</span> <span class="n">vport</span><span class="o">-&gt;</span><span class="n">phba</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">len</span><span class="p">;</span>
	<span class="k">static</span> <span class="kt">char</span>  <span class="n">lpfcinfobuf</span><span class="p">[</span><span class="mi">384</span><span class="p">];</span>

	<span class="n">memset</span><span class="p">(</span><span class="n">lpfcinfobuf</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">384</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">phba</span> <span class="o">&amp;&amp;</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">pcidev</span><span class="p">){</span>
		<span class="n">strncpy</span><span class="p">(</span><span class="n">lpfcinfobuf</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">ModelDesc</span><span class="p">,</span> <span class="mi">256</span><span class="p">);</span>
		<span class="n">len</span> <span class="o">=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">lpfcinfobuf</span><span class="p">);</span>
		<span class="n">snprintf</span><span class="p">(</span><span class="n">lpfcinfobuf</span> <span class="o">+</span> <span class="n">len</span><span class="p">,</span>
			<span class="mi">384</span><span class="o">-</span><span class="n">len</span><span class="p">,</span>
			<span class="s">&quot; on PCI bus %02x device %02x irq %d&quot;</span><span class="p">,</span>
			<span class="n">phba</span><span class="o">-&gt;</span><span class="n">pcidev</span><span class="o">-&gt;</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">number</span><span class="p">,</span>
			<span class="n">phba</span><span class="o">-&gt;</span><span class="n">pcidev</span><span class="o">-&gt;</span><span class="n">devfn</span><span class="p">,</span>
			<span class="n">phba</span><span class="o">-&gt;</span><span class="n">pcidev</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">);</span>
		<span class="n">len</span> <span class="o">=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">lpfcinfobuf</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">Port</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="p">{</span>
			<span class="n">snprintf</span><span class="p">(</span><span class="n">lpfcinfobuf</span> <span class="o">+</span> <span class="n">len</span><span class="p">,</span>
				 <span class="mi">384</span><span class="o">-</span><span class="n">len</span><span class="p">,</span>
				 <span class="s">&quot; port %s&quot;</span><span class="p">,</span>
				 <span class="n">phba</span><span class="o">-&gt;</span><span class="n">Port</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">len</span> <span class="o">=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">lpfcinfobuf</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">link_state</span><span class="p">.</span><span class="n">logical_speed</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">snprintf</span><span class="p">(</span><span class="n">lpfcinfobuf</span> <span class="o">+</span> <span class="n">len</span><span class="p">,</span>
				 <span class="mi">384</span><span class="o">-</span><span class="n">len</span><span class="p">,</span>
				 <span class="s">&quot; Logical Link Speed: %d Mbps&quot;</span><span class="p">,</span>
				 <span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">link_state</span><span class="p">.</span><span class="n">logical_speed</span> <span class="o">*</span> <span class="mi">10</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">lpfcinfobuf</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_poll_rearm_time - Routine to modify fcp_poll timer of hba</span>
<span class="cm"> * @phba: The Hba for which this call is being executed.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine modifies fcp_poll_timer  field of @phba by cfg_poll_tmo.</span>
<span class="cm"> * The default value of cfg_poll_tmo is 10 milliseconds.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="n">__inline__</span> <span class="kt">void</span> <span class="nf">lpfc_poll_rearm_timer</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span> <span class="n">phba</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>  <span class="n">poll_tmo_expires</span> <span class="o">=</span>
		<span class="p">(</span><span class="n">jiffies</span> <span class="o">+</span> <span class="n">msecs_to_jiffies</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">cfg_poll_tmo</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli</span><span class="p">.</span><span class="n">ring</span><span class="p">[</span><span class="n">LPFC_FCP_RING</span><span class="p">].</span><span class="n">txcmplq_cnt</span><span class="p">)</span>
		<span class="n">mod_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">fcp_poll_timer</span><span class="p">,</span>
			  <span class="n">poll_tmo_expires</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_poll_start_timer - Routine to start fcp_poll_timer of HBA</span>
<span class="cm"> * @phba: The Hba for which this call is being executed.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine starts the fcp_poll_timer of @phba.</span>
<span class="cm"> **/</span>
<span class="kt">void</span> <span class="nf">lpfc_poll_start_timer</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span> <span class="n">phba</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">lpfc_poll_rearm_timer</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_poll_timeout - Restart polling timer</span>
<span class="cm"> * @ptr: Map to lpfc_hba data structure pointer.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine restarts fcp_poll timer, when FCP ring  polling is enable</span>
<span class="cm"> * and FCP Ring interrupt is disable.</span>
<span class="cm"> **/</span>

<span class="kt">void</span> <span class="nf">lpfc_poll_timeout</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ptr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="p">)</span> <span class="n">ptr</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">cfg_poll</span> <span class="o">&amp;</span> <span class="n">ENABLE_FCP_RING_POLLING</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lpfc_sli_handle_fast_ring_event</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span>
			<span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli</span><span class="p">.</span><span class="n">ring</span><span class="p">[</span><span class="n">LPFC_FCP_RING</span><span class="p">],</span> <span class="n">HA_R0RE_REQ</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">cfg_poll</span> <span class="o">&amp;</span> <span class="n">DISABLE_FCP_RING_INT</span><span class="p">)</span>
			<span class="n">lpfc_poll_rearm_timer</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_queuecommand - scsi_host_template queuecommand entry point</span>
<span class="cm"> * @cmnd: Pointer to scsi_cmnd data structure.</span>
<span class="cm"> * @done: Pointer to done routine.</span>
<span class="cm"> *</span>
<span class="cm"> * Driver registers this routine to scsi midlayer to submit a @cmd to process.</span>
<span class="cm"> * This routine prepares an IOCB from scsi command and provides to firmware.</span>
<span class="cm"> * The @done callback is invoked after driver finished processing the command.</span>
<span class="cm"> *</span>
<span class="cm"> * Return value :</span>
<span class="cm"> *   0 - Success</span>
<span class="cm"> *   SCSI_MLQUEUE_HOST_BUSY - Block all devices served by this host temporarily.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">lpfc_queuecommand_lck</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="n">cmnd</span><span class="p">,</span> <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">done</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="p">))</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span>  <span class="o">*</span><span class="n">shost</span> <span class="o">=</span> <span class="n">cmnd</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="n">vport</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="p">)</span> <span class="n">shost</span><span class="o">-&gt;</span><span class="n">hostdata</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_hba</span>   <span class="o">*</span><span class="n">phba</span> <span class="o">=</span> <span class="n">vport</span><span class="o">-&gt;</span><span class="n">phba</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_rport_data</span> <span class="o">*</span><span class="n">rdata</span> <span class="o">=</span> <span class="n">cmnd</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">hostdata</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_nodelist</span> <span class="o">*</span><span class="n">ndlp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_scsi_buf</span> <span class="o">*</span><span class="n">lpfc_cmd</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fc_rport</span> <span class="o">*</span><span class="n">rport</span> <span class="o">=</span> <span class="n">starget_to_rport</span><span class="p">(</span><span class="n">scsi_target</span><span class="p">(</span><span class="n">cmnd</span><span class="o">-&gt;</span><span class="n">device</span><span class="p">));</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">fc_remote_port_chkready</span><span class="p">(</span><span class="n">rport</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cmnd</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">=</span> <span class="n">err</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out_fail_command</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">ndlp</span> <span class="o">=</span> <span class="n">rdata</span><span class="o">-&gt;</span><span class="n">pnode</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">scsi_get_prot_op</span><span class="p">(</span><span class="n">cmnd</span><span class="p">)</span> <span class="o">!=</span> <span class="n">SCSI_PROT_NORMAL</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		<span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli3_options</span> <span class="o">&amp;</span> <span class="n">LPFC_SLI3_BG_ENABLED</span><span class="p">)))</span> <span class="p">{</span>

		<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_BG</span><span class="p">,</span>
				<span class="s">&quot;9058 BLKGRD: ERROR: rcvd protected cmd:%02x&quot;</span>
				<span class="s">&quot; op:%02x str=%s without registering for&quot;</span>
				<span class="s">&quot; BlockGuard - Rejecting command</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">cmnd</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">scsi_get_prot_op</span><span class="p">(</span><span class="n">cmnd</span><span class="p">),</span>
				<span class="n">dif_op_str</span><span class="p">[</span><span class="n">scsi_get_prot_op</span><span class="p">(</span><span class="n">cmnd</span><span class="p">)]);</span>
		<span class="k">goto</span> <span class="n">out_fail_command</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Catch race where our node has transitioned, but the</span>
<span class="cm">	 * transport is still transitioning.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ndlp</span> <span class="o">||</span> <span class="o">!</span><span class="n">NLP_CHK_NODE_ACT</span><span class="p">(</span><span class="n">ndlp</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">cmnd</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">=</span> <span class="n">ScsiResult</span><span class="p">(</span><span class="n">DID_IMM_RETRY</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_fail_command</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">cmd_pending</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">cmd_qdepth</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_tgt_busy</span><span class="p">;</span>

	<span class="n">lpfc_cmd</span> <span class="o">=</span> <span class="n">lpfc_get_scsi_buf</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">ndlp</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">lpfc_cmd</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lpfc_rampdown_queue_depth</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>

		<span class="n">lpfc_printf_vlog</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">KERN_INFO</span><span class="p">,</span> <span class="n">LOG_FCP</span><span class="p">,</span>
				 <span class="s">&quot;0707 driver&#39;s buffer pool is empty, &quot;</span>
				 <span class="s">&quot;IO busied</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_host_busy</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Store the midlayer&#39;s command structure for the completion phase</span>
<span class="cm">	 * and complete the command initialization.</span>
<span class="cm">	 */</span>
	<span class="n">lpfc_cmd</span><span class="o">-&gt;</span><span class="n">pCmd</span>  <span class="o">=</span> <span class="n">cmnd</span><span class="p">;</span>
	<span class="n">lpfc_cmd</span><span class="o">-&gt;</span><span class="n">rdata</span> <span class="o">=</span> <span class="n">rdata</span><span class="p">;</span>
	<span class="n">lpfc_cmd</span><span class="o">-&gt;</span><span class="n">timeout</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">lpfc_cmd</span><span class="o">-&gt;</span><span class="n">start_time</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span>
	<span class="n">cmnd</span><span class="o">-&gt;</span><span class="n">host_scribble</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">lpfc_cmd</span><span class="p">;</span>
	<span class="n">cmnd</span><span class="o">-&gt;</span><span class="n">scsi_done</span> <span class="o">=</span> <span class="n">done</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">scsi_get_prot_op</span><span class="p">(</span><span class="n">cmnd</span><span class="p">)</span> <span class="o">!=</span> <span class="n">SCSI_PROT_NORMAL</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">cfg_enable_bg</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">lpfc_printf_vlog</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">KERN_WARNING</span><span class="p">,</span> <span class="n">LOG_BG</span><span class="p">,</span>
				<span class="s">&quot;9033 BLKGRD: rcvd protected cmd:%02x op=%s &quot;</span>
				<span class="s">&quot;guard=%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">cmnd</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
				<span class="n">dif_op_str</span><span class="p">[</span><span class="n">scsi_get_prot_op</span><span class="p">(</span><span class="n">cmnd</span><span class="p">)],</span>
				<span class="n">dif_grd_str</span><span class="p">[</span><span class="n">scsi_host_get_guard</span><span class="p">(</span><span class="n">shost</span><span class="p">)]);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">cmnd</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">READ_10</span><span class="p">)</span>
				<span class="n">lpfc_printf_vlog</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">KERN_WARNING</span><span class="p">,</span> <span class="n">LOG_BG</span><span class="p">,</span>
					<span class="s">&quot;9035 BLKGRD: READ @ sector %llu, &quot;</span>
					<span class="s">&quot;cnt %u, rpt %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">scsi_get_lba</span><span class="p">(</span><span class="n">cmnd</span><span class="p">),</span>
					<span class="n">blk_rq_sectors</span><span class="p">(</span><span class="n">cmnd</span><span class="o">-&gt;</span><span class="n">request</span><span class="p">),</span>
					<span class="p">(</span><span class="n">cmnd</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">&gt;&gt;</span><span class="mi">5</span><span class="p">));</span>
			<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">cmnd</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">WRITE_10</span><span class="p">)</span>
				<span class="n">lpfc_printf_vlog</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">KERN_WARNING</span><span class="p">,</span> <span class="n">LOG_BG</span><span class="p">,</span>
					<span class="s">&quot;9036 BLKGRD: WRITE @ sector %llu, &quot;</span>
					<span class="s">&quot;cnt %u, wpt %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">scsi_get_lba</span><span class="p">(</span><span class="n">cmnd</span><span class="p">),</span>
					<span class="n">blk_rq_sectors</span><span class="p">(</span><span class="n">cmnd</span><span class="o">-&gt;</span><span class="n">request</span><span class="p">),</span>
					<span class="p">(</span><span class="n">cmnd</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">&gt;&gt;</span><span class="mi">5</span><span class="p">));</span>
		<span class="p">}</span>

		<span class="n">err</span> <span class="o">=</span> <span class="n">lpfc_bg_scsi_prep_dma_buf</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">lpfc_cmd</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">cfg_enable_bg</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">lpfc_printf_vlog</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">KERN_WARNING</span><span class="p">,</span> <span class="n">LOG_BG</span><span class="p">,</span>
				<span class="s">&quot;9038 BLKGRD: rcvd unprotected cmd:&quot;</span>
				<span class="s">&quot;%02x op=%s guard=%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">cmnd</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
				<span class="n">dif_op_str</span><span class="p">[</span><span class="n">scsi_get_prot_op</span><span class="p">(</span><span class="n">cmnd</span><span class="p">)],</span>
				<span class="n">dif_grd_str</span><span class="p">[</span><span class="n">scsi_host_get_guard</span><span class="p">(</span><span class="n">shost</span><span class="p">)]);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">cmnd</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">READ_10</span><span class="p">)</span>
				<span class="n">lpfc_printf_vlog</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">KERN_WARNING</span><span class="p">,</span> <span class="n">LOG_BG</span><span class="p">,</span>
					<span class="s">&quot;9040 dbg: READ @ sector %llu, &quot;</span>
					<span class="s">&quot;cnt %u, rpt %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">scsi_get_lba</span><span class="p">(</span><span class="n">cmnd</span><span class="p">),</span>
					 <span class="n">blk_rq_sectors</span><span class="p">(</span><span class="n">cmnd</span><span class="o">-&gt;</span><span class="n">request</span><span class="p">),</span>
					<span class="p">(</span><span class="n">cmnd</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">&gt;&gt;</span><span class="mi">5</span><span class="p">));</span>
			<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">cmnd</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">WRITE_10</span><span class="p">)</span>
				<span class="n">lpfc_printf_vlog</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">KERN_WARNING</span><span class="p">,</span> <span class="n">LOG_BG</span><span class="p">,</span>
					<span class="s">&quot;9041 dbg: WRITE @ sector %llu, &quot;</span>
					<span class="s">&quot;cnt %u, wpt %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">scsi_get_lba</span><span class="p">(</span><span class="n">cmnd</span><span class="p">),</span>
					<span class="n">blk_rq_sectors</span><span class="p">(</span><span class="n">cmnd</span><span class="o">-&gt;</span><span class="n">request</span><span class="p">),</span>
					<span class="p">(</span><span class="n">cmnd</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">&gt;&gt;</span><span class="mi">5</span><span class="p">));</span>
		<span class="p">}</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">lpfc_scsi_prep_dma_buf</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">lpfc_cmd</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_host_busy_free_buf</span><span class="p">;</span>

	<span class="n">lpfc_scsi_prep_cmnd</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">lpfc_cmd</span><span class="p">,</span> <span class="n">ndlp</span><span class="p">);</span>

	<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">cmd_pending</span><span class="p">);</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">lpfc_sli_issue_iocb</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">LPFC_FCP_RING</span><span class="p">,</span>
				  <span class="o">&amp;</span><span class="n">lpfc_cmd</span><span class="o">-&gt;</span><span class="n">cur_iocbq</span><span class="p">,</span> <span class="n">SLI_IOCB_RET_IOCB</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">atomic_dec</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">cmd_pending</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_host_busy_free_buf</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">cfg_poll</span> <span class="o">&amp;</span> <span class="n">ENABLE_FCP_RING_POLLING</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>
		<span class="n">lpfc_sli_handle_fast_ring_event</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span>
			<span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli</span><span class="p">.</span><span class="n">ring</span><span class="p">[</span><span class="n">LPFC_FCP_RING</span><span class="p">],</span> <span class="n">HA_R0RE_REQ</span><span class="p">);</span>

		<span class="n">spin_lock</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">cfg_poll</span> <span class="o">&amp;</span> <span class="n">DISABLE_FCP_RING_INT</span><span class="p">)</span>
			<span class="n">lpfc_poll_rearm_timer</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

 <span class="nl">out_host_busy_free_buf:</span>
	<span class="n">lpfc_scsi_unprep_dma_buf</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">lpfc_cmd</span><span class="p">);</span>
	<span class="n">lpfc_release_scsi_buf</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">lpfc_cmd</span><span class="p">);</span>
 <span class="nl">out_host_busy:</span>
	<span class="k">return</span> <span class="n">SCSI_MLQUEUE_HOST_BUSY</span><span class="p">;</span>

 <span class="nl">out_tgt_busy:</span>
	<span class="k">return</span> <span class="n">SCSI_MLQUEUE_TARGET_BUSY</span><span class="p">;</span>

 <span class="nl">out_fail_command:</span>
	<span class="n">done</span><span class="p">(</span><span class="n">cmnd</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="nf">DEF_SCSI_QCMD</span><span class="p">(</span><span class="n">lpfc_queuecommand</span><span class="p">)</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_abort_handler - scsi_host_template eh_abort_handler entry point</span>
<span class="cm"> * @cmnd: Pointer to scsi_cmnd data structure.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine aborts @cmnd pending in base driver.</span>
<span class="cm"> *</span>
<span class="cm"> * Return code :</span>
<span class="cm"> *   0x2003 - Error</span>
<span class="cm"> *   0x2002 - Success</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="n">lpfc_abort_handler</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="n">cmnd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span>  <span class="o">*</span><span class="n">shost</span> <span class="o">=</span> <span class="n">cmnd</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="n">vport</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="p">)</span> <span class="n">shost</span><span class="o">-&gt;</span><span class="n">hostdata</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_hba</span>   <span class="o">*</span><span class="n">phba</span> <span class="o">=</span> <span class="n">vport</span><span class="o">-&gt;</span><span class="n">phba</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_iocbq</span> <span class="o">*</span><span class="n">iocb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_iocbq</span> <span class="o">*</span><span class="n">abtsiocb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_scsi_buf</span> <span class="o">*</span><span class="n">lpfc_cmd</span><span class="p">;</span>
	<span class="n">IOCB_t</span> <span class="o">*</span><span class="n">cmd</span><span class="p">,</span> <span class="o">*</span><span class="n">icmd</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">SUCCESS</span><span class="p">;</span>
	<span class="n">DECLARE_WAIT_QUEUE_HEAD_ONSTACK</span><span class="p">(</span><span class="n">waitq</span><span class="p">);</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">fc_block_scsi_eh</span><span class="p">(</span><span class="n">cmnd</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>
	<span class="cm">/* driver queued commands are in process of being flushed */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hba_flag</span> <span class="o">&amp;</span> <span class="n">HBA_FCP_IOQ_FLUSH</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>
		<span class="n">lpfc_printf_vlog</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">KERN_WARNING</span><span class="p">,</span> <span class="n">LOG_FCP</span><span class="p">,</span>
			<span class="s">&quot;3168 SCSI Layer abort requested I/O has been &quot;</span>
			<span class="s">&quot;flushed by LLD.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">FAILED</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">lpfc_cmd</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_scsi_buf</span> <span class="o">*</span><span class="p">)</span><span class="n">cmnd</span><span class="o">-&gt;</span><span class="n">host_scribble</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">lpfc_cmd</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>
		<span class="n">lpfc_printf_vlog</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">KERN_WARNING</span><span class="p">,</span> <span class="n">LOG_FCP</span><span class="p">,</span>
			 <span class="s">&quot;2873 SCSI Layer I/O Abort Request IO CMPL Status &quot;</span>
			 <span class="s">&quot;x%x ID %d LUN %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			 <span class="n">ret</span><span class="p">,</span> <span class="n">cmnd</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">,</span> <span class="n">cmnd</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">lun</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">SUCCESS</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">iocb</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">lpfc_cmd</span><span class="o">-&gt;</span><span class="n">cur_iocbq</span><span class="p">;</span>
	<span class="cm">/* the command is in process of being cancelled */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">iocb</span><span class="o">-&gt;</span><span class="n">iocb_flag</span> <span class="o">&amp;</span> <span class="n">LPFC_IO_ON_TXCMPLQ</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>
		<span class="n">lpfc_printf_vlog</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">KERN_WARNING</span><span class="p">,</span> <span class="n">LOG_FCP</span><span class="p">,</span>
			<span class="s">&quot;3169 SCSI Layer abort requested I/O has been &quot;</span>
			<span class="s">&quot;cancelled by LLD.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">FAILED</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * If pCmd field of the corresponding lpfc_scsi_buf structure</span>
<span class="cm">	 * points to a different SCSI command, then the driver has</span>
<span class="cm">	 * already completed this command, but the midlayer did not</span>
<span class="cm">	 * see the completion before the eh fired. Just return SUCCESS.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">lpfc_cmd</span><span class="o">-&gt;</span><span class="n">pCmd</span> <span class="o">!=</span> <span class="n">cmnd</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lpfc_printf_vlog</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">KERN_WARNING</span><span class="p">,</span> <span class="n">LOG_FCP</span><span class="p">,</span>
			<span class="s">&quot;3170 SCSI Layer abort requested I/O has been &quot;</span>
			<span class="s">&quot;completed by LLD.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">iocb</span><span class="o">-&gt;</span><span class="n">context1</span> <span class="o">!=</span> <span class="n">lpfc_cmd</span><span class="p">);</span>

	<span class="n">abtsiocb</span> <span class="o">=</span> <span class="n">__lpfc_sli_get_iocbq</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">abtsiocb</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">FAILED</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * The scsi command can not be in txq and it is in flight because the</span>
<span class="cm">	 * pCmd is still pointig at the SCSI command we have to abort. There</span>
<span class="cm">	 * is no need to search the txcmplq. Just send an abort to the FW.</span>
<span class="cm">	 */</span>

	<span class="n">cmd</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">iocb</span><span class="o">-&gt;</span><span class="n">iocb</span><span class="p">;</span>
	<span class="n">icmd</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">abtsiocb</span><span class="o">-&gt;</span><span class="n">iocb</span><span class="p">;</span>
	<span class="n">icmd</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">acxri</span><span class="p">.</span><span class="n">abortType</span> <span class="o">=</span> <span class="n">ABORT_TYPE_ABTS</span><span class="p">;</span>
	<span class="n">icmd</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">acxri</span><span class="p">.</span><span class="n">abortContextTag</span> <span class="o">=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">ulpContext</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli_rev</span> <span class="o">==</span> <span class="n">LPFC_SLI_REV4</span><span class="p">)</span>
		<span class="n">icmd</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">acxri</span><span class="p">.</span><span class="n">abortIoTag</span> <span class="o">=</span> <span class="n">iocb</span><span class="o">-&gt;</span><span class="n">sli4_xritag</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">icmd</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">acxri</span><span class="p">.</span><span class="n">abortIoTag</span> <span class="o">=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">ulpIoTag</span><span class="p">;</span>

	<span class="n">icmd</span><span class="o">-&gt;</span><span class="n">ulpLe</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">icmd</span><span class="o">-&gt;</span><span class="n">ulpClass</span> <span class="o">=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">ulpClass</span><span class="p">;</span>

	<span class="cm">/* ABTS WQE must go to the same WQ as the WQE to be aborted */</span>
	<span class="n">abtsiocb</span><span class="o">-&gt;</span><span class="n">fcp_wqidx</span> <span class="o">=</span> <span class="n">iocb</span><span class="o">-&gt;</span><span class="n">fcp_wqidx</span><span class="p">;</span>
	<span class="n">abtsiocb</span><span class="o">-&gt;</span><span class="n">iocb_flag</span> <span class="o">|=</span> <span class="n">LPFC_USE_FCPWQIDX</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">lpfc_is_link_up</span><span class="p">(</span><span class="n">phba</span><span class="p">))</span>
		<span class="n">icmd</span><span class="o">-&gt;</span><span class="n">ulpCommand</span> <span class="o">=</span> <span class="n">CMD_ABORT_XRI_CN</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">icmd</span><span class="o">-&gt;</span><span class="n">ulpCommand</span> <span class="o">=</span> <span class="n">CMD_CLOSE_XRI_CN</span><span class="p">;</span>

	<span class="n">abtsiocb</span><span class="o">-&gt;</span><span class="n">iocb_cmpl</span> <span class="o">=</span> <span class="n">lpfc_sli_abort_fcp_cmpl</span><span class="p">;</span>
	<span class="n">abtsiocb</span><span class="o">-&gt;</span><span class="n">vport</span> <span class="o">=</span> <span class="n">vport</span><span class="p">;</span>
	<span class="cm">/* no longer need the lock after this point */</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">lpfc_sli_issue_iocb</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">LPFC_FCP_RING</span><span class="p">,</span> <span class="n">abtsiocb</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">==</span>
	    <span class="n">IOCB_ERROR</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lpfc_sli_release_iocbq</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">abtsiocb</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">FAILED</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">cfg_poll</span> <span class="o">&amp;</span> <span class="n">DISABLE_FCP_RING_INT</span><span class="p">)</span>
		<span class="n">lpfc_sli_handle_fast_ring_event</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span>
			<span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli</span><span class="p">.</span><span class="n">ring</span><span class="p">[</span><span class="n">LPFC_FCP_RING</span><span class="p">],</span> <span class="n">HA_R0RE_REQ</span><span class="p">);</span>

	<span class="n">lpfc_cmd</span><span class="o">-&gt;</span><span class="n">waitq</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">waitq</span><span class="p">;</span>
	<span class="cm">/* Wait for abort to complete */</span>
	<span class="n">wait_event_timeout</span><span class="p">(</span><span class="n">waitq</span><span class="p">,</span>
			  <span class="p">(</span><span class="n">lpfc_cmd</span><span class="o">-&gt;</span><span class="n">pCmd</span> <span class="o">!=</span> <span class="n">cmnd</span><span class="p">),</span>
			   <span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">cfg_devloss_tmo</span><span class="o">*</span><span class="n">HZ</span><span class="p">));</span>
	<span class="n">lpfc_cmd</span><span class="o">-&gt;</span><span class="n">waitq</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">lpfc_cmd</span><span class="o">-&gt;</span><span class="n">pCmd</span> <span class="o">==</span> <span class="n">cmnd</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">FAILED</span><span class="p">;</span>
		<span class="n">lpfc_printf_vlog</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_FCP</span><span class="p">,</span>
				 <span class="s">&quot;0748 abort handler timed out waiting &quot;</span>
				 <span class="s">&quot;for abort to complete: ret %#x, ID %d, &quot;</span>
				 <span class="s">&quot;LUN %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				 <span class="n">ret</span><span class="p">,</span> <span class="n">cmnd</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">,</span> <span class="n">cmnd</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">lun</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

<span class="nl">out_unlock:</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="n">lpfc_printf_vlog</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">KERN_WARNING</span><span class="p">,</span> <span class="n">LOG_FCP</span><span class="p">,</span>
			 <span class="s">&quot;0749 SCSI Layer I/O Abort Request Status x%x ID %d &quot;</span>
			 <span class="s">&quot;LUN %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ret</span><span class="p">,</span> <span class="n">cmnd</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">,</span>
			 <span class="n">cmnd</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">lun</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">char</span> <span class="o">*</span>
<span class="nf">lpfc_taskmgmt_name</span><span class="p">(</span><span class="kt">uint8_t</span> <span class="n">task_mgmt_cmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">task_mgmt_cmd</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">FCP_ABORT_TASK_SET</span>:
		<span class="k">return</span> <span class="s">&quot;ABORT_TASK_SET&quot;</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">FCP_CLEAR_TASK_SET</span>:
		<span class="k">return</span> <span class="s">&quot;FCP_CLEAR_TASK_SET&quot;</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">FCP_BUS_RESET</span>:
		<span class="k">return</span> <span class="s">&quot;FCP_BUS_RESET&quot;</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">FCP_LUN_RESET</span>:
		<span class="k">return</span> <span class="s">&quot;FCP_LUN_RESET&quot;</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">FCP_TARGET_RESET</span>:
		<span class="k">return</span> <span class="s">&quot;FCP_TARGET_RESET&quot;</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">FCP_CLEAR_ACA</span>:
		<span class="k">return</span> <span class="s">&quot;FCP_CLEAR_ACA&quot;</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">FCP_TERMINATE_TASK</span>:
		<span class="k">return</span> <span class="s">&quot;FCP_TERMINATE_TASK&quot;</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">return</span> <span class="s">&quot;unknown&quot;</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_send_taskmgmt - Generic SCSI Task Mgmt Handler</span>
<span class="cm"> * @vport: The virtual port for which this call is being executed.</span>
<span class="cm"> * @rdata: Pointer to remote port local data</span>
<span class="cm"> * @tgt_id: Target ID of remote device.</span>
<span class="cm"> * @lun_id: Lun number for the TMF</span>
<span class="cm"> * @task_mgmt_cmd: type of TMF to send</span>
<span class="cm"> *</span>
<span class="cm"> * This routine builds and sends a TMF (SCSI Task Mgmt Function) to</span>
<span class="cm"> * a remote port.</span>
<span class="cm"> *</span>
<span class="cm"> * Return Code:</span>
<span class="cm"> *   0x2003 - Error</span>
<span class="cm"> *   0x2002 - Success.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">lpfc_send_taskmgmt</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="n">vport</span><span class="p">,</span> <span class="k">struct</span> <span class="n">lpfc_rport_data</span> <span class="o">*</span><span class="n">rdata</span><span class="p">,</span>
		    <span class="kt">unsigned</span>  <span class="n">tgt_id</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">lun_id</span><span class="p">,</span>
		    <span class="kt">uint8_t</span> <span class="n">task_mgmt_cmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpfc_hba</span>   <span class="o">*</span><span class="n">phba</span> <span class="o">=</span> <span class="n">vport</span><span class="o">-&gt;</span><span class="n">phba</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_scsi_buf</span> <span class="o">*</span><span class="n">lpfc_cmd</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_iocbq</span> <span class="o">*</span><span class="n">iocbq</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_iocbq</span> <span class="o">*</span><span class="n">iocbqrsp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_nodelist</span> <span class="o">*</span><span class="n">pnode</span> <span class="o">=</span> <span class="n">rdata</span><span class="o">-&gt;</span><span class="n">pnode</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">status</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pnode</span> <span class="o">||</span> <span class="o">!</span><span class="n">NLP_CHK_NODE_ACT</span><span class="p">(</span><span class="n">pnode</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">FAILED</span><span class="p">;</span>

	<span class="n">lpfc_cmd</span> <span class="o">=</span> <span class="n">lpfc_get_scsi_buf</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">rdata</span><span class="o">-&gt;</span><span class="n">pnode</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">lpfc_cmd</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">FAILED</span><span class="p">;</span>
	<span class="n">lpfc_cmd</span><span class="o">-&gt;</span><span class="n">timeout</span> <span class="o">=</span> <span class="mi">60</span><span class="p">;</span>
	<span class="n">lpfc_cmd</span><span class="o">-&gt;</span><span class="n">rdata</span> <span class="o">=</span> <span class="n">rdata</span><span class="p">;</span>

	<span class="n">status</span> <span class="o">=</span> <span class="n">lpfc_scsi_prep_task_mgmt_cmd</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">lpfc_cmd</span><span class="p">,</span> <span class="n">lun_id</span><span class="p">,</span>
					   <span class="n">task_mgmt_cmd</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">status</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lpfc_release_scsi_buf</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">lpfc_cmd</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">FAILED</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">iocbq</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">lpfc_cmd</span><span class="o">-&gt;</span><span class="n">cur_iocbq</span><span class="p">;</span>
	<span class="n">iocbqrsp</span> <span class="o">=</span> <span class="n">lpfc_sli_get_iocbq</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">iocbqrsp</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lpfc_release_scsi_buf</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">lpfc_cmd</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">FAILED</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">lpfc_printf_vlog</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">KERN_INFO</span><span class="p">,</span> <span class="n">LOG_FCP</span><span class="p">,</span>
			 <span class="s">&quot;0702 Issue %s to TGT %d LUN %d &quot;</span>
			 <span class="s">&quot;rpi x%x nlp_flag x%x Data: x%x x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			 <span class="n">lpfc_taskmgmt_name</span><span class="p">(</span><span class="n">task_mgmt_cmd</span><span class="p">),</span> <span class="n">tgt_id</span><span class="p">,</span> <span class="n">lun_id</span><span class="p">,</span>
			 <span class="n">pnode</span><span class="o">-&gt;</span><span class="n">nlp_rpi</span><span class="p">,</span> <span class="n">pnode</span><span class="o">-&gt;</span><span class="n">nlp_flag</span><span class="p">,</span> <span class="n">iocbq</span><span class="o">-&gt;</span><span class="n">sli4_xritag</span><span class="p">,</span>
			 <span class="n">iocbq</span><span class="o">-&gt;</span><span class="n">iocb_flag</span><span class="p">);</span>

	<span class="n">status</span> <span class="o">=</span> <span class="n">lpfc_sli_issue_iocb_wait</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">LPFC_FCP_RING</span><span class="p">,</span>
					  <span class="n">iocbq</span><span class="p">,</span> <span class="n">iocbqrsp</span><span class="p">,</span> <span class="n">lpfc_cmd</span><span class="o">-&gt;</span><span class="n">timeout</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">!=</span> <span class="n">IOCB_SUCCESS</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">==</span> <span class="n">IOCB_TIMEDOUT</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">iocbq</span><span class="o">-&gt;</span><span class="n">iocb_cmpl</span> <span class="o">=</span> <span class="n">lpfc_tskmgmt_def_cmpl</span><span class="p">;</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">TIMEOUT_ERROR</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">FAILED</span><span class="p">;</span>
		<span class="n">lpfc_cmd</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">=</span> <span class="n">IOSTAT_DRIVER_REJECT</span><span class="p">;</span>
		<span class="n">lpfc_printf_vlog</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_FCP</span><span class="p">,</span>
			 <span class="s">&quot;0727 TMF %s to TGT %d LUN %d failed (%d, %d) &quot;</span>
			 <span class="s">&quot;iocb_flag x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			 <span class="n">lpfc_taskmgmt_name</span><span class="p">(</span><span class="n">task_mgmt_cmd</span><span class="p">),</span>
			 <span class="n">tgt_id</span><span class="p">,</span> <span class="n">lun_id</span><span class="p">,</span> <span class="n">iocbqrsp</span><span class="o">-&gt;</span><span class="n">iocb</span><span class="p">.</span><span class="n">ulpStatus</span><span class="p">,</span>
			 <span class="n">iocbqrsp</span><span class="o">-&gt;</span><span class="n">iocb</span><span class="p">.</span><span class="n">un</span><span class="p">.</span><span class="n">ulpWord</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span>
			 <span class="n">iocbq</span><span class="o">-&gt;</span><span class="n">iocb_flag</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">==</span> <span class="n">IOCB_BUSY</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">FAILED</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">SUCCESS</span><span class="p">;</span>

	<span class="n">lpfc_sli_release_iocbq</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">iocbqrsp</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="n">TIMEOUT_ERROR</span><span class="p">)</span>
		<span class="n">lpfc_release_scsi_buf</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">lpfc_cmd</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_chk_tgt_mapped -</span>
<span class="cm"> * @vport: The virtual port to check on</span>
<span class="cm"> * @cmnd: Pointer to scsi_cmnd data structure.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine delays until the scsi target (aka rport) for the</span>
<span class="cm"> * command exists (is present and logged in) or we declare it non-existent.</span>
<span class="cm"> *</span>
<span class="cm"> * Return code :</span>
<span class="cm"> *  0x2003 - Error</span>
<span class="cm"> *  0x2002 - Success</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">lpfc_chk_tgt_mapped</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="n">vport</span><span class="p">,</span> <span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="n">cmnd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpfc_rport_data</span> <span class="o">*</span><span class="n">rdata</span> <span class="o">=</span> <span class="n">cmnd</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">hostdata</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_nodelist</span> <span class="o">*</span><span class="n">pnode</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">later</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rdata</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lpfc_printf_vlog</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">KERN_INFO</span><span class="p">,</span> <span class="n">LOG_FCP</span><span class="p">,</span>
			<span class="s">&quot;0797 Tgt Map rport failure: rdata x%p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">rdata</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">FAILED</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">pnode</span> <span class="o">=</span> <span class="n">rdata</span><span class="o">-&gt;</span><span class="n">pnode</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * If target is not in a MAPPED state, delay until</span>
<span class="cm">	 * target is rediscovered or devloss timeout expires.</span>
<span class="cm">	 */</span>
	<span class="n">later</span> <span class="o">=</span> <span class="n">msecs_to_jiffies</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">vport</span><span class="o">-&gt;</span><span class="n">cfg_devloss_tmo</span> <span class="o">*</span> <span class="mi">1000</span><span class="p">)</span> <span class="o">+</span> <span class="n">jiffies</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">time_after</span><span class="p">(</span><span class="n">later</span><span class="p">,</span> <span class="n">jiffies</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pnode</span> <span class="o">||</span> <span class="o">!</span><span class="n">NLP_CHK_NODE_ACT</span><span class="p">(</span><span class="n">pnode</span><span class="p">))</span>
			<span class="k">return</span> <span class="n">FAILED</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pnode</span><span class="o">-&gt;</span><span class="n">nlp_state</span> <span class="o">==</span> <span class="n">NLP_STE_MAPPED_NODE</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">SUCCESS</span><span class="p">;</span>
		<span class="n">schedule_timeout_uninterruptible</span><span class="p">(</span><span class="n">msecs_to_jiffies</span><span class="p">(</span><span class="mi">500</span><span class="p">));</span>
		<span class="n">rdata</span> <span class="o">=</span> <span class="n">cmnd</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">hostdata</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rdata</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">FAILED</span><span class="p">;</span>
		<span class="n">pnode</span> <span class="o">=</span> <span class="n">rdata</span><span class="o">-&gt;</span><span class="n">pnode</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pnode</span> <span class="o">||</span> <span class="o">!</span><span class="n">NLP_CHK_NODE_ACT</span><span class="p">(</span><span class="n">pnode</span><span class="p">)</span> <span class="o">||</span>
	    <span class="p">(</span><span class="n">pnode</span><span class="o">-&gt;</span><span class="n">nlp_state</span> <span class="o">!=</span> <span class="n">NLP_STE_MAPPED_NODE</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">FAILED</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">SUCCESS</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_reset_flush_io_context -</span>
<span class="cm"> * @vport: The virtual port (scsi_host) for the flush context</span>
<span class="cm"> * @tgt_id: If aborting by Target contect - specifies the target id</span>
<span class="cm"> * @lun_id: If aborting by Lun context - specifies the lun id</span>
<span class="cm"> * @context: specifies the context level to flush at.</span>
<span class="cm"> *</span>
<span class="cm"> * After a reset condition via TMF, we need to flush orphaned i/o</span>
<span class="cm"> * contexts from the adapter. This routine aborts any contexts</span>
<span class="cm"> * outstanding, then waits for their completions. The wait is</span>
<span class="cm"> * bounded by devloss_tmo though.</span>
<span class="cm"> *</span>
<span class="cm"> * Return code :</span>
<span class="cm"> *  0x2003 - Error</span>
<span class="cm"> *  0x2002 - Success</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">lpfc_reset_flush_io_context</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="n">vport</span><span class="p">,</span> <span class="kt">uint16_t</span> <span class="n">tgt_id</span><span class="p">,</span>
			<span class="kt">uint64_t</span> <span class="n">lun_id</span><span class="p">,</span> <span class="n">lpfc_ctx_cmd</span> <span class="n">context</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpfc_hba</span>   <span class="o">*</span><span class="n">phba</span> <span class="o">=</span> <span class="n">vport</span><span class="o">-&gt;</span><span class="n">phba</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">later</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">cnt</span><span class="p">;</span>

	<span class="n">cnt</span> <span class="o">=</span> <span class="n">lpfc_sli_sum_iocb</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">tgt_id</span><span class="p">,</span> <span class="n">lun_id</span><span class="p">,</span> <span class="n">context</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cnt</span><span class="p">)</span>
		<span class="n">lpfc_sli_abort_iocb</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli</span><span class="p">.</span><span class="n">ring</span><span class="p">[</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli</span><span class="p">.</span><span class="n">fcp_ring</span><span class="p">],</span>
				    <span class="n">tgt_id</span><span class="p">,</span> <span class="n">lun_id</span><span class="p">,</span> <span class="n">context</span><span class="p">);</span>
	<span class="n">later</span> <span class="o">=</span> <span class="n">msecs_to_jiffies</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">vport</span><span class="o">-&gt;</span><span class="n">cfg_devloss_tmo</span> <span class="o">*</span> <span class="mi">1000</span><span class="p">)</span> <span class="o">+</span> <span class="n">jiffies</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">time_after</span><span class="p">(</span><span class="n">later</span><span class="p">,</span> <span class="n">jiffies</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">cnt</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">schedule_timeout_uninterruptible</span><span class="p">(</span><span class="n">msecs_to_jiffies</span><span class="p">(</span><span class="mi">20</span><span class="p">));</span>
		<span class="n">cnt</span> <span class="o">=</span> <span class="n">lpfc_sli_sum_iocb</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">tgt_id</span><span class="p">,</span> <span class="n">lun_id</span><span class="p">,</span> <span class="n">context</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cnt</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lpfc_printf_vlog</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_FCP</span><span class="p">,</span>
			<span class="s">&quot;0724 I/O flush failure for context %s : cnt x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="p">((</span><span class="n">context</span> <span class="o">==</span> <span class="n">LPFC_CTX_LUN</span><span class="p">)</span> <span class="o">?</span> <span class="s">&quot;LUN&quot;</span> <span class="o">:</span>
			 <span class="p">((</span><span class="n">context</span> <span class="o">==</span> <span class="n">LPFC_CTX_TGT</span><span class="p">)</span> <span class="o">?</span> <span class="s">&quot;TGT&quot;</span> <span class="o">:</span>
			  <span class="p">((</span><span class="n">context</span> <span class="o">==</span> <span class="n">LPFC_CTX_HOST</span><span class="p">)</span> <span class="o">?</span> <span class="s">&quot;HOST&quot;</span> <span class="o">:</span> <span class="s">&quot;Unknown&quot;</span><span class="p">))),</span>
			<span class="n">cnt</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">FAILED</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">SUCCESS</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_device_reset_handler - scsi_host_template eh_device_reset entry point</span>
<span class="cm"> * @cmnd: Pointer to scsi_cmnd data structure.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine does a device reset by sending a LUN_RESET task management</span>
<span class="cm"> * command.</span>
<span class="cm"> *</span>
<span class="cm"> * Return code :</span>
<span class="cm"> *  0x2003 - Error</span>
<span class="cm"> *  0x2002 - Success</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">lpfc_device_reset_handler</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="n">cmnd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span>  <span class="o">*</span><span class="n">shost</span> <span class="o">=</span> <span class="n">cmnd</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="n">vport</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="p">)</span> <span class="n">shost</span><span class="o">-&gt;</span><span class="n">hostdata</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_rport_data</span> <span class="o">*</span><span class="n">rdata</span> <span class="o">=</span> <span class="n">cmnd</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">hostdata</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_nodelist</span> <span class="o">*</span><span class="n">pnode</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">tgt_id</span> <span class="o">=</span> <span class="n">cmnd</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">lun_id</span> <span class="o">=</span> <span class="n">cmnd</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">lun</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_scsi_event_header</span> <span class="n">scsi_event</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">status</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rdata</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lpfc_printf_vlog</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_FCP</span><span class="p">,</span>
			<span class="s">&quot;0798 Device Reset rport failure: rdata x%p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">rdata</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">FAILED</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">pnode</span> <span class="o">=</span> <span class="n">rdata</span><span class="o">-&gt;</span><span class="n">pnode</span><span class="p">;</span>
	<span class="n">status</span> <span class="o">=</span> <span class="n">fc_block_scsi_eh</span><span class="p">(</span><span class="n">cmnd</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">status</span><span class="p">;</span>

	<span class="n">status</span> <span class="o">=</span> <span class="n">lpfc_chk_tgt_mapped</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">cmnd</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">==</span> <span class="n">FAILED</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lpfc_printf_vlog</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_FCP</span><span class="p">,</span>
			<span class="s">&quot;0721 Device Reset rport failure: rdata x%p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">rdata</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">FAILED</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">scsi_event</span><span class="p">.</span><span class="n">event_type</span> <span class="o">=</span> <span class="n">FC_REG_SCSI_EVENT</span><span class="p">;</span>
	<span class="n">scsi_event</span><span class="p">.</span><span class="n">subcategory</span> <span class="o">=</span> <span class="n">LPFC_EVENT_LUNRESET</span><span class="p">;</span>
	<span class="n">scsi_event</span><span class="p">.</span><span class="n">lun</span> <span class="o">=</span> <span class="n">lun_id</span><span class="p">;</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">scsi_event</span><span class="p">.</span><span class="n">wwpn</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pnode</span><span class="o">-&gt;</span><span class="n">nlp_portname</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_name</span><span class="p">));</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">scsi_event</span><span class="p">.</span><span class="n">wwnn</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pnode</span><span class="o">-&gt;</span><span class="n">nlp_nodename</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_name</span><span class="p">));</span>

	<span class="n">fc_host_post_vendor_event</span><span class="p">(</span><span class="n">shost</span><span class="p">,</span> <span class="n">fc_get_event_number</span><span class="p">(),</span>
		<span class="k">sizeof</span><span class="p">(</span><span class="n">scsi_event</span><span class="p">),</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">scsi_event</span><span class="p">,</span> <span class="n">LPFC_NL_VENDOR_ID</span><span class="p">);</span>

	<span class="n">status</span> <span class="o">=</span> <span class="n">lpfc_send_taskmgmt</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">rdata</span><span class="p">,</span> <span class="n">tgt_id</span><span class="p">,</span> <span class="n">lun_id</span><span class="p">,</span>
						<span class="n">FCP_LUN_RESET</span><span class="p">);</span>

	<span class="n">lpfc_printf_vlog</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_FCP</span><span class="p">,</span>
			 <span class="s">&quot;0713 SCSI layer issued Device Reset (%d, %d) &quot;</span>
			 <span class="s">&quot;return x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">tgt_id</span><span class="p">,</span> <span class="n">lun_id</span><span class="p">,</span> <span class="n">status</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * We have to clean up i/o as : they may be orphaned by the TMF;</span>
<span class="cm">	 * or if the TMF failed, they may be in an indeterminate state.</span>
<span class="cm">	 * So, continue on.</span>
<span class="cm">	 * We will report success if all the i/o aborts successfully.</span>
<span class="cm">	 */</span>
	<span class="n">status</span> <span class="o">=</span> <span class="n">lpfc_reset_flush_io_context</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">tgt_id</span><span class="p">,</span> <span class="n">lun_id</span><span class="p">,</span>
						<span class="n">LPFC_CTX_LUN</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_target_reset_handler - scsi_host_template eh_target_reset entry point</span>
<span class="cm"> * @cmnd: Pointer to scsi_cmnd data structure.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine does a target reset by sending a TARGET_RESET task management</span>
<span class="cm"> * command.</span>
<span class="cm"> *</span>
<span class="cm"> * Return code :</span>
<span class="cm"> *  0x2003 - Error</span>
<span class="cm"> *  0x2002 - Success</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">lpfc_target_reset_handler</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="n">cmnd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span>  <span class="o">*</span><span class="n">shost</span> <span class="o">=</span> <span class="n">cmnd</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="n">vport</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="p">)</span> <span class="n">shost</span><span class="o">-&gt;</span><span class="n">hostdata</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_rport_data</span> <span class="o">*</span><span class="n">rdata</span> <span class="o">=</span> <span class="n">cmnd</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">hostdata</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_nodelist</span> <span class="o">*</span><span class="n">pnode</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">tgt_id</span> <span class="o">=</span> <span class="n">cmnd</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">lun_id</span> <span class="o">=</span> <span class="n">cmnd</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">lun</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_scsi_event_header</span> <span class="n">scsi_event</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">status</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rdata</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lpfc_printf_vlog</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_FCP</span><span class="p">,</span>
			<span class="s">&quot;0799 Target Reset rport failure: rdata x%p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">rdata</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">FAILED</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">pnode</span> <span class="o">=</span> <span class="n">rdata</span><span class="o">-&gt;</span><span class="n">pnode</span><span class="p">;</span>
	<span class="n">status</span> <span class="o">=</span> <span class="n">fc_block_scsi_eh</span><span class="p">(</span><span class="n">cmnd</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">status</span><span class="p">;</span>

	<span class="n">status</span> <span class="o">=</span> <span class="n">lpfc_chk_tgt_mapped</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">cmnd</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">==</span> <span class="n">FAILED</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lpfc_printf_vlog</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_FCP</span><span class="p">,</span>
			<span class="s">&quot;0722 Target Reset rport failure: rdata x%p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">rdata</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">FAILED</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">scsi_event</span><span class="p">.</span><span class="n">event_type</span> <span class="o">=</span> <span class="n">FC_REG_SCSI_EVENT</span><span class="p">;</span>
	<span class="n">scsi_event</span><span class="p">.</span><span class="n">subcategory</span> <span class="o">=</span> <span class="n">LPFC_EVENT_TGTRESET</span><span class="p">;</span>
	<span class="n">scsi_event</span><span class="p">.</span><span class="n">lun</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">scsi_event</span><span class="p">.</span><span class="n">wwpn</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pnode</span><span class="o">-&gt;</span><span class="n">nlp_portname</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_name</span><span class="p">));</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">scsi_event</span><span class="p">.</span><span class="n">wwnn</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pnode</span><span class="o">-&gt;</span><span class="n">nlp_nodename</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_name</span><span class="p">));</span>

	<span class="n">fc_host_post_vendor_event</span><span class="p">(</span><span class="n">shost</span><span class="p">,</span> <span class="n">fc_get_event_number</span><span class="p">(),</span>
		<span class="k">sizeof</span><span class="p">(</span><span class="n">scsi_event</span><span class="p">),</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">scsi_event</span><span class="p">,</span> <span class="n">LPFC_NL_VENDOR_ID</span><span class="p">);</span>

	<span class="n">status</span> <span class="o">=</span> <span class="n">lpfc_send_taskmgmt</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">rdata</span><span class="p">,</span> <span class="n">tgt_id</span><span class="p">,</span> <span class="n">lun_id</span><span class="p">,</span>
					<span class="n">FCP_TARGET_RESET</span><span class="p">);</span>

	<span class="n">lpfc_printf_vlog</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_FCP</span><span class="p">,</span>
			 <span class="s">&quot;0723 SCSI layer issued Target Reset (%d, %d) &quot;</span>
			 <span class="s">&quot;return x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">tgt_id</span><span class="p">,</span> <span class="n">lun_id</span><span class="p">,</span> <span class="n">status</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * We have to clean up i/o as : they may be orphaned by the TMF;</span>
<span class="cm">	 * or if the TMF failed, they may be in an indeterminate state.</span>
<span class="cm">	 * So, continue on.</span>
<span class="cm">	 * We will report success if all the i/o aborts successfully.</span>
<span class="cm">	 */</span>
	<span class="n">status</span> <span class="o">=</span> <span class="n">lpfc_reset_flush_io_context</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">tgt_id</span><span class="p">,</span> <span class="n">lun_id</span><span class="p">,</span>
					<span class="n">LPFC_CTX_TGT</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_bus_reset_handler - scsi_host_template eh_bus_reset_handler entry point</span>
<span class="cm"> * @cmnd: Pointer to scsi_cmnd data structure.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine does target reset to all targets on @cmnd-&gt;device-&gt;host.</span>
<span class="cm"> * This emulates Parallel SCSI Bus Reset Semantics.</span>
<span class="cm"> *</span>
<span class="cm"> * Return code :</span>
<span class="cm"> *  0x2003 - Error</span>
<span class="cm"> *  0x2002 - Success</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">lpfc_bus_reset_handler</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="n">cmnd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span>  <span class="o">*</span><span class="n">shost</span> <span class="o">=</span> <span class="n">cmnd</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="n">vport</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="p">)</span> <span class="n">shost</span><span class="o">-&gt;</span><span class="n">hostdata</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_nodelist</span> <span class="o">*</span><span class="n">ndlp</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_scsi_event_header</span> <span class="n">scsi_event</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">match</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">SUCCESS</span><span class="p">,</span> <span class="n">status</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">scsi_event</span><span class="p">.</span><span class="n">event_type</span> <span class="o">=</span> <span class="n">FC_REG_SCSI_EVENT</span><span class="p">;</span>
	<span class="n">scsi_event</span><span class="p">.</span><span class="n">subcategory</span> <span class="o">=</span> <span class="n">LPFC_EVENT_BUSRESET</span><span class="p">;</span>
	<span class="n">scsi_event</span><span class="p">.</span><span class="n">lun</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">scsi_event</span><span class="p">.</span><span class="n">wwpn</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_portname</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_name</span><span class="p">));</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">scsi_event</span><span class="p">.</span><span class="n">wwnn</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_nodename</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_name</span><span class="p">));</span>

	<span class="n">fc_host_post_vendor_event</span><span class="p">(</span><span class="n">shost</span><span class="p">,</span> <span class="n">fc_get_event_number</span><span class="p">(),</span>
		<span class="k">sizeof</span><span class="p">(</span><span class="n">scsi_event</span><span class="p">),</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">scsi_event</span><span class="p">,</span> <span class="n">LPFC_NL_VENDOR_ID</span><span class="p">);</span>

	<span class="n">status</span> <span class="o">=</span> <span class="n">fc_block_scsi_eh</span><span class="p">(</span><span class="n">cmnd</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">status</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Since the driver manages a single bus device, reset all</span>
<span class="cm">	 * targets known to the driver.  Should any target reset</span>
<span class="cm">	 * fail, this routine returns failure to the midlayer.</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">LPFC_MAX_TARGET</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Search for mapped node by target ID */</span>
		<span class="n">match</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">spin_lock_irq</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>
		<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">ndlp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_nodes</span><span class="p">,</span> <span class="n">nlp_listp</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">NLP_CHK_NODE_ACT</span><span class="p">(</span><span class="n">ndlp</span><span class="p">))</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_state</span> <span class="o">==</span> <span class="n">NLP_STE_MAPPED_NODE</span> <span class="o">&amp;&amp;</span>
			    <span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_sid</span> <span class="o">==</span> <span class="n">i</span> <span class="o">&amp;&amp;</span>
			    <span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">rport</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">match</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">match</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">status</span> <span class="o">=</span> <span class="n">lpfc_send_taskmgmt</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">rport</span><span class="o">-&gt;</span><span class="n">dd_data</span><span class="p">,</span>
					<span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">FCP_TARGET_RESET</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">!=</span> <span class="n">SUCCESS</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">lpfc_printf_vlog</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_FCP</span><span class="p">,</span>
					 <span class="s">&quot;0700 Bus Reset on target %d failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					 <span class="n">i</span><span class="p">);</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">FAILED</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * We have to clean up i/o as : they may be orphaned by the TMFs</span>
<span class="cm">	 * above; or if any of the TMFs failed, they may be in an</span>
<span class="cm">	 * indeterminate state.</span>
<span class="cm">	 * We will report success if all the i/o aborts successfully.</span>
<span class="cm">	 */</span>

	<span class="n">status</span> <span class="o">=</span> <span class="n">lpfc_reset_flush_io_context</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">LPFC_CTX_HOST</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">!=</span> <span class="n">SUCCESS</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">FAILED</span><span class="p">;</span>

	<span class="n">lpfc_printf_vlog</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_FCP</span><span class="p">,</span>
			 <span class="s">&quot;0714 SCSI layer issued Bus Reset Data: x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_host_reset_handler - scsi_host_template eh_host_reset_handler entry pt</span>
<span class="cm"> * @cmnd: Pointer to scsi_cmnd data structure.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine does host reset to the adaptor port. It brings the HBA</span>
<span class="cm"> * offline, performs a board restart, and then brings the board back online.</span>
<span class="cm"> * The lpfc_offline calls lpfc_sli_hba_down which will abort and local</span>
<span class="cm"> * reject all outstanding SCSI commands to the host and error returned</span>
<span class="cm"> * back to SCSI mid-level. As this will be SCSI mid-level&#39;s last resort</span>
<span class="cm"> * of error handling, it will only return error if resetting of the adapter</span>
<span class="cm"> * is not successful; in all other cases, will return success.</span>
<span class="cm"> *</span>
<span class="cm"> * Return code :</span>
<span class="cm"> *  0x2003 - Error</span>
<span class="cm"> *  0x2002 - Success</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">lpfc_host_reset_handler</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="n">cmnd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span> <span class="o">=</span> <span class="n">cmnd</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="n">vport</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="p">)</span> <span class="n">shost</span><span class="o">-&gt;</span><span class="n">hostdata</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span> <span class="o">=</span> <span class="n">vport</span><span class="o">-&gt;</span><span class="n">phba</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">,</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">SUCCESS</span><span class="p">;</span>

	<span class="n">lpfc_offline_prep</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
	<span class="n">lpfc_offline</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">lpfc_sli_brdrestart</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">FAILED</span><span class="p">;</span>
	<span class="n">lpfc_online</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
	<span class="n">lpfc_unblock_mgmt_io</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>

	<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_FCP</span><span class="p">,</span>
			<span class="s">&quot;3172 SCSI layer issued Host Reset Data: x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_slave_alloc - scsi_host_template slave_alloc entry point</span>
<span class="cm"> * @sdev: Pointer to scsi_device.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine populates the cmds_per_lun count + 2 scsi_bufs into  this host&#39;s</span>
<span class="cm"> * globally available list of scsi buffers. This routine also makes sure scsi</span>
<span class="cm"> * buffer is not allocated more than HBA limit conveyed to midlayer. This list</span>
<span class="cm"> * of scsi buffer exists for the lifetime of the driver.</span>
<span class="cm"> *</span>
<span class="cm"> * Return codes:</span>
<span class="cm"> *   non-0 - Error</span>
<span class="cm"> *   0 - Success</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">lpfc_slave_alloc</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="n">sdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="n">vport</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="p">)</span> <span class="n">sdev</span><span class="o">-&gt;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">hostdata</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_hba</span>   <span class="o">*</span><span class="n">phba</span> <span class="o">=</span> <span class="n">vport</span><span class="o">-&gt;</span><span class="n">phba</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fc_rport</span> <span class="o">*</span><span class="n">rport</span> <span class="o">=</span> <span class="n">starget_to_rport</span><span class="p">(</span><span class="n">scsi_target</span><span class="p">(</span><span class="n">sdev</span><span class="p">));</span>
	<span class="kt">uint32_t</span> <span class="n">total</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">num_to_alloc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">num_allocated</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">sdev_cnt</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rport</span> <span class="o">||</span> <span class="n">fc_remote_port_chkready</span><span class="p">(</span><span class="n">rport</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENXIO</span><span class="p">;</span>

	<span class="n">sdev</span><span class="o">-&gt;</span><span class="n">hostdata</span> <span class="o">=</span> <span class="n">rport</span><span class="o">-&gt;</span><span class="n">dd_data</span><span class="p">;</span>
	<span class="n">sdev_cnt</span> <span class="o">=</span> <span class="n">atomic_inc_return</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sdev_cnt</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Populate the cmds_per_lun count scsi_bufs into this host&#39;s globally</span>
<span class="cm">	 * available list of scsi buffers.  Don&#39;t allocate more than the</span>
<span class="cm">	 * HBA limit conveyed to the midlayer via the host structure.  The</span>
<span class="cm">	 * formula accounts for the lun_queue_depth + error handlers + 1</span>
<span class="cm">	 * extra.  This list of scsi bufs exists for the lifetime of the driver.</span>
<span class="cm">	 */</span>
	<span class="n">total</span> <span class="o">=</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">total_scsi_bufs</span><span class="p">;</span>
	<span class="n">num_to_alloc</span> <span class="o">=</span> <span class="n">vport</span><span class="o">-&gt;</span><span class="n">cfg_lun_queue_depth</span> <span class="o">+</span> <span class="mi">2</span><span class="p">;</span>

	<span class="cm">/* If allocated buffers are enough do nothing */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">sdev_cnt</span> <span class="o">*</span> <span class="p">(</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">cfg_lun_queue_depth</span> <span class="o">+</span> <span class="mi">2</span><span class="p">))</span> <span class="o">&lt;</span> <span class="n">total</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Allow some exchanges to be available always to complete discovery */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">total</span> <span class="o">&gt;=</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">cfg_hba_queue_depth</span> <span class="o">-</span> <span class="n">LPFC_DISC_IOCB_BUFF_COUNT</span> <span class="p">)</span> <span class="p">{</span>
		<span class="n">lpfc_printf_vlog</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">KERN_WARNING</span><span class="p">,</span> <span class="n">LOG_FCP</span><span class="p">,</span>
				 <span class="s">&quot;0704 At limitation of %d preallocated &quot;</span>
				 <span class="s">&quot;command buffers</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">total</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="cm">/* Allow some exchanges to be available always to complete discovery */</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">total</span> <span class="o">+</span> <span class="n">num_to_alloc</span> <span class="o">&gt;</span>
		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">cfg_hba_queue_depth</span> <span class="o">-</span> <span class="n">LPFC_DISC_IOCB_BUFF_COUNT</span> <span class="p">)</span> <span class="p">{</span>
		<span class="n">lpfc_printf_vlog</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">KERN_WARNING</span><span class="p">,</span> <span class="n">LOG_FCP</span><span class="p">,</span>
				 <span class="s">&quot;0705 Allocation request of %d &quot;</span>
				 <span class="s">&quot;command buffers will exceed max of %d.  &quot;</span>
				 <span class="s">&quot;Reducing allocation request to %d.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				 <span class="n">num_to_alloc</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">cfg_hba_queue_depth</span><span class="p">,</span>
				 <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">cfg_hba_queue_depth</span> <span class="o">-</span> <span class="n">total</span><span class="p">));</span>
		<span class="n">num_to_alloc</span> <span class="o">=</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">cfg_hba_queue_depth</span> <span class="o">-</span> <span class="n">total</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">num_allocated</span> <span class="o">=</span> <span class="n">lpfc_new_scsi_buf</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">num_to_alloc</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">num_to_alloc</span> <span class="o">!=</span> <span class="n">num_allocated</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">lpfc_printf_vlog</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">KERN_WARNING</span><span class="p">,</span> <span class="n">LOG_FCP</span><span class="p">,</span>
				 <span class="s">&quot;0708 Allocation request of %d &quot;</span>
				 <span class="s">&quot;command buffers did not succeed.  &quot;</span>
				 <span class="s">&quot;Allocated %d buffers.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				 <span class="n">num_to_alloc</span><span class="p">,</span> <span class="n">num_allocated</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">num_allocated</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">total_scsi_bufs</span> <span class="o">+=</span> <span class="n">num_allocated</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_slave_configure - scsi_host_template slave_configure entry point</span>
<span class="cm"> * @sdev: Pointer to scsi_device.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine configures following items</span>
<span class="cm"> *   - Tag command queuing support for @sdev if supported.</span>
<span class="cm"> *   - Enable SLI polling for fcp ring if ENABLE_FCP_RING_POLLING flag is set.</span>
<span class="cm"> *</span>
<span class="cm"> * Return codes:</span>
<span class="cm"> *   0 - Success</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">lpfc_slave_configure</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="n">sdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="n">vport</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="p">)</span> <span class="n">sdev</span><span class="o">-&gt;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">hostdata</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_hba</span>   <span class="o">*</span><span class="n">phba</span> <span class="o">=</span> <span class="n">vport</span><span class="o">-&gt;</span><span class="n">phba</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">tagged_supported</span><span class="p">)</span>
		<span class="n">scsi_activate_tcq</span><span class="p">(</span><span class="n">sdev</span><span class="p">,</span> <span class="n">vport</span><span class="o">-&gt;</span><span class="n">cfg_lun_queue_depth</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">scsi_deactivate_tcq</span><span class="p">(</span><span class="n">sdev</span><span class="p">,</span> <span class="n">vport</span><span class="o">-&gt;</span><span class="n">cfg_lun_queue_depth</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">cfg_poll</span> <span class="o">&amp;</span> <span class="n">ENABLE_FCP_RING_POLLING</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lpfc_sli_handle_fast_ring_event</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span>
			<span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli</span><span class="p">.</span><span class="n">ring</span><span class="p">[</span><span class="n">LPFC_FCP_RING</span><span class="p">],</span> <span class="n">HA_R0RE_REQ</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">cfg_poll</span> <span class="o">&amp;</span> <span class="n">DISABLE_FCP_RING_INT</span><span class="p">)</span>
			<span class="n">lpfc_poll_rearm_timer</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_slave_destroy - slave_destroy entry point of SHT data structure</span>
<span class="cm"> * @sdev: Pointer to scsi_device.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine sets @sdev hostatdata filed to null.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">lpfc_slave_destroy</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="n">sdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="n">vport</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="p">)</span> <span class="n">sdev</span><span class="o">-&gt;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">hostdata</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_hba</span>   <span class="o">*</span><span class="n">phba</span> <span class="o">=</span> <span class="n">vport</span><span class="o">-&gt;</span><span class="n">phba</span><span class="p">;</span>
	<span class="n">atomic_dec</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sdev_cnt</span><span class="p">);</span>
	<span class="n">sdev</span><span class="o">-&gt;</span><span class="n">hostdata</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>


<span class="k">struct</span> <span class="n">scsi_host_template</span> <span class="n">lpfc_template</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">module</span>			<span class="o">=</span> <span class="n">THIS_MODULE</span><span class="p">,</span>
	<span class="p">.</span><span class="n">name</span>			<span class="o">=</span> <span class="n">LPFC_DRIVER_NAME</span><span class="p">,</span>
	<span class="p">.</span><span class="n">info</span>			<span class="o">=</span> <span class="n">lpfc_info</span><span class="p">,</span>
	<span class="p">.</span><span class="n">queuecommand</span>		<span class="o">=</span> <span class="n">lpfc_queuecommand</span><span class="p">,</span>
	<span class="p">.</span><span class="n">eh_abort_handler</span>	<span class="o">=</span> <span class="n">lpfc_abort_handler</span><span class="p">,</span>
	<span class="p">.</span><span class="n">eh_device_reset_handler</span> <span class="o">=</span> <span class="n">lpfc_device_reset_handler</span><span class="p">,</span>
	<span class="p">.</span><span class="n">eh_target_reset_handler</span> <span class="o">=</span> <span class="n">lpfc_target_reset_handler</span><span class="p">,</span>
	<span class="p">.</span><span class="n">eh_bus_reset_handler</span>	<span class="o">=</span> <span class="n">lpfc_bus_reset_handler</span><span class="p">,</span>
	<span class="p">.</span><span class="n">eh_host_reset_handler</span>  <span class="o">=</span> <span class="n">lpfc_host_reset_handler</span><span class="p">,</span>
	<span class="p">.</span><span class="n">slave_alloc</span>		<span class="o">=</span> <span class="n">lpfc_slave_alloc</span><span class="p">,</span>
	<span class="p">.</span><span class="n">slave_configure</span>	<span class="o">=</span> <span class="n">lpfc_slave_configure</span><span class="p">,</span>
	<span class="p">.</span><span class="n">slave_destroy</span>		<span class="o">=</span> <span class="n">lpfc_slave_destroy</span><span class="p">,</span>
	<span class="p">.</span><span class="n">scan_finished</span>		<span class="o">=</span> <span class="n">lpfc_scan_finished</span><span class="p">,</span>
	<span class="p">.</span><span class="n">this_id</span>		<span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
	<span class="p">.</span><span class="n">sg_tablesize</span>		<span class="o">=</span> <span class="n">LPFC_DEFAULT_SG_SEG_CNT</span><span class="p">,</span>
	<span class="p">.</span><span class="n">cmd_per_lun</span>		<span class="o">=</span> <span class="n">LPFC_CMD_PER_LUN</span><span class="p">,</span>
	<span class="p">.</span><span class="n">use_clustering</span>		<span class="o">=</span> <span class="n">ENABLE_CLUSTERING</span><span class="p">,</span>
	<span class="p">.</span><span class="n">shost_attrs</span>		<span class="o">=</span> <span class="n">lpfc_hba_attrs</span><span class="p">,</span>
	<span class="p">.</span><span class="n">max_sectors</span>		<span class="o">=</span> <span class="mh">0xFFFF</span><span class="p">,</span>
	<span class="p">.</span><span class="n">vendor_id</span>		<span class="o">=</span> <span class="n">LPFC_NL_VENDOR_ID</span><span class="p">,</span>
	<span class="p">.</span><span class="n">change_queue_depth</span>	<span class="o">=</span> <span class="n">lpfc_change_queue_depth</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">scsi_host_template</span> <span class="n">lpfc_vport_template</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">module</span>			<span class="o">=</span> <span class="n">THIS_MODULE</span><span class="p">,</span>
	<span class="p">.</span><span class="n">name</span>			<span class="o">=</span> <span class="n">LPFC_DRIVER_NAME</span><span class="p">,</span>
	<span class="p">.</span><span class="n">info</span>			<span class="o">=</span> <span class="n">lpfc_info</span><span class="p">,</span>
	<span class="p">.</span><span class="n">queuecommand</span>		<span class="o">=</span> <span class="n">lpfc_queuecommand</span><span class="p">,</span>
	<span class="p">.</span><span class="n">eh_abort_handler</span>	<span class="o">=</span> <span class="n">lpfc_abort_handler</span><span class="p">,</span>
	<span class="p">.</span><span class="n">eh_device_reset_handler</span> <span class="o">=</span> <span class="n">lpfc_device_reset_handler</span><span class="p">,</span>
	<span class="p">.</span><span class="n">eh_target_reset_handler</span> <span class="o">=</span> <span class="n">lpfc_target_reset_handler</span><span class="p">,</span>
	<span class="p">.</span><span class="n">eh_bus_reset_handler</span>	<span class="o">=</span> <span class="n">lpfc_bus_reset_handler</span><span class="p">,</span>
	<span class="p">.</span><span class="n">slave_alloc</span>		<span class="o">=</span> <span class="n">lpfc_slave_alloc</span><span class="p">,</span>
	<span class="p">.</span><span class="n">slave_configure</span>	<span class="o">=</span> <span class="n">lpfc_slave_configure</span><span class="p">,</span>
	<span class="p">.</span><span class="n">slave_destroy</span>		<span class="o">=</span> <span class="n">lpfc_slave_destroy</span><span class="p">,</span>
	<span class="p">.</span><span class="n">scan_finished</span>		<span class="o">=</span> <span class="n">lpfc_scan_finished</span><span class="p">,</span>
	<span class="p">.</span><span class="n">this_id</span>		<span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
	<span class="p">.</span><span class="n">sg_tablesize</span>		<span class="o">=</span> <span class="n">LPFC_DEFAULT_SG_SEG_CNT</span><span class="p">,</span>
	<span class="p">.</span><span class="n">cmd_per_lun</span>		<span class="o">=</span> <span class="n">LPFC_CMD_PER_LUN</span><span class="p">,</span>
	<span class="p">.</span><span class="n">use_clustering</span>		<span class="o">=</span> <span class="n">ENABLE_CLUSTERING</span><span class="p">,</span>
	<span class="p">.</span><span class="n">shost_attrs</span>		<span class="o">=</span> <span class="n">lpfc_vport_attrs</span><span class="p">,</span>
	<span class="p">.</span><span class="n">max_sectors</span>		<span class="o">=</span> <span class="mh">0xFFFF</span><span class="p">,</span>
	<span class="p">.</span><span class="n">change_queue_depth</span>	<span class="o">=</span> <span class="n">lpfc_change_queue_depth</span><span class="p">,</span>
<span class="p">};</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
