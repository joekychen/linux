<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › scsi › lpfc › lpfc_els.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>lpfc_els.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*******************************************************************</span>
<span class="cm"> * This file is part of the Emulex Linux Device Driver for         *</span>
<span class="cm"> * Fibre Channel Host Bus Adapters.                                *</span>
<span class="cm"> * Copyright (C) 2004-2012 Emulex.  All rights reserved.           *</span>
<span class="cm"> * EMULEX and SLI are trademarks of Emulex.                        *</span>
<span class="cm"> * www.emulex.com                                                  *</span>
<span class="cm"> * Portions Copyright (C) 2004-2005 Christoph Hellwig              *</span>
<span class="cm"> *                                                                 *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or   *</span>
<span class="cm"> * modify it under the terms of version 2 of the GNU General       *</span>
<span class="cm"> * Public License as published by the Free Software Foundation.    *</span>
<span class="cm"> * This program is distributed in the hope that it will be useful. *</span>
<span class="cm"> * ALL EXPRESS OR IMPLIED CONDITIONS, REPRESENTATIONS AND          *</span>
<span class="cm"> * WARRANTIES, INCLUDING ANY IMPLIED WARRANTY OF MERCHANTABILITY,  *</span>
<span class="cm"> * FITNESS FOR A PARTICULAR PURPOSE, OR NON-INFRINGEMENT, ARE      *</span>
<span class="cm"> * DISCLAIMED, EXCEPT TO THE EXTENT THAT SUCH DISCLAIMERS ARE HELD *</span>
<span class="cm"> * TO BE LEGALLY INVALID.  See the GNU General Public License for  *</span>
<span class="cm"> * more details, a copy of which can be found in the file COPYING  *</span>
<span class="cm"> * included with this package.                                     *</span>
<span class="cm"> *******************************************************************/</span>
<span class="cm">/* See Fibre Channel protocol T11 FC-LS for details */</span>
<span class="cp">#include &lt;linux/blkdev.h&gt;</span>
<span class="cp">#include &lt;linux/pci.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/interrupt.h&gt;</span>

<span class="cp">#include &lt;scsi/scsi.h&gt;</span>
<span class="cp">#include &lt;scsi/scsi_device.h&gt;</span>
<span class="cp">#include &lt;scsi/scsi_host.h&gt;</span>
<span class="cp">#include &lt;scsi/scsi_transport_fc.h&gt;</span>

<span class="cp">#include &quot;lpfc_hw4.h&quot;</span>
<span class="cp">#include &quot;lpfc_hw.h&quot;</span>
<span class="cp">#include &quot;lpfc_sli.h&quot;</span>
<span class="cp">#include &quot;lpfc_sli4.h&quot;</span>
<span class="cp">#include &quot;lpfc_nl.h&quot;</span>
<span class="cp">#include &quot;lpfc_disc.h&quot;</span>
<span class="cp">#include &quot;lpfc_scsi.h&quot;</span>
<span class="cp">#include &quot;lpfc.h&quot;</span>
<span class="cp">#include &quot;lpfc_logmsg.h&quot;</span>
<span class="cp">#include &quot;lpfc_crtn.h&quot;</span>
<span class="cp">#include &quot;lpfc_vport.h&quot;</span>
<span class="cp">#include &quot;lpfc_debugfs.h&quot;</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">lpfc_els_retry</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">lpfc_iocbq</span> <span class="o">*</span><span class="p">,</span>
			  <span class="k">struct</span> <span class="n">lpfc_iocbq</span> <span class="o">*</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">lpfc_cmpl_fabric_iocb</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">lpfc_iocbq</span> <span class="o">*</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">lpfc_iocbq</span> <span class="o">*</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">lpfc_fabric_abort_vport</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="n">vport</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">lpfc_issue_els_fdisc</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="n">vport</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">lpfc_nodelist</span> <span class="o">*</span><span class="n">ndlp</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="n">retry</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">lpfc_issue_fabric_iocb</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">lpfc_iocbq</span> <span class="o">*</span><span class="n">iocb</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">lpfc_max_els_tries</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_els_chk_latt - Check host link attention event for a vport</span>
<span class="cm"> * @vport: pointer to a host virtual N_Port data structure.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine checks whether there is an outstanding host link</span>
<span class="cm"> * attention event during the discovery process with the @vport. It is done</span>
<span class="cm"> * by reading the HBA&#39;s Host Attention (HA) register. If there is any host</span>
<span class="cm"> * link attention events during this @vport&#39;s discovery process, the @vport</span>
<span class="cm"> * shall be marked as FC_ABORT_DISCOVERY, a host link attention clear shall</span>
<span class="cm"> * be issued if the link state is not already in host link cleared state,</span>
<span class="cm"> * and a return code shall indicate whether the host link attention event</span>
<span class="cm"> * had happened.</span>
<span class="cm"> *</span>
<span class="cm"> * Note that, if either the host link is in state LPFC_LINK_DOWN or @vport</span>
<span class="cm"> * state in LPFC_VPORT_READY, the request for checking host link attention</span>
<span class="cm"> * event will be ignored and a return code shall indicate no host link</span>
<span class="cm"> * attention event had happened.</span>
<span class="cm"> *</span>
<span class="cm"> * Return codes</span>
<span class="cm"> *   0 - no host link attention event happened</span>
<span class="cm"> *   1 - host link attention event happened</span>
<span class="cm"> **/</span>
<span class="kt">int</span>
<span class="nf">lpfc_els_chk_latt</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="n">vport</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span> <span class="o">=</span> <span class="n">lpfc_shost_from_vport</span><span class="p">(</span><span class="n">vport</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">lpfc_hba</span>  <span class="o">*</span><span class="n">phba</span> <span class="o">=</span> <span class="n">vport</span><span class="o">-&gt;</span><span class="n">phba</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">ha_copy</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">port_state</span> <span class="o">&gt;=</span> <span class="n">LPFC_VPORT_READY</span> <span class="o">||</span>
	    <span class="n">phba</span><span class="o">-&gt;</span><span class="n">link_state</span> <span class="o">==</span> <span class="n">LPFC_LINK_DOWN</span> <span class="o">||</span>
	    <span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli_rev</span> <span class="o">&gt;</span> <span class="n">LPFC_SLI_REV3</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Read the HBA Host Attention Register */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">lpfc_readl</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">HAregaddr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ha_copy</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">ha_copy</span> <span class="o">&amp;</span> <span class="n">HA_LATT</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Pending Link Event during Discovery */</span>
	<span class="n">lpfc_printf_vlog</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_DISCOVERY</span><span class="p">,</span>
			 <span class="s">&quot;0237 Pending Link Event during &quot;</span>
			 <span class="s">&quot;Discovery: State x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			 <span class="n">phba</span><span class="o">-&gt;</span><span class="n">pport</span><span class="o">-&gt;</span><span class="n">port_state</span><span class="p">);</span>

	<span class="cm">/* CLEAR_LA should re-enable link attention events and</span>
<span class="cm">	 * we should then immediately take a LATT event. The</span>
<span class="cm">	 * LATT processing should call lpfc_linkdown() which</span>
<span class="cm">	 * will cleanup any left over in-progress discovery</span>
<span class="cm">	 * events.</span>
<span class="cm">	 */</span>
	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>
	<span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_flag</span> <span class="o">|=</span> <span class="n">FC_ABORT_DISCOVERY</span><span class="p">;</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">link_state</span> <span class="o">!=</span> <span class="n">LPFC_CLEAR_LA</span><span class="p">)</span>
		<span class="n">lpfc_issue_clear_la</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">vport</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_prep_els_iocb - Allocate and prepare a lpfc iocb data structure</span>
<span class="cm"> * @vport: pointer to a host virtual N_Port data structure.</span>
<span class="cm"> * @expectRsp: flag indicating whether response is expected.</span>
<span class="cm"> * @cmdSize: size of the ELS command.</span>
<span class="cm"> * @retry: number of retries to the command IOCB when it fails.</span>
<span class="cm"> * @ndlp: pointer to a node-list data structure.</span>
<span class="cm"> * @did: destination identifier.</span>
<span class="cm"> * @elscmd: the ELS command code.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine is used for allocating a lpfc-IOCB data structure from</span>
<span class="cm"> * the driver lpfc-IOCB free-list and prepare the IOCB with the parameters</span>
<span class="cm"> * passed into the routine for discovery state machine to issue an Extended</span>
<span class="cm"> * Link Service (ELS) commands. It is a generic lpfc-IOCB allocation</span>
<span class="cm"> * and preparation routine that is used by all the discovery state machine</span>
<span class="cm"> * routines and the ELS command-specific fields will be later set up by</span>
<span class="cm"> * the individual discovery machine routines after calling this routine</span>
<span class="cm"> * allocating and preparing a generic IOCB data structure. It fills in the</span>
<span class="cm"> * Buffer Descriptor Entries (BDEs), allocates buffers for both command</span>
<span class="cm"> * payload and response payload (if expected). The reference count on the</span>
<span class="cm"> * ndlp is incremented by 1 and the reference to the ndlp is put into</span>
<span class="cm"> * context1 of the IOCB data structure for this IOCB to hold the ndlp</span>
<span class="cm"> * reference for the command&#39;s callback function to access later.</span>
<span class="cm"> *</span>
<span class="cm"> * Return code</span>
<span class="cm"> *   Pointer to the newly allocated/prepared els iocb data structure</span>
<span class="cm"> *   NULL - when els iocb data structure allocation/preparation failed</span>
<span class="cm"> **/</span>
<span class="k">struct</span> <span class="n">lpfc_iocbq</span> <span class="o">*</span>
<span class="nf">lpfc_prep_els_iocb</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="n">vport</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="n">expectRsp</span><span class="p">,</span>
		   <span class="kt">uint16_t</span> <span class="n">cmdSize</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="n">retry</span><span class="p">,</span>
		   <span class="k">struct</span> <span class="n">lpfc_nodelist</span> <span class="o">*</span><span class="n">ndlp</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">did</span><span class="p">,</span>
		   <span class="kt">uint32_t</span> <span class="n">elscmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpfc_hba</span>  <span class="o">*</span><span class="n">phba</span> <span class="o">=</span> <span class="n">vport</span><span class="o">-&gt;</span><span class="n">phba</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_iocbq</span> <span class="o">*</span><span class="n">elsiocb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_dmabuf</span> <span class="o">*</span><span class="n">pcmd</span><span class="p">,</span> <span class="o">*</span><span class="n">prsp</span><span class="p">,</span> <span class="o">*</span><span class="n">pbuflist</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ulp_bde64</span> <span class="o">*</span><span class="n">bpl</span><span class="p">;</span>
	<span class="n">IOCB_t</span> <span class="o">*</span><span class="n">icmd</span><span class="p">;</span>


	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">lpfc_is_link_up</span><span class="p">(</span><span class="n">phba</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="cm">/* Allocate buffer for  command iocb */</span>
	<span class="n">elsiocb</span> <span class="o">=</span> <span class="n">lpfc_sli_get_iocbq</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">elsiocb</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * If this command is for fabric controller and HBA running</span>
<span class="cm">	 * in FIP mode send FLOGI, FDISC and LOGO as FIP frames.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">did</span> <span class="o">==</span> <span class="n">Fabric_DID</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		<span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hba_flag</span> <span class="o">&amp;</span> <span class="n">HBA_FIP_SUPPORT</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		<span class="p">((</span><span class="n">elscmd</span> <span class="o">==</span> <span class="n">ELS_CMD_FLOGI</span><span class="p">)</span> <span class="o">||</span>
		 <span class="p">(</span><span class="n">elscmd</span> <span class="o">==</span> <span class="n">ELS_CMD_FDISC</span><span class="p">)</span> <span class="o">||</span>
		 <span class="p">(</span><span class="n">elscmd</span> <span class="o">==</span> <span class="n">ELS_CMD_LOGO</span><span class="p">)))</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">elscmd</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">ELS_CMD_FLOGI</span>:
		<span class="n">elsiocb</span><span class="o">-&gt;</span><span class="n">iocb_flag</span> <span class="o">|=</span>
			<span class="p">((</span><span class="n">LPFC_ELS_ID_FLOGI</span> <span class="o">&lt;&lt;</span> <span class="n">LPFC_FIP_ELS_ID_SHIFT</span><span class="p">)</span>
					<span class="o">&amp;</span> <span class="n">LPFC_FIP_ELS_ID_MASK</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">ELS_CMD_FDISC</span>:
		<span class="n">elsiocb</span><span class="o">-&gt;</span><span class="n">iocb_flag</span> <span class="o">|=</span>
			<span class="p">((</span><span class="n">LPFC_ELS_ID_FDISC</span> <span class="o">&lt;&lt;</span> <span class="n">LPFC_FIP_ELS_ID_SHIFT</span><span class="p">)</span>
					<span class="o">&amp;</span> <span class="n">LPFC_FIP_ELS_ID_MASK</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">ELS_CMD_LOGO</span>:
		<span class="n">elsiocb</span><span class="o">-&gt;</span><span class="n">iocb_flag</span> <span class="o">|=</span>
			<span class="p">((</span><span class="n">LPFC_ELS_ID_LOGO</span> <span class="o">&lt;&lt;</span> <span class="n">LPFC_FIP_ELS_ID_SHIFT</span><span class="p">)</span>
					<span class="o">&amp;</span> <span class="n">LPFC_FIP_ELS_ID_MASK</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="k">else</span>
		<span class="n">elsiocb</span><span class="o">-&gt;</span><span class="n">iocb_flag</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">LPFC_FIP_ELS_ID_MASK</span><span class="p">;</span>

	<span class="n">icmd</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">elsiocb</span><span class="o">-&gt;</span><span class="n">iocb</span><span class="p">;</span>

	<span class="cm">/* fill in BDEs for command */</span>
	<span class="cm">/* Allocate buffer for command payload */</span>
	<span class="n">pcmd</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_dmabuf</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pcmd</span><span class="p">)</span>
		<span class="n">pcmd</span><span class="o">-&gt;</span><span class="n">virt</span> <span class="o">=</span> <span class="n">lpfc_mbuf_alloc</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">MEM_PRI</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pcmd</span><span class="o">-&gt;</span><span class="n">phys</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pcmd</span> <span class="o">||</span> <span class="o">!</span><span class="n">pcmd</span><span class="o">-&gt;</span><span class="n">virt</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">els_iocb_free_pcmb_exit</span><span class="p">;</span>

	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pcmd</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>

	<span class="cm">/* Allocate buffer for response payload */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">expectRsp</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">prsp</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_dmabuf</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">prsp</span><span class="p">)</span>
			<span class="n">prsp</span><span class="o">-&gt;</span><span class="n">virt</span> <span class="o">=</span> <span class="n">lpfc_mbuf_alloc</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">MEM_PRI</span><span class="p">,</span>
						     <span class="o">&amp;</span><span class="n">prsp</span><span class="o">-&gt;</span><span class="n">phys</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">prsp</span> <span class="o">||</span> <span class="o">!</span><span class="n">prsp</span><span class="o">-&gt;</span><span class="n">virt</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">els_iocb_free_prsp_exit</span><span class="p">;</span>
		<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">prsp</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">prsp</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="cm">/* Allocate buffer for Buffer ptr list */</span>
	<span class="n">pbuflist</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_dmabuf</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pbuflist</span><span class="p">)</span>
		<span class="n">pbuflist</span><span class="o">-&gt;</span><span class="n">virt</span> <span class="o">=</span> <span class="n">lpfc_mbuf_alloc</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">MEM_PRI</span><span class="p">,</span>
						 <span class="o">&amp;</span><span class="n">pbuflist</span><span class="o">-&gt;</span><span class="n">phys</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pbuflist</span> <span class="o">||</span> <span class="o">!</span><span class="n">pbuflist</span><span class="o">-&gt;</span><span class="n">virt</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">els_iocb_free_pbuf_exit</span><span class="p">;</span>

	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pbuflist</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">expectRsp</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">icmd</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">elsreq64</span><span class="p">.</span><span class="n">bdl</span><span class="p">.</span><span class="n">addrHigh</span> <span class="o">=</span> <span class="n">putPaddrHigh</span><span class="p">(</span><span class="n">pbuflist</span><span class="o">-&gt;</span><span class="n">phys</span><span class="p">);</span>
		<span class="n">icmd</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">elsreq64</span><span class="p">.</span><span class="n">bdl</span><span class="p">.</span><span class="n">addrLow</span> <span class="o">=</span> <span class="n">putPaddrLow</span><span class="p">(</span><span class="n">pbuflist</span><span class="o">-&gt;</span><span class="n">phys</span><span class="p">);</span>
		<span class="n">icmd</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">elsreq64</span><span class="p">.</span><span class="n">bdl</span><span class="p">.</span><span class="n">bdeFlags</span> <span class="o">=</span> <span class="n">BUFF_TYPE_BLP_64</span><span class="p">;</span>
		<span class="n">icmd</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">elsreq64</span><span class="p">.</span><span class="n">bdl</span><span class="p">.</span><span class="n">bdeSize</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ulp_bde64</span><span class="p">));</span>

		<span class="n">icmd</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">elsreq64</span><span class="p">.</span><span class="n">remoteID</span> <span class="o">=</span> <span class="n">did</span><span class="p">;</span>		<span class="cm">/* DID */</span>
		<span class="n">icmd</span><span class="o">-&gt;</span><span class="n">ulpCommand</span> <span class="o">=</span> <span class="n">CMD_ELS_REQUEST64_CR</span><span class="p">;</span>
		<span class="n">icmd</span><span class="o">-&gt;</span><span class="n">ulpTimeout</span> <span class="o">=</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">fc_ratov</span> <span class="o">*</span> <span class="mi">2</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">icmd</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">xseq64</span><span class="p">.</span><span class="n">bdl</span><span class="p">.</span><span class="n">addrHigh</span> <span class="o">=</span> <span class="n">putPaddrHigh</span><span class="p">(</span><span class="n">pbuflist</span><span class="o">-&gt;</span><span class="n">phys</span><span class="p">);</span>
		<span class="n">icmd</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">xseq64</span><span class="p">.</span><span class="n">bdl</span><span class="p">.</span><span class="n">addrLow</span> <span class="o">=</span> <span class="n">putPaddrLow</span><span class="p">(</span><span class="n">pbuflist</span><span class="o">-&gt;</span><span class="n">phys</span><span class="p">);</span>
		<span class="n">icmd</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">xseq64</span><span class="p">.</span><span class="n">bdl</span><span class="p">.</span><span class="n">bdeFlags</span> <span class="o">=</span> <span class="n">BUFF_TYPE_BLP_64</span><span class="p">;</span>
		<span class="n">icmd</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">xseq64</span><span class="p">.</span><span class="n">bdl</span><span class="p">.</span><span class="n">bdeSize</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ulp_bde64</span><span class="p">);</span>
		<span class="n">icmd</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">xseq64</span><span class="p">.</span><span class="n">xmit_els_remoteID</span> <span class="o">=</span> <span class="n">did</span><span class="p">;</span>	<span class="cm">/* DID */</span>
		<span class="n">icmd</span><span class="o">-&gt;</span><span class="n">ulpCommand</span> <span class="o">=</span> <span class="n">CMD_XMIT_ELS_RSP64_CX</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">icmd</span><span class="o">-&gt;</span><span class="n">ulpBdeCount</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">icmd</span><span class="o">-&gt;</span><span class="n">ulpLe</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">icmd</span><span class="o">-&gt;</span><span class="n">ulpClass</span> <span class="o">=</span> <span class="n">CLASS3</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * If we have NPIV enabled, we want to send ELS traffic by VPI.</span>
<span class="cm">	 * For SLI4, since the driver controls VPIs we also want to include</span>
<span class="cm">	 * all ELS pt2pt protocol traffic as well.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli3_options</span> <span class="o">&amp;</span> <span class="n">LPFC_SLI3_NPIV_ENABLED</span><span class="p">)</span> <span class="o">||</span>
		<span class="p">((</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli_rev</span> <span class="o">==</span> <span class="n">LPFC_SLI_REV4</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="p">(</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_flag</span> <span class="o">&amp;</span> <span class="n">FC_PT2PT</span><span class="p">)))</span> <span class="p">{</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">expectRsp</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">icmd</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">elsreq64</span><span class="p">.</span><span class="n">myID</span> <span class="o">=</span> <span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_myDID</span><span class="p">;</span>

			<span class="cm">/* For ELS_REQUEST64_CR, use the VPI by default */</span>
			<span class="n">icmd</span><span class="o">-&gt;</span><span class="n">ulpContext</span> <span class="o">=</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">vpi_ids</span><span class="p">[</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">vpi</span><span class="p">];</span>
		<span class="p">}</span>

		<span class="n">icmd</span><span class="o">-&gt;</span><span class="n">ulpCt_h</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="cm">/* The CT field must be 0=INVALID_RPI for the ECHO cmd */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">elscmd</span> <span class="o">==</span> <span class="n">ELS_CMD_ECHO</span><span class="p">)</span>
			<span class="n">icmd</span><span class="o">-&gt;</span><span class="n">ulpCt_l</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="cm">/* context = invalid RPI */</span>
		<span class="k">else</span>
			<span class="n">icmd</span><span class="o">-&gt;</span><span class="n">ulpCt_l</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="cm">/* context = VPI */</span>
	<span class="p">}</span>

	<span class="n">bpl</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ulp_bde64</span> <span class="o">*</span><span class="p">)</span> <span class="n">pbuflist</span><span class="o">-&gt;</span><span class="n">virt</span><span class="p">;</span>
	<span class="n">bpl</span><span class="o">-&gt;</span><span class="n">addrLow</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">putPaddrLow</span><span class="p">(</span><span class="n">pcmd</span><span class="o">-&gt;</span><span class="n">phys</span><span class="p">));</span>
	<span class="n">bpl</span><span class="o">-&gt;</span><span class="n">addrHigh</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">putPaddrHigh</span><span class="p">(</span><span class="n">pcmd</span><span class="o">-&gt;</span><span class="n">phys</span><span class="p">));</span>
	<span class="n">bpl</span><span class="o">-&gt;</span><span class="n">tus</span><span class="p">.</span><span class="n">f</span><span class="p">.</span><span class="n">bdeSize</span> <span class="o">=</span> <span class="n">cmdSize</span><span class="p">;</span>
	<span class="n">bpl</span><span class="o">-&gt;</span><span class="n">tus</span><span class="p">.</span><span class="n">f</span><span class="p">.</span><span class="n">bdeFlags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">bpl</span><span class="o">-&gt;</span><span class="n">tus</span><span class="p">.</span><span class="n">w</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">bpl</span><span class="o">-&gt;</span><span class="n">tus</span><span class="p">.</span><span class="n">w</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">expectRsp</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">bpl</span><span class="o">++</span><span class="p">;</span>
		<span class="n">bpl</span><span class="o">-&gt;</span><span class="n">addrLow</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">putPaddrLow</span><span class="p">(</span><span class="n">prsp</span><span class="o">-&gt;</span><span class="n">phys</span><span class="p">));</span>
		<span class="n">bpl</span><span class="o">-&gt;</span><span class="n">addrHigh</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">putPaddrHigh</span><span class="p">(</span><span class="n">prsp</span><span class="o">-&gt;</span><span class="n">phys</span><span class="p">));</span>
		<span class="n">bpl</span><span class="o">-&gt;</span><span class="n">tus</span><span class="p">.</span><span class="n">f</span><span class="p">.</span><span class="n">bdeSize</span> <span class="o">=</span> <span class="n">FCELSSIZE</span><span class="p">;</span>
		<span class="n">bpl</span><span class="o">-&gt;</span><span class="n">tus</span><span class="p">.</span><span class="n">f</span><span class="p">.</span><span class="n">bdeFlags</span> <span class="o">=</span> <span class="n">BUFF_TYPE_BDE_64</span><span class="p">;</span>
		<span class="n">bpl</span><span class="o">-&gt;</span><span class="n">tus</span><span class="p">.</span><span class="n">w</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">bpl</span><span class="o">-&gt;</span><span class="n">tus</span><span class="p">.</span><span class="n">w</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* prevent preparing iocb with NULL ndlp reference */</span>
	<span class="n">elsiocb</span><span class="o">-&gt;</span><span class="n">context1</span> <span class="o">=</span> <span class="n">lpfc_nlp_get</span><span class="p">(</span><span class="n">ndlp</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">elsiocb</span><span class="o">-&gt;</span><span class="n">context1</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">els_iocb_free_pbuf_exit</span><span class="p">;</span>
	<span class="n">elsiocb</span><span class="o">-&gt;</span><span class="n">context2</span> <span class="o">=</span> <span class="n">pcmd</span><span class="p">;</span>
	<span class="n">elsiocb</span><span class="o">-&gt;</span><span class="n">context3</span> <span class="o">=</span> <span class="n">pbuflist</span><span class="p">;</span>
	<span class="n">elsiocb</span><span class="o">-&gt;</span><span class="n">retry</span> <span class="o">=</span> <span class="n">retry</span><span class="p">;</span>
	<span class="n">elsiocb</span><span class="o">-&gt;</span><span class="n">vport</span> <span class="o">=</span> <span class="n">vport</span><span class="p">;</span>
	<span class="n">elsiocb</span><span class="o">-&gt;</span><span class="n">drvrTimeout</span> <span class="o">=</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">fc_ratov</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">LPFC_DRVR_TIMEOUT</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">prsp</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">prsp</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pcmd</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">expectRsp</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Xmit ELS command &lt;elsCmd&gt; to remote NPORT &lt;did&gt; */</span>
		<span class="n">lpfc_printf_vlog</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">KERN_INFO</span><span class="p">,</span> <span class="n">LOG_ELS</span><span class="p">,</span>
				 <span class="s">&quot;0116 Xmit ELS command x%x to remote &quot;</span>
				 <span class="s">&quot;NPORT x%x I/O tag: x%x, port state: x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				 <span class="n">elscmd</span><span class="p">,</span> <span class="n">did</span><span class="p">,</span> <span class="n">elsiocb</span><span class="o">-&gt;</span><span class="n">iotag</span><span class="p">,</span>
				 <span class="n">vport</span><span class="o">-&gt;</span><span class="n">port_state</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* Xmit ELS response &lt;elsCmd&gt; to remote NPORT &lt;did&gt; */</span>
		<span class="n">lpfc_printf_vlog</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">KERN_INFO</span><span class="p">,</span> <span class="n">LOG_ELS</span><span class="p">,</span>
				 <span class="s">&quot;0117 Xmit ELS response x%x to remote &quot;</span>
				 <span class="s">&quot;NPORT x%x I/O tag: x%x, size: x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				 <span class="n">elscmd</span><span class="p">,</span> <span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_DID</span><span class="p">,</span> <span class="n">elsiocb</span><span class="o">-&gt;</span><span class="n">iotag</span><span class="p">,</span>
				 <span class="n">cmdSize</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">elsiocb</span><span class="p">;</span>

<span class="nl">els_iocb_free_pbuf_exit:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">expectRsp</span><span class="p">)</span>
		<span class="n">lpfc_mbuf_free</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">prsp</span><span class="o">-&gt;</span><span class="n">virt</span><span class="p">,</span> <span class="n">prsp</span><span class="o">-&gt;</span><span class="n">phys</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">pbuflist</span><span class="p">);</span>

<span class="nl">els_iocb_free_prsp_exit:</span>
	<span class="n">lpfc_mbuf_free</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">pcmd</span><span class="o">-&gt;</span><span class="n">virt</span><span class="p">,</span> <span class="n">pcmd</span><span class="o">-&gt;</span><span class="n">phys</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">prsp</span><span class="p">);</span>

<span class="nl">els_iocb_free_pcmb_exit:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">pcmd</span><span class="p">);</span>
	<span class="n">lpfc_sli_release_iocbq</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">elsiocb</span><span class="p">);</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_issue_fabric_reglogin - Issue fabric registration login for a vport</span>
<span class="cm"> * @vport: pointer to a host virtual N_Port data structure.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine issues a fabric registration login for a @vport. An</span>
<span class="cm"> * active ndlp node with Fabric_DID must already exist for this @vport.</span>
<span class="cm"> * The routine invokes two mailbox commands to carry out fabric registration</span>
<span class="cm"> * login through the HBA firmware: the first mailbox command requests the</span>
<span class="cm"> * HBA to perform link configuration for the @vport; and the second mailbox</span>
<span class="cm"> * command requests the HBA to perform the actual fabric registration login</span>
<span class="cm"> * with the @vport.</span>
<span class="cm"> *</span>
<span class="cm"> * Return code</span>
<span class="cm"> *   0 - successfully issued fabric registration login for @vport</span>
<span class="cm"> *   -ENXIO -- failed to issue fabric registration login for @vport</span>
<span class="cm"> **/</span>
<span class="kt">int</span>
<span class="nf">lpfc_issue_fabric_reglogin</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="n">vport</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpfc_hba</span>  <span class="o">*</span><span class="n">phba</span> <span class="o">=</span> <span class="n">vport</span><span class="o">-&gt;</span><span class="n">phba</span><span class="p">;</span>
	<span class="n">LPFC_MBOXQ_t</span> <span class="o">*</span><span class="n">mbox</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_dmabuf</span> <span class="o">*</span><span class="n">mp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_nodelist</span> <span class="o">*</span><span class="n">ndlp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">serv_parm</span> <span class="o">*</span><span class="n">sp</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">sp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">fc_fabparam</span><span class="p">;</span>
	<span class="n">ndlp</span> <span class="o">=</span> <span class="n">lpfc_findnode_did</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">Fabric_DID</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ndlp</span> <span class="o">||</span> <span class="o">!</span><span class="n">NLP_CHK_NODE_ACT</span><span class="p">(</span><span class="n">ndlp</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">mbox</span> <span class="o">=</span> <span class="n">mempool_alloc</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">mbox_mem_pool</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mbox</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">vport</span><span class="o">-&gt;</span><span class="n">port_state</span> <span class="o">=</span> <span class="n">LPFC_FABRIC_CFG_LINK</span><span class="p">;</span>
	<span class="n">lpfc_config_link</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">mbox</span><span class="p">);</span>
	<span class="n">mbox</span><span class="o">-&gt;</span><span class="n">mbox_cmpl</span> <span class="o">=</span> <span class="n">lpfc_sli_def_mbox_cmpl</span><span class="p">;</span>
	<span class="n">mbox</span><span class="o">-&gt;</span><span class="n">vport</span> <span class="o">=</span> <span class="n">vport</span><span class="p">;</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">lpfc_sli_issue_mbox</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">mbox</span><span class="p">,</span> <span class="n">MBX_NOWAIT</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">==</span> <span class="n">MBX_NOT_FINISHED</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">fail_free_mbox</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">mbox</span> <span class="o">=</span> <span class="n">mempool_alloc</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">mbox_mem_pool</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mbox</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">lpfc_reg_rpi</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">vport</span><span class="o">-&gt;</span><span class="n">vpi</span><span class="p">,</span> <span class="n">Fabric_DID</span><span class="p">,</span> <span class="p">(</span><span class="kt">uint8_t</span> <span class="o">*</span><span class="p">)</span><span class="n">sp</span><span class="p">,</span> <span class="n">mbox</span><span class="p">,</span>
			  <span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_rpi</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">fail_free_mbox</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">mbox</span><span class="o">-&gt;</span><span class="n">mbox_cmpl</span> <span class="o">=</span> <span class="n">lpfc_mbx_cmpl_fabric_reg_login</span><span class="p">;</span>
	<span class="n">mbox</span><span class="o">-&gt;</span><span class="n">vport</span> <span class="o">=</span> <span class="n">vport</span><span class="p">;</span>
	<span class="cm">/* increment the reference count on ndlp to hold reference</span>
<span class="cm">	 * for the callback routine.</span>
<span class="cm">	 */</span>
	<span class="n">mbox</span><span class="o">-&gt;</span><span class="n">context2</span> <span class="o">=</span> <span class="n">lpfc_nlp_get</span><span class="p">(</span><span class="n">ndlp</span><span class="p">);</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">lpfc_sli_issue_mbox</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">mbox</span><span class="p">,</span> <span class="n">MBX_NOWAIT</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">==</span> <span class="n">MBX_NOT_FINISHED</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="mi">6</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">fail_issue_reg_login</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">fail_issue_reg_login:</span>
	<span class="cm">/* decrement the reference count on ndlp just incremented</span>
<span class="cm">	 * for the failed mbox command.</span>
<span class="cm">	 */</span>
	<span class="n">lpfc_nlp_put</span><span class="p">(</span><span class="n">ndlp</span><span class="p">);</span>
	<span class="n">mp</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_dmabuf</span> <span class="o">*</span><span class="p">)</span> <span class="n">mbox</span><span class="o">-&gt;</span><span class="n">context1</span><span class="p">;</span>
	<span class="n">lpfc_mbuf_free</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">virt</span><span class="p">,</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">phys</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">mp</span><span class="p">);</span>
<span class="nl">fail_free_mbox:</span>
	<span class="n">mempool_free</span><span class="p">(</span><span class="n">mbox</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">mbox_mem_pool</span><span class="p">);</span>

<span class="nl">fail:</span>
	<span class="n">lpfc_vport_set_state</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">FC_VPORT_FAILED</span><span class="p">);</span>
	<span class="n">lpfc_printf_vlog</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_ELS</span><span class="p">,</span>
		<span class="s">&quot;0249 Cannot issue Register Fabric login: Err %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">ENXIO</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_issue_reg_vfi - Register VFI for this vport&#39;s fabric login</span>
<span class="cm"> * @vport: pointer to a host virtual N_Port data structure.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine issues a REG_VFI mailbox for the vfi, vpi, fcfi triplet for</span>
<span class="cm"> * the @vport. This mailbox command is necessary for SLI4 port only.</span>
<span class="cm"> *</span>
<span class="cm"> * Return code</span>
<span class="cm"> *   0 - successfully issued REG_VFI for @vport</span>
<span class="cm"> *   A failure code otherwise.</span>
<span class="cm"> **/</span>
<span class="kt">int</span>
<span class="nf">lpfc_issue_reg_vfi</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="n">vport</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpfc_hba</span>  <span class="o">*</span><span class="n">phba</span> <span class="o">=</span> <span class="n">vport</span><span class="o">-&gt;</span><span class="n">phba</span><span class="p">;</span>
	<span class="n">LPFC_MBOXQ_t</span> <span class="o">*</span><span class="n">mboxq</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_nodelist</span> <span class="o">*</span><span class="n">ndlp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">serv_parm</span> <span class="o">*</span><span class="n">sp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_dmabuf</span> <span class="o">*</span><span class="n">dmabuf</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">sp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">fc_fabparam</span><span class="p">;</span>
	<span class="cm">/* move forward in case of SLI4 FC port loopback test and pt2pt mode */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli_rev</span> <span class="o">==</span> <span class="n">LPFC_SLI_REV4</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="o">!</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">link_flag</span> <span class="o">&amp;</span> <span class="n">LS_LOOPBACK_MODE</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="o">!</span><span class="p">(</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_flag</span> <span class="o">&amp;</span> <span class="n">FC_PT2PT</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ndlp</span> <span class="o">=</span> <span class="n">lpfc_findnode_did</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">Fabric_DID</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ndlp</span> <span class="o">||</span> <span class="o">!</span><span class="n">NLP_CHK_NODE_ACT</span><span class="p">(</span><span class="n">ndlp</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">dmabuf</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_dmabuf</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dmabuf</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">dmabuf</span><span class="o">-&gt;</span><span class="n">virt</span> <span class="o">=</span> <span class="n">lpfc_mbuf_alloc</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">MEM_PRI</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dmabuf</span><span class="o">-&gt;</span><span class="n">phys</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dmabuf</span><span class="o">-&gt;</span><span class="n">virt</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">fail_free_dmabuf</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">mboxq</span> <span class="o">=</span> <span class="n">mempool_alloc</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">mbox_mem_pool</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mboxq</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">fail_free_coherent</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">vport</span><span class="o">-&gt;</span><span class="n">port_state</span> <span class="o">=</span> <span class="n">LPFC_FABRIC_CFG_LINK</span><span class="p">;</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">dmabuf</span><span class="o">-&gt;</span><span class="n">virt</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">fc_fabparam</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_sparam</span><span class="p">));</span>
	<span class="n">lpfc_reg_vfi</span><span class="p">(</span><span class="n">mboxq</span><span class="p">,</span> <span class="n">vport</span><span class="p">,</span> <span class="n">dmabuf</span><span class="o">-&gt;</span><span class="n">phys</span><span class="p">);</span>
	<span class="n">mboxq</span><span class="o">-&gt;</span><span class="n">mbox_cmpl</span> <span class="o">=</span> <span class="n">lpfc_mbx_cmpl_reg_vfi</span><span class="p">;</span>
	<span class="n">mboxq</span><span class="o">-&gt;</span><span class="n">vport</span> <span class="o">=</span> <span class="n">vport</span><span class="p">;</span>
	<span class="n">mboxq</span><span class="o">-&gt;</span><span class="n">context1</span> <span class="o">=</span> <span class="n">dmabuf</span><span class="p">;</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">lpfc_sli_issue_mbox</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">mboxq</span><span class="p">,</span> <span class="n">MBX_NOWAIT</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">==</span> <span class="n">MBX_NOT_FINISHED</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENXIO</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">fail_free_mbox</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">fail_free_mbox:</span>
	<span class="n">mempool_free</span><span class="p">(</span><span class="n">mboxq</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">mbox_mem_pool</span><span class="p">);</span>
<span class="nl">fail_free_coherent:</span>
	<span class="n">lpfc_mbuf_free</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">dmabuf</span><span class="o">-&gt;</span><span class="n">virt</span><span class="p">,</span> <span class="n">dmabuf</span><span class="o">-&gt;</span><span class="n">phys</span><span class="p">);</span>
<span class="nl">fail_free_dmabuf:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">dmabuf</span><span class="p">);</span>
<span class="nl">fail:</span>
	<span class="n">lpfc_vport_set_state</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">FC_VPORT_FAILED</span><span class="p">);</span>
	<span class="n">lpfc_printf_vlog</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_ELS</span><span class="p">,</span>
		<span class="s">&quot;0289 Issue Register VFI failed: Err %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">rc</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_issue_unreg_vfi - Unregister VFI for this vport&#39;s fabric login</span>
<span class="cm"> * @vport: pointer to a host virtual N_Port data structure.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine issues a UNREG_VFI mailbox with the vfi, vpi, fcfi triplet for</span>
<span class="cm"> * the @vport. This mailbox command is necessary for SLI4 port only.</span>
<span class="cm"> *</span>
<span class="cm"> * Return code</span>
<span class="cm"> *   0 - successfully issued REG_VFI for @vport</span>
<span class="cm"> *   A failure code otherwise.</span>
<span class="cm"> **/</span>
<span class="kt">int</span>
<span class="nf">lpfc_issue_unreg_vfi</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="n">vport</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span> <span class="o">=</span> <span class="n">vport</span><span class="o">-&gt;</span><span class="n">phba</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span><span class="p">;</span>
	<span class="n">LPFC_MBOXQ_t</span> <span class="o">*</span><span class="n">mboxq</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">mboxq</span> <span class="o">=</span> <span class="n">mempool_alloc</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">mbox_mem_pool</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mboxq</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_DISCOVERY</span><span class="o">|</span><span class="n">LOG_MBOX</span><span class="p">,</span>
				<span class="s">&quot;2556 UNREG_VFI mbox allocation failed&quot;</span>
				<span class="s">&quot;HBA state x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">pport</span><span class="o">-&gt;</span><span class="n">port_state</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">lpfc_unreg_vfi</span><span class="p">(</span><span class="n">mboxq</span><span class="p">,</span> <span class="n">vport</span><span class="p">);</span>
	<span class="n">mboxq</span><span class="o">-&gt;</span><span class="n">vport</span> <span class="o">=</span> <span class="n">vport</span><span class="p">;</span>
	<span class="n">mboxq</span><span class="o">-&gt;</span><span class="n">mbox_cmpl</span> <span class="o">=</span> <span class="n">lpfc_unregister_vfi_cmpl</span><span class="p">;</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">lpfc_sli_issue_mbox</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">mboxq</span><span class="p">,</span> <span class="n">MBX_NOWAIT</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">==</span> <span class="n">MBX_NOT_FINISHED</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_DISCOVERY</span><span class="o">|</span><span class="n">LOG_MBOX</span><span class="p">,</span>
				<span class="s">&quot;2557 UNREG_VFI issue mbox failed rc x%x &quot;</span>
				<span class="s">&quot;HBA state x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">rc</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">pport</span><span class="o">-&gt;</span><span class="n">port_state</span><span class="p">);</span>
		<span class="n">mempool_free</span><span class="p">(</span><span class="n">mboxq</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">mbox_mem_pool</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">shost</span> <span class="o">=</span> <span class="n">lpfc_shost_from_vport</span><span class="p">(</span><span class="n">vport</span><span class="p">);</span>
	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>
	<span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_flag</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">FC_VFI_REGISTERED</span><span class="p">;</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_check_clean_addr_bit - Check whether assigned FCID is clean.</span>
<span class="cm"> * @vport: pointer to a host virtual N_Port data structure.</span>
<span class="cm"> * @sp: pointer to service parameter data structure.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine is called from FLOGI/FDISC completion handler functions.</span>
<span class="cm"> * lpfc_check_clean_addr_bit return 1 when FCID/Fabric portname/ Fabric</span>
<span class="cm"> * node nodename is changed in the completion service parameter else return</span>
<span class="cm"> * 0. This function also set flag in the vport data structure to delay</span>
<span class="cm"> * NP_Port discovery after the FLOGI/FDISC completion if Clean address bit</span>
<span class="cm"> * in FLOGI/FDISC response is cleared and FCID/Fabric portname/ Fabric</span>
<span class="cm"> * node nodename is changed in the completion service parameter.</span>
<span class="cm"> *</span>
<span class="cm"> * Return code</span>
<span class="cm"> *   0 - FCID and Fabric Nodename and Fabric portname is not changed.</span>
<span class="cm"> *   1 - FCID or Fabric Nodename or Fabric portname is changed.</span>
<span class="cm"> *</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">uint8_t</span>
<span class="nf">lpfc_check_clean_addr_bit</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="n">vport</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">serv_parm</span> <span class="o">*</span><span class="n">sp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">uint8_t</span> <span class="n">fabric_param_changed</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span> <span class="o">=</span> <span class="n">lpfc_shost_from_vport</span><span class="p">(</span><span class="n">vport</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_prevDID</span> <span class="o">!=</span> <span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_myDID</span><span class="p">)</span> <span class="o">||</span>
		<span class="n">memcmp</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">fabric_portname</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">portName</span><span class="p">,</span>
			<span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_name</span><span class="p">))</span> <span class="o">||</span>
		<span class="n">memcmp</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">fabric_nodename</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">nodeName</span><span class="p">,</span>
			<span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_name</span><span class="p">)))</span>
		<span class="n">fabric_param_changed</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Word 1 Bit 31 in common service parameter is overloaded.</span>
<span class="cm">	 * Word 1 Bit 31 in FLOGI request is multiple NPort request</span>
<span class="cm">	 * Word 1 Bit 31 in FLOGI response is clean address bit</span>
<span class="cm">	 *</span>
<span class="cm">	 * If fabric parameter is changed and clean address bit is</span>
<span class="cm">	 * cleared delay nport discovery if</span>
<span class="cm">	 * - vport-&gt;fc_prevDID != 0 (not initial discovery) OR</span>
<span class="cm">	 * - lpfc_delay_discovery module parameter is set.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">fabric_param_changed</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">cmn</span><span class="p">.</span><span class="n">clean_address_bit</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_prevDID</span> <span class="o">||</span> <span class="n">lpfc_delay_discovery</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">spin_lock_irq</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>
		<span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_flag</span> <span class="o">|=</span> <span class="n">FC_DISC_DELAYED</span><span class="p">;</span>
		<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">fabric_param_changed</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/**</span>
<span class="cm"> * lpfc_cmpl_els_flogi_fabric - Completion function for flogi to a fabric port</span>
<span class="cm"> * @vport: pointer to a host virtual N_Port data structure.</span>
<span class="cm"> * @ndlp: pointer to a node-list data structure.</span>
<span class="cm"> * @sp: pointer to service parameter data structure.</span>
<span class="cm"> * @irsp: pointer to the IOCB within the lpfc response IOCB.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine is invoked by the lpfc_cmpl_els_flogi() completion callback</span>
<span class="cm"> * function to handle the completion of a Fabric Login (FLOGI) into a fabric</span>
<span class="cm"> * port in a fabric topology. It properly sets up the parameters to the @ndlp</span>
<span class="cm"> * from the IOCB response. It also check the newly assigned N_Port ID to the</span>
<span class="cm"> * @vport against the previously assigned N_Port ID. If it is different from</span>
<span class="cm"> * the previously assigned Destination ID (DID), the lpfc_unreg_rpi() routine</span>
<span class="cm"> * is invoked on all the remaining nodes with the @vport to unregister the</span>
<span class="cm"> * Remote Port Indicators (RPIs). Finally, the lpfc_issue_fabric_reglogin()</span>
<span class="cm"> * is invoked to register login to the fabric.</span>
<span class="cm"> *</span>
<span class="cm"> * Return code</span>
<span class="cm"> *   0 - Success (currently, always return 0)</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">lpfc_cmpl_els_flogi_fabric</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="n">vport</span><span class="p">,</span> <span class="k">struct</span> <span class="n">lpfc_nodelist</span> <span class="o">*</span><span class="n">ndlp</span><span class="p">,</span>
			   <span class="k">struct</span> <span class="n">serv_parm</span> <span class="o">*</span><span class="n">sp</span><span class="p">,</span> <span class="n">IOCB_t</span> <span class="o">*</span><span class="n">irsp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span> <span class="o">=</span> <span class="n">lpfc_shost_from_vport</span><span class="p">(</span><span class="n">vport</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">lpfc_hba</span>  <span class="o">*</span><span class="n">phba</span> <span class="o">=</span> <span class="n">vport</span><span class="o">-&gt;</span><span class="n">phba</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_nodelist</span> <span class="o">*</span><span class="n">np</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_nodelist</span> <span class="o">*</span><span class="n">next_np</span><span class="p">;</span>
	<span class="kt">uint8_t</span> <span class="n">fabric_param_changed</span><span class="p">;</span>

	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>
	<span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_flag</span> <span class="o">|=</span> <span class="n">FC_FABRIC</span><span class="p">;</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>

	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">fc_edtov</span> <span class="o">=</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">cmn</span><span class="p">.</span><span class="n">e_d_tov</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">cmn</span><span class="p">.</span><span class="n">edtovResolution</span><span class="p">)</span>	<span class="cm">/* E_D_TOV ticks are in nanoseconds */</span>
		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">fc_edtov</span> <span class="o">=</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">fc_edtov</span> <span class="o">+</span> <span class="mi">999999</span><span class="p">)</span> <span class="o">/</span> <span class="mi">1000000</span><span class="p">;</span>

	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">fc_edtovResol</span> <span class="o">=</span> <span class="n">sp</span><span class="o">-&gt;</span><span class="n">cmn</span><span class="p">.</span><span class="n">edtovResolution</span><span class="p">;</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">fc_ratov</span> <span class="o">=</span> <span class="p">(</span><span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">cmn</span><span class="p">.</span><span class="n">w2</span><span class="p">.</span><span class="n">r_a_tov</span><span class="p">)</span> <span class="o">+</span> <span class="mi">999</span><span class="p">)</span> <span class="o">/</span> <span class="mi">1000</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">fc_topology</span> <span class="o">==</span> <span class="n">LPFC_TOPOLOGY_LOOP</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_lock_irq</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>
		<span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_flag</span> <span class="o">|=</span> <span class="n">FC_PUBLIC_LOOP</span><span class="p">;</span>
		<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_myDID</span> <span class="o">=</span> <span class="n">irsp</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">ulpWord</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">Mask_DID</span><span class="p">;</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_portname</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">portName</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_name</span><span class="p">));</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_nodename</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">nodeName</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_name</span><span class="p">));</span>
	<span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_class_sup</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">cls1</span><span class="p">.</span><span class="n">classValid</span><span class="p">)</span>
		<span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_class_sup</span> <span class="o">|=</span> <span class="n">FC_COS_CLASS1</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">cls2</span><span class="p">.</span><span class="n">classValid</span><span class="p">)</span>
		<span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_class_sup</span> <span class="o">|=</span> <span class="n">FC_COS_CLASS2</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">cls3</span><span class="p">.</span><span class="n">classValid</span><span class="p">)</span>
		<span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_class_sup</span> <span class="o">|=</span> <span class="n">FC_COS_CLASS3</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">cls4</span><span class="p">.</span><span class="n">classValid</span><span class="p">)</span>
		<span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_class_sup</span> <span class="o">|=</span> <span class="n">FC_COS_CLASS4</span><span class="p">;</span>
	<span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_maxframe</span> <span class="o">=</span> <span class="p">((</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">cmn</span><span class="p">.</span><span class="n">bbRcvSizeMsb</span> <span class="o">&amp;</span> <span class="mh">0x0F</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">|</span>
				<span class="n">sp</span><span class="o">-&gt;</span><span class="n">cmn</span><span class="p">.</span><span class="n">bbRcvSizeLsb</span><span class="p">;</span>

	<span class="n">fabric_param_changed</span> <span class="o">=</span> <span class="n">lpfc_check_clean_addr_bit</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">sp</span><span class="p">);</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">fabric_portname</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">portName</span><span class="p">,</span>
			<span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_name</span><span class="p">));</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">fabric_nodename</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">nodeName</span><span class="p">,</span>
			<span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_name</span><span class="p">));</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">fc_fabparam</span><span class="p">,</span> <span class="n">sp</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">serv_parm</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli3_options</span> <span class="o">&amp;</span> <span class="n">LPFC_SLI3_NPIV_ENABLED</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">cmn</span><span class="p">.</span><span class="n">response_multiple_NPort</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">lpfc_printf_vlog</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">KERN_WARNING</span><span class="p">,</span>
					 <span class="n">LOG_ELS</span> <span class="o">|</span> <span class="n">LOG_VPORT</span><span class="p">,</span>
					 <span class="s">&quot;1816 FLOGI NPIV supported, &quot;</span>
					 <span class="s">&quot;response data 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					 <span class="n">sp</span><span class="o">-&gt;</span><span class="n">cmn</span><span class="p">.</span><span class="n">response_multiple_NPort</span><span class="p">);</span>
			<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>
			<span class="n">phba</span><span class="o">-&gt;</span><span class="n">link_flag</span> <span class="o">|=</span> <span class="n">LS_NPIV_FAB_SUPPORTED</span><span class="p">;</span>
			<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/* Because we asked f/w for NPIV it still expects us</span>
<span class="cm">			to call reg_vnpid atleast for the physcial host */</span>
			<span class="n">lpfc_printf_vlog</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">KERN_WARNING</span><span class="p">,</span>
					 <span class="n">LOG_ELS</span> <span class="o">|</span> <span class="n">LOG_VPORT</span><span class="p">,</span>
					 <span class="s">&quot;1817 Fabric does not support NPIV &quot;</span>
					 <span class="s">&quot;- configuring single port mode.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>
			<span class="n">phba</span><span class="o">-&gt;</span><span class="n">link_flag</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">LS_NPIV_FAB_SUPPORTED</span><span class="p">;</span>
			<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">fabric_param_changed</span> <span class="o">&amp;&amp;</span>
		<span class="o">!</span><span class="p">(</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_flag</span> <span class="o">&amp;</span> <span class="n">FC_VPORT_NEEDS_REG_VPI</span><span class="p">))</span> <span class="p">{</span>

		<span class="cm">/* If our NportID changed, we need to ensure all</span>
<span class="cm">		 * remaining NPORTs get unreg_login&#39;ed.</span>
<span class="cm">		 */</span>
		<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">next_np</span><span class="p">,</span>
					<span class="o">&amp;</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_nodes</span><span class="p">,</span> <span class="n">nlp_listp</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">NLP_CHK_NODE_ACT</span><span class="p">(</span><span class="n">np</span><span class="p">))</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">nlp_state</span> <span class="o">!=</span> <span class="n">NLP_STE_NPR_NODE</span><span class="p">)</span> <span class="o">||</span>
				   <span class="o">!</span><span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">nlp_flag</span> <span class="o">&amp;</span> <span class="n">NLP_NPR_ADISC</span><span class="p">))</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="n">spin_lock_irq</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>
			<span class="n">np</span><span class="o">-&gt;</span><span class="n">nlp_flag</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">NLP_NPR_ADISC</span><span class="p">;</span>
			<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>
			<span class="n">lpfc_unreg_rpi</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">np</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">lpfc_cleanup_pending_mbox</span><span class="p">(</span><span class="n">vport</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli_rev</span> <span class="o">==</span> <span class="n">LPFC_SLI_REV4</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">lpfc_sli4_unreg_all_rpis</span><span class="p">(</span><span class="n">vport</span><span class="p">);</span>
			<span class="n">lpfc_mbx_unreg_vpi</span><span class="p">(</span><span class="n">vport</span><span class="p">);</span>
			<span class="n">spin_lock_irq</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>
			<span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_flag</span> <span class="o">|=</span> <span class="n">FC_VPORT_NEEDS_INIT_VPI</span><span class="p">;</span>
			<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 * For SLI3 and SLI4, the VPI needs to be reregistered in</span>
<span class="cm">		 * response to this fabric parameter change event.</span>
<span class="cm">		 */</span>
		<span class="n">spin_lock_irq</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>
		<span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_flag</span> <span class="o">|=</span> <span class="n">FC_VPORT_NEEDS_REG_VPI</span><span class="p">;</span>
		<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli_rev</span> <span class="o">==</span> <span class="n">LPFC_SLI_REV4</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		<span class="o">!</span><span class="p">(</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_flag</span> <span class="o">&amp;</span> <span class="n">FC_VPORT_NEEDS_REG_VPI</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * Driver needs to re-reg VPI in order for f/w</span>
<span class="cm">			 * to update the MAC address.</span>
<span class="cm">			 */</span>
			<span class="n">lpfc_nlp_set_state</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">ndlp</span><span class="p">,</span> <span class="n">NLP_STE_UNMAPPED_NODE</span><span class="p">);</span>
			<span class="n">lpfc_register_new_vport</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">vport</span><span class="p">,</span> <span class="n">ndlp</span><span class="p">);</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli_rev</span> <span class="o">&lt;</span> <span class="n">LPFC_SLI_REV4</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lpfc_nlp_set_state</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">ndlp</span><span class="p">,</span> <span class="n">NLP_STE_REG_LOGIN_ISSUE</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli3_options</span> <span class="o">&amp;</span> <span class="n">LPFC_SLI3_NPIV_ENABLED</span> <span class="o">&amp;&amp;</span>
		    <span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_flag</span> <span class="o">&amp;</span> <span class="n">FC_VPORT_NEEDS_REG_VPI</span><span class="p">)</span>
			<span class="n">lpfc_register_new_vport</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">vport</span><span class="p">,</span> <span class="n">ndlp</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">lpfc_issue_fabric_reglogin</span><span class="p">(</span><span class="n">vport</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_type</span> <span class="o">|=</span> <span class="n">NLP_FABRIC</span><span class="p">;</span>
		<span class="n">lpfc_nlp_set_state</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">ndlp</span><span class="p">,</span> <span class="n">NLP_STE_UNMAPPED_NODE</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">((</span><span class="o">!</span><span class="p">(</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_flag</span> <span class="o">&amp;</span> <span class="n">FC_VPORT_NEEDS_REG_VPI</span><span class="p">))</span> <span class="o">&amp;&amp;</span>
			<span class="p">(</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">vpi_state</span> <span class="o">&amp;</span> <span class="n">LPFC_VPI_REGISTERED</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">lpfc_start_fdiscs</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
			<span class="n">lpfc_do_scr_ns_plogi</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">vport</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_flag</span> <span class="o">&amp;</span> <span class="n">FC_VFI_REGISTERED</span><span class="p">)</span>
			<span class="n">lpfc_issue_init_vpi</span><span class="p">(</span><span class="n">vport</span><span class="p">);</span>
		<span class="k">else</span> <span class="p">{</span>
			<span class="n">lpfc_printf_vlog</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">KERN_INFO</span><span class="p">,</span> <span class="n">LOG_ELS</span><span class="p">,</span>
					<span class="s">&quot;3135 Need register VFI: (x%x/%x)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_prevDID</span><span class="p">,</span> <span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_myDID</span><span class="p">);</span>
			<span class="n">lpfc_issue_reg_vfi</span><span class="p">(</span><span class="n">vport</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_cmpl_els_flogi_nport - Completion function for flogi to an N_Port</span>
<span class="cm"> * @vport: pointer to a host virtual N_Port data structure.</span>
<span class="cm"> * @ndlp: pointer to a node-list data structure.</span>
<span class="cm"> * @sp: pointer to service parameter data structure.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine is invoked by the lpfc_cmpl_els_flogi() completion callback</span>
<span class="cm"> * function to handle the completion of a Fabric Login (FLOGI) into an N_Port</span>
<span class="cm"> * in a point-to-point topology. First, the @vport&#39;s N_Port Name is compared</span>
<span class="cm"> * with the received N_Port Name: if the @vport&#39;s N_Port Name is greater than</span>
<span class="cm"> * the received N_Port Name lexicographically, this node shall assign local</span>
<span class="cm"> * N_Port ID (PT2PT_LocalID: 1) and remote N_Port ID (PT2PT_RemoteID: 2) and</span>
<span class="cm"> * will send out Port Login (PLOGI) with the N_Port IDs assigned. Otherwise,</span>
<span class="cm"> * this node shall just wait for the remote node to issue PLOGI and assign</span>
<span class="cm"> * N_Port IDs.</span>
<span class="cm"> *</span>
<span class="cm"> * Return code</span>
<span class="cm"> *   0 - Success</span>
<span class="cm"> *   -ENXIO - Fail</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">lpfc_cmpl_els_flogi_nport</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="n">vport</span><span class="p">,</span> <span class="k">struct</span> <span class="n">lpfc_nodelist</span> <span class="o">*</span><span class="n">ndlp</span><span class="p">,</span>
			  <span class="k">struct</span> <span class="n">serv_parm</span> <span class="o">*</span><span class="n">sp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span> <span class="o">=</span> <span class="n">lpfc_shost_from_vport</span><span class="p">(</span><span class="n">vport</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">lpfc_hba</span>  <span class="o">*</span><span class="n">phba</span> <span class="o">=</span> <span class="n">vport</span><span class="o">-&gt;</span><span class="n">phba</span><span class="p">;</span>
	<span class="n">LPFC_MBOXQ_t</span> <span class="o">*</span><span class="n">mbox</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>
	<span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_flag</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">FC_FABRIC</span> <span class="o">|</span> <span class="n">FC_PUBLIC_LOOP</span><span class="p">);</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>

	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">fc_edtov</span> <span class="o">=</span> <span class="n">FF_DEF_EDTOV</span><span class="p">;</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">fc_ratov</span> <span class="o">=</span> <span class="n">FF_DEF_RATOV</span><span class="p">;</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">memcmp</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_portname</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">portName</span><span class="p">,</span>
		    <span class="k">sizeof</span><span class="p">(</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_portname</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* This side will initiate the PLOGI */</span>
		<span class="n">spin_lock_irq</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>
		<span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_flag</span> <span class="o">|=</span> <span class="n">FC_PT2PT_PLOGI</span><span class="p">;</span>
		<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * N_Port ID cannot be 0, set our to LocalID the other</span>
<span class="cm">		 * side will be RemoteID.</span>
<span class="cm">		 */</span>

		<span class="cm">/* not equal */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
			<span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_myDID</span> <span class="o">=</span> <span class="n">PT2PT_LocalID</span><span class="p">;</span>

		<span class="n">mbox</span> <span class="o">=</span> <span class="n">mempool_alloc</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">mbox_mem_pool</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mbox</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>

		<span class="n">lpfc_config_link</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">mbox</span><span class="p">);</span>

		<span class="n">mbox</span><span class="o">-&gt;</span><span class="n">mbox_cmpl</span> <span class="o">=</span> <span class="n">lpfc_sli_def_mbox_cmpl</span><span class="p">;</span>
		<span class="n">mbox</span><span class="o">-&gt;</span><span class="n">vport</span> <span class="o">=</span> <span class="n">vport</span><span class="p">;</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">lpfc_sli_issue_mbox</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">mbox</span><span class="p">,</span> <span class="n">MBX_NOWAIT</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">==</span> <span class="n">MBX_NOT_FINISHED</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">mempool_free</span><span class="p">(</span><span class="n">mbox</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">mbox_mem_pool</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 * For SLI4, the VFI/VPI are registered AFTER the</span>
<span class="cm">		 * Nport with the higher WWPN sends the PLOGI with</span>
<span class="cm">		 * an assigned NPortId.</span>
<span class="cm">		 */</span>

		<span class="cm">/* not equal */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli_rev</span> <span class="o">==</span> <span class="n">LPFC_SLI_REV4</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">rc</span><span class="p">)</span>
			<span class="n">lpfc_issue_reg_vfi</span><span class="p">(</span><span class="n">vport</span><span class="p">);</span>

		<span class="cm">/* Decrement ndlp reference count indicating that ndlp can be</span>
<span class="cm">		 * safely released when other references to it are done.</span>
<span class="cm">		 */</span>
		<span class="n">lpfc_nlp_put</span><span class="p">(</span><span class="n">ndlp</span><span class="p">);</span>

		<span class="n">ndlp</span> <span class="o">=</span> <span class="n">lpfc_findnode_did</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">PT2PT_RemoteID</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ndlp</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * Cannot find existing Fabric ndlp, so allocate a</span>
<span class="cm">			 * new one</span>
<span class="cm">			 */</span>
			<span class="n">ndlp</span> <span class="o">=</span> <span class="n">mempool_alloc</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">nlp_mem_pool</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ndlp</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
			<span class="n">lpfc_nlp_init</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">ndlp</span><span class="p">,</span> <span class="n">PT2PT_RemoteID</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">NLP_CHK_NODE_ACT</span><span class="p">(</span><span class="n">ndlp</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">ndlp</span> <span class="o">=</span> <span class="n">lpfc_enable_node</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">ndlp</span><span class="p">,</span>
						<span class="n">NLP_STE_UNUSED_NODE</span><span class="p">);</span>
			<span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">ndlp</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_portname</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">portName</span><span class="p">,</span>
		       <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_name</span><span class="p">));</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_nodename</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">nodeName</span><span class="p">,</span>
		       <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_name</span><span class="p">));</span>
		<span class="cm">/* Set state will put ndlp onto node list if not already done */</span>
		<span class="n">lpfc_nlp_set_state</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">ndlp</span><span class="p">,</span> <span class="n">NLP_STE_NPR_NODE</span><span class="p">);</span>
		<span class="n">spin_lock_irq</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>
		<span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_flag</span> <span class="o">|=</span> <span class="n">NLP_NPR_2B_DISC</span><span class="p">;</span>
		<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="cm">/* This side will wait for the PLOGI, decrement ndlp reference</span>
<span class="cm">		 * count indicating that ndlp can be released when other</span>
<span class="cm">		 * references to it are done.</span>
<span class="cm">		 */</span>
		<span class="n">lpfc_nlp_put</span><span class="p">(</span><span class="n">ndlp</span><span class="p">);</span>

	<span class="cm">/* If we are pt2pt with another NPort, force NPIV off! */</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli3_options</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">LPFC_SLI3_NPIV_ENABLED</span><span class="p">;</span>

	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>
	<span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_flag</span> <span class="o">|=</span> <span class="n">FC_PT2PT</span><span class="p">;</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>

	<span class="cm">/* Start discovery - this should just do CLEAR_LA */</span>
	<span class="n">lpfc_disc_start</span><span class="p">(</span><span class="n">vport</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">fail:</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">ENXIO</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_cmpl_els_flogi - Completion callback function for flogi</span>
<span class="cm"> * @phba: pointer to lpfc hba data structure.</span>
<span class="cm"> * @cmdiocb: pointer to lpfc command iocb data structure.</span>
<span class="cm"> * @rspiocb: pointer to lpfc response iocb data structure.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine is the top-level completion callback function for issuing</span>
<span class="cm"> * a Fabric Login (FLOGI) command. If the response IOCB reported error,</span>
<span class="cm"> * the lpfc_els_retry() routine shall be invoked to retry the FLOGI. If</span>
<span class="cm"> * retry has been made (either immediately or delayed with lpfc_els_retry()</span>
<span class="cm"> * returning 1), the command IOCB will be released and function returned.</span>
<span class="cm"> * If the retry attempt has been given up (possibly reach the maximum</span>
<span class="cm"> * number of retries), one additional decrement of ndlp reference shall be</span>
<span class="cm"> * invoked before going out after releasing the command IOCB. This will</span>
<span class="cm"> * actually release the remote node (Note, lpfc_els_free_iocb() will also</span>
<span class="cm"> * invoke one decrement of ndlp reference count). If no error reported in</span>
<span class="cm"> * the IOCB status, the command Port ID field is used to determine whether</span>
<span class="cm"> * this is a point-to-point topology or a fabric topology: if the Port ID</span>
<span class="cm"> * field is assigned, it is a fabric topology; otherwise, it is a</span>
<span class="cm"> * point-to-point topology. The routine lpfc_cmpl_els_flogi_fabric() or</span>
<span class="cm"> * lpfc_cmpl_els_flogi_nport() shall be invoked accordingly to handle the</span>
<span class="cm"> * specific topology completion conditions.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">lpfc_cmpl_els_flogi</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">,</span> <span class="k">struct</span> <span class="n">lpfc_iocbq</span> <span class="o">*</span><span class="n">cmdiocb</span><span class="p">,</span>
		    <span class="k">struct</span> <span class="n">lpfc_iocbq</span> <span class="o">*</span><span class="n">rspiocb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="n">vport</span> <span class="o">=</span> <span class="n">cmdiocb</span><span class="o">-&gt;</span><span class="n">vport</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span>  <span class="o">*</span><span class="n">shost</span> <span class="o">=</span> <span class="n">lpfc_shost_from_vport</span><span class="p">(</span><span class="n">vport</span><span class="p">);</span>
	<span class="n">IOCB_t</span> <span class="o">*</span><span class="n">irsp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">rspiocb</span><span class="o">-&gt;</span><span class="n">iocb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_nodelist</span> <span class="o">*</span><span class="n">ndlp</span> <span class="o">=</span> <span class="n">cmdiocb</span><span class="o">-&gt;</span><span class="n">context1</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_dmabuf</span> <span class="o">*</span><span class="n">pcmd</span> <span class="o">=</span> <span class="n">cmdiocb</span><span class="o">-&gt;</span><span class="n">context2</span><span class="p">,</span> <span class="o">*</span><span class="n">prsp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">serv_parm</span> <span class="o">*</span><span class="n">sp</span><span class="p">;</span>
	<span class="kt">uint16_t</span> <span class="n">fcf_index</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="cm">/* Check to see if link went down during discovery */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">lpfc_els_chk_latt</span><span class="p">(</span><span class="n">vport</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* One additional decrement on node reference count to</span>
<span class="cm">		 * trigger the release of the node</span>
<span class="cm">		 */</span>
		<span class="n">lpfc_nlp_put</span><span class="p">(</span><span class="n">ndlp</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">lpfc_debugfs_disc_trc</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">LPFC_DISC_TRC_ELS_CMD</span><span class="p">,</span>
		<span class="s">&quot;FLOGI cmpl:      status:x%x/x%x state:x%x&quot;</span><span class="p">,</span>
		<span class="n">irsp</span><span class="o">-&gt;</span><span class="n">ulpStatus</span><span class="p">,</span> <span class="n">irsp</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">ulpWord</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span>
		<span class="n">vport</span><span class="o">-&gt;</span><span class="n">port_state</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">irsp</span><span class="o">-&gt;</span><span class="n">ulpStatus</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * In case of FIP mode, perform roundrobin FCF failover</span>
<span class="cm">		 * due to new FCF discovery</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hba_flag</span> <span class="o">&amp;</span> <span class="n">HBA_FIP_SUPPORT</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">fcf</span><span class="p">.</span><span class="n">fcf_flag</span> <span class="o">&amp;</span> <span class="n">FCF_DISCOVERY</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">link_state</span> <span class="o">&lt;</span> <span class="n">LPFC_LINK_UP</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">stop_rr_fcf_flogi</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">fcoe_cvl_eventtag_attn</span> <span class="o">==</span>
			     <span class="n">phba</span><span class="o">-&gt;</span><span class="n">fcoe_cvl_eventtag</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			    <span class="p">(</span><span class="n">irsp</span><span class="o">-&gt;</span><span class="n">ulpStatus</span> <span class="o">==</span> <span class="n">IOSTAT_LOCAL_REJECT</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			    <span class="p">(</span><span class="n">irsp</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">ulpWord</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">==</span> <span class="n">IOERR_SLI_ABORTED</span><span class="p">))</span>
				<span class="k">goto</span> <span class="n">stop_rr_fcf_flogi</span><span class="p">;</span>
			<span class="k">else</span>
				<span class="n">phba</span><span class="o">-&gt;</span><span class="n">fcoe_cvl_eventtag_attn</span> <span class="o">=</span>
					<span class="n">phba</span><span class="o">-&gt;</span><span class="n">fcoe_cvl_eventtag</span><span class="p">;</span>
			<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_WARNING</span><span class="p">,</span> <span class="n">LOG_FIP</span> <span class="o">|</span> <span class="n">LOG_ELS</span><span class="p">,</span>
					<span class="s">&quot;2611 FLOGI failed on FCF (x%x), &quot;</span>
					<span class="s">&quot;status:x%x/x%x, tmo:x%x, perform &quot;</span>
					<span class="s">&quot;roundrobin FCF failover</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">phba</span><span class="o">-&gt;</span><span class="n">fcf</span><span class="p">.</span><span class="n">current_rec</span><span class="p">.</span><span class="n">fcf_indx</span><span class="p">,</span>
					<span class="n">irsp</span><span class="o">-&gt;</span><span class="n">ulpStatus</span><span class="p">,</span> <span class="n">irsp</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">ulpWord</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span>
					<span class="n">irsp</span><span class="o">-&gt;</span><span class="n">ulpTimeout</span><span class="p">);</span>
			<span class="n">lpfc_sli4_set_fcf_flogi_fail</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span>
					<span class="n">phba</span><span class="o">-&gt;</span><span class="n">fcf</span><span class="p">.</span><span class="n">current_rec</span><span class="p">.</span><span class="n">fcf_indx</span><span class="p">);</span>
			<span class="n">fcf_index</span> <span class="o">=</span> <span class="n">lpfc_sli4_fcf_rr_next_index_get</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
			<span class="n">rc</span> <span class="o">=</span> <span class="n">lpfc_sli4_fcf_rr_next_proc</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">fcf_index</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>

<span class="nl">stop_rr_fcf_flogi:</span>
		<span class="cm">/* FLOGI failure */</span>
		<span class="n">lpfc_printf_vlog</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_ELS</span><span class="p">,</span>
				<span class="s">&quot;2858 FLOGI failure Status:x%x/x%x TMO:x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">irsp</span><span class="o">-&gt;</span><span class="n">ulpStatus</span><span class="p">,</span> <span class="n">irsp</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">ulpWord</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span>
				<span class="n">irsp</span><span class="o">-&gt;</span><span class="n">ulpTimeout</span><span class="p">);</span>

		<span class="cm">/* Check for retry */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">lpfc_els_retry</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">cmdiocb</span><span class="p">,</span> <span class="n">rspiocb</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

		<span class="cm">/* FLOGI failure */</span>
		<span class="n">lpfc_printf_vlog</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_ELS</span><span class="p">,</span>
				 <span class="s">&quot;0100 FLOGI failure Status:x%x/x%x TMO:x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				 <span class="n">irsp</span><span class="o">-&gt;</span><span class="n">ulpStatus</span><span class="p">,</span> <span class="n">irsp</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">ulpWord</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span>
				 <span class="n">irsp</span><span class="o">-&gt;</span><span class="n">ulpTimeout</span><span class="p">);</span>

		<span class="cm">/* FLOGI failed, so there is no fabric */</span>
		<span class="n">spin_lock_irq</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>
		<span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_flag</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">FC_FABRIC</span> <span class="o">|</span> <span class="n">FC_PUBLIC_LOOP</span><span class="p">);</span>
		<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>

		<span class="cm">/* If private loop, then allow max outstanding els to be</span>
<span class="cm">		 * LPFC_MAX_DISC_THREADS (32). Scanning in the case of no</span>
<span class="cm">		 * alpa map would take too long otherwise.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">alpa_map</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">vport</span><span class="o">-&gt;</span><span class="n">cfg_discovery_threads</span> <span class="o">=</span> <span class="n">LPFC_MAX_DISC_THREADS</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli_rev</span> <span class="o">==</span> <span class="n">LPFC_SLI_REV4</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_flag</span> <span class="o">&amp;</span> <span class="n">FC_VFI_REGISTERED</span><span class="p">)</span> <span class="o">||</span>
		     <span class="p">(</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_prevDID</span> <span class="o">!=</span> <span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_myDID</span><span class="p">)))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_flag</span> <span class="o">&amp;</span> <span class="n">FC_VFI_REGISTERED</span><span class="p">)</span>
				<span class="n">lpfc_sli4_unreg_all_rpis</span><span class="p">(</span><span class="n">vport</span><span class="p">);</span>
			<span class="n">lpfc_issue_reg_vfi</span><span class="p">(</span><span class="n">vport</span><span class="p">);</span>
			<span class="n">lpfc_nlp_put</span><span class="p">(</span><span class="n">ndlp</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">goto</span> <span class="n">flogifail</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>
	<span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_flag</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">FC_VPORT_CVL_RCVD</span><span class="p">;</span>
	<span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_flag</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">FC_VPORT_LOGO_RCVD</span><span class="p">;</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * The FLogI succeeded.  Sync the data for the CPU before</span>
<span class="cm">	 * accessing it.</span>
<span class="cm">	 */</span>
	<span class="n">prsp</span> <span class="o">=</span> <span class="n">list_get_first</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pcmd</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="k">struct</span> <span class="n">lpfc_dmabuf</span><span class="p">,</span> <span class="n">list</span><span class="p">);</span>

	<span class="n">sp</span> <span class="o">=</span> <span class="n">prsp</span><span class="o">-&gt;</span><span class="n">virt</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">uint32_t</span><span class="p">);</span>

	<span class="cm">/* FLOGI completes successfully */</span>
	<span class="n">lpfc_printf_vlog</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">KERN_INFO</span><span class="p">,</span> <span class="n">LOG_ELS</span><span class="p">,</span>
			 <span class="s">&quot;0101 FLOGI completes successfully &quot;</span>
			 <span class="s">&quot;Data: x%x x%x x%x x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			 <span class="n">irsp</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">ulpWord</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span> <span class="n">sp</span><span class="o">-&gt;</span><span class="n">cmn</span><span class="p">.</span><span class="n">e_d_tov</span><span class="p">,</span>
			 <span class="n">sp</span><span class="o">-&gt;</span><span class="n">cmn</span><span class="p">.</span><span class="n">w2</span><span class="p">.</span><span class="n">r_a_tov</span><span class="p">,</span> <span class="n">sp</span><span class="o">-&gt;</span><span class="n">cmn</span><span class="p">.</span><span class="n">edtovResolution</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">port_state</span> <span class="o">==</span> <span class="n">LPFC_FLOGI</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * If Common Service Parameters indicate Nport</span>
<span class="cm">		 * we are point to point, if Fport we are Fabric.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">cmn</span><span class="p">.</span><span class="n">fPort</span><span class="p">)</span>
			<span class="n">rc</span> <span class="o">=</span> <span class="n">lpfc_cmpl_els_flogi_fabric</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">ndlp</span><span class="p">,</span> <span class="n">sp</span><span class="p">,</span> <span class="n">irsp</span><span class="p">);</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hba_flag</span> <span class="o">&amp;</span> <span class="n">HBA_FCOE_MODE</span><span class="p">))</span>
			<span class="n">rc</span> <span class="o">=</span> <span class="n">lpfc_cmpl_els_flogi_nport</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">ndlp</span><span class="p">,</span> <span class="n">sp</span><span class="p">);</span>
		<span class="k">else</span> <span class="p">{</span>
			<span class="n">lpfc_printf_vlog</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span>
				<span class="n">LOG_FIP</span> <span class="o">|</span> <span class="n">LOG_ELS</span><span class="p">,</span>
				<span class="s">&quot;2831 FLOGI response with cleared Fabric &quot;</span>
				<span class="s">&quot;bit fcf_index 0x%x &quot;</span>
				<span class="s">&quot;Switch Name %02x%02x%02x%02x%02x%02x%02x%02x &quot;</span>
				<span class="s">&quot;Fabric Name &quot;</span>
				<span class="s">&quot;%02x%02x%02x%02x%02x%02x%02x%02x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">phba</span><span class="o">-&gt;</span><span class="n">fcf</span><span class="p">.</span><span class="n">current_rec</span><span class="p">.</span><span class="n">fcf_indx</span><span class="p">,</span>
				<span class="n">phba</span><span class="o">-&gt;</span><span class="n">fcf</span><span class="p">.</span><span class="n">current_rec</span><span class="p">.</span><span class="n">switch_name</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
				<span class="n">phba</span><span class="o">-&gt;</span><span class="n">fcf</span><span class="p">.</span><span class="n">current_rec</span><span class="p">.</span><span class="n">switch_name</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
				<span class="n">phba</span><span class="o">-&gt;</span><span class="n">fcf</span><span class="p">.</span><span class="n">current_rec</span><span class="p">.</span><span class="n">switch_name</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span>
				<span class="n">phba</span><span class="o">-&gt;</span><span class="n">fcf</span><span class="p">.</span><span class="n">current_rec</span><span class="p">.</span><span class="n">switch_name</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span>
				<span class="n">phba</span><span class="o">-&gt;</span><span class="n">fcf</span><span class="p">.</span><span class="n">current_rec</span><span class="p">.</span><span class="n">switch_name</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span>
				<span class="n">phba</span><span class="o">-&gt;</span><span class="n">fcf</span><span class="p">.</span><span class="n">current_rec</span><span class="p">.</span><span class="n">switch_name</span><span class="p">[</span><span class="mi">5</span><span class="p">],</span>
				<span class="n">phba</span><span class="o">-&gt;</span><span class="n">fcf</span><span class="p">.</span><span class="n">current_rec</span><span class="p">.</span><span class="n">switch_name</span><span class="p">[</span><span class="mi">6</span><span class="p">],</span>
				<span class="n">phba</span><span class="o">-&gt;</span><span class="n">fcf</span><span class="p">.</span><span class="n">current_rec</span><span class="p">.</span><span class="n">switch_name</span><span class="p">[</span><span class="mi">7</span><span class="p">],</span>
				<span class="n">phba</span><span class="o">-&gt;</span><span class="n">fcf</span><span class="p">.</span><span class="n">current_rec</span><span class="p">.</span><span class="n">fabric_name</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
				<span class="n">phba</span><span class="o">-&gt;</span><span class="n">fcf</span><span class="p">.</span><span class="n">current_rec</span><span class="p">.</span><span class="n">fabric_name</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
				<span class="n">phba</span><span class="o">-&gt;</span><span class="n">fcf</span><span class="p">.</span><span class="n">current_rec</span><span class="p">.</span><span class="n">fabric_name</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span>
				<span class="n">phba</span><span class="o">-&gt;</span><span class="n">fcf</span><span class="p">.</span><span class="n">current_rec</span><span class="p">.</span><span class="n">fabric_name</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span>
				<span class="n">phba</span><span class="o">-&gt;</span><span class="n">fcf</span><span class="p">.</span><span class="n">current_rec</span><span class="p">.</span><span class="n">fabric_name</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span>
				<span class="n">phba</span><span class="o">-&gt;</span><span class="n">fcf</span><span class="p">.</span><span class="n">current_rec</span><span class="p">.</span><span class="n">fabric_name</span><span class="p">[</span><span class="mi">5</span><span class="p">],</span>
				<span class="n">phba</span><span class="o">-&gt;</span><span class="n">fcf</span><span class="p">.</span><span class="n">current_rec</span><span class="p">.</span><span class="n">fabric_name</span><span class="p">[</span><span class="mi">6</span><span class="p">],</span>
				<span class="n">phba</span><span class="o">-&gt;</span><span class="n">fcf</span><span class="p">.</span><span class="n">current_rec</span><span class="p">.</span><span class="n">fabric_name</span><span class="p">[</span><span class="mi">7</span><span class="p">]);</span>
			<span class="n">lpfc_nlp_put</span><span class="p">(</span><span class="n">ndlp</span><span class="p">);</span>
			<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>
			<span class="n">phba</span><span class="o">-&gt;</span><span class="n">fcf</span><span class="p">.</span><span class="n">fcf_flag</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">FCF_DISCOVERY</span><span class="p">;</span>
			<span class="n">phba</span><span class="o">-&gt;</span><span class="n">hba_flag</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">FCF_RR_INPROG</span> <span class="o">|</span> <span class="n">HBA_DEVLOSS_TMO</span><span class="p">);</span>
			<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Mark the FCF discovery process done */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hba_flag</span> <span class="o">&amp;</span> <span class="n">HBA_FIP_SUPPORT</span><span class="p">)</span>
				<span class="n">lpfc_printf_vlog</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">KERN_INFO</span><span class="p">,</span> <span class="n">LOG_FIP</span> <span class="o">|</span>
						<span class="n">LOG_ELS</span><span class="p">,</span>
						<span class="s">&quot;2769 FLOGI to FCF (x%x) &quot;</span>
						<span class="s">&quot;completed successfully</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
						<span class="n">phba</span><span class="o">-&gt;</span><span class="n">fcf</span><span class="p">.</span><span class="n">current_rec</span><span class="p">.</span><span class="n">fcf_indx</span><span class="p">);</span>
			<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>
			<span class="n">phba</span><span class="o">-&gt;</span><span class="n">fcf</span><span class="p">.</span><span class="n">fcf_flag</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">FCF_DISCOVERY</span><span class="p">;</span>
			<span class="n">phba</span><span class="o">-&gt;</span><span class="n">hba_flag</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">FCF_RR_INPROG</span> <span class="o">|</span> <span class="n">HBA_DEVLOSS_TMO</span><span class="p">);</span>
			<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

<span class="nl">flogifail:</span>
	<span class="n">lpfc_nlp_put</span><span class="p">(</span><span class="n">ndlp</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">lpfc_error_lost_link</span><span class="p">(</span><span class="n">irsp</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* FLOGI failed, so just use loop map to make discovery list */</span>
		<span class="n">lpfc_disc_list_loopmap</span><span class="p">(</span><span class="n">vport</span><span class="p">);</span>

		<span class="cm">/* Start discovery */</span>
		<span class="n">lpfc_disc_start</span><span class="p">(</span><span class="n">vport</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(((</span><span class="n">irsp</span><span class="o">-&gt;</span><span class="n">ulpStatus</span> <span class="o">!=</span> <span class="n">IOSTAT_LOCAL_REJECT</span><span class="p">)</span> <span class="o">||</span>
			<span class="p">((</span><span class="n">irsp</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">ulpWord</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">!=</span> <span class="n">IOERR_SLI_ABORTED</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			<span class="p">(</span><span class="n">irsp</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">ulpWord</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">!=</span> <span class="n">IOERR_SLI_DOWN</span><span class="p">)))</span> <span class="o">&amp;&amp;</span>
			<span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">link_state</span> <span class="o">!=</span> <span class="n">LPFC_CLEAR_LA</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* If FLOGI failed enable link interrupt. */</span>
		<span class="n">lpfc_issue_clear_la</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">vport</span><span class="p">);</span>
	<span class="p">}</span>
<span class="nl">out:</span>
	<span class="n">lpfc_els_free_iocb</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">cmdiocb</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_issue_els_flogi - Issue an flogi iocb command for a vport</span>
<span class="cm"> * @vport: pointer to a host virtual N_Port data structure.</span>
<span class="cm"> * @ndlp: pointer to a node-list data structure.</span>
<span class="cm"> * @retry: number of retries to the command IOCB.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine issues a Fabric Login (FLOGI) Request ELS command</span>
<span class="cm"> * for a @vport. The initiator service parameters are put into the payload</span>
<span class="cm"> * of the FLOGI Request IOCB and the top-level callback function pointer</span>
<span class="cm"> * to lpfc_cmpl_els_flogi() routine is put to the IOCB completion callback</span>
<span class="cm"> * function field. The lpfc_issue_fabric_iocb routine is invoked to send</span>
<span class="cm"> * out FLOGI ELS command with one outstanding fabric IOCB at a time.</span>
<span class="cm"> *</span>
<span class="cm"> * Note that, in lpfc_prep_els_iocb() routine, the reference count of ndlp</span>
<span class="cm"> * will be incremented by 1 for holding the ndlp and the reference to ndlp</span>
<span class="cm"> * will be stored into the context1 field of the IOCB for the completion</span>
<span class="cm"> * callback function to the FLOGI ELS command.</span>
<span class="cm"> *</span>
<span class="cm"> * Return code</span>
<span class="cm"> *   0 - successfully issued flogi iocb for @vport</span>
<span class="cm"> *   1 - failed to issue flogi iocb for @vport</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">lpfc_issue_els_flogi</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="n">vport</span><span class="p">,</span> <span class="k">struct</span> <span class="n">lpfc_nodelist</span> <span class="o">*</span><span class="n">ndlp</span><span class="p">,</span>
		     <span class="kt">uint8_t</span> <span class="n">retry</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpfc_hba</span>  <span class="o">*</span><span class="n">phba</span> <span class="o">=</span> <span class="n">vport</span><span class="o">-&gt;</span><span class="n">phba</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">serv_parm</span> <span class="o">*</span><span class="n">sp</span><span class="p">;</span>
	<span class="n">IOCB_t</span> <span class="o">*</span><span class="n">icmd</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_iocbq</span> <span class="o">*</span><span class="n">elsiocb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_sli_ring</span> <span class="o">*</span><span class="n">pring</span><span class="p">;</span>
	<span class="kt">uint8_t</span> <span class="o">*</span><span class="n">pcmd</span><span class="p">;</span>
	<span class="kt">uint16_t</span> <span class="n">cmdsize</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">tmo</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">pring</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli</span><span class="p">.</span><span class="n">ring</span><span class="p">[</span><span class="n">LPFC_ELS_RING</span><span class="p">];</span>

	<span class="n">cmdsize</span> <span class="o">=</span> <span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">uint32_t</span><span class="p">)</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">serv_parm</span><span class="p">));</span>
	<span class="n">elsiocb</span> <span class="o">=</span> <span class="n">lpfc_prep_els_iocb</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">cmdsize</span><span class="p">,</span> <span class="n">retry</span><span class="p">,</span> <span class="n">ndlp</span><span class="p">,</span>
				     <span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_DID</span><span class="p">,</span> <span class="n">ELS_CMD_FLOGI</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">elsiocb</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">icmd</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">elsiocb</span><span class="o">-&gt;</span><span class="n">iocb</span><span class="p">;</span>
	<span class="n">pcmd</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint8_t</span> <span class="o">*</span><span class="p">)</span> <span class="p">(((</span><span class="k">struct</span> <span class="n">lpfc_dmabuf</span> <span class="o">*</span><span class="p">)</span> <span class="n">elsiocb</span><span class="o">-&gt;</span><span class="n">context2</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">virt</span><span class="p">);</span>

	<span class="cm">/* For FLOGI request, remainder of payload is service parameters */</span>
	<span class="o">*</span><span class="p">((</span><span class="kt">uint32_t</span> <span class="o">*</span><span class="p">)</span> <span class="p">(</span><span class="n">pcmd</span><span class="p">))</span> <span class="o">=</span> <span class="n">ELS_CMD_FLOGI</span><span class="p">;</span>
	<span class="n">pcmd</span> <span class="o">+=</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">uint32_t</span><span class="p">);</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">pcmd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_sparam</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">serv_parm</span><span class="p">));</span>
	<span class="n">sp</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">serv_parm</span> <span class="o">*</span><span class="p">)</span> <span class="n">pcmd</span><span class="p">;</span>

	<span class="cm">/* Setup CSPs accordingly for Fabric */</span>
	<span class="n">sp</span><span class="o">-&gt;</span><span class="n">cmn</span><span class="p">.</span><span class="n">e_d_tov</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">sp</span><span class="o">-&gt;</span><span class="n">cmn</span><span class="p">.</span><span class="n">w2</span><span class="p">.</span><span class="n">r_a_tov</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">sp</span><span class="o">-&gt;</span><span class="n">cmn</span><span class="p">.</span><span class="n">virtual_fabric_support</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">sp</span><span class="o">-&gt;</span><span class="n">cls1</span><span class="p">.</span><span class="n">classValid</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">sp</span><span class="o">-&gt;</span><span class="n">cls2</span><span class="p">.</span><span class="n">seqDelivery</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">sp</span><span class="o">-&gt;</span><span class="n">cls3</span><span class="p">.</span><span class="n">seqDelivery</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">cmn</span><span class="p">.</span><span class="n">fcphLow</span> <span class="o">&lt;</span> <span class="n">FC_PH3</span><span class="p">)</span>
		<span class="n">sp</span><span class="o">-&gt;</span><span class="n">cmn</span><span class="p">.</span><span class="n">fcphLow</span> <span class="o">=</span> <span class="n">FC_PH3</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">cmn</span><span class="p">.</span><span class="n">fcphHigh</span> <span class="o">&lt;</span> <span class="n">FC_PH3</span><span class="p">)</span>
		<span class="n">sp</span><span class="o">-&gt;</span><span class="n">cmn</span><span class="p">.</span><span class="n">fcphHigh</span> <span class="o">=</span> <span class="n">FC_PH3</span><span class="p">;</span>

	<span class="k">if</span>  <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli_rev</span> <span class="o">==</span> <span class="n">LPFC_SLI_REV4</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_sli_intf_if_type</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">sli_intf</span><span class="p">)</span> <span class="o">==</span>
		    <span class="n">LPFC_SLI_INTF_IF_TYPE_0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">elsiocb</span><span class="o">-&gt;</span><span class="n">iocb</span><span class="p">.</span><span class="n">ulpCt_h</span> <span class="o">=</span> <span class="p">((</span><span class="n">SLI4_CT_FCFI</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">);</span>
			<span class="n">elsiocb</span><span class="o">-&gt;</span><span class="n">iocb</span><span class="p">.</span><span class="n">ulpCt_l</span> <span class="o">=</span> <span class="p">(</span><span class="n">SLI4_CT_FCFI</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">);</span>
			<span class="cm">/* FLOGI needs to be 3 for WQE FCFI */</span>
			<span class="cm">/* Set the fcfi to the fcfi we registered with */</span>
			<span class="n">elsiocb</span><span class="o">-&gt;</span><span class="n">iocb</span><span class="p">.</span><span class="n">ulpContext</span> <span class="o">=</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">fcf</span><span class="p">.</span><span class="n">fcfi</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli3_options</span> <span class="o">&amp;</span> <span class="n">LPFC_SLI3_NPIV_ENABLED</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">sp</span><span class="o">-&gt;</span><span class="n">cmn</span><span class="p">.</span><span class="n">request_multiple_Nport</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="cm">/* For FLOGI, Let FLOGI rsp set the NPortID for VPI 0 */</span>
			<span class="n">icmd</span><span class="o">-&gt;</span><span class="n">ulpCt_h</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">icmd</span><span class="o">-&gt;</span><span class="n">ulpCt_l</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="n">sp</span><span class="o">-&gt;</span><span class="n">cmn</span><span class="p">.</span><span class="n">request_multiple_Nport</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">fc_topology</span> <span class="o">!=</span> <span class="n">LPFC_TOPOLOGY_LOOP</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">icmd</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">elsreq64</span><span class="p">.</span><span class="n">myID</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">icmd</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">elsreq64</span><span class="p">.</span><span class="n">fl</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">tmo</span> <span class="o">=</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">fc_ratov</span><span class="p">;</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">fc_ratov</span> <span class="o">=</span> <span class="n">LPFC_DISC_FLOGI_TMO</span><span class="p">;</span>
	<span class="n">lpfc_set_disctmo</span><span class="p">(</span><span class="n">vport</span><span class="p">);</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">fc_ratov</span> <span class="o">=</span> <span class="n">tmo</span><span class="p">;</span>

	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">fc_stat</span><span class="p">.</span><span class="n">elsXmitFLOGI</span><span class="o">++</span><span class="p">;</span>
	<span class="n">elsiocb</span><span class="o">-&gt;</span><span class="n">iocb_cmpl</span> <span class="o">=</span> <span class="n">lpfc_cmpl_els_flogi</span><span class="p">;</span>

	<span class="n">lpfc_debugfs_disc_trc</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">LPFC_DISC_TRC_ELS_CMD</span><span class="p">,</span>
		<span class="s">&quot;Issue FLOGI:     opt:x%x&quot;</span><span class="p">,</span>
		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli3_options</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">lpfc_issue_fabric_iocb</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">elsiocb</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">==</span> <span class="n">IOCB_ERROR</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lpfc_els_free_iocb</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">elsiocb</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_els_abort_flogi - Abort all outstanding flogi iocbs</span>
<span class="cm"> * @phba: pointer to lpfc hba data structure.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine aborts all the outstanding Fabric Login (FLOGI) IOCBs</span>
<span class="cm"> * with a @phba. This routine walks all the outstanding IOCBs on the txcmplq</span>
<span class="cm"> * list and issues an abort IOCB commond on each outstanding IOCB that</span>
<span class="cm"> * contains a active Fabric_DID ndlp. Note that this function is to issue</span>
<span class="cm"> * the abort IOCB command on all the outstanding IOCBs, thus when this</span>
<span class="cm"> * function returns, it does not guarantee all the IOCBs are actually aborted.</span>
<span class="cm"> *</span>
<span class="cm"> * Return code</span>
<span class="cm"> *   0 - Successfully issued abort iocb on all outstanding flogis (Always 0)</span>
<span class="cm"> **/</span>
<span class="kt">int</span>
<span class="nf">lpfc_els_abort_flogi</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpfc_sli_ring</span> <span class="o">*</span><span class="n">pring</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_iocbq</span> <span class="o">*</span><span class="n">iocb</span><span class="p">,</span> <span class="o">*</span><span class="n">next_iocb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_nodelist</span> <span class="o">*</span><span class="n">ndlp</span><span class="p">;</span>
	<span class="n">IOCB_t</span> <span class="o">*</span><span class="n">icmd</span><span class="p">;</span>

	<span class="cm">/* Abort outstanding I/O on NPort &lt;nlp_DID&gt; */</span>
	<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_INFO</span><span class="p">,</span> <span class="n">LOG_DISCOVERY</span><span class="p">,</span>
			<span class="s">&quot;0201 Abort outstanding I/O on NPort x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">Fabric_DID</span><span class="p">);</span>

	<span class="n">pring</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli</span><span class="p">.</span><span class="n">ring</span><span class="p">[</span><span class="n">LPFC_ELS_RING</span><span class="p">];</span>

	<span class="cm">/*</span>
<span class="cm">	 * Check the txcmplq for an iocb that matches the nport the driver is</span>
<span class="cm">	 * searching for.</span>
<span class="cm">	 */</span>
	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>
	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">iocb</span><span class="p">,</span> <span class="n">next_iocb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pring</span><span class="o">-&gt;</span><span class="n">txcmplq</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">icmd</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">iocb</span><span class="o">-&gt;</span><span class="n">iocb</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">icmd</span><span class="o">-&gt;</span><span class="n">ulpCommand</span> <span class="o">==</span> <span class="n">CMD_ELS_REQUEST64_CR</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ndlp</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_nodelist</span> <span class="o">*</span><span class="p">)(</span><span class="n">iocb</span><span class="o">-&gt;</span><span class="n">context1</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ndlp</span> <span class="o">&amp;&amp;</span> <span class="n">NLP_CHK_NODE_ACT</span><span class="p">(</span><span class="n">ndlp</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			    <span class="p">(</span><span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_DID</span> <span class="o">==</span> <span class="n">Fabric_DID</span><span class="p">))</span>
				<span class="n">lpfc_sli_issue_abort_iotag</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">pring</span><span class="p">,</span> <span class="n">iocb</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_initial_flogi - Issue an initial fabric login for a vport</span>
<span class="cm"> * @vport: pointer to a host virtual N_Port data structure.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine issues an initial Fabric Login (FLOGI) for the @vport</span>
<span class="cm"> * specified. It first searches the ndlp with the Fabric_DID (0xfffffe) from</span>
<span class="cm"> * the @vport&#39;s ndlp list. If no such ndlp found, it will create an ndlp and</span>
<span class="cm"> * put it into the @vport&#39;s ndlp list. If an inactive ndlp found on the list,</span>
<span class="cm"> * it will just be enabled and made active. The lpfc_issue_els_flogi() routine</span>
<span class="cm"> * is then invoked with the @vport and the ndlp to perform the FLOGI for the</span>
<span class="cm"> * @vport.</span>
<span class="cm"> *</span>
<span class="cm"> * Return code</span>
<span class="cm"> *   0 - failed to issue initial flogi for @vport</span>
<span class="cm"> *   1 - successfully issued initial flogi for @vport</span>
<span class="cm"> **/</span>
<span class="kt">int</span>
<span class="nf">lpfc_initial_flogi</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="n">vport</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span> <span class="o">=</span> <span class="n">vport</span><span class="o">-&gt;</span><span class="n">phba</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_nodelist</span> <span class="o">*</span><span class="n">ndlp</span><span class="p">;</span>

	<span class="n">vport</span><span class="o">-&gt;</span><span class="n">port_state</span> <span class="o">=</span> <span class="n">LPFC_FLOGI</span><span class="p">;</span>
	<span class="n">lpfc_set_disctmo</span><span class="p">(</span><span class="n">vport</span><span class="p">);</span>

	<span class="cm">/* First look for the Fabric ndlp */</span>
	<span class="n">ndlp</span> <span class="o">=</span> <span class="n">lpfc_findnode_did</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">Fabric_DID</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ndlp</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Cannot find existing Fabric ndlp, so allocate a new one */</span>
		<span class="n">ndlp</span> <span class="o">=</span> <span class="n">mempool_alloc</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">nlp_mem_pool</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ndlp</span><span class="p">)</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">lpfc_nlp_init</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">ndlp</span><span class="p">,</span> <span class="n">Fabric_DID</span><span class="p">);</span>
		<span class="cm">/* Set the node type */</span>
		<span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_type</span> <span class="o">|=</span> <span class="n">NLP_FABRIC</span><span class="p">;</span>
		<span class="cm">/* Put ndlp onto node list */</span>
		<span class="n">lpfc_enqueue_node</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">ndlp</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">NLP_CHK_NODE_ACT</span><span class="p">(</span><span class="n">ndlp</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* re-setup ndlp without removing from node list */</span>
		<span class="n">ndlp</span> <span class="o">=</span> <span class="n">lpfc_enable_node</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">ndlp</span><span class="p">,</span> <span class="n">NLP_STE_UNUSED_NODE</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ndlp</span><span class="p">)</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">lpfc_issue_els_flogi</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">ndlp</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* This decrement of reference count to node shall kick off</span>
<span class="cm">		 * the release of the node.</span>
<span class="cm">		 */</span>
		<span class="n">lpfc_nlp_put</span><span class="p">(</span><span class="n">ndlp</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_initial_fdisc - Issue an initial fabric discovery for a vport</span>
<span class="cm"> * @vport: pointer to a host virtual N_Port data structure.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine issues an initial Fabric Discover (FDISC) for the @vport</span>
<span class="cm"> * specified. It first searches the ndlp with the Fabric_DID (0xfffffe) from</span>
<span class="cm"> * the @vport&#39;s ndlp list. If no such ndlp found, it will create an ndlp and</span>
<span class="cm"> * put it into the @vport&#39;s ndlp list. If an inactive ndlp found on the list,</span>
<span class="cm"> * it will just be enabled and made active. The lpfc_issue_els_fdisc() routine</span>
<span class="cm"> * is then invoked with the @vport and the ndlp to perform the FDISC for the</span>
<span class="cm"> * @vport.</span>
<span class="cm"> *</span>
<span class="cm"> * Return code</span>
<span class="cm"> *   0 - failed to issue initial fdisc for @vport</span>
<span class="cm"> *   1 - successfully issued initial fdisc for @vport</span>
<span class="cm"> **/</span>
<span class="kt">int</span>
<span class="nf">lpfc_initial_fdisc</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="n">vport</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span> <span class="o">=</span> <span class="n">vport</span><span class="o">-&gt;</span><span class="n">phba</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_nodelist</span> <span class="o">*</span><span class="n">ndlp</span><span class="p">;</span>

	<span class="cm">/* First look for the Fabric ndlp */</span>
	<span class="n">ndlp</span> <span class="o">=</span> <span class="n">lpfc_findnode_did</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">Fabric_DID</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ndlp</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Cannot find existing Fabric ndlp, so allocate a new one */</span>
		<span class="n">ndlp</span> <span class="o">=</span> <span class="n">mempool_alloc</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">nlp_mem_pool</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ndlp</span><span class="p">)</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">lpfc_nlp_init</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">ndlp</span><span class="p">,</span> <span class="n">Fabric_DID</span><span class="p">);</span>
		<span class="cm">/* Put ndlp onto node list */</span>
		<span class="n">lpfc_enqueue_node</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">ndlp</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">NLP_CHK_NODE_ACT</span><span class="p">(</span><span class="n">ndlp</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* re-setup ndlp without removing from node list */</span>
		<span class="n">ndlp</span> <span class="o">=</span> <span class="n">lpfc_enable_node</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">ndlp</span><span class="p">,</span> <span class="n">NLP_STE_UNUSED_NODE</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ndlp</span><span class="p">)</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">lpfc_issue_els_fdisc</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">ndlp</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* decrement node reference count to trigger the release of</span>
<span class="cm">		 * the node.</span>
<span class="cm">		 */</span>
		<span class="n">lpfc_nlp_put</span><span class="p">(</span><span class="n">ndlp</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_more_plogi - Check and issue remaining plogis for a vport</span>
<span class="cm"> * @vport: pointer to a host virtual N_Port data structure.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine checks whether there are more remaining Port Logins</span>
<span class="cm"> * (PLOGI) to be issued for the @vport. If so, it will invoke the routine</span>
<span class="cm"> * lpfc_els_disc_plogi() to go through the Node Port Recovery (NPR) nodes</span>
<span class="cm"> * to issue ELS PLOGIs up to the configured discover threads with the</span>
<span class="cm"> * @vport (@vport-&gt;cfg_discovery_threads). The function also decrement</span>
<span class="cm"> * the @vport&#39;s num_disc_node by 1 if it is not already 0.</span>
<span class="cm"> **/</span>
<span class="kt">void</span>
<span class="nf">lpfc_more_plogi</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="n">vport</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">sentplogi</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">num_disc_nodes</span><span class="p">)</span>
		<span class="n">vport</span><span class="o">-&gt;</span><span class="n">num_disc_nodes</span><span class="o">--</span><span class="p">;</span>

	<span class="cm">/* Continue discovery with &lt;num_disc_nodes&gt; PLOGIs to go */</span>
	<span class="n">lpfc_printf_vlog</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">KERN_INFO</span><span class="p">,</span> <span class="n">LOG_DISCOVERY</span><span class="p">,</span>
			 <span class="s">&quot;0232 Continue discovery with %d PLOGIs to go &quot;</span>
			 <span class="s">&quot;Data: x%x x%x x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			 <span class="n">vport</span><span class="o">-&gt;</span><span class="n">num_disc_nodes</span><span class="p">,</span> <span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_plogi_cnt</span><span class="p">,</span>
			 <span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_flag</span><span class="p">,</span> <span class="n">vport</span><span class="o">-&gt;</span><span class="n">port_state</span><span class="p">);</span>
	<span class="cm">/* Check to see if there are more PLOGIs to be sent */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_flag</span> <span class="o">&amp;</span> <span class="n">FC_NLP_MORE</span><span class="p">)</span>
		<span class="cm">/* go thru NPR nodes and issue any remaining ELS PLOGIs */</span>
		<span class="n">sentplogi</span> <span class="o">=</span> <span class="n">lpfc_els_disc_plogi</span><span class="p">(</span><span class="n">vport</span><span class="p">);</span>

	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_plogi_confirm_nport - Confirm pologi wwpn matches stored ndlp</span>
<span class="cm"> * @phba: pointer to lpfc hba data structure.</span>
<span class="cm"> * @prsp: pointer to response IOCB payload.</span>
<span class="cm"> * @ndlp: pointer to a node-list data structure.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine checks and indicates whether the WWPN of an N_Port, retrieved</span>
<span class="cm"> * from a PLOGI, matches the WWPN that is stored in the @ndlp for that N_POrt.</span>
<span class="cm"> * The following cases are considered N_Port confirmed:</span>
<span class="cm"> * 1) The N_Port is a Fabric ndlp; 2) The @ndlp is on vport list and matches</span>
<span class="cm"> * the WWPN of the N_Port logged into; 3) The @ndlp is not on vport list but</span>
<span class="cm"> * it does not have WWPN assigned either. If the WWPN is confirmed, the</span>
<span class="cm"> * pointer to the @ndlp will be returned. If the WWPN is not confirmed:</span>
<span class="cm"> * 1) if there is a node on vport list other than the @ndlp with the same</span>
<span class="cm"> * WWPN of the N_Port PLOGI logged into, the lpfc_unreg_rpi() will be invoked</span>
<span class="cm"> * on that node to release the RPI associated with the node; 2) if there is</span>
<span class="cm"> * no node found on vport list with the same WWPN of the N_Port PLOGI logged</span>
<span class="cm"> * into, a new node shall be allocated (or activated). In either case, the</span>
<span class="cm"> * parameters of the @ndlp shall be copied to the new_ndlp, the @ndlp shall</span>
<span class="cm"> * be released and the new_ndlp shall be put on to the vport node list and</span>
<span class="cm"> * its pointer returned as the confirmed node.</span>
<span class="cm"> *</span>
<span class="cm"> * Note that before the @ndlp got &quot;released&quot;, the keepDID from not-matching</span>
<span class="cm"> * or inactive &quot;new_ndlp&quot; on the vport node list is assigned to the nlp_DID</span>
<span class="cm"> * of the @ndlp. This is because the release of @ndlp is actually to put it</span>
<span class="cm"> * into an inactive state on the vport node list and the vport node list</span>
<span class="cm"> * management algorithm does not allow two node with a same DID.</span>
<span class="cm"> *</span>
<span class="cm"> * Return code</span>
<span class="cm"> *   pointer to the PLOGI N_Port @ndlp</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">lpfc_nodelist</span> <span class="o">*</span>
<span class="nf">lpfc_plogi_confirm_nport</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="o">*</span><span class="n">prsp</span><span class="p">,</span>
			 <span class="k">struct</span> <span class="n">lpfc_nodelist</span> <span class="o">*</span><span class="n">ndlp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpfc_vport</span>    <span class="o">*</span><span class="n">vport</span> <span class="o">=</span> <span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">vport</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_nodelist</span> <span class="o">*</span><span class="n">new_ndlp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_rport_data</span> <span class="o">*</span><span class="n">rdata</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fc_rport</span> <span class="o">*</span><span class="n">rport</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">serv_parm</span> <span class="o">*</span><span class="n">sp</span><span class="p">;</span>
	<span class="kt">uint8_t</span>  <span class="n">name</span><span class="p">[</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_name</span><span class="p">)];</span>
	<span class="kt">uint32_t</span> <span class="n">rc</span><span class="p">,</span> <span class="n">keepDID</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span>  <span class="n">put_node</span><span class="p">;</span>
	<span class="kt">int</span>  <span class="n">put_rport</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_node_rrqs</span> <span class="n">rrq</span><span class="p">;</span>

	<span class="cm">/* Fabric nodes can have the same WWPN so we don&#39;t bother searching</span>
<span class="cm">	 * by WWPN.  Just return the ndlp that was given to us.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_type</span> <span class="o">&amp;</span> <span class="n">NLP_FABRIC</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ndlp</span><span class="p">;</span>

	<span class="n">sp</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">serv_parm</span> <span class="o">*</span><span class="p">)</span> <span class="p">((</span><span class="kt">uint8_t</span> <span class="o">*</span><span class="p">)</span> <span class="n">prsp</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">uint32_t</span><span class="p">));</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_name</span><span class="p">));</span>

	<span class="cm">/* Now we find out if the NPort we are logging into, matches the WWPN</span>
<span class="cm">	 * we have for that ndlp. If not, we have some work to do.</span>
<span class="cm">	 */</span>
	<span class="n">new_ndlp</span> <span class="o">=</span> <span class="n">lpfc_findnode_wwpn</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">portName</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">new_ndlp</span> <span class="o">==</span> <span class="n">ndlp</span> <span class="o">&amp;&amp;</span> <span class="n">NLP_CHK_NODE_ACT</span><span class="p">(</span><span class="n">new_ndlp</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">ndlp</span><span class="p">;</span>
	<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rrq</span><span class="p">.</span><span class="n">xri_bitmap</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">new_ndlp</span><span class="o">-&gt;</span><span class="n">active_rrqs</span><span class="p">.</span><span class="n">xri_bitmap</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">new_ndlp</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">memcmp</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_portname</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span>
			    <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_name</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rc</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">ndlp</span><span class="p">;</span>
		<span class="n">new_ndlp</span> <span class="o">=</span> <span class="n">mempool_alloc</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">nlp_mem_pool</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">new_ndlp</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">ndlp</span><span class="p">;</span>
		<span class="n">lpfc_nlp_init</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">new_ndlp</span><span class="p">,</span> <span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_DID</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">NLP_CHK_NODE_ACT</span><span class="p">(</span><span class="n">new_ndlp</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">memcmp</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_portname</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span>
			    <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_name</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rc</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">ndlp</span><span class="p">;</span>
		<span class="n">new_ndlp</span> <span class="o">=</span> <span class="n">lpfc_enable_node</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">new_ndlp</span><span class="p">,</span>
						<span class="n">NLP_STE_UNUSED_NODE</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">new_ndlp</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">ndlp</span><span class="p">;</span>
		<span class="n">keepDID</span> <span class="o">=</span> <span class="n">new_ndlp</span><span class="o">-&gt;</span><span class="n">nlp_DID</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli_rev</span> <span class="o">==</span> <span class="n">LPFC_SLI_REV4</span><span class="p">)</span>
			<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rrq</span><span class="p">.</span><span class="n">xri_bitmap</span><span class="p">,</span>
				<span class="o">&amp;</span><span class="n">new_ndlp</span><span class="o">-&gt;</span><span class="n">active_rrqs</span><span class="p">.</span><span class="n">xri_bitmap</span><span class="p">,</span>
				<span class="k">sizeof</span><span class="p">(</span><span class="n">new_ndlp</span><span class="o">-&gt;</span><span class="n">active_rrqs</span><span class="p">.</span><span class="n">xri_bitmap</span><span class="p">));</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">keepDID</span> <span class="o">=</span> <span class="n">new_ndlp</span><span class="o">-&gt;</span><span class="n">nlp_DID</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli_rev</span> <span class="o">==</span> <span class="n">LPFC_SLI_REV4</span><span class="p">)</span>
			<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rrq</span><span class="p">.</span><span class="n">xri_bitmap</span><span class="p">,</span>
				<span class="o">&amp;</span><span class="n">new_ndlp</span><span class="o">-&gt;</span><span class="n">active_rrqs</span><span class="p">.</span><span class="n">xri_bitmap</span><span class="p">,</span>
				<span class="k">sizeof</span><span class="p">(</span><span class="n">new_ndlp</span><span class="o">-&gt;</span><span class="n">active_rrqs</span><span class="p">.</span><span class="n">xri_bitmap</span><span class="p">));</span>
	<span class="p">}</span>

	<span class="n">lpfc_unreg_rpi</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">new_ndlp</span><span class="p">);</span>
	<span class="n">new_ndlp</span><span class="o">-&gt;</span><span class="n">nlp_DID</span> <span class="o">=</span> <span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_DID</span><span class="p">;</span>
	<span class="n">new_ndlp</span><span class="o">-&gt;</span><span class="n">nlp_prev_state</span> <span class="o">=</span> <span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_prev_state</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli_rev</span> <span class="o">==</span> <span class="n">LPFC_SLI_REV4</span><span class="p">)</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">new_ndlp</span><span class="o">-&gt;</span><span class="n">active_rrqs</span><span class="p">.</span><span class="n">xri_bitmap</span><span class="p">,</span>
			<span class="o">&amp;</span><span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">active_rrqs</span><span class="p">.</span><span class="n">xri_bitmap</span><span class="p">,</span>
			<span class="k">sizeof</span><span class="p">(</span><span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">active_rrqs</span><span class="p">.</span><span class="n">xri_bitmap</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_flag</span> <span class="o">&amp;</span> <span class="n">NLP_NPR_2B_DISC</span><span class="p">)</span>
		<span class="n">new_ndlp</span><span class="o">-&gt;</span><span class="n">nlp_flag</span> <span class="o">|=</span> <span class="n">NLP_NPR_2B_DISC</span><span class="p">;</span>
	<span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_flag</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">NLP_NPR_2B_DISC</span><span class="p">;</span>

	<span class="cm">/* Set state will put new_ndlp on to node list if not already done */</span>
	<span class="n">lpfc_nlp_set_state</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">new_ndlp</span><span class="p">,</span> <span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_state</span><span class="p">);</span>

	<span class="cm">/* Move this back to NPR state */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">memcmp</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_portname</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_name</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* The new_ndlp is replacing ndlp totally, so we need</span>
<span class="cm">		 * to put ndlp on UNUSED list and try to free it.</span>
<span class="cm">		 */</span>

		<span class="cm">/* Fix up the rport accordingly */</span>
		<span class="n">rport</span> <span class="o">=</span>  <span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">rport</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rport</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">rdata</span> <span class="o">=</span> <span class="n">rport</span><span class="o">-&gt;</span><span class="n">dd_data</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">rdata</span><span class="o">-&gt;</span><span class="n">pnode</span> <span class="o">==</span> <span class="n">ndlp</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">lpfc_nlp_put</span><span class="p">(</span><span class="n">ndlp</span><span class="p">);</span>
				<span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">rport</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
				<span class="n">rdata</span><span class="o">-&gt;</span><span class="n">pnode</span> <span class="o">=</span> <span class="n">lpfc_nlp_get</span><span class="p">(</span><span class="n">new_ndlp</span><span class="p">);</span>
				<span class="n">new_ndlp</span><span class="o">-&gt;</span><span class="n">rport</span> <span class="o">=</span> <span class="n">rport</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">new_ndlp</span><span class="o">-&gt;</span><span class="n">nlp_type</span> <span class="o">=</span> <span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_type</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/* We shall actually free the ndlp with both nlp_DID and</span>
<span class="cm">		 * nlp_portname fields equals 0 to avoid any ndlp on the</span>
<span class="cm">		 * nodelist never to be used.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_DID</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">ndlp_lock</span><span class="p">);</span>
			<span class="n">NLP_SET_FREE_REQ</span><span class="p">(</span><span class="n">ndlp</span><span class="p">);</span>
			<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">ndlp_lock</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="cm">/* Two ndlps cannot have the same did on the nodelist */</span>
		<span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_DID</span> <span class="o">=</span> <span class="n">keepDID</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli_rev</span> <span class="o">==</span> <span class="n">LPFC_SLI_REV4</span><span class="p">)</span>
			<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">active_rrqs</span><span class="p">.</span><span class="n">xri_bitmap</span><span class="p">,</span>
				<span class="o">&amp;</span><span class="n">rrq</span><span class="p">.</span><span class="n">xri_bitmap</span><span class="p">,</span>
				<span class="k">sizeof</span><span class="p">(</span><span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">active_rrqs</span><span class="p">.</span><span class="n">xri_bitmap</span><span class="p">));</span>
		<span class="n">lpfc_drop_node</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">ndlp</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="n">lpfc_unreg_rpi</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">ndlp</span><span class="p">);</span>
		<span class="cm">/* Two ndlps cannot have the same did */</span>
		<span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_DID</span> <span class="o">=</span> <span class="n">keepDID</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli_rev</span> <span class="o">==</span> <span class="n">LPFC_SLI_REV4</span><span class="p">)</span>
			<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">active_rrqs</span><span class="p">.</span><span class="n">xri_bitmap</span><span class="p">,</span>
				<span class="o">&amp;</span><span class="n">rrq</span><span class="p">.</span><span class="n">xri_bitmap</span><span class="p">,</span>
				<span class="k">sizeof</span><span class="p">(</span><span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">active_rrqs</span><span class="p">.</span><span class="n">xri_bitmap</span><span class="p">));</span>
		<span class="cm">/* Since we are swapping the ndlp passed in with the new one</span>
<span class="cm">		 * and the did has already been swapped, copy over the</span>
<span class="cm">		 * state and names.</span>
<span class="cm">		 */</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">new_ndlp</span><span class="o">-&gt;</span><span class="n">nlp_portname</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_portname</span><span class="p">,</span>
			<span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_name</span><span class="p">));</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">new_ndlp</span><span class="o">-&gt;</span><span class="n">nlp_nodename</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_nodename</span><span class="p">,</span>
			<span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_name</span><span class="p">));</span>
		<span class="n">new_ndlp</span><span class="o">-&gt;</span><span class="n">nlp_state</span> <span class="o">=</span> <span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_state</span><span class="p">;</span>
		<span class="n">lpfc_nlp_set_state</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">ndlp</span><span class="p">,</span> <span class="n">NLP_STE_NPR_NODE</span><span class="p">);</span>
		<span class="cm">/* Fix up the rport accordingly */</span>
		<span class="n">rport</span> <span class="o">=</span> <span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">rport</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rport</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">rdata</span> <span class="o">=</span> <span class="n">rport</span><span class="o">-&gt;</span><span class="n">dd_data</span><span class="p">;</span>
			<span class="n">put_node</span> <span class="o">=</span> <span class="n">rdata</span><span class="o">-&gt;</span><span class="n">pnode</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="n">put_rport</span> <span class="o">=</span> <span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">rport</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="n">rdata</span><span class="o">-&gt;</span><span class="n">pnode</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">rport</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">put_node</span><span class="p">)</span>
				<span class="n">lpfc_nlp_put</span><span class="p">(</span><span class="n">ndlp</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">put_rport</span><span class="p">)</span>
				<span class="n">put_device</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rport</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">new_ndlp</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_end_rscn - Check and handle more rscn for a vport</span>
<span class="cm"> * @vport: pointer to a host virtual N_Port data structure.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine checks whether more Registration State Change</span>
<span class="cm"> * Notifications (RSCNs) came in while the discovery state machine was in</span>
<span class="cm"> * the FC_RSCN_MODE. If so, the lpfc_els_handle_rscn() routine will be</span>
<span class="cm"> * invoked to handle the additional RSCNs for the @vport. Otherwise, the</span>
<span class="cm"> * FC_RSCN_MODE bit will be cleared with the @vport to mark as the end of</span>
<span class="cm"> * handling the RSCNs.</span>
<span class="cm"> **/</span>
<span class="kt">void</span>
<span class="nf">lpfc_end_rscn</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="n">vport</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span> <span class="o">=</span> <span class="n">lpfc_shost_from_vport</span><span class="p">(</span><span class="n">vport</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_flag</span> <span class="o">&amp;</span> <span class="n">FC_RSCN_MODE</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Check to see if more RSCNs came in while we were</span>
<span class="cm">		 * processing this one.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_rscn_id_cnt</span> <span class="o">||</span>
		    <span class="p">(</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_flag</span> <span class="o">&amp;</span> <span class="n">FC_RSCN_DISCOVERY</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">lpfc_els_handle_rscn</span><span class="p">(</span><span class="n">vport</span><span class="p">);</span>
		<span class="k">else</span> <span class="p">{</span>
			<span class="n">spin_lock_irq</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>
			<span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_flag</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">FC_RSCN_MODE</span><span class="p">;</span>
			<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_cmpl_els_rrq - Completion handled for els RRQs.</span>
<span class="cm"> * @phba: pointer to lpfc hba data structure.</span>
<span class="cm"> * @cmdiocb: pointer to lpfc command iocb data structure.</span>
<span class="cm"> * @rspiocb: pointer to lpfc response iocb data structure.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine will call the clear rrq function to free the rrq and</span>
<span class="cm"> * clear the xri&#39;s bit in the ndlp&#39;s xri_bitmap. If the ndlp does not</span>
<span class="cm"> * exist then the clear_rrq is still called because the rrq needs to</span>
<span class="cm"> * be freed.</span>
<span class="cm"> **/</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">lpfc_cmpl_els_rrq</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">,</span> <span class="k">struct</span> <span class="n">lpfc_iocbq</span> <span class="o">*</span><span class="n">cmdiocb</span><span class="p">,</span>
		    <span class="k">struct</span> <span class="n">lpfc_iocbq</span> <span class="o">*</span><span class="n">rspiocb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="n">vport</span> <span class="o">=</span> <span class="n">cmdiocb</span><span class="o">-&gt;</span><span class="n">vport</span><span class="p">;</span>
	<span class="n">IOCB_t</span> <span class="o">*</span><span class="n">irsp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_nodelist</span> <span class="o">*</span><span class="n">ndlp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_node_rrq</span> <span class="o">*</span><span class="n">rrq</span><span class="p">;</span>

	<span class="cm">/* we pass cmdiocb to state machine which needs rspiocb as well */</span>
	<span class="n">rrq</span> <span class="o">=</span> <span class="n">cmdiocb</span><span class="o">-&gt;</span><span class="n">context_un</span><span class="p">.</span><span class="n">rrq</span><span class="p">;</span>
	<span class="n">cmdiocb</span><span class="o">-&gt;</span><span class="n">context_un</span><span class="p">.</span><span class="n">rsp_iocb</span> <span class="o">=</span> <span class="n">rspiocb</span><span class="p">;</span>

	<span class="n">irsp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">rspiocb</span><span class="o">-&gt;</span><span class="n">iocb</span><span class="p">;</span>
	<span class="n">lpfc_debugfs_disc_trc</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">LPFC_DISC_TRC_ELS_CMD</span><span class="p">,</span>
		<span class="s">&quot;RRQ cmpl:      status:x%x/x%x did:x%x&quot;</span><span class="p">,</span>
		<span class="n">irsp</span><span class="o">-&gt;</span><span class="n">ulpStatus</span><span class="p">,</span> <span class="n">irsp</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">ulpWord</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span>
		<span class="n">irsp</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">elsreq64</span><span class="p">.</span><span class="n">remoteID</span><span class="p">);</span>

	<span class="n">ndlp</span> <span class="o">=</span> <span class="n">lpfc_findnode_did</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">irsp</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">elsreq64</span><span class="p">.</span><span class="n">remoteID</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ndlp</span> <span class="o">||</span> <span class="o">!</span><span class="n">NLP_CHK_NODE_ACT</span><span class="p">(</span><span class="n">ndlp</span><span class="p">)</span> <span class="o">||</span> <span class="n">ndlp</span> <span class="o">!=</span> <span class="n">rrq</span><span class="o">-&gt;</span><span class="n">ndlp</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lpfc_printf_vlog</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_ELS</span><span class="p">,</span>
				 <span class="s">&quot;2882 RRQ completes to NPort x%x &quot;</span>
				 <span class="s">&quot;with no ndlp. Data: x%x x%x x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				 <span class="n">irsp</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">elsreq64</span><span class="p">.</span><span class="n">remoteID</span><span class="p">,</span>
				 <span class="n">irsp</span><span class="o">-&gt;</span><span class="n">ulpStatus</span><span class="p">,</span> <span class="n">irsp</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">ulpWord</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span>
				 <span class="n">irsp</span><span class="o">-&gt;</span><span class="n">ulpIoTag</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* rrq completes to NPort &lt;nlp_DID&gt; */</span>
	<span class="n">lpfc_printf_vlog</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">KERN_INFO</span><span class="p">,</span> <span class="n">LOG_ELS</span><span class="p">,</span>
			 <span class="s">&quot;2880 RRQ completes to NPort x%x &quot;</span>
			 <span class="s">&quot;Data: x%x x%x x%x x%x x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			 <span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_DID</span><span class="p">,</span> <span class="n">irsp</span><span class="o">-&gt;</span><span class="n">ulpStatus</span><span class="p">,</span> <span class="n">irsp</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">ulpWord</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span>
			 <span class="n">irsp</span><span class="o">-&gt;</span><span class="n">ulpTimeout</span><span class="p">,</span> <span class="n">rrq</span><span class="o">-&gt;</span><span class="n">xritag</span><span class="p">,</span> <span class="n">rrq</span><span class="o">-&gt;</span><span class="n">rxid</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">irsp</span><span class="o">-&gt;</span><span class="n">ulpStatus</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Check for retry */</span>
		<span class="cm">/* RRQ failed Don&#39;t print the vport to vport rjts */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">irsp</span><span class="o">-&gt;</span><span class="n">ulpStatus</span> <span class="o">!=</span> <span class="n">IOSTAT_LS_RJT</span> <span class="o">||</span>
			<span class="p">(((</span><span class="n">irsp</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">ulpWord</span><span class="p">[</span><span class="mi">4</span><span class="p">])</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span> <span class="o">!=</span> <span class="n">LSRJT_INVALID_CMD</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			<span class="p">((</span><span class="n">irsp</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">ulpWord</span><span class="p">[</span><span class="mi">4</span><span class="p">])</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span> <span class="o">!=</span> <span class="n">LSRJT_UNABLE_TPC</span><span class="p">))</span> <span class="o">||</span>
			<span class="p">(</span><span class="n">phba</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">pport</span><span class="o">-&gt;</span><span class="n">cfg_log_verbose</span> <span class="o">&amp;</span> <span class="n">LOG_ELS</span><span class="p">)</span>
			<span class="n">lpfc_printf_vlog</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_ELS</span><span class="p">,</span>
				 <span class="s">&quot;2881 RRQ failure DID:%06X Status:x%x/x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				 <span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_DID</span><span class="p">,</span> <span class="n">irsp</span><span class="o">-&gt;</span><span class="n">ulpStatus</span><span class="p">,</span>
				 <span class="n">irsp</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">ulpWord</span><span class="p">[</span><span class="mi">4</span><span class="p">]);</span>
	<span class="p">}</span>
<span class="nl">out:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rrq</span><span class="p">)</span>
		<span class="n">lpfc_clr_rrq_active</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">rrq</span><span class="o">-&gt;</span><span class="n">xritag</span><span class="p">,</span> <span class="n">rrq</span><span class="p">);</span>
	<span class="n">lpfc_els_free_iocb</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">cmdiocb</span><span class="p">);</span>
	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>
<span class="cm">/**</span>
<span class="cm"> * lpfc_cmpl_els_plogi - Completion callback function for plogi</span>
<span class="cm"> * @phba: pointer to lpfc hba data structure.</span>
<span class="cm"> * @cmdiocb: pointer to lpfc command iocb data structure.</span>
<span class="cm"> * @rspiocb: pointer to lpfc response iocb data structure.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine is the completion callback function for issuing the Port</span>
<span class="cm"> * Login (PLOGI) command. For PLOGI completion, there must be an active</span>
<span class="cm"> * ndlp on the vport node list that matches the remote node ID from the</span>
<span class="cm"> * PLOGI response IOCB. If such ndlp does not exist, the PLOGI is simply</span>
<span class="cm"> * ignored and command IOCB released. The PLOGI response IOCB status is</span>
<span class="cm"> * checked for error conditons. If there is error status reported, PLOGI</span>
<span class="cm"> * retry shall be attempted by invoking the lpfc_els_retry() routine.</span>
<span class="cm"> * Otherwise, the lpfc_plogi_confirm_nport() routine shall be invoked on</span>
<span class="cm"> * the ndlp and the NLP_EVT_CMPL_PLOGI state to the Discover State Machine</span>
<span class="cm"> * (DSM) is set for this PLOGI completion. Finally, it checks whether</span>
<span class="cm"> * there are additional N_Port nodes with the vport that need to perform</span>
<span class="cm"> * PLOGI. If so, the lpfc_more_plogi() routine is invoked to issue addition</span>
<span class="cm"> * PLOGIs.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">lpfc_cmpl_els_plogi</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">,</span> <span class="k">struct</span> <span class="n">lpfc_iocbq</span> <span class="o">*</span><span class="n">cmdiocb</span><span class="p">,</span>
		    <span class="k">struct</span> <span class="n">lpfc_iocbq</span> <span class="o">*</span><span class="n">rspiocb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="n">vport</span> <span class="o">=</span> <span class="n">cmdiocb</span><span class="o">-&gt;</span><span class="n">vport</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span>  <span class="o">*</span><span class="n">shost</span> <span class="o">=</span> <span class="n">lpfc_shost_from_vport</span><span class="p">(</span><span class="n">vport</span><span class="p">);</span>
	<span class="n">IOCB_t</span> <span class="o">*</span><span class="n">irsp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_nodelist</span> <span class="o">*</span><span class="n">ndlp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_dmabuf</span> <span class="o">*</span><span class="n">prsp</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">disc</span><span class="p">,</span> <span class="n">rc</span><span class="p">,</span> <span class="n">did</span><span class="p">,</span> <span class="n">type</span><span class="p">;</span>

	<span class="cm">/* we pass cmdiocb to state machine which needs rspiocb as well */</span>
	<span class="n">cmdiocb</span><span class="o">-&gt;</span><span class="n">context_un</span><span class="p">.</span><span class="n">rsp_iocb</span> <span class="o">=</span> <span class="n">rspiocb</span><span class="p">;</span>

	<span class="n">irsp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">rspiocb</span><span class="o">-&gt;</span><span class="n">iocb</span><span class="p">;</span>
	<span class="n">lpfc_debugfs_disc_trc</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">LPFC_DISC_TRC_ELS_CMD</span><span class="p">,</span>
		<span class="s">&quot;PLOGI cmpl:      status:x%x/x%x did:x%x&quot;</span><span class="p">,</span>
		<span class="n">irsp</span><span class="o">-&gt;</span><span class="n">ulpStatus</span><span class="p">,</span> <span class="n">irsp</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">ulpWord</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span>
		<span class="n">irsp</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">elsreq64</span><span class="p">.</span><span class="n">remoteID</span><span class="p">);</span>

	<span class="n">ndlp</span> <span class="o">=</span> <span class="n">lpfc_findnode_did</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">irsp</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">elsreq64</span><span class="p">.</span><span class="n">remoteID</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ndlp</span> <span class="o">||</span> <span class="o">!</span><span class="n">NLP_CHK_NODE_ACT</span><span class="p">(</span><span class="n">ndlp</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">lpfc_printf_vlog</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_ELS</span><span class="p">,</span>
				 <span class="s">&quot;0136 PLOGI completes to NPort x%x &quot;</span>
				 <span class="s">&quot;with no ndlp. Data: x%x x%x x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				 <span class="n">irsp</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">elsreq64</span><span class="p">.</span><span class="n">remoteID</span><span class="p">,</span>
				 <span class="n">irsp</span><span class="o">-&gt;</span><span class="n">ulpStatus</span><span class="p">,</span> <span class="n">irsp</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">ulpWord</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span>
				 <span class="n">irsp</span><span class="o">-&gt;</span><span class="n">ulpIoTag</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Since ndlp can be freed in the disc state machine, note if this node</span>
<span class="cm">	 * is being used during discovery.</span>
<span class="cm">	 */</span>
	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>
	<span class="n">disc</span> <span class="o">=</span> <span class="p">(</span><span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_flag</span> <span class="o">&amp;</span> <span class="n">NLP_NPR_2B_DISC</span><span class="p">);</span>
	<span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_flag</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">NLP_NPR_2B_DISC</span><span class="p">;</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>
	<span class="n">rc</span>   <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* PLOGI completes to NPort &lt;nlp_DID&gt; */</span>
	<span class="n">lpfc_printf_vlog</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">KERN_INFO</span><span class="p">,</span> <span class="n">LOG_ELS</span><span class="p">,</span>
			 <span class="s">&quot;0102 PLOGI completes to NPort x%x &quot;</span>
			 <span class="s">&quot;Data: x%x x%x x%x x%x x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			 <span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_DID</span><span class="p">,</span> <span class="n">irsp</span><span class="o">-&gt;</span><span class="n">ulpStatus</span><span class="p">,</span> <span class="n">irsp</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">ulpWord</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span>
			 <span class="n">irsp</span><span class="o">-&gt;</span><span class="n">ulpTimeout</span><span class="p">,</span> <span class="n">disc</span><span class="p">,</span> <span class="n">vport</span><span class="o">-&gt;</span><span class="n">num_disc_nodes</span><span class="p">);</span>
	<span class="cm">/* Check to see if link went down during discovery */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">lpfc_els_chk_latt</span><span class="p">(</span><span class="n">vport</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">spin_lock_irq</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>
		<span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_flag</span> <span class="o">|=</span> <span class="n">NLP_NPR_2B_DISC</span><span class="p">;</span>
		<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* ndlp could be freed in DSM, save these values now */</span>
	<span class="n">type</span> <span class="o">=</span> <span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_type</span><span class="p">;</span>
	<span class="n">did</span> <span class="o">=</span> <span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_DID</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">irsp</span><span class="o">-&gt;</span><span class="n">ulpStatus</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Check for retry */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">lpfc_els_retry</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">cmdiocb</span><span class="p">,</span> <span class="n">rspiocb</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/* ELS command is being retried */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">disc</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">spin_lock_irq</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>
				<span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_flag</span> <span class="o">|=</span> <span class="n">NLP_NPR_2B_DISC</span><span class="p">;</span>
				<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/* PLOGI failed Don&#39;t print the vport to vport rjts */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">irsp</span><span class="o">-&gt;</span><span class="n">ulpStatus</span> <span class="o">!=</span> <span class="n">IOSTAT_LS_RJT</span> <span class="o">||</span>
			<span class="p">(((</span><span class="n">irsp</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">ulpWord</span><span class="p">[</span><span class="mi">4</span><span class="p">])</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span> <span class="o">!=</span> <span class="n">LSRJT_INVALID_CMD</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			<span class="p">((</span><span class="n">irsp</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">ulpWord</span><span class="p">[</span><span class="mi">4</span><span class="p">])</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span> <span class="o">!=</span> <span class="n">LSRJT_UNABLE_TPC</span><span class="p">))</span> <span class="o">||</span>
			<span class="p">(</span><span class="n">phba</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">pport</span><span class="o">-&gt;</span><span class="n">cfg_log_verbose</span> <span class="o">&amp;</span> <span class="n">LOG_ELS</span><span class="p">)</span>
			<span class="n">lpfc_printf_vlog</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_ELS</span><span class="p">,</span>
				 <span class="s">&quot;2753 PLOGI failure DID:%06X Status:x%x/x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				 <span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_DID</span><span class="p">,</span> <span class="n">irsp</span><span class="o">-&gt;</span><span class="n">ulpStatus</span><span class="p">,</span>
				 <span class="n">irsp</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">ulpWord</span><span class="p">[</span><span class="mi">4</span><span class="p">]);</span>
		<span class="cm">/* Do not call DSM for lpfc_els_abort&#39;ed ELS cmds */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">lpfc_error_lost_link</span><span class="p">(</span><span class="n">irsp</span><span class="p">))</span>
			<span class="n">rc</span> <span class="o">=</span> <span class="n">NLP_STE_FREED_NODE</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">rc</span> <span class="o">=</span> <span class="n">lpfc_disc_state_machine</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">ndlp</span><span class="p">,</span> <span class="n">cmdiocb</span><span class="p">,</span>
						     <span class="n">NLP_EVT_CMPL_PLOGI</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* Good status, call state machine */</span>
		<span class="n">prsp</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(((</span><span class="k">struct</span> <span class="n">lpfc_dmabuf</span> <span class="o">*</span><span class="p">)</span>
				   <span class="n">cmdiocb</span><span class="o">-&gt;</span><span class="n">context2</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">.</span><span class="n">next</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">lpfc_dmabuf</span><span class="p">,</span> <span class="n">list</span><span class="p">);</span>
		<span class="n">ndlp</span> <span class="o">=</span> <span class="n">lpfc_plogi_confirm_nport</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">prsp</span><span class="o">-&gt;</span><span class="n">virt</span><span class="p">,</span> <span class="n">ndlp</span><span class="p">);</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">lpfc_disc_state_machine</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">ndlp</span><span class="p">,</span> <span class="n">cmdiocb</span><span class="p">,</span>
					     <span class="n">NLP_EVT_CMPL_PLOGI</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">disc</span> <span class="o">&amp;&amp;</span> <span class="n">vport</span><span class="o">-&gt;</span><span class="n">num_disc_nodes</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Check to see if there are more PLOGIs to be sent */</span>
		<span class="n">lpfc_more_plogi</span><span class="p">(</span><span class="n">vport</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">num_disc_nodes</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">spin_lock_irq</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>
			<span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_flag</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">FC_NDISC_ACTIVE</span><span class="p">;</span>
			<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>

			<span class="n">lpfc_can_disctmo</span><span class="p">(</span><span class="n">vport</span><span class="p">);</span>
			<span class="n">lpfc_end_rscn</span><span class="p">(</span><span class="n">vport</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

<span class="nl">out:</span>
	<span class="n">lpfc_els_free_iocb</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">cmdiocb</span><span class="p">);</span>
	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_issue_els_plogi - Issue an plogi iocb command for a vport</span>
<span class="cm"> * @vport: pointer to a host virtual N_Port data structure.</span>
<span class="cm"> * @did: destination port identifier.</span>
<span class="cm"> * @retry: number of retries to the command IOCB.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine issues a Port Login (PLOGI) command to a remote N_Port</span>
<span class="cm"> * (with the @did) for a @vport. Before issuing a PLOGI to a remote N_Port,</span>
<span class="cm"> * the ndlp with the remote N_Port DID must exist on the @vport&#39;s ndlp list.</span>
<span class="cm"> * This routine constructs the proper feilds of the PLOGI IOCB and invokes</span>
<span class="cm"> * the lpfc_sli_issue_iocb() routine to send out PLOGI ELS command.</span>
<span class="cm"> *</span>
<span class="cm"> * Note that, in lpfc_prep_els_iocb() routine, the reference count of ndlp</span>
<span class="cm"> * will be incremented by 1 for holding the ndlp and the reference to ndlp</span>
<span class="cm"> * will be stored into the context1 field of the IOCB for the completion</span>
<span class="cm"> * callback function to the PLOGI ELS command.</span>
<span class="cm"> *</span>
<span class="cm"> * Return code</span>
<span class="cm"> *   0 - Successfully issued a plogi for @vport</span>
<span class="cm"> *   1 - failed to issue a plogi for @vport</span>
<span class="cm"> **/</span>
<span class="kt">int</span>
<span class="nf">lpfc_issue_els_plogi</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="n">vport</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">did</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="n">retry</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpfc_hba</span>  <span class="o">*</span><span class="n">phba</span> <span class="o">=</span> <span class="n">vport</span><span class="o">-&gt;</span><span class="n">phba</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">serv_parm</span> <span class="o">*</span><span class="n">sp</span><span class="p">;</span>
	<span class="n">IOCB_t</span> <span class="o">*</span><span class="n">icmd</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_nodelist</span> <span class="o">*</span><span class="n">ndlp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_iocbq</span> <span class="o">*</span><span class="n">elsiocb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_sli</span> <span class="o">*</span><span class="n">psli</span><span class="p">;</span>
	<span class="kt">uint8_t</span> <span class="o">*</span><span class="n">pcmd</span><span class="p">;</span>
	<span class="kt">uint16_t</span> <span class="n">cmdsize</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">psli</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli</span><span class="p">;</span>

	<span class="n">ndlp</span> <span class="o">=</span> <span class="n">lpfc_findnode_did</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">did</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ndlp</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">NLP_CHK_NODE_ACT</span><span class="p">(</span><span class="n">ndlp</span><span class="p">))</span>
		<span class="n">ndlp</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="cm">/* If ndlp is not NULL, we will bump the reference count on it */</span>
	<span class="n">cmdsize</span> <span class="o">=</span> <span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">uint32_t</span><span class="p">)</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">serv_parm</span><span class="p">));</span>
	<span class="n">elsiocb</span> <span class="o">=</span> <span class="n">lpfc_prep_els_iocb</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">cmdsize</span><span class="p">,</span> <span class="n">retry</span><span class="p">,</span> <span class="n">ndlp</span><span class="p">,</span> <span class="n">did</span><span class="p">,</span>
				     <span class="n">ELS_CMD_PLOGI</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">elsiocb</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">icmd</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">elsiocb</span><span class="o">-&gt;</span><span class="n">iocb</span><span class="p">;</span>
	<span class="n">pcmd</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint8_t</span> <span class="o">*</span><span class="p">)</span> <span class="p">(((</span><span class="k">struct</span> <span class="n">lpfc_dmabuf</span> <span class="o">*</span><span class="p">)</span> <span class="n">elsiocb</span><span class="o">-&gt;</span><span class="n">context2</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">virt</span><span class="p">);</span>

	<span class="cm">/* For PLOGI request, remainder of payload is service parameters */</span>
	<span class="o">*</span><span class="p">((</span><span class="kt">uint32_t</span> <span class="o">*</span><span class="p">)</span> <span class="p">(</span><span class="n">pcmd</span><span class="p">))</span> <span class="o">=</span> <span class="n">ELS_CMD_PLOGI</span><span class="p">;</span>
	<span class="n">pcmd</span> <span class="o">+=</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">uint32_t</span><span class="p">);</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">pcmd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_sparam</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">serv_parm</span><span class="p">));</span>
	<span class="n">sp</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">serv_parm</span> <span class="o">*</span><span class="p">)</span> <span class="n">pcmd</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * If we are a N-port connected to a Fabric, fix-up paramm&#39;s so logins</span>
<span class="cm">	 * to device on remote loops work.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_flag</span> <span class="o">&amp;</span> <span class="n">FC_FABRIC</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_flag</span> <span class="o">&amp;</span> <span class="n">FC_PUBLIC_LOOP</span><span class="p">))</span>
		<span class="n">sp</span><span class="o">-&gt;</span><span class="n">cmn</span><span class="p">.</span><span class="n">altBbCredit</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">cmn</span><span class="p">.</span><span class="n">fcphLow</span> <span class="o">&lt;</span> <span class="n">FC_PH_4_3</span><span class="p">)</span>
		<span class="n">sp</span><span class="o">-&gt;</span><span class="n">cmn</span><span class="p">.</span><span class="n">fcphLow</span> <span class="o">=</span> <span class="n">FC_PH_4_3</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">cmn</span><span class="p">.</span><span class="n">fcphHigh</span> <span class="o">&lt;</span> <span class="n">FC_PH3</span><span class="p">)</span>
		<span class="n">sp</span><span class="o">-&gt;</span><span class="n">cmn</span><span class="p">.</span><span class="n">fcphHigh</span> <span class="o">=</span> <span class="n">FC_PH3</span><span class="p">;</span>

	<span class="n">lpfc_debugfs_disc_trc</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">LPFC_DISC_TRC_ELS_CMD</span><span class="p">,</span>
		<span class="s">&quot;Issue PLOGI:     did:x%x&quot;</span><span class="p">,</span>
		<span class="n">did</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">fc_stat</span><span class="p">.</span><span class="n">elsXmitPLOGI</span><span class="o">++</span><span class="p">;</span>
	<span class="n">elsiocb</span><span class="o">-&gt;</span><span class="n">iocb_cmpl</span> <span class="o">=</span> <span class="n">lpfc_cmpl_els_plogi</span><span class="p">;</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">lpfc_sli_issue_iocb</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">LPFC_ELS_RING</span><span class="p">,</span> <span class="n">elsiocb</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="n">IOCB_ERROR</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lpfc_els_free_iocb</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">elsiocb</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_cmpl_els_prli - Completion callback function for prli</span>
<span class="cm"> * @phba: pointer to lpfc hba data structure.</span>
<span class="cm"> * @cmdiocb: pointer to lpfc command iocb data structure.</span>
<span class="cm"> * @rspiocb: pointer to lpfc response iocb data structure.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine is the completion callback function for a Process Login</span>
<span class="cm"> * (PRLI) ELS command. The PRLI response IOCB status is checked for error</span>
<span class="cm"> * status. If there is error status reported, PRLI retry shall be attempted</span>
<span class="cm"> * by invoking the lpfc_els_retry() routine. Otherwise, the state</span>
<span class="cm"> * NLP_EVT_CMPL_PRLI is sent to the Discover State Machine (DSM) for this</span>
<span class="cm"> * ndlp to mark the PRLI completion.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">lpfc_cmpl_els_prli</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">,</span> <span class="k">struct</span> <span class="n">lpfc_iocbq</span> <span class="o">*</span><span class="n">cmdiocb</span><span class="p">,</span>
		   <span class="k">struct</span> <span class="n">lpfc_iocbq</span> <span class="o">*</span><span class="n">rspiocb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="n">vport</span> <span class="o">=</span> <span class="n">cmdiocb</span><span class="o">-&gt;</span><span class="n">vport</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span>  <span class="o">*</span><span class="n">shost</span> <span class="o">=</span> <span class="n">lpfc_shost_from_vport</span><span class="p">(</span><span class="n">vport</span><span class="p">);</span>
	<span class="n">IOCB_t</span> <span class="o">*</span><span class="n">irsp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_sli</span> <span class="o">*</span><span class="n">psli</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_nodelist</span> <span class="o">*</span><span class="n">ndlp</span><span class="p">;</span>

	<span class="n">psli</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli</span><span class="p">;</span>
	<span class="cm">/* we pass cmdiocb to state machine which needs rspiocb as well */</span>
	<span class="n">cmdiocb</span><span class="o">-&gt;</span><span class="n">context_un</span><span class="p">.</span><span class="n">rsp_iocb</span> <span class="o">=</span> <span class="n">rspiocb</span><span class="p">;</span>

	<span class="n">irsp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">rspiocb</span><span class="o">-&gt;</span><span class="n">iocb</span><span class="p">);</span>
	<span class="n">ndlp</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_nodelist</span> <span class="o">*</span><span class="p">)</span> <span class="n">cmdiocb</span><span class="o">-&gt;</span><span class="n">context1</span><span class="p">;</span>
	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>
	<span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_flag</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">NLP_PRLI_SND</span><span class="p">;</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>

	<span class="n">lpfc_debugfs_disc_trc</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">LPFC_DISC_TRC_ELS_CMD</span><span class="p">,</span>
		<span class="s">&quot;PRLI cmpl:       status:x%x/x%x did:x%x&quot;</span><span class="p">,</span>
		<span class="n">irsp</span><span class="o">-&gt;</span><span class="n">ulpStatus</span><span class="p">,</span> <span class="n">irsp</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">ulpWord</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span>
		<span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_DID</span><span class="p">);</span>
	<span class="cm">/* PRLI completes to NPort &lt;nlp_DID&gt; */</span>
	<span class="n">lpfc_printf_vlog</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">KERN_INFO</span><span class="p">,</span> <span class="n">LOG_ELS</span><span class="p">,</span>
			 <span class="s">&quot;0103 PRLI completes to NPort x%x &quot;</span>
			 <span class="s">&quot;Data: x%x x%x x%x x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			 <span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_DID</span><span class="p">,</span> <span class="n">irsp</span><span class="o">-&gt;</span><span class="n">ulpStatus</span><span class="p">,</span> <span class="n">irsp</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">ulpWord</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span>
			 <span class="n">irsp</span><span class="o">-&gt;</span><span class="n">ulpTimeout</span><span class="p">,</span> <span class="n">vport</span><span class="o">-&gt;</span><span class="n">num_disc_nodes</span><span class="p">);</span>

	<span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_prli_sent</span><span class="o">--</span><span class="p">;</span>
	<span class="cm">/* Check to see if link went down during discovery */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">lpfc_els_chk_latt</span><span class="p">(</span><span class="n">vport</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">irsp</span><span class="o">-&gt;</span><span class="n">ulpStatus</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Check for retry */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">lpfc_els_retry</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">cmdiocb</span><span class="p">,</span> <span class="n">rspiocb</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/* ELS command is being retried */</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/* PRLI failed */</span>
		<span class="n">lpfc_printf_vlog</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_ELS</span><span class="p">,</span>
				 <span class="s">&quot;2754 PRLI failure DID:%06X Status:x%x/x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				 <span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_DID</span><span class="p">,</span> <span class="n">irsp</span><span class="o">-&gt;</span><span class="n">ulpStatus</span><span class="p">,</span>
				 <span class="n">irsp</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">ulpWord</span><span class="p">[</span><span class="mi">4</span><span class="p">]);</span>
		<span class="cm">/* Do not call DSM for lpfc_els_abort&#39;ed ELS cmds */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">lpfc_error_lost_link</span><span class="p">(</span><span class="n">irsp</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">lpfc_disc_state_machine</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">ndlp</span><span class="p">,</span> <span class="n">cmdiocb</span><span class="p">,</span>
						<span class="n">NLP_EVT_CMPL_PRLI</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="cm">/* Good status, call state machine */</span>
		<span class="n">lpfc_disc_state_machine</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">ndlp</span><span class="p">,</span> <span class="n">cmdiocb</span><span class="p">,</span>
					<span class="n">NLP_EVT_CMPL_PRLI</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="n">lpfc_els_free_iocb</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">cmdiocb</span><span class="p">);</span>
	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_issue_els_prli - Issue a prli iocb command for a vport</span>
<span class="cm"> * @vport: pointer to a host virtual N_Port data structure.</span>
<span class="cm"> * @ndlp: pointer to a node-list data structure.</span>
<span class="cm"> * @retry: number of retries to the command IOCB.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine issues a Process Login (PRLI) ELS command for the</span>
<span class="cm"> * @vport. The PRLI service parameters are set up in the payload of the</span>
<span class="cm"> * PRLI Request command and the pointer to lpfc_cmpl_els_prli() routine</span>
<span class="cm"> * is put to the IOCB completion callback func field before invoking the</span>
<span class="cm"> * routine lpfc_sli_issue_iocb() to send out PRLI command.</span>
<span class="cm"> *</span>
<span class="cm"> * Note that, in lpfc_prep_els_iocb() routine, the reference count of ndlp</span>
<span class="cm"> * will be incremented by 1 for holding the ndlp and the reference to ndlp</span>
<span class="cm"> * will be stored into the context1 field of the IOCB for the completion</span>
<span class="cm"> * callback function to the PRLI ELS command.</span>
<span class="cm"> *</span>
<span class="cm"> * Return code</span>
<span class="cm"> *   0 - successfully issued prli iocb command for @vport</span>
<span class="cm"> *   1 - failed to issue prli iocb command for @vport</span>
<span class="cm"> **/</span>
<span class="kt">int</span>
<span class="nf">lpfc_issue_els_prli</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="n">vport</span><span class="p">,</span> <span class="k">struct</span> <span class="n">lpfc_nodelist</span> <span class="o">*</span><span class="n">ndlp</span><span class="p">,</span>
		    <span class="kt">uint8_t</span> <span class="n">retry</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span> <span class="o">=</span> <span class="n">lpfc_shost_from_vport</span><span class="p">(</span><span class="n">vport</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span> <span class="o">=</span> <span class="n">vport</span><span class="o">-&gt;</span><span class="n">phba</span><span class="p">;</span>
	<span class="n">PRLI</span> <span class="o">*</span><span class="n">npr</span><span class="p">;</span>
	<span class="n">IOCB_t</span> <span class="o">*</span><span class="n">icmd</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_iocbq</span> <span class="o">*</span><span class="n">elsiocb</span><span class="p">;</span>
	<span class="kt">uint8_t</span> <span class="o">*</span><span class="n">pcmd</span><span class="p">;</span>
	<span class="kt">uint16_t</span> <span class="n">cmdsize</span><span class="p">;</span>

	<span class="n">cmdsize</span> <span class="o">=</span> <span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">uint32_t</span><span class="p">)</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">PRLI</span><span class="p">));</span>
	<span class="n">elsiocb</span> <span class="o">=</span> <span class="n">lpfc_prep_els_iocb</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">cmdsize</span><span class="p">,</span> <span class="n">retry</span><span class="p">,</span> <span class="n">ndlp</span><span class="p">,</span>
				     <span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_DID</span><span class="p">,</span> <span class="n">ELS_CMD_PRLI</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">elsiocb</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">icmd</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">elsiocb</span><span class="o">-&gt;</span><span class="n">iocb</span><span class="p">;</span>
	<span class="n">pcmd</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint8_t</span> <span class="o">*</span><span class="p">)</span> <span class="p">(((</span><span class="k">struct</span> <span class="n">lpfc_dmabuf</span> <span class="o">*</span><span class="p">)</span> <span class="n">elsiocb</span><span class="o">-&gt;</span><span class="n">context2</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">virt</span><span class="p">);</span>

	<span class="cm">/* For PRLI request, remainder of payload is service parameters */</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">pcmd</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">PRLI</span><span class="p">)</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">uint32_t</span><span class="p">)));</span>
	<span class="o">*</span><span class="p">((</span><span class="kt">uint32_t</span> <span class="o">*</span><span class="p">)</span> <span class="p">(</span><span class="n">pcmd</span><span class="p">))</span> <span class="o">=</span> <span class="n">ELS_CMD_PRLI</span><span class="p">;</span>
	<span class="n">pcmd</span> <span class="o">+=</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">uint32_t</span><span class="p">);</span>

	<span class="cm">/* For PRLI, remainder of payload is PRLI parameter page */</span>
	<span class="n">npr</span> <span class="o">=</span> <span class="p">(</span><span class="n">PRLI</span> <span class="o">*</span><span class="p">)</span> <span class="n">pcmd</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * If our firmware version is 3.20 or later,</span>
<span class="cm">	 * set the following bits for FC-TAPE support.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">vpd</span><span class="p">.</span><span class="n">rev</span><span class="p">.</span><span class="n">feaLevelHigh</span> <span class="o">&gt;=</span> <span class="mh">0x02</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">npr</span><span class="o">-&gt;</span><span class="n">ConfmComplAllowed</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">npr</span><span class="o">-&gt;</span><span class="n">Retry</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">npr</span><span class="o">-&gt;</span><span class="n">TaskRetryIdReq</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">npr</span><span class="o">-&gt;</span><span class="n">estabImagePair</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">npr</span><span class="o">-&gt;</span><span class="n">readXferRdyDis</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/* For FCP support */</span>
	<span class="n">npr</span><span class="o">-&gt;</span><span class="n">prliType</span> <span class="o">=</span> <span class="n">PRLI_FCP_TYPE</span><span class="p">;</span>
	<span class="n">npr</span><span class="o">-&gt;</span><span class="n">initiatorFunc</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">lpfc_debugfs_disc_trc</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">LPFC_DISC_TRC_ELS_CMD</span><span class="p">,</span>
		<span class="s">&quot;Issue PRLI:      did:x%x&quot;</span><span class="p">,</span>
		<span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_DID</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">fc_stat</span><span class="p">.</span><span class="n">elsXmitPRLI</span><span class="o">++</span><span class="p">;</span>
	<span class="n">elsiocb</span><span class="o">-&gt;</span><span class="n">iocb_cmpl</span> <span class="o">=</span> <span class="n">lpfc_cmpl_els_prli</span><span class="p">;</span>
	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>
	<span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_flag</span> <span class="o">|=</span> <span class="n">NLP_PRLI_SND</span><span class="p">;</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">lpfc_sli_issue_iocb</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">LPFC_ELS_RING</span><span class="p">,</span> <span class="n">elsiocb</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">==</span>
	    <span class="n">IOCB_ERROR</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_lock_irq</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>
		<span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_flag</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">NLP_PRLI_SND</span><span class="p">;</span>
		<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>
		<span class="n">lpfc_els_free_iocb</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">elsiocb</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_prli_sent</span><span class="o">++</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_rscn_disc - Perform rscn discovery for a vport</span>
<span class="cm"> * @vport: pointer to a host virtual N_Port data structure.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine performs Registration State Change Notification (RSCN)</span>
<span class="cm"> * discovery for a @vport. If the @vport&#39;s node port recovery count is not</span>
<span class="cm"> * zero, it will invoke the lpfc_els_disc_plogi() to perform PLOGI for all</span>
<span class="cm"> * the nodes that need recovery. If none of the PLOGI were needed through</span>
<span class="cm"> * the lpfc_els_disc_plogi() routine, the lpfc_end_rscn() routine shall be</span>
<span class="cm"> * invoked to check and handle possible more RSCN came in during the period</span>
<span class="cm"> * of processing the current ones.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">lpfc_rscn_disc</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="n">vport</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">lpfc_can_disctmo</span><span class="p">(</span><span class="n">vport</span><span class="p">);</span>

	<span class="cm">/* RSCN discovery */</span>
	<span class="cm">/* go thru NPR nodes and issue ELS PLOGIs */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_npr_cnt</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">lpfc_els_disc_plogi</span><span class="p">(</span><span class="n">vport</span><span class="p">))</span>
			<span class="k">return</span><span class="p">;</span>

	<span class="n">lpfc_end_rscn</span><span class="p">(</span><span class="n">vport</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_adisc_done - Complete the adisc phase of discovery</span>
<span class="cm"> * @vport: pointer to lpfc_vport hba data structure that finished all ADISCs.</span>
<span class="cm"> *</span>
<span class="cm"> * This function is called when the final ADISC is completed during discovery.</span>
<span class="cm"> * This function handles clearing link attention or issuing reg_vpi depending</span>
<span class="cm"> * on whether npiv is enabled. This function also kicks off the PLOGI phase of</span>
<span class="cm"> * discovery.</span>
<span class="cm"> * This function is called with no locks held.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">lpfc_adisc_done</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="n">vport</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span>   <span class="o">*</span><span class="n">shost</span> <span class="o">=</span> <span class="n">lpfc_shost_from_vport</span><span class="p">(</span><span class="n">vport</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">lpfc_hba</span>   <span class="o">*</span><span class="n">phba</span> <span class="o">=</span> <span class="n">vport</span><span class="o">-&gt;</span><span class="n">phba</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * For NPIV, cmpl_reg_vpi will set port_state to READY,</span>
<span class="cm">	 * and continue discovery.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli3_options</span> <span class="o">&amp;</span> <span class="n">LPFC_SLI3_NPIV_ENABLED</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="o">!</span><span class="p">(</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_flag</span> <span class="o">&amp;</span> <span class="n">FC_RSCN_MODE</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli_rev</span> <span class="o">&lt;</span> <span class="n">LPFC_SLI_REV4</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">lpfc_issue_reg_vpi</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">vport</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	* For SLI2, we need to set port_state to READY</span>
<span class="cm">	* and continue discovery.</span>
<span class="cm">	*/</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">port_state</span> <span class="o">&lt;</span> <span class="n">LPFC_VPORT_READY</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* If we get here, there is nothing to ADISC */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">port_type</span> <span class="o">==</span> <span class="n">LPFC_PHYSICAL_PORT</span><span class="p">)</span>
			<span class="n">lpfc_issue_clear_la</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">vport</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_flag</span> <span class="o">&amp;</span> <span class="n">FC_ABORT_DISCOVERY</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">vport</span><span class="o">-&gt;</span><span class="n">num_disc_nodes</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="cm">/* go thru NPR list, issue ELS PLOGIs */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_npr_cnt</span><span class="p">)</span>
				<span class="n">lpfc_els_disc_plogi</span><span class="p">(</span><span class="n">vport</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">num_disc_nodes</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">spin_lock_irq</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>
				<span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_flag</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">FC_NDISC_ACTIVE</span><span class="p">;</span>
				<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>
				<span class="n">lpfc_can_disctmo</span><span class="p">(</span><span class="n">vport</span><span class="p">);</span>
				<span class="n">lpfc_end_rscn</span><span class="p">(</span><span class="n">vport</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="n">vport</span><span class="o">-&gt;</span><span class="n">port_state</span> <span class="o">=</span> <span class="n">LPFC_VPORT_READY</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">lpfc_rscn_disc</span><span class="p">(</span><span class="n">vport</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_more_adisc - Issue more adisc as needed</span>
<span class="cm"> * @vport: pointer to a host virtual N_Port data structure.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine determines whether there are more ndlps on a @vport</span>
<span class="cm"> * node list need to have Address Discover (ADISC) issued. If so, it will</span>
<span class="cm"> * invoke the lpfc_els_disc_adisc() routine to issue ADISC on the @vport&#39;s</span>
<span class="cm"> * remaining nodes which need to have ADISC sent.</span>
<span class="cm"> **/</span>
<span class="kt">void</span>
<span class="nf">lpfc_more_adisc</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="n">vport</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">sentadisc</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">num_disc_nodes</span><span class="p">)</span>
		<span class="n">vport</span><span class="o">-&gt;</span><span class="n">num_disc_nodes</span><span class="o">--</span><span class="p">;</span>
	<span class="cm">/* Continue discovery with &lt;num_disc_nodes&gt; ADISCs to go */</span>
	<span class="n">lpfc_printf_vlog</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">KERN_INFO</span><span class="p">,</span> <span class="n">LOG_DISCOVERY</span><span class="p">,</span>
			 <span class="s">&quot;0210 Continue discovery with %d ADISCs to go &quot;</span>
			 <span class="s">&quot;Data: x%x x%x x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			 <span class="n">vport</span><span class="o">-&gt;</span><span class="n">num_disc_nodes</span><span class="p">,</span> <span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_adisc_cnt</span><span class="p">,</span>
			 <span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_flag</span><span class="p">,</span> <span class="n">vport</span><span class="o">-&gt;</span><span class="n">port_state</span><span class="p">);</span>
	<span class="cm">/* Check to see if there are more ADISCs to be sent */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_flag</span> <span class="o">&amp;</span> <span class="n">FC_NLP_MORE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lpfc_set_disctmo</span><span class="p">(</span><span class="n">vport</span><span class="p">);</span>
		<span class="cm">/* go thru NPR nodes and issue any remaining ELS ADISCs */</span>
		<span class="n">sentadisc</span> <span class="o">=</span> <span class="n">lpfc_els_disc_adisc</span><span class="p">(</span><span class="n">vport</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">num_disc_nodes</span><span class="p">)</span>
		<span class="n">lpfc_adisc_done</span><span class="p">(</span><span class="n">vport</span><span class="p">);</span>
	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_cmpl_els_adisc - Completion callback function for adisc</span>
<span class="cm"> * @phba: pointer to lpfc hba data structure.</span>
<span class="cm"> * @cmdiocb: pointer to lpfc command iocb data structure.</span>
<span class="cm"> * @rspiocb: pointer to lpfc response iocb data structure.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine is the completion function for issuing the Address Discover</span>
<span class="cm"> * (ADISC) command. It first checks to see whether link went down during</span>
<span class="cm"> * the discovery process. If so, the node will be marked as node port</span>
<span class="cm"> * recovery for issuing discover IOCB by the link attention handler and</span>
<span class="cm"> * exit. Otherwise, the response status is checked. If error was reported</span>
<span class="cm"> * in the response status, the ADISC command shall be retried by invoking</span>
<span class="cm"> * the lpfc_els_retry() routine. Otherwise, if no error was reported in</span>
<span class="cm"> * the response status, the state machine is invoked to set transition</span>
<span class="cm"> * with respect to NLP_EVT_CMPL_ADISC event.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">lpfc_cmpl_els_adisc</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">,</span> <span class="k">struct</span> <span class="n">lpfc_iocbq</span> <span class="o">*</span><span class="n">cmdiocb</span><span class="p">,</span>
		    <span class="k">struct</span> <span class="n">lpfc_iocbq</span> <span class="o">*</span><span class="n">rspiocb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="n">vport</span> <span class="o">=</span> <span class="n">cmdiocb</span><span class="o">-&gt;</span><span class="n">vport</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span>  <span class="o">*</span><span class="n">shost</span> <span class="o">=</span> <span class="n">lpfc_shost_from_vport</span><span class="p">(</span><span class="n">vport</span><span class="p">);</span>
	<span class="n">IOCB_t</span> <span class="o">*</span><span class="n">irsp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_nodelist</span> <span class="o">*</span><span class="n">ndlp</span><span class="p">;</span>
	<span class="kt">int</span>  <span class="n">disc</span><span class="p">;</span>

	<span class="cm">/* we pass cmdiocb to state machine which needs rspiocb as well */</span>
	<span class="n">cmdiocb</span><span class="o">-&gt;</span><span class="n">context_un</span><span class="p">.</span><span class="n">rsp_iocb</span> <span class="o">=</span> <span class="n">rspiocb</span><span class="p">;</span>

	<span class="n">irsp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">rspiocb</span><span class="o">-&gt;</span><span class="n">iocb</span><span class="p">);</span>
	<span class="n">ndlp</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_nodelist</span> <span class="o">*</span><span class="p">)</span> <span class="n">cmdiocb</span><span class="o">-&gt;</span><span class="n">context1</span><span class="p">;</span>

	<span class="n">lpfc_debugfs_disc_trc</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">LPFC_DISC_TRC_ELS_CMD</span><span class="p">,</span>
		<span class="s">&quot;ADISC cmpl:      status:x%x/x%x did:x%x&quot;</span><span class="p">,</span>
		<span class="n">irsp</span><span class="o">-&gt;</span><span class="n">ulpStatus</span><span class="p">,</span> <span class="n">irsp</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">ulpWord</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span>
		<span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_DID</span><span class="p">);</span>

	<span class="cm">/* Since ndlp can be freed in the disc state machine, note if this node</span>
<span class="cm">	 * is being used during discovery.</span>
<span class="cm">	 */</span>
	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>
	<span class="n">disc</span> <span class="o">=</span> <span class="p">(</span><span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_flag</span> <span class="o">&amp;</span> <span class="n">NLP_NPR_2B_DISC</span><span class="p">);</span>
	<span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_flag</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">NLP_ADISC_SND</span> <span class="o">|</span> <span class="n">NLP_NPR_2B_DISC</span><span class="p">);</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>
	<span class="cm">/* ADISC completes to NPort &lt;nlp_DID&gt; */</span>
	<span class="n">lpfc_printf_vlog</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">KERN_INFO</span><span class="p">,</span> <span class="n">LOG_ELS</span><span class="p">,</span>
			 <span class="s">&quot;0104 ADISC completes to NPort x%x &quot;</span>
			 <span class="s">&quot;Data: x%x x%x x%x x%x x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			 <span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_DID</span><span class="p">,</span> <span class="n">irsp</span><span class="o">-&gt;</span><span class="n">ulpStatus</span><span class="p">,</span> <span class="n">irsp</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">ulpWord</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span>
			 <span class="n">irsp</span><span class="o">-&gt;</span><span class="n">ulpTimeout</span><span class="p">,</span> <span class="n">disc</span><span class="p">,</span> <span class="n">vport</span><span class="o">-&gt;</span><span class="n">num_disc_nodes</span><span class="p">);</span>
	<span class="cm">/* Check to see if link went down during discovery */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">lpfc_els_chk_latt</span><span class="p">(</span><span class="n">vport</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">spin_lock_irq</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>
		<span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_flag</span> <span class="o">|=</span> <span class="n">NLP_NPR_2B_DISC</span><span class="p">;</span>
		<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">irsp</span><span class="o">-&gt;</span><span class="n">ulpStatus</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Check for retry */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">lpfc_els_retry</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">cmdiocb</span><span class="p">,</span> <span class="n">rspiocb</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/* ELS command is being retried */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">disc</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">spin_lock_irq</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>
				<span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_flag</span> <span class="o">|=</span> <span class="n">NLP_NPR_2B_DISC</span><span class="p">;</span>
				<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>
				<span class="n">lpfc_set_disctmo</span><span class="p">(</span><span class="n">vport</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/* ADISC failed */</span>
		<span class="n">lpfc_printf_vlog</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_ELS</span><span class="p">,</span>
				 <span class="s">&quot;2755 ADISC failure DID:%06X Status:x%x/x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				 <span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_DID</span><span class="p">,</span> <span class="n">irsp</span><span class="o">-&gt;</span><span class="n">ulpStatus</span><span class="p">,</span>
				 <span class="n">irsp</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">ulpWord</span><span class="p">[</span><span class="mi">4</span><span class="p">]);</span>
		<span class="cm">/* Do not call DSM for lpfc_els_abort&#39;ed ELS cmds */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">lpfc_error_lost_link</span><span class="p">(</span><span class="n">irsp</span><span class="p">))</span>
			<span class="n">lpfc_disc_state_machine</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">ndlp</span><span class="p">,</span> <span class="n">cmdiocb</span><span class="p">,</span>
						<span class="n">NLP_EVT_CMPL_ADISC</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="cm">/* Good status, call state machine */</span>
		<span class="n">lpfc_disc_state_machine</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">ndlp</span><span class="p">,</span> <span class="n">cmdiocb</span><span class="p">,</span>
					<span class="n">NLP_EVT_CMPL_ADISC</span><span class="p">);</span>

	<span class="cm">/* Check to see if there are more ADISCs to be sent */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">disc</span> <span class="o">&amp;&amp;</span> <span class="n">vport</span><span class="o">-&gt;</span><span class="n">num_disc_nodes</span><span class="p">)</span>
		<span class="n">lpfc_more_adisc</span><span class="p">(</span><span class="n">vport</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="n">lpfc_els_free_iocb</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">cmdiocb</span><span class="p">);</span>
	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_issue_els_adisc - Issue an address discover iocb to an node on a vport</span>
<span class="cm"> * @vport: pointer to a virtual N_Port data structure.</span>
<span class="cm"> * @ndlp: pointer to a node-list data structure.</span>
<span class="cm"> * @retry: number of retries to the command IOCB.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine issues an Address Discover (ADISC) for an @ndlp on a</span>
<span class="cm"> * @vport. It prepares the payload of the ADISC ELS command, updates the</span>
<span class="cm"> * and states of the ndlp, and invokes the lpfc_sli_issue_iocb() routine</span>
<span class="cm"> * to issue the ADISC ELS command.</span>
<span class="cm"> *</span>
<span class="cm"> * Note that, in lpfc_prep_els_iocb() routine, the reference count of ndlp</span>
<span class="cm"> * will be incremented by 1 for holding the ndlp and the reference to ndlp</span>
<span class="cm"> * will be stored into the context1 field of the IOCB for the completion</span>
<span class="cm"> * callback function to the ADISC ELS command.</span>
<span class="cm"> *</span>
<span class="cm"> * Return code</span>
<span class="cm"> *   0 - successfully issued adisc</span>
<span class="cm"> *   1 - failed to issue adisc</span>
<span class="cm"> **/</span>
<span class="kt">int</span>
<span class="nf">lpfc_issue_els_adisc</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="n">vport</span><span class="p">,</span> <span class="k">struct</span> <span class="n">lpfc_nodelist</span> <span class="o">*</span><span class="n">ndlp</span><span class="p">,</span>
		     <span class="kt">uint8_t</span> <span class="n">retry</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span> <span class="o">=</span> <span class="n">lpfc_shost_from_vport</span><span class="p">(</span><span class="n">vport</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">lpfc_hba</span>  <span class="o">*</span><span class="n">phba</span> <span class="o">=</span> <span class="n">vport</span><span class="o">-&gt;</span><span class="n">phba</span><span class="p">;</span>
	<span class="n">ADISC</span> <span class="o">*</span><span class="n">ap</span><span class="p">;</span>
	<span class="n">IOCB_t</span> <span class="o">*</span><span class="n">icmd</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_iocbq</span> <span class="o">*</span><span class="n">elsiocb</span><span class="p">;</span>
	<span class="kt">uint8_t</span> <span class="o">*</span><span class="n">pcmd</span><span class="p">;</span>
	<span class="kt">uint16_t</span> <span class="n">cmdsize</span><span class="p">;</span>

	<span class="n">cmdsize</span> <span class="o">=</span> <span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">uint32_t</span><span class="p">)</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">ADISC</span><span class="p">));</span>
	<span class="n">elsiocb</span> <span class="o">=</span> <span class="n">lpfc_prep_els_iocb</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">cmdsize</span><span class="p">,</span> <span class="n">retry</span><span class="p">,</span> <span class="n">ndlp</span><span class="p">,</span>
				     <span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_DID</span><span class="p">,</span> <span class="n">ELS_CMD_ADISC</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">elsiocb</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">icmd</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">elsiocb</span><span class="o">-&gt;</span><span class="n">iocb</span><span class="p">;</span>
	<span class="n">pcmd</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint8_t</span> <span class="o">*</span><span class="p">)</span> <span class="p">(((</span><span class="k">struct</span> <span class="n">lpfc_dmabuf</span> <span class="o">*</span><span class="p">)</span> <span class="n">elsiocb</span><span class="o">-&gt;</span><span class="n">context2</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">virt</span><span class="p">);</span>

	<span class="cm">/* For ADISC request, remainder of payload is service parameters */</span>
	<span class="o">*</span><span class="p">((</span><span class="kt">uint32_t</span> <span class="o">*</span><span class="p">)</span> <span class="p">(</span><span class="n">pcmd</span><span class="p">))</span> <span class="o">=</span> <span class="n">ELS_CMD_ADISC</span><span class="p">;</span>
	<span class="n">pcmd</span> <span class="o">+=</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">uint32_t</span><span class="p">);</span>

	<span class="cm">/* Fill in ADISC payload */</span>
	<span class="n">ap</span> <span class="o">=</span> <span class="p">(</span><span class="n">ADISC</span> <span class="o">*</span><span class="p">)</span> <span class="n">pcmd</span><span class="p">;</span>
	<span class="n">ap</span><span class="o">-&gt;</span><span class="n">hardAL_PA</span> <span class="o">=</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">fc_pref_ALPA</span><span class="p">;</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">portName</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_portname</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_name</span><span class="p">));</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">nodeName</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_nodename</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_name</span><span class="p">));</span>
	<span class="n">ap</span><span class="o">-&gt;</span><span class="n">DID</span> <span class="o">=</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_myDID</span><span class="p">);</span>

	<span class="n">lpfc_debugfs_disc_trc</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">LPFC_DISC_TRC_ELS_CMD</span><span class="p">,</span>
		<span class="s">&quot;Issue ADISC:     did:x%x&quot;</span><span class="p">,</span>
		<span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_DID</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">fc_stat</span><span class="p">.</span><span class="n">elsXmitADISC</span><span class="o">++</span><span class="p">;</span>
	<span class="n">elsiocb</span><span class="o">-&gt;</span><span class="n">iocb_cmpl</span> <span class="o">=</span> <span class="n">lpfc_cmpl_els_adisc</span><span class="p">;</span>
	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>
	<span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_flag</span> <span class="o">|=</span> <span class="n">NLP_ADISC_SND</span><span class="p">;</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">lpfc_sli_issue_iocb</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">LPFC_ELS_RING</span><span class="p">,</span> <span class="n">elsiocb</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">==</span>
	    <span class="n">IOCB_ERROR</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_lock_irq</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>
		<span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_flag</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">NLP_ADISC_SND</span><span class="p">;</span>
		<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>
		<span class="n">lpfc_els_free_iocb</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">elsiocb</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_cmpl_els_logo - Completion callback function for logo</span>
<span class="cm"> * @phba: pointer to lpfc hba data structure.</span>
<span class="cm"> * @cmdiocb: pointer to lpfc command iocb data structure.</span>
<span class="cm"> * @rspiocb: pointer to lpfc response iocb data structure.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine is the completion function for issuing the ELS Logout (LOGO)</span>
<span class="cm"> * command. If no error status was reported from the LOGO response, the</span>
<span class="cm"> * state machine of the associated ndlp shall be invoked for transition with</span>
<span class="cm"> * respect to NLP_EVT_CMPL_LOGO event. Otherwise, if error status was reported,</span>
<span class="cm"> * the lpfc_els_retry() routine will be invoked to retry the LOGO command.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">lpfc_cmpl_els_logo</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">,</span> <span class="k">struct</span> <span class="n">lpfc_iocbq</span> <span class="o">*</span><span class="n">cmdiocb</span><span class="p">,</span>
		   <span class="k">struct</span> <span class="n">lpfc_iocbq</span> <span class="o">*</span><span class="n">rspiocb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpfc_nodelist</span> <span class="o">*</span><span class="n">ndlp</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_nodelist</span> <span class="o">*</span><span class="p">)</span> <span class="n">cmdiocb</span><span class="o">-&gt;</span><span class="n">context1</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="n">vport</span> <span class="o">=</span> <span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">vport</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span>  <span class="o">*</span><span class="n">shost</span> <span class="o">=</span> <span class="n">lpfc_shost_from_vport</span><span class="p">(</span><span class="n">vport</span><span class="p">);</span>
	<span class="n">IOCB_t</span> <span class="o">*</span><span class="n">irsp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_sli</span> <span class="o">*</span><span class="n">psli</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfcMboxq</span> <span class="o">*</span><span class="n">mbox</span><span class="p">;</span>

	<span class="n">psli</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli</span><span class="p">;</span>
	<span class="cm">/* we pass cmdiocb to state machine which needs rspiocb as well */</span>
	<span class="n">cmdiocb</span><span class="o">-&gt;</span><span class="n">context_un</span><span class="p">.</span><span class="n">rsp_iocb</span> <span class="o">=</span> <span class="n">rspiocb</span><span class="p">;</span>

	<span class="n">irsp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">rspiocb</span><span class="o">-&gt;</span><span class="n">iocb</span><span class="p">);</span>
	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>
	<span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_flag</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">NLP_LOGO_SND</span><span class="p">;</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>

	<span class="n">lpfc_debugfs_disc_trc</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">LPFC_DISC_TRC_ELS_CMD</span><span class="p">,</span>
		<span class="s">&quot;LOGO cmpl:       status:x%x/x%x did:x%x&quot;</span><span class="p">,</span>
		<span class="n">irsp</span><span class="o">-&gt;</span><span class="n">ulpStatus</span><span class="p">,</span> <span class="n">irsp</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">ulpWord</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span>
		<span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_DID</span><span class="p">);</span>
	<span class="cm">/* LOGO completes to NPort &lt;nlp_DID&gt; */</span>
	<span class="n">lpfc_printf_vlog</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">KERN_INFO</span><span class="p">,</span> <span class="n">LOG_ELS</span><span class="p">,</span>
			 <span class="s">&quot;0105 LOGO completes to NPort x%x &quot;</span>
			 <span class="s">&quot;Data: x%x x%x x%x x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			 <span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_DID</span><span class="p">,</span> <span class="n">irsp</span><span class="o">-&gt;</span><span class="n">ulpStatus</span><span class="p">,</span> <span class="n">irsp</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">ulpWord</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span>
			 <span class="n">irsp</span><span class="o">-&gt;</span><span class="n">ulpTimeout</span><span class="p">,</span> <span class="n">vport</span><span class="o">-&gt;</span><span class="n">num_disc_nodes</span><span class="p">);</span>
	<span class="cm">/* Check to see if link went down during discovery */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">lpfc_els_chk_latt</span><span class="p">(</span><span class="n">vport</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_flag</span> <span class="o">&amp;</span> <span class="n">NLP_TARGET_REMOVE</span><span class="p">)</span> <span class="p">{</span>
	        <span class="cm">/* NLP_EVT_DEVICE_RM should unregister the RPI</span>
<span class="cm">		 * which should abort all outstanding IOs.</span>
<span class="cm">		 */</span>
		<span class="n">lpfc_disc_state_machine</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">ndlp</span><span class="p">,</span> <span class="n">cmdiocb</span><span class="p">,</span>
					<span class="n">NLP_EVT_DEVICE_RM</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">irsp</span><span class="o">-&gt;</span><span class="n">ulpStatus</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Check for retry */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">lpfc_els_retry</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">cmdiocb</span><span class="p">,</span> <span class="n">rspiocb</span><span class="p">))</span>
			<span class="cm">/* ELS command is being retried */</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="cm">/* LOGO failed */</span>
		<span class="n">lpfc_printf_vlog</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_ELS</span><span class="p">,</span>
				 <span class="s">&quot;2756 LOGO failure DID:%06X Status:x%x/x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				 <span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_DID</span><span class="p">,</span> <span class="n">irsp</span><span class="o">-&gt;</span><span class="n">ulpStatus</span><span class="p">,</span>
				 <span class="n">irsp</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">ulpWord</span><span class="p">[</span><span class="mi">4</span><span class="p">]);</span>
		<span class="cm">/* Do not call DSM for lpfc_els_abort&#39;ed ELS cmds */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">lpfc_error_lost_link</span><span class="p">(</span><span class="n">irsp</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">lpfc_disc_state_machine</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">ndlp</span><span class="p">,</span> <span class="n">cmdiocb</span><span class="p">,</span>
						<span class="n">NLP_EVT_CMPL_LOGO</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="cm">/* Good status, call state machine.</span>
<span class="cm">		 * This will unregister the rpi if needed.</span>
<span class="cm">		 */</span>
		<span class="n">lpfc_disc_state_machine</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">ndlp</span><span class="p">,</span> <span class="n">cmdiocb</span><span class="p">,</span>
					<span class="n">NLP_EVT_CMPL_LOGO</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="n">lpfc_els_free_iocb</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">cmdiocb</span><span class="p">);</span>
	<span class="cm">/* If we are in pt2pt mode, we could rcv new S_ID on PLOGI */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_flag</span> <span class="o">&amp;</span> <span class="n">FC_PT2PT</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		<span class="o">!</span><span class="p">(</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_flag</span> <span class="o">&amp;</span> <span class="n">FC_PT2PT_PLOGI</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">pport</span><span class="o">-&gt;</span><span class="n">fc_myDID</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">mbox</span> <span class="o">=</span> <span class="n">mempool_alloc</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">mbox_mem_pool</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">mbox</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">lpfc_config_link</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">mbox</span><span class="p">);</span>
			<span class="n">mbox</span><span class="o">-&gt;</span><span class="n">mbox_cmpl</span> <span class="o">=</span> <span class="n">lpfc_sli_def_mbox_cmpl</span><span class="p">;</span>
			<span class="n">mbox</span><span class="o">-&gt;</span><span class="n">vport</span> <span class="o">=</span> <span class="n">vport</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">lpfc_sli_issue_mbox</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">mbox</span><span class="p">,</span> <span class="n">MBX_NOWAIT</span><span class="p">)</span> <span class="o">==</span>
				<span class="n">MBX_NOT_FINISHED</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">mempool_free</span><span class="p">(</span><span class="n">mbox</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">mbox_mem_pool</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_issue_els_logo - Issue a logo to an node on a vport</span>
<span class="cm"> * @vport: pointer to a virtual N_Port data structure.</span>
<span class="cm"> * @ndlp: pointer to a node-list data structure.</span>
<span class="cm"> * @retry: number of retries to the command IOCB.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine constructs and issues an ELS Logout (LOGO) iocb command</span>
<span class="cm"> * to a remote node, referred by an @ndlp on a @vport. It constructs the</span>
<span class="cm"> * payload of the IOCB, properly sets up the @ndlp state, and invokes the</span>
<span class="cm"> * lpfc_sli_issue_iocb() routine to send out the LOGO ELS command.</span>
<span class="cm"> *</span>
<span class="cm"> * Note that, in lpfc_prep_els_iocb() routine, the reference count of ndlp</span>
<span class="cm"> * will be incremented by 1 for holding the ndlp and the reference to ndlp</span>
<span class="cm"> * will be stored into the context1 field of the IOCB for the completion</span>
<span class="cm"> * callback function to the LOGO ELS command.</span>
<span class="cm"> *</span>
<span class="cm"> * Return code</span>
<span class="cm"> *   0 - successfully issued logo</span>
<span class="cm"> *   1 - failed to issue logo</span>
<span class="cm"> **/</span>
<span class="kt">int</span>
<span class="nf">lpfc_issue_els_logo</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="n">vport</span><span class="p">,</span> <span class="k">struct</span> <span class="n">lpfc_nodelist</span> <span class="o">*</span><span class="n">ndlp</span><span class="p">,</span>
		    <span class="kt">uint8_t</span> <span class="n">retry</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span> <span class="o">=</span> <span class="n">lpfc_shost_from_vport</span><span class="p">(</span><span class="n">vport</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">lpfc_hba</span>  <span class="o">*</span><span class="n">phba</span> <span class="o">=</span> <span class="n">vport</span><span class="o">-&gt;</span><span class="n">phba</span><span class="p">;</span>
	<span class="n">IOCB_t</span> <span class="o">*</span><span class="n">icmd</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_iocbq</span> <span class="o">*</span><span class="n">elsiocb</span><span class="p">;</span>
	<span class="kt">uint8_t</span> <span class="o">*</span><span class="n">pcmd</span><span class="p">;</span>
	<span class="kt">uint16_t</span> <span class="n">cmdsize</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_flag</span> <span class="o">&amp;</span> <span class="n">NLP_LOGO_SND</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>

	<span class="n">cmdsize</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">uint32_t</span><span class="p">))</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_name</span><span class="p">);</span>
	<span class="n">elsiocb</span> <span class="o">=</span> <span class="n">lpfc_prep_els_iocb</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">cmdsize</span><span class="p">,</span> <span class="n">retry</span><span class="p">,</span> <span class="n">ndlp</span><span class="p">,</span>
				     <span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_DID</span><span class="p">,</span> <span class="n">ELS_CMD_LOGO</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">elsiocb</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">icmd</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">elsiocb</span><span class="o">-&gt;</span><span class="n">iocb</span><span class="p">;</span>
	<span class="n">pcmd</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint8_t</span> <span class="o">*</span><span class="p">)</span> <span class="p">(((</span><span class="k">struct</span> <span class="n">lpfc_dmabuf</span> <span class="o">*</span><span class="p">)</span> <span class="n">elsiocb</span><span class="o">-&gt;</span><span class="n">context2</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">virt</span><span class="p">);</span>
	<span class="o">*</span><span class="p">((</span><span class="kt">uint32_t</span> <span class="o">*</span><span class="p">)</span> <span class="p">(</span><span class="n">pcmd</span><span class="p">))</span> <span class="o">=</span> <span class="n">ELS_CMD_LOGO</span><span class="p">;</span>
	<span class="n">pcmd</span> <span class="o">+=</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">uint32_t</span><span class="p">);</span>

	<span class="cm">/* Fill in LOGO payload */</span>
	<span class="o">*</span><span class="p">((</span><span class="kt">uint32_t</span> <span class="o">*</span><span class="p">)</span> <span class="p">(</span><span class="n">pcmd</span><span class="p">))</span> <span class="o">=</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_myDID</span><span class="p">);</span>
	<span class="n">pcmd</span> <span class="o">+=</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">uint32_t</span><span class="p">);</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">pcmd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_portname</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_name</span><span class="p">));</span>

	<span class="n">lpfc_debugfs_disc_trc</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">LPFC_DISC_TRC_ELS_CMD</span><span class="p">,</span>
		<span class="s">&quot;Issue LOGO:      did:x%x&quot;</span><span class="p">,</span>
		<span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_DID</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">fc_stat</span><span class="p">.</span><span class="n">elsXmitLOGO</span><span class="o">++</span><span class="p">;</span>
	<span class="n">elsiocb</span><span class="o">-&gt;</span><span class="n">iocb_cmpl</span> <span class="o">=</span> <span class="n">lpfc_cmpl_els_logo</span><span class="p">;</span>
	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>
	<span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_flag</span> <span class="o">|=</span> <span class="n">NLP_LOGO_SND</span><span class="p">;</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">lpfc_sli_issue_iocb</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">LPFC_ELS_RING</span><span class="p">,</span> <span class="n">elsiocb</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">==</span> <span class="n">IOCB_ERROR</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_lock_irq</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>
		<span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_flag</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">NLP_LOGO_SND</span><span class="p">;</span>
		<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>
		<span class="n">lpfc_els_free_iocb</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">elsiocb</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_cmpl_els_cmd - Completion callback function for generic els command</span>
<span class="cm"> * @phba: pointer to lpfc hba data structure.</span>
<span class="cm"> * @cmdiocb: pointer to lpfc command iocb data structure.</span>
<span class="cm"> * @rspiocb: pointer to lpfc response iocb data structure.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine is a generic completion callback function for ELS commands.</span>
<span class="cm"> * Specifically, it is the callback function which does not need to perform</span>
<span class="cm"> * any command specific operations. It is currently used by the ELS command</span>
<span class="cm"> * issuing routines for the ELS State Change  Request (SCR),</span>
<span class="cm"> * lpfc_issue_els_scr(), and the ELS Fibre Channel Address Resolution</span>
<span class="cm"> * Protocol Response (FARPR) routine, lpfc_issue_els_farpr(). Other than</span>
<span class="cm"> * certain debug loggings, this callback function simply invokes the</span>
<span class="cm"> * lpfc_els_chk_latt() routine to check whether link went down during the</span>
<span class="cm"> * discovery process.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">lpfc_cmpl_els_cmd</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">,</span> <span class="k">struct</span> <span class="n">lpfc_iocbq</span> <span class="o">*</span><span class="n">cmdiocb</span><span class="p">,</span>
		  <span class="k">struct</span> <span class="n">lpfc_iocbq</span> <span class="o">*</span><span class="n">rspiocb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="n">vport</span> <span class="o">=</span> <span class="n">cmdiocb</span><span class="o">-&gt;</span><span class="n">vport</span><span class="p">;</span>
	<span class="n">IOCB_t</span> <span class="o">*</span><span class="n">irsp</span><span class="p">;</span>

	<span class="n">irsp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">rspiocb</span><span class="o">-&gt;</span><span class="n">iocb</span><span class="p">;</span>

	<span class="n">lpfc_debugfs_disc_trc</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">LPFC_DISC_TRC_ELS_CMD</span><span class="p">,</span>
		<span class="s">&quot;ELS cmd cmpl:    status:x%x/x%x did:x%x&quot;</span><span class="p">,</span>
		<span class="n">irsp</span><span class="o">-&gt;</span><span class="n">ulpStatus</span><span class="p">,</span> <span class="n">irsp</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">ulpWord</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span>
		<span class="n">irsp</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">elsreq64</span><span class="p">.</span><span class="n">remoteID</span><span class="p">);</span>
	<span class="cm">/* ELS cmd tag &lt;ulpIoTag&gt; completes */</span>
	<span class="n">lpfc_printf_vlog</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">KERN_INFO</span><span class="p">,</span> <span class="n">LOG_ELS</span><span class="p">,</span>
			 <span class="s">&quot;0106 ELS cmd tag x%x completes Data: x%x x%x x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			 <span class="n">irsp</span><span class="o">-&gt;</span><span class="n">ulpIoTag</span><span class="p">,</span> <span class="n">irsp</span><span class="o">-&gt;</span><span class="n">ulpStatus</span><span class="p">,</span>
			 <span class="n">irsp</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">ulpWord</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span> <span class="n">irsp</span><span class="o">-&gt;</span><span class="n">ulpTimeout</span><span class="p">);</span>
	<span class="cm">/* Check to see if link went down during discovery */</span>
	<span class="n">lpfc_els_chk_latt</span><span class="p">(</span><span class="n">vport</span><span class="p">);</span>
	<span class="n">lpfc_els_free_iocb</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">cmdiocb</span><span class="p">);</span>
	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_issue_els_scr - Issue a scr to an node on a vport</span>
<span class="cm"> * @vport: pointer to a host virtual N_Port data structure.</span>
<span class="cm"> * @nportid: N_Port identifier to the remote node.</span>
<span class="cm"> * @retry: number of retries to the command IOCB.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine issues a State Change Request (SCR) to a fabric node</span>
<span class="cm"> * on a @vport. The remote node @nportid is passed into the function. It</span>
<span class="cm"> * first search the @vport node list to find the matching ndlp. If no such</span>
<span class="cm"> * ndlp is found, a new ndlp shall be created for this (SCR) purpose. An</span>
<span class="cm"> * IOCB is allocated, payload prepared, and the lpfc_sli_issue_iocb()</span>
<span class="cm"> * routine is invoked to send the SCR IOCB.</span>
<span class="cm"> *</span>
<span class="cm"> * Note that, in lpfc_prep_els_iocb() routine, the reference count of ndlp</span>
<span class="cm"> * will be incremented by 1 for holding the ndlp and the reference to ndlp</span>
<span class="cm"> * will be stored into the context1 field of the IOCB for the completion</span>
<span class="cm"> * callback function to the SCR ELS command.</span>
<span class="cm"> *</span>
<span class="cm"> * Return code</span>
<span class="cm"> *   0 - Successfully issued scr command</span>
<span class="cm"> *   1 - Failed to issue scr command</span>
<span class="cm"> **/</span>
<span class="kt">int</span>
<span class="nf">lpfc_issue_els_scr</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="n">vport</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">nportid</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="n">retry</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpfc_hba</span>  <span class="o">*</span><span class="n">phba</span> <span class="o">=</span> <span class="n">vport</span><span class="o">-&gt;</span><span class="n">phba</span><span class="p">;</span>
	<span class="n">IOCB_t</span> <span class="o">*</span><span class="n">icmd</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_iocbq</span> <span class="o">*</span><span class="n">elsiocb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_sli</span> <span class="o">*</span><span class="n">psli</span><span class="p">;</span>
	<span class="kt">uint8_t</span> <span class="o">*</span><span class="n">pcmd</span><span class="p">;</span>
	<span class="kt">uint16_t</span> <span class="n">cmdsize</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_nodelist</span> <span class="o">*</span><span class="n">ndlp</span><span class="p">;</span>

	<span class="n">psli</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli</span><span class="p">;</span>
	<span class="n">cmdsize</span> <span class="o">=</span> <span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">uint32_t</span><span class="p">)</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">SCR</span><span class="p">));</span>

	<span class="n">ndlp</span> <span class="o">=</span> <span class="n">lpfc_findnode_did</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">nportid</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ndlp</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ndlp</span> <span class="o">=</span> <span class="n">mempool_alloc</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">nlp_mem_pool</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ndlp</span><span class="p">)</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">lpfc_nlp_init</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">ndlp</span><span class="p">,</span> <span class="n">nportid</span><span class="p">);</span>
		<span class="n">lpfc_enqueue_node</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">ndlp</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">NLP_CHK_NODE_ACT</span><span class="p">(</span><span class="n">ndlp</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ndlp</span> <span class="o">=</span> <span class="n">lpfc_enable_node</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">ndlp</span><span class="p">,</span> <span class="n">NLP_STE_UNUSED_NODE</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ndlp</span><span class="p">)</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">elsiocb</span> <span class="o">=</span> <span class="n">lpfc_prep_els_iocb</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">cmdsize</span><span class="p">,</span> <span class="n">retry</span><span class="p">,</span> <span class="n">ndlp</span><span class="p">,</span>
				     <span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_DID</span><span class="p">,</span> <span class="n">ELS_CMD_SCR</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">elsiocb</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* This will trigger the release of the node just</span>
<span class="cm">		 * allocated</span>
<span class="cm">		 */</span>
		<span class="n">lpfc_nlp_put</span><span class="p">(</span><span class="n">ndlp</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">icmd</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">elsiocb</span><span class="o">-&gt;</span><span class="n">iocb</span><span class="p">;</span>
	<span class="n">pcmd</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint8_t</span> <span class="o">*</span><span class="p">)</span> <span class="p">(((</span><span class="k">struct</span> <span class="n">lpfc_dmabuf</span> <span class="o">*</span><span class="p">)</span> <span class="n">elsiocb</span><span class="o">-&gt;</span><span class="n">context2</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">virt</span><span class="p">);</span>

	<span class="o">*</span><span class="p">((</span><span class="kt">uint32_t</span> <span class="o">*</span><span class="p">)</span> <span class="p">(</span><span class="n">pcmd</span><span class="p">))</span> <span class="o">=</span> <span class="n">ELS_CMD_SCR</span><span class="p">;</span>
	<span class="n">pcmd</span> <span class="o">+=</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">uint32_t</span><span class="p">);</span>

	<span class="cm">/* For SCR, remainder of payload is SCR parameter page */</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">pcmd</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">SCR</span><span class="p">));</span>
	<span class="p">((</span><span class="n">SCR</span> <span class="o">*</span><span class="p">)</span> <span class="n">pcmd</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">Function</span> <span class="o">=</span> <span class="n">SCR_FUNC_FULL</span><span class="p">;</span>

	<span class="n">lpfc_debugfs_disc_trc</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">LPFC_DISC_TRC_ELS_CMD</span><span class="p">,</span>
		<span class="s">&quot;Issue SCR:       did:x%x&quot;</span><span class="p">,</span>
		<span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_DID</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">fc_stat</span><span class="p">.</span><span class="n">elsXmitSCR</span><span class="o">++</span><span class="p">;</span>
	<span class="n">elsiocb</span><span class="o">-&gt;</span><span class="n">iocb_cmpl</span> <span class="o">=</span> <span class="n">lpfc_cmpl_els_cmd</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">lpfc_sli_issue_iocb</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">LPFC_ELS_RING</span><span class="p">,</span> <span class="n">elsiocb</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">==</span>
	    <span class="n">IOCB_ERROR</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* The additional lpfc_nlp_put will cause the following</span>
<span class="cm">		 * lpfc_els_free_iocb routine to trigger the rlease of</span>
<span class="cm">		 * the node.</span>
<span class="cm">		 */</span>
		<span class="n">lpfc_nlp_put</span><span class="p">(</span><span class="n">ndlp</span><span class="p">);</span>
		<span class="n">lpfc_els_free_iocb</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">elsiocb</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* This will cause the callback-function lpfc_cmpl_els_cmd to</span>
<span class="cm">	 * trigger the release of node.</span>
<span class="cm">	 */</span>
	<span class="n">lpfc_nlp_put</span><span class="p">(</span><span class="n">ndlp</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_issue_els_farpr - Issue a farp to an node on a vport</span>
<span class="cm"> * @vport: pointer to a host virtual N_Port data structure.</span>
<span class="cm"> * @nportid: N_Port identifier to the remote node.</span>
<span class="cm"> * @retry: number of retries to the command IOCB.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine issues a Fibre Channel Address Resolution Response</span>
<span class="cm"> * (FARPR) to a node on a vport. The remote node N_Port identifier (@nportid)</span>
<span class="cm"> * is passed into the function. It first search the @vport node list to find</span>
<span class="cm"> * the matching ndlp. If no such ndlp is found, a new ndlp shall be created</span>
<span class="cm"> * for this (FARPR) purpose. An IOCB is allocated, payload prepared, and the</span>
<span class="cm"> * lpfc_sli_issue_iocb() routine is invoked to send the FARPR ELS command.</span>
<span class="cm"> *</span>
<span class="cm"> * Note that, in lpfc_prep_els_iocb() routine, the reference count of ndlp</span>
<span class="cm"> * will be incremented by 1 for holding the ndlp and the reference to ndlp</span>
<span class="cm"> * will be stored into the context1 field of the IOCB for the completion</span>
<span class="cm"> * callback function to the PARPR ELS command.</span>
<span class="cm"> *</span>
<span class="cm"> * Return code</span>
<span class="cm"> *   0 - Successfully issued farpr command</span>
<span class="cm"> *   1 - Failed to issue farpr command</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">lpfc_issue_els_farpr</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="n">vport</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">nportid</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="n">retry</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpfc_hba</span>  <span class="o">*</span><span class="n">phba</span> <span class="o">=</span> <span class="n">vport</span><span class="o">-&gt;</span><span class="n">phba</span><span class="p">;</span>
	<span class="n">IOCB_t</span> <span class="o">*</span><span class="n">icmd</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_iocbq</span> <span class="o">*</span><span class="n">elsiocb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_sli</span> <span class="o">*</span><span class="n">psli</span><span class="p">;</span>
	<span class="n">FARP</span> <span class="o">*</span><span class="n">fp</span><span class="p">;</span>
	<span class="kt">uint8_t</span> <span class="o">*</span><span class="n">pcmd</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="o">*</span><span class="n">lp</span><span class="p">;</span>
	<span class="kt">uint16_t</span> <span class="n">cmdsize</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_nodelist</span> <span class="o">*</span><span class="n">ondlp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_nodelist</span> <span class="o">*</span><span class="n">ndlp</span><span class="p">;</span>

	<span class="n">psli</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli</span><span class="p">;</span>
	<span class="n">cmdsize</span> <span class="o">=</span> <span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">uint32_t</span><span class="p">)</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">FARP</span><span class="p">));</span>

	<span class="n">ndlp</span> <span class="o">=</span> <span class="n">lpfc_findnode_did</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">nportid</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ndlp</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ndlp</span> <span class="o">=</span> <span class="n">mempool_alloc</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">nlp_mem_pool</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ndlp</span><span class="p">)</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">lpfc_nlp_init</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">ndlp</span><span class="p">,</span> <span class="n">nportid</span><span class="p">);</span>
		<span class="n">lpfc_enqueue_node</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">ndlp</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">NLP_CHK_NODE_ACT</span><span class="p">(</span><span class="n">ndlp</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ndlp</span> <span class="o">=</span> <span class="n">lpfc_enable_node</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">ndlp</span><span class="p">,</span> <span class="n">NLP_STE_UNUSED_NODE</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ndlp</span><span class="p">)</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">elsiocb</span> <span class="o">=</span> <span class="n">lpfc_prep_els_iocb</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">cmdsize</span><span class="p">,</span> <span class="n">retry</span><span class="p">,</span> <span class="n">ndlp</span><span class="p">,</span>
				     <span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_DID</span><span class="p">,</span> <span class="n">ELS_CMD_RNID</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">elsiocb</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* This will trigger the release of the node just</span>
<span class="cm">		 * allocated</span>
<span class="cm">		 */</span>
		<span class="n">lpfc_nlp_put</span><span class="p">(</span><span class="n">ndlp</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">icmd</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">elsiocb</span><span class="o">-&gt;</span><span class="n">iocb</span><span class="p">;</span>
	<span class="n">pcmd</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint8_t</span> <span class="o">*</span><span class="p">)</span> <span class="p">(((</span><span class="k">struct</span> <span class="n">lpfc_dmabuf</span> <span class="o">*</span><span class="p">)</span> <span class="n">elsiocb</span><span class="o">-&gt;</span><span class="n">context2</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">virt</span><span class="p">);</span>

	<span class="o">*</span><span class="p">((</span><span class="kt">uint32_t</span> <span class="o">*</span><span class="p">)</span> <span class="p">(</span><span class="n">pcmd</span><span class="p">))</span> <span class="o">=</span> <span class="n">ELS_CMD_FARPR</span><span class="p">;</span>
	<span class="n">pcmd</span> <span class="o">+=</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">uint32_t</span><span class="p">);</span>

	<span class="cm">/* Fill in FARPR payload */</span>
	<span class="n">fp</span> <span class="o">=</span> <span class="p">(</span><span class="n">FARP</span> <span class="o">*</span><span class="p">)</span> <span class="p">(</span><span class="n">pcmd</span><span class="p">);</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">fp</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">FARP</span><span class="p">));</span>
	<span class="n">lp</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint32_t</span> <span class="o">*</span><span class="p">)</span> <span class="n">pcmd</span><span class="p">;</span>
	<span class="o">*</span><span class="n">lp</span><span class="o">++</span> <span class="o">=</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">nportid</span><span class="p">);</span>
	<span class="o">*</span><span class="n">lp</span><span class="o">++</span> <span class="o">=</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_myDID</span><span class="p">);</span>
	<span class="n">fp</span><span class="o">-&gt;</span><span class="n">Rflags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">fp</span><span class="o">-&gt;</span><span class="n">Mflags</span> <span class="o">=</span> <span class="p">(</span><span class="n">FARP_MATCH_PORT</span> <span class="o">|</span> <span class="n">FARP_MATCH_NODE</span><span class="p">);</span>

	<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fp</span><span class="o">-&gt;</span><span class="n">RportName</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_portname</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_name</span><span class="p">));</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fp</span><span class="o">-&gt;</span><span class="n">RnodeName</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_nodename</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_name</span><span class="p">));</span>
	<span class="n">ondlp</span> <span class="o">=</span> <span class="n">lpfc_findnode_did</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">nportid</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ondlp</span> <span class="o">&amp;&amp;</span> <span class="n">NLP_CHK_NODE_ACT</span><span class="p">(</span><span class="n">ondlp</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fp</span><span class="o">-&gt;</span><span class="n">OportName</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ondlp</span><span class="o">-&gt;</span><span class="n">nlp_portname</span><span class="p">,</span>
		       <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_name</span><span class="p">));</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fp</span><span class="o">-&gt;</span><span class="n">OnodeName</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ondlp</span><span class="o">-&gt;</span><span class="n">nlp_nodename</span><span class="p">,</span>
		       <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_name</span><span class="p">));</span>
	<span class="p">}</span>

	<span class="n">lpfc_debugfs_disc_trc</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">LPFC_DISC_TRC_ELS_CMD</span><span class="p">,</span>
		<span class="s">&quot;Issue FARPR:     did:x%x&quot;</span><span class="p">,</span>
		<span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_DID</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">fc_stat</span><span class="p">.</span><span class="n">elsXmitFARPR</span><span class="o">++</span><span class="p">;</span>
	<span class="n">elsiocb</span><span class="o">-&gt;</span><span class="n">iocb_cmpl</span> <span class="o">=</span> <span class="n">lpfc_cmpl_els_cmd</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">lpfc_sli_issue_iocb</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">LPFC_ELS_RING</span><span class="p">,</span> <span class="n">elsiocb</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">==</span>
	    <span class="n">IOCB_ERROR</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* The additional lpfc_nlp_put will cause the following</span>
<span class="cm">		 * lpfc_els_free_iocb routine to trigger the release of</span>
<span class="cm">		 * the node.</span>
<span class="cm">		 */</span>
		<span class="n">lpfc_nlp_put</span><span class="p">(</span><span class="n">ndlp</span><span class="p">);</span>
		<span class="n">lpfc_els_free_iocb</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">elsiocb</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* This will cause the callback-function lpfc_cmpl_els_cmd to</span>
<span class="cm">	 * trigger the release of the node.</span>
<span class="cm">	 */</span>
	<span class="n">lpfc_nlp_put</span><span class="p">(</span><span class="n">ndlp</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_cancel_retry_delay_tmo - Cancel the timer with delayed iocb-cmd retry</span>
<span class="cm"> * @vport: pointer to a host virtual N_Port data structure.</span>
<span class="cm"> * @nlp: pointer to a node-list data structure.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine cancels the timer with a delayed IOCB-command retry for</span>
<span class="cm"> * a @vport&#39;s @ndlp. It stops the timer for the delayed function retrial and</span>
<span class="cm"> * removes the ELS retry event if it presents. In addition, if the</span>
<span class="cm"> * NLP_NPR_2B_DISC bit is set in the @nlp&#39;s nlp_flag bitmap, ADISC IOCB</span>
<span class="cm"> * commands are sent for the @vport&#39;s nodes that require issuing discovery</span>
<span class="cm"> * ADISC.</span>
<span class="cm"> **/</span>
<span class="kt">void</span>
<span class="nf">lpfc_cancel_retry_delay_tmo</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="n">vport</span><span class="p">,</span> <span class="k">struct</span> <span class="n">lpfc_nodelist</span> <span class="o">*</span><span class="n">nlp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span> <span class="o">=</span> <span class="n">lpfc_shost_from_vport</span><span class="p">(</span><span class="n">vport</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">lpfc_work_evt</span> <span class="o">*</span><span class="n">evtp</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">nlp</span><span class="o">-&gt;</span><span class="n">nlp_flag</span> <span class="o">&amp;</span> <span class="n">NLP_DELAY_TMO</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>
	<span class="n">nlp</span><span class="o">-&gt;</span><span class="n">nlp_flag</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">NLP_DELAY_TMO</span><span class="p">;</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>
	<span class="n">del_timer_sync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nlp</span><span class="o">-&gt;</span><span class="n">nlp_delayfunc</span><span class="p">);</span>
	<span class="n">nlp</span><span class="o">-&gt;</span><span class="n">nlp_last_elscmd</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nlp</span><span class="o">-&gt;</span><span class="n">els_retry_evt</span><span class="p">.</span><span class="n">evt_listp</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nlp</span><span class="o">-&gt;</span><span class="n">els_retry_evt</span><span class="p">.</span><span class="n">evt_listp</span><span class="p">);</span>
		<span class="cm">/* Decrement nlp reference count held for the delayed retry */</span>
		<span class="n">evtp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">nlp</span><span class="o">-&gt;</span><span class="n">els_retry_evt</span><span class="p">;</span>
		<span class="n">lpfc_nlp_put</span><span class="p">((</span><span class="k">struct</span> <span class="n">lpfc_nodelist</span> <span class="o">*</span><span class="p">)</span><span class="n">evtp</span><span class="o">-&gt;</span><span class="n">evt_arg1</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nlp</span><span class="o">-&gt;</span><span class="n">nlp_flag</span> <span class="o">&amp;</span> <span class="n">NLP_NPR_2B_DISC</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_lock_irq</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>
		<span class="n">nlp</span><span class="o">-&gt;</span><span class="n">nlp_flag</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">NLP_NPR_2B_DISC</span><span class="p">;</span>
		<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">num_disc_nodes</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">port_state</span> <span class="o">&lt;</span> <span class="n">LPFC_VPORT_READY</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/* Check if there are more ADISCs to be sent */</span>
				<span class="n">lpfc_more_adisc</span><span class="p">(</span><span class="n">vport</span><span class="p">);</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="cm">/* Check if there are more PLOGIs to be sent */</span>
				<span class="n">lpfc_more_plogi</span><span class="p">(</span><span class="n">vport</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">num_disc_nodes</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">spin_lock_irq</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>
					<span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_flag</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">FC_NDISC_ACTIVE</span><span class="p">;</span>
					<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>
					<span class="n">lpfc_can_disctmo</span><span class="p">(</span><span class="n">vport</span><span class="p">);</span>
					<span class="n">lpfc_end_rscn</span><span class="p">(</span><span class="n">vport</span><span class="p">);</span>
				<span class="p">}</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_els_retry_delay - Timer function with a ndlp delayed function timer</span>
<span class="cm"> * @ptr: holder for the pointer to the timer function associated data (ndlp).</span>
<span class="cm"> *</span>
<span class="cm"> * This routine is invoked by the ndlp delayed-function timer to check</span>
<span class="cm"> * whether there is any pending ELS retry event(s) with the node. If not, it</span>
<span class="cm"> * simply returns. Otherwise, if there is at least one ELS delayed event, it</span>
<span class="cm"> * adds the delayed events to the HBA work list and invokes the</span>
<span class="cm"> * lpfc_worker_wake_up() routine to wake up worker thread to process the</span>
<span class="cm"> * event. Note that lpfc_nlp_get() is called before posting the event to</span>
<span class="cm"> * the work list to hold reference count of ndlp so that it guarantees the</span>
<span class="cm"> * reference to ndlp will still be available when the worker thread gets</span>
<span class="cm"> * to the event associated with the ndlp.</span>
<span class="cm"> **/</span>
<span class="kt">void</span>
<span class="nf">lpfc_els_retry_delay</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ptr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpfc_nodelist</span> <span class="o">*</span><span class="n">ndlp</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_nodelist</span> <span class="o">*</span><span class="p">)</span> <span class="n">ptr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="n">vport</span> <span class="o">=</span> <span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">vport</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_hba</span>   <span class="o">*</span><span class="n">phba</span> <span class="o">=</span> <span class="n">vport</span><span class="o">-&gt;</span><span class="n">phba</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_work_evt</span>  <span class="o">*</span><span class="n">evtp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">els_retry_evt</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">evtp</span><span class="o">-&gt;</span><span class="n">evt_listp</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* We need to hold the node by incrementing the reference</span>
<span class="cm">	 * count until the queued work is done</span>
<span class="cm">	 */</span>
	<span class="n">evtp</span><span class="o">-&gt;</span><span class="n">evt_arg1</span>  <span class="o">=</span> <span class="n">lpfc_nlp_get</span><span class="p">(</span><span class="n">ndlp</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">evtp</span><span class="o">-&gt;</span><span class="n">evt_arg1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">evtp</span><span class="o">-&gt;</span><span class="n">evt</span> <span class="o">=</span> <span class="n">LPFC_EVT_ELS_RETRY</span><span class="p">;</span>
		<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">evtp</span><span class="o">-&gt;</span><span class="n">evt_listp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">work_list</span><span class="p">);</span>
		<span class="n">lpfc_worker_wake_up</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_els_retry_delay_handler - Work thread handler for ndlp delayed function</span>
<span class="cm"> * @ndlp: pointer to a node-list data structure.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine is the worker-thread handler for processing the @ndlp delayed</span>
<span class="cm"> * event(s), posted by the lpfc_els_retry_delay() routine. It simply retrieves</span>
<span class="cm"> * the last ELS command from the associated ndlp and invokes the proper ELS</span>
<span class="cm"> * function according to the delayed ELS command to retry the command.</span>
<span class="cm"> **/</span>
<span class="kt">void</span>
<span class="nf">lpfc_els_retry_delay_handler</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_nodelist</span> <span class="o">*</span><span class="n">ndlp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="n">vport</span> <span class="o">=</span> <span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">vport</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span>  <span class="o">*</span><span class="n">shost</span> <span class="o">=</span> <span class="n">lpfc_shost_from_vport</span><span class="p">(</span><span class="n">vport</span><span class="p">);</span>
	<span class="kt">uint32_t</span> <span class="n">cmd</span><span class="p">,</span> <span class="n">did</span><span class="p">,</span> <span class="n">retry</span><span class="p">;</span>

	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>
	<span class="n">did</span> <span class="o">=</span> <span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_DID</span><span class="p">;</span>
	<span class="n">cmd</span> <span class="o">=</span> <span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_last_elscmd</span><span class="p">;</span>
	<span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_last_elscmd</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_flag</span> <span class="o">&amp;</span> <span class="n">NLP_DELAY_TMO</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_flag</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">NLP_DELAY_TMO</span><span class="p">;</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * If a discovery event readded nlp_delayfunc after timer</span>
<span class="cm">	 * firing and before processing the timer, cancel the</span>
<span class="cm">	 * nlp_delayfunc.</span>
<span class="cm">	 */</span>
	<span class="n">del_timer_sync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_delayfunc</span><span class="p">);</span>
	<span class="n">retry</span> <span class="o">=</span> <span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_retry</span><span class="p">;</span>
	<span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_retry</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">cmd</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">ELS_CMD_FLOGI</span>:
		<span class="n">lpfc_issue_els_flogi</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">ndlp</span><span class="p">,</span> <span class="n">retry</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">ELS_CMD_PLOGI</span>:
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">lpfc_issue_els_plogi</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_DID</span><span class="p">,</span> <span class="n">retry</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_prev_state</span> <span class="o">=</span> <span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_state</span><span class="p">;</span>
			<span class="n">lpfc_nlp_set_state</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">ndlp</span><span class="p">,</span> <span class="n">NLP_STE_PLOGI_ISSUE</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">ELS_CMD_ADISC</span>:
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">lpfc_issue_els_adisc</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">ndlp</span><span class="p">,</span> <span class="n">retry</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_prev_state</span> <span class="o">=</span> <span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_state</span><span class="p">;</span>
			<span class="n">lpfc_nlp_set_state</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">ndlp</span><span class="p">,</span> <span class="n">NLP_STE_ADISC_ISSUE</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">ELS_CMD_PRLI</span>:
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">lpfc_issue_els_prli</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">ndlp</span><span class="p">,</span> <span class="n">retry</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_prev_state</span> <span class="o">=</span> <span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_state</span><span class="p">;</span>
			<span class="n">lpfc_nlp_set_state</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">ndlp</span><span class="p">,</span> <span class="n">NLP_STE_PRLI_ISSUE</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">ELS_CMD_LOGO</span>:
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">lpfc_issue_els_logo</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">ndlp</span><span class="p">,</span> <span class="n">retry</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_prev_state</span> <span class="o">=</span> <span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_state</span><span class="p">;</span>
			<span class="n">lpfc_nlp_set_state</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">ndlp</span><span class="p">,</span> <span class="n">NLP_STE_NPR_NODE</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">ELS_CMD_FDISC</span>:
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_flag</span> <span class="o">&amp;</span> <span class="n">FC_VPORT_NEEDS_INIT_VPI</span><span class="p">))</span>
			<span class="n">lpfc_issue_els_fdisc</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">ndlp</span><span class="p">,</span> <span class="n">retry</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_els_retry - Make retry decision on an els command iocb</span>
<span class="cm"> * @phba: pointer to lpfc hba data structure.</span>
<span class="cm"> * @cmdiocb: pointer to lpfc command iocb data structure.</span>
<span class="cm"> * @rspiocb: pointer to lpfc response iocb data structure.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine makes a retry decision on an ELS command IOCB, which has</span>
<span class="cm"> * failed. The following ELS IOCBs use this function for retrying the command</span>
<span class="cm"> * when previously issued command responsed with error status: FLOGI, PLOGI,</span>
<span class="cm"> * PRLI, ADISC, LOGO, and FDISC. Based on the ELS command type and the</span>
<span class="cm"> * returned error status, it makes the decision whether a retry shall be</span>
<span class="cm"> * issued for the command, and whether a retry shall be made immediately or</span>
<span class="cm"> * delayed. In the former case, the corresponding ELS command issuing-function</span>
<span class="cm"> * is called to retry the command. In the later case, the ELS command shall</span>
<span class="cm"> * be posted to the ndlp delayed event and delayed function timer set to the</span>
<span class="cm"> * ndlp for the delayed command issusing.</span>
<span class="cm"> *</span>
<span class="cm"> * Return code</span>
<span class="cm"> *   0 - No retry of els command is made</span>
<span class="cm"> *   1 - Immediate or delayed retry of els command is made</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">lpfc_els_retry</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">,</span> <span class="k">struct</span> <span class="n">lpfc_iocbq</span> <span class="o">*</span><span class="n">cmdiocb</span><span class="p">,</span>
	       <span class="k">struct</span> <span class="n">lpfc_iocbq</span> <span class="o">*</span><span class="n">rspiocb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="n">vport</span> <span class="o">=</span> <span class="n">cmdiocb</span><span class="o">-&gt;</span><span class="n">vport</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span>  <span class="o">*</span><span class="n">shost</span> <span class="o">=</span> <span class="n">lpfc_shost_from_vport</span><span class="p">(</span><span class="n">vport</span><span class="p">);</span>
	<span class="n">IOCB_t</span> <span class="o">*</span><span class="n">irsp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">rspiocb</span><span class="o">-&gt;</span><span class="n">iocb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_nodelist</span> <span class="o">*</span><span class="n">ndlp</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_nodelist</span> <span class="o">*</span><span class="p">)</span> <span class="n">cmdiocb</span><span class="o">-&gt;</span><span class="n">context1</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_dmabuf</span> <span class="o">*</span><span class="n">pcmd</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_dmabuf</span> <span class="o">*</span><span class="p">)</span> <span class="n">cmdiocb</span><span class="o">-&gt;</span><span class="n">context2</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="o">*</span><span class="n">elscmd</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ls_rjt</span> <span class="n">stat</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">retry</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">maxretry</span> <span class="o">=</span> <span class="n">lpfc_max_els_tries</span><span class="p">,</span> <span class="n">delay</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">logerr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">cmd</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">did</span><span class="p">;</span>


	<span class="cm">/* Note: context2 may be 0 for internal driver abort</span>
<span class="cm">	 * of delays ELS command.</span>
<span class="cm">	 */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pcmd</span> <span class="o">&amp;&amp;</span> <span class="n">pcmd</span><span class="o">-&gt;</span><span class="n">virt</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">elscmd</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint32_t</span> <span class="o">*</span><span class="p">)</span> <span class="p">(</span><span class="n">pcmd</span><span class="o">-&gt;</span><span class="n">virt</span><span class="p">);</span>
		<span class="n">cmd</span> <span class="o">=</span> <span class="o">*</span><span class="n">elscmd</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ndlp</span> <span class="o">&amp;&amp;</span> <span class="n">NLP_CHK_NODE_ACT</span><span class="p">(</span><span class="n">ndlp</span><span class="p">))</span>
		<span class="n">did</span> <span class="o">=</span> <span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_DID</span><span class="p">;</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* We should only hit this case for retrying PLOGI */</span>
		<span class="n">did</span> <span class="o">=</span> <span class="n">irsp</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">elsreq64</span><span class="p">.</span><span class="n">remoteID</span><span class="p">;</span>
		<span class="n">ndlp</span> <span class="o">=</span> <span class="n">lpfc_findnode_did</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">did</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">((</span><span class="o">!</span><span class="n">ndlp</span> <span class="o">||</span> <span class="o">!</span><span class="n">NLP_CHK_NODE_ACT</span><span class="p">(</span><span class="n">ndlp</span><span class="p">))</span>
		    <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">cmd</span> <span class="o">!=</span> <span class="n">ELS_CMD_PLOGI</span><span class="p">))</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">lpfc_debugfs_disc_trc</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">LPFC_DISC_TRC_ELS_CMD</span><span class="p">,</span>
		<span class="s">&quot;Retry ELS:       wd7:x%x wd4:x%x did:x%x&quot;</span><span class="p">,</span>
		<span class="o">*</span><span class="p">(((</span><span class="kt">uint32_t</span> <span class="o">*</span><span class="p">)</span> <span class="n">irsp</span><span class="p">)</span> <span class="o">+</span> <span class="mi">7</span><span class="p">),</span> <span class="n">irsp</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">ulpWord</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span> <span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_DID</span><span class="p">);</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">irsp</span><span class="o">-&gt;</span><span class="n">ulpStatus</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">IOSTAT_FCP_RSP_ERROR</span>:
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">IOSTAT_REMOTE_STOP</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli_rev</span> <span class="o">==</span> <span class="n">LPFC_SLI_REV4</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* This IO was aborted by the target, we don&#39;t</span>
<span class="cm">			 * know the rxid and because we did not send the</span>
<span class="cm">			 * ABTS we cannot generate and RRQ.</span>
<span class="cm">			 */</span>
			<span class="n">lpfc_set_rrq_active</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">ndlp</span><span class="p">,</span>
					 <span class="n">cmdiocb</span><span class="o">-&gt;</span><span class="n">sli4_lxritag</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">IOSTAT_LOCAL_REJECT</span>:
		<span class="k">switch</span> <span class="p">((</span><span class="n">irsp</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">ulpWord</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">IOERR_LOOP_OPEN_FAILURE</span>:
			<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span> <span class="o">==</span> <span class="n">ELS_CMD_FLOGI</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">PCI_DEVICE_ID_HORNET</span> <span class="o">==</span>
					<span class="n">phba</span><span class="o">-&gt;</span><span class="n">pcidev</span><span class="o">-&gt;</span><span class="n">device</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">phba</span><span class="o">-&gt;</span><span class="n">fc_topology</span> <span class="o">=</span> <span class="n">LPFC_TOPOLOGY_LOOP</span><span class="p">;</span>
					<span class="n">phba</span><span class="o">-&gt;</span><span class="n">pport</span><span class="o">-&gt;</span><span class="n">fc_myDID</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
					<span class="n">phba</span><span class="o">-&gt;</span><span class="n">alpa_map</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
					<span class="n">phba</span><span class="o">-&gt;</span><span class="n">alpa_map</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
				<span class="p">}</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span> <span class="o">==</span> <span class="n">ELS_CMD_PLOGI</span> <span class="o">&amp;&amp;</span> <span class="n">cmdiocb</span><span class="o">-&gt;</span><span class="n">retry</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
				<span class="n">delay</span> <span class="o">=</span> <span class="mi">1000</span><span class="p">;</span>
			<span class="n">retry</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">IOERR_ILLEGAL_COMMAND</span>:
			<span class="n">lpfc_printf_vlog</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_ELS</span><span class="p">,</span>
					 <span class="s">&quot;0124 Retry illegal cmd x%x &quot;</span>
					 <span class="s">&quot;retry:x%x delay:x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					 <span class="n">cmd</span><span class="p">,</span> <span class="n">cmdiocb</span><span class="o">-&gt;</span><span class="n">retry</span><span class="p">,</span> <span class="n">delay</span><span class="p">);</span>
			<span class="n">retry</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="cm">/* All command&#39;s retry policy */</span>
			<span class="n">maxretry</span> <span class="o">=</span> <span class="mi">8</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">cmdiocb</span><span class="o">-&gt;</span><span class="n">retry</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">)</span>
				<span class="n">delay</span> <span class="o">=</span> <span class="mi">1000</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">IOERR_NO_RESOURCES</span>:
			<span class="n">logerr</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="cm">/* HBA out of resources */</span>
			<span class="n">retry</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">cmdiocb</span><span class="o">-&gt;</span><span class="n">retry</span> <span class="o">&gt;</span> <span class="mi">100</span><span class="p">)</span>
				<span class="n">delay</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>
			<span class="n">maxretry</span> <span class="o">=</span> <span class="mi">250</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">IOERR_ILLEGAL_FRAME</span>:
			<span class="n">delay</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>
			<span class="n">retry</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">IOERR_SEQUENCE_TIMEOUT</span>:
		<span class="k">case</span> <span class="n">IOERR_INVALID_RPI</span>:
			<span class="n">retry</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">IOSTAT_NPORT_RJT</span>:
	<span class="k">case</span> <span class="n">IOSTAT_FABRIC_RJT</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">irsp</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">ulpWord</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">RJT_UNAVAIL_TEMP</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">retry</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">IOSTAT_NPORT_BSY</span>:
	<span class="k">case</span> <span class="n">IOSTAT_FABRIC_BSY</span>:
		<span class="n">logerr</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="cm">/* Fabric / Remote NPort out of resources */</span>
		<span class="n">retry</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">IOSTAT_LS_RJT</span>:
		<span class="n">stat</span><span class="p">.</span><span class="n">un</span><span class="p">.</span><span class="n">lsRjtError</span> <span class="o">=</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">irsp</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">ulpWord</span><span class="p">[</span><span class="mi">4</span><span class="p">]);</span>
		<span class="cm">/* Added for Vendor specifc support</span>
<span class="cm">		 * Just keep retrying for these Rsn / Exp codes</span>
<span class="cm">		 */</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">stat</span><span class="p">.</span><span class="n">un</span><span class="p">.</span><span class="n">b</span><span class="p">.</span><span class="n">lsRjtRsnCode</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">LSRJT_UNABLE_TPC</span>:
			<span class="k">if</span> <span class="p">(</span><span class="n">stat</span><span class="p">.</span><span class="n">un</span><span class="p">.</span><span class="n">b</span><span class="p">.</span><span class="n">lsRjtRsnCodeExp</span> <span class="o">==</span>
			    <span class="n">LSEXP_CMD_IN_PROGRESS</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span> <span class="o">==</span> <span class="n">ELS_CMD_PLOGI</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">delay</span> <span class="o">=</span> <span class="mi">1000</span><span class="p">;</span>
					<span class="n">maxretry</span> <span class="o">=</span> <span class="mi">48</span><span class="p">;</span>
				<span class="p">}</span>
				<span class="n">retry</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">stat</span><span class="p">.</span><span class="n">un</span><span class="p">.</span><span class="n">b</span><span class="p">.</span><span class="n">lsRjtRsnCodeExp</span> <span class="o">==</span>
			    <span class="n">LSEXP_CANT_GIVE_DATA</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span> <span class="o">==</span> <span class="n">ELS_CMD_PLOGI</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">delay</span> <span class="o">=</span> <span class="mi">1000</span><span class="p">;</span>
					<span class="n">maxretry</span> <span class="o">=</span> <span class="mi">48</span><span class="p">;</span>
				<span class="p">}</span>
				<span class="n">retry</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span> <span class="o">==</span> <span class="n">ELS_CMD_PLOGI</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">delay</span> <span class="o">=</span> <span class="mi">1000</span><span class="p">;</span>
				<span class="n">maxretry</span> <span class="o">=</span> <span class="n">lpfc_max_els_tries</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
				<span class="n">retry</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli3_options</span> <span class="o">&amp;</span> <span class="n">LPFC_SLI3_NPIV_ENABLED</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			  <span class="p">(</span><span class="n">cmd</span> <span class="o">==</span> <span class="n">ELS_CMD_FDISC</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			  <span class="p">(</span><span class="n">stat</span><span class="p">.</span><span class="n">un</span><span class="p">.</span><span class="n">b</span><span class="p">.</span><span class="n">lsRjtRsnCodeExp</span> <span class="o">==</span> <span class="n">LSEXP_OUT_OF_RESOURCE</span><span class="p">)){</span>
				<span class="n">lpfc_printf_vlog</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_ELS</span><span class="p">,</span>
						 <span class="s">&quot;0125 FDISC Failed (x%x). &quot;</span>
						 <span class="s">&quot;Fabric out of resources</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
						 <span class="n">stat</span><span class="p">.</span><span class="n">un</span><span class="p">.</span><span class="n">lsRjtError</span><span class="p">);</span>
				<span class="n">lpfc_vport_set_state</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span>
						     <span class="n">FC_VPORT_NO_FABRIC_RSCS</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">LSRJT_LOGICAL_BSY</span>:
			<span class="k">if</span> <span class="p">((</span><span class="n">cmd</span> <span class="o">==</span> <span class="n">ELS_CMD_PLOGI</span><span class="p">)</span> <span class="o">||</span>
			    <span class="p">(</span><span class="n">cmd</span> <span class="o">==</span> <span class="n">ELS_CMD_PRLI</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">delay</span> <span class="o">=</span> <span class="mi">1000</span><span class="p">;</span>
				<span class="n">maxretry</span> <span class="o">=</span> <span class="mi">48</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">cmd</span> <span class="o">==</span> <span class="n">ELS_CMD_FDISC</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/* FDISC retry policy */</span>
				<span class="n">maxretry</span> <span class="o">=</span> <span class="mi">48</span><span class="p">;</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">cmdiocb</span><span class="o">-&gt;</span><span class="n">retry</span> <span class="o">&gt;=</span> <span class="mi">32</span><span class="p">)</span>
					<span class="n">delay</span> <span class="o">=</span> <span class="mi">1000</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">retry</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">LSRJT_LOGICAL_ERR</span>:
			<span class="cm">/* There are some cases where switches return this</span>
<span class="cm">			 * error when they are not ready and should be returning</span>
<span class="cm">			 * Logical Busy. We should delay every time.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span> <span class="o">==</span> <span class="n">ELS_CMD_FDISC</span> <span class="o">&amp;&amp;</span>
			    <span class="n">stat</span><span class="p">.</span><span class="n">un</span><span class="p">.</span><span class="n">b</span><span class="p">.</span><span class="n">lsRjtRsnCodeExp</span> <span class="o">==</span> <span class="n">LSEXP_PORT_LOGIN_REQ</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">maxretry</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
				<span class="n">delay</span> <span class="o">=</span> <span class="mi">1000</span><span class="p">;</span>
				<span class="n">retry</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="k">case</span> <span class="n">LSRJT_PROTOCOL_ERR</span>:
			<span class="k">if</span> <span class="p">((</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli3_options</span> <span class="o">&amp;</span> <span class="n">LPFC_SLI3_NPIV_ENABLED</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			  <span class="p">(</span><span class="n">cmd</span> <span class="o">==</span> <span class="n">ELS_CMD_FDISC</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			  <span class="p">((</span><span class="n">stat</span><span class="p">.</span><span class="n">un</span><span class="p">.</span><span class="n">b</span><span class="p">.</span><span class="n">lsRjtRsnCodeExp</span> <span class="o">==</span> <span class="n">LSEXP_INVALID_PNAME</span><span class="p">)</span> <span class="o">||</span>
			  <span class="p">(</span><span class="n">stat</span><span class="p">.</span><span class="n">un</span><span class="p">.</span><span class="n">b</span><span class="p">.</span><span class="n">lsRjtRsnCodeExp</span> <span class="o">==</span> <span class="n">LSEXP_INVALID_NPORT_ID</span><span class="p">))</span>
			  <span class="p">)</span> <span class="p">{</span>
				<span class="n">lpfc_printf_vlog</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_ELS</span><span class="p">,</span>
						 <span class="s">&quot;0122 FDISC Failed (x%x). &quot;</span>
						 <span class="s">&quot;Fabric Detected Bad WWN</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
						 <span class="n">stat</span><span class="p">.</span><span class="n">un</span><span class="p">.</span><span class="n">lsRjtError</span><span class="p">);</span>
				<span class="n">lpfc_vport_set_state</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span>
						     <span class="n">FC_VPORT_FABRIC_REJ_WWN</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">IOSTAT_INTERMED_RSP</span>:
	<span class="k">case</span> <span class="n">IOSTAT_BA_RJT</span>:
		<span class="k">break</span><span class="p">;</span>

	<span class="nl">default:</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">did</span> <span class="o">==</span> <span class="n">FDMI_DID</span><span class="p">)</span>
		<span class="n">retry</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">cmd</span> <span class="o">==</span> <span class="n">ELS_CMD_FLOGI</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">fc_topology</span> <span class="o">!=</span> <span class="n">LPFC_TOPOLOGY_LOOP</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="o">!</span><span class="n">lpfc_error_lost_link</span><span class="p">(</span><span class="n">irsp</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* FLOGI retry policy */</span>
		<span class="n">retry</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="cm">/* retry FLOGI forever */</span>
		<span class="n">maxretry</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cmdiocb</span><span class="o">-&gt;</span><span class="n">retry</span> <span class="o">&gt;=</span> <span class="mi">100</span><span class="p">)</span>
			<span class="n">delay</span> <span class="o">=</span> <span class="mi">5000</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">cmdiocb</span><span class="o">-&gt;</span><span class="n">retry</span> <span class="o">&gt;=</span> <span class="mi">32</span><span class="p">)</span>
			<span class="n">delay</span> <span class="o">=</span> <span class="mi">1000</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">cmd</span> <span class="o">==</span> <span class="n">ELS_CMD_FDISC</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">lpfc_error_lost_link</span><span class="p">(</span><span class="n">irsp</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* retry FDISCs every second up to devloss */</span>
		<span class="n">retry</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">maxretry</span> <span class="o">=</span> <span class="n">vport</span><span class="o">-&gt;</span><span class="n">cfg_devloss_tmo</span><span class="p">;</span>
		<span class="n">delay</span> <span class="o">=</span> <span class="mi">1000</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">cmdiocb</span><span class="o">-&gt;</span><span class="n">retry</span><span class="o">++</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">maxretry</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">cmdiocb</span><span class="o">-&gt;</span><span class="n">retry</span> <span class="o">&gt;=</span> <span class="n">maxretry</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">fc_stat</span><span class="p">.</span><span class="n">elsRetryExceeded</span><span class="o">++</span><span class="p">;</span>
		<span class="n">retry</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">load_flag</span> <span class="o">&amp;</span> <span class="n">FC_UNLOADING</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">retry</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">retry</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">cmd</span> <span class="o">==</span> <span class="n">ELS_CMD_PLOGI</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">cmd</span> <span class="o">==</span> <span class="n">ELS_CMD_FDISC</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/* Stop retrying PLOGI and FDISC if in FCF discovery */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">fcf</span><span class="p">.</span><span class="n">fcf_flag</span> <span class="o">&amp;</span> <span class="n">FCF_DISCOVERY</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">lpfc_printf_vlog</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">KERN_INFO</span><span class="p">,</span> <span class="n">LOG_ELS</span><span class="p">,</span>
						 <span class="s">&quot;2849 Stop retry ELS command &quot;</span>
						 <span class="s">&quot;x%x to remote NPORT x%x, &quot;</span>
						 <span class="s">&quot;Data: x%x x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">cmd</span><span class="p">,</span> <span class="n">did</span><span class="p">,</span>
						 <span class="n">cmdiocb</span><span class="o">-&gt;</span><span class="n">retry</span><span class="p">,</span> <span class="n">delay</span><span class="p">);</span>
				<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="cm">/* Retry ELS command &lt;elsCmd&gt; to remote NPORT &lt;did&gt; */</span>
		<span class="n">lpfc_printf_vlog</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">KERN_INFO</span><span class="p">,</span> <span class="n">LOG_ELS</span><span class="p">,</span>
				 <span class="s">&quot;0107 Retry ELS command x%x to remote &quot;</span>
				 <span class="s">&quot;NPORT x%x Data: x%x x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				 <span class="n">cmd</span><span class="p">,</span> <span class="n">did</span><span class="p">,</span> <span class="n">cmdiocb</span><span class="o">-&gt;</span><span class="n">retry</span><span class="p">,</span> <span class="n">delay</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(((</span><span class="n">cmd</span> <span class="o">==</span> <span class="n">ELS_CMD_PLOGI</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">cmd</span> <span class="o">==</span> <span class="n">ELS_CMD_ADISC</span><span class="p">))</span> <span class="o">&amp;&amp;</span>
			<span class="p">((</span><span class="n">irsp</span><span class="o">-&gt;</span><span class="n">ulpStatus</span> <span class="o">!=</span> <span class="n">IOSTAT_LOCAL_REJECT</span><span class="p">)</span> <span class="o">||</span>
			<span class="p">((</span><span class="n">irsp</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">ulpWord</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">)</span> <span class="o">!=</span> <span class="n">IOERR_NO_RESOURCES</span><span class="p">)))</span> <span class="p">{</span>
			<span class="cm">/* Don&#39;t reset timer for no resources */</span>

			<span class="cm">/* If discovery / RSCN timer is running, reset it */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">timer_pending</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_disctmo</span><span class="p">)</span> <span class="o">||</span>
			    <span class="p">(</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_flag</span> <span class="o">&amp;</span> <span class="n">FC_RSCN_MODE</span><span class="p">))</span>
				<span class="n">lpfc_set_disctmo</span><span class="p">(</span><span class="n">vport</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">fc_stat</span><span class="p">.</span><span class="n">elsXmitRetry</span><span class="o">++</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ndlp</span> <span class="o">&amp;&amp;</span> <span class="n">NLP_CHK_NODE_ACT</span><span class="p">(</span><span class="n">ndlp</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">delay</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">phba</span><span class="o">-&gt;</span><span class="n">fc_stat</span><span class="p">.</span><span class="n">elsDelayRetry</span><span class="o">++</span><span class="p">;</span>
			<span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_retry</span> <span class="o">=</span> <span class="n">cmdiocb</span><span class="o">-&gt;</span><span class="n">retry</span><span class="p">;</span>

			<span class="cm">/* delay is specified in milliseconds */</span>
			<span class="n">mod_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_delayfunc</span><span class="p">,</span>
				<span class="n">jiffies</span> <span class="o">+</span> <span class="n">msecs_to_jiffies</span><span class="p">(</span><span class="n">delay</span><span class="p">));</span>
			<span class="n">spin_lock_irq</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>
			<span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_flag</span> <span class="o">|=</span> <span class="n">NLP_DELAY_TMO</span><span class="p">;</span>
			<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>

			<span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_prev_state</span> <span class="o">=</span> <span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_state</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span> <span class="o">==</span> <span class="n">ELS_CMD_PRLI</span><span class="p">)</span>
				<span class="n">lpfc_nlp_set_state</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">ndlp</span><span class="p">,</span>
					<span class="n">NLP_STE_REG_LOGIN_ISSUE</span><span class="p">);</span>
			<span class="k">else</span>
				<span class="n">lpfc_nlp_set_state</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">ndlp</span><span class="p">,</span>
					<span class="n">NLP_STE_NPR_NODE</span><span class="p">);</span>
			<span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_last_elscmd</span> <span class="o">=</span> <span class="n">cmd</span><span class="p">;</span>

			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">cmd</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">ELS_CMD_FLOGI</span>:
			<span class="n">lpfc_issue_els_flogi</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">ndlp</span><span class="p">,</span> <span class="n">cmdiocb</span><span class="o">-&gt;</span><span class="n">retry</span><span class="p">);</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">ELS_CMD_FDISC</span>:
			<span class="n">lpfc_issue_els_fdisc</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">ndlp</span><span class="p">,</span> <span class="n">cmdiocb</span><span class="o">-&gt;</span><span class="n">retry</span><span class="p">);</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">ELS_CMD_PLOGI</span>:
			<span class="k">if</span> <span class="p">(</span><span class="n">ndlp</span> <span class="o">&amp;&amp;</span> <span class="n">NLP_CHK_NODE_ACT</span><span class="p">(</span><span class="n">ndlp</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_prev_state</span> <span class="o">=</span> <span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_state</span><span class="p">;</span>
				<span class="n">lpfc_nlp_set_state</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">ndlp</span><span class="p">,</span>
						   <span class="n">NLP_STE_PLOGI_ISSUE</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="n">lpfc_issue_els_plogi</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">did</span><span class="p">,</span> <span class="n">cmdiocb</span><span class="o">-&gt;</span><span class="n">retry</span><span class="p">);</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">ELS_CMD_ADISC</span>:
			<span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_prev_state</span> <span class="o">=</span> <span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_state</span><span class="p">;</span>
			<span class="n">lpfc_nlp_set_state</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">ndlp</span><span class="p">,</span> <span class="n">NLP_STE_ADISC_ISSUE</span><span class="p">);</span>
			<span class="n">lpfc_issue_els_adisc</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">ndlp</span><span class="p">,</span> <span class="n">cmdiocb</span><span class="o">-&gt;</span><span class="n">retry</span><span class="p">);</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">ELS_CMD_PRLI</span>:
			<span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_prev_state</span> <span class="o">=</span> <span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_state</span><span class="p">;</span>
			<span class="n">lpfc_nlp_set_state</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">ndlp</span><span class="p">,</span> <span class="n">NLP_STE_PRLI_ISSUE</span><span class="p">);</span>
			<span class="n">lpfc_issue_els_prli</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">ndlp</span><span class="p">,</span> <span class="n">cmdiocb</span><span class="o">-&gt;</span><span class="n">retry</span><span class="p">);</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">ELS_CMD_LOGO</span>:
			<span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_prev_state</span> <span class="o">=</span> <span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_state</span><span class="p">;</span>
			<span class="n">lpfc_nlp_set_state</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">ndlp</span><span class="p">,</span> <span class="n">NLP_STE_NPR_NODE</span><span class="p">);</span>
			<span class="n">lpfc_issue_els_logo</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">ndlp</span><span class="p">,</span> <span class="n">cmdiocb</span><span class="o">-&gt;</span><span class="n">retry</span><span class="p">);</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="cm">/* No retry ELS command &lt;elsCmd&gt; to remote NPORT &lt;did&gt; */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">logerr</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lpfc_printf_vlog</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_ELS</span><span class="p">,</span>
			 <span class="s">&quot;0137 No retry ELS command x%x to remote &quot;</span>
			 <span class="s">&quot;NPORT x%x: Out of Resources: Error:x%x/%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			 <span class="n">cmd</span><span class="p">,</span> <span class="n">did</span><span class="p">,</span> <span class="n">irsp</span><span class="o">-&gt;</span><span class="n">ulpStatus</span><span class="p">,</span>
			 <span class="n">irsp</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">ulpWord</span><span class="p">[</span><span class="mi">4</span><span class="p">]);</span>
	<span class="p">}</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="n">lpfc_printf_vlog</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">KERN_INFO</span><span class="p">,</span> <span class="n">LOG_ELS</span><span class="p">,</span>
			 <span class="s">&quot;0108 No retry ELS command x%x to remote &quot;</span>
			 <span class="s">&quot;NPORT x%x Retried:%d Error:x%x/%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			 <span class="n">cmd</span><span class="p">,</span> <span class="n">did</span><span class="p">,</span> <span class="n">cmdiocb</span><span class="o">-&gt;</span><span class="n">retry</span><span class="p">,</span> <span class="n">irsp</span><span class="o">-&gt;</span><span class="n">ulpStatus</span><span class="p">,</span>
			 <span class="n">irsp</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">ulpWord</span><span class="p">[</span><span class="mi">4</span><span class="p">]);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_els_free_data - Free lpfc dma buffer and data structure with an iocb</span>
<span class="cm"> * @phba: pointer to lpfc hba data structure.</span>
<span class="cm"> * @buf_ptr1: pointer to the lpfc DMA buffer data structure.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine releases the lpfc DMA (Direct Memory Access) buffer(s)</span>
<span class="cm"> * associated with a command IOCB back to the lpfc DMA buffer pool. It first</span>
<span class="cm"> * checks to see whether there is a lpfc DMA buffer associated with the</span>
<span class="cm"> * response of the command IOCB. If so, it will be released before releasing</span>
<span class="cm"> * the lpfc DMA buffer associated with the IOCB itself.</span>
<span class="cm"> *</span>
<span class="cm"> * Return code</span>
<span class="cm"> *   0 - Successfully released lpfc DMA buffer (currently, always return 0)</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">lpfc_els_free_data</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">,</span> <span class="k">struct</span> <span class="n">lpfc_dmabuf</span> <span class="o">*</span><span class="n">buf_ptr1</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpfc_dmabuf</span> <span class="o">*</span><span class="n">buf_ptr</span><span class="p">;</span>

	<span class="cm">/* Free the response before processing the command. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buf_ptr1</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">list_remove_head</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buf_ptr1</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="n">buf_ptr</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">lpfc_dmabuf</span><span class="p">,</span>
				 <span class="n">list</span><span class="p">);</span>
		<span class="n">lpfc_mbuf_free</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">buf_ptr</span><span class="o">-&gt;</span><span class="n">virt</span><span class="p">,</span> <span class="n">buf_ptr</span><span class="o">-&gt;</span><span class="n">phys</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">buf_ptr</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">lpfc_mbuf_free</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">buf_ptr1</span><span class="o">-&gt;</span><span class="n">virt</span><span class="p">,</span> <span class="n">buf_ptr1</span><span class="o">-&gt;</span><span class="n">phys</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">buf_ptr1</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_els_free_bpl - Free lpfc dma buffer and data structure with bpl</span>
<span class="cm"> * @phba: pointer to lpfc hba data structure.</span>
<span class="cm"> * @buf_ptr: pointer to the lpfc dma buffer data structure.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine releases the lpfc Direct Memory Access (DMA) buffer</span>
<span class="cm"> * associated with a Buffer Pointer List (BPL) back to the lpfc DMA buffer</span>
<span class="cm"> * pool.</span>
<span class="cm"> *</span>
<span class="cm"> * Return code</span>
<span class="cm"> *   0 - Successfully released lpfc DMA buffer (currently, always return 0)</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">lpfc_els_free_bpl</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">,</span> <span class="k">struct</span> <span class="n">lpfc_dmabuf</span> <span class="o">*</span><span class="n">buf_ptr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">lpfc_mbuf_free</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">buf_ptr</span><span class="o">-&gt;</span><span class="n">virt</span><span class="p">,</span> <span class="n">buf_ptr</span><span class="o">-&gt;</span><span class="n">phys</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">buf_ptr</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_els_free_iocb - Free a command iocb and its associated resources</span>
<span class="cm"> * @phba: pointer to lpfc hba data structure.</span>
<span class="cm"> * @elsiocb: pointer to lpfc els command iocb data structure.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine frees a command IOCB and its associated resources. The</span>
<span class="cm"> * command IOCB data structure contains the reference to various associated</span>
<span class="cm"> * resources, these fields must be set to NULL if the associated reference</span>
<span class="cm"> * not present:</span>
<span class="cm"> *   context1 - reference to ndlp</span>
<span class="cm"> *   context2 - reference to cmd</span>
<span class="cm"> *   context2-&gt;next - reference to rsp</span>
<span class="cm"> *   context3 - reference to bpl</span>
<span class="cm"> *</span>
<span class="cm"> * It first properly decrements the reference count held on ndlp for the</span>
<span class="cm"> * IOCB completion callback function. If LPFC_DELAY_MEM_FREE flag is not</span>
<span class="cm"> * set, it invokes the lpfc_els_free_data() routine to release the Direct</span>
<span class="cm"> * Memory Access (DMA) buffers associated with the IOCB. Otherwise, it</span>
<span class="cm"> * adds the DMA buffer the @phba data structure for the delayed release.</span>
<span class="cm"> * If reference to the Buffer Pointer List (BPL) is present, the</span>
<span class="cm"> * lpfc_els_free_bpl() routine is invoked to release the DMA memory</span>
<span class="cm"> * associated with BPL. Finally, the lpfc_sli_release_iocbq() routine is</span>
<span class="cm"> * invoked to release the IOCB data structure back to @phba IOCBQ list.</span>
<span class="cm"> *</span>
<span class="cm"> * Return code</span>
<span class="cm"> *   0 - Success (currently, always return 0)</span>
<span class="cm"> **/</span>
<span class="kt">int</span>
<span class="nf">lpfc_els_free_iocb</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">,</span> <span class="k">struct</span> <span class="n">lpfc_iocbq</span> <span class="o">*</span><span class="n">elsiocb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpfc_dmabuf</span> <span class="o">*</span><span class="n">buf_ptr</span><span class="p">,</span> <span class="o">*</span><span class="n">buf_ptr1</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_nodelist</span> <span class="o">*</span><span class="n">ndlp</span><span class="p">;</span>

	<span class="n">ndlp</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_nodelist</span> <span class="o">*</span><span class="p">)</span><span class="n">elsiocb</span><span class="o">-&gt;</span><span class="n">context1</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ndlp</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_flag</span> <span class="o">&amp;</span> <span class="n">NLP_DEFER_RM</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">lpfc_nlp_put</span><span class="p">(</span><span class="n">ndlp</span><span class="p">);</span>

			<span class="cm">/* If the ndlp is not being used by another discovery</span>
<span class="cm">			 * thread, free it.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">lpfc_nlp_not_used</span><span class="p">(</span><span class="n">ndlp</span><span class="p">))</span> <span class="p">{</span>
				<span class="cm">/* If ndlp is being used by another discovery</span>
<span class="cm">				 * thread, just clear NLP_DEFER_RM</span>
<span class="cm">				 */</span>
				<span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_flag</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">NLP_DEFER_RM</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="k">else</span>
			<span class="n">lpfc_nlp_put</span><span class="p">(</span><span class="n">ndlp</span><span class="p">);</span>
		<span class="n">elsiocb</span><span class="o">-&gt;</span><span class="n">context1</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* context2  = cmd,  context2-&gt;next = rsp, context3 = bpl */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">elsiocb</span><span class="o">-&gt;</span><span class="n">context2</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">elsiocb</span><span class="o">-&gt;</span><span class="n">iocb_flag</span> <span class="o">&amp;</span> <span class="n">LPFC_DELAY_MEM_FREE</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Firmware could still be in progress of DMAing</span>
<span class="cm">			 * payload, so don&#39;t free data buffer till after</span>
<span class="cm">			 * a hbeat.</span>
<span class="cm">			 */</span>
			<span class="n">elsiocb</span><span class="o">-&gt;</span><span class="n">iocb_flag</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">LPFC_DELAY_MEM_FREE</span><span class="p">;</span>
			<span class="n">buf_ptr</span> <span class="o">=</span> <span class="n">elsiocb</span><span class="o">-&gt;</span><span class="n">context2</span><span class="p">;</span>
			<span class="n">elsiocb</span><span class="o">-&gt;</span><span class="n">context2</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">buf_ptr</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">buf_ptr1</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
				<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buf_ptr</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">))</span> <span class="p">{</span>
					<span class="n">list_remove_head</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buf_ptr</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span>
						<span class="n">buf_ptr1</span><span class="p">,</span> <span class="k">struct</span> <span class="n">lpfc_dmabuf</span><span class="p">,</span>
						<span class="n">list</span><span class="p">);</span>
					<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buf_ptr1</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
					<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buf_ptr1</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span>
						<span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">elsbuf</span><span class="p">);</span>
					<span class="n">phba</span><span class="o">-&gt;</span><span class="n">elsbuf_cnt</span><span class="o">++</span><span class="p">;</span>
				<span class="p">}</span>
				<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buf_ptr</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
				<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buf_ptr</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">elsbuf</span><span class="p">);</span>
				<span class="n">phba</span><span class="o">-&gt;</span><span class="n">elsbuf_cnt</span><span class="o">++</span><span class="p">;</span>
				<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">buf_ptr1</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_dmabuf</span> <span class="o">*</span><span class="p">)</span> <span class="n">elsiocb</span><span class="o">-&gt;</span><span class="n">context2</span><span class="p">;</span>
			<span class="n">lpfc_els_free_data</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">buf_ptr1</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">elsiocb</span><span class="o">-&gt;</span><span class="n">context3</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">buf_ptr</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_dmabuf</span> <span class="o">*</span><span class="p">)</span> <span class="n">elsiocb</span><span class="o">-&gt;</span><span class="n">context3</span><span class="p">;</span>
		<span class="n">lpfc_els_free_bpl</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">buf_ptr</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">lpfc_sli_release_iocbq</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">elsiocb</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_cmpl_els_logo_acc - Completion callback function to logo acc response</span>
<span class="cm"> * @phba: pointer to lpfc hba data structure.</span>
<span class="cm"> * @cmdiocb: pointer to lpfc command iocb data structure.</span>
<span class="cm"> * @rspiocb: pointer to lpfc response iocb data structure.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine is the completion callback function to the Logout (LOGO)</span>
<span class="cm"> * Accept (ACC) Response ELS command. This routine is invoked to indicate</span>
<span class="cm"> * the completion of the LOGO process. It invokes the lpfc_nlp_not_used() to</span>
<span class="cm"> * release the ndlp if it has the last reference remaining (reference count</span>
<span class="cm"> * is 1). If succeeded (meaning ndlp released), it sets the IOCB context1</span>
<span class="cm"> * field to NULL to inform the following lpfc_els_free_iocb() routine no</span>
<span class="cm"> * ndlp reference count needs to be decremented. Otherwise, the ndlp</span>
<span class="cm"> * reference use-count shall be decremented by the lpfc_els_free_iocb()</span>
<span class="cm"> * routine. Finally, the lpfc_els_free_iocb() is invoked to release the</span>
<span class="cm"> * IOCB data structure.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">lpfc_cmpl_els_logo_acc</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">,</span> <span class="k">struct</span> <span class="n">lpfc_iocbq</span> <span class="o">*</span><span class="n">cmdiocb</span><span class="p">,</span>
		       <span class="k">struct</span> <span class="n">lpfc_iocbq</span> <span class="o">*</span><span class="n">rspiocb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpfc_nodelist</span> <span class="o">*</span><span class="n">ndlp</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_nodelist</span> <span class="o">*</span><span class="p">)</span> <span class="n">cmdiocb</span><span class="o">-&gt;</span><span class="n">context1</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="n">vport</span> <span class="o">=</span> <span class="n">cmdiocb</span><span class="o">-&gt;</span><span class="n">vport</span><span class="p">;</span>
	<span class="n">IOCB_t</span> <span class="o">*</span><span class="n">irsp</span><span class="p">;</span>

	<span class="n">irsp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">rspiocb</span><span class="o">-&gt;</span><span class="n">iocb</span><span class="p">;</span>
	<span class="n">lpfc_debugfs_disc_trc</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">LPFC_DISC_TRC_ELS_RSP</span><span class="p">,</span>
		<span class="s">&quot;ACC LOGO cmpl:   status:x%x/x%x did:x%x&quot;</span><span class="p">,</span>
		<span class="n">irsp</span><span class="o">-&gt;</span><span class="n">ulpStatus</span><span class="p">,</span> <span class="n">irsp</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">ulpWord</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span> <span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_DID</span><span class="p">);</span>
	<span class="cm">/* ACC to LOGO completes to NPort &lt;nlp_DID&gt; */</span>
	<span class="n">lpfc_printf_vlog</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">KERN_INFO</span><span class="p">,</span> <span class="n">LOG_ELS</span><span class="p">,</span>
			 <span class="s">&quot;0109 ACC to LOGO completes to NPort x%x &quot;</span>
			 <span class="s">&quot;Data: x%x x%x x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			 <span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_DID</span><span class="p">,</span> <span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_flag</span><span class="p">,</span> <span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_state</span><span class="p">,</span>
			 <span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_rpi</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_state</span> <span class="o">==</span> <span class="n">NLP_STE_NPR_NODE</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* NPort Recovery mode or node is just allocated */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">lpfc_nlp_not_used</span><span class="p">(</span><span class="n">ndlp</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/* If the ndlp is being used by another discovery</span>
<span class="cm">			 * thread, just unregister the RPI.</span>
<span class="cm">			 */</span>
			<span class="n">lpfc_unreg_rpi</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">ndlp</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/* Indicate the node has already released, should</span>
<span class="cm">			 * not reference to it from within lpfc_els_free_iocb.</span>
<span class="cm">			 */</span>
			<span class="n">cmdiocb</span><span class="o">-&gt;</span><span class="n">context1</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * The driver received a LOGO from the rport and has ACK&#39;d it.</span>
<span class="cm">	 * At this point, the driver is done so release the IOCB</span>
<span class="cm">	 */</span>
	<span class="n">lpfc_els_free_iocb</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">cmdiocb</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Remove the ndlp reference if it&#39;s a fabric node that has</span>
<span class="cm">	 * sent us an unsolicted LOGO.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_type</span> <span class="o">&amp;</span> <span class="n">NLP_FABRIC</span><span class="p">)</span>
		<span class="n">lpfc_nlp_put</span><span class="p">(</span><span class="n">ndlp</span><span class="p">);</span>

	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_mbx_cmpl_dflt_rpi - Completion callbk func for unreg dflt rpi mbox cmd</span>
<span class="cm"> * @phba: pointer to lpfc hba data structure.</span>
<span class="cm"> * @pmb: pointer to the driver internal queue element for mailbox command.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine is the completion callback function for unregister default</span>
<span class="cm"> * RPI (Remote Port Index) mailbox command to the @phba. It simply releases</span>
<span class="cm"> * the associated lpfc Direct Memory Access (DMA) buffer back to the pool and</span>
<span class="cm"> * decrements the ndlp reference count held for this completion callback</span>
<span class="cm"> * function. After that, it invokes the lpfc_nlp_not_used() to check</span>
<span class="cm"> * whether there is only one reference left on the ndlp. If so, it will</span>
<span class="cm"> * perform one more decrement and trigger the release of the ndlp.</span>
<span class="cm"> **/</span>
<span class="kt">void</span>
<span class="nf">lpfc_mbx_cmpl_dflt_rpi</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">,</span> <span class="n">LPFC_MBOXQ_t</span> <span class="o">*</span><span class="n">pmb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpfc_dmabuf</span> <span class="o">*</span><span class="n">mp</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_dmabuf</span> <span class="o">*</span><span class="p">)</span> <span class="p">(</span><span class="n">pmb</span><span class="o">-&gt;</span><span class="n">context1</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">lpfc_nodelist</span> <span class="o">*</span><span class="n">ndlp</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_nodelist</span> <span class="o">*</span><span class="p">)</span> <span class="n">pmb</span><span class="o">-&gt;</span><span class="n">context2</span><span class="p">;</span>

	<span class="n">pmb</span><span class="o">-&gt;</span><span class="n">context1</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">pmb</span><span class="o">-&gt;</span><span class="n">context2</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">lpfc_mbuf_free</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">virt</span><span class="p">,</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">phys</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">mp</span><span class="p">);</span>
	<span class="n">mempool_free</span><span class="p">(</span><span class="n">pmb</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">mbox_mem_pool</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ndlp</span> <span class="o">&amp;&amp;</span> <span class="n">NLP_CHK_NODE_ACT</span><span class="p">(</span><span class="n">ndlp</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">lpfc_nlp_put</span><span class="p">(</span><span class="n">ndlp</span><span class="p">);</span>
		<span class="cm">/* This is the end of the default RPI cleanup logic for this</span>
<span class="cm">		 * ndlp. If no other discovery threads are using this ndlp.</span>
<span class="cm">		 * we should free all resources associated with it.</span>
<span class="cm">		 */</span>
		<span class="n">lpfc_nlp_not_used</span><span class="p">(</span><span class="n">ndlp</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_cmpl_els_rsp - Completion callback function for els response iocb cmd</span>
<span class="cm"> * @phba: pointer to lpfc hba data structure.</span>
<span class="cm"> * @cmdiocb: pointer to lpfc command iocb data structure.</span>
<span class="cm"> * @rspiocb: pointer to lpfc response iocb data structure.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine is the completion callback function for ELS Response IOCB</span>
<span class="cm"> * command. In normal case, this callback function just properly sets the</span>
<span class="cm"> * nlp_flag bitmap in the ndlp data structure, if the mbox command reference</span>
<span class="cm"> * field in the command IOCB is not NULL, the referred mailbox command will</span>
<span class="cm"> * be send out, and then invokes the lpfc_els_free_iocb() routine to release</span>
<span class="cm"> * the IOCB. Under error conditions, such as when a LS_RJT is returned or a</span>
<span class="cm"> * link down event occurred during the discovery, the lpfc_nlp_not_used()</span>
<span class="cm"> * routine shall be invoked trying to release the ndlp if no other threads</span>
<span class="cm"> * are currently referring it.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">lpfc_cmpl_els_rsp</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">,</span> <span class="k">struct</span> <span class="n">lpfc_iocbq</span> <span class="o">*</span><span class="n">cmdiocb</span><span class="p">,</span>
		  <span class="k">struct</span> <span class="n">lpfc_iocbq</span> <span class="o">*</span><span class="n">rspiocb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpfc_nodelist</span> <span class="o">*</span><span class="n">ndlp</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_nodelist</span> <span class="o">*</span><span class="p">)</span> <span class="n">cmdiocb</span><span class="o">-&gt;</span><span class="n">context1</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="n">vport</span> <span class="o">=</span> <span class="n">ndlp</span> <span class="o">?</span> <span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">vport</span> <span class="o">:</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span>  <span class="o">*</span><span class="n">shost</span> <span class="o">=</span> <span class="n">vport</span> <span class="o">?</span> <span class="n">lpfc_shost_from_vport</span><span class="p">(</span><span class="n">vport</span><span class="p">)</span> <span class="o">:</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">IOCB_t</span>  <span class="o">*</span><span class="n">irsp</span><span class="p">;</span>
	<span class="kt">uint8_t</span> <span class="o">*</span><span class="n">pcmd</span><span class="p">;</span>
	<span class="n">LPFC_MBOXQ_t</span> <span class="o">*</span><span class="n">mbox</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_dmabuf</span> <span class="o">*</span><span class="n">mp</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">ls_rjt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">irsp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">rspiocb</span><span class="o">-&gt;</span><span class="n">iocb</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cmdiocb</span><span class="o">-&gt;</span><span class="n">context_un</span><span class="p">.</span><span class="n">mbox</span><span class="p">)</span>
		<span class="n">mbox</span> <span class="o">=</span> <span class="n">cmdiocb</span><span class="o">-&gt;</span><span class="n">context_un</span><span class="p">.</span><span class="n">mbox</span><span class="p">;</span>

	<span class="cm">/* First determine if this is a LS_RJT cmpl. Note, this callback</span>
<span class="cm">	 * function can have cmdiocb-&gt;contest1 (ndlp) field set to NULL.</span>
<span class="cm">	 */</span>
	<span class="n">pcmd</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint8_t</span> <span class="o">*</span><span class="p">)</span> <span class="p">(((</span><span class="k">struct</span> <span class="n">lpfc_dmabuf</span> <span class="o">*</span><span class="p">)</span> <span class="n">cmdiocb</span><span class="o">-&gt;</span><span class="n">context2</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">virt</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ndlp</span> <span class="o">&amp;&amp;</span> <span class="n">NLP_CHK_NODE_ACT</span><span class="p">(</span><span class="n">ndlp</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="o">*</span><span class="p">((</span><span class="kt">uint32_t</span> <span class="o">*</span><span class="p">)</span> <span class="p">(</span><span class="n">pcmd</span><span class="p">))</span> <span class="o">==</span> <span class="n">ELS_CMD_LS_RJT</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* A LS_RJT associated with Default RPI cleanup has its own</span>
<span class="cm">		 * separate code path.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_flag</span> <span class="o">&amp;</span> <span class="n">NLP_RM_DFLT_RPI</span><span class="p">))</span>
			<span class="n">ls_rjt</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Check to see if link went down during discovery */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ndlp</span> <span class="o">||</span> <span class="o">!</span><span class="n">NLP_CHK_NODE_ACT</span><span class="p">(</span><span class="n">ndlp</span><span class="p">)</span> <span class="o">||</span> <span class="n">lpfc_els_chk_latt</span><span class="p">(</span><span class="n">vport</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">mbox</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">mp</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_dmabuf</span> <span class="o">*</span><span class="p">)</span> <span class="n">mbox</span><span class="o">-&gt;</span><span class="n">context1</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">mp</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">lpfc_mbuf_free</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">virt</span><span class="p">,</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">phys</span><span class="p">);</span>
				<span class="n">kfree</span><span class="p">(</span><span class="n">mp</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="n">mempool_free</span><span class="p">(</span><span class="n">mbox</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">mbox_mem_pool</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ndlp</span> <span class="o">&amp;&amp;</span> <span class="n">NLP_CHK_NODE_ACT</span><span class="p">(</span><span class="n">ndlp</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="p">(</span><span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_flag</span> <span class="o">&amp;</span> <span class="n">NLP_RM_DFLT_RPI</span><span class="p">))</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">lpfc_nlp_not_used</span><span class="p">(</span><span class="n">ndlp</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">ndlp</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
				<span class="cm">/* Indicate the node has already released,</span>
<span class="cm">				 * should not reference to it from within</span>
<span class="cm">				 * the routine lpfc_els_free_iocb.</span>
<span class="cm">				 */</span>
				<span class="n">cmdiocb</span><span class="o">-&gt;</span><span class="n">context1</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">lpfc_debugfs_disc_trc</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">LPFC_DISC_TRC_ELS_RSP</span><span class="p">,</span>
		<span class="s">&quot;ELS rsp cmpl:    status:x%x/x%x did:x%x&quot;</span><span class="p">,</span>
		<span class="n">irsp</span><span class="o">-&gt;</span><span class="n">ulpStatus</span><span class="p">,</span> <span class="n">irsp</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">ulpWord</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span>
		<span class="n">cmdiocb</span><span class="o">-&gt;</span><span class="n">iocb</span><span class="p">.</span><span class="n">un</span><span class="p">.</span><span class="n">elsreq64</span><span class="p">.</span><span class="n">remoteID</span><span class="p">);</span>
	<span class="cm">/* ELS response tag &lt;ulpIoTag&gt; completes */</span>
	<span class="n">lpfc_printf_vlog</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">KERN_INFO</span><span class="p">,</span> <span class="n">LOG_ELS</span><span class="p">,</span>
			 <span class="s">&quot;0110 ELS response tag x%x completes &quot;</span>
			 <span class="s">&quot;Data: x%x x%x x%x x%x x%x x%x x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			 <span class="n">cmdiocb</span><span class="o">-&gt;</span><span class="n">iocb</span><span class="p">.</span><span class="n">ulpIoTag</span><span class="p">,</span> <span class="n">rspiocb</span><span class="o">-&gt;</span><span class="n">iocb</span><span class="p">.</span><span class="n">ulpStatus</span><span class="p">,</span>
			 <span class="n">rspiocb</span><span class="o">-&gt;</span><span class="n">iocb</span><span class="p">.</span><span class="n">un</span><span class="p">.</span><span class="n">ulpWord</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span> <span class="n">rspiocb</span><span class="o">-&gt;</span><span class="n">iocb</span><span class="p">.</span><span class="n">ulpTimeout</span><span class="p">,</span>
			 <span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_DID</span><span class="p">,</span> <span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_flag</span><span class="p">,</span> <span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_state</span><span class="p">,</span>
			 <span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_rpi</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mbox</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">rspiocb</span><span class="o">-&gt;</span><span class="n">iocb</span><span class="p">.</span><span class="n">ulpStatus</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		    <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_flag</span> <span class="o">&amp;</span> <span class="n">NLP_ACC_REGLOGIN</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">lpfc_unreg_rpi</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">ndlp</span><span class="p">);</span>
			<span class="cm">/* Increment reference count to ndlp to hold the</span>
<span class="cm">			 * reference to ndlp for the callback function.</span>
<span class="cm">			 */</span>
			<span class="n">mbox</span><span class="o">-&gt;</span><span class="n">context2</span> <span class="o">=</span> <span class="n">lpfc_nlp_get</span><span class="p">(</span><span class="n">ndlp</span><span class="p">);</span>
			<span class="n">mbox</span><span class="o">-&gt;</span><span class="n">vport</span> <span class="o">=</span> <span class="n">vport</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_flag</span> <span class="o">&amp;</span> <span class="n">NLP_RM_DFLT_RPI</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">mbox</span><span class="o">-&gt;</span><span class="n">mbox_flag</span> <span class="o">|=</span> <span class="n">LPFC_MBX_IMED_UNREG</span><span class="p">;</span>
				<span class="n">mbox</span><span class="o">-&gt;</span><span class="n">mbox_cmpl</span> <span class="o">=</span> <span class="n">lpfc_mbx_cmpl_dflt_rpi</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">else</span> <span class="p">{</span>
				<span class="n">mbox</span><span class="o">-&gt;</span><span class="n">mbox_cmpl</span> <span class="o">=</span> <span class="n">lpfc_mbx_cmpl_reg_login</span><span class="p">;</span>
				<span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_prev_state</span> <span class="o">=</span> <span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_state</span><span class="p">;</span>
				<span class="n">lpfc_nlp_set_state</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">ndlp</span><span class="p">,</span>
					   <span class="n">NLP_STE_REG_LOGIN_ISSUE</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">lpfc_sli_issue_mbox</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">mbox</span><span class="p">,</span> <span class="n">MBX_NOWAIT</span><span class="p">)</span>
			    <span class="o">!=</span> <span class="n">MBX_NOT_FINISHED</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
			<span class="k">else</span>
				<span class="cm">/* Decrement the ndlp reference count we</span>
<span class="cm">				 * set for this failed mailbox command.</span>
<span class="cm">				 */</span>
				<span class="n">lpfc_nlp_put</span><span class="p">(</span><span class="n">ndlp</span><span class="p">);</span>

			<span class="cm">/* ELS rsp: Cannot issue reg_login for &lt;NPortid&gt; */</span>
			<span class="n">lpfc_printf_vlog</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_ELS</span><span class="p">,</span>
				<span class="s">&quot;0138 ELS rsp: Cannot issue reg_login for x%x &quot;</span>
				<span class="s">&quot;Data: x%x x%x x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_DID</span><span class="p">,</span> <span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_flag</span><span class="p">,</span> <span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_state</span><span class="p">,</span>
				<span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_rpi</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">lpfc_nlp_not_used</span><span class="p">(</span><span class="n">ndlp</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">ndlp</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
				<span class="cm">/* Indicate node has already been released,</span>
<span class="cm">				 * should not reference to it from within</span>
<span class="cm">				 * the routine lpfc_els_free_iocb.</span>
<span class="cm">				 */</span>
				<span class="n">cmdiocb</span><span class="o">-&gt;</span><span class="n">context1</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/* Do not drop node for lpfc_els_abort&#39;ed ELS cmds */</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">lpfc_error_lost_link</span><span class="p">(</span><span class="n">irsp</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			    <span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_flag</span> <span class="o">&amp;</span> <span class="n">NLP_ACC_REGLOGIN</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">lpfc_nlp_not_used</span><span class="p">(</span><span class="n">ndlp</span><span class="p">))</span> <span class="p">{</span>
					<span class="n">ndlp</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
					<span class="cm">/* Indicate node has already been</span>
<span class="cm">					 * released, should not reference</span>
<span class="cm">					 * to it from within the routine</span>
<span class="cm">					 * lpfc_els_free_iocb.</span>
<span class="cm">					 */</span>
					<span class="n">cmdiocb</span><span class="o">-&gt;</span><span class="n">context1</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
				<span class="p">}</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="n">mp</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_dmabuf</span> <span class="o">*</span><span class="p">)</span> <span class="n">mbox</span><span class="o">-&gt;</span><span class="n">context1</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">mp</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">lpfc_mbuf_free</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">virt</span><span class="p">,</span> <span class="n">mp</span><span class="o">-&gt;</span><span class="n">phys</span><span class="p">);</span>
			<span class="n">kfree</span><span class="p">(</span><span class="n">mp</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">mempool_free</span><span class="p">(</span><span class="n">mbox</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">mbox_mem_pool</span><span class="p">);</span>
	<span class="p">}</span>
<span class="nl">out:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ndlp</span> <span class="o">&amp;&amp;</span> <span class="n">NLP_CHK_NODE_ACT</span><span class="p">(</span><span class="n">ndlp</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">spin_lock_irq</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>
		<span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_flag</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">NLP_ACC_REGLOGIN</span> <span class="o">|</span> <span class="n">NLP_RM_DFLT_RPI</span><span class="p">);</span>
		<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>

		<span class="cm">/* If the node is not being used by another discovery thread,</span>
<span class="cm">		 * and we are sending a reject, we are done with it.</span>
<span class="cm">		 * Release driver reference count here and free associated</span>
<span class="cm">		 * resources.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ls_rjt</span><span class="p">)</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">lpfc_nlp_not_used</span><span class="p">(</span><span class="n">ndlp</span><span class="p">))</span>
				<span class="cm">/* Indicate node has already been released,</span>
<span class="cm">				 * should not reference to it from within</span>
<span class="cm">				 * the routine lpfc_els_free_iocb.</span>
<span class="cm">				 */</span>
				<span class="n">cmdiocb</span><span class="o">-&gt;</span><span class="n">context1</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">lpfc_els_free_iocb</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">cmdiocb</span><span class="p">);</span>
	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_els_rsp_acc - Prepare and issue an acc response iocb command</span>
<span class="cm"> * @vport: pointer to a host virtual N_Port data structure.</span>
<span class="cm"> * @flag: the els command code to be accepted.</span>
<span class="cm"> * @oldiocb: pointer to the original lpfc command iocb data structure.</span>
<span class="cm"> * @ndlp: pointer to a node-list data structure.</span>
<span class="cm"> * @mbox: pointer to the driver internal queue element for mailbox command.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine prepares and issues an Accept (ACC) response IOCB</span>
<span class="cm"> * command. It uses the @flag to properly set up the IOCB field for the</span>
<span class="cm"> * specific ACC response command to be issued and invokes the</span>
<span class="cm"> * lpfc_sli_issue_iocb() routine to send out ACC response IOCB. If a</span>
<span class="cm"> * @mbox pointer is passed in, it will be put into the context_un.mbox</span>
<span class="cm"> * field of the IOCB for the completion callback function to issue the</span>
<span class="cm"> * mailbox command to the HBA later when callback is invoked.</span>
<span class="cm"> *</span>
<span class="cm"> * Note that, in lpfc_prep_els_iocb() routine, the reference count of ndlp</span>
<span class="cm"> * will be incremented by 1 for holding the ndlp and the reference to ndlp</span>
<span class="cm"> * will be stored into the context1 field of the IOCB for the completion</span>
<span class="cm"> * callback function to the corresponding response ELS IOCB command.</span>
<span class="cm"> *</span>
<span class="cm"> * Return code</span>
<span class="cm"> *   0 - Successfully issued acc response</span>
<span class="cm"> *   1 - Failed to issue acc response</span>
<span class="cm"> **/</span>
<span class="kt">int</span>
<span class="nf">lpfc_els_rsp_acc</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="n">vport</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">flag</span><span class="p">,</span>
		 <span class="k">struct</span> <span class="n">lpfc_iocbq</span> <span class="o">*</span><span class="n">oldiocb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">lpfc_nodelist</span> <span class="o">*</span><span class="n">ndlp</span><span class="p">,</span>
		 <span class="n">LPFC_MBOXQ_t</span> <span class="o">*</span><span class="n">mbox</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span> <span class="o">=</span> <span class="n">lpfc_shost_from_vport</span><span class="p">(</span><span class="n">vport</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">lpfc_hba</span>  <span class="o">*</span><span class="n">phba</span> <span class="o">=</span> <span class="n">vport</span><span class="o">-&gt;</span><span class="n">phba</span><span class="p">;</span>
	<span class="n">IOCB_t</span> <span class="o">*</span><span class="n">icmd</span><span class="p">;</span>
	<span class="n">IOCB_t</span> <span class="o">*</span><span class="n">oldcmd</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_iocbq</span> <span class="o">*</span><span class="n">elsiocb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_sli</span> <span class="o">*</span><span class="n">psli</span><span class="p">;</span>
	<span class="kt">uint8_t</span> <span class="o">*</span><span class="n">pcmd</span><span class="p">;</span>
	<span class="kt">uint16_t</span> <span class="n">cmdsize</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>
	<span class="n">ELS_PKT</span> <span class="o">*</span><span class="n">els_pkt_ptr</span><span class="p">;</span>

	<span class="n">psli</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli</span><span class="p">;</span>
	<span class="n">oldcmd</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">oldiocb</span><span class="o">-&gt;</span><span class="n">iocb</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">flag</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">ELS_CMD_ACC</span>:
		<span class="n">cmdsize</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">uint32_t</span><span class="p">);</span>
		<span class="n">elsiocb</span> <span class="o">=</span> <span class="n">lpfc_prep_els_iocb</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">cmdsize</span><span class="p">,</span> <span class="n">oldiocb</span><span class="o">-&gt;</span><span class="n">retry</span><span class="p">,</span>
					     <span class="n">ndlp</span><span class="p">,</span> <span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_DID</span><span class="p">,</span> <span class="n">ELS_CMD_ACC</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">elsiocb</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">spin_lock_irq</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>
			<span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_flag</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">NLP_LOGO_ACC</span><span class="p">;</span>
			<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">icmd</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">elsiocb</span><span class="o">-&gt;</span><span class="n">iocb</span><span class="p">;</span>
		<span class="n">icmd</span><span class="o">-&gt;</span><span class="n">ulpContext</span> <span class="o">=</span> <span class="n">oldcmd</span><span class="o">-&gt;</span><span class="n">ulpContext</span><span class="p">;</span>	<span class="cm">/* Xri / rx_id */</span>
		<span class="n">icmd</span><span class="o">-&gt;</span><span class="n">unsli3</span><span class="p">.</span><span class="n">rcvsli3</span><span class="p">.</span><span class="n">ox_id</span> <span class="o">=</span> <span class="n">oldcmd</span><span class="o">-&gt;</span><span class="n">unsli3</span><span class="p">.</span><span class="n">rcvsli3</span><span class="p">.</span><span class="n">ox_id</span><span class="p">;</span>
		<span class="n">pcmd</span> <span class="o">=</span> <span class="p">(((</span><span class="k">struct</span> <span class="n">lpfc_dmabuf</span> <span class="o">*</span><span class="p">)</span> <span class="n">elsiocb</span><span class="o">-&gt;</span><span class="n">context2</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">virt</span><span class="p">);</span>
		<span class="o">*</span><span class="p">((</span><span class="kt">uint32_t</span> <span class="o">*</span><span class="p">)</span> <span class="p">(</span><span class="n">pcmd</span><span class="p">))</span> <span class="o">=</span> <span class="n">ELS_CMD_ACC</span><span class="p">;</span>
		<span class="n">pcmd</span> <span class="o">+=</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">uint32_t</span><span class="p">);</span>

		<span class="n">lpfc_debugfs_disc_trc</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">LPFC_DISC_TRC_ELS_RSP</span><span class="p">,</span>
			<span class="s">&quot;Issue ACC:       did:x%x flg:x%x&quot;</span><span class="p">,</span>
			<span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_DID</span><span class="p">,</span> <span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_flag</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">ELS_CMD_PLOGI</span>:
		<span class="n">cmdsize</span> <span class="o">=</span> <span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">serv_parm</span><span class="p">)</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">uint32_t</span><span class="p">));</span>
		<span class="n">elsiocb</span> <span class="o">=</span> <span class="n">lpfc_prep_els_iocb</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">cmdsize</span><span class="p">,</span> <span class="n">oldiocb</span><span class="o">-&gt;</span><span class="n">retry</span><span class="p">,</span>
					     <span class="n">ndlp</span><span class="p">,</span> <span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_DID</span><span class="p">,</span> <span class="n">ELS_CMD_ACC</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">elsiocb</span><span class="p">)</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

		<span class="n">icmd</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">elsiocb</span><span class="o">-&gt;</span><span class="n">iocb</span><span class="p">;</span>
		<span class="n">icmd</span><span class="o">-&gt;</span><span class="n">ulpContext</span> <span class="o">=</span> <span class="n">oldcmd</span><span class="o">-&gt;</span><span class="n">ulpContext</span><span class="p">;</span>	<span class="cm">/* Xri / rx_id */</span>
		<span class="n">icmd</span><span class="o">-&gt;</span><span class="n">unsli3</span><span class="p">.</span><span class="n">rcvsli3</span><span class="p">.</span><span class="n">ox_id</span> <span class="o">=</span> <span class="n">oldcmd</span><span class="o">-&gt;</span><span class="n">unsli3</span><span class="p">.</span><span class="n">rcvsli3</span><span class="p">.</span><span class="n">ox_id</span><span class="p">;</span>
		<span class="n">pcmd</span> <span class="o">=</span> <span class="p">(((</span><span class="k">struct</span> <span class="n">lpfc_dmabuf</span> <span class="o">*</span><span class="p">)</span> <span class="n">elsiocb</span><span class="o">-&gt;</span><span class="n">context2</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">virt</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">mbox</span><span class="p">)</span>
			<span class="n">elsiocb</span><span class="o">-&gt;</span><span class="n">context_un</span><span class="p">.</span><span class="n">mbox</span> <span class="o">=</span> <span class="n">mbox</span><span class="p">;</span>

		<span class="o">*</span><span class="p">((</span><span class="kt">uint32_t</span> <span class="o">*</span><span class="p">)</span> <span class="p">(</span><span class="n">pcmd</span><span class="p">))</span> <span class="o">=</span> <span class="n">ELS_CMD_ACC</span><span class="p">;</span>
		<span class="n">pcmd</span> <span class="o">+=</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">uint32_t</span><span class="p">);</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">pcmd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_sparam</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">serv_parm</span><span class="p">));</span>

		<span class="n">lpfc_debugfs_disc_trc</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">LPFC_DISC_TRC_ELS_RSP</span><span class="p">,</span>
			<span class="s">&quot;Issue ACC PLOGI: did:x%x flg:x%x&quot;</span><span class="p">,</span>
			<span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_DID</span><span class="p">,</span> <span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_flag</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">ELS_CMD_PRLO</span>:
		<span class="n">cmdsize</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">uint32_t</span><span class="p">)</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">PRLO</span><span class="p">);</span>
		<span class="n">elsiocb</span> <span class="o">=</span> <span class="n">lpfc_prep_els_iocb</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">cmdsize</span><span class="p">,</span> <span class="n">oldiocb</span><span class="o">-&gt;</span><span class="n">retry</span><span class="p">,</span>
					     <span class="n">ndlp</span><span class="p">,</span> <span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_DID</span><span class="p">,</span> <span class="n">ELS_CMD_PRLO</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">elsiocb</span><span class="p">)</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

		<span class="n">icmd</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">elsiocb</span><span class="o">-&gt;</span><span class="n">iocb</span><span class="p">;</span>
		<span class="n">icmd</span><span class="o">-&gt;</span><span class="n">ulpContext</span> <span class="o">=</span> <span class="n">oldcmd</span><span class="o">-&gt;</span><span class="n">ulpContext</span><span class="p">;</span>	<span class="cm">/* Xri / rx_id */</span>
		<span class="n">icmd</span><span class="o">-&gt;</span><span class="n">unsli3</span><span class="p">.</span><span class="n">rcvsli3</span><span class="p">.</span><span class="n">ox_id</span> <span class="o">=</span> <span class="n">oldcmd</span><span class="o">-&gt;</span><span class="n">unsli3</span><span class="p">.</span><span class="n">rcvsli3</span><span class="p">.</span><span class="n">ox_id</span><span class="p">;</span>
		<span class="n">pcmd</span> <span class="o">=</span> <span class="p">(((</span><span class="k">struct</span> <span class="n">lpfc_dmabuf</span> <span class="o">*</span><span class="p">)</span> <span class="n">elsiocb</span><span class="o">-&gt;</span><span class="n">context2</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">virt</span><span class="p">);</span>

		<span class="n">memcpy</span><span class="p">(</span><span class="n">pcmd</span><span class="p">,</span> <span class="p">((</span><span class="k">struct</span> <span class="n">lpfc_dmabuf</span> <span class="o">*</span><span class="p">)</span> <span class="n">oldiocb</span><span class="o">-&gt;</span><span class="n">context2</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">virt</span><span class="p">,</span>
		       <span class="k">sizeof</span><span class="p">(</span><span class="kt">uint32_t</span><span class="p">)</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">PRLO</span><span class="p">));</span>
		<span class="o">*</span><span class="p">((</span><span class="kt">uint32_t</span> <span class="o">*</span><span class="p">)</span> <span class="p">(</span><span class="n">pcmd</span><span class="p">))</span> <span class="o">=</span> <span class="n">ELS_CMD_PRLO_ACC</span><span class="p">;</span>
		<span class="n">els_pkt_ptr</span> <span class="o">=</span> <span class="p">(</span><span class="n">ELS_PKT</span> <span class="o">*</span><span class="p">)</span> <span class="n">pcmd</span><span class="p">;</span>
		<span class="n">els_pkt_ptr</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">prlo</span><span class="p">.</span><span class="n">acceptRspCode</span> <span class="o">=</span> <span class="n">PRLO_REQ_EXECUTED</span><span class="p">;</span>

		<span class="n">lpfc_debugfs_disc_trc</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">LPFC_DISC_TRC_ELS_RSP</span><span class="p">,</span>
			<span class="s">&quot;Issue ACC PRLO:  did:x%x flg:x%x&quot;</span><span class="p">,</span>
			<span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_DID</span><span class="p">,</span> <span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_flag</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* Xmit ELS ACC response tag &lt;ulpIoTag&gt; */</span>
	<span class="n">lpfc_printf_vlog</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">KERN_INFO</span><span class="p">,</span> <span class="n">LOG_ELS</span><span class="p">,</span>
			 <span class="s">&quot;0128 Xmit ELS ACC response tag x%x, XRI: x%x, &quot;</span>
			 <span class="s">&quot;DID: x%x, nlp_flag: x%x nlp_state: x%x RPI: x%x &quot;</span>
			 <span class="s">&quot;fc_flag x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			 <span class="n">elsiocb</span><span class="o">-&gt;</span><span class="n">iotag</span><span class="p">,</span> <span class="n">elsiocb</span><span class="o">-&gt;</span><span class="n">iocb</span><span class="p">.</span><span class="n">ulpContext</span><span class="p">,</span>
			 <span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_DID</span><span class="p">,</span> <span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_flag</span><span class="p">,</span> <span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_state</span><span class="p">,</span>
			 <span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_rpi</span><span class="p">,</span> <span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_flag</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_flag</span> <span class="o">&amp;</span> <span class="n">NLP_LOGO_ACC</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_lock_irq</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>
		<span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_flag</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">NLP_LOGO_ACC</span><span class="p">;</span>
		<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>
		<span class="n">elsiocb</span><span class="o">-&gt;</span><span class="n">iocb_cmpl</span> <span class="o">=</span> <span class="n">lpfc_cmpl_els_logo_acc</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">elsiocb</span><span class="o">-&gt;</span><span class="n">iocb_cmpl</span> <span class="o">=</span> <span class="n">lpfc_cmpl_els_rsp</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">fc_stat</span><span class="p">.</span><span class="n">elsXmitACC</span><span class="o">++</span><span class="p">;</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">lpfc_sli_issue_iocb</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">LPFC_ELS_RING</span><span class="p">,</span> <span class="n">elsiocb</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">==</span> <span class="n">IOCB_ERROR</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lpfc_els_free_iocb</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">elsiocb</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_els_rsp_reject - Propare and issue a rjt response iocb command</span>
<span class="cm"> * @vport: pointer to a virtual N_Port data structure.</span>
<span class="cm"> * @rejectError:</span>
<span class="cm"> * @oldiocb: pointer to the original lpfc command iocb data structure.</span>
<span class="cm"> * @ndlp: pointer to a node-list data structure.</span>
<span class="cm"> * @mbox: pointer to the driver internal queue element for mailbox command.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine prepares and issue an Reject (RJT) response IOCB</span>
<span class="cm"> * command. If a @mbox pointer is passed in, it will be put into the</span>
<span class="cm"> * context_un.mbox field of the IOCB for the completion callback function</span>
<span class="cm"> * to issue to the HBA later.</span>
<span class="cm"> *</span>
<span class="cm"> * Note that, in lpfc_prep_els_iocb() routine, the reference count of ndlp</span>
<span class="cm"> * will be incremented by 1 for holding the ndlp and the reference to ndlp</span>
<span class="cm"> * will be stored into the context1 field of the IOCB for the completion</span>
<span class="cm"> * callback function to the reject response ELS IOCB command.</span>
<span class="cm"> *</span>
<span class="cm"> * Return code</span>
<span class="cm"> *   0 - Successfully issued reject response</span>
<span class="cm"> *   1 - Failed to issue reject response</span>
<span class="cm"> **/</span>
<span class="kt">int</span>
<span class="nf">lpfc_els_rsp_reject</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="n">vport</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">rejectError</span><span class="p">,</span>
		    <span class="k">struct</span> <span class="n">lpfc_iocbq</span> <span class="o">*</span><span class="n">oldiocb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">lpfc_nodelist</span> <span class="o">*</span><span class="n">ndlp</span><span class="p">,</span>
		    <span class="n">LPFC_MBOXQ_t</span> <span class="o">*</span><span class="n">mbox</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpfc_hba</span>  <span class="o">*</span><span class="n">phba</span> <span class="o">=</span> <span class="n">vport</span><span class="o">-&gt;</span><span class="n">phba</span><span class="p">;</span>
	<span class="n">IOCB_t</span> <span class="o">*</span><span class="n">icmd</span><span class="p">;</span>
	<span class="n">IOCB_t</span> <span class="o">*</span><span class="n">oldcmd</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_iocbq</span> <span class="o">*</span><span class="n">elsiocb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_sli</span> <span class="o">*</span><span class="n">psli</span><span class="p">;</span>
	<span class="kt">uint8_t</span> <span class="o">*</span><span class="n">pcmd</span><span class="p">;</span>
	<span class="kt">uint16_t</span> <span class="n">cmdsize</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">psli</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli</span><span class="p">;</span>
	<span class="n">cmdsize</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">uint32_t</span><span class="p">);</span>
	<span class="n">elsiocb</span> <span class="o">=</span> <span class="n">lpfc_prep_els_iocb</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">cmdsize</span><span class="p">,</span> <span class="n">oldiocb</span><span class="o">-&gt;</span><span class="n">retry</span><span class="p">,</span> <span class="n">ndlp</span><span class="p">,</span>
				     <span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_DID</span><span class="p">,</span> <span class="n">ELS_CMD_LS_RJT</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">elsiocb</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">icmd</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">elsiocb</span><span class="o">-&gt;</span><span class="n">iocb</span><span class="p">;</span>
	<span class="n">oldcmd</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">oldiocb</span><span class="o">-&gt;</span><span class="n">iocb</span><span class="p">;</span>
	<span class="n">icmd</span><span class="o">-&gt;</span><span class="n">ulpContext</span> <span class="o">=</span> <span class="n">oldcmd</span><span class="o">-&gt;</span><span class="n">ulpContext</span><span class="p">;</span>	<span class="cm">/* Xri / rx_id */</span>
	<span class="n">icmd</span><span class="o">-&gt;</span><span class="n">unsli3</span><span class="p">.</span><span class="n">rcvsli3</span><span class="p">.</span><span class="n">ox_id</span> <span class="o">=</span> <span class="n">oldcmd</span><span class="o">-&gt;</span><span class="n">unsli3</span><span class="p">.</span><span class="n">rcvsli3</span><span class="p">.</span><span class="n">ox_id</span><span class="p">;</span>
	<span class="n">pcmd</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint8_t</span> <span class="o">*</span><span class="p">)</span> <span class="p">(((</span><span class="k">struct</span> <span class="n">lpfc_dmabuf</span> <span class="o">*</span><span class="p">)</span> <span class="n">elsiocb</span><span class="o">-&gt;</span><span class="n">context2</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">virt</span><span class="p">);</span>

	<span class="o">*</span><span class="p">((</span><span class="kt">uint32_t</span> <span class="o">*</span><span class="p">)</span> <span class="p">(</span><span class="n">pcmd</span><span class="p">))</span> <span class="o">=</span> <span class="n">ELS_CMD_LS_RJT</span><span class="p">;</span>
	<span class="n">pcmd</span> <span class="o">+=</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">uint32_t</span><span class="p">);</span>
	<span class="o">*</span><span class="p">((</span><span class="kt">uint32_t</span> <span class="o">*</span><span class="p">)</span> <span class="p">(</span><span class="n">pcmd</span><span class="p">))</span> <span class="o">=</span> <span class="n">rejectError</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">mbox</span><span class="p">)</span>
		<span class="n">elsiocb</span><span class="o">-&gt;</span><span class="n">context_un</span><span class="p">.</span><span class="n">mbox</span> <span class="o">=</span> <span class="n">mbox</span><span class="p">;</span>

	<span class="cm">/* Xmit ELS RJT &lt;err&gt; response tag &lt;ulpIoTag&gt; */</span>
	<span class="n">lpfc_printf_vlog</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">KERN_INFO</span><span class="p">,</span> <span class="n">LOG_ELS</span><span class="p">,</span>
			 <span class="s">&quot;0129 Xmit ELS RJT x%x response tag x%x &quot;</span>
			 <span class="s">&quot;xri x%x, did x%x, nlp_flag x%x, nlp_state x%x, &quot;</span>
			 <span class="s">&quot;rpi x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			 <span class="n">rejectError</span><span class="p">,</span> <span class="n">elsiocb</span><span class="o">-&gt;</span><span class="n">iotag</span><span class="p">,</span>
			 <span class="n">elsiocb</span><span class="o">-&gt;</span><span class="n">iocb</span><span class="p">.</span><span class="n">ulpContext</span><span class="p">,</span> <span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_DID</span><span class="p">,</span>
			 <span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_flag</span><span class="p">,</span> <span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_state</span><span class="p">,</span> <span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_rpi</span><span class="p">);</span>
	<span class="n">lpfc_debugfs_disc_trc</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">LPFC_DISC_TRC_ELS_RSP</span><span class="p">,</span>
		<span class="s">&quot;Issue LS_RJT:    did:x%x flg:x%x err:x%x&quot;</span><span class="p">,</span>
		<span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_DID</span><span class="p">,</span> <span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_flag</span><span class="p">,</span> <span class="n">rejectError</span><span class="p">);</span>

	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">fc_stat</span><span class="p">.</span><span class="n">elsXmitLSRJT</span><span class="o">++</span><span class="p">;</span>
	<span class="n">elsiocb</span><span class="o">-&gt;</span><span class="n">iocb_cmpl</span> <span class="o">=</span> <span class="n">lpfc_cmpl_els_rsp</span><span class="p">;</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">lpfc_sli_issue_iocb</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">LPFC_ELS_RING</span><span class="p">,</span> <span class="n">elsiocb</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">==</span> <span class="n">IOCB_ERROR</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lpfc_els_free_iocb</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">elsiocb</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_els_rsp_adisc_acc - Prepare and issue acc response to adisc iocb cmd</span>
<span class="cm"> * @vport: pointer to a virtual N_Port data structure.</span>
<span class="cm"> * @oldiocb: pointer to the original lpfc command iocb data structure.</span>
<span class="cm"> * @ndlp: pointer to a node-list data structure.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine prepares and issues an Accept (ACC) response to Address</span>
<span class="cm"> * Discover (ADISC) ELS command. It simply prepares the payload of the IOCB</span>
<span class="cm"> * and invokes the lpfc_sli_issue_iocb() routine to send out the command.</span>
<span class="cm"> *</span>
<span class="cm"> * Note that, in lpfc_prep_els_iocb() routine, the reference count of ndlp</span>
<span class="cm"> * will be incremented by 1 for holding the ndlp and the reference to ndlp</span>
<span class="cm"> * will be stored into the context1 field of the IOCB for the completion</span>
<span class="cm"> * callback function to the ADISC Accept response ELS IOCB command.</span>
<span class="cm"> *</span>
<span class="cm"> * Return code</span>
<span class="cm"> *   0 - Successfully issued acc adisc response</span>
<span class="cm"> *   1 - Failed to issue adisc acc response</span>
<span class="cm"> **/</span>
<span class="kt">int</span>
<span class="nf">lpfc_els_rsp_adisc_acc</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="n">vport</span><span class="p">,</span> <span class="k">struct</span> <span class="n">lpfc_iocbq</span> <span class="o">*</span><span class="n">oldiocb</span><span class="p">,</span>
		       <span class="k">struct</span> <span class="n">lpfc_nodelist</span> <span class="o">*</span><span class="n">ndlp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpfc_hba</span>  <span class="o">*</span><span class="n">phba</span> <span class="o">=</span> <span class="n">vport</span><span class="o">-&gt;</span><span class="n">phba</span><span class="p">;</span>
	<span class="n">ADISC</span> <span class="o">*</span><span class="n">ap</span><span class="p">;</span>
	<span class="n">IOCB_t</span> <span class="o">*</span><span class="n">icmd</span><span class="p">,</span> <span class="o">*</span><span class="n">oldcmd</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_iocbq</span> <span class="o">*</span><span class="n">elsiocb</span><span class="p">;</span>
	<span class="kt">uint8_t</span> <span class="o">*</span><span class="n">pcmd</span><span class="p">;</span>
	<span class="kt">uint16_t</span> <span class="n">cmdsize</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">cmdsize</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">uint32_t</span><span class="p">)</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">ADISC</span><span class="p">);</span>
	<span class="n">elsiocb</span> <span class="o">=</span> <span class="n">lpfc_prep_els_iocb</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">cmdsize</span><span class="p">,</span> <span class="n">oldiocb</span><span class="o">-&gt;</span><span class="n">retry</span><span class="p">,</span> <span class="n">ndlp</span><span class="p">,</span>
				     <span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_DID</span><span class="p">,</span> <span class="n">ELS_CMD_ACC</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">elsiocb</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">icmd</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">elsiocb</span><span class="o">-&gt;</span><span class="n">iocb</span><span class="p">;</span>
	<span class="n">oldcmd</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">oldiocb</span><span class="o">-&gt;</span><span class="n">iocb</span><span class="p">;</span>
	<span class="n">icmd</span><span class="o">-&gt;</span><span class="n">ulpContext</span> <span class="o">=</span> <span class="n">oldcmd</span><span class="o">-&gt;</span><span class="n">ulpContext</span><span class="p">;</span>	<span class="cm">/* Xri / rx_id */</span>
	<span class="n">icmd</span><span class="o">-&gt;</span><span class="n">unsli3</span><span class="p">.</span><span class="n">rcvsli3</span><span class="p">.</span><span class="n">ox_id</span> <span class="o">=</span> <span class="n">oldcmd</span><span class="o">-&gt;</span><span class="n">unsli3</span><span class="p">.</span><span class="n">rcvsli3</span><span class="p">.</span><span class="n">ox_id</span><span class="p">;</span>

	<span class="cm">/* Xmit ADISC ACC response tag &lt;ulpIoTag&gt; */</span>
	<span class="n">lpfc_printf_vlog</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">KERN_INFO</span><span class="p">,</span> <span class="n">LOG_ELS</span><span class="p">,</span>
			 <span class="s">&quot;0130 Xmit ADISC ACC response iotag x%x xri: &quot;</span>
			 <span class="s">&quot;x%x, did x%x, nlp_flag x%x, nlp_state x%x rpi x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			 <span class="n">elsiocb</span><span class="o">-&gt;</span><span class="n">iotag</span><span class="p">,</span> <span class="n">elsiocb</span><span class="o">-&gt;</span><span class="n">iocb</span><span class="p">.</span><span class="n">ulpContext</span><span class="p">,</span>
			 <span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_DID</span><span class="p">,</span> <span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_flag</span><span class="p">,</span> <span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_state</span><span class="p">,</span>
			 <span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_rpi</span><span class="p">);</span>
	<span class="n">pcmd</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint8_t</span> <span class="o">*</span><span class="p">)</span> <span class="p">(((</span><span class="k">struct</span> <span class="n">lpfc_dmabuf</span> <span class="o">*</span><span class="p">)</span> <span class="n">elsiocb</span><span class="o">-&gt;</span><span class="n">context2</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">virt</span><span class="p">);</span>

	<span class="o">*</span><span class="p">((</span><span class="kt">uint32_t</span> <span class="o">*</span><span class="p">)</span> <span class="p">(</span><span class="n">pcmd</span><span class="p">))</span> <span class="o">=</span> <span class="n">ELS_CMD_ACC</span><span class="p">;</span>
	<span class="n">pcmd</span> <span class="o">+=</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">uint32_t</span><span class="p">);</span>

	<span class="n">ap</span> <span class="o">=</span> <span class="p">(</span><span class="n">ADISC</span> <span class="o">*</span><span class="p">)</span> <span class="p">(</span><span class="n">pcmd</span><span class="p">);</span>
	<span class="n">ap</span><span class="o">-&gt;</span><span class="n">hardAL_PA</span> <span class="o">=</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">fc_pref_ALPA</span><span class="p">;</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">portName</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_portname</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_name</span><span class="p">));</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">nodeName</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_nodename</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_name</span><span class="p">));</span>
	<span class="n">ap</span><span class="o">-&gt;</span><span class="n">DID</span> <span class="o">=</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_myDID</span><span class="p">);</span>

	<span class="n">lpfc_debugfs_disc_trc</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">LPFC_DISC_TRC_ELS_RSP</span><span class="p">,</span>
		<span class="s">&quot;Issue ACC ADISC: did:x%x flg:x%x&quot;</span><span class="p">,</span>
		<span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_DID</span><span class="p">,</span> <span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_flag</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">fc_stat</span><span class="p">.</span><span class="n">elsXmitACC</span><span class="o">++</span><span class="p">;</span>
	<span class="n">elsiocb</span><span class="o">-&gt;</span><span class="n">iocb_cmpl</span> <span class="o">=</span> <span class="n">lpfc_cmpl_els_rsp</span><span class="p">;</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">lpfc_sli_issue_iocb</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">LPFC_ELS_RING</span><span class="p">,</span> <span class="n">elsiocb</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">==</span> <span class="n">IOCB_ERROR</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lpfc_els_free_iocb</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">elsiocb</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_els_rsp_prli_acc - Prepare and issue acc response to prli iocb cmd</span>
<span class="cm"> * @vport: pointer to a virtual N_Port data structure.</span>
<span class="cm"> * @oldiocb: pointer to the original lpfc command iocb data structure.</span>
<span class="cm"> * @ndlp: pointer to a node-list data structure.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine prepares and issues an Accept (ACC) response to Process</span>
<span class="cm"> * Login (PRLI) ELS command. It simply prepares the payload of the IOCB</span>
<span class="cm"> * and invokes the lpfc_sli_issue_iocb() routine to send out the command.</span>
<span class="cm"> *</span>
<span class="cm"> * Note that, in lpfc_prep_els_iocb() routine, the reference count of ndlp</span>
<span class="cm"> * will be incremented by 1 for holding the ndlp and the reference to ndlp</span>
<span class="cm"> * will be stored into the context1 field of the IOCB for the completion</span>
<span class="cm"> * callback function to the PRLI Accept response ELS IOCB command.</span>
<span class="cm"> *</span>
<span class="cm"> * Return code</span>
<span class="cm"> *   0 - Successfully issued acc prli response</span>
<span class="cm"> *   1 - Failed to issue acc prli response</span>
<span class="cm"> **/</span>
<span class="kt">int</span>
<span class="nf">lpfc_els_rsp_prli_acc</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="n">vport</span><span class="p">,</span> <span class="k">struct</span> <span class="n">lpfc_iocbq</span> <span class="o">*</span><span class="n">oldiocb</span><span class="p">,</span>
		      <span class="k">struct</span> <span class="n">lpfc_nodelist</span> <span class="o">*</span><span class="n">ndlp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpfc_hba</span>  <span class="o">*</span><span class="n">phba</span> <span class="o">=</span> <span class="n">vport</span><span class="o">-&gt;</span><span class="n">phba</span><span class="p">;</span>
	<span class="n">PRLI</span> <span class="o">*</span><span class="n">npr</span><span class="p">;</span>
	<span class="n">lpfc_vpd_t</span> <span class="o">*</span><span class="n">vpd</span><span class="p">;</span>
	<span class="n">IOCB_t</span> <span class="o">*</span><span class="n">icmd</span><span class="p">;</span>
	<span class="n">IOCB_t</span> <span class="o">*</span><span class="n">oldcmd</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_iocbq</span> <span class="o">*</span><span class="n">elsiocb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_sli</span> <span class="o">*</span><span class="n">psli</span><span class="p">;</span>
	<span class="kt">uint8_t</span> <span class="o">*</span><span class="n">pcmd</span><span class="p">;</span>
	<span class="kt">uint16_t</span> <span class="n">cmdsize</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">psli</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli</span><span class="p">;</span>

	<span class="n">cmdsize</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">uint32_t</span><span class="p">)</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">PRLI</span><span class="p">);</span>
	<span class="n">elsiocb</span> <span class="o">=</span> <span class="n">lpfc_prep_els_iocb</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">cmdsize</span><span class="p">,</span> <span class="n">oldiocb</span><span class="o">-&gt;</span><span class="n">retry</span><span class="p">,</span> <span class="n">ndlp</span><span class="p">,</span>
		<span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_DID</span><span class="p">,</span> <span class="p">(</span><span class="n">ELS_CMD_ACC</span> <span class="o">|</span> <span class="p">(</span><span class="n">ELS_CMD_PRLI</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">ELS_RSP_MASK</span><span class="p">)));</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">elsiocb</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">icmd</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">elsiocb</span><span class="o">-&gt;</span><span class="n">iocb</span><span class="p">;</span>
	<span class="n">oldcmd</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">oldiocb</span><span class="o">-&gt;</span><span class="n">iocb</span><span class="p">;</span>
	<span class="n">icmd</span><span class="o">-&gt;</span><span class="n">ulpContext</span> <span class="o">=</span> <span class="n">oldcmd</span><span class="o">-&gt;</span><span class="n">ulpContext</span><span class="p">;</span>	<span class="cm">/* Xri / rx_id */</span>
	<span class="n">icmd</span><span class="o">-&gt;</span><span class="n">unsli3</span><span class="p">.</span><span class="n">rcvsli3</span><span class="p">.</span><span class="n">ox_id</span> <span class="o">=</span> <span class="n">oldcmd</span><span class="o">-&gt;</span><span class="n">unsli3</span><span class="p">.</span><span class="n">rcvsli3</span><span class="p">.</span><span class="n">ox_id</span><span class="p">;</span>

	<span class="cm">/* Xmit PRLI ACC response tag &lt;ulpIoTag&gt; */</span>
	<span class="n">lpfc_printf_vlog</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">KERN_INFO</span><span class="p">,</span> <span class="n">LOG_ELS</span><span class="p">,</span>
			 <span class="s">&quot;0131 Xmit PRLI ACC response tag x%x xri x%x, &quot;</span>
			 <span class="s">&quot;did x%x, nlp_flag x%x, nlp_state x%x, rpi x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			 <span class="n">elsiocb</span><span class="o">-&gt;</span><span class="n">iotag</span><span class="p">,</span> <span class="n">elsiocb</span><span class="o">-&gt;</span><span class="n">iocb</span><span class="p">.</span><span class="n">ulpContext</span><span class="p">,</span>
			 <span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_DID</span><span class="p">,</span> <span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_flag</span><span class="p">,</span> <span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_state</span><span class="p">,</span>
			 <span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_rpi</span><span class="p">);</span>
	<span class="n">pcmd</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint8_t</span> <span class="o">*</span><span class="p">)</span> <span class="p">(((</span><span class="k">struct</span> <span class="n">lpfc_dmabuf</span> <span class="o">*</span><span class="p">)</span> <span class="n">elsiocb</span><span class="o">-&gt;</span><span class="n">context2</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">virt</span><span class="p">);</span>

	<span class="o">*</span><span class="p">((</span><span class="kt">uint32_t</span> <span class="o">*</span><span class="p">)</span> <span class="p">(</span><span class="n">pcmd</span><span class="p">))</span> <span class="o">=</span> <span class="p">(</span><span class="n">ELS_CMD_ACC</span> <span class="o">|</span> <span class="p">(</span><span class="n">ELS_CMD_PRLI</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">ELS_RSP_MASK</span><span class="p">));</span>
	<span class="n">pcmd</span> <span class="o">+=</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">uint32_t</span><span class="p">);</span>

	<span class="cm">/* For PRLI, remainder of payload is PRLI parameter page */</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">pcmd</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">PRLI</span><span class="p">));</span>

	<span class="n">npr</span> <span class="o">=</span> <span class="p">(</span><span class="n">PRLI</span> <span class="o">*</span><span class="p">)</span> <span class="n">pcmd</span><span class="p">;</span>
	<span class="n">vpd</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">vpd</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * If the remote port is a target and our firmware version is 3.20 or</span>
<span class="cm">	 * later, set the following bits for FC-TAPE support.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_type</span> <span class="o">&amp;</span> <span class="n">NLP_FCP_TARGET</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">vpd</span><span class="o">-&gt;</span><span class="n">rev</span><span class="p">.</span><span class="n">feaLevelHigh</span> <span class="o">&gt;=</span> <span class="mh">0x02</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">npr</span><span class="o">-&gt;</span><span class="n">ConfmComplAllowed</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">npr</span><span class="o">-&gt;</span><span class="n">Retry</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">npr</span><span class="o">-&gt;</span><span class="n">TaskRetryIdReq</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">npr</span><span class="o">-&gt;</span><span class="n">acceptRspCode</span> <span class="o">=</span> <span class="n">PRLI_REQ_EXECUTED</span><span class="p">;</span>
	<span class="n">npr</span><span class="o">-&gt;</span><span class="n">estabImagePair</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">npr</span><span class="o">-&gt;</span><span class="n">readXferRdyDis</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">npr</span><span class="o">-&gt;</span><span class="n">ConfmComplAllowed</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">npr</span><span class="o">-&gt;</span><span class="n">prliType</span> <span class="o">=</span> <span class="n">PRLI_FCP_TYPE</span><span class="p">;</span>
	<span class="n">npr</span><span class="o">-&gt;</span><span class="n">initiatorFunc</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">lpfc_debugfs_disc_trc</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">LPFC_DISC_TRC_ELS_RSP</span><span class="p">,</span>
		<span class="s">&quot;Issue ACC PRLI:  did:x%x flg:x%x&quot;</span><span class="p">,</span>
		<span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_DID</span><span class="p">,</span> <span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_flag</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">fc_stat</span><span class="p">.</span><span class="n">elsXmitACC</span><span class="o">++</span><span class="p">;</span>
	<span class="n">elsiocb</span><span class="o">-&gt;</span><span class="n">iocb_cmpl</span> <span class="o">=</span> <span class="n">lpfc_cmpl_els_rsp</span><span class="p">;</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">lpfc_sli_issue_iocb</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">LPFC_ELS_RING</span><span class="p">,</span> <span class="n">elsiocb</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">==</span> <span class="n">IOCB_ERROR</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lpfc_els_free_iocb</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">elsiocb</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_els_rsp_rnid_acc - Issue rnid acc response iocb command</span>
<span class="cm"> * @vport: pointer to a virtual N_Port data structure.</span>
<span class="cm"> * @format: rnid command format.</span>
<span class="cm"> * @oldiocb: pointer to the original lpfc command iocb data structure.</span>
<span class="cm"> * @ndlp: pointer to a node-list data structure.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine issues a Request Node Identification Data (RNID) Accept</span>
<span class="cm"> * (ACC) response. It constructs the RNID ACC response command according to</span>
<span class="cm"> * the proper @format and then calls the lpfc_sli_issue_iocb() routine to</span>
<span class="cm"> * issue the response. Note that this command does not need to hold the ndlp</span>
<span class="cm"> * reference count for the callback. So, the ndlp reference count taken by</span>
<span class="cm"> * the lpfc_prep_els_iocb() routine is put back and the context1 field of</span>
<span class="cm"> * IOCB is set to NULL to indicate to the lpfc_els_free_iocb() routine that</span>
<span class="cm"> * there is no ndlp reference available.</span>
<span class="cm"> *</span>
<span class="cm"> * Note that, in lpfc_prep_els_iocb() routine, the reference count of ndlp</span>
<span class="cm"> * will be incremented by 1 for holding the ndlp and the reference to ndlp</span>
<span class="cm"> * will be stored into the context1 field of the IOCB for the completion</span>
<span class="cm"> * callback function. However, for the RNID Accept Response ELS command,</span>
<span class="cm"> * this is undone later by this routine after the IOCB is allocated.</span>
<span class="cm"> *</span>
<span class="cm"> * Return code</span>
<span class="cm"> *   0 - Successfully issued acc rnid response</span>
<span class="cm"> *   1 - Failed to issue acc rnid response</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">lpfc_els_rsp_rnid_acc</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="n">vport</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="n">format</span><span class="p">,</span>
		      <span class="k">struct</span> <span class="n">lpfc_iocbq</span> <span class="o">*</span><span class="n">oldiocb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">lpfc_nodelist</span> <span class="o">*</span><span class="n">ndlp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpfc_hba</span>  <span class="o">*</span><span class="n">phba</span> <span class="o">=</span> <span class="n">vport</span><span class="o">-&gt;</span><span class="n">phba</span><span class="p">;</span>
	<span class="n">RNID</span> <span class="o">*</span><span class="n">rn</span><span class="p">;</span>
	<span class="n">IOCB_t</span> <span class="o">*</span><span class="n">icmd</span><span class="p">,</span> <span class="o">*</span><span class="n">oldcmd</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_iocbq</span> <span class="o">*</span><span class="n">elsiocb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_sli</span> <span class="o">*</span><span class="n">psli</span><span class="p">;</span>
	<span class="kt">uint8_t</span> <span class="o">*</span><span class="n">pcmd</span><span class="p">;</span>
	<span class="kt">uint16_t</span> <span class="n">cmdsize</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">psli</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli</span><span class="p">;</span>
	<span class="n">cmdsize</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">uint32_t</span><span class="p">)</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">uint32_t</span><span class="p">)</span>
					<span class="o">+</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_name</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">format</span><span class="p">)</span>
		<span class="n">cmdsize</span> <span class="o">+=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">RNID_TOP_DISC</span><span class="p">);</span>

	<span class="n">elsiocb</span> <span class="o">=</span> <span class="n">lpfc_prep_els_iocb</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">cmdsize</span><span class="p">,</span> <span class="n">oldiocb</span><span class="o">-&gt;</span><span class="n">retry</span><span class="p">,</span> <span class="n">ndlp</span><span class="p">,</span>
				     <span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_DID</span><span class="p">,</span> <span class="n">ELS_CMD_ACC</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">elsiocb</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">icmd</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">elsiocb</span><span class="o">-&gt;</span><span class="n">iocb</span><span class="p">;</span>
	<span class="n">oldcmd</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">oldiocb</span><span class="o">-&gt;</span><span class="n">iocb</span><span class="p">;</span>
	<span class="n">icmd</span><span class="o">-&gt;</span><span class="n">ulpContext</span> <span class="o">=</span> <span class="n">oldcmd</span><span class="o">-&gt;</span><span class="n">ulpContext</span><span class="p">;</span>	<span class="cm">/* Xri / rx_id */</span>
	<span class="n">icmd</span><span class="o">-&gt;</span><span class="n">unsli3</span><span class="p">.</span><span class="n">rcvsli3</span><span class="p">.</span><span class="n">ox_id</span> <span class="o">=</span> <span class="n">oldcmd</span><span class="o">-&gt;</span><span class="n">unsli3</span><span class="p">.</span><span class="n">rcvsli3</span><span class="p">.</span><span class="n">ox_id</span><span class="p">;</span>

	<span class="cm">/* Xmit RNID ACC response tag &lt;ulpIoTag&gt; */</span>
	<span class="n">lpfc_printf_vlog</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">KERN_INFO</span><span class="p">,</span> <span class="n">LOG_ELS</span><span class="p">,</span>
			 <span class="s">&quot;0132 Xmit RNID ACC response tag x%x xri x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			 <span class="n">elsiocb</span><span class="o">-&gt;</span><span class="n">iotag</span><span class="p">,</span> <span class="n">elsiocb</span><span class="o">-&gt;</span><span class="n">iocb</span><span class="p">.</span><span class="n">ulpContext</span><span class="p">);</span>
	<span class="n">pcmd</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint8_t</span> <span class="o">*</span><span class="p">)</span> <span class="p">(((</span><span class="k">struct</span> <span class="n">lpfc_dmabuf</span> <span class="o">*</span><span class="p">)</span> <span class="n">elsiocb</span><span class="o">-&gt;</span><span class="n">context2</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">virt</span><span class="p">);</span>
	<span class="o">*</span><span class="p">((</span><span class="kt">uint32_t</span> <span class="o">*</span><span class="p">)</span> <span class="p">(</span><span class="n">pcmd</span><span class="p">))</span> <span class="o">=</span> <span class="n">ELS_CMD_ACC</span><span class="p">;</span>
	<span class="n">pcmd</span> <span class="o">+=</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">uint32_t</span><span class="p">);</span>

	<span class="n">memset</span><span class="p">(</span><span class="n">pcmd</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">RNID</span><span class="p">));</span>
	<span class="n">rn</span> <span class="o">=</span> <span class="p">(</span><span class="n">RNID</span> <span class="o">*</span><span class="p">)</span> <span class="p">(</span><span class="n">pcmd</span><span class="p">);</span>
	<span class="n">rn</span><span class="o">-&gt;</span><span class="n">Format</span> <span class="o">=</span> <span class="n">format</span><span class="p">;</span>
	<span class="n">rn</span><span class="o">-&gt;</span><span class="n">CommonLen</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_name</span><span class="p">));</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rn</span><span class="o">-&gt;</span><span class="n">portName</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_portname</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_name</span><span class="p">));</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rn</span><span class="o">-&gt;</span><span class="n">nodeName</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_nodename</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_name</span><span class="p">));</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">format</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="mi">0</span>:
		<span class="n">rn</span><span class="o">-&gt;</span><span class="n">SpecificLen</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">RNID_TOPOLOGY_DISC</span>:
		<span class="n">rn</span><span class="o">-&gt;</span><span class="n">SpecificLen</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">RNID_TOP_DISC</span><span class="p">);</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rn</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">topologyDisc</span><span class="p">.</span><span class="n">portName</span><span class="p">,</span>
		       <span class="o">&amp;</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_portname</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_name</span><span class="p">));</span>
		<span class="n">rn</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">topologyDisc</span><span class="p">.</span><span class="n">unitType</span> <span class="o">=</span> <span class="n">RNID_HBA</span><span class="p">;</span>
		<span class="n">rn</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">topologyDisc</span><span class="p">.</span><span class="n">physPort</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">rn</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">topologyDisc</span><span class="p">.</span><span class="n">attachedNodes</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">rn</span><span class="o">-&gt;</span><span class="n">CommonLen</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">rn</span><span class="o">-&gt;</span><span class="n">SpecificLen</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">lpfc_debugfs_disc_trc</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">LPFC_DISC_TRC_ELS_RSP</span><span class="p">,</span>
		<span class="s">&quot;Issue ACC RNID:  did:x%x flg:x%x&quot;</span><span class="p">,</span>
		<span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_DID</span><span class="p">,</span> <span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_flag</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">fc_stat</span><span class="p">.</span><span class="n">elsXmitACC</span><span class="o">++</span><span class="p">;</span>
	<span class="n">elsiocb</span><span class="o">-&gt;</span><span class="n">iocb_cmpl</span> <span class="o">=</span> <span class="n">lpfc_cmpl_els_rsp</span><span class="p">;</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">lpfc_sli_issue_iocb</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">LPFC_ELS_RING</span><span class="p">,</span> <span class="n">elsiocb</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">==</span> <span class="n">IOCB_ERROR</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lpfc_els_free_iocb</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">elsiocb</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_els_clear_rrq - Clear the rq that this rrq describes.</span>
<span class="cm"> * @vport: pointer to a virtual N_Port data structure.</span>
<span class="cm"> * @iocb: pointer to the lpfc command iocb data structure.</span>
<span class="cm"> * @ndlp: pointer to a node-list data structure.</span>
<span class="cm"> *</span>
<span class="cm"> * Return</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">lpfc_els_clear_rrq</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="n">vport</span><span class="p">,</span>
      <span class="k">struct</span> <span class="n">lpfc_iocbq</span> <span class="o">*</span><span class="n">iocb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">lpfc_nodelist</span> <span class="o">*</span><span class="n">ndlp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpfc_hba</span>  <span class="o">*</span><span class="n">phba</span> <span class="o">=</span> <span class="n">vport</span><span class="o">-&gt;</span><span class="n">phba</span><span class="p">;</span>
	<span class="kt">uint8_t</span> <span class="o">*</span><span class="n">pcmd</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">RRQ</span> <span class="o">*</span><span class="n">rrq</span><span class="p">;</span>
	<span class="kt">uint16_t</span> <span class="n">rxid</span><span class="p">;</span>
	<span class="kt">uint16_t</span> <span class="n">xri</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_node_rrq</span> <span class="o">*</span><span class="n">prrq</span><span class="p">;</span>


	<span class="n">pcmd</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint8_t</span> <span class="o">*</span><span class="p">)</span> <span class="p">(((</span><span class="k">struct</span> <span class="n">lpfc_dmabuf</span> <span class="o">*</span><span class="p">)</span> <span class="n">iocb</span><span class="o">-&gt;</span><span class="n">context2</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">virt</span><span class="p">);</span>
	<span class="n">pcmd</span> <span class="o">+=</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">uint32_t</span><span class="p">);</span>
	<span class="n">rrq</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">RRQ</span> <span class="o">*</span><span class="p">)</span><span class="n">pcmd</span><span class="p">;</span>
	<span class="n">rrq</span><span class="o">-&gt;</span><span class="n">rrq_exchg</span> <span class="o">=</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">rrq</span><span class="o">-&gt;</span><span class="n">rrq_exchg</span><span class="p">);</span>
	<span class="n">rxid</span> <span class="o">=</span> <span class="n">bf_get</span><span class="p">(</span><span class="n">rrq_rxid</span><span class="p">,</span> <span class="n">rrq</span><span class="p">);</span>

	<span class="n">lpfc_printf_vlog</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">KERN_INFO</span><span class="p">,</span> <span class="n">LOG_ELS</span><span class="p">,</span>
			<span class="s">&quot;2883 Clear RRQ for SID:x%x OXID:x%x RXID:x%x&quot;</span>
			<span class="s">&quot; x%x x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">bf_get</span><span class="p">(</span><span class="n">rrq_did</span><span class="p">,</span> <span class="n">rrq</span><span class="p">)),</span>
			<span class="n">bf_get</span><span class="p">(</span><span class="n">rrq_oxid</span><span class="p">,</span> <span class="n">rrq</span><span class="p">),</span>
			<span class="n">rxid</span><span class="p">,</span>
			<span class="n">iocb</span><span class="o">-&gt;</span><span class="n">iotag</span><span class="p">,</span> <span class="n">iocb</span><span class="o">-&gt;</span><span class="n">iocb</span><span class="p">.</span><span class="n">ulpContext</span><span class="p">);</span>

	<span class="n">lpfc_debugfs_disc_trc</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">LPFC_DISC_TRC_ELS_RSP</span><span class="p">,</span>
		<span class="s">&quot;Clear RRQ:  did:x%x flg:x%x exchg:x%.08x&quot;</span><span class="p">,</span>
		<span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_DID</span><span class="p">,</span> <span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_flag</span><span class="p">,</span> <span class="n">rrq</span><span class="o">-&gt;</span><span class="n">rrq_exchg</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_myDID</span> <span class="o">==</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">bf_get</span><span class="p">(</span><span class="n">rrq_did</span><span class="p">,</span> <span class="n">rrq</span><span class="p">)))</span>
		<span class="n">xri</span> <span class="o">=</span> <span class="n">bf_get</span><span class="p">(</span><span class="n">rrq_oxid</span><span class="p">,</span> <span class="n">rrq</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">xri</span> <span class="o">=</span> <span class="n">rxid</span><span class="p">;</span>
	<span class="n">prrq</span> <span class="o">=</span> <span class="n">lpfc_get_active_rrq</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">xri</span><span class="p">,</span> <span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_DID</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">prrq</span><span class="p">)</span>
		<span class="n">lpfc_clr_rrq_active</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">xri</span><span class="p">,</span> <span class="n">prrq</span><span class="p">);</span>
	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_els_rsp_echo_acc - Issue echo acc response</span>
<span class="cm"> * @vport: pointer to a virtual N_Port data structure.</span>
<span class="cm"> * @data: pointer to echo data to return in the accept.</span>
<span class="cm"> * @oldiocb: pointer to the original lpfc command iocb data structure.</span>
<span class="cm"> * @ndlp: pointer to a node-list data structure.</span>
<span class="cm"> *</span>
<span class="cm"> * Return code</span>
<span class="cm"> *   0 - Successfully issued acc echo response</span>
<span class="cm"> *   1 - Failed to issue acc echo response</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">lpfc_els_rsp_echo_acc</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="n">vport</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span>
		      <span class="k">struct</span> <span class="n">lpfc_iocbq</span> <span class="o">*</span><span class="n">oldiocb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">lpfc_nodelist</span> <span class="o">*</span><span class="n">ndlp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpfc_hba</span>  <span class="o">*</span><span class="n">phba</span> <span class="o">=</span> <span class="n">vport</span><span class="o">-&gt;</span><span class="n">phba</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_iocbq</span> <span class="o">*</span><span class="n">elsiocb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_sli</span> <span class="o">*</span><span class="n">psli</span><span class="p">;</span>
	<span class="kt">uint8_t</span> <span class="o">*</span><span class="n">pcmd</span><span class="p">;</span>
	<span class="kt">uint16_t</span> <span class="n">cmdsize</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">psli</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli</span><span class="p">;</span>
	<span class="n">cmdsize</span> <span class="o">=</span> <span class="n">oldiocb</span><span class="o">-&gt;</span><span class="n">iocb</span><span class="p">.</span><span class="n">unsli3</span><span class="p">.</span><span class="n">rcvsli3</span><span class="p">.</span><span class="n">acc_len</span><span class="p">;</span>

	<span class="cm">/* The accumulated length can exceed the BPL_SIZE.  For</span>
<span class="cm">	 * now, use this as the limit</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cmdsize</span> <span class="o">&gt;</span> <span class="n">LPFC_BPL_SIZE</span><span class="p">)</span>
		<span class="n">cmdsize</span> <span class="o">=</span> <span class="n">LPFC_BPL_SIZE</span><span class="p">;</span>
	<span class="n">elsiocb</span> <span class="o">=</span> <span class="n">lpfc_prep_els_iocb</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">cmdsize</span><span class="p">,</span> <span class="n">oldiocb</span><span class="o">-&gt;</span><span class="n">retry</span><span class="p">,</span> <span class="n">ndlp</span><span class="p">,</span>
				     <span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_DID</span><span class="p">,</span> <span class="n">ELS_CMD_ACC</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">elsiocb</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">elsiocb</span><span class="o">-&gt;</span><span class="n">iocb</span><span class="p">.</span><span class="n">ulpContext</span> <span class="o">=</span> <span class="n">oldiocb</span><span class="o">-&gt;</span><span class="n">iocb</span><span class="p">.</span><span class="n">ulpContext</span><span class="p">;</span>  <span class="cm">/* Xri / rx_id */</span>
	<span class="n">elsiocb</span><span class="o">-&gt;</span><span class="n">iocb</span><span class="p">.</span><span class="n">unsli3</span><span class="p">.</span><span class="n">rcvsli3</span><span class="p">.</span><span class="n">ox_id</span> <span class="o">=</span> <span class="n">oldiocb</span><span class="o">-&gt;</span><span class="n">iocb</span><span class="p">.</span><span class="n">unsli3</span><span class="p">.</span><span class="n">rcvsli3</span><span class="p">.</span><span class="n">ox_id</span><span class="p">;</span>

	<span class="cm">/* Xmit ECHO ACC response tag &lt;ulpIoTag&gt; */</span>
	<span class="n">lpfc_printf_vlog</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">KERN_INFO</span><span class="p">,</span> <span class="n">LOG_ELS</span><span class="p">,</span>
			 <span class="s">&quot;2876 Xmit ECHO ACC response tag x%x xri x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			 <span class="n">elsiocb</span><span class="o">-&gt;</span><span class="n">iotag</span><span class="p">,</span> <span class="n">elsiocb</span><span class="o">-&gt;</span><span class="n">iocb</span><span class="p">.</span><span class="n">ulpContext</span><span class="p">);</span>
	<span class="n">pcmd</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint8_t</span> <span class="o">*</span><span class="p">)</span> <span class="p">(((</span><span class="k">struct</span> <span class="n">lpfc_dmabuf</span> <span class="o">*</span><span class="p">)</span> <span class="n">elsiocb</span><span class="o">-&gt;</span><span class="n">context2</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">virt</span><span class="p">);</span>
	<span class="o">*</span><span class="p">((</span><span class="kt">uint32_t</span> <span class="o">*</span><span class="p">)</span> <span class="p">(</span><span class="n">pcmd</span><span class="p">))</span> <span class="o">=</span> <span class="n">ELS_CMD_ACC</span><span class="p">;</span>
	<span class="n">pcmd</span> <span class="o">+=</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">uint32_t</span><span class="p">);</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">pcmd</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">cmdsize</span> <span class="o">-</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">uint32_t</span><span class="p">));</span>

	<span class="n">lpfc_debugfs_disc_trc</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">LPFC_DISC_TRC_ELS_RSP</span><span class="p">,</span>
		<span class="s">&quot;Issue ACC ECHO:  did:x%x flg:x%x&quot;</span><span class="p">,</span>
		<span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_DID</span><span class="p">,</span> <span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_flag</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">fc_stat</span><span class="p">.</span><span class="n">elsXmitACC</span><span class="o">++</span><span class="p">;</span>
	<span class="n">elsiocb</span><span class="o">-&gt;</span><span class="n">iocb_cmpl</span> <span class="o">=</span> <span class="n">lpfc_cmpl_els_rsp</span><span class="p">;</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">lpfc_sli_issue_iocb</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">LPFC_ELS_RING</span><span class="p">,</span> <span class="n">elsiocb</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">==</span> <span class="n">IOCB_ERROR</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lpfc_els_free_iocb</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">elsiocb</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_els_disc_adisc - Issue remaining adisc iocbs to npr nodes of a vport</span>
<span class="cm"> * @vport: pointer to a host virtual N_Port data structure.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine issues Address Discover (ADISC) ELS commands to those</span>
<span class="cm"> * N_Ports which are in node port recovery state and ADISC has not been issued</span>
<span class="cm"> * for the @vport. Each time an ELS ADISC IOCB is issued by invoking the</span>
<span class="cm"> * lpfc_issue_els_adisc() routine, the per @vport number of discover count</span>
<span class="cm"> * (num_disc_nodes) shall be incremented. If the num_disc_nodes reaches a</span>
<span class="cm"> * pre-configured threshold (cfg_discovery_threads), the @vport fc_flag will</span>
<span class="cm"> * be marked with FC_NLP_MORE bit and the process of issuing remaining ADISC</span>
<span class="cm"> * IOCBs quit for later pick up. On the other hand, after walking through</span>
<span class="cm"> * all the ndlps with the @vport and there is none ADISC IOCB issued, the</span>
<span class="cm"> * @vport fc_flag shall be cleared with FC_NLP_MORE bit indicating there is</span>
<span class="cm"> * no more ADISC need to be sent.</span>
<span class="cm"> *</span>
<span class="cm"> * Return code</span>
<span class="cm"> *    The number of N_Ports with adisc issued.</span>
<span class="cm"> **/</span>
<span class="kt">int</span>
<span class="nf">lpfc_els_disc_adisc</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="n">vport</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span> <span class="o">=</span> <span class="n">lpfc_shost_from_vport</span><span class="p">(</span><span class="n">vport</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">lpfc_nodelist</span> <span class="o">*</span><span class="n">ndlp</span><span class="p">,</span> <span class="o">*</span><span class="n">next_ndlp</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">sentadisc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* go thru NPR nodes and issue any remaining ELS ADISCs */</span>
	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">ndlp</span><span class="p">,</span> <span class="n">next_ndlp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_nodes</span><span class="p">,</span> <span class="n">nlp_listp</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">NLP_CHK_NODE_ACT</span><span class="p">(</span><span class="n">ndlp</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_state</span> <span class="o">==</span> <span class="n">NLP_STE_NPR_NODE</span> <span class="o">&amp;&amp;</span>
		    <span class="p">(</span><span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_flag</span> <span class="o">&amp;</span> <span class="n">NLP_NPR_2B_DISC</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span>
		    <span class="p">(</span><span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_flag</span> <span class="o">&amp;</span> <span class="n">NLP_NPR_ADISC</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">spin_lock_irq</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>
			<span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_flag</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">NLP_NPR_ADISC</span><span class="p">;</span>
			<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>
			<span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_prev_state</span> <span class="o">=</span> <span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_state</span><span class="p">;</span>
			<span class="n">lpfc_nlp_set_state</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">ndlp</span><span class="p">,</span> <span class="n">NLP_STE_ADISC_ISSUE</span><span class="p">);</span>
			<span class="n">lpfc_issue_els_adisc</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">ndlp</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
			<span class="n">sentadisc</span><span class="o">++</span><span class="p">;</span>
			<span class="n">vport</span><span class="o">-&gt;</span><span class="n">num_disc_nodes</span><span class="o">++</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">num_disc_nodes</span> <span class="o">&gt;=</span>
			    <span class="n">vport</span><span class="o">-&gt;</span><span class="n">cfg_discovery_threads</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">spin_lock_irq</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>
				<span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_flag</span> <span class="o">|=</span> <span class="n">FC_NLP_MORE</span><span class="p">;</span>
				<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sentadisc</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_lock_irq</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>
		<span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_flag</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">FC_NLP_MORE</span><span class="p">;</span>
		<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">sentadisc</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_els_disc_plogi - Issue plogi for all npr nodes of a vport before adisc</span>
<span class="cm"> * @vport: pointer to a host virtual N_Port data structure.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine issues Port Login (PLOGI) ELS commands to all the N_Ports</span>
<span class="cm"> * which are in node port recovery state, with a @vport. Each time an ELS</span>
<span class="cm"> * ADISC PLOGI IOCB is issued by invoking the lpfc_issue_els_plogi() routine,</span>
<span class="cm"> * the per @vport number of discover count (num_disc_nodes) shall be</span>
<span class="cm"> * incremented. If the num_disc_nodes reaches a pre-configured threshold</span>
<span class="cm"> * (cfg_discovery_threads), the @vport fc_flag will be marked with FC_NLP_MORE</span>
<span class="cm"> * bit set and quit the process of issuing remaining ADISC PLOGIN IOCBs for</span>
<span class="cm"> * later pick up. On the other hand, after walking through all the ndlps with</span>
<span class="cm"> * the @vport and there is none ADISC PLOGI IOCB issued, the @vport fc_flag</span>
<span class="cm"> * shall be cleared with the FC_NLP_MORE bit indicating there is no more ADISC</span>
<span class="cm"> * PLOGI need to be sent.</span>
<span class="cm"> *</span>
<span class="cm"> * Return code</span>
<span class="cm"> *   The number of N_Ports with plogi issued.</span>
<span class="cm"> **/</span>
<span class="kt">int</span>
<span class="nf">lpfc_els_disc_plogi</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="n">vport</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span> <span class="o">=</span> <span class="n">lpfc_shost_from_vport</span><span class="p">(</span><span class="n">vport</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">lpfc_nodelist</span> <span class="o">*</span><span class="n">ndlp</span><span class="p">,</span> <span class="o">*</span><span class="n">next_ndlp</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">sentplogi</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* go thru NPR nodes and issue any remaining ELS PLOGIs */</span>
	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">ndlp</span><span class="p">,</span> <span class="n">next_ndlp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_nodes</span><span class="p">,</span> <span class="n">nlp_listp</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">NLP_CHK_NODE_ACT</span><span class="p">(</span><span class="n">ndlp</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_state</span> <span class="o">==</span> <span class="n">NLP_STE_NPR_NODE</span> <span class="o">&amp;&amp;</span>
		    <span class="p">(</span><span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_flag</span> <span class="o">&amp;</span> <span class="n">NLP_NPR_2B_DISC</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span>
		    <span class="p">(</span><span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_flag</span> <span class="o">&amp;</span> <span class="n">NLP_DELAY_TMO</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span>
		    <span class="p">(</span><span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_flag</span> <span class="o">&amp;</span> <span class="n">NLP_NPR_ADISC</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_prev_state</span> <span class="o">=</span> <span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_state</span><span class="p">;</span>
			<span class="n">lpfc_nlp_set_state</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">ndlp</span><span class="p">,</span> <span class="n">NLP_STE_PLOGI_ISSUE</span><span class="p">);</span>
			<span class="n">lpfc_issue_els_plogi</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_DID</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
			<span class="n">sentplogi</span><span class="o">++</span><span class="p">;</span>
			<span class="n">vport</span><span class="o">-&gt;</span><span class="n">num_disc_nodes</span><span class="o">++</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">num_disc_nodes</span> <span class="o">&gt;=</span>
			    <span class="n">vport</span><span class="o">-&gt;</span><span class="n">cfg_discovery_threads</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">spin_lock_irq</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>
				<span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_flag</span> <span class="o">|=</span> <span class="n">FC_NLP_MORE</span><span class="p">;</span>
				<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sentplogi</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lpfc_set_disctmo</span><span class="p">(</span><span class="n">vport</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="n">spin_lock_irq</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>
		<span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_flag</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">FC_NLP_MORE</span><span class="p">;</span>
		<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">sentplogi</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_els_flush_rscn - Clean up any rscn activities with a vport</span>
<span class="cm"> * @vport: pointer to a host virtual N_Port data structure.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine cleans up any Registration State Change Notification</span>
<span class="cm"> * (RSCN) activity with a @vport. Note that the fc_rscn_flush flag of the</span>
<span class="cm"> * @vport together with the host_lock is used to prevent multiple thread</span>
<span class="cm"> * trying to access the RSCN array on a same @vport at the same time.</span>
<span class="cm"> **/</span>
<span class="kt">void</span>
<span class="nf">lpfc_els_flush_rscn</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="n">vport</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span> <span class="o">=</span> <span class="n">lpfc_shost_from_vport</span><span class="p">(</span><span class="n">vport</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">lpfc_hba</span>  <span class="o">*</span><span class="n">phba</span> <span class="o">=</span> <span class="n">vport</span><span class="o">-&gt;</span><span class="n">phba</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_rscn_flush</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Another thread is walking fc_rscn_id_list on this vport */</span>
		<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* Indicate we are walking lpfc_els_flush_rscn on this vport */</span>
	<span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_rscn_flush</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_rscn_id_cnt</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lpfc_in_buf_free</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_rscn_id_list</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
		<span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_rscn_id_list</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>
	<span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_rscn_id_cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_flag</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">FC_RSCN_MODE</span> <span class="o">|</span> <span class="n">FC_RSCN_DISCOVERY</span><span class="p">);</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>
	<span class="n">lpfc_can_disctmo</span><span class="p">(</span><span class="n">vport</span><span class="p">);</span>
	<span class="cm">/* Indicate we are done walking this fc_rscn_id_list */</span>
	<span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_rscn_flush</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_rscn_payload_check - Check whether there is a pending rscn to a did</span>
<span class="cm"> * @vport: pointer to a host virtual N_Port data structure.</span>
<span class="cm"> * @did: remote destination port identifier.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine checks whether there is any pending Registration State</span>
<span class="cm"> * Configuration Notification (RSCN) to a @did on @vport.</span>
<span class="cm"> *</span>
<span class="cm"> * Return code</span>
<span class="cm"> *   None zero - The @did matched with a pending rscn</span>
<span class="cm"> *   0 - not able to match @did with a pending rscn</span>
<span class="cm"> **/</span>
<span class="kt">int</span>
<span class="nf">lpfc_rscn_payload_check</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="n">vport</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">did</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">D_ID</span> <span class="n">ns_did</span><span class="p">;</span>
	<span class="n">D_ID</span> <span class="n">rscn_did</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="o">*</span><span class="n">lp</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">payload_len</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span> <span class="o">=</span> <span class="n">lpfc_shost_from_vport</span><span class="p">(</span><span class="n">vport</span><span class="p">);</span>

	<span class="n">ns_did</span><span class="p">.</span><span class="n">un</span><span class="p">.</span><span class="n">word</span> <span class="o">=</span> <span class="n">did</span><span class="p">;</span>

	<span class="cm">/* Never match fabric nodes for RSCNs */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">did</span> <span class="o">&amp;</span> <span class="n">Fabric_DID_MASK</span><span class="p">)</span> <span class="o">==</span> <span class="n">Fabric_DID_MASK</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* If we are doing a FULL RSCN rediscovery, match everything */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_flag</span> <span class="o">&amp;</span> <span class="n">FC_RSCN_DISCOVERY</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">did</span><span class="p">;</span>

	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_rscn_flush</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Another thread is walking fc_rscn_id_list on this vport */</span>
		<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* Indicate we are walking fc_rscn_id_list on this vport */</span>
	<span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_rscn_flush</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_rscn_id_cnt</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lp</span> <span class="o">=</span> <span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_rscn_id_list</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">virt</span><span class="p">;</span>
		<span class="n">payload_len</span> <span class="o">=</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="o">*</span><span class="n">lp</span><span class="o">++</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">ELS_CMD_MASK</span><span class="p">);</span>
		<span class="n">payload_len</span> <span class="o">-=</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">uint32_t</span><span class="p">);</span>	<span class="cm">/* take off word 0 */</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">payload_len</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">rscn_did</span><span class="p">.</span><span class="n">un</span><span class="p">.</span><span class="n">word</span> <span class="o">=</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="o">*</span><span class="n">lp</span><span class="o">++</span><span class="p">);</span>
			<span class="n">payload_len</span> <span class="o">-=</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">uint32_t</span><span class="p">);</span>
			<span class="k">switch</span> <span class="p">(</span><span class="n">rscn_did</span><span class="p">.</span><span class="n">un</span><span class="p">.</span><span class="n">b</span><span class="p">.</span><span class="n">resv</span> <span class="o">&amp;</span> <span class="n">RSCN_ADDRESS_FORMAT_MASK</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">case</span> <span class="n">RSCN_ADDRESS_FORMAT_PORT</span>:
				<span class="k">if</span> <span class="p">((</span><span class="n">ns_did</span><span class="p">.</span><span class="n">un</span><span class="p">.</span><span class="n">b</span><span class="p">.</span><span class="n">domain</span> <span class="o">==</span> <span class="n">rscn_did</span><span class="p">.</span><span class="n">un</span><span class="p">.</span><span class="n">b</span><span class="p">.</span><span class="n">domain</span><span class="p">)</span>
				    <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">ns_did</span><span class="p">.</span><span class="n">un</span><span class="p">.</span><span class="n">b</span><span class="p">.</span><span class="n">area</span> <span class="o">==</span> <span class="n">rscn_did</span><span class="p">.</span><span class="n">un</span><span class="p">.</span><span class="n">b</span><span class="p">.</span><span class="n">area</span><span class="p">)</span>
				    <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">ns_did</span><span class="p">.</span><span class="n">un</span><span class="p">.</span><span class="n">b</span><span class="p">.</span><span class="n">id</span> <span class="o">==</span> <span class="n">rscn_did</span><span class="p">.</span><span class="n">un</span><span class="p">.</span><span class="n">b</span><span class="p">.</span><span class="n">id</span><span class="p">))</span>
					<span class="k">goto</span> <span class="n">return_did_out</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="k">case</span> <span class="n">RSCN_ADDRESS_FORMAT_AREA</span>:
				<span class="k">if</span> <span class="p">((</span><span class="n">ns_did</span><span class="p">.</span><span class="n">un</span><span class="p">.</span><span class="n">b</span><span class="p">.</span><span class="n">domain</span> <span class="o">==</span> <span class="n">rscn_did</span><span class="p">.</span><span class="n">un</span><span class="p">.</span><span class="n">b</span><span class="p">.</span><span class="n">domain</span><span class="p">)</span>
				    <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">ns_did</span><span class="p">.</span><span class="n">un</span><span class="p">.</span><span class="n">b</span><span class="p">.</span><span class="n">area</span> <span class="o">==</span> <span class="n">rscn_did</span><span class="p">.</span><span class="n">un</span><span class="p">.</span><span class="n">b</span><span class="p">.</span><span class="n">area</span><span class="p">))</span>
					<span class="k">goto</span> <span class="n">return_did_out</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="k">case</span> <span class="n">RSCN_ADDRESS_FORMAT_DOMAIN</span>:
				<span class="k">if</span> <span class="p">(</span><span class="n">ns_did</span><span class="p">.</span><span class="n">un</span><span class="p">.</span><span class="n">b</span><span class="p">.</span><span class="n">domain</span> <span class="o">==</span> <span class="n">rscn_did</span><span class="p">.</span><span class="n">un</span><span class="p">.</span><span class="n">b</span><span class="p">.</span><span class="n">domain</span><span class="p">)</span>
					<span class="k">goto</span> <span class="n">return_did_out</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="k">case</span> <span class="n">RSCN_ADDRESS_FORMAT_FABRIC</span>:
				<span class="k">goto</span> <span class="n">return_did_out</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="cm">/* Indicate we are done with walking fc_rscn_id_list on this vport */</span>
	<span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_rscn_flush</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">return_did_out:</span>
	<span class="cm">/* Indicate we are done with walking fc_rscn_id_list on this vport */</span>
	<span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_rscn_flush</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">did</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_rscn_recovery_check - Send recovery event to vport nodes matching rscn</span>
<span class="cm"> * @vport: pointer to a host virtual N_Port data structure.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine sends recovery (NLP_EVT_DEVICE_RECOVERY) event to the</span>
<span class="cm"> * state machine for a @vport&#39;s nodes that are with pending RSCN (Registration</span>
<span class="cm"> * State Change Notification).</span>
<span class="cm"> *</span>
<span class="cm"> * Return code</span>
<span class="cm"> *   0 - Successful (currently alway return 0)</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">lpfc_rscn_recovery_check</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="n">vport</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpfc_nodelist</span> <span class="o">*</span><span class="n">ndlp</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="cm">/* Move all affected nodes by pending RSCNs to NPR state. */</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">ndlp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_nodes</span><span class="p">,</span> <span class="n">nlp_listp</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">NLP_CHK_NODE_ACT</span><span class="p">(</span><span class="n">ndlp</span><span class="p">)</span> <span class="o">||</span>
		    <span class="p">(</span><span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_state</span> <span class="o">==</span> <span class="n">NLP_STE_UNUSED_NODE</span><span class="p">)</span> <span class="o">||</span>
		    <span class="o">!</span><span class="n">lpfc_rscn_payload_check</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_DID</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="n">lpfc_disc_state_machine</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">ndlp</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span>
					<span class="n">NLP_EVT_DEVICE_RECOVERY</span><span class="p">);</span>
		<span class="n">lpfc_cancel_retry_delay_tmo</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">ndlp</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_send_rscn_event - Send an RSCN event to management application</span>
<span class="cm"> * @vport: pointer to a host virtual N_Port data structure.</span>
<span class="cm"> * @cmdiocb: pointer to lpfc command iocb data structure.</span>
<span class="cm"> *</span>
<span class="cm"> * lpfc_send_rscn_event sends an RSCN netlink event to management</span>
<span class="cm"> * applications.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">lpfc_send_rscn_event</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="n">vport</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">lpfc_iocbq</span> <span class="o">*</span><span class="n">cmdiocb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpfc_dmabuf</span> <span class="o">*</span><span class="n">pcmd</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span> <span class="o">=</span> <span class="n">lpfc_shost_from_vport</span><span class="p">(</span><span class="n">vport</span><span class="p">);</span>
	<span class="kt">uint32_t</span> <span class="o">*</span><span class="n">payload_ptr</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">payload_len</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_rscn_event_header</span> <span class="o">*</span><span class="n">rscn_event_data</span><span class="p">;</span>

	<span class="n">pcmd</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_dmabuf</span> <span class="o">*</span><span class="p">)</span> <span class="n">cmdiocb</span><span class="o">-&gt;</span><span class="n">context2</span><span class="p">;</span>
	<span class="n">payload_ptr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint32_t</span> <span class="o">*</span><span class="p">)</span> <span class="n">pcmd</span><span class="o">-&gt;</span><span class="n">virt</span><span class="p">;</span>
	<span class="n">payload_len</span> <span class="o">=</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="o">*</span><span class="n">payload_ptr</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">ELS_CMD_MASK</span><span class="p">);</span>

	<span class="n">rscn_event_data</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_rscn_event_header</span><span class="p">)</span> <span class="o">+</span>
		<span class="n">payload_len</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rscn_event_data</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lpfc_printf_vlog</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_ELS</span><span class="p">,</span>
			<span class="s">&quot;0147 Failed to allocate memory for RSCN event</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">rscn_event_data</span><span class="o">-&gt;</span><span class="n">event_type</span> <span class="o">=</span> <span class="n">FC_REG_RSCN_EVENT</span><span class="p">;</span>
	<span class="n">rscn_event_data</span><span class="o">-&gt;</span><span class="n">payload_length</span> <span class="o">=</span> <span class="n">payload_len</span><span class="p">;</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">rscn_event_data</span><span class="o">-&gt;</span><span class="n">rscn_payload</span><span class="p">,</span> <span class="n">payload_ptr</span><span class="p">,</span>
		<span class="n">payload_len</span><span class="p">);</span>

	<span class="n">fc_host_post_vendor_event</span><span class="p">(</span><span class="n">shost</span><span class="p">,</span>
		<span class="n">fc_get_event_number</span><span class="p">(),</span>
		<span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_els_event_header</span><span class="p">)</span> <span class="o">+</span> <span class="n">payload_len</span><span class="p">,</span>
		<span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">rscn_event_data</span><span class="p">,</span>
		<span class="n">LPFC_NL_VENDOR_ID</span><span class="p">);</span>

	<span class="n">kfree</span><span class="p">(</span><span class="n">rscn_event_data</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_els_rcv_rscn - Process an unsolicited rscn iocb</span>
<span class="cm"> * @vport: pointer to a host virtual N_Port data structure.</span>
<span class="cm"> * @cmdiocb: pointer to lpfc command iocb data structure.</span>
<span class="cm"> * @ndlp: pointer to a node-list data structure.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine processes an unsolicited RSCN (Registration State Change</span>
<span class="cm"> * Notification) IOCB. First, the payload of the unsolicited RSCN is walked</span>
<span class="cm"> * to invoke fc_host_post_event() routine to the FC transport layer. If the</span>
<span class="cm"> * discover state machine is about to begin discovery, it just accepts the</span>
<span class="cm"> * RSCN and the discovery process will satisfy the RSCN. If this RSCN only</span>
<span class="cm"> * contains N_Port IDs for other vports on this HBA, it just accepts the</span>
<span class="cm"> * RSCN and ignore processing it. If the state machine is in the recovery</span>
<span class="cm"> * state, the fc_rscn_id_list of this @vport is walked and the</span>
<span class="cm"> * lpfc_rscn_recovery_check() routine is invoked to send recovery event for</span>
<span class="cm"> * all nodes that match RSCN payload. Otherwise, the lpfc_els_handle_rscn()</span>
<span class="cm"> * routine is invoked to handle the RSCN event.</span>
<span class="cm"> *</span>
<span class="cm"> * Return code</span>
<span class="cm"> *   0 - Just sent the acc response</span>
<span class="cm"> *   1 - Sent the acc response and waited for name server completion</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">lpfc_els_rcv_rscn</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="n">vport</span><span class="p">,</span> <span class="k">struct</span> <span class="n">lpfc_iocbq</span> <span class="o">*</span><span class="n">cmdiocb</span><span class="p">,</span>
		  <span class="k">struct</span> <span class="n">lpfc_nodelist</span> <span class="o">*</span><span class="n">ndlp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span> <span class="o">=</span> <span class="n">lpfc_shost_from_vport</span><span class="p">(</span><span class="n">vport</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">lpfc_hba</span>  <span class="o">*</span><span class="n">phba</span> <span class="o">=</span> <span class="n">vport</span><span class="o">-&gt;</span><span class="n">phba</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_dmabuf</span> <span class="o">*</span><span class="n">pcmd</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="o">*</span><span class="n">lp</span><span class="p">,</span> <span class="o">*</span><span class="n">datap</span><span class="p">;</span>
	<span class="n">IOCB_t</span> <span class="o">*</span><span class="n">icmd</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">payload_len</span><span class="p">,</span> <span class="n">length</span><span class="p">,</span> <span class="n">nportid</span><span class="p">,</span> <span class="o">*</span><span class="n">cmd</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rscn_cnt</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rscn_id</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">hba_id</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">icmd</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">cmdiocb</span><span class="o">-&gt;</span><span class="n">iocb</span><span class="p">;</span>
	<span class="n">pcmd</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_dmabuf</span> <span class="o">*</span><span class="p">)</span> <span class="n">cmdiocb</span><span class="o">-&gt;</span><span class="n">context2</span><span class="p">;</span>
	<span class="n">lp</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint32_t</span> <span class="o">*</span><span class="p">)</span> <span class="n">pcmd</span><span class="o">-&gt;</span><span class="n">virt</span><span class="p">;</span>

	<span class="n">payload_len</span> <span class="o">=</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="o">*</span><span class="n">lp</span><span class="o">++</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">ELS_CMD_MASK</span><span class="p">);</span>
	<span class="n">payload_len</span> <span class="o">-=</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">uint32_t</span><span class="p">);</span>	<span class="cm">/* take off word 0 */</span>
	<span class="cm">/* RSCN received */</span>
	<span class="n">lpfc_printf_vlog</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">KERN_INFO</span><span class="p">,</span> <span class="n">LOG_DISCOVERY</span><span class="p">,</span>
			 <span class="s">&quot;0214 RSCN received Data: x%x x%x x%x x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			 <span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_flag</span><span class="p">,</span> <span class="n">payload_len</span><span class="p">,</span> <span class="o">*</span><span class="n">lp</span><span class="p">,</span>
			 <span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_rscn_id_cnt</span><span class="p">);</span>

	<span class="cm">/* Send an RSCN event to the management application */</span>
	<span class="n">lpfc_send_rscn_event</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">cmdiocb</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">payload_len</span><span class="o">/</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">uint32_t</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">fc_host_post_event</span><span class="p">(</span><span class="n">shost</span><span class="p">,</span> <span class="n">fc_get_event_number</span><span class="p">(),</span>
			<span class="n">FCH_EVT_RSCN</span><span class="p">,</span> <span class="n">lp</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>

	<span class="cm">/* If we are about to begin discovery, just ACC the RSCN.</span>
<span class="cm">	 * Discovery processing will satisfy it.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">port_state</span> <span class="o">&lt;=</span> <span class="n">LPFC_NS_QRY</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lpfc_debugfs_disc_trc</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">LPFC_DISC_TRC_ELS_UNSOL</span><span class="p">,</span>
			<span class="s">&quot;RCV RSCN ignore: did:x%x/ste:x%x flg:x%x&quot;</span><span class="p">,</span>
			<span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_DID</span><span class="p">,</span> <span class="n">vport</span><span class="o">-&gt;</span><span class="n">port_state</span><span class="p">,</span> <span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_flag</span><span class="p">);</span>

		<span class="n">lpfc_els_rsp_acc</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">ELS_CMD_ACC</span><span class="p">,</span> <span class="n">cmdiocb</span><span class="p">,</span> <span class="n">ndlp</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* If this RSCN just contains NPortIDs for other vports on this HBA,</span>
<span class="cm">	 * just ACC and ignore it.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli3_options</span> <span class="o">&amp;</span> <span class="n">LPFC_SLI3_NPIV_ENABLED</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		<span class="o">!</span><span class="p">(</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">cfg_peer_port_login</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">i</span> <span class="o">=</span> <span class="n">payload_len</span><span class="p">;</span>
		<span class="n">datap</span> <span class="o">=</span> <span class="n">lp</span><span class="p">;</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">nportid</span> <span class="o">=</span> <span class="o">*</span><span class="n">datap</span><span class="o">++</span><span class="p">;</span>
			<span class="n">nportid</span> <span class="o">=</span> <span class="p">((</span><span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">nportid</span><span class="p">))</span> <span class="o">&amp;</span> <span class="n">Mask_DID</span><span class="p">);</span>
			<span class="n">i</span> <span class="o">-=</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">uint32_t</span><span class="p">);</span>
			<span class="n">rscn_id</span><span class="o">++</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">lpfc_find_vport_by_did</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">nportid</span><span class="p">))</span>
				<span class="n">hba_id</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rscn_id</span> <span class="o">==</span> <span class="n">hba_id</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* ALL NPortIDs in RSCN are on HBA */</span>
			<span class="n">lpfc_printf_vlog</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">KERN_INFO</span><span class="p">,</span> <span class="n">LOG_DISCOVERY</span><span class="p">,</span>
					 <span class="s">&quot;0219 Ignore RSCN &quot;</span>
					 <span class="s">&quot;Data: x%x x%x x%x x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					 <span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_flag</span><span class="p">,</span> <span class="n">payload_len</span><span class="p">,</span>
					 <span class="o">*</span><span class="n">lp</span><span class="p">,</span> <span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_rscn_id_cnt</span><span class="p">);</span>
			<span class="n">lpfc_debugfs_disc_trc</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">LPFC_DISC_TRC_ELS_UNSOL</span><span class="p">,</span>
				<span class="s">&quot;RCV RSCN vport:  did:x%x/ste:x%x flg:x%x&quot;</span><span class="p">,</span>
				<span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_DID</span><span class="p">,</span> <span class="n">vport</span><span class="o">-&gt;</span><span class="n">port_state</span><span class="p">,</span>
				<span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_flag</span><span class="p">);</span>

			<span class="n">lpfc_els_rsp_acc</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">ELS_CMD_ACC</span><span class="p">,</span> <span class="n">cmdiocb</span><span class="p">,</span>
				<span class="n">ndlp</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_rscn_flush</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Another thread is walking fc_rscn_id_list on this vport */</span>
		<span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_flag</span> <span class="o">|=</span> <span class="n">FC_RSCN_DISCOVERY</span><span class="p">;</span>
		<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>
		<span class="cm">/* Send back ACC */</span>
		<span class="n">lpfc_els_rsp_acc</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">ELS_CMD_ACC</span><span class="p">,</span> <span class="n">cmdiocb</span><span class="p">,</span> <span class="n">ndlp</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* Indicate we are walking fc_rscn_id_list on this vport */</span>
	<span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_rscn_flush</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>
	<span class="cm">/* Get the array count after successfully have the token */</span>
	<span class="n">rscn_cnt</span> <span class="o">=</span> <span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_rscn_id_cnt</span><span class="p">;</span>
	<span class="cm">/* If we are already processing an RSCN, save the received</span>
<span class="cm">	 * RSCN payload buffer, cmdiocb-&gt;context2 to process later.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_flag</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">FC_RSCN_MODE</span> <span class="o">|</span> <span class="n">FC_NDISC_ACTIVE</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">lpfc_debugfs_disc_trc</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">LPFC_DISC_TRC_ELS_UNSOL</span><span class="p">,</span>
			<span class="s">&quot;RCV RSCN defer:  did:x%x/ste:x%x flg:x%x&quot;</span><span class="p">,</span>
			<span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_DID</span><span class="p">,</span> <span class="n">vport</span><span class="o">-&gt;</span><span class="n">port_state</span><span class="p">,</span> <span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_flag</span><span class="p">);</span>

		<span class="n">spin_lock_irq</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>
		<span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_flag</span> <span class="o">|=</span> <span class="n">FC_RSCN_DEFERRED</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">rscn_cnt</span> <span class="o">&lt;</span> <span class="n">FC_MAX_HOLD_RSCN</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="o">!</span><span class="p">(</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_flag</span> <span class="o">&amp;</span> <span class="n">FC_RSCN_DISCOVERY</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_flag</span> <span class="o">|=</span> <span class="n">FC_RSCN_MODE</span><span class="p">;</span>
			<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">rscn_cnt</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">cmd</span> <span class="o">=</span> <span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_rscn_id_list</span><span class="p">[</span><span class="n">rscn_cnt</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">virt</span><span class="p">;</span>
				<span class="n">length</span> <span class="o">=</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="o">*</span><span class="n">cmd</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">ELS_CMD_MASK</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">rscn_cnt</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			    <span class="p">(</span><span class="n">payload_len</span> <span class="o">+</span> <span class="n">length</span> <span class="o">&lt;=</span> <span class="n">LPFC_BPL_SIZE</span><span class="p">))</span> <span class="p">{</span>
				<span class="o">*</span><span class="n">cmd</span> <span class="o">&amp;=</span> <span class="n">ELS_CMD_MASK</span><span class="p">;</span>
				<span class="o">*</span><span class="n">cmd</span> <span class="o">|=</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">payload_len</span> <span class="o">+</span> <span class="n">length</span><span class="p">);</span>
				<span class="n">memcpy</span><span class="p">(((</span><span class="kt">uint8_t</span> <span class="o">*</span><span class="p">)</span><span class="n">cmd</span><span class="p">)</span> <span class="o">+</span> <span class="n">length</span><span class="p">,</span> <span class="n">lp</span><span class="p">,</span>
				       <span class="n">payload_len</span><span class="p">);</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_rscn_id_list</span><span class="p">[</span><span class="n">rscn_cnt</span><span class="p">]</span> <span class="o">=</span> <span class="n">pcmd</span><span class="p">;</span>
				<span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_rscn_id_cnt</span><span class="o">++</span><span class="p">;</span>
				<span class="cm">/* If we zero, cmdiocb-&gt;context2, the calling</span>
<span class="cm">				 * routine will not try to free it.</span>
<span class="cm">				 */</span>
				<span class="n">cmdiocb</span><span class="o">-&gt;</span><span class="n">context2</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="cm">/* Deferred RSCN */</span>
			<span class="n">lpfc_printf_vlog</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">KERN_INFO</span><span class="p">,</span> <span class="n">LOG_DISCOVERY</span><span class="p">,</span>
					 <span class="s">&quot;0235 Deferred RSCN &quot;</span>
					 <span class="s">&quot;Data: x%x x%x x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					 <span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_rscn_id_cnt</span><span class="p">,</span> <span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_flag</span><span class="p">,</span>
					 <span class="n">vport</span><span class="o">-&gt;</span><span class="n">port_state</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_flag</span> <span class="o">|=</span> <span class="n">FC_RSCN_DISCOVERY</span><span class="p">;</span>
			<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>
			<span class="cm">/* ReDiscovery RSCN */</span>
			<span class="n">lpfc_printf_vlog</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">KERN_INFO</span><span class="p">,</span> <span class="n">LOG_DISCOVERY</span><span class="p">,</span>
					 <span class="s">&quot;0234 ReDiscovery RSCN &quot;</span>
					 <span class="s">&quot;Data: x%x x%x x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					 <span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_rscn_id_cnt</span><span class="p">,</span> <span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_flag</span><span class="p">,</span>
					 <span class="n">vport</span><span class="o">-&gt;</span><span class="n">port_state</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="cm">/* Indicate we are done walking fc_rscn_id_list on this vport */</span>
		<span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_rscn_flush</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="cm">/* Send back ACC */</span>
		<span class="n">lpfc_els_rsp_acc</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">ELS_CMD_ACC</span><span class="p">,</span> <span class="n">cmdiocb</span><span class="p">,</span> <span class="n">ndlp</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="cm">/* send RECOVERY event for ALL nodes that match RSCN payload */</span>
		<span class="n">lpfc_rscn_recovery_check</span><span class="p">(</span><span class="n">vport</span><span class="p">);</span>
		<span class="n">spin_lock_irq</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>
		<span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_flag</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">FC_RSCN_DEFERRED</span><span class="p">;</span>
		<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">lpfc_debugfs_disc_trc</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">LPFC_DISC_TRC_ELS_UNSOL</span><span class="p">,</span>
		<span class="s">&quot;RCV RSCN:        did:x%x/ste:x%x flg:x%x&quot;</span><span class="p">,</span>
		<span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_DID</span><span class="p">,</span> <span class="n">vport</span><span class="o">-&gt;</span><span class="n">port_state</span><span class="p">,</span> <span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_flag</span><span class="p">);</span>

	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>
	<span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_flag</span> <span class="o">|=</span> <span class="n">FC_RSCN_MODE</span><span class="p">;</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>
	<span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_rscn_id_list</span><span class="p">[</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_rscn_id_cnt</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">pcmd</span><span class="p">;</span>
	<span class="cm">/* Indicate we are done walking fc_rscn_id_list on this vport */</span>
	<span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_rscn_flush</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * If we zero, cmdiocb-&gt;context2, the calling routine will</span>
<span class="cm">	 * not try to free it.</span>
<span class="cm">	 */</span>
	<span class="n">cmdiocb</span><span class="o">-&gt;</span><span class="n">context2</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">lpfc_set_disctmo</span><span class="p">(</span><span class="n">vport</span><span class="p">);</span>
	<span class="cm">/* Send back ACC */</span>
	<span class="n">lpfc_els_rsp_acc</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">ELS_CMD_ACC</span><span class="p">,</span> <span class="n">cmdiocb</span><span class="p">,</span> <span class="n">ndlp</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="cm">/* send RECOVERY event for ALL nodes that match RSCN payload */</span>
	<span class="n">lpfc_rscn_recovery_check</span><span class="p">(</span><span class="n">vport</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">lpfc_els_handle_rscn</span><span class="p">(</span><span class="n">vport</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_els_handle_rscn - Handle rscn for a vport</span>
<span class="cm"> * @vport: pointer to a host virtual N_Port data structure.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine handles the Registration State Configuration Notification</span>
<span class="cm"> * (RSCN) for a @vport. If login to NameServer does not exist, a new ndlp shall</span>
<span class="cm"> * be created and a Port Login (PLOGI) to the NameServer is issued. Otherwise,</span>
<span class="cm"> * if the ndlp to NameServer exists, a Common Transport (CT) command to the</span>
<span class="cm"> * NameServer shall be issued. If CT command to the NameServer fails to be</span>
<span class="cm"> * issued, the lpfc_els_flush_rscn() routine shall be invoked to clean up any</span>
<span class="cm"> * RSCN activities with the @vport.</span>
<span class="cm"> *</span>
<span class="cm"> * Return code</span>
<span class="cm"> *   0 - Cleaned up rscn on the @vport</span>
<span class="cm"> *   1 - Wait for plogi to name server before proceed</span>
<span class="cm"> **/</span>
<span class="kt">int</span>
<span class="nf">lpfc_els_handle_rscn</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="n">vport</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpfc_nodelist</span> <span class="o">*</span><span class="n">ndlp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span> <span class="o">=</span> <span class="n">vport</span><span class="o">-&gt;</span><span class="n">phba</span><span class="p">;</span>

	<span class="cm">/* Ignore RSCN if the port is being torn down. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">load_flag</span> <span class="o">&amp;</span> <span class="n">FC_UNLOADING</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lpfc_els_flush_rscn</span><span class="p">(</span><span class="n">vport</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Start timer for RSCN processing */</span>
	<span class="n">lpfc_set_disctmo</span><span class="p">(</span><span class="n">vport</span><span class="p">);</span>

	<span class="cm">/* RSCN processed */</span>
	<span class="n">lpfc_printf_vlog</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">KERN_INFO</span><span class="p">,</span> <span class="n">LOG_DISCOVERY</span><span class="p">,</span>
			 <span class="s">&quot;0215 RSCN processed Data: x%x x%x x%x x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			 <span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_flag</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_rscn_id_cnt</span><span class="p">,</span>
			 <span class="n">vport</span><span class="o">-&gt;</span><span class="n">port_state</span><span class="p">);</span>

	<span class="cm">/* To process RSCN, first compare RSCN data with NameServer */</span>
	<span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_ns_retry</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">vport</span><span class="o">-&gt;</span><span class="n">num_disc_nodes</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">ndlp</span> <span class="o">=</span> <span class="n">lpfc_findnode_did</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">NameServer_DID</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ndlp</span> <span class="o">&amp;&amp;</span> <span class="n">NLP_CHK_NODE_ACT</span><span class="p">(</span><span class="n">ndlp</span><span class="p">)</span>
	    <span class="o">&amp;&amp;</span> <span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_state</span> <span class="o">==</span> <span class="n">NLP_STE_UNMAPPED_NODE</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Good ndlp, issue CT Request to NameServer */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">lpfc_ns_cmd</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">SLI_CTNS_GID_FT</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="cm">/* Wait for NameServer query cmpl before we can</span>
<span class="cm">			   continue */</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* If login to NameServer does not exist, issue one */</span>
		<span class="cm">/* Good status, issue PLOGI to NameServer */</span>
		<span class="n">ndlp</span> <span class="o">=</span> <span class="n">lpfc_findnode_did</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">NameServer_DID</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ndlp</span> <span class="o">&amp;&amp;</span> <span class="n">NLP_CHK_NODE_ACT</span><span class="p">(</span><span class="n">ndlp</span><span class="p">))</span>
			<span class="cm">/* Wait for NameServer login cmpl before we can</span>
<span class="cm">			   continue */</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">ndlp</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ndlp</span> <span class="o">=</span> <span class="n">lpfc_enable_node</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">ndlp</span><span class="p">,</span>
						<span class="n">NLP_STE_PLOGI_ISSUE</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ndlp</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">lpfc_els_flush_rscn</span><span class="p">(</span><span class="n">vport</span><span class="p">);</span>
				<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_prev_state</span> <span class="o">=</span> <span class="n">NLP_STE_UNUSED_NODE</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">ndlp</span> <span class="o">=</span> <span class="n">mempool_alloc</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">nlp_mem_pool</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ndlp</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">lpfc_els_flush_rscn</span><span class="p">(</span><span class="n">vport</span><span class="p">);</span>
				<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">lpfc_nlp_init</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">ndlp</span><span class="p">,</span> <span class="n">NameServer_DID</span><span class="p">);</span>
			<span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_prev_state</span> <span class="o">=</span> <span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_state</span><span class="p">;</span>
			<span class="n">lpfc_nlp_set_state</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">ndlp</span><span class="p">,</span> <span class="n">NLP_STE_PLOGI_ISSUE</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_type</span> <span class="o">|=</span> <span class="n">NLP_FABRIC</span><span class="p">;</span>
		<span class="n">lpfc_issue_els_plogi</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">NameServer_DID</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="cm">/* Wait for NameServer login cmpl before we can</span>
<span class="cm">		 * continue</span>
<span class="cm">		 */</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">lpfc_els_flush_rscn</span><span class="p">(</span><span class="n">vport</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_els_rcv_flogi - Process an unsolicited flogi iocb</span>
<span class="cm"> * @vport: pointer to a host virtual N_Port data structure.</span>
<span class="cm"> * @cmdiocb: pointer to lpfc command iocb data structure.</span>
<span class="cm"> * @ndlp: pointer to a node-list data structure.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine processes Fabric Login (FLOGI) IOCB received as an ELS</span>
<span class="cm"> * unsolicited event. An unsolicited FLOGI can be received in a point-to-</span>
<span class="cm"> * point topology. As an unsolicited FLOGI should not be received in a loop</span>
<span class="cm"> * mode, any unsolicited FLOGI received in loop mode shall be ignored. The</span>
<span class="cm"> * lpfc_check_sparm() routine is invoked to check the parameters in the</span>
<span class="cm"> * unsolicited FLOGI. If parameters validation failed, the routine</span>
<span class="cm"> * lpfc_els_rsp_reject() shall be called with reject reason code set to</span>
<span class="cm"> * LSEXP_SPARM_OPTIONS to reject the FLOGI. Otherwise, the Port WWN in the</span>
<span class="cm"> * FLOGI shall be compared with the Port WWN of the @vport to determine who</span>
<span class="cm"> * will initiate PLOGI. The higher lexicographical value party shall has</span>
<span class="cm"> * higher priority (as the winning port) and will initiate PLOGI and</span>
<span class="cm"> * communicate Port_IDs (Addresses) for both nodes in PLOGI. The result</span>
<span class="cm"> * of this will be marked in the @vport fc_flag field with FC_PT2PT_PLOGI</span>
<span class="cm"> * and then the lpfc_els_rsp_acc() routine is invoked to accept the FLOGI.</span>
<span class="cm"> *</span>
<span class="cm"> * Return code</span>
<span class="cm"> *   0 - Successfully processed the unsolicited flogi</span>
<span class="cm"> *   1 - Failed to process the unsolicited flogi</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">lpfc_els_rcv_flogi</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="n">vport</span><span class="p">,</span> <span class="k">struct</span> <span class="n">lpfc_iocbq</span> <span class="o">*</span><span class="n">cmdiocb</span><span class="p">,</span>
		   <span class="k">struct</span> <span class="n">lpfc_nodelist</span> <span class="o">*</span><span class="n">ndlp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span> <span class="o">=</span> <span class="n">lpfc_shost_from_vport</span><span class="p">(</span><span class="n">vport</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">lpfc_hba</span>  <span class="o">*</span><span class="n">phba</span> <span class="o">=</span> <span class="n">vport</span><span class="o">-&gt;</span><span class="n">phba</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_dmabuf</span> <span class="o">*</span><span class="n">pcmd</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_dmabuf</span> <span class="o">*</span><span class="p">)</span> <span class="n">cmdiocb</span><span class="o">-&gt;</span><span class="n">context2</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="o">*</span><span class="n">lp</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint32_t</span> <span class="o">*</span><span class="p">)</span> <span class="n">pcmd</span><span class="o">-&gt;</span><span class="n">virt</span><span class="p">;</span>
	<span class="n">IOCB_t</span> <span class="o">*</span><span class="n">icmd</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">cmdiocb</span><span class="o">-&gt;</span><span class="n">iocb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">serv_parm</span> <span class="o">*</span><span class="n">sp</span><span class="p">;</span>
	<span class="n">LPFC_MBOXQ_t</span> <span class="o">*</span><span class="n">mbox</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ls_rjt</span> <span class="n">stat</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">cmd</span><span class="p">,</span> <span class="n">did</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">cmd</span> <span class="o">=</span> <span class="o">*</span><span class="n">lp</span><span class="o">++</span><span class="p">;</span>
	<span class="n">sp</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">serv_parm</span> <span class="o">*</span><span class="p">)</span> <span class="n">lp</span><span class="p">;</span>

	<span class="cm">/* FLOGI received */</span>

	<span class="n">lpfc_set_disctmo</span><span class="p">(</span><span class="n">vport</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">fc_topology</span> <span class="o">==</span> <span class="n">LPFC_TOPOLOGY_LOOP</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* We should never receive a FLOGI in loop mode, ignore it */</span>
		<span class="n">did</span> <span class="o">=</span> <span class="n">icmd</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">elsreq64</span><span class="p">.</span><span class="n">remoteID</span><span class="p">;</span>

		<span class="cm">/* An FLOGI ELS command &lt;elsCmd&gt; was received from DID &lt;did&gt; in</span>
<span class="cm">		   Loop Mode */</span>
		<span class="n">lpfc_printf_vlog</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_ELS</span><span class="p">,</span>
				 <span class="s">&quot;0113 An FLOGI ELS command x%x was &quot;</span>
				 <span class="s">&quot;received from DID x%x in Loop Mode</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				 <span class="n">cmd</span><span class="p">,</span> <span class="n">did</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">lpfc_check_sparm</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">ndlp</span><span class="p">,</span> <span class="n">sp</span><span class="p">,</span> <span class="n">CLASS3</span><span class="p">,</span> <span class="mi">1</span><span class="p">)))</span> <span class="p">{</span>
		<span class="cm">/* For a FLOGI we accept, then if our portname is greater</span>
<span class="cm">		 * then the remote portname we initiate Nport login.</span>
<span class="cm">		 */</span>

		<span class="n">rc</span> <span class="o">=</span> <span class="n">memcmp</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_portname</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">portName</span><span class="p">,</span>
			    <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_name</span><span class="p">));</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli_rev</span> <span class="o">&lt;</span> <span class="n">LPFC_SLI_REV4</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">mbox</span> <span class="o">=</span> <span class="n">mempool_alloc</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">mbox_mem_pool</span><span class="p">,</span>
						     <span class="n">GFP_KERNEL</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mbox</span><span class="p">)</span>
					<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
				<span class="n">lpfc_linkdown</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
				<span class="n">lpfc_init_link</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">mbox</span><span class="p">,</span>
					       <span class="n">phba</span><span class="o">-&gt;</span><span class="n">cfg_topology</span><span class="p">,</span>
					       <span class="n">phba</span><span class="o">-&gt;</span><span class="n">cfg_link_speed</span><span class="p">);</span>
				<span class="n">mbox</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">mb</span><span class="p">.</span><span class="n">un</span><span class="p">.</span><span class="n">varInitLnk</span><span class="p">.</span><span class="n">lipsr_AL_PA</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
				<span class="n">mbox</span><span class="o">-&gt;</span><span class="n">mbox_cmpl</span> <span class="o">=</span> <span class="n">lpfc_sli_def_mbox_cmpl</span><span class="p">;</span>
				<span class="n">mbox</span><span class="o">-&gt;</span><span class="n">vport</span> <span class="o">=</span> <span class="n">vport</span><span class="p">;</span>
				<span class="n">rc</span> <span class="o">=</span> <span class="n">lpfc_sli_issue_mbox</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">mbox</span><span class="p">,</span>
							 <span class="n">MBX_NOWAIT</span><span class="p">);</span>
				<span class="n">lpfc_set_loopback_flag</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">==</span> <span class="n">MBX_NOT_FINISHED</span><span class="p">)</span>
					<span class="n">mempool_free</span><span class="p">(</span><span class="n">mbox</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">mbox_mem_pool</span><span class="p">);</span>
				<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="cm">/* abort the flogi coming back to ourselves</span>
<span class="cm">				 * due to external loopback on the port.</span>
<span class="cm">				 */</span>
				<span class="n">lpfc_els_abort_flogi</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
				<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>	<span class="cm">/* greater than */</span>
			<span class="n">spin_lock_irq</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>
			<span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_flag</span> <span class="o">|=</span> <span class="n">FC_PT2PT_PLOGI</span><span class="p">;</span>
			<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>

			<span class="cm">/* If we have the high WWPN we can assign our own</span>
<span class="cm">			 * myDID; otherwise, we have to WAIT for a PLOGI</span>
<span class="cm">			 * from the remote NPort to find out what it</span>
<span class="cm">			 * will be.</span>
<span class="cm">			 */</span>
			<span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_myDID</span> <span class="o">=</span> <span class="n">PT2PT_LocalID</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 * The vport state should go to LPFC_FLOGI only</span>
<span class="cm">		 * AFTER we issue a FLOGI, not receive one.</span>
<span class="cm">		 */</span>
		<span class="n">spin_lock_irq</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>
		<span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_flag</span> <span class="o">|=</span> <span class="n">FC_PT2PT</span><span class="p">;</span>
		<span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_flag</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">FC_FABRIC</span> <span class="o">|</span> <span class="n">FC_PUBLIC_LOOP</span><span class="p">);</span>
		<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * We temporarily set fc_myDID to make it look like we are</span>
<span class="cm">		 * a Fabric. This is done just so we end up with the right</span>
<span class="cm">		 * did / sid on the FLOGI ACC rsp.</span>
<span class="cm">		 */</span>
		<span class="n">did</span> <span class="o">=</span> <span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_myDID</span><span class="p">;</span>
		<span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_myDID</span> <span class="o">=</span> <span class="n">Fabric_DID</span><span class="p">;</span>

	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* Reject this request because invalid parameters */</span>
		<span class="n">stat</span><span class="p">.</span><span class="n">un</span><span class="p">.</span><span class="n">b</span><span class="p">.</span><span class="n">lsRjtRsvd0</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">stat</span><span class="p">.</span><span class="n">un</span><span class="p">.</span><span class="n">b</span><span class="p">.</span><span class="n">lsRjtRsnCode</span> <span class="o">=</span> <span class="n">LSRJT_UNABLE_TPC</span><span class="p">;</span>
		<span class="n">stat</span><span class="p">.</span><span class="n">un</span><span class="p">.</span><span class="n">b</span><span class="p">.</span><span class="n">lsRjtRsnCodeExp</span> <span class="o">=</span> <span class="n">LSEXP_SPARM_OPTIONS</span><span class="p">;</span>
		<span class="n">stat</span><span class="p">.</span><span class="n">un</span><span class="p">.</span><span class="n">b</span><span class="p">.</span><span class="n">vendorUnique</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * We temporarily set fc_myDID to make it look like we are</span>
<span class="cm">		 * a Fabric. This is done just so we end up with the right</span>
<span class="cm">		 * did / sid on the FLOGI LS_RJT rsp.</span>
<span class="cm">		 */</span>
		<span class="n">did</span> <span class="o">=</span> <span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_myDID</span><span class="p">;</span>
		<span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_myDID</span> <span class="o">=</span> <span class="n">Fabric_DID</span><span class="p">;</span>

		<span class="n">lpfc_els_rsp_reject</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">stat</span><span class="p">.</span><span class="n">un</span><span class="p">.</span><span class="n">lsRjtError</span><span class="p">,</span> <span class="n">cmdiocb</span><span class="p">,</span> <span class="n">ndlp</span><span class="p">,</span>
			<span class="nb">NULL</span><span class="p">);</span>

		<span class="cm">/* Now lets put fc_myDID back to what its supposed to be */</span>
		<span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_myDID</span> <span class="o">=</span> <span class="n">did</span><span class="p">;</span>

		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Send back ACC */</span>
	<span class="n">lpfc_els_rsp_acc</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">ELS_CMD_PLOGI</span><span class="p">,</span> <span class="n">cmdiocb</span><span class="p">,</span> <span class="n">ndlp</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

	<span class="cm">/* Now lets put fc_myDID back to what its supposed to be */</span>
	<span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_myDID</span> <span class="o">=</span> <span class="n">did</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_flag</span> <span class="o">&amp;</span> <span class="n">FC_PT2PT_PLOGI</span><span class="p">))</span> <span class="p">{</span>

		<span class="n">mbox</span> <span class="o">=</span> <span class="n">mempool_alloc</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">mbox_mem_pool</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mbox</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>

		<span class="n">lpfc_config_link</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">mbox</span><span class="p">);</span>

		<span class="n">mbox</span><span class="o">-&gt;</span><span class="n">mbox_cmpl</span> <span class="o">=</span> <span class="n">lpfc_sli_def_mbox_cmpl</span><span class="p">;</span>
		<span class="n">mbox</span><span class="o">-&gt;</span><span class="n">vport</span> <span class="o">=</span> <span class="n">vport</span><span class="p">;</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">lpfc_sli_issue_mbox</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">mbox</span><span class="p">,</span> <span class="n">MBX_NOWAIT</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">==</span> <span class="n">MBX_NOT_FINISHED</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">mempool_free</span><span class="p">(</span><span class="n">mbox</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">mbox_mem_pool</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">fail:</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_els_rcv_rnid - Process an unsolicited rnid iocb</span>
<span class="cm"> * @vport: pointer to a host virtual N_Port data structure.</span>
<span class="cm"> * @cmdiocb: pointer to lpfc command iocb data structure.</span>
<span class="cm"> * @ndlp: pointer to a node-list data structure.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine processes Request Node Identification Data (RNID) IOCB</span>
<span class="cm"> * received as an ELS unsolicited event. Only when the RNID specified format</span>
<span class="cm"> * 0x0 or 0xDF (Topology Discovery Specific Node Identification Data)</span>
<span class="cm"> * present, this routine will invoke the lpfc_els_rsp_rnid_acc() routine to</span>
<span class="cm"> * Accept (ACC) the RNID ELS command. All the other RNID formats are</span>
<span class="cm"> * rejected by invoking the lpfc_els_rsp_reject() routine.</span>
<span class="cm"> *</span>
<span class="cm"> * Return code</span>
<span class="cm"> *   0 - Successfully processed rnid iocb (currently always return 0)</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">lpfc_els_rcv_rnid</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="n">vport</span><span class="p">,</span> <span class="k">struct</span> <span class="n">lpfc_iocbq</span> <span class="o">*</span><span class="n">cmdiocb</span><span class="p">,</span>
		  <span class="k">struct</span> <span class="n">lpfc_nodelist</span> <span class="o">*</span><span class="n">ndlp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpfc_dmabuf</span> <span class="o">*</span><span class="n">pcmd</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="o">*</span><span class="n">lp</span><span class="p">;</span>
	<span class="n">IOCB_t</span> <span class="o">*</span><span class="n">icmd</span><span class="p">;</span>
	<span class="n">RNID</span> <span class="o">*</span><span class="n">rn</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ls_rjt</span> <span class="n">stat</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">cmd</span><span class="p">,</span> <span class="n">did</span><span class="p">;</span>

	<span class="n">icmd</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">cmdiocb</span><span class="o">-&gt;</span><span class="n">iocb</span><span class="p">;</span>
	<span class="n">did</span> <span class="o">=</span> <span class="n">icmd</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">elsreq64</span><span class="p">.</span><span class="n">remoteID</span><span class="p">;</span>
	<span class="n">pcmd</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_dmabuf</span> <span class="o">*</span><span class="p">)</span> <span class="n">cmdiocb</span><span class="o">-&gt;</span><span class="n">context2</span><span class="p">;</span>
	<span class="n">lp</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint32_t</span> <span class="o">*</span><span class="p">)</span> <span class="n">pcmd</span><span class="o">-&gt;</span><span class="n">virt</span><span class="p">;</span>

	<span class="n">cmd</span> <span class="o">=</span> <span class="o">*</span><span class="n">lp</span><span class="o">++</span><span class="p">;</span>
	<span class="n">rn</span> <span class="o">=</span> <span class="p">(</span><span class="n">RNID</span> <span class="o">*</span><span class="p">)</span> <span class="n">lp</span><span class="p">;</span>

	<span class="cm">/* RNID received */</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">rn</span><span class="o">-&gt;</span><span class="n">Format</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="mi">0</span>:
	<span class="k">case</span> <span class="n">RNID_TOPOLOGY_DISC</span>:
		<span class="cm">/* Send back ACC */</span>
		<span class="n">lpfc_els_rsp_rnid_acc</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">rn</span><span class="o">-&gt;</span><span class="n">Format</span><span class="p">,</span> <span class="n">cmdiocb</span><span class="p">,</span> <span class="n">ndlp</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="cm">/* Reject this request because format not supported */</span>
		<span class="n">stat</span><span class="p">.</span><span class="n">un</span><span class="p">.</span><span class="n">b</span><span class="p">.</span><span class="n">lsRjtRsvd0</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">stat</span><span class="p">.</span><span class="n">un</span><span class="p">.</span><span class="n">b</span><span class="p">.</span><span class="n">lsRjtRsnCode</span> <span class="o">=</span> <span class="n">LSRJT_UNABLE_TPC</span><span class="p">;</span>
		<span class="n">stat</span><span class="p">.</span><span class="n">un</span><span class="p">.</span><span class="n">b</span><span class="p">.</span><span class="n">lsRjtRsnCodeExp</span> <span class="o">=</span> <span class="n">LSEXP_CANT_GIVE_DATA</span><span class="p">;</span>
		<span class="n">stat</span><span class="p">.</span><span class="n">un</span><span class="p">.</span><span class="n">b</span><span class="p">.</span><span class="n">vendorUnique</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">lpfc_els_rsp_reject</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">stat</span><span class="p">.</span><span class="n">un</span><span class="p">.</span><span class="n">lsRjtError</span><span class="p">,</span> <span class="n">cmdiocb</span><span class="p">,</span> <span class="n">ndlp</span><span class="p">,</span>
			<span class="nb">NULL</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_els_rcv_echo - Process an unsolicited echo iocb</span>
<span class="cm"> * @vport: pointer to a host virtual N_Port data structure.</span>
<span class="cm"> * @cmdiocb: pointer to lpfc command iocb data structure.</span>
<span class="cm"> * @ndlp: pointer to a node-list data structure.</span>
<span class="cm"> *</span>
<span class="cm"> * Return code</span>
<span class="cm"> *   0 - Successfully processed echo iocb (currently always return 0)</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">lpfc_els_rcv_echo</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="n">vport</span><span class="p">,</span> <span class="k">struct</span> <span class="n">lpfc_iocbq</span> <span class="o">*</span><span class="n">cmdiocb</span><span class="p">,</span>
		  <span class="k">struct</span> <span class="n">lpfc_nodelist</span> <span class="o">*</span><span class="n">ndlp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">uint8_t</span> <span class="o">*</span><span class="n">pcmd</span><span class="p">;</span>

	<span class="n">pcmd</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint8_t</span> <span class="o">*</span><span class="p">)</span> <span class="p">(((</span><span class="k">struct</span> <span class="n">lpfc_dmabuf</span> <span class="o">*</span><span class="p">)</span> <span class="n">cmdiocb</span><span class="o">-&gt;</span><span class="n">context2</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">virt</span><span class="p">);</span>

	<span class="cm">/* skip over first word of echo command to find echo data */</span>
	<span class="n">pcmd</span> <span class="o">+=</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">uint32_t</span><span class="p">);</span>

	<span class="n">lpfc_els_rsp_echo_acc</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">pcmd</span><span class="p">,</span> <span class="n">cmdiocb</span><span class="p">,</span> <span class="n">ndlp</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_els_rcv_lirr - Process an unsolicited lirr iocb</span>
<span class="cm"> * @vport: pointer to a host virtual N_Port data structure.</span>
<span class="cm"> * @cmdiocb: pointer to lpfc command iocb data structure.</span>
<span class="cm"> * @ndlp: pointer to a node-list data structure.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine processes a Link Incident Report Registration(LIRR) IOCB</span>
<span class="cm"> * received as an ELS unsolicited event. Currently, this function just invokes</span>
<span class="cm"> * the lpfc_els_rsp_reject() routine to reject the LIRR IOCB unconditionally.</span>
<span class="cm"> *</span>
<span class="cm"> * Return code</span>
<span class="cm"> *   0 - Successfully processed lirr iocb (currently always return 0)</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">lpfc_els_rcv_lirr</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="n">vport</span><span class="p">,</span> <span class="k">struct</span> <span class="n">lpfc_iocbq</span> <span class="o">*</span><span class="n">cmdiocb</span><span class="p">,</span>
		  <span class="k">struct</span> <span class="n">lpfc_nodelist</span> <span class="o">*</span><span class="n">ndlp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ls_rjt</span> <span class="n">stat</span><span class="p">;</span>

	<span class="cm">/* For now, unconditionally reject this command */</span>
	<span class="n">stat</span><span class="p">.</span><span class="n">un</span><span class="p">.</span><span class="n">b</span><span class="p">.</span><span class="n">lsRjtRsvd0</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">stat</span><span class="p">.</span><span class="n">un</span><span class="p">.</span><span class="n">b</span><span class="p">.</span><span class="n">lsRjtRsnCode</span> <span class="o">=</span> <span class="n">LSRJT_UNABLE_TPC</span><span class="p">;</span>
	<span class="n">stat</span><span class="p">.</span><span class="n">un</span><span class="p">.</span><span class="n">b</span><span class="p">.</span><span class="n">lsRjtRsnCodeExp</span> <span class="o">=</span> <span class="n">LSEXP_CANT_GIVE_DATA</span><span class="p">;</span>
	<span class="n">stat</span><span class="p">.</span><span class="n">un</span><span class="p">.</span><span class="n">b</span><span class="p">.</span><span class="n">vendorUnique</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">lpfc_els_rsp_reject</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">stat</span><span class="p">.</span><span class="n">un</span><span class="p">.</span><span class="n">lsRjtError</span><span class="p">,</span> <span class="n">cmdiocb</span><span class="p">,</span> <span class="n">ndlp</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_els_rcv_rrq - Process an unsolicited rrq iocb</span>
<span class="cm"> * @vport: pointer to a host virtual N_Port data structure.</span>
<span class="cm"> * @cmdiocb: pointer to lpfc command iocb data structure.</span>
<span class="cm"> * @ndlp: pointer to a node-list data structure.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine processes a Reinstate Recovery Qualifier (RRQ) IOCB</span>
<span class="cm"> * received as an ELS unsolicited event. A request to RRQ shall only</span>
<span class="cm"> * be accepted if the Originator Nx_Port N_Port_ID or the Responder</span>
<span class="cm"> * Nx_Port N_Port_ID of the target Exchange is the same as the</span>
<span class="cm"> * N_Port_ID of the Nx_Port that makes the request. If the RRQ is</span>
<span class="cm"> * not accepted, an LS_RJT with reason code &quot;Unable to perform</span>
<span class="cm"> * command request&quot; and reason code explanation &quot;Invalid Originator</span>
<span class="cm"> * S_ID&quot; shall be returned. For now, we just unconditionally accept</span>
<span class="cm"> * RRQ from the target.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">lpfc_els_rcv_rrq</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="n">vport</span><span class="p">,</span> <span class="k">struct</span> <span class="n">lpfc_iocbq</span> <span class="o">*</span><span class="n">cmdiocb</span><span class="p">,</span>
		 <span class="k">struct</span> <span class="n">lpfc_nodelist</span> <span class="o">*</span><span class="n">ndlp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">lpfc_els_rsp_acc</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">ELS_CMD_ACC</span><span class="p">,</span> <span class="n">cmdiocb</span><span class="p">,</span> <span class="n">ndlp</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli_rev</span> <span class="o">==</span> <span class="n">LPFC_SLI_REV4</span><span class="p">)</span>
		<span class="n">lpfc_els_clear_rrq</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">cmdiocb</span><span class="p">,</span> <span class="n">ndlp</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_els_rsp_rls_acc - Completion callbk func for MBX_READ_LNK_STAT mbox cmd</span>
<span class="cm"> * @phba: pointer to lpfc hba data structure.</span>
<span class="cm"> * @pmb: pointer to the driver internal queue element for mailbox command.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine is the completion callback function for the MBX_READ_LNK_STAT</span>
<span class="cm"> * mailbox command. This callback function is to actually send the Accept</span>
<span class="cm"> * (ACC) response to a Read Port Status (RPS) unsolicited IOCB event. It</span>
<span class="cm"> * collects the link statistics from the completion of the MBX_READ_LNK_STAT</span>
<span class="cm"> * mailbox command, constructs the RPS response with the link statistics</span>
<span class="cm"> * collected, and then invokes the lpfc_sli_issue_iocb() routine to send ACC</span>
<span class="cm"> * response to the RPS.</span>
<span class="cm"> *</span>
<span class="cm"> * Note that, in lpfc_prep_els_iocb() routine, the reference count of ndlp</span>
<span class="cm"> * will be incremented by 1 for holding the ndlp and the reference to ndlp</span>
<span class="cm"> * will be stored into the context1 field of the IOCB for the completion</span>
<span class="cm"> * callback function to the RPS Accept Response ELS IOCB command.</span>
<span class="cm"> *</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">lpfc_els_rsp_rls_acc</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">,</span> <span class="n">LPFC_MBOXQ_t</span> <span class="o">*</span><span class="n">pmb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">MAILBOX_t</span> <span class="o">*</span><span class="n">mb</span><span class="p">;</span>
	<span class="n">IOCB_t</span> <span class="o">*</span><span class="n">icmd</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">RLS_RSP</span> <span class="o">*</span><span class="n">rls_rsp</span><span class="p">;</span>
	<span class="kt">uint8_t</span> <span class="o">*</span><span class="n">pcmd</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_iocbq</span> <span class="o">*</span><span class="n">elsiocb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_nodelist</span> <span class="o">*</span><span class="n">ndlp</span><span class="p">;</span>
	<span class="kt">uint16_t</span> <span class="n">oxid</span><span class="p">;</span>
	<span class="kt">uint16_t</span> <span class="n">rxid</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">cmdsize</span><span class="p">;</span>

	<span class="n">mb</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">pmb</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">mb</span><span class="p">;</span>

	<span class="n">ndlp</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_nodelist</span> <span class="o">*</span><span class="p">)</span> <span class="n">pmb</span><span class="o">-&gt;</span><span class="n">context2</span><span class="p">;</span>
	<span class="n">rxid</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint16_t</span><span class="p">)</span> <span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)(</span><span class="n">pmb</span><span class="o">-&gt;</span><span class="n">context1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xffff</span><span class="p">);</span>
	<span class="n">oxid</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint16_t</span><span class="p">)</span> <span class="p">(((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)(</span><span class="n">pmb</span><span class="o">-&gt;</span><span class="n">context1</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xffff</span><span class="p">);</span>
	<span class="n">pmb</span><span class="o">-&gt;</span><span class="n">context1</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">pmb</span><span class="o">-&gt;</span><span class="n">context2</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">mb</span><span class="o">-&gt;</span><span class="n">mbxStatus</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mempool_free</span><span class="p">(</span><span class="n">pmb</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">mbox_mem_pool</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">cmdsize</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">RLS_RSP</span><span class="p">)</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">uint32_t</span><span class="p">);</span>
	<span class="n">elsiocb</span> <span class="o">=</span> <span class="n">lpfc_prep_els_iocb</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">pport</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">cmdsize</span><span class="p">,</span>
				     <span class="n">lpfc_max_els_tries</span><span class="p">,</span> <span class="n">ndlp</span><span class="p">,</span>
				     <span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_DID</span><span class="p">,</span> <span class="n">ELS_CMD_ACC</span><span class="p">);</span>

	<span class="cm">/* Decrement the ndlp reference count from previous mbox command */</span>
	<span class="n">lpfc_nlp_put</span><span class="p">(</span><span class="n">ndlp</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">elsiocb</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mempool_free</span><span class="p">(</span><span class="n">pmb</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">mbox_mem_pool</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">icmd</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">elsiocb</span><span class="o">-&gt;</span><span class="n">iocb</span><span class="p">;</span>
	<span class="n">icmd</span><span class="o">-&gt;</span><span class="n">ulpContext</span> <span class="o">=</span> <span class="n">rxid</span><span class="p">;</span>
	<span class="n">icmd</span><span class="o">-&gt;</span><span class="n">unsli3</span><span class="p">.</span><span class="n">rcvsli3</span><span class="p">.</span><span class="n">ox_id</span> <span class="o">=</span> <span class="n">oxid</span><span class="p">;</span>

	<span class="n">pcmd</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint8_t</span> <span class="o">*</span><span class="p">)</span> <span class="p">(((</span><span class="k">struct</span> <span class="n">lpfc_dmabuf</span> <span class="o">*</span><span class="p">)</span> <span class="n">elsiocb</span><span class="o">-&gt;</span><span class="n">context2</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">virt</span><span class="p">);</span>
	<span class="o">*</span><span class="p">((</span><span class="kt">uint32_t</span> <span class="o">*</span><span class="p">)</span> <span class="p">(</span><span class="n">pcmd</span><span class="p">))</span> <span class="o">=</span> <span class="n">ELS_CMD_ACC</span><span class="p">;</span>
	<span class="n">pcmd</span> <span class="o">+=</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">uint32_t</span><span class="p">);</span> <span class="cm">/* Skip past command */</span>
	<span class="n">rls_rsp</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">RLS_RSP</span> <span class="o">*</span><span class="p">)</span><span class="n">pcmd</span><span class="p">;</span>

	<span class="n">rls_rsp</span><span class="o">-&gt;</span><span class="n">linkFailureCnt</span> <span class="o">=</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">mb</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">varRdLnk</span><span class="p">.</span><span class="n">linkFailureCnt</span><span class="p">);</span>
	<span class="n">rls_rsp</span><span class="o">-&gt;</span><span class="n">lossSyncCnt</span> <span class="o">=</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">mb</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">varRdLnk</span><span class="p">.</span><span class="n">lossSyncCnt</span><span class="p">);</span>
	<span class="n">rls_rsp</span><span class="o">-&gt;</span><span class="n">lossSignalCnt</span> <span class="o">=</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">mb</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">varRdLnk</span><span class="p">.</span><span class="n">lossSignalCnt</span><span class="p">);</span>
	<span class="n">rls_rsp</span><span class="o">-&gt;</span><span class="n">primSeqErrCnt</span> <span class="o">=</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">mb</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">varRdLnk</span><span class="p">.</span><span class="n">primSeqErrCnt</span><span class="p">);</span>
	<span class="n">rls_rsp</span><span class="o">-&gt;</span><span class="n">invalidXmitWord</span> <span class="o">=</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">mb</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">varRdLnk</span><span class="p">.</span><span class="n">invalidXmitWord</span><span class="p">);</span>
	<span class="n">rls_rsp</span><span class="o">-&gt;</span><span class="n">crcCnt</span> <span class="o">=</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">mb</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">varRdLnk</span><span class="p">.</span><span class="n">crcCnt</span><span class="p">);</span>
	<span class="n">mempool_free</span><span class="p">(</span><span class="n">pmb</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">mbox_mem_pool</span><span class="p">);</span>
	<span class="cm">/* Xmit ELS RLS ACC response tag &lt;ulpIoTag&gt; */</span>
	<span class="n">lpfc_printf_vlog</span><span class="p">(</span><span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">vport</span><span class="p">,</span> <span class="n">KERN_INFO</span><span class="p">,</span> <span class="n">LOG_ELS</span><span class="p">,</span>
			 <span class="s">&quot;2874 Xmit ELS RLS ACC response tag x%x xri x%x, &quot;</span>
			 <span class="s">&quot;did x%x, nlp_flag x%x, nlp_state x%x, rpi x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			 <span class="n">elsiocb</span><span class="o">-&gt;</span><span class="n">iotag</span><span class="p">,</span> <span class="n">elsiocb</span><span class="o">-&gt;</span><span class="n">iocb</span><span class="p">.</span><span class="n">ulpContext</span><span class="p">,</span>
			 <span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_DID</span><span class="p">,</span> <span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_flag</span><span class="p">,</span> <span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_state</span><span class="p">,</span>
			 <span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_rpi</span><span class="p">);</span>
	<span class="n">elsiocb</span><span class="o">-&gt;</span><span class="n">iocb_cmpl</span> <span class="o">=</span> <span class="n">lpfc_cmpl_els_rsp</span><span class="p">;</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">fc_stat</span><span class="p">.</span><span class="n">elsXmitACC</span><span class="o">++</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">lpfc_sli_issue_iocb</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">LPFC_ELS_RING</span><span class="p">,</span> <span class="n">elsiocb</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">==</span> <span class="n">IOCB_ERROR</span><span class="p">)</span>
		<span class="n">lpfc_els_free_iocb</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">elsiocb</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_els_rsp_rps_acc - Completion callbk func for MBX_READ_LNK_STAT mbox cmd</span>
<span class="cm"> * @phba: pointer to lpfc hba data structure.</span>
<span class="cm"> * @pmb: pointer to the driver internal queue element for mailbox command.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine is the completion callback function for the MBX_READ_LNK_STAT</span>
<span class="cm"> * mailbox command. This callback function is to actually send the Accept</span>
<span class="cm"> * (ACC) response to a Read Port Status (RPS) unsolicited IOCB event. It</span>
<span class="cm"> * collects the link statistics from the completion of the MBX_READ_LNK_STAT</span>
<span class="cm"> * mailbox command, constructs the RPS response with the link statistics</span>
<span class="cm"> * collected, and then invokes the lpfc_sli_issue_iocb() routine to send ACC</span>
<span class="cm"> * response to the RPS.</span>
<span class="cm"> *</span>
<span class="cm"> * Note that, in lpfc_prep_els_iocb() routine, the reference count of ndlp</span>
<span class="cm"> * will be incremented by 1 for holding the ndlp and the reference to ndlp</span>
<span class="cm"> * will be stored into the context1 field of the IOCB for the completion</span>
<span class="cm"> * callback function to the RPS Accept Response ELS IOCB command.</span>
<span class="cm"> *</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">lpfc_els_rsp_rps_acc</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">,</span> <span class="n">LPFC_MBOXQ_t</span> <span class="o">*</span><span class="n">pmb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">MAILBOX_t</span> <span class="o">*</span><span class="n">mb</span><span class="p">;</span>
	<span class="n">IOCB_t</span> <span class="o">*</span><span class="n">icmd</span><span class="p">;</span>
	<span class="n">RPS_RSP</span> <span class="o">*</span><span class="n">rps_rsp</span><span class="p">;</span>
	<span class="kt">uint8_t</span> <span class="o">*</span><span class="n">pcmd</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_iocbq</span> <span class="o">*</span><span class="n">elsiocb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_nodelist</span> <span class="o">*</span><span class="n">ndlp</span><span class="p">;</span>
	<span class="kt">uint16_t</span> <span class="n">status</span><span class="p">;</span>
	<span class="kt">uint16_t</span> <span class="n">oxid</span><span class="p">;</span>
	<span class="kt">uint16_t</span> <span class="n">rxid</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">cmdsize</span><span class="p">;</span>

	<span class="n">mb</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">pmb</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">mb</span><span class="p">;</span>

	<span class="n">ndlp</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_nodelist</span> <span class="o">*</span><span class="p">)</span> <span class="n">pmb</span><span class="o">-&gt;</span><span class="n">context2</span><span class="p">;</span>
	<span class="n">rxid</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint16_t</span><span class="p">)</span> <span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)(</span><span class="n">pmb</span><span class="o">-&gt;</span><span class="n">context1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xffff</span><span class="p">);</span>
	<span class="n">oxid</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint16_t</span><span class="p">)</span> <span class="p">(((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)(</span><span class="n">pmb</span><span class="o">-&gt;</span><span class="n">context1</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xffff</span><span class="p">);</span>
	<span class="n">pmb</span><span class="o">-&gt;</span><span class="n">context1</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">pmb</span><span class="o">-&gt;</span><span class="n">context2</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">mb</span><span class="o">-&gt;</span><span class="n">mbxStatus</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mempool_free</span><span class="p">(</span><span class="n">pmb</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">mbox_mem_pool</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">cmdsize</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">RPS_RSP</span><span class="p">)</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">uint32_t</span><span class="p">);</span>
	<span class="n">mempool_free</span><span class="p">(</span><span class="n">pmb</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">mbox_mem_pool</span><span class="p">);</span>
	<span class="n">elsiocb</span> <span class="o">=</span> <span class="n">lpfc_prep_els_iocb</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">pport</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">cmdsize</span><span class="p">,</span>
				     <span class="n">lpfc_max_els_tries</span><span class="p">,</span> <span class="n">ndlp</span><span class="p">,</span>
				     <span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_DID</span><span class="p">,</span> <span class="n">ELS_CMD_ACC</span><span class="p">);</span>

	<span class="cm">/* Decrement the ndlp reference count from previous mbox command */</span>
	<span class="n">lpfc_nlp_put</span><span class="p">(</span><span class="n">ndlp</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">elsiocb</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">icmd</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">elsiocb</span><span class="o">-&gt;</span><span class="n">iocb</span><span class="p">;</span>
	<span class="n">icmd</span><span class="o">-&gt;</span><span class="n">ulpContext</span> <span class="o">=</span> <span class="n">rxid</span><span class="p">;</span>
	<span class="n">icmd</span><span class="o">-&gt;</span><span class="n">unsli3</span><span class="p">.</span><span class="n">rcvsli3</span><span class="p">.</span><span class="n">ox_id</span> <span class="o">=</span> <span class="n">oxid</span><span class="p">;</span>

	<span class="n">pcmd</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint8_t</span> <span class="o">*</span><span class="p">)</span> <span class="p">(((</span><span class="k">struct</span> <span class="n">lpfc_dmabuf</span> <span class="o">*</span><span class="p">)</span> <span class="n">elsiocb</span><span class="o">-&gt;</span><span class="n">context2</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">virt</span><span class="p">);</span>
	<span class="o">*</span><span class="p">((</span><span class="kt">uint32_t</span> <span class="o">*</span><span class="p">)</span> <span class="p">(</span><span class="n">pcmd</span><span class="p">))</span> <span class="o">=</span> <span class="n">ELS_CMD_ACC</span><span class="p">;</span>
	<span class="n">pcmd</span> <span class="o">+=</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">uint32_t</span><span class="p">);</span> <span class="cm">/* Skip past command */</span>
	<span class="n">rps_rsp</span> <span class="o">=</span> <span class="p">(</span><span class="n">RPS_RSP</span> <span class="o">*</span><span class="p">)</span><span class="n">pcmd</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">fc_topology</span> <span class="o">!=</span> <span class="n">LPFC_TOPOLOGY_LOOP</span><span class="p">)</span>
		<span class="n">status</span> <span class="o">=</span> <span class="mh">0x10</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">status</span> <span class="o">=</span> <span class="mh">0x8</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">pport</span><span class="o">-&gt;</span><span class="n">fc_flag</span> <span class="o">&amp;</span> <span class="n">FC_FABRIC</span><span class="p">)</span>
		<span class="n">status</span> <span class="o">|=</span> <span class="mh">0x4</span><span class="p">;</span>

	<span class="n">rps_rsp</span><span class="o">-&gt;</span><span class="n">rsvd1</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">rps_rsp</span><span class="o">-&gt;</span><span class="n">portStatus</span> <span class="o">=</span> <span class="n">cpu_to_be16</span><span class="p">(</span><span class="n">status</span><span class="p">);</span>
	<span class="n">rps_rsp</span><span class="o">-&gt;</span><span class="n">linkFailureCnt</span> <span class="o">=</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">mb</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">varRdLnk</span><span class="p">.</span><span class="n">linkFailureCnt</span><span class="p">);</span>
	<span class="n">rps_rsp</span><span class="o">-&gt;</span><span class="n">lossSyncCnt</span> <span class="o">=</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">mb</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">varRdLnk</span><span class="p">.</span><span class="n">lossSyncCnt</span><span class="p">);</span>
	<span class="n">rps_rsp</span><span class="o">-&gt;</span><span class="n">lossSignalCnt</span> <span class="o">=</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">mb</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">varRdLnk</span><span class="p">.</span><span class="n">lossSignalCnt</span><span class="p">);</span>
	<span class="n">rps_rsp</span><span class="o">-&gt;</span><span class="n">primSeqErrCnt</span> <span class="o">=</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">mb</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">varRdLnk</span><span class="p">.</span><span class="n">primSeqErrCnt</span><span class="p">);</span>
	<span class="n">rps_rsp</span><span class="o">-&gt;</span><span class="n">invalidXmitWord</span> <span class="o">=</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">mb</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">varRdLnk</span><span class="p">.</span><span class="n">invalidXmitWord</span><span class="p">);</span>
	<span class="n">rps_rsp</span><span class="o">-&gt;</span><span class="n">crcCnt</span> <span class="o">=</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">mb</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">varRdLnk</span><span class="p">.</span><span class="n">crcCnt</span><span class="p">);</span>
	<span class="cm">/* Xmit ELS RPS ACC response tag &lt;ulpIoTag&gt; */</span>
	<span class="n">lpfc_printf_vlog</span><span class="p">(</span><span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">vport</span><span class="p">,</span> <span class="n">KERN_INFO</span><span class="p">,</span> <span class="n">LOG_ELS</span><span class="p">,</span>
			 <span class="s">&quot;0118 Xmit ELS RPS ACC response tag x%x xri x%x, &quot;</span>
			 <span class="s">&quot;did x%x, nlp_flag x%x, nlp_state x%x, rpi x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			 <span class="n">elsiocb</span><span class="o">-&gt;</span><span class="n">iotag</span><span class="p">,</span> <span class="n">elsiocb</span><span class="o">-&gt;</span><span class="n">iocb</span><span class="p">.</span><span class="n">ulpContext</span><span class="p">,</span>
			 <span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_DID</span><span class="p">,</span> <span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_flag</span><span class="p">,</span> <span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_state</span><span class="p">,</span>
			 <span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_rpi</span><span class="p">);</span>
	<span class="n">elsiocb</span><span class="o">-&gt;</span><span class="n">iocb_cmpl</span> <span class="o">=</span> <span class="n">lpfc_cmpl_els_rsp</span><span class="p">;</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">fc_stat</span><span class="p">.</span><span class="n">elsXmitACC</span><span class="o">++</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">lpfc_sli_issue_iocb</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">LPFC_ELS_RING</span><span class="p">,</span> <span class="n">elsiocb</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">==</span> <span class="n">IOCB_ERROR</span><span class="p">)</span>
		<span class="n">lpfc_els_free_iocb</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">elsiocb</span><span class="p">);</span>
	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_els_rcv_rls - Process an unsolicited rls iocb</span>
<span class="cm"> * @vport: pointer to a host virtual N_Port data structure.</span>
<span class="cm"> * @cmdiocb: pointer to lpfc command iocb data structure.</span>
<span class="cm"> * @ndlp: pointer to a node-list data structure.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine processes Read Port Status (RPL) IOCB received as an</span>
<span class="cm"> * ELS unsolicited event. It first checks the remote port state. If the</span>
<span class="cm"> * remote port is not in NLP_STE_UNMAPPED_NODE state or NLP_STE_MAPPED_NODE</span>
<span class="cm"> * state, it invokes the lpfc_els_rsl_reject() routine to send the reject</span>
<span class="cm"> * response. Otherwise, it issue the MBX_READ_LNK_STAT mailbox command</span>
<span class="cm"> * for reading the HBA link statistics. It is for the callback function,</span>
<span class="cm"> * lpfc_els_rsp_rls_acc(), set to the MBX_READ_LNK_STAT mailbox command</span>
<span class="cm"> * to actually sending out RPL Accept (ACC) response.</span>
<span class="cm"> *</span>
<span class="cm"> * Return codes</span>
<span class="cm"> *   0 - Successfully processed rls iocb (currently always return 0)</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">lpfc_els_rcv_rls</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="n">vport</span><span class="p">,</span> <span class="k">struct</span> <span class="n">lpfc_iocbq</span> <span class="o">*</span><span class="n">cmdiocb</span><span class="p">,</span>
		 <span class="k">struct</span> <span class="n">lpfc_nodelist</span> <span class="o">*</span><span class="n">ndlp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span> <span class="o">=</span> <span class="n">vport</span><span class="o">-&gt;</span><span class="n">phba</span><span class="p">;</span>
	<span class="n">LPFC_MBOXQ_t</span> <span class="o">*</span><span class="n">mbox</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_dmabuf</span> <span class="o">*</span><span class="n">pcmd</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ls_rjt</span> <span class="n">stat</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_state</span> <span class="o">!=</span> <span class="n">NLP_STE_UNMAPPED_NODE</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_state</span> <span class="o">!=</span> <span class="n">NLP_STE_MAPPED_NODE</span><span class="p">))</span>
		<span class="cm">/* reject the unsolicited RPS request and done with it */</span>
		<span class="k">goto</span> <span class="n">reject_out</span><span class="p">;</span>

	<span class="n">pcmd</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_dmabuf</span> <span class="o">*</span><span class="p">)</span> <span class="n">cmdiocb</span><span class="o">-&gt;</span><span class="n">context2</span><span class="p">;</span>

	<span class="n">mbox</span> <span class="o">=</span> <span class="n">mempool_alloc</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">mbox_mem_pool</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mbox</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lpfc_read_lnk_stat</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">mbox</span><span class="p">);</span>
		<span class="n">mbox</span><span class="o">-&gt;</span><span class="n">context1</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span>
			<span class="p">((</span><span class="n">cmdiocb</span><span class="o">-&gt;</span><span class="n">iocb</span><span class="p">.</span><span class="n">unsli3</span><span class="p">.</span><span class="n">rcvsli3</span><span class="p">.</span><span class="n">ox_id</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">|</span>
			<span class="n">cmdiocb</span><span class="o">-&gt;</span><span class="n">iocb</span><span class="p">.</span><span class="n">ulpContext</span><span class="p">));</span> <span class="cm">/* rx_id */</span>
		<span class="n">mbox</span><span class="o">-&gt;</span><span class="n">context2</span> <span class="o">=</span> <span class="n">lpfc_nlp_get</span><span class="p">(</span><span class="n">ndlp</span><span class="p">);</span>
		<span class="n">mbox</span><span class="o">-&gt;</span><span class="n">vport</span> <span class="o">=</span> <span class="n">vport</span><span class="p">;</span>
		<span class="n">mbox</span><span class="o">-&gt;</span><span class="n">mbox_cmpl</span> <span class="o">=</span> <span class="n">lpfc_els_rsp_rls_acc</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">lpfc_sli_issue_mbox</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">mbox</span><span class="p">,</span> <span class="n">MBX_NOWAIT</span><span class="p">)</span>
			<span class="o">!=</span> <span class="n">MBX_NOT_FINISHED</span><span class="p">)</span>
			<span class="cm">/* Mbox completion will send ELS Response */</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="cm">/* Decrement reference count used for the failed mbox</span>
<span class="cm">		 * command.</span>
<span class="cm">		 */</span>
		<span class="n">lpfc_nlp_put</span><span class="p">(</span><span class="n">ndlp</span><span class="p">);</span>
		<span class="n">mempool_free</span><span class="p">(</span><span class="n">mbox</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">mbox_mem_pool</span><span class="p">);</span>
	<span class="p">}</span>
<span class="nl">reject_out:</span>
	<span class="cm">/* issue rejection response */</span>
	<span class="n">stat</span><span class="p">.</span><span class="n">un</span><span class="p">.</span><span class="n">b</span><span class="p">.</span><span class="n">lsRjtRsvd0</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">stat</span><span class="p">.</span><span class="n">un</span><span class="p">.</span><span class="n">b</span><span class="p">.</span><span class="n">lsRjtRsnCode</span> <span class="o">=</span> <span class="n">LSRJT_UNABLE_TPC</span><span class="p">;</span>
	<span class="n">stat</span><span class="p">.</span><span class="n">un</span><span class="p">.</span><span class="n">b</span><span class="p">.</span><span class="n">lsRjtRsnCodeExp</span> <span class="o">=</span> <span class="n">LSEXP_CANT_GIVE_DATA</span><span class="p">;</span>
	<span class="n">stat</span><span class="p">.</span><span class="n">un</span><span class="p">.</span><span class="n">b</span><span class="p">.</span><span class="n">vendorUnique</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">lpfc_els_rsp_reject</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">stat</span><span class="p">.</span><span class="n">un</span><span class="p">.</span><span class="n">lsRjtError</span><span class="p">,</span> <span class="n">cmdiocb</span><span class="p">,</span> <span class="n">ndlp</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_els_rcv_rtv - Process an unsolicited rtv iocb</span>
<span class="cm"> * @vport: pointer to a host virtual N_Port data structure.</span>
<span class="cm"> * @cmdiocb: pointer to lpfc command iocb data structure.</span>
<span class="cm"> * @ndlp: pointer to a node-list data structure.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine processes Read Timout Value (RTV) IOCB received as an</span>
<span class="cm"> * ELS unsolicited event. It first checks the remote port state. If the</span>
<span class="cm"> * remote port is not in NLP_STE_UNMAPPED_NODE state or NLP_STE_MAPPED_NODE</span>
<span class="cm"> * state, it invokes the lpfc_els_rsl_reject() routine to send the reject</span>
<span class="cm"> * response. Otherwise, it sends the Accept(ACC) response to a Read Timeout</span>
<span class="cm"> * Value (RTV) unsolicited IOCB event.</span>
<span class="cm"> *</span>
<span class="cm"> * Note that, in lpfc_prep_els_iocb() routine, the reference count of ndlp</span>
<span class="cm"> * will be incremented by 1 for holding the ndlp and the reference to ndlp</span>
<span class="cm"> * will be stored into the context1 field of the IOCB for the completion</span>
<span class="cm"> * callback function to the RPS Accept Response ELS IOCB command.</span>
<span class="cm"> *</span>
<span class="cm"> * Return codes</span>
<span class="cm"> *   0 - Successfully processed rtv iocb (currently always return 0)</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">lpfc_els_rcv_rtv</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="n">vport</span><span class="p">,</span> <span class="k">struct</span> <span class="n">lpfc_iocbq</span> <span class="o">*</span><span class="n">cmdiocb</span><span class="p">,</span>
		 <span class="k">struct</span> <span class="n">lpfc_nodelist</span> <span class="o">*</span><span class="n">ndlp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span> <span class="o">=</span> <span class="n">vport</span><span class="o">-&gt;</span><span class="n">phba</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ls_rjt</span> <span class="n">stat</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">RTV_RSP</span> <span class="o">*</span><span class="n">rtv_rsp</span><span class="p">;</span>
	<span class="kt">uint8_t</span> <span class="o">*</span><span class="n">pcmd</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_iocbq</span> <span class="o">*</span><span class="n">elsiocb</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">cmdsize</span><span class="p">;</span>


	<span class="k">if</span> <span class="p">((</span><span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_state</span> <span class="o">!=</span> <span class="n">NLP_STE_UNMAPPED_NODE</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_state</span> <span class="o">!=</span> <span class="n">NLP_STE_MAPPED_NODE</span><span class="p">))</span>
		<span class="cm">/* reject the unsolicited RPS request and done with it */</span>
		<span class="k">goto</span> <span class="n">reject_out</span><span class="p">;</span>

	<span class="n">cmdsize</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">RTV_RSP</span><span class="p">)</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">uint32_t</span><span class="p">);</span>
	<span class="n">elsiocb</span> <span class="o">=</span> <span class="n">lpfc_prep_els_iocb</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">pport</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">cmdsize</span><span class="p">,</span>
				     <span class="n">lpfc_max_els_tries</span><span class="p">,</span> <span class="n">ndlp</span><span class="p">,</span>
				     <span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_DID</span><span class="p">,</span> <span class="n">ELS_CMD_ACC</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">elsiocb</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">pcmd</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint8_t</span> <span class="o">*</span><span class="p">)</span> <span class="p">(((</span><span class="k">struct</span> <span class="n">lpfc_dmabuf</span> <span class="o">*</span><span class="p">)</span> <span class="n">elsiocb</span><span class="o">-&gt;</span><span class="n">context2</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">virt</span><span class="p">);</span>
		<span class="o">*</span><span class="p">((</span><span class="kt">uint32_t</span> <span class="o">*</span><span class="p">)</span> <span class="p">(</span><span class="n">pcmd</span><span class="p">))</span> <span class="o">=</span> <span class="n">ELS_CMD_ACC</span><span class="p">;</span>
	<span class="n">pcmd</span> <span class="o">+=</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">uint32_t</span><span class="p">);</span> <span class="cm">/* Skip past command */</span>

	<span class="cm">/* use the command&#39;s xri in the response */</span>
	<span class="n">elsiocb</span><span class="o">-&gt;</span><span class="n">iocb</span><span class="p">.</span><span class="n">ulpContext</span> <span class="o">=</span> <span class="n">cmdiocb</span><span class="o">-&gt;</span><span class="n">iocb</span><span class="p">.</span><span class="n">ulpContext</span><span class="p">;</span>  <span class="cm">/* Xri / rx_id */</span>
	<span class="n">elsiocb</span><span class="o">-&gt;</span><span class="n">iocb</span><span class="p">.</span><span class="n">unsli3</span><span class="p">.</span><span class="n">rcvsli3</span><span class="p">.</span><span class="n">ox_id</span> <span class="o">=</span> <span class="n">cmdiocb</span><span class="o">-&gt;</span><span class="n">iocb</span><span class="p">.</span><span class="n">unsli3</span><span class="p">.</span><span class="n">rcvsli3</span><span class="p">.</span><span class="n">ox_id</span><span class="p">;</span>

	<span class="n">rtv_rsp</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">RTV_RSP</span> <span class="o">*</span><span class="p">)</span><span class="n">pcmd</span><span class="p">;</span>

	<span class="cm">/* populate RTV payload */</span>
	<span class="n">rtv_rsp</span><span class="o">-&gt;</span><span class="n">ratov</span> <span class="o">=</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">fc_ratov</span> <span class="o">*</span> <span class="mi">1000</span><span class="p">);</span> <span class="cm">/* report msecs */</span>
	<span class="n">rtv_rsp</span><span class="o">-&gt;</span><span class="n">edtov</span> <span class="o">=</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">fc_edtov</span><span class="p">);</span>
	<span class="n">bf_set</span><span class="p">(</span><span class="n">qtov_edtovres</span><span class="p">,</span> <span class="n">rtv_rsp</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">fc_edtovResol</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">bf_set</span><span class="p">(</span><span class="n">qtov_rttov</span><span class="p">,</span> <span class="n">rtv_rsp</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span> <span class="cm">/* Field is for FC ONLY */</span>
	<span class="n">rtv_rsp</span><span class="o">-&gt;</span><span class="n">qtov</span> <span class="o">=</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">rtv_rsp</span><span class="o">-&gt;</span><span class="n">qtov</span><span class="p">);</span>

	<span class="cm">/* Xmit ELS RLS ACC response tag &lt;ulpIoTag&gt; */</span>
	<span class="n">lpfc_printf_vlog</span><span class="p">(</span><span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">vport</span><span class="p">,</span> <span class="n">KERN_INFO</span><span class="p">,</span> <span class="n">LOG_ELS</span><span class="p">,</span>
			 <span class="s">&quot;2875 Xmit ELS RTV ACC response tag x%x xri x%x, &quot;</span>
			 <span class="s">&quot;did x%x, nlp_flag x%x, nlp_state x%x, rpi x%x, &quot;</span>
			 <span class="s">&quot;Data: x%x x%x x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			 <span class="n">elsiocb</span><span class="o">-&gt;</span><span class="n">iotag</span><span class="p">,</span> <span class="n">elsiocb</span><span class="o">-&gt;</span><span class="n">iocb</span><span class="p">.</span><span class="n">ulpContext</span><span class="p">,</span>
			 <span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_DID</span><span class="p">,</span> <span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_flag</span><span class="p">,</span> <span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_state</span><span class="p">,</span>
			 <span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_rpi</span><span class="p">,</span>
			<span class="n">rtv_rsp</span><span class="o">-&gt;</span><span class="n">ratov</span><span class="p">,</span> <span class="n">rtv_rsp</span><span class="o">-&gt;</span><span class="n">edtov</span><span class="p">,</span> <span class="n">rtv_rsp</span><span class="o">-&gt;</span><span class="n">qtov</span><span class="p">);</span>
	<span class="n">elsiocb</span><span class="o">-&gt;</span><span class="n">iocb_cmpl</span> <span class="o">=</span> <span class="n">lpfc_cmpl_els_rsp</span><span class="p">;</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">fc_stat</span><span class="p">.</span><span class="n">elsXmitACC</span><span class="o">++</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">lpfc_sli_issue_iocb</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">LPFC_ELS_RING</span><span class="p">,</span> <span class="n">elsiocb</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">==</span> <span class="n">IOCB_ERROR</span><span class="p">)</span>
		<span class="n">lpfc_els_free_iocb</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">elsiocb</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">reject_out:</span>
	<span class="cm">/* issue rejection response */</span>
	<span class="n">stat</span><span class="p">.</span><span class="n">un</span><span class="p">.</span><span class="n">b</span><span class="p">.</span><span class="n">lsRjtRsvd0</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">stat</span><span class="p">.</span><span class="n">un</span><span class="p">.</span><span class="n">b</span><span class="p">.</span><span class="n">lsRjtRsnCode</span> <span class="o">=</span> <span class="n">LSRJT_UNABLE_TPC</span><span class="p">;</span>
	<span class="n">stat</span><span class="p">.</span><span class="n">un</span><span class="p">.</span><span class="n">b</span><span class="p">.</span><span class="n">lsRjtRsnCodeExp</span> <span class="o">=</span> <span class="n">LSEXP_CANT_GIVE_DATA</span><span class="p">;</span>
	<span class="n">stat</span><span class="p">.</span><span class="n">un</span><span class="p">.</span><span class="n">b</span><span class="p">.</span><span class="n">vendorUnique</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">lpfc_els_rsp_reject</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">stat</span><span class="p">.</span><span class="n">un</span><span class="p">.</span><span class="n">lsRjtError</span><span class="p">,</span> <span class="n">cmdiocb</span><span class="p">,</span> <span class="n">ndlp</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* lpfc_els_rcv_rps - Process an unsolicited rps iocb</span>
<span class="cm"> * @vport: pointer to a host virtual N_Port data structure.</span>
<span class="cm"> * @cmdiocb: pointer to lpfc command iocb data structure.</span>
<span class="cm"> * @ndlp: pointer to a node-list data structure.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine processes Read Port Status (RPS) IOCB received as an</span>
<span class="cm"> * ELS unsolicited event. It first checks the remote port state. If the</span>
<span class="cm"> * remote port is not in NLP_STE_UNMAPPED_NODE state or NLP_STE_MAPPED_NODE</span>
<span class="cm"> * state, it invokes the lpfc_els_rsp_reject() routine to send the reject</span>
<span class="cm"> * response. Otherwise, it issue the MBX_READ_LNK_STAT mailbox command</span>
<span class="cm"> * for reading the HBA link statistics. It is for the callback function,</span>
<span class="cm"> * lpfc_els_rsp_rps_acc(), set to the MBX_READ_LNK_STAT mailbox command</span>
<span class="cm"> * to actually sending out RPS Accept (ACC) response.</span>
<span class="cm"> *</span>
<span class="cm"> * Return codes</span>
<span class="cm"> *   0 - Successfully processed rps iocb (currently always return 0)</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">lpfc_els_rcv_rps</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="n">vport</span><span class="p">,</span> <span class="k">struct</span> <span class="n">lpfc_iocbq</span> <span class="o">*</span><span class="n">cmdiocb</span><span class="p">,</span>
		 <span class="k">struct</span> <span class="n">lpfc_nodelist</span> <span class="o">*</span><span class="n">ndlp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span> <span class="o">=</span> <span class="n">vport</span><span class="o">-&gt;</span><span class="n">phba</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="o">*</span><span class="n">lp</span><span class="p">;</span>
	<span class="kt">uint8_t</span> <span class="n">flag</span><span class="p">;</span>
	<span class="n">LPFC_MBOXQ_t</span> <span class="o">*</span><span class="n">mbox</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_dmabuf</span> <span class="o">*</span><span class="n">pcmd</span><span class="p">;</span>
	<span class="n">RPS</span> <span class="o">*</span><span class="n">rps</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ls_rjt</span> <span class="n">stat</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_state</span> <span class="o">!=</span> <span class="n">NLP_STE_UNMAPPED_NODE</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_state</span> <span class="o">!=</span> <span class="n">NLP_STE_MAPPED_NODE</span><span class="p">))</span>
		<span class="cm">/* reject the unsolicited RPS request and done with it */</span>
		<span class="k">goto</span> <span class="n">reject_out</span><span class="p">;</span>

	<span class="n">pcmd</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_dmabuf</span> <span class="o">*</span><span class="p">)</span> <span class="n">cmdiocb</span><span class="o">-&gt;</span><span class="n">context2</span><span class="p">;</span>
	<span class="n">lp</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint32_t</span> <span class="o">*</span><span class="p">)</span> <span class="n">pcmd</span><span class="o">-&gt;</span><span class="n">virt</span><span class="p">;</span>
	<span class="n">flag</span> <span class="o">=</span> <span class="p">(</span><span class="n">be32_to_cpu</span><span class="p">(</span><span class="o">*</span><span class="n">lp</span><span class="o">++</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xf</span><span class="p">);</span>
	<span class="n">rps</span> <span class="o">=</span> <span class="p">(</span><span class="n">RPS</span> <span class="o">*</span><span class="p">)</span> <span class="n">lp</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">flag</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">||</span>
	    <span class="p">((</span><span class="n">flag</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">rps</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">portNum</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span> <span class="o">||</span>
	    <span class="p">((</span><span class="n">flag</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">memcmp</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rps</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">portName</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_portname</span><span class="p">,</span>
				    <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_name</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)))</span> <span class="p">{</span>

		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;Fix me....</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">dump_stack</span><span class="p">();</span>
		<span class="n">mbox</span> <span class="o">=</span> <span class="n">mempool_alloc</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">mbox_mem_pool</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">mbox</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">lpfc_read_lnk_stat</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">mbox</span><span class="p">);</span>
			<span class="n">mbox</span><span class="o">-&gt;</span><span class="n">context1</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span>
				<span class="p">((</span><span class="n">cmdiocb</span><span class="o">-&gt;</span><span class="n">iocb</span><span class="p">.</span><span class="n">unsli3</span><span class="p">.</span><span class="n">rcvsli3</span><span class="p">.</span><span class="n">ox_id</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">|</span>
				<span class="n">cmdiocb</span><span class="o">-&gt;</span><span class="n">iocb</span><span class="p">.</span><span class="n">ulpContext</span><span class="p">));</span> <span class="cm">/* rx_id */</span>
			<span class="n">mbox</span><span class="o">-&gt;</span><span class="n">context2</span> <span class="o">=</span> <span class="n">lpfc_nlp_get</span><span class="p">(</span><span class="n">ndlp</span><span class="p">);</span>
			<span class="n">mbox</span><span class="o">-&gt;</span><span class="n">vport</span> <span class="o">=</span> <span class="n">vport</span><span class="p">;</span>
			<span class="n">mbox</span><span class="o">-&gt;</span><span class="n">mbox_cmpl</span> <span class="o">=</span> <span class="n">lpfc_els_rsp_rps_acc</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">lpfc_sli_issue_mbox</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">mbox</span><span class="p">,</span> <span class="n">MBX_NOWAIT</span><span class="p">)</span>
				<span class="o">!=</span> <span class="n">MBX_NOT_FINISHED</span><span class="p">)</span>
				<span class="cm">/* Mbox completion will send ELS Response */</span>
				<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
			<span class="cm">/* Decrement reference count used for the failed mbox</span>
<span class="cm">			 * command.</span>
<span class="cm">			 */</span>
			<span class="n">lpfc_nlp_put</span><span class="p">(</span><span class="n">ndlp</span><span class="p">);</span>
			<span class="n">mempool_free</span><span class="p">(</span><span class="n">mbox</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">mbox_mem_pool</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

<span class="nl">reject_out:</span>
	<span class="cm">/* issue rejection response */</span>
	<span class="n">stat</span><span class="p">.</span><span class="n">un</span><span class="p">.</span><span class="n">b</span><span class="p">.</span><span class="n">lsRjtRsvd0</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">stat</span><span class="p">.</span><span class="n">un</span><span class="p">.</span><span class="n">b</span><span class="p">.</span><span class="n">lsRjtRsnCode</span> <span class="o">=</span> <span class="n">LSRJT_UNABLE_TPC</span><span class="p">;</span>
	<span class="n">stat</span><span class="p">.</span><span class="n">un</span><span class="p">.</span><span class="n">b</span><span class="p">.</span><span class="n">lsRjtRsnCodeExp</span> <span class="o">=</span> <span class="n">LSEXP_CANT_GIVE_DATA</span><span class="p">;</span>
	<span class="n">stat</span><span class="p">.</span><span class="n">un</span><span class="p">.</span><span class="n">b</span><span class="p">.</span><span class="n">vendorUnique</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">lpfc_els_rsp_reject</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">stat</span><span class="p">.</span><span class="n">un</span><span class="p">.</span><span class="n">lsRjtError</span><span class="p">,</span> <span class="n">cmdiocb</span><span class="p">,</span> <span class="n">ndlp</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* lpfc_issue_els_rrq - Process an unsolicited rps iocb</span>
<span class="cm"> * @vport: pointer to a host virtual N_Port data structure.</span>
<span class="cm"> * @ndlp: pointer to a node-list data structure.</span>
<span class="cm"> * @did: DID of the target.</span>
<span class="cm"> * @rrq: Pointer to the rrq struct.</span>
<span class="cm"> *</span>
<span class="cm"> * Build a ELS RRQ command and send it to the target. If the issue_iocb is</span>
<span class="cm"> * Successful the the completion handler will clear the RRQ.</span>
<span class="cm"> *</span>
<span class="cm"> * Return codes</span>
<span class="cm"> *   0 - Successfully sent rrq els iocb.</span>
<span class="cm"> *   1 - Failed to send rrq els iocb.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">lpfc_issue_els_rrq</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="n">vport</span><span class="p">,</span> <span class="k">struct</span> <span class="n">lpfc_nodelist</span> <span class="o">*</span><span class="n">ndlp</span><span class="p">,</span>
			<span class="kt">uint32_t</span> <span class="n">did</span><span class="p">,</span> <span class="k">struct</span> <span class="n">lpfc_node_rrq</span> <span class="o">*</span><span class="n">rrq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpfc_hba</span>  <span class="o">*</span><span class="n">phba</span> <span class="o">=</span> <span class="n">vport</span><span class="o">-&gt;</span><span class="n">phba</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">RRQ</span> <span class="o">*</span><span class="n">els_rrq</span><span class="p">;</span>
	<span class="n">IOCB_t</span> <span class="o">*</span><span class="n">icmd</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_iocbq</span> <span class="o">*</span><span class="n">elsiocb</span><span class="p">;</span>
	<span class="kt">uint8_t</span> <span class="o">*</span><span class="n">pcmd</span><span class="p">;</span>
	<span class="kt">uint16_t</span> <span class="n">cmdsize</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>


	<span class="k">if</span> <span class="p">(</span><span class="n">ndlp</span> <span class="o">!=</span> <span class="n">rrq</span><span class="o">-&gt;</span><span class="n">ndlp</span><span class="p">)</span>
		<span class="n">ndlp</span> <span class="o">=</span> <span class="n">rrq</span><span class="o">-&gt;</span><span class="n">ndlp</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ndlp</span> <span class="o">||</span> <span class="o">!</span><span class="n">NLP_CHK_NODE_ACT</span><span class="p">(</span><span class="n">ndlp</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/* If ndlp is not NULL, we will bump the reference count on it */</span>
	<span class="n">cmdsize</span> <span class="o">=</span> <span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">uint32_t</span><span class="p">)</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">RRQ</span><span class="p">));</span>
	<span class="n">elsiocb</span> <span class="o">=</span> <span class="n">lpfc_prep_els_iocb</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">cmdsize</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">ndlp</span><span class="p">,</span> <span class="n">did</span><span class="p">,</span>
				     <span class="n">ELS_CMD_RRQ</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">elsiocb</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">icmd</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">elsiocb</span><span class="o">-&gt;</span><span class="n">iocb</span><span class="p">;</span>
	<span class="n">pcmd</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint8_t</span> <span class="o">*</span><span class="p">)</span> <span class="p">(((</span><span class="k">struct</span> <span class="n">lpfc_dmabuf</span> <span class="o">*</span><span class="p">)</span> <span class="n">elsiocb</span><span class="o">-&gt;</span><span class="n">context2</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">virt</span><span class="p">);</span>

	<span class="cm">/* For RRQ request, remainder of payload is Exchange IDs */</span>
	<span class="o">*</span><span class="p">((</span><span class="kt">uint32_t</span> <span class="o">*</span><span class="p">)</span> <span class="p">(</span><span class="n">pcmd</span><span class="p">))</span> <span class="o">=</span> <span class="n">ELS_CMD_RRQ</span><span class="p">;</span>
	<span class="n">pcmd</span> <span class="o">+=</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">uint32_t</span><span class="p">);</span>
	<span class="n">els_rrq</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">RRQ</span> <span class="o">*</span><span class="p">)</span> <span class="n">pcmd</span><span class="p">;</span>

	<span class="n">bf_set</span><span class="p">(</span><span class="n">rrq_oxid</span><span class="p">,</span> <span class="n">els_rrq</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">xri_ids</span><span class="p">[</span><span class="n">rrq</span><span class="o">-&gt;</span><span class="n">xritag</span><span class="p">]);</span>
	<span class="n">bf_set</span><span class="p">(</span><span class="n">rrq_rxid</span><span class="p">,</span> <span class="n">els_rrq</span><span class="p">,</span> <span class="n">rrq</span><span class="o">-&gt;</span><span class="n">rxid</span><span class="p">);</span>
	<span class="n">bf_set</span><span class="p">(</span><span class="n">rrq_did</span><span class="p">,</span> <span class="n">els_rrq</span><span class="p">,</span> <span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_myDID</span><span class="p">);</span>
	<span class="n">els_rrq</span><span class="o">-&gt;</span><span class="n">rrq</span> <span class="o">=</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">els_rrq</span><span class="o">-&gt;</span><span class="n">rrq</span><span class="p">);</span>
	<span class="n">els_rrq</span><span class="o">-&gt;</span><span class="n">rrq_exchg</span> <span class="o">=</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">els_rrq</span><span class="o">-&gt;</span><span class="n">rrq_exchg</span><span class="p">);</span>


	<span class="n">lpfc_debugfs_disc_trc</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">LPFC_DISC_TRC_ELS_CMD</span><span class="p">,</span>
		<span class="s">&quot;Issue RRQ:     did:x%x&quot;</span><span class="p">,</span>
		<span class="n">did</span><span class="p">,</span> <span class="n">rrq</span><span class="o">-&gt;</span><span class="n">xritag</span><span class="p">,</span> <span class="n">rrq</span><span class="o">-&gt;</span><span class="n">rxid</span><span class="p">);</span>
	<span class="n">elsiocb</span><span class="o">-&gt;</span><span class="n">context_un</span><span class="p">.</span><span class="n">rrq</span> <span class="o">=</span> <span class="n">rrq</span><span class="p">;</span>
	<span class="n">elsiocb</span><span class="o">-&gt;</span><span class="n">iocb_cmpl</span> <span class="o">=</span> <span class="n">lpfc_cmpl_els_rrq</span><span class="p">;</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">lpfc_sli_issue_iocb</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">LPFC_ELS_RING</span><span class="p">,</span> <span class="n">elsiocb</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="n">IOCB_ERROR</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lpfc_els_free_iocb</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">elsiocb</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_send_rrq - Sends ELS RRQ if needed.</span>
<span class="cm"> * @phba: pointer to lpfc hba data structure.</span>
<span class="cm"> * @rrq: pointer to the active rrq.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine will call the lpfc_issue_els_rrq if the rrq is</span>
<span class="cm"> * still active for the xri. If this function returns a failure then</span>
<span class="cm"> * the caller needs to clean up the RRQ by calling lpfc_clr_active_rrq.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 0 Success.</span>
<span class="cm"> *         1 Failure.</span>
<span class="cm"> **/</span>
<span class="kt">int</span>
<span class="nf">lpfc_send_rrq</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">,</span> <span class="k">struct</span> <span class="n">lpfc_node_rrq</span> <span class="o">*</span><span class="n">rrq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpfc_nodelist</span> <span class="o">*</span><span class="n">ndlp</span> <span class="o">=</span> <span class="n">lpfc_findnode_did</span><span class="p">(</span><span class="n">rrq</span><span class="o">-&gt;</span><span class="n">vport</span><span class="p">,</span>
							<span class="n">rrq</span><span class="o">-&gt;</span><span class="n">nlp_DID</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">lpfc_test_rrq_active</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">ndlp</span><span class="p">,</span> <span class="n">rrq</span><span class="o">-&gt;</span><span class="n">xritag</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">lpfc_issue_els_rrq</span><span class="p">(</span><span class="n">rrq</span><span class="o">-&gt;</span><span class="n">vport</span><span class="p">,</span> <span class="n">ndlp</span><span class="p">,</span>
					 <span class="n">rrq</span><span class="o">-&gt;</span><span class="n">nlp_DID</span><span class="p">,</span> <span class="n">rrq</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_els_rsp_rpl_acc - Issue an accept rpl els command</span>
<span class="cm"> * @vport: pointer to a host virtual N_Port data structure.</span>
<span class="cm"> * @cmdsize: size of the ELS command.</span>
<span class="cm"> * @oldiocb: pointer to the original lpfc command iocb data structure.</span>
<span class="cm"> * @ndlp: pointer to a node-list data structure.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine issuees an Accept (ACC) Read Port List (RPL) ELS command.</span>
<span class="cm"> * It is to be called by the lpfc_els_rcv_rpl() routine to accept the RPL.</span>
<span class="cm"> *</span>
<span class="cm"> * Note that, in lpfc_prep_els_iocb() routine, the reference count of ndlp</span>
<span class="cm"> * will be incremented by 1 for holding the ndlp and the reference to ndlp</span>
<span class="cm"> * will be stored into the context1 field of the IOCB for the completion</span>
<span class="cm"> * callback function to the RPL Accept Response ELS command.</span>
<span class="cm"> *</span>
<span class="cm"> * Return code</span>
<span class="cm"> *   0 - Successfully issued ACC RPL ELS command</span>
<span class="cm"> *   1 - Failed to issue ACC RPL ELS command</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">lpfc_els_rsp_rpl_acc</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="n">vport</span><span class="p">,</span> <span class="kt">uint16_t</span> <span class="n">cmdsize</span><span class="p">,</span>
		     <span class="k">struct</span> <span class="n">lpfc_iocbq</span> <span class="o">*</span><span class="n">oldiocb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">lpfc_nodelist</span> <span class="o">*</span><span class="n">ndlp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span> <span class="o">=</span> <span class="n">vport</span><span class="o">-&gt;</span><span class="n">phba</span><span class="p">;</span>
	<span class="n">IOCB_t</span> <span class="o">*</span><span class="n">icmd</span><span class="p">,</span> <span class="o">*</span><span class="n">oldcmd</span><span class="p">;</span>
	<span class="n">RPL_RSP</span> <span class="n">rpl_rsp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_iocbq</span> <span class="o">*</span><span class="n">elsiocb</span><span class="p">;</span>
	<span class="kt">uint8_t</span> <span class="o">*</span><span class="n">pcmd</span><span class="p">;</span>

	<span class="n">elsiocb</span> <span class="o">=</span> <span class="n">lpfc_prep_els_iocb</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">cmdsize</span><span class="p">,</span> <span class="n">oldiocb</span><span class="o">-&gt;</span><span class="n">retry</span><span class="p">,</span> <span class="n">ndlp</span><span class="p">,</span>
				     <span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_DID</span><span class="p">,</span> <span class="n">ELS_CMD_ACC</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">elsiocb</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">icmd</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">elsiocb</span><span class="o">-&gt;</span><span class="n">iocb</span><span class="p">;</span>
	<span class="n">oldcmd</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">oldiocb</span><span class="o">-&gt;</span><span class="n">iocb</span><span class="p">;</span>
	<span class="n">icmd</span><span class="o">-&gt;</span><span class="n">ulpContext</span> <span class="o">=</span> <span class="n">oldcmd</span><span class="o">-&gt;</span><span class="n">ulpContext</span><span class="p">;</span>	<span class="cm">/* Xri / rx_id */</span>
	<span class="n">icmd</span><span class="o">-&gt;</span><span class="n">unsli3</span><span class="p">.</span><span class="n">rcvsli3</span><span class="p">.</span><span class="n">ox_id</span> <span class="o">=</span> <span class="n">oldcmd</span><span class="o">-&gt;</span><span class="n">unsli3</span><span class="p">.</span><span class="n">rcvsli3</span><span class="p">.</span><span class="n">ox_id</span><span class="p">;</span>

	<span class="n">pcmd</span> <span class="o">=</span> <span class="p">(((</span><span class="k">struct</span> <span class="n">lpfc_dmabuf</span> <span class="o">*</span><span class="p">)</span> <span class="n">elsiocb</span><span class="o">-&gt;</span><span class="n">context2</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">virt</span><span class="p">);</span>
	<span class="o">*</span><span class="p">((</span><span class="kt">uint32_t</span> <span class="o">*</span><span class="p">)</span> <span class="p">(</span><span class="n">pcmd</span><span class="p">))</span> <span class="o">=</span> <span class="n">ELS_CMD_ACC</span><span class="p">;</span>
	<span class="n">pcmd</span> <span class="o">+=</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">uint16_t</span><span class="p">);</span>
	<span class="o">*</span><span class="p">((</span><span class="kt">uint16_t</span> <span class="o">*</span><span class="p">)(</span><span class="n">pcmd</span><span class="p">))</span> <span class="o">=</span> <span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">cmdsize</span><span class="p">);</span>
	<span class="n">pcmd</span> <span class="o">+=</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">uint16_t</span><span class="p">);</span>

	<span class="cm">/* Setup the RPL ACC payload */</span>
	<span class="n">rpl_rsp</span><span class="p">.</span><span class="n">listLen</span> <span class="o">=</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
	<span class="n">rpl_rsp</span><span class="p">.</span><span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">rpl_rsp</span><span class="p">.</span><span class="n">port_num_blk</span><span class="p">.</span><span class="n">portNum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">rpl_rsp</span><span class="p">.</span><span class="n">port_num_blk</span><span class="p">.</span><span class="n">portID</span> <span class="o">=</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_myDID</span><span class="p">);</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rpl_rsp</span><span class="p">.</span><span class="n">port_num_blk</span><span class="p">.</span><span class="n">portName</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_portname</span><span class="p">,</span>
	    <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_name</span><span class="p">));</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">pcmd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rpl_rsp</span><span class="p">,</span> <span class="n">cmdsize</span> <span class="o">-</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">uint32_t</span><span class="p">));</span>
	<span class="cm">/* Xmit ELS RPL ACC response tag &lt;ulpIoTag&gt; */</span>
	<span class="n">lpfc_printf_vlog</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">KERN_INFO</span><span class="p">,</span> <span class="n">LOG_ELS</span><span class="p">,</span>
			 <span class="s">&quot;0120 Xmit ELS RPL ACC response tag x%x &quot;</span>
			 <span class="s">&quot;xri x%x, did x%x, nlp_flag x%x, nlp_state x%x, &quot;</span>
			 <span class="s">&quot;rpi x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			 <span class="n">elsiocb</span><span class="o">-&gt;</span><span class="n">iotag</span><span class="p">,</span> <span class="n">elsiocb</span><span class="o">-&gt;</span><span class="n">iocb</span><span class="p">.</span><span class="n">ulpContext</span><span class="p">,</span>
			 <span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_DID</span><span class="p">,</span> <span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_flag</span><span class="p">,</span> <span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_state</span><span class="p">,</span>
			 <span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_rpi</span><span class="p">);</span>
	<span class="n">elsiocb</span><span class="o">-&gt;</span><span class="n">iocb_cmpl</span> <span class="o">=</span> <span class="n">lpfc_cmpl_els_rsp</span><span class="p">;</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">fc_stat</span><span class="p">.</span><span class="n">elsXmitACC</span><span class="o">++</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">lpfc_sli_issue_iocb</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">LPFC_ELS_RING</span><span class="p">,</span> <span class="n">elsiocb</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">==</span>
	    <span class="n">IOCB_ERROR</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lpfc_els_free_iocb</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">elsiocb</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_els_rcv_rpl - Process an unsolicited rpl iocb</span>
<span class="cm"> * @vport: pointer to a host virtual N_Port data structure.</span>
<span class="cm"> * @cmdiocb: pointer to lpfc command iocb data structure.</span>
<span class="cm"> * @ndlp: pointer to a node-list data structure.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine processes Read Port List (RPL) IOCB received as an ELS</span>
<span class="cm"> * unsolicited event. It first checks the remote port state. If the remote</span>
<span class="cm"> * port is not in NLP_STE_UNMAPPED_NODE and NLP_STE_MAPPED_NODE states, it</span>
<span class="cm"> * invokes the lpfc_els_rsp_reject() routine to send reject response.</span>
<span class="cm"> * Otherwise, this routine then invokes the lpfc_els_rsp_rpl_acc() routine</span>
<span class="cm"> * to accept the RPL.</span>
<span class="cm"> *</span>
<span class="cm"> * Return code</span>
<span class="cm"> *   0 - Successfully processed rpl iocb (currently always return 0)</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">lpfc_els_rcv_rpl</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="n">vport</span><span class="p">,</span> <span class="k">struct</span> <span class="n">lpfc_iocbq</span> <span class="o">*</span><span class="n">cmdiocb</span><span class="p">,</span>
		 <span class="k">struct</span> <span class="n">lpfc_nodelist</span> <span class="o">*</span><span class="n">ndlp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpfc_dmabuf</span> <span class="o">*</span><span class="n">pcmd</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="o">*</span><span class="n">lp</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">maxsize</span><span class="p">;</span>
	<span class="kt">uint16_t</span> <span class="n">cmdsize</span><span class="p">;</span>
	<span class="n">RPL</span> <span class="o">*</span><span class="n">rpl</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ls_rjt</span> <span class="n">stat</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_state</span> <span class="o">!=</span> <span class="n">NLP_STE_UNMAPPED_NODE</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_state</span> <span class="o">!=</span> <span class="n">NLP_STE_MAPPED_NODE</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* issue rejection response */</span>
		<span class="n">stat</span><span class="p">.</span><span class="n">un</span><span class="p">.</span><span class="n">b</span><span class="p">.</span><span class="n">lsRjtRsvd0</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">stat</span><span class="p">.</span><span class="n">un</span><span class="p">.</span><span class="n">b</span><span class="p">.</span><span class="n">lsRjtRsnCode</span> <span class="o">=</span> <span class="n">LSRJT_UNABLE_TPC</span><span class="p">;</span>
		<span class="n">stat</span><span class="p">.</span><span class="n">un</span><span class="p">.</span><span class="n">b</span><span class="p">.</span><span class="n">lsRjtRsnCodeExp</span> <span class="o">=</span> <span class="n">LSEXP_CANT_GIVE_DATA</span><span class="p">;</span>
		<span class="n">stat</span><span class="p">.</span><span class="n">un</span><span class="p">.</span><span class="n">b</span><span class="p">.</span><span class="n">vendorUnique</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">lpfc_els_rsp_reject</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">stat</span><span class="p">.</span><span class="n">un</span><span class="p">.</span><span class="n">lsRjtError</span><span class="p">,</span> <span class="n">cmdiocb</span><span class="p">,</span> <span class="n">ndlp</span><span class="p">,</span>
			<span class="nb">NULL</span><span class="p">);</span>
		<span class="cm">/* rejected the unsolicited RPL request and done with it */</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">pcmd</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_dmabuf</span> <span class="o">*</span><span class="p">)</span> <span class="n">cmdiocb</span><span class="o">-&gt;</span><span class="n">context2</span><span class="p">;</span>
	<span class="n">lp</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint32_t</span> <span class="o">*</span><span class="p">)</span> <span class="n">pcmd</span><span class="o">-&gt;</span><span class="n">virt</span><span class="p">;</span>
	<span class="n">rpl</span> <span class="o">=</span> <span class="p">(</span><span class="n">RPL</span> <span class="o">*</span><span class="p">)</span> <span class="p">(</span><span class="n">lp</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">maxsize</span> <span class="o">=</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">rpl</span><span class="o">-&gt;</span><span class="n">maxsize</span><span class="p">);</span>

	<span class="cm">/* We support only one port */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">rpl</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="p">((</span><span class="n">maxsize</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">||</span>
	     <span class="p">((</span><span class="n">maxsize</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">uint32_t</span><span class="p">))</span> <span class="o">&gt;=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">RPL_RSP</span><span class="p">))))</span> <span class="p">{</span>
		<span class="n">cmdsize</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">uint32_t</span><span class="p">)</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">RPL_RSP</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">cmdsize</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">uint32_t</span><span class="p">)</span> <span class="o">+</span> <span class="n">maxsize</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">uint32_t</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">lpfc_els_rsp_rpl_acc</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">cmdsize</span><span class="p">,</span> <span class="n">cmdiocb</span><span class="p">,</span> <span class="n">ndlp</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_els_rcv_farp - Process an unsolicited farp request els command</span>
<span class="cm"> * @vport: pointer to a virtual N_Port data structure.</span>
<span class="cm"> * @cmdiocb: pointer to lpfc command iocb data structure.</span>
<span class="cm"> * @ndlp: pointer to a node-list data structure.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine processes Fibre Channel Address Resolution Protocol</span>
<span class="cm"> * (FARP) Request IOCB received as an ELS unsolicited event. Currently,</span>
<span class="cm"> * the lpfc driver only supports matching on WWPN or WWNN for FARP. As such,</span>
<span class="cm"> * FARP_MATCH_PORT flag and FARP_MATCH_NODE flag are checked against the</span>
<span class="cm"> * Match Flag in the FARP request IOCB: if FARP_MATCH_PORT flag is set, the</span>
<span class="cm"> * remote PortName is compared against the FC PortName stored in the @vport</span>
<span class="cm"> * data structure; if FARP_MATCH_NODE flag is set, the remote NodeName is</span>
<span class="cm"> * compared against the FC NodeName stored in the @vport data structure.</span>
<span class="cm"> * If any of these matches and the FARP_REQUEST_FARPR flag is set in the</span>
<span class="cm"> * FARP request IOCB Response Flag, the lpfc_issue_els_farpr() routine is</span>
<span class="cm"> * invoked to send out FARP Response to the remote node. Before sending the</span>
<span class="cm"> * FARP Response, however, the FARP_REQUEST_PLOGI flag is check in the FARP</span>
<span class="cm"> * request IOCB Response Flag and, if it is set, the lpfc_issue_els_plogi()</span>
<span class="cm"> * routine is invoked to log into the remote port first.</span>
<span class="cm"> *</span>
<span class="cm"> * Return code</span>
<span class="cm"> *   0 - Either the FARP Match Mode not supported or successfully processed</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">lpfc_els_rcv_farp</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="n">vport</span><span class="p">,</span> <span class="k">struct</span> <span class="n">lpfc_iocbq</span> <span class="o">*</span><span class="n">cmdiocb</span><span class="p">,</span>
		  <span class="k">struct</span> <span class="n">lpfc_nodelist</span> <span class="o">*</span><span class="n">ndlp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpfc_dmabuf</span> <span class="o">*</span><span class="n">pcmd</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="o">*</span><span class="n">lp</span><span class="p">;</span>
	<span class="n">IOCB_t</span> <span class="o">*</span><span class="n">icmd</span><span class="p">;</span>
	<span class="n">FARP</span> <span class="o">*</span><span class="n">fp</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">cmd</span><span class="p">,</span> <span class="n">cnt</span><span class="p">,</span> <span class="n">did</span><span class="p">;</span>

	<span class="n">icmd</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">cmdiocb</span><span class="o">-&gt;</span><span class="n">iocb</span><span class="p">;</span>
	<span class="n">did</span> <span class="o">=</span> <span class="n">icmd</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">elsreq64</span><span class="p">.</span><span class="n">remoteID</span><span class="p">;</span>
	<span class="n">pcmd</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_dmabuf</span> <span class="o">*</span><span class="p">)</span> <span class="n">cmdiocb</span><span class="o">-&gt;</span><span class="n">context2</span><span class="p">;</span>
	<span class="n">lp</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint32_t</span> <span class="o">*</span><span class="p">)</span> <span class="n">pcmd</span><span class="o">-&gt;</span><span class="n">virt</span><span class="p">;</span>

	<span class="n">cmd</span> <span class="o">=</span> <span class="o">*</span><span class="n">lp</span><span class="o">++</span><span class="p">;</span>
	<span class="n">fp</span> <span class="o">=</span> <span class="p">(</span><span class="n">FARP</span> <span class="o">*</span><span class="p">)</span> <span class="n">lp</span><span class="p">;</span>
	<span class="cm">/* FARP-REQ received from DID &lt;did&gt; */</span>
	<span class="n">lpfc_printf_vlog</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">KERN_INFO</span><span class="p">,</span> <span class="n">LOG_ELS</span><span class="p">,</span>
			 <span class="s">&quot;0601 FARP-REQ received from DID x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">did</span><span class="p">);</span>
	<span class="cm">/* We will only support match on WWPN or WWNN */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">fp</span><span class="o">-&gt;</span><span class="n">Mflags</span> <span class="o">&amp;</span> <span class="o">~</span><span class="p">(</span><span class="n">FARP_MATCH_NODE</span> <span class="o">|</span> <span class="n">FARP_MATCH_PORT</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="cm">/* If this FARP command is searching for my portname */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">fp</span><span class="o">-&gt;</span><span class="n">Mflags</span> <span class="o">&amp;</span> <span class="n">FARP_MATCH_PORT</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">memcmp</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fp</span><span class="o">-&gt;</span><span class="n">RportName</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_portname</span><span class="p">,</span>
			   <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_name</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">cnt</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* If this FARP command is searching for my nodename */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">fp</span><span class="o">-&gt;</span><span class="n">Mflags</span> <span class="o">&amp;</span> <span class="n">FARP_MATCH_NODE</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">memcmp</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fp</span><span class="o">-&gt;</span><span class="n">RnodeName</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_nodename</span><span class="p">,</span>
			   <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_name</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">cnt</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cnt</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_state</span> <span class="o">==</span> <span class="n">NLP_STE_UNMAPPED_NODE</span><span class="p">)</span> <span class="o">||</span>
		   <span class="p">(</span><span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_state</span> <span class="o">==</span> <span class="n">NLP_STE_MAPPED_NODE</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/* Log back into the node before sending the FARP. */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">fp</span><span class="o">-&gt;</span><span class="n">Rflags</span> <span class="o">&amp;</span> <span class="n">FARP_REQUEST_PLOGI</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_prev_state</span> <span class="o">=</span> <span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_state</span><span class="p">;</span>
				<span class="n">lpfc_nlp_set_state</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">ndlp</span><span class="p">,</span>
						   <span class="n">NLP_STE_PLOGI_ISSUE</span><span class="p">);</span>
				<span class="n">lpfc_issue_els_plogi</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_DID</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
			<span class="p">}</span>

			<span class="cm">/* Send a FARP response to that node */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">fp</span><span class="o">-&gt;</span><span class="n">Rflags</span> <span class="o">&amp;</span> <span class="n">FARP_REQUEST_FARPR</span><span class="p">)</span>
				<span class="n">lpfc_issue_els_farpr</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">did</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_els_rcv_farpr - Process an unsolicited farp response iocb</span>
<span class="cm"> * @vport: pointer to a host virtual N_Port data structure.</span>
<span class="cm"> * @cmdiocb: pointer to lpfc command iocb data structure.</span>
<span class="cm"> * @ndlp: pointer to a node-list data structure.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine processes Fibre Channel Address Resolution Protocol</span>
<span class="cm"> * Response (FARPR) IOCB received as an ELS unsolicited event. It simply</span>
<span class="cm"> * invokes the lpfc_els_rsp_acc() routine to the remote node to accept</span>
<span class="cm"> * the FARP response request.</span>
<span class="cm"> *</span>
<span class="cm"> * Return code</span>
<span class="cm"> *   0 - Successfully processed FARPR IOCB (currently always return 0)</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">lpfc_els_rcv_farpr</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="n">vport</span><span class="p">,</span> <span class="k">struct</span> <span class="n">lpfc_iocbq</span> <span class="o">*</span><span class="n">cmdiocb</span><span class="p">,</span>
		   <span class="k">struct</span> <span class="n">lpfc_nodelist</span>  <span class="o">*</span><span class="n">ndlp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpfc_dmabuf</span> <span class="o">*</span><span class="n">pcmd</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="o">*</span><span class="n">lp</span><span class="p">;</span>
	<span class="n">IOCB_t</span> <span class="o">*</span><span class="n">icmd</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">cmd</span><span class="p">,</span> <span class="n">did</span><span class="p">;</span>

	<span class="n">icmd</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">cmdiocb</span><span class="o">-&gt;</span><span class="n">iocb</span><span class="p">;</span>
	<span class="n">did</span> <span class="o">=</span> <span class="n">icmd</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">elsreq64</span><span class="p">.</span><span class="n">remoteID</span><span class="p">;</span>
	<span class="n">pcmd</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_dmabuf</span> <span class="o">*</span><span class="p">)</span> <span class="n">cmdiocb</span><span class="o">-&gt;</span><span class="n">context2</span><span class="p">;</span>
	<span class="n">lp</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint32_t</span> <span class="o">*</span><span class="p">)</span> <span class="n">pcmd</span><span class="o">-&gt;</span><span class="n">virt</span><span class="p">;</span>

	<span class="n">cmd</span> <span class="o">=</span> <span class="o">*</span><span class="n">lp</span><span class="o">++</span><span class="p">;</span>
	<span class="cm">/* FARP-RSP received from DID &lt;did&gt; */</span>
	<span class="n">lpfc_printf_vlog</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">KERN_INFO</span><span class="p">,</span> <span class="n">LOG_ELS</span><span class="p">,</span>
			 <span class="s">&quot;0600 FARP-RSP received from DID x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">did</span><span class="p">);</span>
	<span class="cm">/* ACCEPT the Farp resp request */</span>
	<span class="n">lpfc_els_rsp_acc</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">ELS_CMD_ACC</span><span class="p">,</span> <span class="n">cmdiocb</span><span class="p">,</span> <span class="n">ndlp</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_els_rcv_fan - Process an unsolicited fan iocb command</span>
<span class="cm"> * @vport: pointer to a host virtual N_Port data structure.</span>
<span class="cm"> * @cmdiocb: pointer to lpfc command iocb data structure.</span>
<span class="cm"> * @fan_ndlp: pointer to a node-list data structure.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine processes a Fabric Address Notification (FAN) IOCB</span>
<span class="cm"> * command received as an ELS unsolicited event. The FAN ELS command will</span>
<span class="cm"> * only be processed on a physical port (i.e., the @vport represents the</span>
<span class="cm"> * physical port). The fabric NodeName and PortName from the FAN IOCB are</span>
<span class="cm"> * compared against those in the phba data structure. If any of those is</span>
<span class="cm"> * different, the lpfc_initial_flogi() routine is invoked to initialize</span>
<span class="cm"> * Fabric Login (FLOGI) to the fabric to start the discover over. Otherwise,</span>
<span class="cm"> * if both of those are identical, the lpfc_issue_fabric_reglogin() routine</span>
<span class="cm"> * is invoked to register login to the fabric.</span>
<span class="cm"> *</span>
<span class="cm"> * Return code</span>
<span class="cm"> *   0 - Successfully processed fan iocb (currently always return 0).</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">lpfc_els_rcv_fan</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="n">vport</span><span class="p">,</span> <span class="k">struct</span> <span class="n">lpfc_iocbq</span> <span class="o">*</span><span class="n">cmdiocb</span><span class="p">,</span>
		 <span class="k">struct</span> <span class="n">lpfc_nodelist</span> <span class="o">*</span><span class="n">fan_ndlp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span> <span class="o">=</span> <span class="n">vport</span><span class="o">-&gt;</span><span class="n">phba</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="o">*</span><span class="n">lp</span><span class="p">;</span>
	<span class="n">FAN</span> <span class="o">*</span><span class="n">fp</span><span class="p">;</span>

	<span class="n">lpfc_printf_vlog</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">KERN_INFO</span><span class="p">,</span> <span class="n">LOG_ELS</span><span class="p">,</span> <span class="s">&quot;0265 FAN received</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">lp</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint32_t</span> <span class="o">*</span><span class="p">)((</span><span class="k">struct</span> <span class="n">lpfc_dmabuf</span> <span class="o">*</span><span class="p">)</span><span class="n">cmdiocb</span><span class="o">-&gt;</span><span class="n">context2</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">virt</span><span class="p">;</span>
	<span class="n">fp</span> <span class="o">=</span> <span class="p">(</span><span class="n">FAN</span> <span class="o">*</span><span class="p">)</span> <span class="o">++</span><span class="n">lp</span><span class="p">;</span>
	<span class="cm">/* FAN received; Fan does not have a reply sequence */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">vport</span> <span class="o">==</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">pport</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">port_state</span> <span class="o">==</span> <span class="n">LPFC_LOCAL_CFG_LINK</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">memcmp</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">fc_fabparam</span><span class="p">.</span><span class="n">nodeName</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fp</span><span class="o">-&gt;</span><span class="n">FnodeName</span><span class="p">,</span>
			    <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_name</span><span class="p">)))</span> <span class="o">||</span>
		    <span class="p">(</span><span class="n">memcmp</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">fc_fabparam</span><span class="p">.</span><span class="n">portName</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fp</span><span class="o">-&gt;</span><span class="n">FportName</span><span class="p">,</span>
			    <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_name</span><span class="p">))))</span> <span class="p">{</span>
			<span class="cm">/* This port has switched fabrics. FLOGI is required */</span>
			<span class="n">lpfc_issue_init_vfi</span><span class="p">(</span><span class="n">vport</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/* FAN verified - skip FLOGI */</span>
			<span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_myDID</span> <span class="o">=</span> <span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_prevDID</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli_rev</span> <span class="o">&lt;</span> <span class="n">LPFC_SLI_REV4</span><span class="p">)</span>
				<span class="n">lpfc_issue_fabric_reglogin</span><span class="p">(</span><span class="n">vport</span><span class="p">);</span>
			<span class="k">else</span> <span class="p">{</span>
				<span class="n">lpfc_printf_vlog</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">KERN_INFO</span><span class="p">,</span> <span class="n">LOG_ELS</span><span class="p">,</span>
					<span class="s">&quot;3138 Need register VFI: (x%x/%x)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_prevDID</span><span class="p">,</span> <span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_myDID</span><span class="p">);</span>
				<span class="n">lpfc_issue_reg_vfi</span><span class="p">(</span><span class="n">vport</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_els_timeout - Handler funciton to the els timer</span>
<span class="cm"> * @ptr: holder for the timer function associated data.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine is invoked by the ELS timer after timeout. It posts the ELS</span>
<span class="cm"> * timer timeout event by setting the WORKER_ELS_TMO bit to the work port</span>
<span class="cm"> * event bitmap and then invokes the lpfc_worker_wake_up() routine to wake</span>
<span class="cm"> * up the worker thread. It is for the worker thread to invoke the routine</span>
<span class="cm"> * lpfc_els_timeout_handler() to work on the posted event WORKER_ELS_TMO.</span>
<span class="cm"> **/</span>
<span class="kt">void</span>
<span class="nf">lpfc_els_timeout</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ptr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="n">vport</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="p">)</span> <span class="n">ptr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_hba</span>   <span class="o">*</span><span class="n">phba</span> <span class="o">=</span> <span class="n">vport</span><span class="o">-&gt;</span><span class="n">phba</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">tmo_posted</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">iflag</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">work_port_lock</span><span class="p">,</span> <span class="n">iflag</span><span class="p">);</span>
	<span class="n">tmo_posted</span> <span class="o">=</span> <span class="n">vport</span><span class="o">-&gt;</span><span class="n">work_port_events</span> <span class="o">&amp;</span> <span class="n">WORKER_ELS_TMO</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tmo_posted</span><span class="p">)</span>
		<span class="n">vport</span><span class="o">-&gt;</span><span class="n">work_port_events</span> <span class="o">|=</span> <span class="n">WORKER_ELS_TMO</span><span class="p">;</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">work_port_lock</span><span class="p">,</span> <span class="n">iflag</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tmo_posted</span><span class="p">)</span>
		<span class="n">lpfc_worker_wake_up</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/**</span>
<span class="cm"> * lpfc_els_timeout_handler - Process an els timeout event</span>
<span class="cm"> * @vport: pointer to a virtual N_Port data structure.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine is the actual handler function that processes an ELS timeout</span>
<span class="cm"> * event. It walks the ELS ring to get and abort all the IOCBs (except the</span>
<span class="cm"> * ABORT/CLOSE/FARP/FARPR/FDISC), which are associated with the @vport by</span>
<span class="cm"> * invoking the lpfc_sli_issue_abort_iotag() routine.</span>
<span class="cm"> **/</span>
<span class="kt">void</span>
<span class="nf">lpfc_els_timeout_handler</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="n">vport</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpfc_hba</span>  <span class="o">*</span><span class="n">phba</span> <span class="o">=</span> <span class="n">vport</span><span class="o">-&gt;</span><span class="n">phba</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_sli_ring</span> <span class="o">*</span><span class="n">pring</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_iocbq</span> <span class="o">*</span><span class="n">tmp_iocb</span><span class="p">,</span> <span class="o">*</span><span class="n">piocb</span><span class="p">;</span>
	<span class="n">IOCB_t</span> <span class="o">*</span><span class="n">cmd</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_dmabuf</span> <span class="o">*</span><span class="n">pcmd</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">els_command</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">timeout</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">remote_ID</span> <span class="o">=</span> <span class="mh">0xffffffff</span><span class="p">;</span>
	<span class="n">LIST_HEAD</span><span class="p">(</span><span class="n">txcmplq_completions</span><span class="p">);</span>
	<span class="n">LIST_HEAD</span><span class="p">(</span><span class="n">abort_list</span><span class="p">);</span>


	<span class="n">timeout</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint32_t</span><span class="p">)(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">fc_ratov</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">);</span>

	<span class="n">pring</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli</span><span class="p">.</span><span class="n">ring</span><span class="p">[</span><span class="n">LPFC_ELS_RING</span><span class="p">];</span>

	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>
	<span class="n">list_splice_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pring</span><span class="o">-&gt;</span><span class="n">txcmplq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">txcmplq_completions</span><span class="p">);</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>

	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">piocb</span><span class="p">,</span> <span class="n">tmp_iocb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">txcmplq_completions</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cmd</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">piocb</span><span class="o">-&gt;</span><span class="n">iocb</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">((</span><span class="n">piocb</span><span class="o">-&gt;</span><span class="n">iocb_flag</span> <span class="o">&amp;</span> <span class="n">LPFC_IO_LIBDFC</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">||</span>
		    <span class="n">piocb</span><span class="o">-&gt;</span><span class="n">iocb</span><span class="p">.</span><span class="n">ulpCommand</span> <span class="o">==</span> <span class="n">CMD_ABORT_XRI_CN</span> <span class="o">||</span>
		    <span class="n">piocb</span><span class="o">-&gt;</span><span class="n">iocb</span><span class="p">.</span><span class="n">ulpCommand</span> <span class="o">==</span> <span class="n">CMD_CLOSE_XRI_CN</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">piocb</span><span class="o">-&gt;</span><span class="n">vport</span> <span class="o">!=</span> <span class="n">vport</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">pcmd</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_dmabuf</span> <span class="o">*</span><span class="p">)</span> <span class="n">piocb</span><span class="o">-&gt;</span><span class="n">context2</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pcmd</span><span class="p">)</span>
			<span class="n">els_command</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="kt">uint32_t</span> <span class="o">*</span><span class="p">)</span> <span class="p">(</span><span class="n">pcmd</span><span class="o">-&gt;</span><span class="n">virt</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">els_command</span> <span class="o">==</span> <span class="n">ELS_CMD_FARP</span> <span class="o">||</span>
		    <span class="n">els_command</span> <span class="o">==</span> <span class="n">ELS_CMD_FARPR</span> <span class="o">||</span>
		    <span class="n">els_command</span> <span class="o">==</span> <span class="n">ELS_CMD_FDISC</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">piocb</span><span class="o">-&gt;</span><span class="n">drvrTimeout</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">piocb</span><span class="o">-&gt;</span><span class="n">drvrTimeout</span> <span class="o">&gt;=</span> <span class="n">timeout</span><span class="p">)</span>
				<span class="n">piocb</span><span class="o">-&gt;</span><span class="n">drvrTimeout</span> <span class="o">-=</span> <span class="n">timeout</span><span class="p">;</span>
			<span class="k">else</span>
				<span class="n">piocb</span><span class="o">-&gt;</span><span class="n">drvrTimeout</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">remote_ID</span> <span class="o">=</span> <span class="mh">0xffffffff</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">ulpCommand</span> <span class="o">!=</span> <span class="n">CMD_GEN_REQUEST64_CR</span><span class="p">)</span>
			<span class="n">remote_ID</span> <span class="o">=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">elsreq64</span><span class="p">.</span><span class="n">remoteID</span><span class="p">;</span>
		<span class="k">else</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">lpfc_nodelist</span> <span class="o">*</span><span class="n">ndlp</span><span class="p">;</span>
			<span class="n">ndlp</span> <span class="o">=</span> <span class="n">__lpfc_findnode_rpi</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">ulpContext</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ndlp</span> <span class="o">&amp;&amp;</span> <span class="n">NLP_CHK_NODE_ACT</span><span class="p">(</span><span class="n">ndlp</span><span class="p">))</span>
				<span class="n">remote_ID</span> <span class="o">=</span> <span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_DID</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">piocb</span><span class="o">-&gt;</span><span class="n">dlist</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">abort_list</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>
	<span class="n">list_splice</span><span class="p">(</span><span class="o">&amp;</span><span class="n">txcmplq_completions</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pring</span><span class="o">-&gt;</span><span class="n">txcmplq</span><span class="p">);</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>

	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">piocb</span><span class="p">,</span> <span class="n">tmp_iocb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">abort_list</span><span class="p">,</span> <span class="n">dlist</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lpfc_printf_vlog</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_ELS</span><span class="p">,</span>
			 <span class="s">&quot;0127 ELS timeout Data: x%x x%x x%x &quot;</span>
			 <span class="s">&quot;x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">els_command</span><span class="p">,</span>
			 <span class="n">remote_ID</span><span class="p">,</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">ulpCommand</span><span class="p">,</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">ulpIoTag</span><span class="p">);</span>
		<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>
		<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">piocb</span><span class="o">-&gt;</span><span class="n">dlist</span><span class="p">);</span>
		<span class="n">lpfc_sli_issue_abort_iotag</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">pring</span><span class="p">,</span> <span class="n">piocb</span><span class="p">);</span>
		<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli</span><span class="p">.</span><span class="n">ring</span><span class="p">[</span><span class="n">LPFC_ELS_RING</span><span class="p">].</span><span class="n">txcmplq_cnt</span><span class="p">)</span>
		<span class="n">mod_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">els_tmofunc</span><span class="p">,</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="n">HZ</span> <span class="o">*</span> <span class="n">timeout</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_els_flush_cmd - Clean up the outstanding els commands to a vport</span>
<span class="cm"> * @vport: pointer to a host virtual N_Port data structure.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine is used to clean up all the outstanding ELS commands on a</span>
<span class="cm"> * @vport. It first aborts the @vport by invoking lpfc_fabric_abort_vport()</span>
<span class="cm"> * routine. After that, it walks the ELS transmit queue to remove all the</span>
<span class="cm"> * IOCBs with the @vport other than the QUE_RING and ABORT/CLOSE IOCBs. For</span>
<span class="cm"> * the IOCBs with a non-NULL completion callback function, the callback</span>
<span class="cm"> * function will be invoked with the status set to IOSTAT_LOCAL_REJECT and</span>
<span class="cm"> * un.ulpWord[4] set to IOERR_SLI_ABORTED. For IOCBs with a NULL completion</span>
<span class="cm"> * callback function, the IOCB will simply be released. Finally, it walks</span>
<span class="cm"> * the ELS transmit completion queue to issue an abort IOCB to any transmit</span>
<span class="cm"> * completion queue IOCB that is associated with the @vport and is not</span>
<span class="cm"> * an IOCB from libdfc (i.e., the management plane IOCBs that are not</span>
<span class="cm"> * part of the discovery state machine) out to HBA by invoking the</span>
<span class="cm"> * lpfc_sli_issue_abort_iotag() routine. Note that this function issues the</span>
<span class="cm"> * abort IOCB to any transmit completion queueed IOCB, it does not guarantee</span>
<span class="cm"> * the IOCBs are aborted when this function returns.</span>
<span class="cm"> **/</span>
<span class="kt">void</span>
<span class="nf">lpfc_els_flush_cmd</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="n">vport</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">LIST_HEAD</span><span class="p">(</span><span class="n">completions</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">lpfc_hba</span>  <span class="o">*</span><span class="n">phba</span> <span class="o">=</span> <span class="n">vport</span><span class="o">-&gt;</span><span class="n">phba</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_sli_ring</span> <span class="o">*</span><span class="n">pring</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli</span><span class="p">.</span><span class="n">ring</span><span class="p">[</span><span class="n">LPFC_ELS_RING</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">lpfc_iocbq</span> <span class="o">*</span><span class="n">tmp_iocb</span><span class="p">,</span> <span class="o">*</span><span class="n">piocb</span><span class="p">;</span>
	<span class="n">IOCB_t</span> <span class="o">*</span><span class="n">cmd</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">lpfc_fabric_abort_vport</span><span class="p">(</span><span class="n">vport</span><span class="p">);</span>

	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>
	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">piocb</span><span class="p">,</span> <span class="n">tmp_iocb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pring</span><span class="o">-&gt;</span><span class="n">txq</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cmd</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">piocb</span><span class="o">-&gt;</span><span class="n">iocb</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">piocb</span><span class="o">-&gt;</span><span class="n">iocb_flag</span> <span class="o">&amp;</span> <span class="n">LPFC_IO_LIBDFC</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* Do not flush out the QUE_RING and ABORT/CLOSE iocbs */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">ulpCommand</span> <span class="o">==</span> <span class="n">CMD_QUE_RING_BUF_CN</span> <span class="o">||</span>
		    <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">ulpCommand</span> <span class="o">==</span> <span class="n">CMD_QUE_RING_BUF64_CN</span> <span class="o">||</span>
		    <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">ulpCommand</span> <span class="o">==</span> <span class="n">CMD_CLOSE_XRI_CN</span> <span class="o">||</span>
		    <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">ulpCommand</span> <span class="o">==</span> <span class="n">CMD_ABORT_XRI_CN</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">piocb</span><span class="o">-&gt;</span><span class="n">vport</span> <span class="o">!=</span> <span class="n">vport</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">list_move_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">piocb</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">completions</span><span class="p">);</span>
		<span class="n">pring</span><span class="o">-&gt;</span><span class="n">txq_cnt</span><span class="o">--</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">piocb</span><span class="p">,</span> <span class="n">tmp_iocb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pring</span><span class="o">-&gt;</span><span class="n">txcmplq</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">piocb</span><span class="o">-&gt;</span><span class="n">iocb_flag</span> <span class="o">&amp;</span> <span class="n">LPFC_IO_LIBDFC</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">piocb</span><span class="o">-&gt;</span><span class="n">vport</span> <span class="o">!=</span> <span class="n">vport</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">lpfc_sli_issue_abort_iotag</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">pring</span><span class="p">,</span> <span class="n">piocb</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>

	<span class="cm">/* Cancell all the IOCBs from the completions list */</span>
	<span class="n">lpfc_sli_cancel_iocbs</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">completions</span><span class="p">,</span> <span class="n">IOSTAT_LOCAL_REJECT</span><span class="p">,</span>
			      <span class="n">IOERR_SLI_ABORTED</span><span class="p">);</span>

	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_els_flush_all_cmd - Clean up all the outstanding els commands to a HBA</span>
<span class="cm"> * @phba: pointer to lpfc hba data structure.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine is used to clean up all the outstanding ELS commands on a</span>
<span class="cm"> * @phba. It first aborts the @phba by invoking the lpfc_fabric_abort_hba()</span>
<span class="cm"> * routine. After that, it walks the ELS transmit queue to remove all the</span>
<span class="cm"> * IOCBs to the @phba other than the QUE_RING and ABORT/CLOSE IOCBs. For</span>
<span class="cm"> * the IOCBs with the completion callback function associated, the callback</span>
<span class="cm"> * function will be invoked with the status set to IOSTAT_LOCAL_REJECT and</span>
<span class="cm"> * un.ulpWord[4] set to IOERR_SLI_ABORTED. For IOCBs without the completion</span>
<span class="cm"> * callback function associated, the IOCB will simply be released. Finally,</span>
<span class="cm"> * it walks the ELS transmit completion queue to issue an abort IOCB to any</span>
<span class="cm"> * transmit completion queue IOCB that is not an IOCB from libdfc (i.e., the</span>
<span class="cm"> * management plane IOCBs that are not part of the discovery state machine)</span>
<span class="cm"> * out to HBA by invoking the lpfc_sli_issue_abort_iotag() routine.</span>
<span class="cm"> **/</span>
<span class="kt">void</span>
<span class="nf">lpfc_els_flush_all_cmd</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span>  <span class="o">*</span><span class="n">phba</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">LIST_HEAD</span><span class="p">(</span><span class="n">completions</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">lpfc_sli_ring</span> <span class="o">*</span><span class="n">pring</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli</span><span class="p">.</span><span class="n">ring</span><span class="p">[</span><span class="n">LPFC_ELS_RING</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">lpfc_iocbq</span> <span class="o">*</span><span class="n">tmp_iocb</span><span class="p">,</span> <span class="o">*</span><span class="n">piocb</span><span class="p">;</span>
	<span class="n">IOCB_t</span> <span class="o">*</span><span class="n">cmd</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">lpfc_fabric_abort_hba</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>
	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">piocb</span><span class="p">,</span> <span class="n">tmp_iocb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pring</span><span class="o">-&gt;</span><span class="n">txq</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cmd</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">piocb</span><span class="o">-&gt;</span><span class="n">iocb</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">piocb</span><span class="o">-&gt;</span><span class="n">iocb_flag</span> <span class="o">&amp;</span> <span class="n">LPFC_IO_LIBDFC</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="cm">/* Do not flush out the QUE_RING and ABORT/CLOSE iocbs */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">ulpCommand</span> <span class="o">==</span> <span class="n">CMD_QUE_RING_BUF_CN</span> <span class="o">||</span>
		    <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">ulpCommand</span> <span class="o">==</span> <span class="n">CMD_QUE_RING_BUF64_CN</span> <span class="o">||</span>
		    <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">ulpCommand</span> <span class="o">==</span> <span class="n">CMD_CLOSE_XRI_CN</span> <span class="o">||</span>
		    <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">ulpCommand</span> <span class="o">==</span> <span class="n">CMD_ABORT_XRI_CN</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="n">list_move_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">piocb</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">completions</span><span class="p">);</span>
		<span class="n">pring</span><span class="o">-&gt;</span><span class="n">txq_cnt</span><span class="o">--</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">piocb</span><span class="p">,</span> <span class="n">tmp_iocb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pring</span><span class="o">-&gt;</span><span class="n">txcmplq</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">piocb</span><span class="o">-&gt;</span><span class="n">iocb_flag</span> <span class="o">&amp;</span> <span class="n">LPFC_IO_LIBDFC</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="n">lpfc_sli_issue_abort_iotag</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">pring</span><span class="p">,</span> <span class="n">piocb</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>

	<span class="cm">/* Cancel all the IOCBs from the completions list */</span>
	<span class="n">lpfc_sli_cancel_iocbs</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">completions</span><span class="p">,</span> <span class="n">IOSTAT_LOCAL_REJECT</span><span class="p">,</span>
			      <span class="n">IOERR_SLI_ABORTED</span><span class="p">);</span>

	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_send_els_failure_event - Posts an ELS command failure event</span>
<span class="cm"> * @phba: Pointer to hba context object.</span>
<span class="cm"> * @cmdiocbp: Pointer to command iocb which reported error.</span>
<span class="cm"> * @rspiocbp: Pointer to response iocb which reported error.</span>
<span class="cm"> *</span>
<span class="cm"> * This function sends an event when there is an ELS command</span>
<span class="cm"> * failure.</span>
<span class="cm"> **/</span>
<span class="kt">void</span>
<span class="nf">lpfc_send_els_failure_event</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">lpfc_iocbq</span> <span class="o">*</span><span class="n">cmdiocbp</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">lpfc_iocbq</span> <span class="o">*</span><span class="n">rspiocbp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="n">vport</span> <span class="o">=</span> <span class="n">cmdiocbp</span><span class="o">-&gt;</span><span class="n">vport</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span> <span class="o">=</span> <span class="n">lpfc_shost_from_vport</span><span class="p">(</span><span class="n">vport</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">lpfc_lsrjt_event</span> <span class="n">lsrjt_event</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_fabric_event_header</span> <span class="n">fabric_event</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ls_rjt</span> <span class="n">stat</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_nodelist</span> <span class="o">*</span><span class="n">ndlp</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="o">*</span><span class="n">pcmd</span><span class="p">;</span>

	<span class="n">ndlp</span> <span class="o">=</span> <span class="n">cmdiocbp</span><span class="o">-&gt;</span><span class="n">context1</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ndlp</span> <span class="o">||</span> <span class="o">!</span><span class="n">NLP_CHK_NODE_ACT</span><span class="p">(</span><span class="n">ndlp</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">rspiocbp</span><span class="o">-&gt;</span><span class="n">iocb</span><span class="p">.</span><span class="n">ulpStatus</span> <span class="o">==</span> <span class="n">IOSTAT_LS_RJT</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lsrjt_event</span><span class="p">.</span><span class="n">header</span><span class="p">.</span><span class="n">event_type</span> <span class="o">=</span> <span class="n">FC_REG_ELS_EVENT</span><span class="p">;</span>
		<span class="n">lsrjt_event</span><span class="p">.</span><span class="n">header</span><span class="p">.</span><span class="n">subcategory</span> <span class="o">=</span> <span class="n">LPFC_EVENT_LSRJT_RCV</span><span class="p">;</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">lsrjt_event</span><span class="p">.</span><span class="n">header</span><span class="p">.</span><span class="n">wwpn</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_portname</span><span class="p">,</span>
			<span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_name</span><span class="p">));</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">lsrjt_event</span><span class="p">.</span><span class="n">header</span><span class="p">.</span><span class="n">wwnn</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_nodename</span><span class="p">,</span>
			<span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_name</span><span class="p">));</span>
		<span class="n">pcmd</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint32_t</span> <span class="o">*</span><span class="p">)</span> <span class="p">(((</span><span class="k">struct</span> <span class="n">lpfc_dmabuf</span> <span class="o">*</span><span class="p">)</span>
			<span class="n">cmdiocbp</span><span class="o">-&gt;</span><span class="n">context2</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">virt</span><span class="p">);</span>
		<span class="n">lsrjt_event</span><span class="p">.</span><span class="n">command</span> <span class="o">=</span> <span class="p">(</span><span class="n">pcmd</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="o">?</span> <span class="o">*</span><span class="n">pcmd</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">stat</span><span class="p">.</span><span class="n">un</span><span class="p">.</span><span class="n">lsRjtError</span> <span class="o">=</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">rspiocbp</span><span class="o">-&gt;</span><span class="n">iocb</span><span class="p">.</span><span class="n">un</span><span class="p">.</span><span class="n">ulpWord</span><span class="p">[</span><span class="mi">4</span><span class="p">]);</span>
		<span class="n">lsrjt_event</span><span class="p">.</span><span class="n">reason_code</span> <span class="o">=</span> <span class="n">stat</span><span class="p">.</span><span class="n">un</span><span class="p">.</span><span class="n">b</span><span class="p">.</span><span class="n">lsRjtRsnCode</span><span class="p">;</span>
		<span class="n">lsrjt_event</span><span class="p">.</span><span class="n">explanation</span> <span class="o">=</span> <span class="n">stat</span><span class="p">.</span><span class="n">un</span><span class="p">.</span><span class="n">b</span><span class="p">.</span><span class="n">lsRjtRsnCodeExp</span><span class="p">;</span>
		<span class="n">fc_host_post_vendor_event</span><span class="p">(</span><span class="n">shost</span><span class="p">,</span>
			<span class="n">fc_get_event_number</span><span class="p">(),</span>
			<span class="k">sizeof</span><span class="p">(</span><span class="n">lsrjt_event</span><span class="p">),</span>
			<span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">lsrjt_event</span><span class="p">,</span>
			<span class="n">LPFC_NL_VENDOR_ID</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">rspiocbp</span><span class="o">-&gt;</span><span class="n">iocb</span><span class="p">.</span><span class="n">ulpStatus</span> <span class="o">==</span> <span class="n">IOSTAT_NPORT_BSY</span><span class="p">)</span> <span class="o">||</span>
		<span class="p">(</span><span class="n">rspiocbp</span><span class="o">-&gt;</span><span class="n">iocb</span><span class="p">.</span><span class="n">ulpStatus</span> <span class="o">==</span> <span class="n">IOSTAT_FABRIC_BSY</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">fabric_event</span><span class="p">.</span><span class="n">event_type</span> <span class="o">=</span> <span class="n">FC_REG_FABRIC_EVENT</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rspiocbp</span><span class="o">-&gt;</span><span class="n">iocb</span><span class="p">.</span><span class="n">ulpStatus</span> <span class="o">==</span> <span class="n">IOSTAT_NPORT_BSY</span><span class="p">)</span>
			<span class="n">fabric_event</span><span class="p">.</span><span class="n">subcategory</span> <span class="o">=</span> <span class="n">LPFC_EVENT_PORT_BUSY</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">fabric_event</span><span class="p">.</span><span class="n">subcategory</span> <span class="o">=</span> <span class="n">LPFC_EVENT_FABRIC_BUSY</span><span class="p">;</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">fabric_event</span><span class="p">.</span><span class="n">wwpn</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_portname</span><span class="p">,</span>
			<span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_name</span><span class="p">));</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">fabric_event</span><span class="p">.</span><span class="n">wwnn</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_nodename</span><span class="p">,</span>
			<span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_name</span><span class="p">));</span>
		<span class="n">fc_host_post_vendor_event</span><span class="p">(</span><span class="n">shost</span><span class="p">,</span>
			<span class="n">fc_get_event_number</span><span class="p">(),</span>
			<span class="k">sizeof</span><span class="p">(</span><span class="n">fabric_event</span><span class="p">),</span>
			<span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">fabric_event</span><span class="p">,</span>
			<span class="n">LPFC_NL_VENDOR_ID</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_send_els_event - Posts unsolicited els event</span>
<span class="cm"> * @vport: Pointer to vport object.</span>
<span class="cm"> * @ndlp: Pointer FC node object.</span>
<span class="cm"> * @cmd: ELS command code.</span>
<span class="cm"> *</span>
<span class="cm"> * This function posts an event when there is an incoming</span>
<span class="cm"> * unsolicited ELS command.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">lpfc_send_els_event</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="n">vport</span><span class="p">,</span>
		    <span class="k">struct</span> <span class="n">lpfc_nodelist</span> <span class="o">*</span><span class="n">ndlp</span><span class="p">,</span>
		    <span class="kt">uint32_t</span> <span class="o">*</span><span class="n">payload</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpfc_els_event_header</span> <span class="o">*</span><span class="n">els_data</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_logo_event</span> <span class="o">*</span><span class="n">logo_data</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span> <span class="o">=</span> <span class="n">lpfc_shost_from_vport</span><span class="p">(</span><span class="n">vport</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">payload</span> <span class="o">==</span> <span class="n">ELS_CMD_LOGO</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">logo_data</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_logo_event</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">logo_data</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">lpfc_printf_vlog</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_ELS</span><span class="p">,</span>
				<span class="s">&quot;0148 Failed to allocate memory &quot;</span>
				<span class="s">&quot;for LOGO event</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">els_data</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">logo_data</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">els_data</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_els_event_header</span><span class="p">),</span>
			<span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">els_data</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">lpfc_printf_vlog</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_ELS</span><span class="p">,</span>
				<span class="s">&quot;0149 Failed to allocate memory &quot;</span>
				<span class="s">&quot;for ELS event</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">els_data</span><span class="o">-&gt;</span><span class="n">event_type</span> <span class="o">=</span> <span class="n">FC_REG_ELS_EVENT</span><span class="p">;</span>
	<span class="k">switch</span> <span class="p">(</span><span class="o">*</span><span class="n">payload</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">ELS_CMD_PLOGI</span>:
		<span class="n">els_data</span><span class="o">-&gt;</span><span class="n">subcategory</span> <span class="o">=</span> <span class="n">LPFC_EVENT_PLOGI_RCV</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">ELS_CMD_PRLO</span>:
		<span class="n">els_data</span><span class="o">-&gt;</span><span class="n">subcategory</span> <span class="o">=</span> <span class="n">LPFC_EVENT_PRLO_RCV</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">ELS_CMD_ADISC</span>:
		<span class="n">els_data</span><span class="o">-&gt;</span><span class="n">subcategory</span> <span class="o">=</span> <span class="n">LPFC_EVENT_ADISC_RCV</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">ELS_CMD_LOGO</span>:
		<span class="n">els_data</span><span class="o">-&gt;</span><span class="n">subcategory</span> <span class="o">=</span> <span class="n">LPFC_EVENT_LOGO_RCV</span><span class="p">;</span>
		<span class="cm">/* Copy the WWPN in the LOGO payload */</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">logo_data</span><span class="o">-&gt;</span><span class="n">logo_wwpn</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">payload</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span>
			<span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_name</span><span class="p">));</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">els_data</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">els_data</span><span class="o">-&gt;</span><span class="n">wwpn</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_portname</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_name</span><span class="p">));</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">els_data</span><span class="o">-&gt;</span><span class="n">wwnn</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_nodename</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_name</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">payload</span> <span class="o">==</span> <span class="n">ELS_CMD_LOGO</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">fc_host_post_vendor_event</span><span class="p">(</span><span class="n">shost</span><span class="p">,</span>
			<span class="n">fc_get_event_number</span><span class="p">(),</span>
			<span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_logo_event</span><span class="p">),</span>
			<span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">logo_data</span><span class="p">,</span>
			<span class="n">LPFC_NL_VENDOR_ID</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">logo_data</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">fc_host_post_vendor_event</span><span class="p">(</span><span class="n">shost</span><span class="p">,</span>
			<span class="n">fc_get_event_number</span><span class="p">(),</span>
			<span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_els_event_header</span><span class="p">),</span>
			<span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">els_data</span><span class="p">,</span>
			<span class="n">LPFC_NL_VENDOR_ID</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">els_data</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/**</span>
<span class="cm"> * lpfc_els_unsol_buffer - Process an unsolicited event data buffer</span>
<span class="cm"> * @phba: pointer to lpfc hba data structure.</span>
<span class="cm"> * @pring: pointer to a SLI ring.</span>
<span class="cm"> * @vport: pointer to a host virtual N_Port data structure.</span>
<span class="cm"> * @elsiocb: pointer to lpfc els command iocb data structure.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine is used for processing the IOCB associated with a unsolicited</span>
<span class="cm"> * event. It first determines whether there is an existing ndlp that matches</span>
<span class="cm"> * the DID from the unsolicited IOCB. If not, it will create a new one with</span>
<span class="cm"> * the DID from the unsolicited IOCB. The ELS command from the unsolicited</span>
<span class="cm"> * IOCB is then used to invoke the proper routine and to set up proper state</span>
<span class="cm"> * of the discovery state machine.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">lpfc_els_unsol_buffer</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">,</span> <span class="k">struct</span> <span class="n">lpfc_sli_ring</span> <span class="o">*</span><span class="n">pring</span><span class="p">,</span>
		      <span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="n">vport</span><span class="p">,</span> <span class="k">struct</span> <span class="n">lpfc_iocbq</span> <span class="o">*</span><span class="n">elsiocb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span>  <span class="o">*</span><span class="n">shost</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_nodelist</span> <span class="o">*</span><span class="n">ndlp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ls_rjt</span> <span class="n">stat</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="o">*</span><span class="n">payload</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">cmd</span><span class="p">,</span> <span class="n">did</span><span class="p">,</span> <span class="n">newnode</span><span class="p">,</span> <span class="n">rjt_err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">IOCB_t</span> <span class="o">*</span><span class="n">icmd</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">elsiocb</span><span class="o">-&gt;</span><span class="n">iocb</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">vport</span> <span class="o">||</span> <span class="o">!</span><span class="p">(</span><span class="n">elsiocb</span><span class="o">-&gt;</span><span class="n">context2</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">dropit</span><span class="p">;</span>

	<span class="n">newnode</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">payload</span> <span class="o">=</span> <span class="p">((</span><span class="k">struct</span> <span class="n">lpfc_dmabuf</span> <span class="o">*</span><span class="p">)</span><span class="n">elsiocb</span><span class="o">-&gt;</span><span class="n">context2</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">virt</span><span class="p">;</span>
	<span class="n">cmd</span> <span class="o">=</span> <span class="o">*</span><span class="n">payload</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli3_options</span> <span class="o">&amp;</span> <span class="n">LPFC_SLI3_HBQ_ENABLED</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">lpfc_post_buffer</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">pring</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

	<span class="n">did</span> <span class="o">=</span> <span class="n">icmd</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">rcvels</span><span class="p">.</span><span class="n">remoteID</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">icmd</span><span class="o">-&gt;</span><span class="n">ulpStatus</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lpfc_debugfs_disc_trc</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">LPFC_DISC_TRC_ELS_UNSOL</span><span class="p">,</span>
			<span class="s">&quot;RCV Unsol ELS:  status:x%x/x%x did:x%x&quot;</span><span class="p">,</span>
			<span class="n">icmd</span><span class="o">-&gt;</span><span class="n">ulpStatus</span><span class="p">,</span> <span class="n">icmd</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">ulpWord</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span> <span class="n">did</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">dropit</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Check to see if link went down during discovery */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">lpfc_els_chk_latt</span><span class="p">(</span><span class="n">vport</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">dropit</span><span class="p">;</span>

	<span class="cm">/* Ignore traffic received during vport shutdown. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">load_flag</span> <span class="o">&amp;</span> <span class="n">FC_UNLOADING</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">dropit</span><span class="p">;</span>

	<span class="cm">/* If NPort discovery is delayed drop incoming ELS */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_flag</span> <span class="o">&amp;</span> <span class="n">FC_DISC_DELAYED</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			<span class="p">(</span><span class="n">cmd</span> <span class="o">!=</span> <span class="n">ELS_CMD_PLOGI</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">dropit</span><span class="p">;</span>

	<span class="n">ndlp</span> <span class="o">=</span> <span class="n">lpfc_findnode_did</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">did</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ndlp</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Cannot find existing Fabric ndlp, so allocate a new one */</span>
		<span class="n">ndlp</span> <span class="o">=</span> <span class="n">mempool_alloc</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">nlp_mem_pool</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ndlp</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">dropit</span><span class="p">;</span>

		<span class="n">lpfc_nlp_init</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">ndlp</span><span class="p">,</span> <span class="n">did</span><span class="p">);</span>
		<span class="n">lpfc_nlp_set_state</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">ndlp</span><span class="p">,</span> <span class="n">NLP_STE_NPR_NODE</span><span class="p">);</span>
		<span class="n">newnode</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">did</span> <span class="o">&amp;</span> <span class="n">Fabric_DID_MASK</span><span class="p">)</span> <span class="o">==</span> <span class="n">Fabric_DID_MASK</span><span class="p">)</span>
			<span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_type</span> <span class="o">|=</span> <span class="n">NLP_FABRIC</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">NLP_CHK_NODE_ACT</span><span class="p">(</span><span class="n">ndlp</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ndlp</span> <span class="o">=</span> <span class="n">lpfc_enable_node</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">ndlp</span><span class="p">,</span>
					<span class="n">NLP_STE_UNUSED_NODE</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ndlp</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">dropit</span><span class="p">;</span>
		<span class="n">lpfc_nlp_set_state</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">ndlp</span><span class="p">,</span> <span class="n">NLP_STE_NPR_NODE</span><span class="p">);</span>
		<span class="n">newnode</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">did</span> <span class="o">&amp;</span> <span class="n">Fabric_DID_MASK</span><span class="p">)</span> <span class="o">==</span> <span class="n">Fabric_DID_MASK</span><span class="p">)</span>
			<span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_type</span> <span class="o">|=</span> <span class="n">NLP_FABRIC</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_state</span> <span class="o">==</span> <span class="n">NLP_STE_UNUSED_NODE</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* This is similar to the new node path */</span>
		<span class="n">ndlp</span> <span class="o">=</span> <span class="n">lpfc_nlp_get</span><span class="p">(</span><span class="n">ndlp</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ndlp</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">dropit</span><span class="p">;</span>
		<span class="n">lpfc_nlp_set_state</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">ndlp</span><span class="p">,</span> <span class="n">NLP_STE_NPR_NODE</span><span class="p">);</span>
		<span class="n">newnode</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">fc_stat</span><span class="p">.</span><span class="n">elsRcvFrame</span><span class="o">++</span><span class="p">;</span>

	<span class="n">elsiocb</span><span class="o">-&gt;</span><span class="n">context1</span> <span class="o">=</span> <span class="n">lpfc_nlp_get</span><span class="p">(</span><span class="n">ndlp</span><span class="p">);</span>
	<span class="n">elsiocb</span><span class="o">-&gt;</span><span class="n">vport</span> <span class="o">=</span> <span class="n">vport</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">cmd</span> <span class="o">&amp;</span> <span class="n">ELS_CMD_MASK</span><span class="p">)</span> <span class="o">==</span> <span class="n">ELS_CMD_RSCN</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cmd</span> <span class="o">&amp;=</span> <span class="n">ELS_CMD_MASK</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* ELS command &lt;elsCmd&gt; received from NPORT &lt;did&gt; */</span>
	<span class="n">lpfc_printf_vlog</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">KERN_INFO</span><span class="p">,</span> <span class="n">LOG_ELS</span><span class="p">,</span>
			 <span class="s">&quot;0112 ELS command x%x received from NPORT x%x &quot;</span>
			 <span class="s">&quot;Data: x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">cmd</span><span class="p">,</span> <span class="n">did</span><span class="p">,</span> <span class="n">vport</span><span class="o">-&gt;</span><span class="n">port_state</span><span class="p">);</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">cmd</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">ELS_CMD_PLOGI</span>:
		<span class="n">lpfc_debugfs_disc_trc</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">LPFC_DISC_TRC_ELS_UNSOL</span><span class="p">,</span>
			<span class="s">&quot;RCV PLOGI:       did:x%x/ste:x%x flg:x%x&quot;</span><span class="p">,</span>
			<span class="n">did</span><span class="p">,</span> <span class="n">vport</span><span class="o">-&gt;</span><span class="n">port_state</span><span class="p">,</span> <span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_flag</span><span class="p">);</span>

		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">fc_stat</span><span class="p">.</span><span class="n">elsRcvPLOGI</span><span class="o">++</span><span class="p">;</span>
		<span class="n">ndlp</span> <span class="o">=</span> <span class="n">lpfc_plogi_confirm_nport</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">payload</span><span class="p">,</span> <span class="n">ndlp</span><span class="p">);</span>

		<span class="n">lpfc_send_els_event</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">ndlp</span><span class="p">,</span> <span class="n">payload</span><span class="p">);</span>

		<span class="cm">/* If Nport discovery is delayed, reject PLOGIs */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_flag</span> <span class="o">&amp;</span> <span class="n">FC_DISC_DELAYED</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">rjt_err</span> <span class="o">=</span> <span class="n">LSRJT_UNABLE_TPC</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">port_state</span> <span class="o">&lt;</span> <span class="n">LPFC_DISC_AUTH</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">pport</span><span class="o">-&gt;</span><span class="n">fc_flag</span> <span class="o">&amp;</span> <span class="n">FC_PT2PT</span><span class="p">)</span> <span class="o">||</span>
				<span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">pport</span><span class="o">-&gt;</span><span class="n">fc_flag</span> <span class="o">&amp;</span> <span class="n">FC_PT2PT_PLOGI</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">rjt_err</span> <span class="o">=</span> <span class="n">LSRJT_UNABLE_TPC</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="cm">/* We get here, and drop thru, if we are PT2PT with</span>
<span class="cm">			 * another NPort and the other side has initiated</span>
<span class="cm">			 * the PLOGI before responding to our FLOGI.</span>
<span class="cm">			 */</span>
		<span class="p">}</span>

		<span class="n">shost</span> <span class="o">=</span> <span class="n">lpfc_shost_from_vport</span><span class="p">(</span><span class="n">vport</span><span class="p">);</span>
		<span class="n">spin_lock_irq</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>
		<span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_flag</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">NLP_TARGET_REMOVE</span><span class="p">;</span>
		<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>

		<span class="n">lpfc_disc_state_machine</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">ndlp</span><span class="p">,</span> <span class="n">elsiocb</span><span class="p">,</span>
					<span class="n">NLP_EVT_RCV_PLOGI</span><span class="p">);</span>

		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">ELS_CMD_FLOGI</span>:
		<span class="n">lpfc_debugfs_disc_trc</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">LPFC_DISC_TRC_ELS_UNSOL</span><span class="p">,</span>
			<span class="s">&quot;RCV FLOGI:       did:x%x/ste:x%x flg:x%x&quot;</span><span class="p">,</span>
			<span class="n">did</span><span class="p">,</span> <span class="n">vport</span><span class="o">-&gt;</span><span class="n">port_state</span><span class="p">,</span> <span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_flag</span><span class="p">);</span>

		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">fc_stat</span><span class="p">.</span><span class="n">elsRcvFLOGI</span><span class="o">++</span><span class="p">;</span>
		<span class="n">lpfc_els_rcv_flogi</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">elsiocb</span><span class="p">,</span> <span class="n">ndlp</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">newnode</span><span class="p">)</span>
			<span class="n">lpfc_nlp_put</span><span class="p">(</span><span class="n">ndlp</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">ELS_CMD_LOGO</span>:
		<span class="n">lpfc_debugfs_disc_trc</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">LPFC_DISC_TRC_ELS_UNSOL</span><span class="p">,</span>
			<span class="s">&quot;RCV LOGO:        did:x%x/ste:x%x flg:x%x&quot;</span><span class="p">,</span>
			<span class="n">did</span><span class="p">,</span> <span class="n">vport</span><span class="o">-&gt;</span><span class="n">port_state</span><span class="p">,</span> <span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_flag</span><span class="p">);</span>

		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">fc_stat</span><span class="p">.</span><span class="n">elsRcvLOGO</span><span class="o">++</span><span class="p">;</span>
		<span class="n">lpfc_send_els_event</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">ndlp</span><span class="p">,</span> <span class="n">payload</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">port_state</span> <span class="o">&lt;</span> <span class="n">LPFC_DISC_AUTH</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">rjt_err</span> <span class="o">=</span> <span class="n">LSRJT_UNABLE_TPC</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">lpfc_disc_state_machine</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">ndlp</span><span class="p">,</span> <span class="n">elsiocb</span><span class="p">,</span> <span class="n">NLP_EVT_RCV_LOGO</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">ELS_CMD_PRLO</span>:
		<span class="n">lpfc_debugfs_disc_trc</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">LPFC_DISC_TRC_ELS_UNSOL</span><span class="p">,</span>
			<span class="s">&quot;RCV PRLO:        did:x%x/ste:x%x flg:x%x&quot;</span><span class="p">,</span>
			<span class="n">did</span><span class="p">,</span> <span class="n">vport</span><span class="o">-&gt;</span><span class="n">port_state</span><span class="p">,</span> <span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_flag</span><span class="p">);</span>

		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">fc_stat</span><span class="p">.</span><span class="n">elsRcvPRLO</span><span class="o">++</span><span class="p">;</span>
		<span class="n">lpfc_send_els_event</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">ndlp</span><span class="p">,</span> <span class="n">payload</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">port_state</span> <span class="o">&lt;</span> <span class="n">LPFC_DISC_AUTH</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">rjt_err</span> <span class="o">=</span> <span class="n">LSRJT_UNABLE_TPC</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">lpfc_disc_state_machine</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">ndlp</span><span class="p">,</span> <span class="n">elsiocb</span><span class="p">,</span> <span class="n">NLP_EVT_RCV_PRLO</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">ELS_CMD_RSCN</span>:
		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">fc_stat</span><span class="p">.</span><span class="n">elsRcvRSCN</span><span class="o">++</span><span class="p">;</span>
		<span class="n">lpfc_els_rcv_rscn</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">elsiocb</span><span class="p">,</span> <span class="n">ndlp</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">newnode</span><span class="p">)</span>
			<span class="n">lpfc_nlp_put</span><span class="p">(</span><span class="n">ndlp</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">ELS_CMD_ADISC</span>:
		<span class="n">lpfc_debugfs_disc_trc</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">LPFC_DISC_TRC_ELS_UNSOL</span><span class="p">,</span>
			<span class="s">&quot;RCV ADISC:       did:x%x/ste:x%x flg:x%x&quot;</span><span class="p">,</span>
			<span class="n">did</span><span class="p">,</span> <span class="n">vport</span><span class="o">-&gt;</span><span class="n">port_state</span><span class="p">,</span> <span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_flag</span><span class="p">);</span>

		<span class="n">lpfc_send_els_event</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">ndlp</span><span class="p">,</span> <span class="n">payload</span><span class="p">);</span>
		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">fc_stat</span><span class="p">.</span><span class="n">elsRcvADISC</span><span class="o">++</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">port_state</span> <span class="o">&lt;</span> <span class="n">LPFC_DISC_AUTH</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">rjt_err</span> <span class="o">=</span> <span class="n">LSRJT_UNABLE_TPC</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">lpfc_disc_state_machine</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">ndlp</span><span class="p">,</span> <span class="n">elsiocb</span><span class="p">,</span>
					<span class="n">NLP_EVT_RCV_ADISC</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">ELS_CMD_PDISC</span>:
		<span class="n">lpfc_debugfs_disc_trc</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">LPFC_DISC_TRC_ELS_UNSOL</span><span class="p">,</span>
			<span class="s">&quot;RCV PDISC:       did:x%x/ste:x%x flg:x%x&quot;</span><span class="p">,</span>
			<span class="n">did</span><span class="p">,</span> <span class="n">vport</span><span class="o">-&gt;</span><span class="n">port_state</span><span class="p">,</span> <span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_flag</span><span class="p">);</span>

		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">fc_stat</span><span class="p">.</span><span class="n">elsRcvPDISC</span><span class="o">++</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">port_state</span> <span class="o">&lt;</span> <span class="n">LPFC_DISC_AUTH</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">rjt_err</span> <span class="o">=</span> <span class="n">LSRJT_UNABLE_TPC</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">lpfc_disc_state_machine</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">ndlp</span><span class="p">,</span> <span class="n">elsiocb</span><span class="p">,</span>
					<span class="n">NLP_EVT_RCV_PDISC</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">ELS_CMD_FARPR</span>:
		<span class="n">lpfc_debugfs_disc_trc</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">LPFC_DISC_TRC_ELS_UNSOL</span><span class="p">,</span>
			<span class="s">&quot;RCV FARPR:       did:x%x/ste:x%x flg:x%x&quot;</span><span class="p">,</span>
			<span class="n">did</span><span class="p">,</span> <span class="n">vport</span><span class="o">-&gt;</span><span class="n">port_state</span><span class="p">,</span> <span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_flag</span><span class="p">);</span>

		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">fc_stat</span><span class="p">.</span><span class="n">elsRcvFARPR</span><span class="o">++</span><span class="p">;</span>
		<span class="n">lpfc_els_rcv_farpr</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">elsiocb</span><span class="p">,</span> <span class="n">ndlp</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">ELS_CMD_FARP</span>:
		<span class="n">lpfc_debugfs_disc_trc</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">LPFC_DISC_TRC_ELS_UNSOL</span><span class="p">,</span>
			<span class="s">&quot;RCV FARP:        did:x%x/ste:x%x flg:x%x&quot;</span><span class="p">,</span>
			<span class="n">did</span><span class="p">,</span> <span class="n">vport</span><span class="o">-&gt;</span><span class="n">port_state</span><span class="p">,</span> <span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_flag</span><span class="p">);</span>

		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">fc_stat</span><span class="p">.</span><span class="n">elsRcvFARP</span><span class="o">++</span><span class="p">;</span>
		<span class="n">lpfc_els_rcv_farp</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">elsiocb</span><span class="p">,</span> <span class="n">ndlp</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">ELS_CMD_FAN</span>:
		<span class="n">lpfc_debugfs_disc_trc</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">LPFC_DISC_TRC_ELS_UNSOL</span><span class="p">,</span>
			<span class="s">&quot;RCV FAN:         did:x%x/ste:x%x flg:x%x&quot;</span><span class="p">,</span>
			<span class="n">did</span><span class="p">,</span> <span class="n">vport</span><span class="o">-&gt;</span><span class="n">port_state</span><span class="p">,</span> <span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_flag</span><span class="p">);</span>

		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">fc_stat</span><span class="p">.</span><span class="n">elsRcvFAN</span><span class="o">++</span><span class="p">;</span>
		<span class="n">lpfc_els_rcv_fan</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">elsiocb</span><span class="p">,</span> <span class="n">ndlp</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">ELS_CMD_PRLI</span>:
		<span class="n">lpfc_debugfs_disc_trc</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">LPFC_DISC_TRC_ELS_UNSOL</span><span class="p">,</span>
			<span class="s">&quot;RCV PRLI:        did:x%x/ste:x%x flg:x%x&quot;</span><span class="p">,</span>
			<span class="n">did</span><span class="p">,</span> <span class="n">vport</span><span class="o">-&gt;</span><span class="n">port_state</span><span class="p">,</span> <span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_flag</span><span class="p">);</span>

		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">fc_stat</span><span class="p">.</span><span class="n">elsRcvPRLI</span><span class="o">++</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">port_state</span> <span class="o">&lt;</span> <span class="n">LPFC_DISC_AUTH</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">rjt_err</span> <span class="o">=</span> <span class="n">LSRJT_UNABLE_TPC</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">lpfc_disc_state_machine</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">ndlp</span><span class="p">,</span> <span class="n">elsiocb</span><span class="p">,</span> <span class="n">NLP_EVT_RCV_PRLI</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">ELS_CMD_LIRR</span>:
		<span class="n">lpfc_debugfs_disc_trc</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">LPFC_DISC_TRC_ELS_UNSOL</span><span class="p">,</span>
			<span class="s">&quot;RCV LIRR:        did:x%x/ste:x%x flg:x%x&quot;</span><span class="p">,</span>
			<span class="n">did</span><span class="p">,</span> <span class="n">vport</span><span class="o">-&gt;</span><span class="n">port_state</span><span class="p">,</span> <span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_flag</span><span class="p">);</span>

		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">fc_stat</span><span class="p">.</span><span class="n">elsRcvLIRR</span><span class="o">++</span><span class="p">;</span>
		<span class="n">lpfc_els_rcv_lirr</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">elsiocb</span><span class="p">,</span> <span class="n">ndlp</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">newnode</span><span class="p">)</span>
			<span class="n">lpfc_nlp_put</span><span class="p">(</span><span class="n">ndlp</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">ELS_CMD_RLS</span>:
		<span class="n">lpfc_debugfs_disc_trc</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">LPFC_DISC_TRC_ELS_UNSOL</span><span class="p">,</span>
			<span class="s">&quot;RCV RLS:         did:x%x/ste:x%x flg:x%x&quot;</span><span class="p">,</span>
			<span class="n">did</span><span class="p">,</span> <span class="n">vport</span><span class="o">-&gt;</span><span class="n">port_state</span><span class="p">,</span> <span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_flag</span><span class="p">);</span>

		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">fc_stat</span><span class="p">.</span><span class="n">elsRcvRLS</span><span class="o">++</span><span class="p">;</span>
		<span class="n">lpfc_els_rcv_rls</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">elsiocb</span><span class="p">,</span> <span class="n">ndlp</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">newnode</span><span class="p">)</span>
			<span class="n">lpfc_nlp_put</span><span class="p">(</span><span class="n">ndlp</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">ELS_CMD_RPS</span>:
		<span class="n">lpfc_debugfs_disc_trc</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">LPFC_DISC_TRC_ELS_UNSOL</span><span class="p">,</span>
			<span class="s">&quot;RCV RPS:         did:x%x/ste:x%x flg:x%x&quot;</span><span class="p">,</span>
			<span class="n">did</span><span class="p">,</span> <span class="n">vport</span><span class="o">-&gt;</span><span class="n">port_state</span><span class="p">,</span> <span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_flag</span><span class="p">);</span>

		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">fc_stat</span><span class="p">.</span><span class="n">elsRcvRPS</span><span class="o">++</span><span class="p">;</span>
		<span class="n">lpfc_els_rcv_rps</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">elsiocb</span><span class="p">,</span> <span class="n">ndlp</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">newnode</span><span class="p">)</span>
			<span class="n">lpfc_nlp_put</span><span class="p">(</span><span class="n">ndlp</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">ELS_CMD_RPL</span>:
		<span class="n">lpfc_debugfs_disc_trc</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">LPFC_DISC_TRC_ELS_UNSOL</span><span class="p">,</span>
			<span class="s">&quot;RCV RPL:         did:x%x/ste:x%x flg:x%x&quot;</span><span class="p">,</span>
			<span class="n">did</span><span class="p">,</span> <span class="n">vport</span><span class="o">-&gt;</span><span class="n">port_state</span><span class="p">,</span> <span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_flag</span><span class="p">);</span>

		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">fc_stat</span><span class="p">.</span><span class="n">elsRcvRPL</span><span class="o">++</span><span class="p">;</span>
		<span class="n">lpfc_els_rcv_rpl</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">elsiocb</span><span class="p">,</span> <span class="n">ndlp</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">newnode</span><span class="p">)</span>
			<span class="n">lpfc_nlp_put</span><span class="p">(</span><span class="n">ndlp</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">ELS_CMD_RNID</span>:
		<span class="n">lpfc_debugfs_disc_trc</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">LPFC_DISC_TRC_ELS_UNSOL</span><span class="p">,</span>
			<span class="s">&quot;RCV RNID:        did:x%x/ste:x%x flg:x%x&quot;</span><span class="p">,</span>
			<span class="n">did</span><span class="p">,</span> <span class="n">vport</span><span class="o">-&gt;</span><span class="n">port_state</span><span class="p">,</span> <span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_flag</span><span class="p">);</span>

		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">fc_stat</span><span class="p">.</span><span class="n">elsRcvRNID</span><span class="o">++</span><span class="p">;</span>
		<span class="n">lpfc_els_rcv_rnid</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">elsiocb</span><span class="p">,</span> <span class="n">ndlp</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">newnode</span><span class="p">)</span>
			<span class="n">lpfc_nlp_put</span><span class="p">(</span><span class="n">ndlp</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">ELS_CMD_RTV</span>:
		<span class="n">lpfc_debugfs_disc_trc</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">LPFC_DISC_TRC_ELS_UNSOL</span><span class="p">,</span>
			<span class="s">&quot;RCV RTV:        did:x%x/ste:x%x flg:x%x&quot;</span><span class="p">,</span>
			<span class="n">did</span><span class="p">,</span> <span class="n">vport</span><span class="o">-&gt;</span><span class="n">port_state</span><span class="p">,</span> <span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_flag</span><span class="p">);</span>
		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">fc_stat</span><span class="p">.</span><span class="n">elsRcvRTV</span><span class="o">++</span><span class="p">;</span>
		<span class="n">lpfc_els_rcv_rtv</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">elsiocb</span><span class="p">,</span> <span class="n">ndlp</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">newnode</span><span class="p">)</span>
			<span class="n">lpfc_nlp_put</span><span class="p">(</span><span class="n">ndlp</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">ELS_CMD_RRQ</span>:
		<span class="n">lpfc_debugfs_disc_trc</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">LPFC_DISC_TRC_ELS_UNSOL</span><span class="p">,</span>
			<span class="s">&quot;RCV RRQ:         did:x%x/ste:x%x flg:x%x&quot;</span><span class="p">,</span>
			<span class="n">did</span><span class="p">,</span> <span class="n">vport</span><span class="o">-&gt;</span><span class="n">port_state</span><span class="p">,</span> <span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_flag</span><span class="p">);</span>

		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">fc_stat</span><span class="p">.</span><span class="n">elsRcvRRQ</span><span class="o">++</span><span class="p">;</span>
		<span class="n">lpfc_els_rcv_rrq</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">elsiocb</span><span class="p">,</span> <span class="n">ndlp</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">newnode</span><span class="p">)</span>
			<span class="n">lpfc_nlp_put</span><span class="p">(</span><span class="n">ndlp</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">ELS_CMD_ECHO</span>:
		<span class="n">lpfc_debugfs_disc_trc</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">LPFC_DISC_TRC_ELS_UNSOL</span><span class="p">,</span>
			<span class="s">&quot;RCV ECHO:        did:x%x/ste:x%x flg:x%x&quot;</span><span class="p">,</span>
			<span class="n">did</span><span class="p">,</span> <span class="n">vport</span><span class="o">-&gt;</span><span class="n">port_state</span><span class="p">,</span> <span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_flag</span><span class="p">);</span>

		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">fc_stat</span><span class="p">.</span><span class="n">elsRcvECHO</span><span class="o">++</span><span class="p">;</span>
		<span class="n">lpfc_els_rcv_echo</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">elsiocb</span><span class="p">,</span> <span class="n">ndlp</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">newnode</span><span class="p">)</span>
			<span class="n">lpfc_nlp_put</span><span class="p">(</span><span class="n">ndlp</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">lpfc_debugfs_disc_trc</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">LPFC_DISC_TRC_ELS_UNSOL</span><span class="p">,</span>
			<span class="s">&quot;RCV ELS cmd:     cmd:x%x did:x%x/ste:x%x&quot;</span><span class="p">,</span>
			<span class="n">cmd</span><span class="p">,</span> <span class="n">did</span><span class="p">,</span> <span class="n">vport</span><span class="o">-&gt;</span><span class="n">port_state</span><span class="p">);</span>

		<span class="cm">/* Unsupported ELS command, reject */</span>
		<span class="n">rjt_err</span> <span class="o">=</span> <span class="n">LSRJT_CMD_UNSUPPORTED</span><span class="p">;</span>

		<span class="cm">/* Unknown ELS command &lt;elsCmd&gt; received from NPORT &lt;did&gt; */</span>
		<span class="n">lpfc_printf_vlog</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_ELS</span><span class="p">,</span>
				 <span class="s">&quot;0115 Unknown ELS command x%x &quot;</span>
				 <span class="s">&quot;received from NPORT x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">cmd</span><span class="p">,</span> <span class="n">did</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">newnode</span><span class="p">)</span>
			<span class="n">lpfc_nlp_put</span><span class="p">(</span><span class="n">ndlp</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* check if need to LS_RJT received ELS cmd */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rjt_err</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">stat</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">stat</span><span class="p">));</span>
		<span class="n">stat</span><span class="p">.</span><span class="n">un</span><span class="p">.</span><span class="n">b</span><span class="p">.</span><span class="n">lsRjtRsnCode</span> <span class="o">=</span> <span class="n">rjt_err</span><span class="p">;</span>
		<span class="n">stat</span><span class="p">.</span><span class="n">un</span><span class="p">.</span><span class="n">b</span><span class="p">.</span><span class="n">lsRjtRsnCodeExp</span> <span class="o">=</span> <span class="n">LSEXP_NOTHING_MORE</span><span class="p">;</span>
		<span class="n">lpfc_els_rsp_reject</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">stat</span><span class="p">.</span><span class="n">un</span><span class="p">.</span><span class="n">lsRjtError</span><span class="p">,</span> <span class="n">elsiocb</span><span class="p">,</span> <span class="n">ndlp</span><span class="p">,</span>
			<span class="nb">NULL</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">lpfc_nlp_put</span><span class="p">(</span><span class="n">elsiocb</span><span class="o">-&gt;</span><span class="n">context1</span><span class="p">);</span>
	<span class="n">elsiocb</span><span class="o">-&gt;</span><span class="n">context1</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">return</span><span class="p">;</span>

<span class="nl">dropit:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vport</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">load_flag</span> <span class="o">&amp;</span> <span class="n">FC_UNLOADING</span><span class="p">))</span>
		<span class="n">lpfc_printf_vlog</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_ELS</span><span class="p">,</span>
			<span class="s">&quot;0111 Dropping received ELS cmd &quot;</span>
			<span class="s">&quot;Data: x%x x%x x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">icmd</span><span class="o">-&gt;</span><span class="n">ulpStatus</span><span class="p">,</span> <span class="n">icmd</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">ulpWord</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span> <span class="n">icmd</span><span class="o">-&gt;</span><span class="n">ulpTimeout</span><span class="p">);</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">fc_stat</span><span class="p">.</span><span class="n">elsRcvDrop</span><span class="o">++</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_els_unsol_event - Process an unsolicited event from an els sli ring</span>
<span class="cm"> * @phba: pointer to lpfc hba data structure.</span>
<span class="cm"> * @pring: pointer to a SLI ring.</span>
<span class="cm"> * @elsiocb: pointer to lpfc els iocb data structure.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine is used to process an unsolicited event received from a SLI</span>
<span class="cm"> * (Service Level Interface) ring. The actual processing of the data buffer</span>
<span class="cm"> * associated with the unsolicited event is done by invoking the routine</span>
<span class="cm"> * lpfc_els_unsol_buffer() after properly set up the iocb buffer from the</span>
<span class="cm"> * SLI ring on which the unsolicited event was received.</span>
<span class="cm"> **/</span>
<span class="kt">void</span>
<span class="nf">lpfc_els_unsol_event</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">,</span> <span class="k">struct</span> <span class="n">lpfc_sli_ring</span> <span class="o">*</span><span class="n">pring</span><span class="p">,</span>
		     <span class="k">struct</span> <span class="n">lpfc_iocbq</span> <span class="o">*</span><span class="n">elsiocb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="n">vport</span> <span class="o">=</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">pport</span><span class="p">;</span>
	<span class="n">IOCB_t</span> <span class="o">*</span><span class="n">icmd</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">elsiocb</span><span class="o">-&gt;</span><span class="n">iocb</span><span class="p">;</span>
	<span class="n">dma_addr_t</span> <span class="n">paddr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_dmabuf</span> <span class="o">*</span><span class="n">bdeBuf1</span> <span class="o">=</span> <span class="n">elsiocb</span><span class="o">-&gt;</span><span class="n">context2</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_dmabuf</span> <span class="o">*</span><span class="n">bdeBuf2</span> <span class="o">=</span> <span class="n">elsiocb</span><span class="o">-&gt;</span><span class="n">context3</span><span class="p">;</span>

	<span class="n">elsiocb</span><span class="o">-&gt;</span><span class="n">context1</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">elsiocb</span><span class="o">-&gt;</span><span class="n">context2</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">elsiocb</span><span class="o">-&gt;</span><span class="n">context3</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">icmd</span><span class="o">-&gt;</span><span class="n">ulpStatus</span> <span class="o">==</span> <span class="n">IOSTAT_NEED_BUFFER</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lpfc_sli_hbqbuf_add_hbqs</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">LPFC_ELS_HBQ</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">icmd</span><span class="o">-&gt;</span><span class="n">ulpStatus</span> <span class="o">==</span> <span class="n">IOSTAT_LOCAL_REJECT</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">icmd</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">ulpWord</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">)</span> <span class="o">==</span> <span class="n">IOERR_RCV_BUFFER_WAITING</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">fc_stat</span><span class="p">.</span><span class="n">NoRcvBuf</span><span class="o">++</span><span class="p">;</span>
		<span class="cm">/* Not enough posted buffers; Try posting more buffers */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli3_options</span> <span class="o">&amp;</span> <span class="n">LPFC_SLI3_HBQ_ENABLED</span><span class="p">))</span>
			<span class="n">lpfc_post_buffer</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">pring</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli3_options</span> <span class="o">&amp;</span> <span class="n">LPFC_SLI3_NPIV_ENABLED</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">icmd</span><span class="o">-&gt;</span><span class="n">ulpCommand</span> <span class="o">==</span> <span class="n">CMD_IOCB_RCV_ELS64_CX</span> <span class="o">||</span>
	     <span class="n">icmd</span><span class="o">-&gt;</span><span class="n">ulpCommand</span> <span class="o">==</span> <span class="n">CMD_IOCB_RCV_SEQ64_CX</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">icmd</span><span class="o">-&gt;</span><span class="n">unsli3</span><span class="p">.</span><span class="n">rcvsli3</span><span class="p">.</span><span class="n">vpi</span> <span class="o">==</span> <span class="mh">0xffff</span><span class="p">)</span>
			<span class="n">vport</span> <span class="o">=</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">pport</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">vport</span> <span class="o">=</span> <span class="n">lpfc_find_vport_by_vpid</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span>
						<span class="n">icmd</span><span class="o">-&gt;</span><span class="n">unsli3</span><span class="p">.</span><span class="n">rcvsli3</span><span class="p">.</span><span class="n">vpi</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* If there are no BDEs associated</span>
<span class="cm">	 * with this IOCB, there is nothing to do.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">icmd</span><span class="o">-&gt;</span><span class="n">ulpBdeCount</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/* type of ELS cmd is first 32bit word</span>
<span class="cm">	 * in packet</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli3_options</span> <span class="o">&amp;</span> <span class="n">LPFC_SLI3_HBQ_ENABLED</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">elsiocb</span><span class="o">-&gt;</span><span class="n">context2</span> <span class="o">=</span> <span class="n">bdeBuf1</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">paddr</span> <span class="o">=</span> <span class="n">getPaddr</span><span class="p">(</span><span class="n">icmd</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">cont64</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">addrHigh</span><span class="p">,</span>
				 <span class="n">icmd</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">cont64</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">addrLow</span><span class="p">);</span>
		<span class="n">elsiocb</span><span class="o">-&gt;</span><span class="n">context2</span> <span class="o">=</span> <span class="n">lpfc_sli_ringpostbuf_get</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">pring</span><span class="p">,</span>
							     <span class="n">paddr</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">lpfc_els_unsol_buffer</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">pring</span><span class="p">,</span> <span class="n">vport</span><span class="p">,</span> <span class="n">elsiocb</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * The different unsolicited event handlers would tell us</span>
<span class="cm">	 * if they are done with &quot;mp&quot; by setting context2 to NULL.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">elsiocb</span><span class="o">-&gt;</span><span class="n">context2</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lpfc_in_buf_free</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_dmabuf</span> <span class="o">*</span><span class="p">)</span><span class="n">elsiocb</span><span class="o">-&gt;</span><span class="n">context2</span><span class="p">);</span>
		<span class="n">elsiocb</span><span class="o">-&gt;</span><span class="n">context2</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* RCV_ELS64_CX provide for 2 BDEs - process 2nd if included */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli3_options</span> <span class="o">&amp;</span> <span class="n">LPFC_SLI3_HBQ_ENABLED</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="n">icmd</span><span class="o">-&gt;</span><span class="n">ulpBdeCount</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">elsiocb</span><span class="o">-&gt;</span><span class="n">context2</span> <span class="o">=</span> <span class="n">bdeBuf2</span><span class="p">;</span>
		<span class="n">lpfc_els_unsol_buffer</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">pring</span><span class="p">,</span> <span class="n">vport</span><span class="p">,</span> <span class="n">elsiocb</span><span class="p">);</span>
		<span class="cm">/* free mp if we are done with it */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">elsiocb</span><span class="o">-&gt;</span><span class="n">context2</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">lpfc_in_buf_free</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">elsiocb</span><span class="o">-&gt;</span><span class="n">context2</span><span class="p">);</span>
			<span class="n">elsiocb</span><span class="o">-&gt;</span><span class="n">context2</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_do_scr_ns_plogi - Issue a plogi to the name server for scr</span>
<span class="cm"> * @phba: pointer to lpfc hba data structure.</span>
<span class="cm"> * @vport: pointer to a virtual N_Port data structure.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine issues a Port Login (PLOGI) to the Name Server with</span>
<span class="cm"> * State Change Request (SCR) for a @vport. This routine will create an</span>
<span class="cm"> * ndlp for the Name Server associated to the @vport if such node does</span>
<span class="cm"> * not already exist. The PLOGI to Name Server is issued by invoking the</span>
<span class="cm"> * lpfc_issue_els_plogi() routine. If Fabric-Device Management Interface</span>
<span class="cm"> * (FDMI) is configured to the @vport, a FDMI node will be created and</span>
<span class="cm"> * the PLOGI to FDMI is issued by invoking lpfc_issue_els_plogi() routine.</span>
<span class="cm"> **/</span>
<span class="kt">void</span>
<span class="nf">lpfc_do_scr_ns_plogi</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">,</span> <span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="n">vport</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpfc_nodelist</span> <span class="o">*</span><span class="n">ndlp</span><span class="p">,</span> <span class="o">*</span><span class="n">ndlp_fdmi</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span> <span class="o">=</span> <span class="n">lpfc_shost_from_vport</span><span class="p">(</span><span class="n">vport</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * If lpfc_delay_discovery parameter is set and the clean address</span>
<span class="cm">	 * bit is cleared and fc fabric parameters chenged, delay FC NPort</span>
<span class="cm">	 * discovery.</span>
<span class="cm">	 */</span>
	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_flag</span> <span class="o">&amp;</span> <span class="n">FC_DISC_DELAYED</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>
		<span class="n">mod_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">delayed_disc_tmo</span><span class="p">,</span>
			<span class="n">jiffies</span> <span class="o">+</span> <span class="n">HZ</span> <span class="o">*</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">fc_ratov</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>

	<span class="n">ndlp</span> <span class="o">=</span> <span class="n">lpfc_findnode_did</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">NameServer_DID</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ndlp</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ndlp</span> <span class="o">=</span> <span class="n">mempool_alloc</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">nlp_mem_pool</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ndlp</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">fc_topology</span> <span class="o">==</span> <span class="n">LPFC_TOPOLOGY_LOOP</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">lpfc_disc_start</span><span class="p">(</span><span class="n">vport</span><span class="p">);</span>
				<span class="k">return</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">lpfc_vport_set_state</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">FC_VPORT_FAILED</span><span class="p">);</span>
			<span class="n">lpfc_printf_vlog</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_ELS</span><span class="p">,</span>
					 <span class="s">&quot;0251 NameServer login: no memory</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">lpfc_nlp_init</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">ndlp</span><span class="p">,</span> <span class="n">NameServer_DID</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">NLP_CHK_NODE_ACT</span><span class="p">(</span><span class="n">ndlp</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ndlp</span> <span class="o">=</span> <span class="n">lpfc_enable_node</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">ndlp</span><span class="p">,</span> <span class="n">NLP_STE_UNUSED_NODE</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ndlp</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">fc_topology</span> <span class="o">==</span> <span class="n">LPFC_TOPOLOGY_LOOP</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">lpfc_disc_start</span><span class="p">(</span><span class="n">vport</span><span class="p">);</span>
				<span class="k">return</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">lpfc_vport_set_state</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">FC_VPORT_FAILED</span><span class="p">);</span>
			<span class="n">lpfc_printf_vlog</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_ELS</span><span class="p">,</span>
					<span class="s">&quot;0348 NameServer login: node freed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_type</span> <span class="o">|=</span> <span class="n">NLP_FABRIC</span><span class="p">;</span>

	<span class="n">lpfc_nlp_set_state</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">ndlp</span><span class="p">,</span> <span class="n">NLP_STE_PLOGI_ISSUE</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">lpfc_issue_els_plogi</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_DID</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">lpfc_vport_set_state</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">FC_VPORT_FAILED</span><span class="p">);</span>
		<span class="n">lpfc_printf_vlog</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_ELS</span><span class="p">,</span>
				 <span class="s">&quot;0252 Cannot issue NameServer login</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">cfg_fdmi_on</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* If this is the first time, allocate an ndlp and initialize</span>
<span class="cm">		 * it. Otherwise, make sure the node is enabled and then do the</span>
<span class="cm">		 * login.</span>
<span class="cm">		 */</span>
		<span class="n">ndlp_fdmi</span> <span class="o">=</span> <span class="n">lpfc_findnode_did</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">FDMI_DID</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ndlp_fdmi</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ndlp_fdmi</span> <span class="o">=</span> <span class="n">mempool_alloc</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">nlp_mem_pool</span><span class="p">,</span>
						  <span class="n">GFP_KERNEL</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ndlp_fdmi</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">lpfc_nlp_init</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">ndlp_fdmi</span><span class="p">,</span> <span class="n">FDMI_DID</span><span class="p">);</span>
				<span class="n">ndlp_fdmi</span><span class="o">-&gt;</span><span class="n">nlp_type</span> <span class="o">|=</span> <span class="n">NLP_FABRIC</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span>
				<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">NLP_CHK_NODE_ACT</span><span class="p">(</span><span class="n">ndlp_fdmi</span><span class="p">))</span>
			<span class="n">ndlp_fdmi</span> <span class="o">=</span> <span class="n">lpfc_enable_node</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span>
						     <span class="n">ndlp_fdmi</span><span class="p">,</span>
						     <span class="n">NLP_STE_NPR_NODE</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">ndlp_fdmi</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">lpfc_nlp_set_state</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">ndlp_fdmi</span><span class="p">,</span>
					   <span class="n">NLP_STE_PLOGI_ISSUE</span><span class="p">);</span>
			<span class="n">lpfc_issue_els_plogi</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">ndlp_fdmi</span><span class="o">-&gt;</span><span class="n">nlp_DID</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_cmpl_reg_new_vport - Completion callback function to register new vport</span>
<span class="cm"> * @phba: pointer to lpfc hba data structure.</span>
<span class="cm"> * @pmb: pointer to the driver internal queue element for mailbox command.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine is the completion callback function to register new vport</span>
<span class="cm"> * mailbox command. If the new vport mailbox command completes successfully,</span>
<span class="cm"> * the fabric registration login shall be performed on physical port (the</span>
<span class="cm"> * new vport created is actually a physical port, with VPI 0) or the port</span>
<span class="cm"> * login to Name Server for State Change Request (SCR) will be performed</span>
<span class="cm"> * on virtual port (real virtual port, with VPI greater than 0).</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">lpfc_cmpl_reg_new_vport</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">,</span> <span class="n">LPFC_MBOXQ_t</span> <span class="o">*</span><span class="n">pmb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="n">vport</span> <span class="o">=</span> <span class="n">pmb</span><span class="o">-&gt;</span><span class="n">vport</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span>  <span class="o">*</span><span class="n">shost</span> <span class="o">=</span> <span class="n">lpfc_shost_from_vport</span><span class="p">(</span><span class="n">vport</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">lpfc_nodelist</span> <span class="o">*</span><span class="n">ndlp</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_nodelist</span> <span class="o">*</span><span class="p">)</span> <span class="n">pmb</span><span class="o">-&gt;</span><span class="n">context2</span><span class="p">;</span>
	<span class="n">MAILBOX_t</span> <span class="o">*</span><span class="n">mb</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">pmb</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">mb</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>
	<span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_flag</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">FC_VPORT_NEEDS_REG_VPI</span><span class="p">;</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">mb</span><span class="o">-&gt;</span><span class="n">mbxStatus</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lpfc_printf_vlog</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_MBOX</span><span class="p">,</span>
				<span class="s">&quot;0915 Register VPI failed : Status: x%x&quot;</span>
				<span class="s">&quot; upd bit: x%x </span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">mb</span><span class="o">-&gt;</span><span class="n">mbxStatus</span><span class="p">,</span>
				 <span class="n">mb</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">varRegVpi</span><span class="p">.</span><span class="n">upd</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli_rev</span> <span class="o">==</span> <span class="n">LPFC_SLI_REV4</span> <span class="o">&amp;&amp;</span>
			<span class="n">mb</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">varRegVpi</span><span class="p">.</span><span class="n">upd</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">mbox_err_exit</span> <span class="p">;</span>

		<span class="k">switch</span> <span class="p">(</span><span class="n">mb</span><span class="o">-&gt;</span><span class="n">mbxStatus</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="mh">0x11</span>:	<span class="cm">/* unsupported feature */</span>
		<span class="k">case</span> <span class="mh">0x9603</span>:	<span class="cm">/* max_vpi exceeded */</span>
		<span class="k">case</span> <span class="mh">0x9602</span>:	<span class="cm">/* Link event since CLEAR_LA */</span>
			<span class="cm">/* giving up on vport registration */</span>
			<span class="n">lpfc_vport_set_state</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">FC_VPORT_FAILED</span><span class="p">);</span>
			<span class="n">spin_lock_irq</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>
			<span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_flag</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">FC_FABRIC</span> <span class="o">|</span> <span class="n">FC_PUBLIC_LOOP</span><span class="p">);</span>
			<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>
			<span class="n">lpfc_can_disctmo</span><span class="p">(</span><span class="n">vport</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="cm">/* If reg_vpi fail with invalid VPI status, re-init VPI */</span>
		<span class="k">case</span> <span class="mh">0x20</span>:
			<span class="n">spin_lock_irq</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>
			<span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_flag</span> <span class="o">|=</span> <span class="n">FC_VPORT_NEEDS_REG_VPI</span><span class="p">;</span>
			<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>
			<span class="n">lpfc_init_vpi</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">pmb</span><span class="p">,</span> <span class="n">vport</span><span class="o">-&gt;</span><span class="n">vpi</span><span class="p">);</span>
			<span class="n">pmb</span><span class="o">-&gt;</span><span class="n">vport</span> <span class="o">=</span> <span class="n">vport</span><span class="p">;</span>
			<span class="n">pmb</span><span class="o">-&gt;</span><span class="n">mbox_cmpl</span> <span class="o">=</span> <span class="n">lpfc_init_vpi_cmpl</span><span class="p">;</span>
			<span class="n">rc</span> <span class="o">=</span> <span class="n">lpfc_sli_issue_mbox</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">pmb</span><span class="p">,</span>
				<span class="n">MBX_NOWAIT</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">==</span> <span class="n">MBX_NOT_FINISHED</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">lpfc_printf_vlog</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span>
					<span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_MBOX</span><span class="p">,</span>
					<span class="s">&quot;2732 Failed to issue INIT_VPI&quot;</span>
					<span class="s">&quot; mailbox command</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="n">lpfc_nlp_put</span><span class="p">(</span><span class="n">ndlp</span><span class="p">);</span>
				<span class="k">return</span><span class="p">;</span>
			<span class="p">}</span>

		<span class="nl">default:</span>
			<span class="cm">/* Try to recover from this error */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli_rev</span> <span class="o">==</span> <span class="n">LPFC_SLI_REV4</span><span class="p">)</span>
				<span class="n">lpfc_sli4_unreg_all_rpis</span><span class="p">(</span><span class="n">vport</span><span class="p">);</span>
			<span class="n">lpfc_mbx_unreg_vpi</span><span class="p">(</span><span class="n">vport</span><span class="p">);</span>
			<span class="n">spin_lock_irq</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>
			<span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_flag</span> <span class="o">|=</span> <span class="n">FC_VPORT_NEEDS_REG_VPI</span><span class="p">;</span>
			<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">port_type</span> <span class="o">==</span> <span class="n">LPFC_PHYSICAL_PORT</span>
				<span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_flag</span> <span class="o">&amp;</span> <span class="n">FC_LOGO_RCVD_DID_CHNG</span><span class="p">))</span>
				<span class="n">lpfc_issue_init_vfi</span><span class="p">(</span><span class="n">vport</span><span class="p">);</span>
			<span class="k">else</span>
				<span class="n">lpfc_initial_fdisc</span><span class="p">(</span><span class="n">vport</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">spin_lock_irq</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>
		<span class="n">vport</span><span class="o">-&gt;</span><span class="n">vpi_state</span> <span class="o">|=</span> <span class="n">LPFC_VPI_REGISTERED</span><span class="p">;</span>
		<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">vport</span> <span class="o">==</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">pport</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli_rev</span> <span class="o">&lt;</span> <span class="n">LPFC_SLI_REV4</span><span class="p">)</span>
				<span class="n">lpfc_issue_fabric_reglogin</span><span class="p">(</span><span class="n">vport</span><span class="p">);</span>
			<span class="k">else</span> <span class="p">{</span>
				<span class="cm">/*</span>
<span class="cm">				 * If the physical port is instantiated using</span>
<span class="cm">				 * FDISC, do not start vport discovery.</span>
<span class="cm">				 */</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">port_state</span> <span class="o">!=</span> <span class="n">LPFC_FDISC</span><span class="p">)</span>
					<span class="n">lpfc_start_fdiscs</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
				<span class="n">lpfc_do_scr_ns_plogi</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">vport</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="n">lpfc_do_scr_ns_plogi</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">vport</span><span class="p">);</span>
	<span class="p">}</span>
<span class="nl">mbox_err_exit:</span>
	<span class="cm">/* Now, we decrement the ndlp reference count held for this</span>
<span class="cm">	 * callback function</span>
<span class="cm">	 */</span>
	<span class="n">lpfc_nlp_put</span><span class="p">(</span><span class="n">ndlp</span><span class="p">);</span>

	<span class="n">mempool_free</span><span class="p">(</span><span class="n">pmb</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">mbox_mem_pool</span><span class="p">);</span>
	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_register_new_vport - Register a new vport with a HBA</span>
<span class="cm"> * @phba: pointer to lpfc hba data structure.</span>
<span class="cm"> * @vport: pointer to a host virtual N_Port data structure.</span>
<span class="cm"> * @ndlp: pointer to a node-list data structure.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine registers the @vport as a new virtual port with a HBA.</span>
<span class="cm"> * It is done through a registering vpi mailbox command.</span>
<span class="cm"> **/</span>
<span class="kt">void</span>
<span class="nf">lpfc_register_new_vport</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">,</span> <span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="n">vport</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">lpfc_nodelist</span> <span class="o">*</span><span class="n">ndlp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span> <span class="o">=</span> <span class="n">lpfc_shost_from_vport</span><span class="p">(</span><span class="n">vport</span><span class="p">);</span>
	<span class="n">LPFC_MBOXQ_t</span> <span class="o">*</span><span class="n">mbox</span><span class="p">;</span>

	<span class="n">mbox</span> <span class="o">=</span> <span class="n">mempool_alloc</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">mbox_mem_pool</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mbox</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lpfc_reg_vpi</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">mbox</span><span class="p">);</span>
		<span class="n">mbox</span><span class="o">-&gt;</span><span class="n">vport</span> <span class="o">=</span> <span class="n">vport</span><span class="p">;</span>
		<span class="n">mbox</span><span class="o">-&gt;</span><span class="n">context2</span> <span class="o">=</span> <span class="n">lpfc_nlp_get</span><span class="p">(</span><span class="n">ndlp</span><span class="p">);</span>
		<span class="n">mbox</span><span class="o">-&gt;</span><span class="n">mbox_cmpl</span> <span class="o">=</span> <span class="n">lpfc_cmpl_reg_new_vport</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">lpfc_sli_issue_mbox</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">mbox</span><span class="p">,</span> <span class="n">MBX_NOWAIT</span><span class="p">)</span>
		    <span class="o">==</span> <span class="n">MBX_NOT_FINISHED</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* mailbox command not success, decrement ndlp</span>
<span class="cm">			 * reference count for this command</span>
<span class="cm">			 */</span>
			<span class="n">lpfc_nlp_put</span><span class="p">(</span><span class="n">ndlp</span><span class="p">);</span>
			<span class="n">mempool_free</span><span class="p">(</span><span class="n">mbox</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">mbox_mem_pool</span><span class="p">);</span>

			<span class="n">lpfc_printf_vlog</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_MBOX</span><span class="p">,</span>
				<span class="s">&quot;0253 Register VPI: Can&#39;t send mbox</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">mbox_err_exit</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">lpfc_printf_vlog</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_MBOX</span><span class="p">,</span>
				 <span class="s">&quot;0254 Register VPI: no memory</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">mbox_err_exit</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span><span class="p">;</span>

<span class="nl">mbox_err_exit:</span>
	<span class="n">lpfc_vport_set_state</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">FC_VPORT_FAILED</span><span class="p">);</span>
	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>
	<span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_flag</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">FC_VPORT_NEEDS_REG_VPI</span><span class="p">;</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>
	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_cancel_all_vport_retry_delay_timer - Cancel all vport retry delay timer</span>
<span class="cm"> * @phba: pointer to lpfc hba data structure.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine cancels the retry delay timers to all the vports.</span>
<span class="cm"> **/</span>
<span class="kt">void</span>
<span class="nf">lpfc_cancel_all_vport_retry_delay_timer</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">**</span><span class="n">vports</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_nodelist</span> <span class="o">*</span><span class="n">ndlp</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">link_state</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="cm">/* Treat this failure as linkdown for all vports */</span>
	<span class="n">link_state</span> <span class="o">=</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">link_state</span><span class="p">;</span>
	<span class="n">lpfc_linkdown</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">link_state</span> <span class="o">=</span> <span class="n">link_state</span><span class="p">;</span>

	<span class="n">vports</span> <span class="o">=</span> <span class="n">lpfc_create_vport_work_array</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">vports</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">max_vports</span> <span class="o">&amp;&amp;</span> <span class="n">vports</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ndlp</span> <span class="o">=</span> <span class="n">lpfc_findnode_did</span><span class="p">(</span><span class="n">vports</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">Fabric_DID</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ndlp</span><span class="p">)</span>
				<span class="n">lpfc_cancel_retry_delay_tmo</span><span class="p">(</span><span class="n">vports</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">ndlp</span><span class="p">);</span>
			<span class="n">lpfc_els_flush_cmd</span><span class="p">(</span><span class="n">vports</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
		<span class="p">}</span>
		<span class="n">lpfc_destroy_vport_work_array</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">vports</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_retry_pport_discovery - Start timer to retry FLOGI.</span>
<span class="cm"> * @phba: pointer to lpfc hba data structure.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine abort all pending discovery commands and</span>
<span class="cm"> * start a timer to retry FLOGI for the physical port</span>
<span class="cm"> * discovery.</span>
<span class="cm"> **/</span>
<span class="kt">void</span>
<span class="nf">lpfc_retry_pport_discovery</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpfc_nodelist</span> <span class="o">*</span><span class="n">ndlp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span>  <span class="o">*</span><span class="n">shost</span><span class="p">;</span>

	<span class="cm">/* Cancel the all vports retry delay retry timers */</span>
	<span class="n">lpfc_cancel_all_vport_retry_delay_timer</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>

	<span class="cm">/* If fabric require FLOGI, then re-instantiate physical login */</span>
	<span class="n">ndlp</span> <span class="o">=</span> <span class="n">lpfc_findnode_did</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">pport</span><span class="p">,</span> <span class="n">Fabric_DID</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ndlp</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">shost</span> <span class="o">=</span> <span class="n">lpfc_shost_from_vport</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">pport</span><span class="p">);</span>
	<span class="n">mod_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_delayfunc</span><span class="p">,</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="n">HZ</span><span class="p">);</span>
	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>
	<span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_flag</span> <span class="o">|=</span> <span class="n">NLP_DELAY_TMO</span><span class="p">;</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>
	<span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_last_elscmd</span> <span class="o">=</span> <span class="n">ELS_CMD_FLOGI</span><span class="p">;</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">pport</span><span class="o">-&gt;</span><span class="n">port_state</span> <span class="o">=</span> <span class="n">LPFC_FLOGI</span><span class="p">;</span>
	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_fabric_login_reqd - Check if FLOGI required.</span>
<span class="cm"> * @phba: pointer to lpfc hba data structure.</span>
<span class="cm"> * @cmdiocb: pointer to FDISC command iocb.</span>
<span class="cm"> * @rspiocb: pointer to FDISC response iocb.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine checks if a FLOGI is reguired for FDISC</span>
<span class="cm"> * to succeed.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">lpfc_fabric_login_reqd</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">lpfc_iocbq</span> <span class="o">*</span><span class="n">cmdiocb</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">lpfc_iocbq</span> <span class="o">*</span><span class="n">rspiocb</span><span class="p">)</span>
<span class="p">{</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">rspiocb</span><span class="o">-&gt;</span><span class="n">iocb</span><span class="p">.</span><span class="n">ulpStatus</span> <span class="o">!=</span> <span class="n">IOSTAT_FABRIC_RJT</span><span class="p">)</span> <span class="o">||</span>
		<span class="p">(</span><span class="n">rspiocb</span><span class="o">-&gt;</span><span class="n">iocb</span><span class="p">.</span><span class="n">un</span><span class="p">.</span><span class="n">ulpWord</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">!=</span> <span class="n">RJT_LOGIN_REQUIRED</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_cmpl_els_fdisc - Completion function for fdisc iocb command</span>
<span class="cm"> * @phba: pointer to lpfc hba data structure.</span>
<span class="cm"> * @cmdiocb: pointer to lpfc command iocb data structure.</span>
<span class="cm"> * @rspiocb: pointer to lpfc response iocb data structure.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine is the completion callback function to a Fabric Discover</span>
<span class="cm"> * (FDISC) ELS command. Since all the FDISC ELS commands are issued</span>
<span class="cm"> * single threaded, each FDISC completion callback function will reset</span>
<span class="cm"> * the discovery timer for all vports such that the timers will not get</span>
<span class="cm"> * unnecessary timeout. The function checks the FDISC IOCB status. If error</span>
<span class="cm"> * detected, the vport will be set to FC_VPORT_FAILED state. Otherwise,the</span>
<span class="cm"> * vport will set to FC_VPORT_ACTIVE state. It then checks whether the DID</span>
<span class="cm"> * assigned to the vport has been changed with the completion of the FDISC</span>
<span class="cm"> * command. If so, both RPI (Remote Port Index) and VPI (Virtual Port Index)</span>
<span class="cm"> * are unregistered from the HBA, and then the lpfc_register_new_vport()</span>
<span class="cm"> * routine is invoked to register new vport with the HBA. Otherwise, the</span>
<span class="cm"> * lpfc_do_scr_ns_plogi() routine is invoked to issue a PLOGI to the Name</span>
<span class="cm"> * Server for State Change Request (SCR).</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">lpfc_cmpl_els_fdisc</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">,</span> <span class="k">struct</span> <span class="n">lpfc_iocbq</span> <span class="o">*</span><span class="n">cmdiocb</span><span class="p">,</span>
		    <span class="k">struct</span> <span class="n">lpfc_iocbq</span> <span class="o">*</span><span class="n">rspiocb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="n">vport</span> <span class="o">=</span> <span class="n">cmdiocb</span><span class="o">-&gt;</span><span class="n">vport</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span>  <span class="o">*</span><span class="n">shost</span> <span class="o">=</span> <span class="n">lpfc_shost_from_vport</span><span class="p">(</span><span class="n">vport</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">lpfc_nodelist</span> <span class="o">*</span><span class="n">ndlp</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_nodelist</span> <span class="o">*</span><span class="p">)</span> <span class="n">cmdiocb</span><span class="o">-&gt;</span><span class="n">context1</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_nodelist</span> <span class="o">*</span><span class="n">np</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_nodelist</span> <span class="o">*</span><span class="n">next_np</span><span class="p">;</span>
	<span class="n">IOCB_t</span> <span class="o">*</span><span class="n">irsp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">rspiocb</span><span class="o">-&gt;</span><span class="n">iocb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_iocbq</span> <span class="o">*</span><span class="n">piocb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_dmabuf</span> <span class="o">*</span><span class="n">pcmd</span> <span class="o">=</span> <span class="n">cmdiocb</span><span class="o">-&gt;</span><span class="n">context2</span><span class="p">,</span> <span class="o">*</span><span class="n">prsp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">serv_parm</span> <span class="o">*</span><span class="n">sp</span><span class="p">;</span>
	<span class="kt">uint8_t</span> <span class="n">fabric_param_changed</span><span class="p">;</span>

	<span class="n">lpfc_printf_vlog</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">KERN_INFO</span><span class="p">,</span> <span class="n">LOG_ELS</span><span class="p">,</span>
			 <span class="s">&quot;0123 FDISC completes. x%x/x%x prevDID: x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			 <span class="n">irsp</span><span class="o">-&gt;</span><span class="n">ulpStatus</span><span class="p">,</span> <span class="n">irsp</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">ulpWord</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span>
			 <span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_prevDID</span><span class="p">);</span>
	<span class="cm">/* Since all FDISCs are being single threaded, we</span>
<span class="cm">	 * must reset the discovery timer for ALL vports</span>
<span class="cm">	 * waiting to send FDISC when one completes.</span>
<span class="cm">	 */</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">piocb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">fabric_iocb_list</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lpfc_set_disctmo</span><span class="p">(</span><span class="n">piocb</span><span class="o">-&gt;</span><span class="n">vport</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">lpfc_debugfs_disc_trc</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">LPFC_DISC_TRC_ELS_CMD</span><span class="p">,</span>
		<span class="s">&quot;FDISC cmpl:      status:x%x/x%x prevdid:x%x&quot;</span><span class="p">,</span>
		<span class="n">irsp</span><span class="o">-&gt;</span><span class="n">ulpStatus</span><span class="p">,</span> <span class="n">irsp</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">ulpWord</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span> <span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_prevDID</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">irsp</span><span class="o">-&gt;</span><span class="n">ulpStatus</span><span class="p">)</span> <span class="p">{</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">lpfc_fabric_login_reqd</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">cmdiocb</span><span class="p">,</span> <span class="n">rspiocb</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">lpfc_retry_pport_discovery</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* Check for retry */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">lpfc_els_retry</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">cmdiocb</span><span class="p">,</span> <span class="n">rspiocb</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="cm">/* FDISC failed */</span>
		<span class="n">lpfc_printf_vlog</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_ELS</span><span class="p">,</span>
				 <span class="s">&quot;0126 FDISC failed. (x%x/x%x)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				 <span class="n">irsp</span><span class="o">-&gt;</span><span class="n">ulpStatus</span><span class="p">,</span> <span class="n">irsp</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">ulpWord</span><span class="p">[</span><span class="mi">4</span><span class="p">]);</span>
		<span class="k">goto</span> <span class="n">fdisc_failed</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>
	<span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_flag</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">FC_VPORT_CVL_RCVD</span><span class="p">;</span>
	<span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_flag</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">FC_VPORT_LOGO_RCVD</span><span class="p">;</span>
	<span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_flag</span> <span class="o">|=</span> <span class="n">FC_FABRIC</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">fc_topology</span> <span class="o">==</span> <span class="n">LPFC_TOPOLOGY_LOOP</span><span class="p">)</span>
		<span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_flag</span> <span class="o">|=</span>  <span class="n">FC_PUBLIC_LOOP</span><span class="p">;</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>

	<span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_myDID</span> <span class="o">=</span> <span class="n">irsp</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">ulpWord</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">Mask_DID</span><span class="p">;</span>
	<span class="n">lpfc_vport_set_state</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">FC_VPORT_ACTIVE</span><span class="p">);</span>
	<span class="n">prsp</span> <span class="o">=</span> <span class="n">list_get_first</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pcmd</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="k">struct</span> <span class="n">lpfc_dmabuf</span><span class="p">,</span> <span class="n">list</span><span class="p">);</span>
	<span class="n">sp</span> <span class="o">=</span> <span class="n">prsp</span><span class="o">-&gt;</span><span class="n">virt</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">uint32_t</span><span class="p">);</span>
	<span class="n">fabric_param_changed</span> <span class="o">=</span> <span class="n">lpfc_check_clean_addr_bit</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">sp</span><span class="p">);</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">fabric_portname</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">portName</span><span class="p">,</span>
		<span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_name</span><span class="p">));</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">fabric_nodename</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">nodeName</span><span class="p">,</span>
		<span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_name</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">fabric_param_changed</span> <span class="o">&amp;&amp;</span>
		<span class="o">!</span><span class="p">(</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_flag</span> <span class="o">&amp;</span> <span class="n">FC_VPORT_NEEDS_REG_VPI</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* If our NportID changed, we need to ensure all</span>
<span class="cm">		 * remaining NPORTs get unreg_login&#39;ed so we can</span>
<span class="cm">		 * issue unreg_vpi.</span>
<span class="cm">		 */</span>
		<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">next_np</span><span class="p">,</span>
			<span class="o">&amp;</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_nodes</span><span class="p">,</span> <span class="n">nlp_listp</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">NLP_CHK_NODE_ACT</span><span class="p">(</span><span class="n">ndlp</span><span class="p">)</span> <span class="o">||</span>
			    <span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">nlp_state</span> <span class="o">!=</span> <span class="n">NLP_STE_NPR_NODE</span><span class="p">)</span> <span class="o">||</span>
			    <span class="o">!</span><span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">nlp_flag</span> <span class="o">&amp;</span> <span class="n">NLP_NPR_ADISC</span><span class="p">))</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="n">spin_lock_irq</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>
			<span class="n">np</span><span class="o">-&gt;</span><span class="n">nlp_flag</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">NLP_NPR_ADISC</span><span class="p">;</span>
			<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>
			<span class="n">lpfc_unreg_rpi</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">np</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">lpfc_cleanup_pending_mbox</span><span class="p">(</span><span class="n">vport</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli_rev</span> <span class="o">==</span> <span class="n">LPFC_SLI_REV4</span><span class="p">)</span>
			<span class="n">lpfc_sli4_unreg_all_rpis</span><span class="p">(</span><span class="n">vport</span><span class="p">);</span>

		<span class="n">lpfc_mbx_unreg_vpi</span><span class="p">(</span><span class="n">vport</span><span class="p">);</span>
		<span class="n">spin_lock_irq</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>
		<span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_flag</span> <span class="o">|=</span> <span class="n">FC_VPORT_NEEDS_REG_VPI</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli_rev</span> <span class="o">==</span> <span class="n">LPFC_SLI_REV4</span><span class="p">)</span>
			<span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_flag</span> <span class="o">|=</span> <span class="n">FC_VPORT_NEEDS_INIT_VPI</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_flag</span> <span class="o">|=</span> <span class="n">FC_LOGO_RCVD_DID_CHNG</span><span class="p">;</span>
		<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli_rev</span> <span class="o">==</span> <span class="n">LPFC_SLI_REV4</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		<span class="o">!</span><span class="p">(</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_flag</span> <span class="o">&amp;</span> <span class="n">FC_VPORT_NEEDS_REG_VPI</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Driver needs to re-reg VPI in order for f/w</span>
<span class="cm">		 * to update the MAC address.</span>
<span class="cm">		 */</span>
		<span class="n">lpfc_register_new_vport</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">vport</span><span class="p">,</span> <span class="n">ndlp</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_flag</span> <span class="o">&amp;</span> <span class="n">FC_VPORT_NEEDS_INIT_VPI</span><span class="p">)</span>
		<span class="n">lpfc_issue_init_vpi</span><span class="p">(</span><span class="n">vport</span><span class="p">);</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_flag</span> <span class="o">&amp;</span> <span class="n">FC_VPORT_NEEDS_REG_VPI</span><span class="p">)</span>
		<span class="n">lpfc_register_new_vport</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">vport</span><span class="p">,</span> <span class="n">ndlp</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">lpfc_do_scr_ns_plogi</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">vport</span><span class="p">);</span>
	<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
<span class="nl">fdisc_failed:</span>
	<span class="n">lpfc_vport_set_state</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">FC_VPORT_FAILED</span><span class="p">);</span>
	<span class="cm">/* Cancel discovery timer */</span>
	<span class="n">lpfc_can_disctmo</span><span class="p">(</span><span class="n">vport</span><span class="p">);</span>
	<span class="n">lpfc_nlp_put</span><span class="p">(</span><span class="n">ndlp</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="n">lpfc_els_free_iocb</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">cmdiocb</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_issue_els_fdisc - Issue a fdisc iocb command</span>
<span class="cm"> * @vport: pointer to a virtual N_Port data structure.</span>
<span class="cm"> * @ndlp: pointer to a node-list data structure.</span>
<span class="cm"> * @retry: number of retries to the command IOCB.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine prepares and issues a Fabric Discover (FDISC) IOCB to</span>
<span class="cm"> * a remote node (@ndlp) off a @vport. It uses the lpfc_issue_fabric_iocb()</span>
<span class="cm"> * routine to issue the IOCB, which makes sure only one outstanding fabric</span>
<span class="cm"> * IOCB will be sent off HBA at any given time.</span>
<span class="cm"> *</span>
<span class="cm"> * Note that, in lpfc_prep_els_iocb() routine, the reference count of ndlp</span>
<span class="cm"> * will be incremented by 1 for holding the ndlp and the reference to ndlp</span>
<span class="cm"> * will be stored into the context1 field of the IOCB for the completion</span>
<span class="cm"> * callback function to the FDISC ELS command.</span>
<span class="cm"> *</span>
<span class="cm"> * Return code</span>
<span class="cm"> *   0 - Successfully issued fdisc iocb command</span>
<span class="cm"> *   1 - Failed to issue fdisc iocb command</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">lpfc_issue_els_fdisc</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="n">vport</span><span class="p">,</span> <span class="k">struct</span> <span class="n">lpfc_nodelist</span> <span class="o">*</span><span class="n">ndlp</span><span class="p">,</span>
		     <span class="kt">uint8_t</span> <span class="n">retry</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span> <span class="o">=</span> <span class="n">vport</span><span class="o">-&gt;</span><span class="n">phba</span><span class="p">;</span>
	<span class="n">IOCB_t</span> <span class="o">*</span><span class="n">icmd</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_iocbq</span> <span class="o">*</span><span class="n">elsiocb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">serv_parm</span> <span class="o">*</span><span class="n">sp</span><span class="p">;</span>
	<span class="kt">uint8_t</span> <span class="o">*</span><span class="n">pcmd</span><span class="p">;</span>
	<span class="kt">uint16_t</span> <span class="n">cmdsize</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">did</span> <span class="o">=</span> <span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_DID</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">vport</span><span class="o">-&gt;</span><span class="n">port_state</span> <span class="o">=</span> <span class="n">LPFC_FDISC</span><span class="p">;</span>
	<span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_myDID</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">cmdsize</span> <span class="o">=</span> <span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">uint32_t</span><span class="p">)</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">serv_parm</span><span class="p">));</span>
	<span class="n">elsiocb</span> <span class="o">=</span> <span class="n">lpfc_prep_els_iocb</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">cmdsize</span><span class="p">,</span> <span class="n">retry</span><span class="p">,</span> <span class="n">ndlp</span><span class="p">,</span> <span class="n">did</span><span class="p">,</span>
				     <span class="n">ELS_CMD_FDISC</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">elsiocb</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lpfc_vport_set_state</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">FC_VPORT_FAILED</span><span class="p">);</span>
		<span class="n">lpfc_printf_vlog</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_ELS</span><span class="p">,</span>
				 <span class="s">&quot;0255 Issue FDISC: no IOCB</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">icmd</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">elsiocb</span><span class="o">-&gt;</span><span class="n">iocb</span><span class="p">;</span>
	<span class="n">icmd</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">elsreq64</span><span class="p">.</span><span class="n">myID</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">icmd</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">elsreq64</span><span class="p">.</span><span class="n">fl</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * SLI3 ports require a different context type value than SLI4.</span>
<span class="cm">	 * Catch SLI3 ports here and override the prep.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli_rev</span> <span class="o">==</span> <span class="n">LPFC_SLI_REV3</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">icmd</span><span class="o">-&gt;</span><span class="n">ulpCt_h</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">icmd</span><span class="o">-&gt;</span><span class="n">ulpCt_l</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">pcmd</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint8_t</span> <span class="o">*</span><span class="p">)</span> <span class="p">(((</span><span class="k">struct</span> <span class="n">lpfc_dmabuf</span> <span class="o">*</span><span class="p">)</span> <span class="n">elsiocb</span><span class="o">-&gt;</span><span class="n">context2</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">virt</span><span class="p">);</span>
	<span class="o">*</span><span class="p">((</span><span class="kt">uint32_t</span> <span class="o">*</span><span class="p">)</span> <span class="p">(</span><span class="n">pcmd</span><span class="p">))</span> <span class="o">=</span> <span class="n">ELS_CMD_FDISC</span><span class="p">;</span>
	<span class="n">pcmd</span> <span class="o">+=</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">uint32_t</span><span class="p">);</span> <span class="cm">/* CSP Word 1 */</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">pcmd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">pport</span><span class="o">-&gt;</span><span class="n">fc_sparam</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">serv_parm</span><span class="p">));</span>
	<span class="n">sp</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">serv_parm</span> <span class="o">*</span><span class="p">)</span> <span class="n">pcmd</span><span class="p">;</span>
	<span class="cm">/* Setup CSPs accordingly for Fabric */</span>
	<span class="n">sp</span><span class="o">-&gt;</span><span class="n">cmn</span><span class="p">.</span><span class="n">e_d_tov</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">sp</span><span class="o">-&gt;</span><span class="n">cmn</span><span class="p">.</span><span class="n">w2</span><span class="p">.</span><span class="n">r_a_tov</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">sp</span><span class="o">-&gt;</span><span class="n">cmn</span><span class="p">.</span><span class="n">virtual_fabric_support</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">sp</span><span class="o">-&gt;</span><span class="n">cls1</span><span class="p">.</span><span class="n">classValid</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">sp</span><span class="o">-&gt;</span><span class="n">cls2</span><span class="p">.</span><span class="n">seqDelivery</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">sp</span><span class="o">-&gt;</span><span class="n">cls3</span><span class="p">.</span><span class="n">seqDelivery</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">pcmd</span> <span class="o">+=</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">uint32_t</span><span class="p">);</span> <span class="cm">/* CSP Word 2 */</span>
	<span class="n">pcmd</span> <span class="o">+=</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">uint32_t</span><span class="p">);</span> <span class="cm">/* CSP Word 3 */</span>
	<span class="n">pcmd</span> <span class="o">+=</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">uint32_t</span><span class="p">);</span> <span class="cm">/* CSP Word 4 */</span>
	<span class="n">pcmd</span> <span class="o">+=</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">uint32_t</span><span class="p">);</span> <span class="cm">/* Port Name */</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">pcmd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_portname</span><span class="p">,</span> <span class="mi">8</span><span class="p">);</span>
	<span class="n">pcmd</span> <span class="o">+=</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">uint32_t</span><span class="p">);</span> <span class="cm">/* Node Name */</span>
	<span class="n">pcmd</span> <span class="o">+=</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">uint32_t</span><span class="p">);</span> <span class="cm">/* Node Name */</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">pcmd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_nodename</span><span class="p">,</span> <span class="mi">8</span><span class="p">);</span>

	<span class="n">lpfc_set_disctmo</span><span class="p">(</span><span class="n">vport</span><span class="p">);</span>

	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">fc_stat</span><span class="p">.</span><span class="n">elsXmitFDISC</span><span class="o">++</span><span class="p">;</span>
	<span class="n">elsiocb</span><span class="o">-&gt;</span><span class="n">iocb_cmpl</span> <span class="o">=</span> <span class="n">lpfc_cmpl_els_fdisc</span><span class="p">;</span>

	<span class="n">lpfc_debugfs_disc_trc</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">LPFC_DISC_TRC_ELS_CMD</span><span class="p">,</span>
		<span class="s">&quot;Issue FDISC:     did:x%x&quot;</span><span class="p">,</span>
		<span class="n">did</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">lpfc_issue_fabric_iocb</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">elsiocb</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">==</span> <span class="n">IOCB_ERROR</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lpfc_els_free_iocb</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">elsiocb</span><span class="p">);</span>
		<span class="n">lpfc_vport_set_state</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">FC_VPORT_FAILED</span><span class="p">);</span>
		<span class="n">lpfc_printf_vlog</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_ELS</span><span class="p">,</span>
				 <span class="s">&quot;0256 Issue FDISC: Cannot send IOCB</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">lpfc_vport_set_state</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">FC_VPORT_INITIALIZING</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_cmpl_els_npiv_logo - Completion function with vport logo</span>
<span class="cm"> * @phba: pointer to lpfc hba data structure.</span>
<span class="cm"> * @cmdiocb: pointer to lpfc command iocb data structure.</span>
<span class="cm"> * @rspiocb: pointer to lpfc response iocb data structure.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine is the completion callback function to the issuing of a LOGO</span>
<span class="cm"> * ELS command off a vport. It frees the command IOCB and then decrement the</span>
<span class="cm"> * reference count held on ndlp for this completion function, indicating that</span>
<span class="cm"> * the reference to the ndlp is no long needed. Note that the</span>
<span class="cm"> * lpfc_els_free_iocb() routine decrements the ndlp reference held for this</span>
<span class="cm"> * callback function and an additional explicit ndlp reference decrementation</span>
<span class="cm"> * will trigger the actual release of the ndlp.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">lpfc_cmpl_els_npiv_logo</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">,</span> <span class="k">struct</span> <span class="n">lpfc_iocbq</span> <span class="o">*</span><span class="n">cmdiocb</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">lpfc_iocbq</span> <span class="o">*</span><span class="n">rspiocb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="n">vport</span> <span class="o">=</span> <span class="n">cmdiocb</span><span class="o">-&gt;</span><span class="n">vport</span><span class="p">;</span>
	<span class="n">IOCB_t</span> <span class="o">*</span><span class="n">irsp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_nodelist</span> <span class="o">*</span><span class="n">ndlp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span> <span class="o">=</span> <span class="n">lpfc_shost_from_vport</span><span class="p">(</span><span class="n">vport</span><span class="p">);</span>

	<span class="n">ndlp</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_nodelist</span> <span class="o">*</span><span class="p">)</span><span class="n">cmdiocb</span><span class="o">-&gt;</span><span class="n">context1</span><span class="p">;</span>
	<span class="n">irsp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">rspiocb</span><span class="o">-&gt;</span><span class="n">iocb</span><span class="p">;</span>
	<span class="n">lpfc_debugfs_disc_trc</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">LPFC_DISC_TRC_ELS_CMD</span><span class="p">,</span>
		<span class="s">&quot;LOGO npiv cmpl:  status:x%x/x%x did:x%x&quot;</span><span class="p">,</span>
		<span class="n">irsp</span><span class="o">-&gt;</span><span class="n">ulpStatus</span><span class="p">,</span> <span class="n">irsp</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">ulpWord</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span> <span class="n">irsp</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">rcvels</span><span class="p">.</span><span class="n">remoteID</span><span class="p">);</span>

	<span class="n">lpfc_els_free_iocb</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">cmdiocb</span><span class="p">);</span>
	<span class="n">vport</span><span class="o">-&gt;</span><span class="n">unreg_vpi_cmpl</span> <span class="o">=</span> <span class="n">VPORT_ERROR</span><span class="p">;</span>

	<span class="cm">/* Trigger the release of the ndlp after logo */</span>
	<span class="n">lpfc_nlp_put</span><span class="p">(</span><span class="n">ndlp</span><span class="p">);</span>

	<span class="cm">/* NPIV LOGO completes to NPort &lt;nlp_DID&gt; */</span>
	<span class="n">lpfc_printf_vlog</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">KERN_INFO</span><span class="p">,</span> <span class="n">LOG_ELS</span><span class="p">,</span>
			 <span class="s">&quot;2928 NPIV LOGO completes to NPort x%x &quot;</span>
			 <span class="s">&quot;Data: x%x x%x x%x x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			 <span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_DID</span><span class="p">,</span> <span class="n">irsp</span><span class="o">-&gt;</span><span class="n">ulpStatus</span><span class="p">,</span> <span class="n">irsp</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">ulpWord</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span>
			 <span class="n">irsp</span><span class="o">-&gt;</span><span class="n">ulpTimeout</span><span class="p">,</span> <span class="n">vport</span><span class="o">-&gt;</span><span class="n">num_disc_nodes</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">irsp</span><span class="o">-&gt;</span><span class="n">ulpStatus</span> <span class="o">==</span> <span class="n">IOSTAT_SUCCESS</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_lock_irq</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>
		<span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_flag</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">FC_FABRIC</span><span class="p">;</span>
		<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_issue_els_npiv_logo - Issue a logo off a vport</span>
<span class="cm"> * @vport: pointer to a virtual N_Port data structure.</span>
<span class="cm"> * @ndlp: pointer to a node-list data structure.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine issues a LOGO ELS command to an @ndlp off a @vport.</span>
<span class="cm"> *</span>
<span class="cm"> * Note that, in lpfc_prep_els_iocb() routine, the reference count of ndlp</span>
<span class="cm"> * will be incremented by 1 for holding the ndlp and the reference to ndlp</span>
<span class="cm"> * will be stored into the context1 field of the IOCB for the completion</span>
<span class="cm"> * callback function to the LOGO ELS command.</span>
<span class="cm"> *</span>
<span class="cm"> * Return codes</span>
<span class="cm"> *   0 - Successfully issued logo off the @vport</span>
<span class="cm"> *   1 - Failed to issue logo off the @vport</span>
<span class="cm"> **/</span>
<span class="kt">int</span>
<span class="nf">lpfc_issue_els_npiv_logo</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="n">vport</span><span class="p">,</span> <span class="k">struct</span> <span class="n">lpfc_nodelist</span> <span class="o">*</span><span class="n">ndlp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span> <span class="o">=</span> <span class="n">lpfc_shost_from_vport</span><span class="p">(</span><span class="n">vport</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">lpfc_hba</span>  <span class="o">*</span><span class="n">phba</span> <span class="o">=</span> <span class="n">vport</span><span class="o">-&gt;</span><span class="n">phba</span><span class="p">;</span>
	<span class="n">IOCB_t</span> <span class="o">*</span><span class="n">icmd</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_iocbq</span> <span class="o">*</span><span class="n">elsiocb</span><span class="p">;</span>
	<span class="kt">uint8_t</span> <span class="o">*</span><span class="n">pcmd</span><span class="p">;</span>
	<span class="kt">uint16_t</span> <span class="n">cmdsize</span><span class="p">;</span>

	<span class="n">cmdsize</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">uint32_t</span><span class="p">)</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_name</span><span class="p">);</span>
	<span class="n">elsiocb</span> <span class="o">=</span> <span class="n">lpfc_prep_els_iocb</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">cmdsize</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">ndlp</span><span class="p">,</span> <span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_DID</span><span class="p">,</span>
				     <span class="n">ELS_CMD_LOGO</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">elsiocb</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">icmd</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">elsiocb</span><span class="o">-&gt;</span><span class="n">iocb</span><span class="p">;</span>
	<span class="n">pcmd</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint8_t</span> <span class="o">*</span><span class="p">)</span> <span class="p">(((</span><span class="k">struct</span> <span class="n">lpfc_dmabuf</span> <span class="o">*</span><span class="p">)</span> <span class="n">elsiocb</span><span class="o">-&gt;</span><span class="n">context2</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">virt</span><span class="p">);</span>
	<span class="o">*</span><span class="p">((</span><span class="kt">uint32_t</span> <span class="o">*</span><span class="p">)</span> <span class="p">(</span><span class="n">pcmd</span><span class="p">))</span> <span class="o">=</span> <span class="n">ELS_CMD_LOGO</span><span class="p">;</span>
	<span class="n">pcmd</span> <span class="o">+=</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">uint32_t</span><span class="p">);</span>

	<span class="cm">/* Fill in LOGO payload */</span>
	<span class="o">*</span><span class="p">((</span><span class="kt">uint32_t</span> <span class="o">*</span><span class="p">)</span> <span class="p">(</span><span class="n">pcmd</span><span class="p">))</span> <span class="o">=</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_myDID</span><span class="p">);</span>
	<span class="n">pcmd</span> <span class="o">+=</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">uint32_t</span><span class="p">);</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">pcmd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_portname</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_name</span><span class="p">));</span>

	<span class="n">lpfc_debugfs_disc_trc</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">LPFC_DISC_TRC_ELS_CMD</span><span class="p">,</span>
		<span class="s">&quot;Issue LOGO npiv  did:x%x flg:x%x&quot;</span><span class="p">,</span>
		<span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_DID</span><span class="p">,</span> <span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_flag</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="n">elsiocb</span><span class="o">-&gt;</span><span class="n">iocb_cmpl</span> <span class="o">=</span> <span class="n">lpfc_cmpl_els_npiv_logo</span><span class="p">;</span>
	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>
	<span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_flag</span> <span class="o">|=</span> <span class="n">NLP_LOGO_SND</span><span class="p">;</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">lpfc_sli_issue_iocb</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">LPFC_ELS_RING</span><span class="p">,</span> <span class="n">elsiocb</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">==</span>
	    <span class="n">IOCB_ERROR</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_lock_irq</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>
		<span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_flag</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">NLP_LOGO_SND</span><span class="p">;</span>
		<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>
		<span class="n">lpfc_els_free_iocb</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">elsiocb</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_fabric_block_timeout - Handler function to the fabric block timer</span>
<span class="cm"> * @ptr: holder for the timer function associated data.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine is invoked by the fabric iocb block timer after</span>
<span class="cm"> * timeout. It posts the fabric iocb block timeout event by setting the</span>
<span class="cm"> * WORKER_FABRIC_BLOCK_TMO bit to work port event bitmap and then invokes</span>
<span class="cm"> * lpfc_worker_wake_up() routine to wake up the worker thread. It is for</span>
<span class="cm"> * the worker thread to invoke the lpfc_unblock_fabric_iocbs() on the</span>
<span class="cm"> * posted event WORKER_FABRIC_BLOCK_TMO.</span>
<span class="cm"> **/</span>
<span class="kt">void</span>
<span class="nf">lpfc_fabric_block_timeout</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ptr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpfc_hba</span>  <span class="o">*</span><span class="n">phba</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="p">)</span> <span class="n">ptr</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">iflags</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">tmo_posted</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">pport</span><span class="o">-&gt;</span><span class="n">work_port_lock</span><span class="p">,</span> <span class="n">iflags</span><span class="p">);</span>
	<span class="n">tmo_posted</span> <span class="o">=</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">pport</span><span class="o">-&gt;</span><span class="n">work_port_events</span> <span class="o">&amp;</span> <span class="n">WORKER_FABRIC_BLOCK_TMO</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tmo_posted</span><span class="p">)</span>
		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">pport</span><span class="o">-&gt;</span><span class="n">work_port_events</span> <span class="o">|=</span> <span class="n">WORKER_FABRIC_BLOCK_TMO</span><span class="p">;</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">pport</span><span class="o">-&gt;</span><span class="n">work_port_lock</span><span class="p">,</span> <span class="n">iflags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tmo_posted</span><span class="p">)</span>
		<span class="n">lpfc_worker_wake_up</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_resume_fabric_iocbs - Issue a fabric iocb from driver internal list</span>
<span class="cm"> * @phba: pointer to lpfc hba data structure.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine issues one fabric iocb from the driver internal list to</span>
<span class="cm"> * the HBA. It first checks whether it&#39;s ready to issue one fabric iocb to</span>
<span class="cm"> * the HBA (whether there is no outstanding fabric iocb). If so, it shall</span>
<span class="cm"> * remove one pending fabric iocb from the driver internal list and invokes</span>
<span class="cm"> * lpfc_sli_issue_iocb() routine to send the fabric iocb to the HBA.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">lpfc_resume_fabric_iocbs</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpfc_iocbq</span> <span class="o">*</span><span class="n">iocb</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">iflags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="n">IOCB_t</span> <span class="o">*</span><span class="n">cmd</span><span class="p">;</span>

<span class="nl">repeat:</span>
	<span class="n">iocb</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">,</span> <span class="n">iflags</span><span class="p">);</span>
	<span class="cm">/* Post any pending iocb to the SLI layer */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">fabric_iocb_count</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">list_remove_head</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">fabric_iocb_list</span><span class="p">,</span> <span class="n">iocb</span><span class="p">,</span> <span class="n">typeof</span><span class="p">(</span><span class="o">*</span><span class="n">iocb</span><span class="p">),</span>
				 <span class="n">list</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">iocb</span><span class="p">)</span>
			<span class="cm">/* Increment fabric iocb count to hold the position */</span>
			<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">fabric_iocb_count</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">,</span> <span class="n">iflags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">iocb</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">iocb</span><span class="o">-&gt;</span><span class="n">fabric_iocb_cmpl</span> <span class="o">=</span> <span class="n">iocb</span><span class="o">-&gt;</span><span class="n">iocb_cmpl</span><span class="p">;</span>
		<span class="n">iocb</span><span class="o">-&gt;</span><span class="n">iocb_cmpl</span> <span class="o">=</span> <span class="n">lpfc_cmpl_fabric_iocb</span><span class="p">;</span>
		<span class="n">iocb</span><span class="o">-&gt;</span><span class="n">iocb_flag</span> <span class="o">|=</span> <span class="n">LPFC_IO_FABRIC</span><span class="p">;</span>

		<span class="n">lpfc_debugfs_disc_trc</span><span class="p">(</span><span class="n">iocb</span><span class="o">-&gt;</span><span class="n">vport</span><span class="p">,</span> <span class="n">LPFC_DISC_TRC_ELS_CMD</span><span class="p">,</span>
			<span class="s">&quot;Fabric sched1:   ste:x%x&quot;</span><span class="p">,</span>
			<span class="n">iocb</span><span class="o">-&gt;</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">port_state</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

		<span class="n">ret</span> <span class="o">=</span> <span class="n">lpfc_sli_issue_iocb</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">LPFC_ELS_RING</span><span class="p">,</span> <span class="n">iocb</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="n">IOCB_ERROR</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">iocb</span><span class="o">-&gt;</span><span class="n">iocb_cmpl</span> <span class="o">=</span> <span class="n">iocb</span><span class="o">-&gt;</span><span class="n">fabric_iocb_cmpl</span><span class="p">;</span>
			<span class="n">iocb</span><span class="o">-&gt;</span><span class="n">fabric_iocb_cmpl</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="n">iocb</span><span class="o">-&gt;</span><span class="n">iocb_flag</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">LPFC_IO_FABRIC</span><span class="p">;</span>
			<span class="n">cmd</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">iocb</span><span class="o">-&gt;</span><span class="n">iocb</span><span class="p">;</span>
			<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">ulpStatus</span> <span class="o">=</span> <span class="n">IOSTAT_LOCAL_REJECT</span><span class="p">;</span>
			<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">ulpWord</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="n">IOERR_SLI_ABORTED</span><span class="p">;</span>
			<span class="n">iocb</span><span class="o">-&gt;</span><span class="n">iocb_cmpl</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">iocb</span><span class="p">,</span> <span class="n">iocb</span><span class="p">);</span>

			<span class="n">atomic_dec</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">fabric_iocb_count</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">repeat</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_unblock_fabric_iocbs - Unblock issuing fabric iocb command</span>
<span class="cm"> * @phba: pointer to lpfc hba data structure.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine unblocks the  issuing fabric iocb command. The function</span>
<span class="cm"> * will clear the fabric iocb block bit and then invoke the routine</span>
<span class="cm"> * lpfc_resume_fabric_iocbs() to issue one of the pending fabric iocb</span>
<span class="cm"> * from the driver internal fabric iocb list.</span>
<span class="cm"> **/</span>
<span class="kt">void</span>
<span class="nf">lpfc_unblock_fabric_iocbs</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">clear_bit</span><span class="p">(</span><span class="n">FABRIC_COMANDS_BLOCKED</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">bit_flags</span><span class="p">);</span>

	<span class="n">lpfc_resume_fabric_iocbs</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_block_fabric_iocbs - Block issuing fabric iocb command</span>
<span class="cm"> * @phba: pointer to lpfc hba data structure.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine blocks the issuing fabric iocb for a specified amount of</span>
<span class="cm"> * time (currently 100 ms). This is done by set the fabric iocb block bit</span>
<span class="cm"> * and set up a timeout timer for 100ms. When the block bit is set, no more</span>
<span class="cm"> * fabric iocb will be issued out of the HBA.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">lpfc_block_fabric_iocbs</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">blocked</span><span class="p">;</span>

	<span class="n">blocked</span> <span class="o">=</span> <span class="n">test_and_set_bit</span><span class="p">(</span><span class="n">FABRIC_COMANDS_BLOCKED</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">bit_flags</span><span class="p">);</span>
	<span class="cm">/* Start a timer to unblock fabric iocbs after 100ms */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">blocked</span><span class="p">)</span>
		<span class="n">mod_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">fabric_block_timer</span><span class="p">,</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="n">HZ</span><span class="o">/</span><span class="mi">10</span> <span class="p">);</span>

	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_cmpl_fabric_iocb - Completion callback function for fabric iocb</span>
<span class="cm"> * @phba: pointer to lpfc hba data structure.</span>
<span class="cm"> * @cmdiocb: pointer to lpfc command iocb data structure.</span>
<span class="cm"> * @rspiocb: pointer to lpfc response iocb data structure.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine is the callback function that is put to the fabric iocb&#39;s</span>
<span class="cm"> * callback function pointer (iocb-&gt;iocb_cmpl). The original iocb&#39;s callback</span>
<span class="cm"> * function pointer has been stored in iocb-&gt;fabric_iocb_cmpl. This callback</span>
<span class="cm"> * function first restores and invokes the original iocb&#39;s callback function</span>
<span class="cm"> * and then invokes the lpfc_resume_fabric_iocbs() routine to issue the next</span>
<span class="cm"> * fabric bound iocb from the driver internal fabric iocb list onto the wire.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">lpfc_cmpl_fabric_iocb</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">,</span> <span class="k">struct</span> <span class="n">lpfc_iocbq</span> <span class="o">*</span><span class="n">cmdiocb</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">lpfc_iocbq</span> <span class="o">*</span><span class="n">rspiocb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ls_rjt</span> <span class="n">stat</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">cmdiocb</span><span class="o">-&gt;</span><span class="n">iocb_flag</span> <span class="o">&amp;</span> <span class="n">LPFC_IO_FABRIC</span><span class="p">)</span> <span class="o">!=</span> <span class="n">LPFC_IO_FABRIC</span><span class="p">)</span>
		<span class="n">BUG</span><span class="p">();</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">rspiocb</span><span class="o">-&gt;</span><span class="n">iocb</span><span class="p">.</span><span class="n">ulpStatus</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">IOSTAT_NPORT_RJT</span>:
		<span class="k">case</span> <span class="n">IOSTAT_FABRIC_RJT</span>:
			<span class="k">if</span> <span class="p">(</span><span class="n">rspiocb</span><span class="o">-&gt;</span><span class="n">iocb</span><span class="p">.</span><span class="n">un</span><span class="p">.</span><span class="n">ulpWord</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">RJT_UNAVAIL_TEMP</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">lpfc_block_fabric_iocbs</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">IOSTAT_NPORT_BSY</span>:
		<span class="k">case</span> <span class="n">IOSTAT_FABRIC_BSY</span>:
			<span class="n">lpfc_block_fabric_iocbs</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">IOSTAT_LS_RJT</span>:
			<span class="n">stat</span><span class="p">.</span><span class="n">un</span><span class="p">.</span><span class="n">lsRjtError</span> <span class="o">=</span>
				<span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">rspiocb</span><span class="o">-&gt;</span><span class="n">iocb</span><span class="p">.</span><span class="n">un</span><span class="p">.</span><span class="n">ulpWord</span><span class="p">[</span><span class="mi">4</span><span class="p">]);</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">stat</span><span class="p">.</span><span class="n">un</span><span class="p">.</span><span class="n">b</span><span class="p">.</span><span class="n">lsRjtRsnCode</span> <span class="o">==</span> <span class="n">LSRJT_UNABLE_TPC</span><span class="p">)</span> <span class="o">||</span>
				<span class="p">(</span><span class="n">stat</span><span class="p">.</span><span class="n">un</span><span class="p">.</span><span class="n">b</span><span class="p">.</span><span class="n">lsRjtRsnCode</span> <span class="o">==</span> <span class="n">LSRJT_LOGICAL_BSY</span><span class="p">))</span>
				<span class="n">lpfc_block_fabric_iocbs</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">fabric_iocb_count</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">BUG</span><span class="p">();</span>

	<span class="n">cmdiocb</span><span class="o">-&gt;</span><span class="n">iocb_cmpl</span> <span class="o">=</span> <span class="n">cmdiocb</span><span class="o">-&gt;</span><span class="n">fabric_iocb_cmpl</span><span class="p">;</span>
	<span class="n">cmdiocb</span><span class="o">-&gt;</span><span class="n">fabric_iocb_cmpl</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">cmdiocb</span><span class="o">-&gt;</span><span class="n">iocb_flag</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">LPFC_IO_FABRIC</span><span class="p">;</span>
	<span class="n">cmdiocb</span><span class="o">-&gt;</span><span class="n">iocb_cmpl</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">cmdiocb</span><span class="p">,</span> <span class="n">rspiocb</span><span class="p">);</span>

	<span class="n">atomic_dec</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">fabric_iocb_count</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">test_bit</span><span class="p">(</span><span class="n">FABRIC_COMANDS_BLOCKED</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">bit_flags</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* Post any pending iocbs to HBA */</span>
		<span class="n">lpfc_resume_fabric_iocbs</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_issue_fabric_iocb - Issue a fabric iocb command</span>
<span class="cm"> * @phba: pointer to lpfc hba data structure.</span>
<span class="cm"> * @iocb: pointer to lpfc command iocb data structure.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine is used as the top-level API for issuing a fabric iocb command</span>
<span class="cm"> * such as FLOGI and FDISC. To accommodate certain switch fabric, this driver</span>
<span class="cm"> * function makes sure that only one fabric bound iocb will be outstanding at</span>
<span class="cm"> * any given time. As such, this function will first check to see whether there</span>
<span class="cm"> * is already an outstanding fabric iocb on the wire. If so, it will put the</span>
<span class="cm"> * newly issued iocb onto the driver internal fabric iocb list, waiting to be</span>
<span class="cm"> * issued later. Otherwise, it will issue the iocb on the wire and update the</span>
<span class="cm"> * fabric iocb count it indicate that there is one fabric iocb on the wire.</span>
<span class="cm"> *</span>
<span class="cm"> * Note, this implementation has a potential sending out fabric IOCBs out of</span>
<span class="cm"> * order. The problem is caused by the construction of the &quot;ready&quot; boolen does</span>
<span class="cm"> * not include the condition that the internal fabric IOCB list is empty. As</span>
<span class="cm"> * such, it is possible a fabric IOCB issued by this routine might be &quot;jump&quot;</span>
<span class="cm"> * ahead of the fabric IOCBs in the internal list.</span>
<span class="cm"> *</span>
<span class="cm"> * Return code</span>
<span class="cm"> *   IOCB_SUCCESS - either fabric iocb put on the list or issued successfully</span>
<span class="cm"> *   IOCB_ERROR - failed to issue fabric iocb</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">lpfc_issue_fabric_iocb</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">,</span> <span class="k">struct</span> <span class="n">lpfc_iocbq</span> <span class="o">*</span><span class="n">iocb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">iflags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ready</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">fabric_iocb_count</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span>
		<span class="n">BUG</span><span class="p">();</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">,</span> <span class="n">iflags</span><span class="p">);</span>
	<span class="n">ready</span> <span class="o">=</span> <span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">fabric_iocb_count</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span>
		<span class="o">!</span><span class="n">test_bit</span><span class="p">(</span><span class="n">FABRIC_COMANDS_BLOCKED</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">bit_flags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ready</span><span class="p">)</span>
		<span class="cm">/* Increment fabric iocb count to hold the position */</span>
		<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">fabric_iocb_count</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">,</span> <span class="n">iflags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ready</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">iocb</span><span class="o">-&gt;</span><span class="n">fabric_iocb_cmpl</span> <span class="o">=</span> <span class="n">iocb</span><span class="o">-&gt;</span><span class="n">iocb_cmpl</span><span class="p">;</span>
		<span class="n">iocb</span><span class="o">-&gt;</span><span class="n">iocb_cmpl</span> <span class="o">=</span> <span class="n">lpfc_cmpl_fabric_iocb</span><span class="p">;</span>
		<span class="n">iocb</span><span class="o">-&gt;</span><span class="n">iocb_flag</span> <span class="o">|=</span> <span class="n">LPFC_IO_FABRIC</span><span class="p">;</span>

		<span class="n">lpfc_debugfs_disc_trc</span><span class="p">(</span><span class="n">iocb</span><span class="o">-&gt;</span><span class="n">vport</span><span class="p">,</span> <span class="n">LPFC_DISC_TRC_ELS_CMD</span><span class="p">,</span>
			<span class="s">&quot;Fabric sched2:   ste:x%x&quot;</span><span class="p">,</span>
			<span class="n">iocb</span><span class="o">-&gt;</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">port_state</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

		<span class="n">ret</span> <span class="o">=</span> <span class="n">lpfc_sli_issue_iocb</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">LPFC_ELS_RING</span><span class="p">,</span> <span class="n">iocb</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="n">IOCB_ERROR</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">iocb</span><span class="o">-&gt;</span><span class="n">iocb_cmpl</span> <span class="o">=</span> <span class="n">iocb</span><span class="o">-&gt;</span><span class="n">fabric_iocb_cmpl</span><span class="p">;</span>
			<span class="n">iocb</span><span class="o">-&gt;</span><span class="n">fabric_iocb_cmpl</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="n">iocb</span><span class="o">-&gt;</span><span class="n">iocb_flag</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">LPFC_IO_FABRIC</span><span class="p">;</span>
			<span class="n">atomic_dec</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">fabric_iocb_count</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">,</span> <span class="n">iflags</span><span class="p">);</span>
		<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">iocb</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">fabric_iocb_list</span><span class="p">);</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">,</span> <span class="n">iflags</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">IOCB_SUCCESS</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_fabric_abort_vport - Abort a vport&#39;s iocbs from driver fabric iocb list</span>
<span class="cm"> * @vport: pointer to a virtual N_Port data structure.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine aborts all the IOCBs associated with a @vport from the</span>
<span class="cm"> * driver internal fabric IOCB list. The list contains fabric IOCBs to be</span>
<span class="cm"> * issued to the ELS IOCB ring. This abort function walks the fabric IOCB</span>
<span class="cm"> * list, removes each IOCB associated with the @vport off the list, set the</span>
<span class="cm"> * status feild to IOSTAT_LOCAL_REJECT, and invokes the callback function</span>
<span class="cm"> * associated with the IOCB.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">lpfc_fabric_abort_vport</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="n">vport</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">LIST_HEAD</span><span class="p">(</span><span class="n">completions</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">lpfc_hba</span>  <span class="o">*</span><span class="n">phba</span> <span class="o">=</span> <span class="n">vport</span><span class="o">-&gt;</span><span class="n">phba</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_iocbq</span> <span class="o">*</span><span class="n">tmp_iocb</span><span class="p">,</span> <span class="o">*</span><span class="n">piocb</span><span class="p">;</span>

	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>
	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">piocb</span><span class="p">,</span> <span class="n">tmp_iocb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">fabric_iocb_list</span><span class="p">,</span>
				 <span class="n">list</span><span class="p">)</span> <span class="p">{</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">piocb</span><span class="o">-&gt;</span><span class="n">vport</span> <span class="o">!=</span> <span class="n">vport</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">list_move_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">piocb</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">completions</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>

	<span class="cm">/* Cancel all the IOCBs from the completions list */</span>
	<span class="n">lpfc_sli_cancel_iocbs</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">completions</span><span class="p">,</span> <span class="n">IOSTAT_LOCAL_REJECT</span><span class="p">,</span>
			      <span class="n">IOERR_SLI_ABORTED</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_fabric_abort_nport - Abort a ndlp&#39;s iocbs from driver fabric iocb list</span>
<span class="cm"> * @ndlp: pointer to a node-list data structure.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine aborts all the IOCBs associated with an @ndlp from the</span>
<span class="cm"> * driver internal fabric IOCB list. The list contains fabric IOCBs to be</span>
<span class="cm"> * issued to the ELS IOCB ring. This abort function walks the fabric IOCB</span>
<span class="cm"> * list, removes each IOCB associated with the @ndlp off the list, set the</span>
<span class="cm"> * status feild to IOSTAT_LOCAL_REJECT, and invokes the callback function</span>
<span class="cm"> * associated with the IOCB.</span>
<span class="cm"> **/</span>
<span class="kt">void</span> <span class="nf">lpfc_fabric_abort_nport</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_nodelist</span> <span class="o">*</span><span class="n">ndlp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">LIST_HEAD</span><span class="p">(</span><span class="n">completions</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">lpfc_hba</span>  <span class="o">*</span><span class="n">phba</span> <span class="o">=</span> <span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">phba</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_iocbq</span> <span class="o">*</span><span class="n">tmp_iocb</span><span class="p">,</span> <span class="o">*</span><span class="n">piocb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_sli_ring</span> <span class="o">*</span><span class="n">pring</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli</span><span class="p">.</span><span class="n">ring</span><span class="p">[</span><span class="n">LPFC_ELS_RING</span><span class="p">];</span>

	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>
	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">piocb</span><span class="p">,</span> <span class="n">tmp_iocb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">fabric_iocb_list</span><span class="p">,</span>
				 <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">lpfc_check_sli_ndlp</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">pring</span><span class="p">,</span> <span class="n">piocb</span><span class="p">,</span> <span class="n">ndlp</span><span class="p">)))</span> <span class="p">{</span>

			<span class="n">list_move_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">piocb</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">completions</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>

	<span class="cm">/* Cancel all the IOCBs from the completions list */</span>
	<span class="n">lpfc_sli_cancel_iocbs</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">completions</span><span class="p">,</span> <span class="n">IOSTAT_LOCAL_REJECT</span><span class="p">,</span>
			      <span class="n">IOERR_SLI_ABORTED</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_fabric_abort_hba - Abort all iocbs on driver fabric iocb list</span>
<span class="cm"> * @phba: pointer to lpfc hba data structure.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine aborts all the IOCBs currently on the driver internal</span>
<span class="cm"> * fabric IOCB list. The list contains fabric IOCBs to be issued to the ELS</span>
<span class="cm"> * IOCB ring. This function takes the entire IOCB list off the fabric IOCB</span>
<span class="cm"> * list, removes IOCBs off the list, set the status feild to</span>
<span class="cm"> * IOSTAT_LOCAL_REJECT, and invokes the callback function associated with</span>
<span class="cm"> * the IOCB.</span>
<span class="cm"> **/</span>
<span class="kt">void</span> <span class="nf">lpfc_fabric_abort_hba</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">LIST_HEAD</span><span class="p">(</span><span class="n">completions</span><span class="p">);</span>

	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>
	<span class="n">list_splice_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">fabric_iocb_list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">completions</span><span class="p">);</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>

	<span class="cm">/* Cancel all the IOCBs from the completions list */</span>
	<span class="n">lpfc_sli_cancel_iocbs</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">completions</span><span class="p">,</span> <span class="n">IOSTAT_LOCAL_REJECT</span><span class="p">,</span>
			      <span class="n">IOERR_SLI_ABORTED</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_sli4_vport_delete_els_xri_aborted -Remove all ndlp references for vport</span>
<span class="cm"> * @vport: pointer to lpfc vport data structure.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine is invoked by the vport cleanup for deletions and the cleanup</span>
<span class="cm"> * for an ndlp on removal.</span>
<span class="cm"> **/</span>
<span class="kt">void</span>
<span class="nf">lpfc_sli4_vport_delete_els_xri_aborted</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="n">vport</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span> <span class="o">=</span> <span class="n">vport</span><span class="o">-&gt;</span><span class="n">phba</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_sglq</span> <span class="o">*</span><span class="n">sglq_entry</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">*</span><span class="n">sglq_next</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">iflag</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">,</span> <span class="n">iflag</span><span class="p">);</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">abts_sgl_list_lock</span><span class="p">);</span>
	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">sglq_entry</span><span class="p">,</span> <span class="n">sglq_next</span><span class="p">,</span>
			<span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">lpfc_abts_els_sgl_list</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sglq_entry</span><span class="o">-&gt;</span><span class="n">ndlp</span> <span class="o">&amp;&amp;</span> <span class="n">sglq_entry</span><span class="o">-&gt;</span><span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">vport</span> <span class="o">==</span> <span class="n">vport</span><span class="p">)</span>
			<span class="n">sglq_entry</span><span class="o">-&gt;</span><span class="n">ndlp</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">abts_sgl_list_lock</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">,</span> <span class="n">iflag</span><span class="p">);</span>
	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_sli4_els_xri_aborted - Slow-path process of els xri abort</span>
<span class="cm"> * @phba: pointer to lpfc hba data structure.</span>
<span class="cm"> * @axri: pointer to the els xri abort wcqe structure.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine is invoked by the worker thread to process a SLI4 slow-path</span>
<span class="cm"> * ELS aborted xri.</span>
<span class="cm"> **/</span>
<span class="kt">void</span>
<span class="nf">lpfc_sli4_els_xri_aborted</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">,</span>
			  <span class="k">struct</span> <span class="n">sli4_wcqe_xri_aborted</span> <span class="o">*</span><span class="n">axri</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">uint16_t</span> <span class="n">xri</span> <span class="o">=</span> <span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_wcqe_xa_xri</span><span class="p">,</span> <span class="n">axri</span><span class="p">);</span>
	<span class="kt">uint16_t</span> <span class="n">rxid</span> <span class="o">=</span> <span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_wcqe_xa_remote_xid</span><span class="p">,</span> <span class="n">axri</span><span class="p">);</span>
	<span class="kt">uint16_t</span> <span class="n">lxri</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">lpfc_sglq</span> <span class="o">*</span><span class="n">sglq_entry</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">*</span><span class="n">sglq_next</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">iflag</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_nodelist</span> <span class="o">*</span><span class="n">ndlp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_sli_ring</span> <span class="o">*</span><span class="n">pring</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli</span><span class="p">.</span><span class="n">ring</span><span class="p">[</span><span class="n">LPFC_ELS_RING</span><span class="p">];</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">,</span> <span class="n">iflag</span><span class="p">);</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">abts_sgl_list_lock</span><span class="p">);</span>
	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">sglq_entry</span><span class="p">,</span> <span class="n">sglq_next</span><span class="p">,</span>
			<span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">lpfc_abts_els_sgl_list</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sglq_entry</span><span class="o">-&gt;</span><span class="n">sli4_xritag</span> <span class="o">==</span> <span class="n">xri</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sglq_entry</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
			<span class="n">ndlp</span> <span class="o">=</span> <span class="n">sglq_entry</span><span class="o">-&gt;</span><span class="n">ndlp</span><span class="p">;</span>
			<span class="n">sglq_entry</span><span class="o">-&gt;</span><span class="n">ndlp</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sglq_entry</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span>
				<span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">lpfc_sgl_list</span><span class="p">);</span>
			<span class="n">sglq_entry</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">SGL_FREED</span><span class="p">;</span>
			<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">abts_sgl_list_lock</span><span class="p">);</span>
			<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">,</span> <span class="n">iflag</span><span class="p">);</span>
			<span class="n">lpfc_set_rrq_active</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">ndlp</span><span class="p">,</span>
				<span class="n">sglq_entry</span><span class="o">-&gt;</span><span class="n">sli4_lxritag</span><span class="p">,</span>
				<span class="n">rxid</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

			<span class="cm">/* Check if TXQ queue needs to be serviced */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">pring</span><span class="o">-&gt;</span><span class="n">txq_cnt</span><span class="p">)</span>
				<span class="n">lpfc_worker_wake_up</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">abts_sgl_list_lock</span><span class="p">);</span>
	<span class="n">lxri</span> <span class="o">=</span> <span class="n">lpfc_sli4_xri_inrange</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">xri</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">lxri</span> <span class="o">==</span> <span class="n">NO_XRI</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">,</span> <span class="n">iflag</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">sglq_entry</span> <span class="o">=</span> <span class="n">__lpfc_get_active_sglq</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">lxri</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sglq_entry</span> <span class="o">||</span> <span class="p">(</span><span class="n">sglq_entry</span><span class="o">-&gt;</span><span class="n">sli4_xritag</span> <span class="o">!=</span> <span class="n">xri</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">,</span> <span class="n">iflag</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">sglq_entry</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">SGL_XRI_ABORTED</span><span class="p">;</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">,</span> <span class="n">iflag</span><span class="p">);</span>
	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
