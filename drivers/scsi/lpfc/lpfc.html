<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › scsi › lpfc › lpfc.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>lpfc.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*******************************************************************</span>
<span class="cm"> * This file is part of the Emulex Linux Device Driver for         *</span>
<span class="cm"> * Fibre Channel Host Bus Adapters.                                *</span>
<span class="cm"> * Copyright (C) 2004-2012 Emulex.  All rights reserved.           *</span>
<span class="cm"> * EMULEX and SLI are trademarks of Emulex.                        *</span>
<span class="cm"> * www.emulex.com                                                  *</span>
<span class="cm"> * Portions Copyright (C) 2004-2005 Christoph Hellwig              *</span>
<span class="cm"> *                                                                 *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or   *</span>
<span class="cm"> * modify it under the terms of version 2 of the GNU General       *</span>
<span class="cm"> * Public License as published by the Free Software Foundation.    *</span>
<span class="cm"> * This program is distributed in the hope that it will be useful. *</span>
<span class="cm"> * ALL EXPRESS OR IMPLIED CONDITIONS, REPRESENTATIONS AND          *</span>
<span class="cm"> * WARRANTIES, INCLUDING ANY IMPLIED WARRANTY OF MERCHANTABILITY,  *</span>
<span class="cm"> * FITNESS FOR A PARTICULAR PURPOSE, OR NON-INFRINGEMENT, ARE      *</span>
<span class="cm"> * DISCLAIMED, EXCEPT TO THE EXTENT THAT SUCH DISCLAIMERS ARE HELD *</span>
<span class="cm"> * TO BE LEGALLY INVALID.  See the GNU General Public License for  *</span>
<span class="cm"> * more details, a copy of which can be found in the file COPYING  *</span>
<span class="cm"> * included with this package.                                     *</span>
<span class="cm"> *******************************************************************/</span>

<span class="cp">#include &lt;scsi/scsi_host.h&gt;</span>

<span class="cp">#if defined(CONFIG_DEBUG_FS) &amp;&amp; !defined(CONFIG_SCSI_LPFC_DEBUG_FS)</span>
<span class="cp">#define CONFIG_SCSI_LPFC_DEBUG_FS</span>
<span class="cp">#endif</span>

<span class="k">struct</span> <span class="n">lpfc_sli2_slim</span><span class="p">;</span>

<span class="cp">#define LPFC_PCI_DEV_LP		0x1</span>
<span class="cp">#define LPFC_PCI_DEV_OC		0x2</span>

<span class="cp">#define LPFC_SLI_REV2		2</span>
<span class="cp">#define LPFC_SLI_REV3		3</span>
<span class="cp">#define LPFC_SLI_REV4		4</span>

<span class="cp">#define LPFC_MAX_TARGET		4096	</span><span class="cm">/* max number of targets supported */</span><span class="cp"></span>
<span class="cp">#define LPFC_MAX_DISC_THREADS	64	</span><span class="cm">/* max outstanding discovery els</span>
<span class="cm">					   requests */</span><span class="cp"></span>
<span class="cp">#define LPFC_MAX_NS_RETRY	3	</span><span class="cm">/* Number of retry attempts to contact</span>
<span class="cm">					   the NameServer  before giving up. */</span><span class="cp"></span>
<span class="cp">#define LPFC_CMD_PER_LUN	3	</span><span class="cm">/* max outstanding cmds per lun */</span><span class="cp"></span>
<span class="cp">#define LPFC_DEFAULT_SG_SEG_CNT 64	</span><span class="cm">/* sg element count per scsi cmnd */</span><span class="cp"></span>
<span class="cp">#define LPFC_DEFAULT_MENLO_SG_SEG_CNT 128	</span><span class="cm">/* sg element count per scsi</span>
<span class="cm">		cmnd for menlo needs nearly twice as for firmware</span>
<span class="cm">		downloads using bsg */</span><span class="cp"></span>
<span class="cp">#define LPFC_DEFAULT_PROT_SG_SEG_CNT 4096 </span><span class="cm">/* sg protection elements count */</span><span class="cp"></span>
<span class="cp">#define LPFC_MAX_SG_SEG_CNT	4096	</span><span class="cm">/* sg element count per scsi cmnd */</span><span class="cp"></span>
<span class="cp">#define LPFC_MAX_SGE_SIZE       0x80000000 </span><span class="cm">/* Maximum data allowed in a SGE */</span><span class="cp"></span>
<span class="cp">#define LPFC_MAX_PROT_SG_SEG_CNT 4096	</span><span class="cm">/* prot sg element count per scsi cmd*/</span><span class="cp"></span>
<span class="cp">#define LPFC_IOCB_LIST_CNT	2250	</span><span class="cm">/* list of IOCBs for fast-path usage. */</span><span class="cp"></span>
<span class="cp">#define LPFC_Q_RAMP_UP_INTERVAL 120     </span><span class="cm">/* lun q_depth ramp up interval */</span><span class="cp"></span>
<span class="cp">#define LPFC_VNAME_LEN		100	</span><span class="cm">/* vport symbolic name length */</span><span class="cp"></span>
<span class="cp">#define LPFC_TGTQ_INTERVAL	40000	</span><span class="cm">/* Min amount of time between tgt</span>
<span class="cm">					   queue depth change in millisecs */</span><span class="cp"></span>
<span class="cp">#define LPFC_TGTQ_RAMPUP_PCENT	5	</span><span class="cm">/* Target queue rampup in percentage */</span><span class="cp"></span>
<span class="cp">#define LPFC_MIN_TGT_QDEPTH	10</span>
<span class="cp">#define LPFC_MAX_TGT_QDEPTH	0xFFFF</span>

<span class="cp">#define  LPFC_MAX_BUCKET_COUNT 20	</span><span class="cm">/* Maximum no. of buckets for stat data</span>
<span class="cm">					   collection. */</span><span class="cp"></span>
<span class="cm">/*</span>
<span class="cm"> * Following time intervals are used of adjusting SCSI device</span>
<span class="cm"> * queue depths when there are driver resource error or Firmware</span>
<span class="cm"> * resource error.</span>
<span class="cm"> */</span>
<span class="cp">#define QUEUE_RAMP_DOWN_INTERVAL	(1 * HZ)   </span><span class="cm">/* 1 Second */</span><span class="cp"></span>
<span class="cp">#define QUEUE_RAMP_UP_INTERVAL		(300 * HZ) </span><span class="cm">/* 5 minutes */</span><span class="cp"></span>

<span class="cm">/* Number of exchanges reserved for discovery to complete */</span>
<span class="cp">#define LPFC_DISC_IOCB_BUFF_COUNT 20</span>

<span class="cp">#define LPFC_HB_MBOX_INTERVAL   5	</span><span class="cm">/* Heart beat interval in seconds. */</span><span class="cp"></span>
<span class="cp">#define LPFC_HB_MBOX_TIMEOUT    30	</span><span class="cm">/* Heart beat timeout  in seconds. */</span><span class="cp"></span>

<span class="cm">/* Error Attention event polling interval */</span>
<span class="cp">#define LPFC_ERATT_POLL_INTERVAL	5 </span><span class="cm">/* EATT poll interval in seconds */</span><span class="cp"></span>

<span class="cm">/* Define macros for 64 bit support */</span>
<span class="cp">#define putPaddrLow(addr)    ((uint32_t) (0xffffffff &amp; (u64)(addr)))</span>
<span class="cp">#define putPaddrHigh(addr)   ((uint32_t) (0xffffffff &amp; (((u64)(addr))&gt;&gt;32)))</span>
<span class="cp">#define getPaddr(high, low)  ((dma_addr_t)( \</span>
<span class="cp">			     (( (u64)(high)&lt;&lt;16 ) &lt;&lt; 16)|( (u64)(low))))</span>
<span class="cm">/* Provide maximum configuration definitions. */</span>
<span class="cp">#define LPFC_DRVR_TIMEOUT	16	</span><span class="cm">/* driver iocb timeout value in sec */</span><span class="cp"></span>
<span class="cp">#define FC_MAX_ADPTMSG		64</span>

<span class="cp">#define MAX_HBAEVT	32</span>

<span class="cm">/* Number of MSI-X vectors the driver uses */</span>
<span class="cp">#define LPFC_MSIX_VECTORS	2</span>

<span class="cm">/* lpfc wait event data ready flag */</span>
<span class="cp">#define LPFC_DATA_READY		(1&lt;&lt;0)</span>

<span class="cm">/* queue dump line buffer size */</span>
<span class="cp">#define LPFC_LBUF_SZ		128</span>

<span class="k">enum</span> <span class="n">lpfc_polling_flags</span> <span class="p">{</span>
	<span class="n">ENABLE_FCP_RING_POLLING</span> <span class="o">=</span> <span class="mh">0x1</span><span class="p">,</span>
	<span class="n">DISABLE_FCP_RING_INT</span>    <span class="o">=</span> <span class="mh">0x2</span>
<span class="p">};</span>

<span class="cm">/* Provide DMA memory definitions the driver uses per port instance. */</span>
<span class="k">struct</span> <span class="n">lpfc_dmabuf</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">list</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">virt</span><span class="p">;</span>		<span class="cm">/* virtual address ptr */</span>
	<span class="n">dma_addr_t</span> <span class="n">phys</span><span class="p">;</span>	<span class="cm">/* mapped address */</span>
	<span class="kt">uint32_t</span>   <span class="n">buffer_tag</span><span class="p">;</span>	<span class="cm">/* used for tagged queue ring */</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">lpfc_dma_pool</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpfc_dmabuf</span>   <span class="o">*</span><span class="n">elements</span><span class="p">;</span>
	<span class="kt">uint32_t</span>    <span class="n">max_count</span><span class="p">;</span>
	<span class="kt">uint32_t</span>    <span class="n">current_count</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">hbq_dmabuf</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpfc_dmabuf</span> <span class="n">hbuf</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_dmabuf</span> <span class="n">dbuf</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">size</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">tag</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_cq_event</span> <span class="n">cq_event</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">time_stamp</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* Priority bit.  Set value to exceed low water mark in lpfc_mem. */</span>
<span class="cp">#define MEM_PRI		0x100</span>


<span class="cm">/****************************************************************************/</span>
<span class="cm">/*      Device VPD save area                                                */</span>
<span class="cm">/****************************************************************************/</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">lpfc_vpd</span> <span class="p">{</span>
	<span class="kt">uint32_t</span> <span class="n">status</span><span class="p">;</span>	<span class="cm">/* vpd status value */</span>
	<span class="kt">uint32_t</span> <span class="n">length</span><span class="p">;</span>	<span class="cm">/* number of bytes actually returned */</span>
	<span class="k">struct</span> <span class="p">{</span>
		<span class="kt">uint32_t</span> <span class="n">rsvd1</span><span class="p">;</span>	<span class="cm">/* Revision numbers */</span>
		<span class="kt">uint32_t</span> <span class="n">biuRev</span><span class="p">;</span>
		<span class="kt">uint32_t</span> <span class="n">smRev</span><span class="p">;</span>
		<span class="kt">uint32_t</span> <span class="n">smFwRev</span><span class="p">;</span>
		<span class="kt">uint32_t</span> <span class="n">endecRev</span><span class="p">;</span>
		<span class="kt">uint16_t</span> <span class="n">rBit</span><span class="p">;</span>
		<span class="kt">uint8_t</span> <span class="n">fcphHigh</span><span class="p">;</span>
		<span class="kt">uint8_t</span> <span class="n">fcphLow</span><span class="p">;</span>
		<span class="kt">uint8_t</span> <span class="n">feaLevelHigh</span><span class="p">;</span>
		<span class="kt">uint8_t</span> <span class="n">feaLevelLow</span><span class="p">;</span>
		<span class="kt">uint32_t</span> <span class="n">postKernRev</span><span class="p">;</span>
		<span class="kt">uint32_t</span> <span class="n">opFwRev</span><span class="p">;</span>
		<span class="kt">uint8_t</span> <span class="n">opFwName</span><span class="p">[</span><span class="mi">16</span><span class="p">];</span>
		<span class="kt">uint32_t</span> <span class="n">sli1FwRev</span><span class="p">;</span>
		<span class="kt">uint8_t</span> <span class="n">sli1FwName</span><span class="p">[</span><span class="mi">16</span><span class="p">];</span>
		<span class="kt">uint32_t</span> <span class="n">sli2FwRev</span><span class="p">;</span>
		<span class="kt">uint8_t</span> <span class="n">sli2FwName</span><span class="p">[</span><span class="mi">16</span><span class="p">];</span>
	<span class="p">}</span> <span class="n">rev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="p">{</span>
<span class="cp">#ifdef __BIG_ENDIAN_BITFIELD</span>
		<span class="kt">uint32_t</span> <span class="n">rsvd3</span>  <span class="o">:</span><span class="mi">19</span><span class="p">;</span>  <span class="cm">/* Reserved                             */</span>
		<span class="kt">uint32_t</span> <span class="n">cdss</span>	<span class="o">:</span> <span class="mi">1</span><span class="p">;</span>  <span class="cm">/* Configure Data Security SLI          */</span>
		<span class="kt">uint32_t</span> <span class="n">rsvd2</span>	<span class="o">:</span> <span class="mi">3</span><span class="p">;</span>  <span class="cm">/* Reserved                             */</span>
		<span class="kt">uint32_t</span> <span class="n">cbg</span>	<span class="o">:</span> <span class="mi">1</span><span class="p">;</span>  <span class="cm">/* Configure BlockGuard                 */</span>
		<span class="kt">uint32_t</span> <span class="n">cmv</span>	<span class="o">:</span> <span class="mi">1</span><span class="p">;</span>  <span class="cm">/* Configure Max VPIs                   */</span>
		<span class="kt">uint32_t</span> <span class="n">ccrp</span>   <span class="o">:</span> <span class="mi">1</span><span class="p">;</span>  <span class="cm">/* Config Command Ring Polling          */</span>
		<span class="kt">uint32_t</span> <span class="n">csah</span>   <span class="o">:</span> <span class="mi">1</span><span class="p">;</span>  <span class="cm">/* Configure Synchronous Abort Handling */</span>
		<span class="kt">uint32_t</span> <span class="n">chbs</span>   <span class="o">:</span> <span class="mi">1</span><span class="p">;</span>  <span class="cm">/* Cofigure Host Backing store          */</span>
		<span class="kt">uint32_t</span> <span class="n">cinb</span>   <span class="o">:</span> <span class="mi">1</span><span class="p">;</span>  <span class="cm">/* Enable Interrupt Notification Block  */</span>
		<span class="kt">uint32_t</span> <span class="n">cerbm</span>	<span class="o">:</span> <span class="mi">1</span><span class="p">;</span>  <span class="cm">/* Configure Enhanced Receive Buf Mgmt  */</span>
		<span class="kt">uint32_t</span> <span class="n">cmx</span>	<span class="o">:</span> <span class="mi">1</span><span class="p">;</span>  <span class="cm">/* Configure Max XRIs                   */</span>
		<span class="kt">uint32_t</span> <span class="n">cmr</span>	<span class="o">:</span> <span class="mi">1</span><span class="p">;</span>  <span class="cm">/* Configure Max RPIs                   */</span>
<span class="cp">#else	</span><span class="cm">/*  __LITTLE_ENDIAN */</span><span class="cp"></span>
		<span class="kt">uint32_t</span> <span class="n">cmr</span>	<span class="o">:</span> <span class="mi">1</span><span class="p">;</span>  <span class="cm">/* Configure Max RPIs                   */</span>
		<span class="kt">uint32_t</span> <span class="n">cmx</span>	<span class="o">:</span> <span class="mi">1</span><span class="p">;</span>  <span class="cm">/* Configure Max XRIs                   */</span>
		<span class="kt">uint32_t</span> <span class="n">cerbm</span>	<span class="o">:</span> <span class="mi">1</span><span class="p">;</span>  <span class="cm">/* Configure Enhanced Receive Buf Mgmt  */</span>
		<span class="kt">uint32_t</span> <span class="n">cinb</span>   <span class="o">:</span> <span class="mi">1</span><span class="p">;</span>  <span class="cm">/* Enable Interrupt Notification Block  */</span>
		<span class="kt">uint32_t</span> <span class="n">chbs</span>   <span class="o">:</span> <span class="mi">1</span><span class="p">;</span>  <span class="cm">/* Cofigure Host Backing store          */</span>
		<span class="kt">uint32_t</span> <span class="n">csah</span>   <span class="o">:</span> <span class="mi">1</span><span class="p">;</span>  <span class="cm">/* Configure Synchronous Abort Handling */</span>
		<span class="kt">uint32_t</span> <span class="n">ccrp</span>   <span class="o">:</span> <span class="mi">1</span><span class="p">;</span>  <span class="cm">/* Config Command Ring Polling          */</span>
		<span class="kt">uint32_t</span> <span class="n">cmv</span>	<span class="o">:</span> <span class="mi">1</span><span class="p">;</span>  <span class="cm">/* Configure Max VPIs                   */</span>
		<span class="kt">uint32_t</span> <span class="n">cbg</span>	<span class="o">:</span> <span class="mi">1</span><span class="p">;</span>  <span class="cm">/* Configure BlockGuard                 */</span>
		<span class="kt">uint32_t</span> <span class="n">rsvd2</span>	<span class="o">:</span> <span class="mi">3</span><span class="p">;</span>  <span class="cm">/* Reserved                             */</span>
		<span class="kt">uint32_t</span> <span class="n">cdss</span>	<span class="o">:</span> <span class="mi">1</span><span class="p">;</span>  <span class="cm">/* Configure Data Security SLI          */</span>
		<span class="kt">uint32_t</span> <span class="n">rsvd3</span>  <span class="o">:</span><span class="mi">19</span><span class="p">;</span>  <span class="cm">/* Reserved                             */</span>
<span class="cp">#endif</span>
	<span class="p">}</span> <span class="n">sli3Feat</span><span class="p">;</span>
<span class="p">}</span> <span class="n">lpfc_vpd_t</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">lpfc_scsi_buf</span><span class="p">;</span>


<span class="cm">/*</span>
<span class="cm"> * lpfc stat counters</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">lpfc_stats</span> <span class="p">{</span>
	<span class="cm">/* Statistics for ELS commands */</span>
	<span class="kt">uint32_t</span> <span class="n">elsLogiCol</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">elsRetryExceeded</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">elsXmitRetry</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">elsDelayRetry</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">elsRcvDrop</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">elsRcvFrame</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">elsRcvRSCN</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">elsRcvRNID</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">elsRcvFARP</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">elsRcvFARPR</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">elsRcvFLOGI</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">elsRcvPLOGI</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">elsRcvADISC</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">elsRcvPDISC</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">elsRcvFAN</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">elsRcvLOGO</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">elsRcvPRLO</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">elsRcvPRLI</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">elsRcvLIRR</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">elsRcvRLS</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">elsRcvRPS</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">elsRcvRPL</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">elsRcvRRQ</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">elsRcvRTV</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">elsRcvECHO</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">elsXmitFLOGI</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">elsXmitFDISC</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">elsXmitPLOGI</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">elsXmitPRLI</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">elsXmitADISC</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">elsXmitLOGO</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">elsXmitSCR</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">elsXmitRNID</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">elsXmitFARP</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">elsXmitFARPR</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">elsXmitACC</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">elsXmitLSRJT</span><span class="p">;</span>

	<span class="kt">uint32_t</span> <span class="n">frameRcvBcast</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">frameRcvMulti</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">strayXmitCmpl</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">frameXmitDelay</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">xriCmdCmpl</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">xriStatErr</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">LinkUp</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">LinkDown</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">LinkMultiEvent</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">NoRcvBuf</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">fcpCmd</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">fcpCmpl</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">fcpRspErr</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">fcpRemoteStop</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">fcpPortRjt</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">fcpPortBusy</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">fcpError</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">fcpLocalErr</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">lpfc_hba</span><span class="p">;</span>


<span class="k">enum</span> <span class="n">discovery_state</span> <span class="p">{</span>
	<span class="n">LPFC_VPORT_UNKNOWN</span>     <span class="o">=</span>  <span class="mi">0</span><span class="p">,</span>    <span class="cm">/* vport state is unknown */</span>
	<span class="n">LPFC_VPORT_FAILED</span>      <span class="o">=</span>  <span class="mi">1</span><span class="p">,</span>    <span class="cm">/* vport has failed */</span>
	<span class="n">LPFC_LOCAL_CFG_LINK</span>    <span class="o">=</span>  <span class="mi">6</span><span class="p">,</span>    <span class="cm">/* local NPORT Id configured */</span>
	<span class="n">LPFC_FLOGI</span>             <span class="o">=</span>  <span class="mi">7</span><span class="p">,</span>    <span class="cm">/* FLOGI sent to Fabric */</span>
	<span class="n">LPFC_FDISC</span>             <span class="o">=</span>  <span class="mi">8</span><span class="p">,</span>    <span class="cm">/* FDISC sent for vport */</span>
	<span class="n">LPFC_FABRIC_CFG_LINK</span>   <span class="o">=</span>  <span class="mi">9</span><span class="p">,</span>    <span class="cm">/* Fabric assigned NPORT Id</span>
<span class="cm">				         * configured */</span>
	<span class="n">LPFC_NS_REG</span>            <span class="o">=</span>  <span class="mi">10</span><span class="p">,</span>   <span class="cm">/* Register with NameServer */</span>
	<span class="n">LPFC_NS_QRY</span>            <span class="o">=</span>  <span class="mi">11</span><span class="p">,</span>   <span class="cm">/* Query NameServer for NPort ID list */</span>
	<span class="n">LPFC_BUILD_DISC_LIST</span>   <span class="o">=</span>  <span class="mi">12</span><span class="p">,</span>   <span class="cm">/* Build ADISC and PLOGI lists for</span>
<span class="cm">				         * device authentication / discovery */</span>
	<span class="n">LPFC_DISC_AUTH</span>         <span class="o">=</span>  <span class="mi">13</span><span class="p">,</span>   <span class="cm">/* Processing ADISC list */</span>
	<span class="n">LPFC_VPORT_READY</span>       <span class="o">=</span>  <span class="mi">32</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">enum</span> <span class="n">hba_state</span> <span class="p">{</span>
	<span class="n">LPFC_LINK_UNKNOWN</span>    <span class="o">=</span>   <span class="mi">0</span><span class="p">,</span>   <span class="cm">/* HBA state is unknown */</span>
	<span class="n">LPFC_WARM_START</span>      <span class="o">=</span>   <span class="mi">1</span><span class="p">,</span>   <span class="cm">/* HBA state after selective reset */</span>
	<span class="n">LPFC_INIT_START</span>      <span class="o">=</span>   <span class="mi">2</span><span class="p">,</span>   <span class="cm">/* Initial state after board reset */</span>
	<span class="n">LPFC_INIT_MBX_CMDS</span>   <span class="o">=</span>   <span class="mi">3</span><span class="p">,</span>   <span class="cm">/* Initialize HBA with mbox commands */</span>
	<span class="n">LPFC_LINK_DOWN</span>       <span class="o">=</span>   <span class="mi">4</span><span class="p">,</span>   <span class="cm">/* HBA initialized, link is down */</span>
	<span class="n">LPFC_LINK_UP</span>         <span class="o">=</span>   <span class="mi">5</span><span class="p">,</span>   <span class="cm">/* Link is up  - issue READ_LA */</span>
	<span class="n">LPFC_CLEAR_LA</span>        <span class="o">=</span>   <span class="mi">6</span><span class="p">,</span>   <span class="cm">/* authentication cmplt - issue</span>
<span class="cm">				       * CLEAR_LA */</span>
	<span class="n">LPFC_HBA_READY</span>       <span class="o">=</span>  <span class="mi">32</span><span class="p">,</span>
	<span class="n">LPFC_HBA_ERROR</span>       <span class="o">=</span>  <span class="o">-</span><span class="mi">1</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">listentry</span><span class="p">;</span>
	<span class="kt">uint8_t</span> <span class="n">port_type</span><span class="p">;</span>
<span class="cp">#define LPFC_PHYSICAL_PORT 1</span>
<span class="cp">#define LPFC_NPIV_PORT  2</span>
<span class="cp">#define LPFC_FABRIC_PORT 3</span>
	<span class="k">enum</span> <span class="n">discovery_state</span> <span class="n">port_state</span><span class="p">;</span>

	<span class="kt">uint16_t</span> <span class="n">vpi</span><span class="p">;</span>
	<span class="kt">uint16_t</span> <span class="n">vfi</span><span class="p">;</span>
	<span class="kt">uint8_t</span> <span class="n">vpi_state</span><span class="p">;</span>
<span class="cp">#define LPFC_VPI_REGISTERED	0x1</span>

	<span class="kt">uint32_t</span> <span class="n">fc_flag</span><span class="p">;</span>	<span class="cm">/* FC flags */</span>
<span class="cm">/* Several of these flags are HBA centric and should be moved to</span>
<span class="cm"> * phba-&gt;link_flag (e.g. FC_PTP, FC_PUBLIC_LOOP)</span>
<span class="cm"> */</span>
<span class="cp">#define FC_PT2PT                0x1	 </span><span class="cm">/* pt2pt with no fabric */</span><span class="cp"></span>
<span class="cp">#define FC_PT2PT_PLOGI          0x2	 </span><span class="cm">/* pt2pt initiate PLOGI */</span><span class="cp"></span>
<span class="cp">#define FC_DISC_TMO             0x4	 </span><span class="cm">/* Discovery timer running */</span><span class="cp"></span>
<span class="cp">#define FC_PUBLIC_LOOP          0x8	 </span><span class="cm">/* Public loop */</span><span class="cp"></span>
<span class="cp">#define FC_LBIT                 0x10	 </span><span class="cm">/* LOGIN bit in loopinit set */</span><span class="cp"></span>
<span class="cp">#define FC_RSCN_MODE            0x20	 </span><span class="cm">/* RSCN cmd rcv&#39;ed */</span><span class="cp"></span>
<span class="cp">#define FC_NLP_MORE             0x40	 </span><span class="cm">/* More node to process in node tbl */</span><span class="cp"></span>
<span class="cp">#define FC_OFFLINE_MODE         0x80	 </span><span class="cm">/* Interface is offline for diag */</span><span class="cp"></span>
<span class="cp">#define FC_FABRIC               0x100	 </span><span class="cm">/* We are fabric attached */</span><span class="cp"></span>
<span class="cp">#define FC_VPORT_LOGO_RCVD      0x200    </span><span class="cm">/* LOGO received on vport */</span><span class="cp"></span>
<span class="cp">#define FC_RSCN_DISCOVERY       0x400	 </span><span class="cm">/* Auth all devices after RSCN */</span><span class="cp"></span>
<span class="cp">#define FC_LOGO_RCVD_DID_CHNG   0x800    </span><span class="cm">/* FDISC on phys port detect DID chng*/</span><span class="cp"></span>
<span class="cp">#define FC_SCSI_SCAN_TMO        0x4000	 </span><span class="cm">/* scsi scan timer running */</span><span class="cp"></span>
<span class="cp">#define FC_ABORT_DISCOVERY      0x8000	 </span><span class="cm">/* we want to abort discovery */</span><span class="cp"></span>
<span class="cp">#define FC_NDISC_ACTIVE         0x10000	 </span><span class="cm">/* NPort discovery active */</span><span class="cp"></span>
<span class="cp">#define FC_BYPASSED_MODE        0x20000	 </span><span class="cm">/* NPort is in bypassed mode */</span><span class="cp"></span>
<span class="cp">#define FC_VPORT_NEEDS_REG_VPI	0x80000  </span><span class="cm">/* Needs to have its vpi registered */</span><span class="cp"></span>
<span class="cp">#define FC_RSCN_DEFERRED	0x100000 </span><span class="cm">/* A deferred RSCN being processed */</span><span class="cp"></span>
<span class="cp">#define FC_VPORT_NEEDS_INIT_VPI 0x200000 </span><span class="cm">/* Need to INIT_VPI before FDISC */</span><span class="cp"></span>
<span class="cp">#define FC_VPORT_CVL_RCVD	0x400000 </span><span class="cm">/* VLink failed due to CVL	 */</span><span class="cp"></span>
<span class="cp">#define FC_VFI_REGISTERED	0x800000 </span><span class="cm">/* VFI is registered */</span><span class="cp"></span>
<span class="cp">#define FC_FDISC_COMPLETED	0x1000000</span><span class="cm">/* FDISC completed */</span><span class="cp"></span>
<span class="cp">#define FC_DISC_DELAYED		0x2000000</span><span class="cm">/* Delay NPort discovery */</span><span class="cp"></span>

	<span class="kt">uint32_t</span> <span class="n">ct_flags</span><span class="p">;</span>
<span class="cp">#define FC_CT_RFF_ID		0x1	 </span><span class="cm">/* RFF_ID accepted by switch */</span><span class="cp"></span>
<span class="cp">#define FC_CT_RNN_ID		0x2	 </span><span class="cm">/* RNN_ID accepted by switch */</span><span class="cp"></span>
<span class="cp">#define FC_CT_RSNN_NN		0x4	 </span><span class="cm">/* RSNN_NN accepted by switch */</span><span class="cp"></span>
<span class="cp">#define FC_CT_RSPN_ID		0x8	 </span><span class="cm">/* RSPN_ID accepted by switch */</span><span class="cp"></span>
<span class="cp">#define FC_CT_RFT_ID		0x10	 </span><span class="cm">/* RFT_ID accepted by switch */</span><span class="cp"></span>

	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">fc_nodes</span><span class="p">;</span>

	<span class="cm">/* Keep counters for the number of entries in each list. */</span>
	<span class="kt">uint16_t</span> <span class="n">fc_plogi_cnt</span><span class="p">;</span>
	<span class="kt">uint16_t</span> <span class="n">fc_adisc_cnt</span><span class="p">;</span>
	<span class="kt">uint16_t</span> <span class="n">fc_reglogin_cnt</span><span class="p">;</span>
	<span class="kt">uint16_t</span> <span class="n">fc_prli_cnt</span><span class="p">;</span>
	<span class="kt">uint16_t</span> <span class="n">fc_unmap_cnt</span><span class="p">;</span>
	<span class="kt">uint16_t</span> <span class="n">fc_map_cnt</span><span class="p">;</span>
	<span class="kt">uint16_t</span> <span class="n">fc_npr_cnt</span><span class="p">;</span>
	<span class="kt">uint16_t</span> <span class="n">fc_unused_cnt</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">serv_parm</span> <span class="n">fc_sparam</span><span class="p">;</span>	<span class="cm">/* buffer for our service parameters */</span>

	<span class="kt">uint32_t</span> <span class="n">fc_myDID</span><span class="p">;</span>	<span class="cm">/* fibre channel S_ID */</span>
	<span class="kt">uint32_t</span> <span class="n">fc_prevDID</span><span class="p">;</span>	<span class="cm">/* previous fibre channel S_ID */</span>
	<span class="k">struct</span> <span class="n">lpfc_name</span> <span class="n">fabric_portname</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_name</span> <span class="n">fabric_nodename</span><span class="p">;</span>

	<span class="kt">int32_t</span> <span class="n">stopped</span><span class="p">;</span>   <span class="cm">/* HBA has not been restarted since last ERATT */</span>
	<span class="kt">uint8_t</span> <span class="n">fc_linkspeed</span><span class="p">;</span>	<span class="cm">/* Link speed after last READ_LA */</span>

	<span class="kt">uint32_t</span> <span class="n">num_disc_nodes</span><span class="p">;</span>	<span class="cm">/*in addition to hba_state */</span>

	<span class="kt">uint32_t</span> <span class="n">fc_nlp_cnt</span><span class="p">;</span>	<span class="cm">/* outstanding NODELIST requests */</span>
	<span class="kt">uint32_t</span> <span class="n">fc_rscn_id_cnt</span><span class="p">;</span>	<span class="cm">/* count of RSCNs payloads in list */</span>
	<span class="kt">uint32_t</span> <span class="n">fc_rscn_flush</span><span class="p">;</span>		<span class="cm">/* flag use of fc_rscn_id_list */</span>
	<span class="k">struct</span> <span class="n">lpfc_dmabuf</span> <span class="o">*</span><span class="n">fc_rscn_id_list</span><span class="p">[</span><span class="n">FC_MAX_HOLD_RSCN</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">lpfc_name</span> <span class="n">fc_nodename</span><span class="p">;</span>	<span class="cm">/* fc nodename */</span>
	<span class="k">struct</span> <span class="n">lpfc_name</span> <span class="n">fc_portname</span><span class="p">;</span>	<span class="cm">/* fc portname */</span>

	<span class="k">struct</span> <span class="n">lpfc_work_evt</span> <span class="n">disc_timeout_evt</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">timer_list</span> <span class="n">fc_disctmo</span><span class="p">;</span>	<span class="cm">/* Discovery rescue timer */</span>
	<span class="kt">uint8_t</span> <span class="n">fc_ns_retry</span><span class="p">;</span>	<span class="cm">/* retries for fabric nameserver */</span>
	<span class="kt">uint32_t</span> <span class="n">fc_prli_sent</span><span class="p">;</span>	<span class="cm">/* cntr for outstanding PRLIs */</span>

	<span class="n">spinlock_t</span> <span class="n">work_port_lock</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">work_port_events</span><span class="p">;</span> <span class="cm">/* Timeout to be handled  */</span>
<span class="cp">#define WORKER_DISC_TMO                0x1	</span><span class="cm">/* vport: Discovery timeout */</span><span class="cp"></span>
<span class="cp">#define WORKER_ELS_TMO                 0x2	</span><span class="cm">/* vport: ELS timeout */</span><span class="cp"></span>
<span class="cp">#define WORKER_FDMI_TMO                0x4	</span><span class="cm">/* vport: FDMI timeout */</span><span class="cp"></span>
<span class="cp">#define WORKER_DELAYED_DISC_TMO        0x8	</span><span class="cm">/* vport: delayed discovery */</span><span class="cp"></span>

<span class="cp">#define WORKER_MBOX_TMO                0x100	</span><span class="cm">/* hba: MBOX timeout */</span><span class="cp"></span>
<span class="cp">#define WORKER_HB_TMO                  0x200	</span><span class="cm">/* hba: Heart beat timeout */</span><span class="cp"></span>
<span class="cp">#define WORKER_FABRIC_BLOCK_TMO        0x400	</span><span class="cm">/* hba: fabric block timeout */</span><span class="cp"></span>
<span class="cp">#define WORKER_RAMP_DOWN_QUEUE         0x800	</span><span class="cm">/* hba: Decrease Q depth */</span><span class="cp"></span>
<span class="cp">#define WORKER_RAMP_UP_QUEUE           0x1000	</span><span class="cm">/* hba: Increase Q depth */</span><span class="cp"></span>
<span class="cp">#define WORKER_SERVICE_TXQ             0x2000	</span><span class="cm">/* hba: IOCBs on the txq */</span><span class="cp"></span>

	<span class="k">struct</span> <span class="n">timer_list</span> <span class="n">fc_fdmitmo</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">timer_list</span> <span class="n">els_tmofunc</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">timer_list</span> <span class="n">delayed_disc_tmo</span><span class="p">;</span>

	<span class="kt">int</span> <span class="n">unreg_vpi_cmpl</span><span class="p">;</span>

	<span class="kt">uint8_t</span> <span class="n">load_flag</span><span class="p">;</span>
<span class="cp">#define FC_LOADING		0x1	</span><span class="cm">/* HBA in process of loading drvr */</span><span class="cp"></span>
<span class="cp">#define FC_UNLOADING		0x2	</span><span class="cm">/* HBA in process of unloading drvr */</span><span class="cp"></span>
	<span class="cm">/* Vport Config Parameters */</span>
	<span class="kt">uint32_t</span> <span class="n">cfg_scan_down</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">cfg_lun_queue_depth</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">cfg_nodev_tmo</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">cfg_devloss_tmo</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">cfg_restrict_login</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">cfg_peer_port_login</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">cfg_fcp_class</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">cfg_use_adisc</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">cfg_fdmi_on</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">cfg_discovery_threads</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">cfg_log_verbose</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">cfg_max_luns</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">cfg_enable_da_id</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">cfg_max_scsicmpl_time</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">cfg_tgt_queue_depth</span><span class="p">;</span>

	<span class="kt">uint32_t</span> <span class="n">dev_loss_tmo_changed</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">fc_vport</span> <span class="o">*</span><span class="n">fc_vport</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_SCSI_LPFC_DEBUG_FS</span>
	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">debug_disc_trc</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">debug_nodelist</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">vport_debugfs_root</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_debugfs_trc</span> <span class="o">*</span><span class="n">disc_trc</span><span class="p">;</span>
	<span class="n">atomic_t</span> <span class="n">disc_trc_cnt</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="kt">uint8_t</span> <span class="n">stat_data_enabled</span><span class="p">;</span>
	<span class="kt">uint8_t</span> <span class="n">stat_data_blocked</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">rcv_buffer_list</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">rcv_buffer_time_stamp</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">vport_flag</span><span class="p">;</span>
<span class="cp">#define STATIC_VPORT	1</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">hbq_s</span> <span class="p">{</span>
	<span class="kt">uint16_t</span> <span class="n">entry_count</span><span class="p">;</span>	  <span class="cm">/* Current number of HBQ slots */</span>
	<span class="kt">uint16_t</span> <span class="n">buffer_count</span><span class="p">;</span>	  <span class="cm">/* Current number of buffers posted */</span>
	<span class="kt">uint32_t</span> <span class="n">next_hbqPutIdx</span><span class="p">;</span>  <span class="cm">/* Index to next HBQ slot to use */</span>
	<span class="kt">uint32_t</span> <span class="n">hbqPutIdx</span><span class="p">;</span>	  <span class="cm">/* HBQ slot to use */</span>
	<span class="kt">uint32_t</span> <span class="n">local_hbqGetIdx</span><span class="p">;</span> <span class="cm">/* Local copy of Get index from Port */</span>
	<span class="kt">void</span>    <span class="o">*</span><span class="n">hbq_virt</span><span class="p">;</span>	  <span class="cm">/* Virtual ptr to this hbq */</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">hbq_buffer_list</span><span class="p">;</span>  <span class="cm">/* buffers assigned to this HBQ */</span>
				  <span class="cm">/* Callback for HBQ buffer allocation */</span>
	<span class="k">struct</span> <span class="n">hbq_dmabuf</span> <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="n">hbq_alloc_buffer</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="p">);</span>
				  <span class="cm">/* Callback for HBQ buffer free */</span>
	<span class="kt">void</span>               <span class="p">(</span><span class="o">*</span><span class="n">hbq_free_buffer</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="p">,</span>
					       <span class="k">struct</span> <span class="n">hbq_dmabuf</span> <span class="o">*</span><span class="p">);</span>
<span class="p">};</span>

<span class="cp">#define LPFC_MAX_HBQS  4</span>
<span class="cm">/* this matches the position in the lpfc_hbq_defs array */</span>
<span class="cp">#define LPFC_ELS_HBQ	0</span>
<span class="cp">#define LPFC_EXTRA_HBQ	1</span>

<span class="k">enum</span> <span class="n">hba_temp_state</span> <span class="p">{</span>
	<span class="n">HBA_NORMAL_TEMP</span><span class="p">,</span>
	<span class="n">HBA_OVER_TEMP</span>
<span class="p">};</span>

<span class="k">enum</span> <span class="n">intr_type_t</span> <span class="p">{</span>
	<span class="n">NONE</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	<span class="n">INTx</span><span class="p">,</span>
	<span class="n">MSI</span><span class="p">,</span>
	<span class="n">MSIX</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">unsol_rcv_ct_ctx</span> <span class="p">{</span>
	<span class="kt">uint32_t</span> <span class="n">ctxt_id</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">SID</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">flags</span><span class="p">;</span>
<span class="cp">#define UNSOL_VALID	0x00000001</span>
	<span class="kt">uint16_t</span> <span class="n">oxid</span><span class="p">;</span>
	<span class="kt">uint16_t</span> <span class="n">rxid</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#define LPFC_USER_LINK_SPEED_AUTO	0	</span><span class="cm">/* auto select (default)*/</span><span class="cp"></span>
<span class="cp">#define LPFC_USER_LINK_SPEED_1G		1	</span><span class="cm">/* 1 Gigabaud */</span><span class="cp"></span>
<span class="cp">#define LPFC_USER_LINK_SPEED_2G		2	</span><span class="cm">/* 2 Gigabaud */</span><span class="cp"></span>
<span class="cp">#define LPFC_USER_LINK_SPEED_4G		4	</span><span class="cm">/* 4 Gigabaud */</span><span class="cp"></span>
<span class="cp">#define LPFC_USER_LINK_SPEED_8G		8	</span><span class="cm">/* 8 Gigabaud */</span><span class="cp"></span>
<span class="cp">#define LPFC_USER_LINK_SPEED_10G	10	</span><span class="cm">/* 10 Gigabaud */</span><span class="cp"></span>
<span class="cp">#define LPFC_USER_LINK_SPEED_16G	16	</span><span class="cm">/* 16 Gigabaud */</span><span class="cp"></span>
<span class="cp">#define LPFC_USER_LINK_SPEED_MAX	LPFC_USER_LINK_SPEED_16G</span>
<span class="cp">#define LPFC_USER_LINK_SPEED_BITMAP ((1 &lt;&lt; LPFC_USER_LINK_SPEED_16G) | \</span>
<span class="cp">				     (1 &lt;&lt; LPFC_USER_LINK_SPEED_10G) | \</span>
<span class="cp">				     (1 &lt;&lt; LPFC_USER_LINK_SPEED_8G) | \</span>
<span class="cp">				     (1 &lt;&lt; LPFC_USER_LINK_SPEED_4G) | \</span>
<span class="cp">				     (1 &lt;&lt; LPFC_USER_LINK_SPEED_2G) | \</span>
<span class="cp">				     (1 &lt;&lt; LPFC_USER_LINK_SPEED_1G) | \</span>
<span class="cp">				     (1 &lt;&lt; LPFC_USER_LINK_SPEED_AUTO))</span>
<span class="cp">#define LPFC_LINK_SPEED_STRING &quot;0, 1, 2, 4, 8, 10, 16&quot;</span>

<span class="k">enum</span> <span class="n">nemb_type</span> <span class="p">{</span>
	<span class="n">nemb_mse</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
	<span class="n">nemb_hbd</span>
<span class="p">};</span>

<span class="k">enum</span> <span class="n">mbox_type</span> <span class="p">{</span>
	<span class="n">mbox_rd</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
	<span class="n">mbox_wr</span>
<span class="p">};</span>

<span class="k">enum</span> <span class="n">dma_type</span> <span class="p">{</span>
	<span class="n">dma_mbox</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
	<span class="n">dma_ebuf</span>
<span class="p">};</span>

<span class="k">enum</span> <span class="n">sta_type</span> <span class="p">{</span>
	<span class="n">sta_pre_addr</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
	<span class="n">sta_pos_addr</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">lpfc_mbox_ext_buf_ctx</span> <span class="p">{</span>
	<span class="kt">uint32_t</span> <span class="n">state</span><span class="p">;</span>
<span class="cp">#define LPFC_BSG_MBOX_IDLE		0</span>
<span class="cp">#define LPFC_BSG_MBOX_HOST              1</span>
<span class="cp">#define LPFC_BSG_MBOX_PORT		2</span>
<span class="cp">#define LPFC_BSG_MBOX_DONE		3</span>
<span class="cp">#define LPFC_BSG_MBOX_ABTS		4</span>
	<span class="k">enum</span> <span class="n">nemb_type</span> <span class="n">nembType</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">mbox_type</span> <span class="n">mboxType</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">numBuf</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">mbxTag</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">seqNum</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_dmabuf</span> <span class="o">*</span><span class="n">mbx_dmabuf</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">ext_dmabuf_list</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="p">{</span>
	<span class="cm">/* SCSI interface function jump table entries */</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">lpfc_new_scsi_buf</span><span class="p">)</span>
		<span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">lpfc_scsi_buf</span> <span class="o">*</span> <span class="p">(</span><span class="o">*</span><span class="n">lpfc_get_scsi_buf</span><span class="p">)</span>
		<span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">lpfc_nodelist</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">lpfc_scsi_prep_dma_buf</span><span class="p">)</span>
		<span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">lpfc_scsi_buf</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">lpfc_scsi_unprep_dma_buf</span><span class="p">)</span>
		<span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">lpfc_scsi_buf</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">lpfc_release_scsi_buf</span><span class="p">)</span>
		<span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">lpfc_scsi_buf</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">lpfc_rampdown_queue_depth</span><span class="p">)</span>
		<span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">lpfc_scsi_prep_cmnd</span><span class="p">)</span>
		<span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">lpfc_scsi_buf</span> <span class="o">*</span><span class="p">,</span>
		 <span class="k">struct</span> <span class="n">lpfc_nodelist</span> <span class="o">*</span><span class="p">);</span>

	<span class="cm">/* IOCB interface function jump table entries */</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">__lpfc_sli_issue_iocb</span><span class="p">)</span>
		<span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="p">,</span> <span class="kt">uint32_t</span><span class="p">,</span>
		 <span class="k">struct</span> <span class="n">lpfc_iocbq</span> <span class="o">*</span><span class="p">,</span> <span class="kt">uint32_t</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">__lpfc_sli_release_iocbq</span><span class="p">)(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="p">,</span>
			 <span class="k">struct</span> <span class="n">lpfc_iocbq</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">lpfc_hba_down_post</span><span class="p">)(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">);</span>
	<span class="n">IOCB_t</span> <span class="o">*</span> <span class="p">(</span><span class="o">*</span><span class="n">lpfc_get_iocb_from_iocbq</span><span class="p">)</span>
		<span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_iocbq</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">lpfc_scsi_cmd_iocb_cmpl</span><span class="p">)</span>
		<span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">lpfc_iocbq</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">lpfc_iocbq</span> <span class="o">*</span><span class="p">);</span>

	<span class="cm">/* MBOX interface function jump table entries */</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">lpfc_sli_issue_mbox</span><span class="p">)</span>
		<span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="p">,</span> <span class="n">LPFC_MBOXQ_t</span> <span class="o">*</span><span class="p">,</span> <span class="kt">uint32_t</span><span class="p">);</span>

	<span class="cm">/* Slow-path IOCB process function jump table entries */</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">lpfc_sli_handle_slow_ring_event</span><span class="p">)</span>
		<span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">,</span> <span class="k">struct</span> <span class="n">lpfc_sli_ring</span> <span class="o">*</span><span class="n">pring</span><span class="p">,</span>
		 <span class="kt">uint32_t</span> <span class="n">mask</span><span class="p">);</span>

	<span class="cm">/* INIT device interface function jump table entries */</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">lpfc_sli_hbq_to_firmware</span><span class="p">)</span>
		<span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="p">,</span> <span class="kt">uint32_t</span><span class="p">,</span> <span class="k">struct</span> <span class="n">hbq_dmabuf</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">lpfc_sli_brdrestart</span><span class="p">)</span>
		<span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">lpfc_sli_brdready</span><span class="p">)</span>
		<span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="p">,</span> <span class="kt">uint32_t</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">lpfc_handle_eratt</span><span class="p">)</span>
		<span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">lpfc_stop_port</span><span class="p">)</span>
		<span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">lpfc_hba_init_link</span><span class="p">)</span>
		<span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="p">,</span> <span class="kt">uint32_t</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">lpfc_hba_down_link</span><span class="p">)</span>
		<span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="p">,</span> <span class="kt">uint32_t</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">lpfc_selective_reset</span><span class="p">)</span>
		<span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="p">);</span>

	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">lpfc_bg_scsi_prep_dma_buf</span><span class="p">)</span>
		<span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">lpfc_scsi_buf</span> <span class="o">*</span><span class="p">);</span>
	<span class="cm">/* Add new entries here */</span>

	<span class="cm">/* SLI4 specific HBA data structure */</span>
	<span class="k">struct</span> <span class="n">lpfc_sli4_hba</span> <span class="n">sli4_hba</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">lpfc_sli</span> <span class="n">sli</span><span class="p">;</span>
	<span class="kt">uint8_t</span> <span class="n">pci_dev_grp</span><span class="p">;</span>	<span class="cm">/* lpfc PCI dev group: 0x0, 0x1, 0x2,... */</span>
	<span class="kt">uint32_t</span> <span class="n">sli_rev</span><span class="p">;</span>		<span class="cm">/* SLI2, SLI3, or SLI4 */</span>
	<span class="kt">uint32_t</span> <span class="n">sli3_options</span><span class="p">;</span>		<span class="cm">/* Mask of enabled SLI3 options */</span>
<span class="cp">#define LPFC_SLI3_HBQ_ENABLED		0x01</span>
<span class="cp">#define LPFC_SLI3_NPIV_ENABLED		0x02</span>
<span class="cp">#define LPFC_SLI3_VPORT_TEARDOWN	0x04</span>
<span class="cp">#define LPFC_SLI3_CRP_ENABLED		0x08</span>
<span class="cp">#define LPFC_SLI3_BG_ENABLED		0x20</span>
<span class="cp">#define LPFC_SLI3_DSS_ENABLED		0x40</span>
<span class="cp">#define LPFC_SLI4_PERFH_ENABLED		0x80</span>
<span class="cp">#define LPFC_SLI4_PHWQ_ENABLED		0x100</span>
	<span class="kt">uint32_t</span> <span class="n">iocb_cmd_size</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">iocb_rsp_size</span><span class="p">;</span>

	<span class="k">enum</span> <span class="n">hba_state</span> <span class="n">link_state</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">link_flag</span><span class="p">;</span>	<span class="cm">/* link state flags */</span>
<span class="cp">#define LS_LOOPBACK_MODE      0x1	</span><span class="cm">/* NPort is in Loopback mode */</span><span class="cp"></span>
					<span class="cm">/* This flag is set while issuing */</span>
					<span class="cm">/* INIT_LINK mailbox command */</span>
<span class="cp">#define LS_NPIV_FAB_SUPPORTED 0x2	</span><span class="cm">/* Fabric supports NPIV */</span><span class="cp"></span>
<span class="cp">#define LS_IGNORE_ERATT       0x4	</span><span class="cm">/* intr handler should ignore ERATT */</span><span class="cp"></span>

	<span class="kt">uint32_t</span> <span class="n">hba_flag</span><span class="p">;</span>	<span class="cm">/* hba generic flags */</span>
<span class="cp">#define HBA_ERATT_HANDLED	0x1 </span><span class="cm">/* This flag is set when eratt handled */</span><span class="cp"></span>
<span class="cp">#define DEFER_ERATT		0x2 </span><span class="cm">/* Deferred error attention in progress */</span><span class="cp"></span>
<span class="cp">#define HBA_FCOE_MODE		0x4 </span><span class="cm">/* HBA function in FCoE Mode */</span><span class="cp"></span>
<span class="cp">#define HBA_SP_QUEUE_EVT	0x8 </span><span class="cm">/* Slow-path qevt posted to worker thread*/</span><span class="cp"></span>
<span class="cp">#define HBA_POST_RECEIVE_BUFFER 0x10 </span><span class="cm">/* Rcv buffers need to be posted */</span><span class="cp"></span>
<span class="cp">#define FCP_XRI_ABORT_EVENT	0x20</span>
<span class="cp">#define ELS_XRI_ABORT_EVENT	0x40</span>
<span class="cp">#define ASYNC_EVENT		0x80</span>
<span class="cp">#define LINK_DISABLED		0x100 </span><span class="cm">/* Link disabled by user */</span><span class="cp"></span>
<span class="cp">#define FCF_TS_INPROG           0x200 </span><span class="cm">/* FCF table scan in progress */</span><span class="cp"></span>
<span class="cp">#define FCF_RR_INPROG           0x400 </span><span class="cm">/* FCF roundrobin flogi in progress */</span><span class="cp"></span>
<span class="cp">#define HBA_FIP_SUPPORT		0x800 </span><span class="cm">/* FIP support in HBA */</span><span class="cp"></span>
<span class="cp">#define HBA_AER_ENABLED		0x1000 </span><span class="cm">/* AER enabled with HBA */</span><span class="cp"></span>
<span class="cp">#define HBA_DEVLOSS_TMO         0x2000 </span><span class="cm">/* HBA in devloss timeout */</span><span class="cp"></span>
<span class="cp">#define HBA_RRQ_ACTIVE		0x4000 </span><span class="cm">/* process the rrq active list */</span><span class="cp"></span>
<span class="cp">#define HBA_FCP_IOQ_FLUSH	0x8000 </span><span class="cm">/* FCP I/O queues being flushed */</span><span class="cp"></span>
	<span class="kt">uint32_t</span> <span class="n">fcp_ring_in_use</span><span class="p">;</span> <span class="cm">/* When polling test if intr-hndlr active*/</span>
	<span class="k">struct</span> <span class="n">lpfc_dmabuf</span> <span class="n">slim2p</span><span class="p">;</span>

	<span class="n">MAILBOX_t</span> <span class="o">*</span><span class="n">mbox</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="o">*</span><span class="n">mbox_ext</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_mbox_ext_buf_ctx</span> <span class="n">mbox_ext_buf_ctx</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">ha_copy</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">_PCB</span> <span class="o">*</span><span class="n">pcb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">_IOCB</span> <span class="o">*</span><span class="n">IOCBs</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">lpfc_dmabuf</span> <span class="n">hbqslimp</span><span class="p">;</span>

	<span class="kt">uint16_t</span> <span class="n">pci_cfg_value</span><span class="p">;</span>

	<span class="kt">uint8_t</span> <span class="n">fc_linkspeed</span><span class="p">;</span>	<span class="cm">/* Link speed after last READ_LA */</span>

	<span class="kt">uint32_t</span> <span class="n">fc_eventTag</span><span class="p">;</span>	<span class="cm">/* event tag for link attention */</span>
	<span class="kt">uint32_t</span> <span class="n">link_events</span><span class="p">;</span>

	<span class="cm">/* These fields used to be binfo */</span>
	<span class="kt">uint32_t</span> <span class="n">fc_pref_DID</span><span class="p">;</span>	<span class="cm">/* preferred D_ID */</span>
	<span class="kt">uint8_t</span>  <span class="n">fc_pref_ALPA</span><span class="p">;</span>	<span class="cm">/* preferred AL_PA */</span>
	<span class="kt">uint32_t</span> <span class="n">fc_edtovResol</span><span class="p">;</span> <span class="cm">/* E_D_TOV timer resolution */</span>
	<span class="kt">uint32_t</span> <span class="n">fc_edtov</span><span class="p">;</span>	<span class="cm">/* E_D_TOV timer value */</span>
	<span class="kt">uint32_t</span> <span class="n">fc_arbtov</span><span class="p">;</span>	<span class="cm">/* ARB_TOV timer value */</span>
	<span class="kt">uint32_t</span> <span class="n">fc_ratov</span><span class="p">;</span>	<span class="cm">/* R_A_TOV timer value */</span>
	<span class="kt">uint32_t</span> <span class="n">fc_rttov</span><span class="p">;</span>	<span class="cm">/* R_T_TOV timer value */</span>
	<span class="kt">uint32_t</span> <span class="n">fc_altov</span><span class="p">;</span>	<span class="cm">/* AL_TOV timer value */</span>
	<span class="kt">uint32_t</span> <span class="n">fc_crtov</span><span class="p">;</span>	<span class="cm">/* C_R_TOV timer value */</span>
	<span class="kt">uint32_t</span> <span class="n">fc_citov</span><span class="p">;</span>	<span class="cm">/* C_I_TOV timer value */</span>

	<span class="k">struct</span> <span class="n">serv_parm</span> <span class="n">fc_fabparam</span><span class="p">;</span>	<span class="cm">/* fabric service parameters buffer */</span>
	<span class="kt">uint8_t</span> <span class="n">alpa_map</span><span class="p">[</span><span class="mi">128</span><span class="p">];</span>	<span class="cm">/* AL_PA map from READ_LA */</span>

	<span class="kt">uint32_t</span> <span class="n">lmt</span><span class="p">;</span>

	<span class="kt">uint32_t</span> <span class="n">fc_topology</span><span class="p">;</span>	<span class="cm">/* link topology, from LINK INIT */</span>

	<span class="k">struct</span> <span class="n">lpfc_stats</span> <span class="n">fc_stat</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">lpfc_nodelist</span> <span class="n">fc_fcpnodev</span><span class="p">;</span> <span class="cm">/* nodelist entry for no device */</span>
	<span class="kt">uint32_t</span> <span class="n">nport_event_cnt</span><span class="p">;</span>	<span class="cm">/* timestamp for nlplist entry */</span>

	<span class="kt">uint8_t</span>  <span class="n">wwnn</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span>
	<span class="kt">uint8_t</span>  <span class="n">wwpn</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span>
	<span class="kt">uint32_t</span> <span class="n">RandomData</span><span class="p">[</span><span class="mi">7</span><span class="p">];</span>

	<span class="cm">/* HBA Config Parameters */</span>
	<span class="kt">uint32_t</span> <span class="n">cfg_ack0</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">cfg_enable_npiv</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">cfg_enable_rrq</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">cfg_topology</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">cfg_link_speed</span><span class="p">;</span>
<span class="cp">#define LPFC_FCF_FOV 1		</span><span class="cm">/* Fast fcf failover */</span><span class="cp"></span>
<span class="cp">#define LPFC_FCF_PRIORITY 2	</span><span class="cm">/* Priority fcf failover */</span><span class="cp"></span>
	<span class="kt">uint32_t</span> <span class="n">cfg_fcf_failover_policy</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">cfg_cr_delay</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">cfg_cr_count</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">cfg_multi_ring_support</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">cfg_multi_ring_rctl</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">cfg_multi_ring_type</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">cfg_poll</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">cfg_poll_tmo</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">cfg_use_msi</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">cfg_fcp_imax</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">cfg_fcp_wq_count</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">cfg_fcp_eq_count</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">cfg_sg_seg_cnt</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">cfg_prot_sg_seg_cnt</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">cfg_sg_dma_buf_size</span><span class="p">;</span>
	<span class="kt">uint64_t</span> <span class="n">cfg_soft_wwnn</span><span class="p">;</span>
	<span class="kt">uint64_t</span> <span class="n">cfg_soft_wwpn</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">cfg_hba_queue_depth</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">cfg_enable_hba_reset</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">cfg_enable_hba_heartbeat</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">cfg_enable_bg</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">cfg_hostmem_hgp</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">cfg_log_verbose</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">cfg_aer_support</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">cfg_sriov_nr_virtfn</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">cfg_iocb_cnt</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">cfg_suppress_link_up</span><span class="p">;</span>
<span class="cp">#define LPFC_INITIALIZE_LINK              0	</span><span class="cm">/* do normal init_link mbox */</span><span class="cp"></span>
<span class="cp">#define LPFC_DELAY_INIT_LINK              1	</span><span class="cm">/* layered driver hold off */</span><span class="cp"></span>
<span class="cp">#define LPFC_DELAY_INIT_LINK_INDEFINITELY 2	</span><span class="cm">/* wait, manual intervention */</span><span class="cp"></span>
	<span class="kt">uint32_t</span> <span class="n">cfg_enable_dss</span><span class="p">;</span>
	<span class="n">lpfc_vpd_t</span> <span class="n">vpd</span><span class="p">;</span>		<span class="cm">/* vital product data */</span>

	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pcidev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span>      <span class="n">work_list</span><span class="p">;</span>
	<span class="kt">uint32_t</span>              <span class="n">work_ha</span><span class="p">;</span>      <span class="cm">/* Host Attention Bits for WT */</span>
	<span class="kt">uint32_t</span>              <span class="n">work_ha_mask</span><span class="p">;</span> <span class="cm">/* HA Bits owned by WT        */</span>
	<span class="kt">uint32_t</span>              <span class="n">work_hs</span><span class="p">;</span>      <span class="cm">/* HS stored in case of ERRAT */</span>
	<span class="kt">uint32_t</span>              <span class="n">work_status</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span> <span class="cm">/* Extra status from SLIM */</span>

	<span class="n">wait_queue_head_t</span>    <span class="n">work_waitq</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">task_struct</span>   <span class="o">*</span><span class="n">worker_thread</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">data_flags</span><span class="p">;</span>

	<span class="kt">uint32_t</span> <span class="n">hbq_in_use</span><span class="p">;</span>		<span class="cm">/* HBQs in use flag */</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">rb_pend_list</span><span class="p">;</span>  <span class="cm">/* Received buffers to be processed */</span>
	<span class="kt">uint32_t</span> <span class="n">hbq_count</span><span class="p">;</span>	        <span class="cm">/* Count of configured HBQs */</span>
	<span class="k">struct</span> <span class="n">hbq_s</span> <span class="n">hbqs</span><span class="p">[</span><span class="n">LPFC_MAX_HBQS</span><span class="p">];</span> <span class="cm">/* local copy of hbq indicies  */</span>

	<span class="kt">uint32_t</span> <span class="n">fcp_qidx</span><span class="p">;</span>		<span class="cm">/* next work queue to post work to */</span>

	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pci_bar0_map</span><span class="p">;</span>     <span class="cm">/* Physical address for PCI BAR0 */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pci_bar1_map</span><span class="p">;</span>     <span class="cm">/* Physical address for PCI BAR1 */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pci_bar2_map</span><span class="p">;</span>     <span class="cm">/* Physical address for PCI BAR2 */</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">slim_memmap_p</span><span class="p">;</span>	<span class="cm">/* Kernel memory mapped address for</span>
<span class="cm">					   PCI BAR0 */</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">ctrl_regs_memmap_p</span><span class="p">;</span><span class="cm">/* Kernel memory mapped address for</span>
<span class="cm">					    PCI BAR2 */</span>

	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">MBslimaddr</span><span class="p">;</span>	<span class="cm">/* virtual address for mbox cmds */</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">HAregaddr</span><span class="p">;</span>	<span class="cm">/* virtual address for host attn reg */</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">CAregaddr</span><span class="p">;</span>	<span class="cm">/* virtual address for chip attn reg */</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">HSregaddr</span><span class="p">;</span>	<span class="cm">/* virtual address for host status</span>
<span class="cm">					   reg */</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">HCregaddr</span><span class="p">;</span>	<span class="cm">/* virtual address for host ctl reg */</span>

	<span class="k">struct</span> <span class="n">lpfc_hgp</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">host_gp</span><span class="p">;</span> <span class="cm">/* Host side get/put pointers */</span>
	<span class="k">struct</span> <span class="n">lpfc_pgp</span>   <span class="o">*</span><span class="n">port_gp</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">__iomem</span>  <span class="o">*</span><span class="n">hbq_put</span><span class="p">;</span>     <span class="cm">/* Address in SLIM to HBQ put ptrs */</span>
	<span class="kt">uint32_t</span>          <span class="o">*</span><span class="n">hbq_get</span><span class="p">;</span>     <span class="cm">/* Host mem address of HBQ get ptrs */</span>

	<span class="kt">int</span> <span class="n">brd_no</span><span class="p">;</span>			<span class="cm">/* FC board number */</span>
	<span class="kt">char</span> <span class="n">SerialNumber</span><span class="p">[</span><span class="mi">32</span><span class="p">];</span>		<span class="cm">/* adapter Serial Number */</span>
	<span class="kt">char</span> <span class="n">OptionROMVersion</span><span class="p">[</span><span class="mi">32</span><span class="p">];</span>	<span class="cm">/* adapter BIOS / Fcode version */</span>
	<span class="kt">char</span> <span class="n">ModelDesc</span><span class="p">[</span><span class="mi">256</span><span class="p">];</span>		<span class="cm">/* Model Description */</span>
	<span class="kt">char</span> <span class="n">ModelName</span><span class="p">[</span><span class="mi">80</span><span class="p">];</span>		<span class="cm">/* Model Name */</span>
	<span class="kt">char</span> <span class="n">ProgramType</span><span class="p">[</span><span class="mi">256</span><span class="p">];</span>		<span class="cm">/* Program Type */</span>
	<span class="kt">char</span> <span class="n">Port</span><span class="p">[</span><span class="mi">20</span><span class="p">];</span>			<span class="cm">/* Port No */</span>
	<span class="kt">uint8_t</span> <span class="n">vpd_flag</span><span class="p">;</span>               <span class="cm">/* VPD data flag */</span>

<span class="cp">#define VPD_MODEL_DESC      0x1         </span><span class="cm">/* valid vpd model description */</span><span class="cp"></span>
<span class="cp">#define VPD_MODEL_NAME      0x2         </span><span class="cm">/* valid vpd model name */</span><span class="cp"></span>
<span class="cp">#define VPD_PROGRAM_TYPE    0x4         </span><span class="cm">/* valid vpd program type */</span><span class="cp"></span>
<span class="cp">#define VPD_PORT            0x8         </span><span class="cm">/* valid vpd port data */</span><span class="cp"></span>
<span class="cp">#define VPD_MASK            0xf         </span><span class="cm">/* mask for any vpd data */</span><span class="cp"></span>

	<span class="kt">uint8_t</span> <span class="n">soft_wwn_enable</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">timer_list</span> <span class="n">fcp_poll_timer</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">timer_list</span> <span class="n">eratt_poll</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * stat  counters</span>
<span class="cm">	 */</span>
	<span class="kt">uint64_t</span> <span class="n">fc4InputRequests</span><span class="p">;</span>
	<span class="kt">uint64_t</span> <span class="n">fc4OutputRequests</span><span class="p">;</span>
	<span class="kt">uint64_t</span> <span class="n">fc4ControlRequests</span><span class="p">;</span>
	<span class="kt">uint64_t</span> <span class="n">bg_guard_err_cnt</span><span class="p">;</span>
	<span class="kt">uint64_t</span> <span class="n">bg_apptag_err_cnt</span><span class="p">;</span>
	<span class="kt">uint64_t</span> <span class="n">bg_reftag_err_cnt</span><span class="p">;</span>

	<span class="cm">/* fastpath list. */</span>
	<span class="n">spinlock_t</span> <span class="n">scsi_buf_list_lock</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">lpfc_scsi_buf_list</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">total_scsi_bufs</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">lpfc_iocb_list</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">total_iocbq_bufs</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">active_rrq_list</span><span class="p">;</span>
	<span class="n">spinlock_t</span> <span class="n">hbalock</span><span class="p">;</span>

	<span class="cm">/* pci_mem_pools */</span>
	<span class="k">struct</span> <span class="n">pci_pool</span> <span class="o">*</span><span class="n">lpfc_scsi_dma_buf_pool</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pci_pool</span> <span class="o">*</span><span class="n">lpfc_mbuf_pool</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pci_pool</span> <span class="o">*</span><span class="n">lpfc_hrb_pool</span><span class="p">;</span>	<span class="cm">/* header receive buffer pool */</span>
	<span class="k">struct</span> <span class="n">pci_pool</span> <span class="o">*</span><span class="n">lpfc_drb_pool</span><span class="p">;</span> <span class="cm">/* data receive buffer pool */</span>
	<span class="k">struct</span> <span class="n">pci_pool</span> <span class="o">*</span><span class="n">lpfc_hbq_pool</span><span class="p">;</span>	<span class="cm">/* SLI3 hbq buffer pool */</span>
	<span class="k">struct</span> <span class="n">lpfc_dma_pool</span> <span class="n">lpfc_mbuf_safety_pool</span><span class="p">;</span>

	<span class="n">mempool_t</span> <span class="o">*</span><span class="n">mbox_mem_pool</span><span class="p">;</span>
	<span class="n">mempool_t</span> <span class="o">*</span><span class="n">nlp_mem_pool</span><span class="p">;</span>
	<span class="n">mempool_t</span> <span class="o">*</span><span class="n">rrq_pool</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">fc_host_statistics</span> <span class="n">link_stats</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">intr_type_t</span> <span class="n">intr_type</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">intr_mode</span><span class="p">;</span>
<span class="cp">#define LPFC_INTR_ERROR	0xFFFFFFFF</span>
	<span class="k">struct</span> <span class="n">msix_entry</span> <span class="n">msix_entries</span><span class="p">[</span><span class="n">LPFC_MSIX_VECTORS</span><span class="p">];</span>

	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">port_list</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="n">pport</span><span class="p">;</span>	<span class="cm">/* physical lpfc_vport pointer */</span>
	<span class="kt">uint16_t</span> <span class="n">max_vpi</span><span class="p">;</span>		<span class="cm">/* Maximum virtual nports */</span>
<span class="cp">#define LPFC_MAX_VPI 0xFFFF		</span><span class="cm">/* Max number of VPI supported */</span><span class="cp"></span>
	<span class="kt">uint16_t</span> <span class="n">max_vports</span><span class="p">;</span>            <span class="cm">/*</span>
<span class="cm">					 * For IOV HBAs max_vpi can change</span>
<span class="cm">					 * after a reset. max_vports is max</span>
<span class="cm">					 * number of vports present. This can</span>
<span class="cm">					 * be greater than max_vpi.</span>
<span class="cm">					 */</span>
	<span class="kt">uint16_t</span> <span class="n">vpi_base</span><span class="p">;</span>
	<span class="kt">uint16_t</span> <span class="n">vfi_base</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">vpi_bmask</span><span class="p">;</span>	<span class="cm">/* vpi allocation table */</span>
	<span class="kt">uint16_t</span> <span class="o">*</span><span class="n">vpi_ids</span><span class="p">;</span>
	<span class="kt">uint16_t</span> <span class="n">vpi_count</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">lpfc_vpi_blk_list</span><span class="p">;</span>

	<span class="cm">/* Data structure used by fabric iocb scheduler */</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">fabric_iocb_list</span><span class="p">;</span>
	<span class="n">atomic_t</span> <span class="n">fabric_iocb_count</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">timer_list</span> <span class="n">fabric_block_timer</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">bit_flags</span><span class="p">;</span>
<span class="cp">#define	FABRIC_COMANDS_BLOCKED	0</span>
	<span class="n">atomic_t</span> <span class="n">num_rsrc_err</span><span class="p">;</span>
	<span class="n">atomic_t</span> <span class="n">num_cmd_success</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">last_rsrc_error_time</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">last_ramp_down_time</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">last_ramp_up_time</span><span class="p">;</span>
<span class="cp">#ifdef CONFIG_SCSI_LPFC_DEBUG_FS</span>
	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">hba_debugfs_root</span><span class="p">;</span>
	<span class="n">atomic_t</span> <span class="n">debugfs_vport_count</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">debug_hbqinfo</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">debug_dumpHostSlim</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">debug_dumpHBASlim</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">debug_dumpData</span><span class="p">;</span>   <span class="cm">/* BlockGuard BPL */</span>
	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">debug_dumpDif</span><span class="p">;</span>    <span class="cm">/* BlockGuard BPL */</span>
	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">debug_InjErrLBA</span><span class="p">;</span>  <span class="cm">/* LBA to inject errors at */</span>
	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">debug_InjErrNPortID</span><span class="p">;</span>  <span class="cm">/* NPortID to inject errors at */</span>
	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">debug_InjErrWWPN</span><span class="p">;</span>  <span class="cm">/* WWPN to inject errors at */</span>
	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">debug_writeGuard</span><span class="p">;</span> <span class="cm">/* inject write guard_tag errors */</span>
	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">debug_writeApp</span><span class="p">;</span>   <span class="cm">/* inject write app_tag errors */</span>
	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">debug_writeRef</span><span class="p">;</span>   <span class="cm">/* inject write ref_tag errors */</span>
	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">debug_readGuard</span><span class="p">;</span>  <span class="cm">/* inject read guard_tag errors */</span>
	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">debug_readApp</span><span class="p">;</span>    <span class="cm">/* inject read app_tag errors */</span>
	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">debug_readRef</span><span class="p">;</span>    <span class="cm">/* inject read ref_tag errors */</span>

	<span class="cm">/* T10 DIF error injection */</span>
	<span class="kt">uint32_t</span> <span class="n">lpfc_injerr_wgrd_cnt</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">lpfc_injerr_wapp_cnt</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">lpfc_injerr_wref_cnt</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">lpfc_injerr_rgrd_cnt</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">lpfc_injerr_rapp_cnt</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">lpfc_injerr_rref_cnt</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">lpfc_injerr_nportid</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_name</span> <span class="n">lpfc_injerr_wwpn</span><span class="p">;</span>
	<span class="n">sector_t</span> <span class="n">lpfc_injerr_lba</span><span class="p">;</span>
<span class="cp">#define LPFC_INJERR_LBA_OFF	(sector_t)(-1)</span>

	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">debug_slow_ring_trc</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_debugfs_trc</span> <span class="o">*</span><span class="n">slow_ring_trc</span><span class="p">;</span>
	<span class="n">atomic_t</span> <span class="n">slow_ring_trc_cnt</span><span class="p">;</span>
	<span class="cm">/* iDiag debugfs sub-directory */</span>
	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">idiag_root</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">idiag_pci_cfg</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">idiag_bar_acc</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">idiag_que_info</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">idiag_que_acc</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">idiag_drb_acc</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">idiag_ctl_acc</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">idiag_mbx_acc</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">idiag_ext_acc</span><span class="p">;</span>
<span class="cp">#endif</span>

	<span class="cm">/* Used for deferred freeing of ELS data buffers */</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">elsbuf</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">elsbuf_cnt</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">elsbuf_prev_cnt</span><span class="p">;</span>

	<span class="kt">uint8_t</span> <span class="n">temp_sensor_support</span><span class="p">;</span>
	<span class="cm">/* Fields used for heart beat. */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">last_completion_time</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">skipped_hb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">timer_list</span> <span class="n">hb_tmofunc</span><span class="p">;</span>
	<span class="kt">uint8_t</span> <span class="n">hb_outstanding</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">timer_list</span> <span class="n">rrq_tmr</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">hba_temp_state</span> <span class="n">over_temp_state</span><span class="p">;</span>
	<span class="cm">/* ndlp reference management */</span>
	<span class="n">spinlock_t</span> <span class="n">ndlp_lock</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * Following bit will be set for all buffer tags which are not</span>
<span class="cm">	 * associated with any HBQ.</span>
<span class="cm">	 */</span>
<span class="cp">#define QUE_BUFTAG_BIT  (1&lt;&lt;31)</span>
	<span class="kt">uint32_t</span> <span class="n">buffer_tag_count</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">wait_4_mlo_maint_flg</span><span class="p">;</span>
	<span class="n">wait_queue_head_t</span> <span class="n">wait_4_mlo_m_q</span><span class="p">;</span>
	<span class="cm">/* data structure used for latency data collection */</span>
<span class="cp">#define LPFC_NO_BUCKET	   0</span>
<span class="cp">#define LPFC_LINEAR_BUCKET 1</span>
<span class="cp">#define LPFC_POWER2_BUCKET 2</span>
	<span class="kt">uint8_t</span>  <span class="n">bucket_type</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">bucket_base</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">bucket_step</span><span class="p">;</span>

<span class="cm">/* Maximum number of events that can be outstanding at any time*/</span>
<span class="cp">#define LPFC_MAX_EVT_COUNT 512</span>
	<span class="n">atomic_t</span> <span class="n">fast_event_count</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">fcoe_eventtag</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">fcoe_eventtag_at_fcf_scan</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">fcoe_cvl_eventtag</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">fcoe_cvl_eventtag_attn</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_fcf</span> <span class="n">fcf</span><span class="p">;</span>
	<span class="kt">uint8_t</span> <span class="n">fc_map</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
	<span class="kt">uint8_t</span> <span class="n">valid_vlan</span><span class="p">;</span>
	<span class="kt">uint16_t</span> <span class="n">vlan_id</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">fcf_conn_rec_list</span><span class="p">;</span>

	<span class="n">spinlock_t</span> <span class="n">ct_ev_lock</span><span class="p">;</span> <span class="cm">/* synchronize access to ct_ev_waiters */</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">ct_ev_waiters</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">unsol_rcv_ct_ctx</span> <span class="n">ct_ctx</span><span class="p">[</span><span class="mi">64</span><span class="p">];</span>
	<span class="kt">uint32_t</span> <span class="n">ctx_idx</span><span class="p">;</span>

	<span class="kt">uint8_t</span> <span class="n">menlo_flag</span><span class="p">;</span>	<span class="cm">/* menlo generic flags */</span>
<span class="cp">#define HBA_MENLO_SUPPORT	0x1 </span><span class="cm">/* HBA supports menlo commands */</span><span class="cp"></span>
	<span class="kt">uint32_t</span> <span class="n">iocb_cnt</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">iocb_max</span><span class="p">;</span>
	<span class="n">atomic_t</span> <span class="n">sdev_cnt</span><span class="p">;</span>
	<span class="kt">uint8_t</span> <span class="n">fips_spec_rev</span><span class="p">;</span>
	<span class="kt">uint8_t</span> <span class="n">fips_level</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span>
<span class="nf">lpfc_shost_from_vport</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="n">vport</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">container_of</span><span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span> <span class="n">vport</span><span class="p">,</span> <span class="k">struct</span> <span class="n">Scsi_Host</span><span class="p">,</span> <span class="n">hostdata</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">lpfc_set_loopback_flag</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">cfg_topology</span> <span class="o">==</span> <span class="n">FLAGS_LOCAL_LB</span><span class="p">)</span>
		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">link_flag</span> <span class="o">|=</span> <span class="n">LS_LOOPBACK_MODE</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">link_flag</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">LS_LOOPBACK_MODE</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span>
<span class="nf">lpfc_is_link_up</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span>  <span class="n">phba</span><span class="o">-&gt;</span><span class="n">link_state</span> <span class="o">==</span> <span class="n">LPFC_LINK_UP</span> <span class="o">||</span>
		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">link_state</span> <span class="o">==</span> <span class="n">LPFC_CLEAR_LA</span> <span class="o">||</span>
		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">link_state</span> <span class="o">==</span> <span class="n">LPFC_HBA_READY</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">lpfc_worker_wake_up</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Set the lpfc data pending flag */</span>
	<span class="n">set_bit</span><span class="p">(</span><span class="n">LPFC_DATA_READY</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">data_flags</span><span class="p">);</span>

	<span class="cm">/* Wake up worker thread */</span>
	<span class="n">wake_up</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">work_waitq</span><span class="p">);</span>
	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span>
<span class="nf">lpfc_readl</span><span class="p">(</span><span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">addr</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">uint32_t</span> <span class="n">temp</span><span class="p">;</span>
	<span class="n">temp</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="n">addr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">temp</span> <span class="o">==</span> <span class="mh">0xffffffff</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="o">*</span><span class="n">data</span> <span class="o">=</span> <span class="n">temp</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span>
<span class="nf">lpfc_sli_read_hs</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * There was a link/board error. Read the status register to retrieve</span>
<span class="cm">	 * the error event and process it.</span>
<span class="cm">	 */</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli</span><span class="p">.</span><span class="n">slistat</span><span class="p">.</span><span class="n">err_attn_event</span><span class="o">++</span><span class="p">;</span>

	<span class="cm">/* Save status info and check for unplug error */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">lpfc_readl</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">HSregaddr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">work_hs</span><span class="p">)</span> <span class="o">||</span>
		<span class="n">lpfc_readl</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">MBslimaddr</span> <span class="o">+</span> <span class="mh">0xa8</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">work_status</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">||</span>
		<span class="n">lpfc_readl</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">MBslimaddr</span> <span class="o">+</span> <span class="mh">0xac</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">work_status</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span> <span class="p">{</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Clear chip Host Attention error bit */</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">HA_ERATT</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">HAregaddr</span><span class="p">);</span>
	<span class="n">readl</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">HAregaddr</span><span class="p">);</span> <span class="cm">/* flush */</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">pport</span><span class="o">-&gt;</span><span class="n">stopped</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
