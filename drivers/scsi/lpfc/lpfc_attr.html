<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › scsi › lpfc › lpfc_attr.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>lpfc_attr.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*******************************************************************</span>
<span class="cm"> * This file is part of the Emulex Linux Device Driver for         *</span>
<span class="cm"> * Fibre Channel Host Bus Adapters.                                *</span>
<span class="cm"> * Copyright (C) 2004-2012 Emulex.  All rights reserved.           *</span>
<span class="cm"> * EMULEX and SLI are trademarks of Emulex.                        *</span>
<span class="cm"> * www.emulex.com                                                  *</span>
<span class="cm"> * Portions Copyright (C) 2004-2005 Christoph Hellwig              *</span>
<span class="cm"> *                                                                 *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or   *</span>
<span class="cm"> * modify it under the terms of version 2 of the GNU General       *</span>
<span class="cm"> * Public License as published by the Free Software Foundation.    *</span>
<span class="cm"> * This program is distributed in the hope that it will be useful. *</span>
<span class="cm"> * ALL EXPRESS OR IMPLIED CONDITIONS, REPRESENTATIONS AND          *</span>
<span class="cm"> * WARRANTIES, INCLUDING ANY IMPLIED WARRANTY OF MERCHANTABILITY,  *</span>
<span class="cm"> * FITNESS FOR A PARTICULAR PURPOSE, OR NON-INFRINGEMENT, ARE      *</span>
<span class="cm"> * DISCLAIMED, EXCEPT TO THE EXTENT THAT SUCH DISCLAIMERS ARE HELD *</span>
<span class="cm"> * TO BE LEGALLY INVALID.  See the GNU General Public License for  *</span>
<span class="cm"> * more details, a copy of which can be found in the file COPYING  *</span>
<span class="cm"> * included with this package.                                     *</span>
<span class="cm"> *******************************************************************/</span>

<span class="cp">#include &lt;linux/ctype.h&gt;</span>
<span class="cp">#include &lt;linux/delay.h&gt;</span>
<span class="cp">#include &lt;linux/pci.h&gt;</span>
<span class="cp">#include &lt;linux/interrupt.h&gt;</span>
<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/aer.h&gt;</span>
<span class="cp">#include &lt;linux/gfp.h&gt;</span>
<span class="cp">#include &lt;linux/kernel.h&gt;</span>

<span class="cp">#include &lt;scsi/scsi.h&gt;</span>
<span class="cp">#include &lt;scsi/scsi_device.h&gt;</span>
<span class="cp">#include &lt;scsi/scsi_host.h&gt;</span>
<span class="cp">#include &lt;scsi/scsi_tcq.h&gt;</span>
<span class="cp">#include &lt;scsi/scsi_transport_fc.h&gt;</span>
<span class="cp">#include &lt;scsi/fc/fc_fs.h&gt;</span>

<span class="cp">#include &quot;lpfc_hw4.h&quot;</span>
<span class="cp">#include &quot;lpfc_hw.h&quot;</span>
<span class="cp">#include &quot;lpfc_sli.h&quot;</span>
<span class="cp">#include &quot;lpfc_sli4.h&quot;</span>
<span class="cp">#include &quot;lpfc_nl.h&quot;</span>
<span class="cp">#include &quot;lpfc_disc.h&quot;</span>
<span class="cp">#include &quot;lpfc_scsi.h&quot;</span>
<span class="cp">#include &quot;lpfc.h&quot;</span>
<span class="cp">#include &quot;lpfc_logmsg.h&quot;</span>
<span class="cp">#include &quot;lpfc_version.h&quot;</span>
<span class="cp">#include &quot;lpfc_compat.h&quot;</span>
<span class="cp">#include &quot;lpfc_crtn.h&quot;</span>
<span class="cp">#include &quot;lpfc_vport.h&quot;</span>

<span class="cp">#define LPFC_DEF_DEVLOSS_TMO 30</span>
<span class="cp">#define LPFC_MIN_DEVLOSS_TMO 1</span>
<span class="cp">#define LPFC_MAX_DEVLOSS_TMO 255</span>

<span class="cm">/*</span>
<span class="cm"> * Write key size should be multiple of 4. If write key is changed</span>
<span class="cm"> * make sure that library write key is also changed.</span>
<span class="cm"> */</span>
<span class="cp">#define LPFC_REG_WRITE_KEY_SIZE	4</span>
<span class="cp">#define LPFC_REG_WRITE_KEY	&quot;EMLX&quot;</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_jedec_to_ascii - Hex to ascii convertor according to JEDEC rules</span>
<span class="cm"> * @incr: integer to convert.</span>
<span class="cm"> * @hdw: ascii string holding converted integer plus a string terminator.</span>
<span class="cm"> *</span>
<span class="cm"> * Description:</span>
<span class="cm"> * JEDEC Joint Electron Device Engineering Council.</span>
<span class="cm"> * Convert a 32 bit integer composed of 8 nibbles into an 8 byte ascii</span>
<span class="cm"> * character string. The string is then terminated with a NULL in byte 9.</span>
<span class="cm"> * Hex 0-9 becomes ascii &#39;0&#39; to &#39;9&#39;.</span>
<span class="cm"> * Hex a-f becomes ascii &#39;=&#39; to &#39;B&#39; capital B.</span>
<span class="cm"> *</span>
<span class="cm"> * Notes:</span>
<span class="cm"> * Coded for 32 bit integers only.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">lpfc_jedec_to_ascii</span><span class="p">(</span><span class="kt">int</span> <span class="n">incr</span><span class="p">,</span> <span class="kt">char</span> <span class="n">hdw</span><span class="p">[])</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">8</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">j</span> <span class="o">=</span> <span class="p">(</span><span class="n">incr</span> <span class="o">&amp;</span> <span class="mh">0xf</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">j</span> <span class="o">&lt;=</span> <span class="mi">9</span><span class="p">)</span>
			<span class="n">hdw</span><span class="p">[</span><span class="mi">7</span> <span class="o">-</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x30</span> <span class="o">+</span>  <span class="n">j</span><span class="p">;</span>
		 <span class="k">else</span>
			<span class="n">hdw</span><span class="p">[</span><span class="mi">7</span> <span class="o">-</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x61</span> <span class="o">+</span> <span class="n">j</span> <span class="o">-</span> <span class="mi">10</span><span class="p">;</span>
		<span class="n">incr</span> <span class="o">=</span> <span class="p">(</span><span class="n">incr</span> <span class="o">&gt;&gt;</span> <span class="mi">4</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">hdw</span><span class="p">[</span><span class="mi">8</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_drvr_version_show - Return the Emulex driver string with version number</span>
<span class="cm"> * @dev: class unused variable.</span>
<span class="cm"> * @attr: device attribute, not used.</span>
<span class="cm"> * @buf: on return contains the module description text.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns: size of formatted string.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">ssize_t</span>
<span class="nf">lpfc_drvr_version_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span>
		       <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">snprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">PAGE_SIZE</span><span class="p">,</span> <span class="n">LPFC_MODULE_DESC</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_enable_fip_show - Return the fip mode of the HBA</span>
<span class="cm"> * @dev: class unused variable.</span>
<span class="cm"> * @attr: device attribute, not used.</span>
<span class="cm"> * @buf: on return contains the module description text.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns: size of formatted string.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">ssize_t</span>
<span class="nf">lpfc_enable_fip_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span>
		       <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span> <span class="o">=</span> <span class="n">class_to_shost</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="n">vport</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="p">)</span> <span class="n">shost</span><span class="o">-&gt;</span><span class="n">hostdata</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_hba</span>   <span class="o">*</span><span class="n">phba</span> <span class="o">=</span> <span class="n">vport</span><span class="o">-&gt;</span><span class="n">phba</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hba_flag</span> <span class="o">&amp;</span> <span class="n">HBA_FIP_SUPPORT</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">snprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">PAGE_SIZE</span><span class="p">,</span> <span class="s">&quot;1</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="k">return</span> <span class="n">snprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">PAGE_SIZE</span><span class="p">,</span> <span class="s">&quot;0</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span>
<span class="nf">lpfc_bg_info_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span>
		  <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span> <span class="o">=</span> <span class="n">class_to_shost</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="n">vport</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="p">)</span> <span class="n">shost</span><span class="o">-&gt;</span><span class="n">hostdata</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_hba</span>   <span class="o">*</span><span class="n">phba</span> <span class="o">=</span> <span class="n">vport</span><span class="o">-&gt;</span><span class="n">phba</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">cfg_enable_bg</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli3_options</span> <span class="o">&amp;</span> <span class="n">LPFC_SLI3_BG_ENABLED</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">snprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">PAGE_SIZE</span><span class="p">,</span> <span class="s">&quot;BlockGuard Enabled</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="k">return</span> <span class="n">snprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">PAGE_SIZE</span><span class="p">,</span>
					<span class="s">&quot;BlockGuard Not Supported</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">else</span>
			<span class="k">return</span> <span class="n">snprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">PAGE_SIZE</span><span class="p">,</span>
					<span class="s">&quot;BlockGuard Disabled</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span>
<span class="nf">lpfc_bg_guard_err_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span>
		       <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span> <span class="o">=</span> <span class="n">class_to_shost</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="n">vport</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="p">)</span> <span class="n">shost</span><span class="o">-&gt;</span><span class="n">hostdata</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_hba</span>   <span class="o">*</span><span class="n">phba</span> <span class="o">=</span> <span class="n">vport</span><span class="o">-&gt;</span><span class="n">phba</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">snprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">PAGE_SIZE</span><span class="p">,</span> <span class="s">&quot;%llu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">bg_guard_err_cnt</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span>
<span class="nf">lpfc_bg_apptag_err_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span>
			<span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span> <span class="o">=</span> <span class="n">class_to_shost</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="n">vport</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="p">)</span> <span class="n">shost</span><span class="o">-&gt;</span><span class="n">hostdata</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_hba</span>   <span class="o">*</span><span class="n">phba</span> <span class="o">=</span> <span class="n">vport</span><span class="o">-&gt;</span><span class="n">phba</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">snprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">PAGE_SIZE</span><span class="p">,</span> <span class="s">&quot;%llu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">bg_apptag_err_cnt</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span>
<span class="nf">lpfc_bg_reftag_err_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span>
			<span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span> <span class="o">=</span> <span class="n">class_to_shost</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="n">vport</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="p">)</span> <span class="n">shost</span><span class="o">-&gt;</span><span class="n">hostdata</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_hba</span>   <span class="o">*</span><span class="n">phba</span> <span class="o">=</span> <span class="n">vport</span><span class="o">-&gt;</span><span class="n">phba</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">snprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">PAGE_SIZE</span><span class="p">,</span> <span class="s">&quot;%llu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">bg_reftag_err_cnt</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_info_show - Return some pci info about the host in ascii</span>
<span class="cm"> * @dev: class converted to a Scsi_host structure.</span>
<span class="cm"> * @attr: device attribute, not used.</span>
<span class="cm"> * @buf: on return contains the formatted text from lpfc_info().</span>
<span class="cm"> *</span>
<span class="cm"> * Returns: size of formatted string.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">ssize_t</span>
<span class="nf">lpfc_info_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span>
	       <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">host</span> <span class="o">=</span> <span class="n">class_to_shost</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">snprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">PAGE_SIZE</span><span class="p">,</span> <span class="s">&quot;%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="n">lpfc_info</span><span class="p">(</span><span class="n">host</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_serialnum_show - Return the hba serial number in ascii</span>
<span class="cm"> * @dev: class converted to a Scsi_host structure.</span>
<span class="cm"> * @attr: device attribute, not used.</span>
<span class="cm"> * @buf: on return contains the formatted text serial number.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns: size of formatted string.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">ssize_t</span>
<span class="nf">lpfc_serialnum_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span>
		    <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span>  <span class="o">*</span><span class="n">shost</span> <span class="o">=</span> <span class="n">class_to_shost</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="n">vport</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="p">)</span> <span class="n">shost</span><span class="o">-&gt;</span><span class="n">hostdata</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_hba</span>   <span class="o">*</span><span class="n">phba</span> <span class="o">=</span> <span class="n">vport</span><span class="o">-&gt;</span><span class="n">phba</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">snprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">PAGE_SIZE</span><span class="p">,</span> <span class="s">&quot;%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">SerialNumber</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_temp_sensor_show - Return the temperature sensor level</span>
<span class="cm"> * @dev: class converted to a Scsi_host structure.</span>
<span class="cm"> * @attr: device attribute, not used.</span>
<span class="cm"> * @buf: on return contains the formatted support level.</span>
<span class="cm"> *</span>
<span class="cm"> * Description:</span>
<span class="cm"> * Returns a number indicating the temperature sensor level currently</span>
<span class="cm"> * supported, zero or one in ascii.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns: size of formatted string.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">ssize_t</span>
<span class="nf">lpfc_temp_sensor_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span>
		      <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span> <span class="o">=</span> <span class="n">class_to_shost</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="n">vport</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="p">)</span> <span class="n">shost</span><span class="o">-&gt;</span><span class="n">hostdata</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_hba</span>   <span class="o">*</span><span class="n">phba</span> <span class="o">=</span> <span class="n">vport</span><span class="o">-&gt;</span><span class="n">phba</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">snprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">PAGE_SIZE</span><span class="p">,</span> <span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">temp_sensor_support</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_modeldesc_show - Return the model description of the hba</span>
<span class="cm"> * @dev: class converted to a Scsi_host structure.</span>
<span class="cm"> * @attr: device attribute, not used.</span>
<span class="cm"> * @buf: on return contains the scsi vpd model description.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns: size of formatted string.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">ssize_t</span>
<span class="nf">lpfc_modeldesc_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span>
		    <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span>  <span class="o">*</span><span class="n">shost</span> <span class="o">=</span> <span class="n">class_to_shost</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="n">vport</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="p">)</span> <span class="n">shost</span><span class="o">-&gt;</span><span class="n">hostdata</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_hba</span>   <span class="o">*</span><span class="n">phba</span> <span class="o">=</span> <span class="n">vport</span><span class="o">-&gt;</span><span class="n">phba</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">snprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">PAGE_SIZE</span><span class="p">,</span> <span class="s">&quot;%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">ModelDesc</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_modelname_show - Return the model name of the hba</span>
<span class="cm"> * @dev: class converted to a Scsi_host structure.</span>
<span class="cm"> * @attr: device attribute, not used.</span>
<span class="cm"> * @buf: on return contains the scsi vpd model name.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns: size of formatted string.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">ssize_t</span>
<span class="nf">lpfc_modelname_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span>
		    <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span>  <span class="o">*</span><span class="n">shost</span> <span class="o">=</span> <span class="n">class_to_shost</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="n">vport</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="p">)</span> <span class="n">shost</span><span class="o">-&gt;</span><span class="n">hostdata</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_hba</span>   <span class="o">*</span><span class="n">phba</span> <span class="o">=</span> <span class="n">vport</span><span class="o">-&gt;</span><span class="n">phba</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">snprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">PAGE_SIZE</span><span class="p">,</span> <span class="s">&quot;%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">ModelName</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_programtype_show - Return the program type of the hba</span>
<span class="cm"> * @dev: class converted to a Scsi_host structure.</span>
<span class="cm"> * @attr: device attribute, not used.</span>
<span class="cm"> * @buf: on return contains the scsi vpd program type.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns: size of formatted string.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">ssize_t</span>
<span class="nf">lpfc_programtype_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span>
		      <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span>  <span class="o">*</span><span class="n">shost</span> <span class="o">=</span> <span class="n">class_to_shost</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="n">vport</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="p">)</span> <span class="n">shost</span><span class="o">-&gt;</span><span class="n">hostdata</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_hba</span>   <span class="o">*</span><span class="n">phba</span> <span class="o">=</span> <span class="n">vport</span><span class="o">-&gt;</span><span class="n">phba</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">snprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">PAGE_SIZE</span><span class="p">,</span> <span class="s">&quot;%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">ProgramType</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_mlomgmt_show - Return the Menlo Maintenance sli flag</span>
<span class="cm"> * @dev: class converted to a Scsi_host structure.</span>
<span class="cm"> * @attr: device attribute, not used.</span>
<span class="cm"> * @buf: on return contains the Menlo Maintenance sli flag.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns: size of formatted string.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">ssize_t</span>
<span class="nf">lpfc_mlomgmt_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span>  <span class="o">*</span><span class="n">shost</span> <span class="o">=</span> <span class="n">class_to_shost</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="n">vport</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="p">)</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">hostdata</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_hba</span>   <span class="o">*</span><span class="n">phba</span> <span class="o">=</span> <span class="n">vport</span><span class="o">-&gt;</span><span class="n">phba</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">snprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">PAGE_SIZE</span><span class="p">,</span> <span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli</span><span class="p">.</span><span class="n">sli_flag</span> <span class="o">&amp;</span> <span class="n">LPFC_MENLO_MAINT</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_vportnum_show - Return the port number in ascii of the hba</span>
<span class="cm"> * @dev: class converted to a Scsi_host structure.</span>
<span class="cm"> * @attr: device attribute, not used.</span>
<span class="cm"> * @buf: on return contains scsi vpd program type.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns: size of formatted string.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">ssize_t</span>
<span class="nf">lpfc_vportnum_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span>
		   <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span>  <span class="o">*</span><span class="n">shost</span> <span class="o">=</span> <span class="n">class_to_shost</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="n">vport</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="p">)</span> <span class="n">shost</span><span class="o">-&gt;</span><span class="n">hostdata</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_hba</span>   <span class="o">*</span><span class="n">phba</span> <span class="o">=</span> <span class="n">vport</span><span class="o">-&gt;</span><span class="n">phba</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">snprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">PAGE_SIZE</span><span class="p">,</span> <span class="s">&quot;%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">Port</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_fwrev_show - Return the firmware rev running in the hba</span>
<span class="cm"> * @dev: class converted to a Scsi_host structure.</span>
<span class="cm"> * @attr: device attribute, not used.</span>
<span class="cm"> * @buf: on return contains the scsi vpd program type.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns: size of formatted string.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">ssize_t</span>
<span class="nf">lpfc_fwrev_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span>
		<span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span>  <span class="o">*</span><span class="n">shost</span> <span class="o">=</span> <span class="n">class_to_shost</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="n">vport</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="p">)</span> <span class="n">shost</span><span class="o">-&gt;</span><span class="n">hostdata</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_hba</span>   <span class="o">*</span><span class="n">phba</span> <span class="o">=</span> <span class="n">vport</span><span class="o">-&gt;</span><span class="n">phba</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">if_type</span><span class="p">;</span>
	<span class="kt">uint8_t</span> <span class="n">sli_family</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">fwrev</span><span class="p">[</span><span class="n">FW_REV_STR_SIZE</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">len</span><span class="p">;</span>

	<span class="n">lpfc_decode_firmware_rev</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">fwrev</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">if_type</span> <span class="o">=</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">pc_sli4_params</span><span class="p">.</span><span class="n">if_type</span><span class="p">;</span>
	<span class="n">sli_family</span> <span class="o">=</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">pc_sli4_params</span><span class="p">.</span><span class="n">sli_family</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli_rev</span> <span class="o">&lt;</span> <span class="n">LPFC_SLI_REV4</span><span class="p">)</span>
		<span class="n">len</span> <span class="o">=</span> <span class="n">snprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">PAGE_SIZE</span><span class="p">,</span> <span class="s">&quot;%s, sli-%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">fwrev</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli_rev</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">len</span> <span class="o">=</span> <span class="n">snprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">PAGE_SIZE</span><span class="p">,</span> <span class="s">&quot;%s, sli-%d:%d:%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">fwrev</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli_rev</span><span class="p">,</span> <span class="n">if_type</span><span class="p">,</span> <span class="n">sli_family</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">len</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_hdw_show - Return the jedec information about the hba</span>
<span class="cm"> * @dev: class converted to a Scsi_host structure.</span>
<span class="cm"> * @attr: device attribute, not used.</span>
<span class="cm"> * @buf: on return contains the scsi vpd program type.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns: size of formatted string.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">ssize_t</span>
<span class="nf">lpfc_hdw_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="n">hdw</span><span class="p">[</span><span class="mi">9</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span>  <span class="o">*</span><span class="n">shost</span> <span class="o">=</span> <span class="n">class_to_shost</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="n">vport</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="p">)</span> <span class="n">shost</span><span class="o">-&gt;</span><span class="n">hostdata</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_hba</span>   <span class="o">*</span><span class="n">phba</span> <span class="o">=</span> <span class="n">vport</span><span class="o">-&gt;</span><span class="n">phba</span><span class="p">;</span>
	<span class="n">lpfc_vpd_t</span> <span class="o">*</span><span class="n">vp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">vpd</span><span class="p">;</span>

	<span class="n">lpfc_jedec_to_ascii</span><span class="p">(</span><span class="n">vp</span><span class="o">-&gt;</span><span class="n">rev</span><span class="p">.</span><span class="n">biuRev</span><span class="p">,</span> <span class="n">hdw</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">snprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">PAGE_SIZE</span><span class="p">,</span> <span class="s">&quot;%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">hdw</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_option_rom_version_show - Return the adapter ROM FCode version</span>
<span class="cm"> * @dev: class converted to a Scsi_host structure.</span>
<span class="cm"> * @attr: device attribute, not used.</span>
<span class="cm"> * @buf: on return contains the ROM and FCode ascii strings.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns: size of formatted string.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">ssize_t</span>
<span class="nf">lpfc_option_rom_version_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span>
			     <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span>  <span class="o">*</span><span class="n">shost</span> <span class="o">=</span> <span class="n">class_to_shost</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="n">vport</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="p">)</span> <span class="n">shost</span><span class="o">-&gt;</span><span class="n">hostdata</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_hba</span>   <span class="o">*</span><span class="n">phba</span> <span class="o">=</span> <span class="n">vport</span><span class="o">-&gt;</span><span class="n">phba</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">snprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">PAGE_SIZE</span><span class="p">,</span> <span class="s">&quot;%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">OptionROMVersion</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_state_show - Return the link state of the port</span>
<span class="cm"> * @dev: class converted to a Scsi_host structure.</span>
<span class="cm"> * @attr: device attribute, not used.</span>
<span class="cm"> * @buf: on return contains text describing the state of the link.</span>
<span class="cm"> *</span>
<span class="cm"> * Notes:</span>
<span class="cm"> * The switch statement has no default so zero will be returned.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns: size of formatted string.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">ssize_t</span>
<span class="nf">lpfc_link_state_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span>
		     <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span>  <span class="o">*</span><span class="n">shost</span> <span class="o">=</span> <span class="n">class_to_shost</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="n">vport</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="p">)</span> <span class="n">shost</span><span class="o">-&gt;</span><span class="n">hostdata</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_hba</span>   <span class="o">*</span><span class="n">phba</span> <span class="o">=</span> <span class="n">vport</span><span class="o">-&gt;</span><span class="n">phba</span><span class="p">;</span>
	<span class="kt">int</span>  <span class="n">len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">link_state</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">LPFC_LINK_UNKNOWN</span>:
	<span class="k">case</span> <span class="n">LPFC_WARM_START</span>:
	<span class="k">case</span> <span class="n">LPFC_INIT_START</span>:
	<span class="k">case</span> <span class="n">LPFC_INIT_MBX_CMDS</span>:
	<span class="k">case</span> <span class="n">LPFC_LINK_DOWN</span>:
	<span class="k">case</span> <span class="n">LPFC_HBA_ERROR</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hba_flag</span> <span class="o">&amp;</span> <span class="n">LINK_DISABLED</span><span class="p">)</span>
			<span class="n">len</span> <span class="o">+=</span> <span class="n">snprintf</span><span class="p">(</span><span class="n">buf</span> <span class="o">+</span> <span class="n">len</span><span class="p">,</span> <span class="n">PAGE_SIZE</span><span class="o">-</span><span class="n">len</span><span class="p">,</span>
				<span class="s">&quot;Link Down - User disabled</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">len</span> <span class="o">+=</span> <span class="n">snprintf</span><span class="p">(</span><span class="n">buf</span> <span class="o">+</span> <span class="n">len</span><span class="p">,</span> <span class="n">PAGE_SIZE</span><span class="o">-</span><span class="n">len</span><span class="p">,</span>
				<span class="s">&quot;Link Down</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">LPFC_LINK_UP</span>:
	<span class="k">case</span> <span class="n">LPFC_CLEAR_LA</span>:
	<span class="k">case</span> <span class="n">LPFC_HBA_READY</span>:
		<span class="n">len</span> <span class="o">+=</span> <span class="n">snprintf</span><span class="p">(</span><span class="n">buf</span> <span class="o">+</span> <span class="n">len</span><span class="p">,</span> <span class="n">PAGE_SIZE</span><span class="o">-</span><span class="n">len</span><span class="p">,</span> <span class="s">&quot;Link Up - &quot;</span><span class="p">);</span>

		<span class="k">switch</span> <span class="p">(</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">port_state</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">LPFC_LOCAL_CFG_LINK</span>:
			<span class="n">len</span> <span class="o">+=</span> <span class="n">snprintf</span><span class="p">(</span><span class="n">buf</span> <span class="o">+</span> <span class="n">len</span><span class="p">,</span> <span class="n">PAGE_SIZE</span><span class="o">-</span><span class="n">len</span><span class="p">,</span>
					<span class="s">&quot;Configuring Link</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">LPFC_FDISC</span>:
		<span class="k">case</span> <span class="n">LPFC_FLOGI</span>:
		<span class="k">case</span> <span class="n">LPFC_FABRIC_CFG_LINK</span>:
		<span class="k">case</span> <span class="n">LPFC_NS_REG</span>:
		<span class="k">case</span> <span class="n">LPFC_NS_QRY</span>:
		<span class="k">case</span> <span class="n">LPFC_BUILD_DISC_LIST</span>:
		<span class="k">case</span> <span class="n">LPFC_DISC_AUTH</span>:
			<span class="n">len</span> <span class="o">+=</span> <span class="n">snprintf</span><span class="p">(</span><span class="n">buf</span> <span class="o">+</span> <span class="n">len</span><span class="p">,</span> <span class="n">PAGE_SIZE</span> <span class="o">-</span> <span class="n">len</span><span class="p">,</span>
					<span class="s">&quot;Discovery</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">LPFC_VPORT_READY</span>:
			<span class="n">len</span> <span class="o">+=</span> <span class="n">snprintf</span><span class="p">(</span><span class="n">buf</span> <span class="o">+</span> <span class="n">len</span><span class="p">,</span> <span class="n">PAGE_SIZE</span> <span class="o">-</span> <span class="n">len</span><span class="p">,</span> <span class="s">&quot;Ready</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">LPFC_VPORT_FAILED</span>:
			<span class="n">len</span> <span class="o">+=</span> <span class="n">snprintf</span><span class="p">(</span><span class="n">buf</span> <span class="o">+</span> <span class="n">len</span><span class="p">,</span> <span class="n">PAGE_SIZE</span> <span class="o">-</span> <span class="n">len</span><span class="p">,</span> <span class="s">&quot;Failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">LPFC_VPORT_UNKNOWN</span>:
			<span class="n">len</span> <span class="o">+=</span> <span class="n">snprintf</span><span class="p">(</span><span class="n">buf</span> <span class="o">+</span> <span class="n">len</span><span class="p">,</span> <span class="n">PAGE_SIZE</span> <span class="o">-</span> <span class="n">len</span><span class="p">,</span>
					<span class="s">&quot;Unknown</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli</span><span class="p">.</span><span class="n">sli_flag</span> <span class="o">&amp;</span> <span class="n">LPFC_MENLO_MAINT</span><span class="p">)</span>
			<span class="n">len</span> <span class="o">+=</span> <span class="n">snprintf</span><span class="p">(</span><span class="n">buf</span> <span class="o">+</span> <span class="n">len</span><span class="p">,</span> <span class="n">PAGE_SIZE</span><span class="o">-</span><span class="n">len</span><span class="p">,</span>
					<span class="s">&quot;   Menlo Maint Mode</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">fc_topology</span> <span class="o">==</span> <span class="n">LPFC_TOPOLOGY_LOOP</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_flag</span> <span class="o">&amp;</span> <span class="n">FC_PUBLIC_LOOP</span><span class="p">)</span>
				<span class="n">len</span> <span class="o">+=</span> <span class="n">snprintf</span><span class="p">(</span><span class="n">buf</span> <span class="o">+</span> <span class="n">len</span><span class="p">,</span> <span class="n">PAGE_SIZE</span><span class="o">-</span><span class="n">len</span><span class="p">,</span>
						<span class="s">&quot;   Public Loop</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">else</span>
				<span class="n">len</span> <span class="o">+=</span> <span class="n">snprintf</span><span class="p">(</span><span class="n">buf</span> <span class="o">+</span> <span class="n">len</span><span class="p">,</span> <span class="n">PAGE_SIZE</span><span class="o">-</span><span class="n">len</span><span class="p">,</span>
						<span class="s">&quot;   Private Loop</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_flag</span> <span class="o">&amp;</span> <span class="n">FC_FABRIC</span><span class="p">)</span>
				<span class="n">len</span> <span class="o">+=</span> <span class="n">snprintf</span><span class="p">(</span><span class="n">buf</span> <span class="o">+</span> <span class="n">len</span><span class="p">,</span> <span class="n">PAGE_SIZE</span><span class="o">-</span><span class="n">len</span><span class="p">,</span>
						<span class="s">&quot;   Fabric</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">else</span>
				<span class="n">len</span> <span class="o">+=</span> <span class="n">snprintf</span><span class="p">(</span><span class="n">buf</span> <span class="o">+</span> <span class="n">len</span><span class="p">,</span> <span class="n">PAGE_SIZE</span><span class="o">-</span><span class="n">len</span><span class="p">,</span>
						<span class="s">&quot;   Point-2-Point</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">len</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_sli4_protocol_show - Return the fip mode of the HBA</span>
<span class="cm"> * @dev: class unused variable.</span>
<span class="cm"> * @attr: device attribute, not used.</span>
<span class="cm"> * @buf: on return contains the module description text.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns: size of formatted string.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">ssize_t</span>
<span class="nf">lpfc_sli4_protocol_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span>
			<span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span> <span class="o">=</span> <span class="n">class_to_shost</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="n">vport</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="p">)</span> <span class="n">shost</span><span class="o">-&gt;</span><span class="n">hostdata</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span> <span class="o">=</span> <span class="n">vport</span><span class="o">-&gt;</span><span class="n">phba</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli_rev</span> <span class="o">&lt;</span> <span class="n">LPFC_SLI_REV4</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">snprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">PAGE_SIZE</span><span class="p">,</span> <span class="s">&quot;fc</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">lnk_info</span><span class="p">.</span><span class="n">lnk_dv</span> <span class="o">==</span> <span class="n">LPFC_LNK_DAT_VAL</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">lnk_info</span><span class="p">.</span><span class="n">lnk_tp</span> <span class="o">==</span> <span class="n">LPFC_LNK_TYPE_GE</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">snprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">PAGE_SIZE</span><span class="p">,</span> <span class="s">&quot;fcoe</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">lnk_info</span><span class="p">.</span><span class="n">lnk_tp</span> <span class="o">==</span> <span class="n">LPFC_LNK_TYPE_FC</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">snprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">PAGE_SIZE</span><span class="p">,</span> <span class="s">&quot;fc</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">snprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">PAGE_SIZE</span><span class="p">,</span> <span class="s">&quot;unknown</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_link_state_store - Transition the link_state on an HBA port</span>
<span class="cm"> * @dev: class device that is converted into a Scsi_host.</span>
<span class="cm"> * @attr: device attribute, not used.</span>
<span class="cm"> * @buf: one or more lpfc_polling_flags values.</span>
<span class="cm"> * @count: not used.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns:</span>
<span class="cm"> * -EINVAL if the buffer is not &quot;up&quot; or &quot;down&quot;</span>
<span class="cm"> * return from link state change function if non-zero</span>
<span class="cm"> * length of the buf on success</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">ssize_t</span>
<span class="nf">lpfc_link_state_store</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span>
		<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span>  <span class="o">*</span><span class="n">shost</span> <span class="o">=</span> <span class="n">class_to_shost</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="n">vport</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="p">)</span> <span class="n">shost</span><span class="o">-&gt;</span><span class="n">hostdata</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_hba</span>   <span class="o">*</span><span class="n">phba</span> <span class="o">=</span> <span class="n">vport</span><span class="o">-&gt;</span><span class="n">phba</span><span class="p">;</span>

	<span class="kt">int</span> <span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">strncmp</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;up&quot;</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="s">&quot;up&quot;</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			<span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">link_state</span> <span class="o">==</span> <span class="n">LPFC_LINK_DOWN</span><span class="p">))</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">lpfc_hba_init_link</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">MBX_NOWAIT</span><span class="p">);</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">strncmp</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;down&quot;</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="s">&quot;down&quot;</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			<span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">link_state</span> <span class="o">&gt;=</span> <span class="n">LPFC_LINK_UP</span><span class="p">))</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">lpfc_hba_down_link</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">MBX_NOWAIT</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">strlen</span><span class="p">(</span><span class="n">buf</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_num_discovered_ports_show - Return sum of mapped and unmapped vports</span>
<span class="cm"> * @dev: class device that is converted into a Scsi_host.</span>
<span class="cm"> * @attr: device attribute, not used.</span>
<span class="cm"> * @buf: on return contains the sum of fc mapped and unmapped.</span>
<span class="cm"> *</span>
<span class="cm"> * Description:</span>
<span class="cm"> * Returns the ascii text number of the sum of the fc mapped and unmapped</span>
<span class="cm"> * vport counts.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns: size of formatted string.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">ssize_t</span>
<span class="nf">lpfc_num_discovered_ports_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span>  <span class="o">*</span><span class="n">shost</span> <span class="o">=</span> <span class="n">class_to_shost</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="n">vport</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="p">)</span> <span class="n">shost</span><span class="o">-&gt;</span><span class="n">hostdata</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">snprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">PAGE_SIZE</span><span class="p">,</span> <span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_map_cnt</span> <span class="o">+</span> <span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_unmap_cnt</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_issue_lip - Misnomer, name carried over from long ago</span>
<span class="cm"> * @shost: Scsi_Host pointer.</span>
<span class="cm"> *</span>
<span class="cm"> * Description:</span>
<span class="cm"> * Bring the link down gracefully then re-init the link. The firmware will</span>
<span class="cm"> * re-init the fiber channel interface as required. Does not issue a LIP.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns:</span>
<span class="cm"> * -EPERM port offline or management commands are being blocked</span>
<span class="cm"> * -ENOMEM cannot allocate memory for the mailbox command</span>
<span class="cm"> * -EIO error sending the mailbox command</span>
<span class="cm"> * zero for success</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">lpfc_issue_lip</span><span class="p">(</span><span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="n">vport</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="p">)</span> <span class="n">shost</span><span class="o">-&gt;</span><span class="n">hostdata</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_hba</span>   <span class="o">*</span><span class="n">phba</span> <span class="o">=</span> <span class="n">vport</span><span class="o">-&gt;</span><span class="n">phba</span><span class="p">;</span>
	<span class="n">LPFC_MBOXQ_t</span> <span class="o">*</span><span class="n">pmboxq</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">mbxstatus</span> <span class="o">=</span> <span class="n">MBXERR_ERROR</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_flag</span> <span class="o">&amp;</span> <span class="n">FC_OFFLINE_MODE</span><span class="p">)</span> <span class="o">||</span>
	    <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli</span><span class="p">.</span><span class="n">sli_flag</span> <span class="o">&amp;</span> <span class="n">LPFC_BLOCK_MGMT_IO</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>

	<span class="n">pmboxq</span> <span class="o">=</span> <span class="n">mempool_alloc</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">mbox_mem_pool</span><span class="p">,</span><span class="n">GFP_KERNEL</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pmboxq</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">memset</span><span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">pmboxq</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span> <span class="p">(</span><span class="n">LPFC_MBOXQ_t</span><span class="p">));</span>
	<span class="n">pmboxq</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">mb</span><span class="p">.</span><span class="n">mbxCommand</span> <span class="o">=</span> <span class="n">MBX_DOWN_LINK</span><span class="p">;</span>
	<span class="n">pmboxq</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">mb</span><span class="p">.</span><span class="n">mbxOwner</span> <span class="o">=</span> <span class="n">OWN_HOST</span><span class="p">;</span>

	<span class="n">mbxstatus</span> <span class="o">=</span> <span class="n">lpfc_sli_issue_mbox_wait</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">pmboxq</span><span class="p">,</span> <span class="n">LPFC_MBOX_TMO</span> <span class="o">*</span> <span class="mi">2</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">mbxstatus</span> <span class="o">==</span> <span class="n">MBX_SUCCESS</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">pmboxq</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">mb</span><span class="p">.</span><span class="n">mbxStatus</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span>
	     <span class="n">pmboxq</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">mb</span><span class="p">.</span><span class="n">mbxStatus</span> <span class="o">==</span> <span class="n">MBXERR_LINK_DOWN</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">memset</span><span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">pmboxq</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span> <span class="p">(</span><span class="n">LPFC_MBOXQ_t</span><span class="p">));</span>
		<span class="n">lpfc_init_link</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">pmboxq</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">cfg_topology</span><span class="p">,</span>
			       <span class="n">phba</span><span class="o">-&gt;</span><span class="n">cfg_link_speed</span><span class="p">);</span>
		<span class="n">mbxstatus</span> <span class="o">=</span> <span class="n">lpfc_sli_issue_mbox_wait</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">pmboxq</span><span class="p">,</span>
						     <span class="n">phba</span><span class="o">-&gt;</span><span class="n">fc_ratov</span> <span class="o">*</span> <span class="mi">2</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">mbxstatus</span> <span class="o">==</span> <span class="n">MBX_SUCCESS</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="p">(</span><span class="n">pmboxq</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">mb</span><span class="p">.</span><span class="n">mbxStatus</span> <span class="o">==</span> <span class="n">MBXERR_SEC_NO_PERMISSION</span><span class="p">))</span>
			<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_MBOX</span> <span class="o">|</span> <span class="n">LOG_SLI</span><span class="p">,</span>
					<span class="s">&quot;2859 SLI authentication is required &quot;</span>
					<span class="s">&quot;for INIT_LINK but has not done yet</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">lpfc_set_loopback_flag</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mbxstatus</span> <span class="o">!=</span> <span class="n">MBX_TIMEOUT</span><span class="p">)</span>
		<span class="n">mempool_free</span><span class="p">(</span><span class="n">pmboxq</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">mbox_mem_pool</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">mbxstatus</span> <span class="o">==</span> <span class="n">MBXERR_ERROR</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_do_offline - Issues a mailbox command to bring the link down</span>
<span class="cm"> * @phba: lpfc_hba pointer.</span>
<span class="cm"> * @type: LPFC_EVT_OFFLINE, LPFC_EVT_WARM_START, LPFC_EVT_KILL.</span>
<span class="cm"> *</span>
<span class="cm"> * Notes:</span>
<span class="cm"> * Assumes any error from lpfc_do_offline() will be negative.</span>
<span class="cm"> * Can wait up to 5 seconds for the port ring buffers count</span>
<span class="cm"> * to reach zero, prints a warning if it is not zero and continues.</span>
<span class="cm"> * lpfc_workq_post_event() returns a non-zero return code if call fails.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns:</span>
<span class="cm"> * -EIO error posting the event</span>
<span class="cm"> * zero for success</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">lpfc_do_offline</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">type</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">completion</span> <span class="n">online_compl</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_sli_ring</span> <span class="o">*</span><span class="n">pring</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_sli</span> <span class="o">*</span><span class="n">psli</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">init_completion</span><span class="p">(</span><span class="o">&amp;</span><span class="n">online_compl</span><span class="p">);</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">lpfc_workq_post_event</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">status</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">online_compl</span><span class="p">,</span>
			      <span class="n">LPFC_EVT_OFFLINE_PREP</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">wait_for_completion</span><span class="p">(</span><span class="o">&amp;</span><span class="n">online_compl</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>

	<span class="n">psli</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli</span><span class="p">;</span>

	<span class="cm">/* Wait a little for things to settle down, but not</span>
<span class="cm">	 * long enough for dev loss timeout to expire.</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">psli</span><span class="o">-&gt;</span><span class="n">num_rings</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pring</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">psli</span><span class="o">-&gt;</span><span class="n">ring</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">pring</span><span class="o">-&gt;</span><span class="n">txcmplq_cnt</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">msleep</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">cnt</span><span class="o">++</span> <span class="o">&gt;</span> <span class="mi">500</span><span class="p">)</span> <span class="p">{</span>  <span class="cm">/* 5 secs */</span>
				<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span>
					<span class="n">KERN_WARNING</span><span class="p">,</span> <span class="n">LOG_INIT</span><span class="p">,</span>
					<span class="s">&quot;0466 Outstanding IO when &quot;</span>
					<span class="s">&quot;bringing Adapter offline</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">init_completion</span><span class="p">(</span><span class="o">&amp;</span><span class="n">online_compl</span><span class="p">);</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">lpfc_workq_post_event</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">status</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">online_compl</span><span class="p">,</span> <span class="n">type</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">wait_for_completion</span><span class="p">(</span><span class="o">&amp;</span><span class="n">online_compl</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_selective_reset - Offline then onlines the port</span>
<span class="cm"> * @phba: lpfc_hba pointer.</span>
<span class="cm"> *</span>
<span class="cm"> * Description:</span>
<span class="cm"> * If the port is configured to allow a reset then the hba is brought</span>
<span class="cm"> * offline then online.</span>
<span class="cm"> *</span>
<span class="cm"> * Notes:</span>
<span class="cm"> * Assumes any error from lpfc_do_offline() will be negative.</span>
<span class="cm"> * Do not make this function static.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns:</span>
<span class="cm"> * lpfc_do_offline() return code if not zero</span>
<span class="cm"> * -EIO reset not configured or error posting the event</span>
<span class="cm"> * zero for success</span>
<span class="cm"> **/</span>
<span class="kt">int</span>
<span class="nf">lpfc_selective_reset</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">completion</span> <span class="n">online_compl</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">cfg_enable_hba_reset</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EACCES</span><span class="p">;</span>

	<span class="n">status</span> <span class="o">=</span> <span class="n">lpfc_do_offline</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">LPFC_EVT_OFFLINE</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">status</span><span class="p">;</span>

	<span class="n">init_completion</span><span class="p">(</span><span class="o">&amp;</span><span class="n">online_compl</span><span class="p">);</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">lpfc_workq_post_event</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">status</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">online_compl</span><span class="p">,</span>
			      <span class="n">LPFC_EVT_ONLINE</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">wait_for_completion</span><span class="p">(</span><span class="o">&amp;</span><span class="n">online_compl</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_issue_reset - Selectively resets an adapter</span>
<span class="cm"> * @dev: class device that is converted into a Scsi_host.</span>
<span class="cm"> * @attr: device attribute, not used.</span>
<span class="cm"> * @buf: containing the string &quot;selective&quot;.</span>
<span class="cm"> * @count: unused variable.</span>
<span class="cm"> *</span>
<span class="cm"> * Description:</span>
<span class="cm"> * If the buf contains the string &quot;selective&quot; then lpfc_selective_reset()</span>
<span class="cm"> * is called to perform the reset.</span>
<span class="cm"> *</span>
<span class="cm"> * Notes:</span>
<span class="cm"> * Assumes any error from lpfc_selective_reset() will be negative.</span>
<span class="cm"> * If lpfc_selective_reset() returns zero then the length of the buffer</span>
<span class="cm"> * is returned which indicates success</span>
<span class="cm"> *</span>
<span class="cm"> * Returns:</span>
<span class="cm"> * -EINVAL if the buffer does not contain the string &quot;selective&quot;</span>
<span class="cm"> * length of buf if lpfc-selective_reset() if the call succeeds</span>
<span class="cm"> * return value of lpfc_selective_reset() if the call fails</span>
<span class="cm">**/</span>
<span class="k">static</span> <span class="kt">ssize_t</span>
<span class="nf">lpfc_issue_reset</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span>
		 <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span>  <span class="o">*</span><span class="n">shost</span> <span class="o">=</span> <span class="n">class_to_shost</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="n">vport</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="p">)</span> <span class="n">shost</span><span class="o">-&gt;</span><span class="n">hostdata</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_hba</span>   <span class="o">*</span><span class="n">phba</span> <span class="o">=</span> <span class="n">vport</span><span class="o">-&gt;</span><span class="n">phba</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">cfg_enable_hba_reset</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EACCES</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">strncmp</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;selective&quot;</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="s">&quot;selective&quot;</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">lpfc_selective_reset</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">strlen</span><span class="p">(</span><span class="n">buf</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_sli4_pdev_status_reg_wait - Wait for pdev status register for readyness</span>
<span class="cm"> * @phba: lpfc_hba pointer.</span>
<span class="cm"> *</span>
<span class="cm"> * Description:</span>
<span class="cm"> * SLI4 interface type-2 device to wait on the sliport status register for</span>
<span class="cm"> * the readyness after performing a firmware reset.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns:</span>
<span class="cm"> * zero for success, -EPERM when port does not have privilage to perform the</span>
<span class="cm"> * reset, -EIO when port timeout from recovering from the reset.</span>
<span class="cm"> *</span>
<span class="cm"> * Note:</span>
<span class="cm"> * As the caller will interpret the return code by value, be careful in making</span>
<span class="cm"> * change or addition to return codes.</span>
<span class="cm"> **/</span>
<span class="kt">int</span>
<span class="nf">lpfc_sli4_pdev_status_reg_wait</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpfc_register</span> <span class="n">portstat_reg</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">msleep</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span>
	<span class="n">lpfc_readl</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">u</span><span class="p">.</span><span class="n">if_type2</span><span class="p">.</span><span class="n">STATUSregaddr</span><span class="p">,</span>
		   <span class="o">&amp;</span><span class="n">portstat_reg</span><span class="p">.</span><span class="n">word0</span><span class="p">);</span>

	<span class="cm">/* verify if privilaged for the request operation */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_sliport_status_rn</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">portstat_reg</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="o">!</span><span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_sliport_status_err</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">portstat_reg</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>

	<span class="cm">/* wait for the SLI port firmware ready after firmware reset */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">LPFC_FW_RESET_MAXIMUM_WAIT_10MS_CNT</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">msleep</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
		<span class="n">lpfc_readl</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">u</span><span class="p">.</span><span class="n">if_type2</span><span class="p">.</span><span class="n">STATUSregaddr</span><span class="p">,</span>
			   <span class="o">&amp;</span><span class="n">portstat_reg</span><span class="p">.</span><span class="n">word0</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_sliport_status_err</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">portstat_reg</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_sliport_status_rn</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">portstat_reg</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_sliport_status_rdy</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">portstat_reg</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">LPFC_FW_RESET_MAXIMUM_WAIT_10MS_CNT</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_sli4_pdev_reg_request - Request physical dev to perform a register acc</span>
<span class="cm"> * @phba: lpfc_hba pointer.</span>
<span class="cm"> *</span>
<span class="cm"> * Description:</span>
<span class="cm"> * Request SLI4 interface type-2 device to perform a physical register set</span>
<span class="cm"> * access.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns:</span>
<span class="cm"> * zero for success</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">ssize_t</span>
<span class="nf">lpfc_sli4_pdev_reg_request</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">opcode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">completion</span> <span class="n">online_compl</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span> <span class="o">=</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">pcidev</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">before_fc_flag</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">sriov_nr_virtfn</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">reg_val</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">job_posted</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">sriov_err</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">cfg_enable_hba_reset</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EACCES</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli_rev</span> <span class="o">&lt;</span> <span class="n">LPFC_SLI_REV4</span><span class="p">)</span> <span class="o">||</span>
	    <span class="p">(</span><span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_sli_intf_if_type</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">sli_intf</span><span class="p">)</span> <span class="o">!=</span>
	     <span class="n">LPFC_SLI_INTF_IF_TYPE_2</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>

	<span class="cm">/* Keep state if we need to restore back */</span>
	<span class="n">before_fc_flag</span> <span class="o">=</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">pport</span><span class="o">-&gt;</span><span class="n">fc_flag</span><span class="p">;</span>
	<span class="n">sriov_nr_virtfn</span> <span class="o">=</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">cfg_sriov_nr_virtfn</span><span class="p">;</span>

	<span class="cm">/* Disable SR-IOV virtual functions if enabled */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">cfg_sriov_nr_virtfn</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pci_disable_sriov</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">cfg_sriov_nr_virtfn</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">status</span> <span class="o">=</span> <span class="n">lpfc_do_offline</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">LPFC_EVT_OFFLINE</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">status</span><span class="p">;</span>

	<span class="cm">/* wait for the device to be quiesced before firmware reset */</span>
	<span class="n">msleep</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span>

	<span class="n">reg_val</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">conf_regs_memmap_p</span> <span class="o">+</span>
			<span class="n">LPFC_CTL_PDEV_CTL_OFFSET</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">opcode</span> <span class="o">==</span> <span class="n">LPFC_FW_DUMP</span><span class="p">)</span>
		<span class="n">reg_val</span> <span class="o">|=</span> <span class="n">LPFC_FW_DUMP_REQUEST</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">opcode</span> <span class="o">==</span> <span class="n">LPFC_FW_RESET</span><span class="p">)</span>
		<span class="n">reg_val</span> <span class="o">|=</span> <span class="n">LPFC_CTL_PDEV_CTL_FRST</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">opcode</span> <span class="o">==</span> <span class="n">LPFC_DV_RESET</span><span class="p">)</span>
		<span class="n">reg_val</span> <span class="o">|=</span> <span class="n">LPFC_CTL_PDEV_CTL_DRST</span><span class="p">;</span>

	<span class="n">writel</span><span class="p">(</span><span class="n">reg_val</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">conf_regs_memmap_p</span> <span class="o">+</span>
	       <span class="n">LPFC_CTL_PDEV_CTL_OFFSET</span><span class="p">);</span>
	<span class="cm">/* flush */</span>
	<span class="n">readl</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">conf_regs_memmap_p</span> <span class="o">+</span> <span class="n">LPFC_CTL_PDEV_CTL_OFFSET</span><span class="p">);</span>

	<span class="cm">/* delay driver action following IF_TYPE_2 reset */</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">lpfc_sli4_pdev_status_reg_wait</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">==</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* no privilage for reset */</span>
		<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_SLI</span><span class="p">,</span>
				<span class="s">&quot;3150 No privilage to perform the requested &quot;</span>
				<span class="s">&quot;access: x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">reg_val</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">==</span> <span class="o">-</span><span class="n">EIO</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* reset failed, there is nothing more we can do */</span>
		<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_SLI</span><span class="p">,</span>
				<span class="s">&quot;3153 Fail to perform the requested &quot;</span>
				<span class="s">&quot;access: x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">reg_val</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* keep the original port state */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">before_fc_flag</span> <span class="o">&amp;</span> <span class="n">FC_OFFLINE_MODE</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">init_completion</span><span class="p">(</span><span class="o">&amp;</span><span class="n">online_compl</span><span class="p">);</span>
	<span class="n">job_posted</span> <span class="o">=</span> <span class="n">lpfc_workq_post_event</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">status</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">online_compl</span><span class="p">,</span>
					   <span class="n">LPFC_EVT_ONLINE</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">job_posted</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">wait_for_completion</span><span class="p">(</span><span class="o">&amp;</span><span class="n">online_compl</span><span class="p">);</span>

<span class="nl">out:</span>
	<span class="cm">/* in any case, restore the virtual functions enabled as before */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sriov_nr_virtfn</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">sriov_err</span> <span class="o">=</span>
			<span class="n">lpfc_sli_probe_sriov_nr_virtfn</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">sriov_nr_virtfn</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sriov_err</span><span class="p">)</span>
			<span class="n">phba</span><span class="o">-&gt;</span><span class="n">cfg_sriov_nr_virtfn</span> <span class="o">=</span> <span class="n">sriov_nr_virtfn</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* return proper error code */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">job_posted</span><span class="p">)</span>
			<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">status</span><span class="p">)</span>
			<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_nport_evt_cnt_show - Return the number of nport events</span>
<span class="cm"> * @dev: class device that is converted into a Scsi_host.</span>
<span class="cm"> * @attr: device attribute, not used.</span>
<span class="cm"> * @buf: on return contains the ascii number of nport events.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns: size of formatted string.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">ssize_t</span>
<span class="nf">lpfc_nport_evt_cnt_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span>
			<span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span>  <span class="o">*</span><span class="n">shost</span> <span class="o">=</span> <span class="n">class_to_shost</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="n">vport</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="p">)</span> <span class="n">shost</span><span class="o">-&gt;</span><span class="n">hostdata</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_hba</span>   <span class="o">*</span><span class="n">phba</span> <span class="o">=</span> <span class="n">vport</span><span class="o">-&gt;</span><span class="n">phba</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">snprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">PAGE_SIZE</span><span class="p">,</span> <span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">nport_event_cnt</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_board_mode_show - Return the state of the board</span>
<span class="cm"> * @dev: class device that is converted into a Scsi_host.</span>
<span class="cm"> * @attr: device attribute, not used.</span>
<span class="cm"> * @buf: on return contains the state of the adapter.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns: size of formatted string.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">ssize_t</span>
<span class="nf">lpfc_board_mode_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span>
		     <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span>  <span class="o">*</span><span class="n">shost</span> <span class="o">=</span> <span class="n">class_to_shost</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="n">vport</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="p">)</span> <span class="n">shost</span><span class="o">-&gt;</span><span class="n">hostdata</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_hba</span>   <span class="o">*</span><span class="n">phba</span> <span class="o">=</span> <span class="n">vport</span><span class="o">-&gt;</span><span class="n">phba</span><span class="p">;</span>
	<span class="kt">char</span>  <span class="o">*</span> <span class="n">state</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">link_state</span> <span class="o">==</span> <span class="n">LPFC_HBA_ERROR</span><span class="p">)</span>
		<span class="n">state</span> <span class="o">=</span> <span class="s">&quot;error&quot;</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">link_state</span> <span class="o">==</span> <span class="n">LPFC_WARM_START</span><span class="p">)</span>
		<span class="n">state</span> <span class="o">=</span> <span class="s">&quot;warm start&quot;</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">link_state</span> <span class="o">==</span> <span class="n">LPFC_INIT_START</span><span class="p">)</span>
		<span class="n">state</span> <span class="o">=</span> <span class="s">&quot;offline&quot;</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">state</span> <span class="o">=</span> <span class="s">&quot;online&quot;</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">snprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">PAGE_SIZE</span><span class="p">,</span> <span class="s">&quot;%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">state</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_board_mode_store - Puts the hba in online, offline, warm or error state</span>
<span class="cm"> * @dev: class device that is converted into a Scsi_host.</span>
<span class="cm"> * @attr: device attribute, not used.</span>
<span class="cm"> * @buf: containing one of the strings &quot;online&quot;, &quot;offline&quot;, &quot;warm&quot; or &quot;error&quot;.</span>
<span class="cm"> * @count: unused variable.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns:</span>
<span class="cm"> * -EACCES if enable hba reset not enabled</span>
<span class="cm"> * -EINVAL if the buffer does not contain a valid string (see above)</span>
<span class="cm"> * -EIO if lpfc_workq_post_event() or lpfc_do_offline() fails</span>
<span class="cm"> * buf length greater than zero indicates success</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">ssize_t</span>
<span class="nf">lpfc_board_mode_store</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span>
		      <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span>  <span class="o">*</span><span class="n">shost</span> <span class="o">=</span> <span class="n">class_to_shost</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="n">vport</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="p">)</span> <span class="n">shost</span><span class="o">-&gt;</span><span class="n">hostdata</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_hba</span>   <span class="o">*</span><span class="n">phba</span> <span class="o">=</span> <span class="n">vport</span><span class="o">-&gt;</span><span class="n">phba</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">completion</span> <span class="n">online_compl</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">board_mode_str</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">cfg_enable_hba_reset</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EACCES</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">board_mode_out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">lpfc_printf_vlog</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_INIT</span><span class="p">,</span>
			 <span class="s">&quot;3050 lpfc_board_mode set to %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">buf</span><span class="p">);</span>

	<span class="n">init_completion</span><span class="p">(</span><span class="o">&amp;</span><span class="n">online_compl</span><span class="p">);</span>

	<span class="k">if</span><span class="p">(</span><span class="n">strncmp</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;online&quot;</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="s">&quot;online&quot;</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">lpfc_workq_post_event</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">status</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">online_compl</span><span class="p">,</span>
				      <span class="n">LPFC_EVT_ONLINE</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">board_mode_out</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">wait_for_completion</span><span class="p">(</span><span class="o">&amp;</span><span class="n">online_compl</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">strncmp</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;offline&quot;</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="s">&quot;offline&quot;</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">lpfc_do_offline</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">LPFC_EVT_OFFLINE</span><span class="p">);</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">strncmp</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;warm&quot;</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="s">&quot;warm&quot;</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli_rev</span> <span class="o">==</span> <span class="n">LPFC_SLI_REV4</span><span class="p">)</span>
			<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">status</span> <span class="o">=</span> <span class="n">lpfc_do_offline</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">LPFC_EVT_WARM_START</span><span class="p">);</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">strncmp</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;error&quot;</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="s">&quot;error&quot;</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli_rev</span> <span class="o">==</span> <span class="n">LPFC_SLI_REV4</span><span class="p">)</span>
			<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">status</span> <span class="o">=</span> <span class="n">lpfc_do_offline</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">LPFC_EVT_KILL</span><span class="p">);</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">strncmp</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;dump&quot;</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="s">&quot;dump&quot;</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">lpfc_sli4_pdev_reg_request</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">LPFC_FW_DUMP</span><span class="p">);</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">strncmp</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;fw_reset&quot;</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="s">&quot;fw_reset&quot;</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">lpfc_sli4_pdev_reg_request</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">LPFC_FW_RESET</span><span class="p">);</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">strncmp</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;dv_reset&quot;</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="s">&quot;dv_reset&quot;</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">lpfc_sli4_pdev_reg_request</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">LPFC_DV_RESET</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

<span class="nl">board_mode_out:</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">status</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">strlen</span><span class="p">(</span><span class="n">buf</span><span class="p">);</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="n">board_mode_str</span> <span class="o">=</span> <span class="n">strchr</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="sc">&#39;\n&#39;</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">board_mode_str</span><span class="p">)</span>
			<span class="o">*</span><span class="n">board_mode_str</span> <span class="o">=</span> <span class="sc">&#39;\0&#39;</span><span class="p">;</span>
		<span class="n">lpfc_printf_vlog</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_INIT</span><span class="p">,</span>
				 <span class="s">&quot;3097 Failed </span><span class="se">\&quot;</span><span class="s">%s</span><span class="se">\&quot;</span><span class="s">, status(%d), &quot;</span>
				 <span class="s">&quot;fc_flag(x%x)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				 <span class="n">buf</span><span class="p">,</span> <span class="n">status</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">pport</span><span class="o">-&gt;</span><span class="n">fc_flag</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_get_hba_info - Return various bits of informaton about the adapter</span>
<span class="cm"> * @phba: pointer to the adapter structure.</span>
<span class="cm"> * @mxri: max xri count.</span>
<span class="cm"> * @axri: available xri count.</span>
<span class="cm"> * @mrpi: max rpi count.</span>
<span class="cm"> * @arpi: available rpi count.</span>
<span class="cm"> * @mvpi: max vpi count.</span>
<span class="cm"> * @avpi: available vpi count.</span>
<span class="cm"> *</span>
<span class="cm"> * Description:</span>
<span class="cm"> * If an integer pointer for an count is not null then the value for the</span>
<span class="cm"> * count is returned.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns:</span>
<span class="cm"> * zero on error</span>
<span class="cm"> * one for success</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">lpfc_get_hba_info</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">,</span>
		  <span class="kt">uint32_t</span> <span class="o">*</span><span class="n">mxri</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="o">*</span><span class="n">axri</span><span class="p">,</span>
		  <span class="kt">uint32_t</span> <span class="o">*</span><span class="n">mrpi</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="o">*</span><span class="n">arpi</span><span class="p">,</span>
		  <span class="kt">uint32_t</span> <span class="o">*</span><span class="n">mvpi</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="o">*</span><span class="n">avpi</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpfc_mbx_read_config</span> <span class="o">*</span><span class="n">rd_config</span><span class="p">;</span>
	<span class="n">LPFC_MBOXQ_t</span> <span class="o">*</span><span class="n">pmboxq</span><span class="p">;</span>
	<span class="n">MAILBOX_t</span> <span class="o">*</span><span class="n">pmb</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">max_vpi</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * prevent udev from issuing mailbox commands until the port is</span>
<span class="cm">	 * configured.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">link_state</span> <span class="o">&lt;</span> <span class="n">LPFC_LINK_DOWN</span> <span class="o">||</span>
	    <span class="o">!</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">mbox_mem_pool</span> <span class="o">||</span>
	    <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli</span><span class="p">.</span><span class="n">sli_flag</span> <span class="o">&amp;</span> <span class="n">LPFC_SLI_ACTIVE</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli</span><span class="p">.</span><span class="n">sli_flag</span> <span class="o">&amp;</span> <span class="n">LPFC_BLOCK_MGMT_IO</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">pmboxq</span> <span class="o">=</span> <span class="n">mempool_alloc</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">mbox_mem_pool</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pmboxq</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">pmboxq</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span> <span class="p">(</span><span class="n">LPFC_MBOXQ_t</span><span class="p">));</span>

	<span class="n">pmb</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">pmboxq</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">mb</span><span class="p">;</span>
	<span class="n">pmb</span><span class="o">-&gt;</span><span class="n">mbxCommand</span> <span class="o">=</span> <span class="n">MBX_READ_CONFIG</span><span class="p">;</span>
	<span class="n">pmb</span><span class="o">-&gt;</span><span class="n">mbxOwner</span> <span class="o">=</span> <span class="n">OWN_HOST</span><span class="p">;</span>
	<span class="n">pmboxq</span><span class="o">-&gt;</span><span class="n">context1</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">pport</span><span class="o">-&gt;</span><span class="n">fc_flag</span> <span class="o">&amp;</span> <span class="n">FC_OFFLINE_MODE</span><span class="p">)</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">MBX_NOT_FINISHED</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">lpfc_sli_issue_mbox_wait</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">pmboxq</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">fc_ratov</span> <span class="o">*</span> <span class="mi">2</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">!=</span> <span class="n">MBX_SUCCESS</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">!=</span> <span class="n">MBX_TIMEOUT</span><span class="p">)</span>
			<span class="n">mempool_free</span><span class="p">(</span><span class="n">pmboxq</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">mbox_mem_pool</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli_rev</span> <span class="o">==</span> <span class="n">LPFC_SLI_REV4</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rd_config</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">pmboxq</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">mqe</span><span class="p">.</span><span class="n">un</span><span class="p">.</span><span class="n">rd_config</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">mrpi</span><span class="p">)</span>
			<span class="o">*</span><span class="n">mrpi</span> <span class="o">=</span> <span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_mbx_rd_conf_rpi_count</span><span class="p">,</span> <span class="n">rd_config</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">arpi</span><span class="p">)</span>
			<span class="o">*</span><span class="n">arpi</span> <span class="o">=</span> <span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_mbx_rd_conf_rpi_count</span><span class="p">,</span> <span class="n">rd_config</span><span class="p">)</span> <span class="o">-</span>
					<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">max_cfg_param</span><span class="p">.</span><span class="n">rpi_used</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">mxri</span><span class="p">)</span>
			<span class="o">*</span><span class="n">mxri</span> <span class="o">=</span> <span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_mbx_rd_conf_xri_count</span><span class="p">,</span> <span class="n">rd_config</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">axri</span><span class="p">)</span>
			<span class="o">*</span><span class="n">axri</span> <span class="o">=</span> <span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_mbx_rd_conf_xri_count</span><span class="p">,</span> <span class="n">rd_config</span><span class="p">)</span> <span class="o">-</span>
					<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">max_cfg_param</span><span class="p">.</span><span class="n">xri_used</span><span class="p">;</span>

		<span class="cm">/* Account for differences with SLI-3.  Get vpi count from</span>
<span class="cm">		 * mailbox data and subtract one for max vpi value.</span>
<span class="cm">		 */</span>
		<span class="n">max_vpi</span> <span class="o">=</span> <span class="p">(</span><span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_mbx_rd_conf_vpi_count</span><span class="p">,</span> <span class="n">rd_config</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">?</span>
			<span class="p">(</span><span class="n">bf_get</span><span class="p">(</span><span class="n">lpfc_mbx_rd_conf_vpi_count</span><span class="p">,</span> <span class="n">rd_config</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">mvpi</span><span class="p">)</span>
			<span class="o">*</span><span class="n">mvpi</span> <span class="o">=</span> <span class="n">max_vpi</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">avpi</span><span class="p">)</span>
			<span class="o">*</span><span class="n">avpi</span> <span class="o">=</span> <span class="n">max_vpi</span> <span class="o">-</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli4_hba</span><span class="p">.</span><span class="n">max_cfg_param</span><span class="p">.</span><span class="n">vpi_used</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">mrpi</span><span class="p">)</span>
			<span class="o">*</span><span class="n">mrpi</span> <span class="o">=</span> <span class="n">pmb</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">varRdConfig</span><span class="p">.</span><span class="n">max_rpi</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">arpi</span><span class="p">)</span>
			<span class="o">*</span><span class="n">arpi</span> <span class="o">=</span> <span class="n">pmb</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">varRdConfig</span><span class="p">.</span><span class="n">avail_rpi</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">mxri</span><span class="p">)</span>
			<span class="o">*</span><span class="n">mxri</span> <span class="o">=</span> <span class="n">pmb</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">varRdConfig</span><span class="p">.</span><span class="n">max_xri</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">axri</span><span class="p">)</span>
			<span class="o">*</span><span class="n">axri</span> <span class="o">=</span> <span class="n">pmb</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">varRdConfig</span><span class="p">.</span><span class="n">avail_xri</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">mvpi</span><span class="p">)</span>
			<span class="o">*</span><span class="n">mvpi</span> <span class="o">=</span> <span class="n">pmb</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">varRdConfig</span><span class="p">.</span><span class="n">max_vpi</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">avpi</span><span class="p">)</span>
			<span class="o">*</span><span class="n">avpi</span> <span class="o">=</span> <span class="n">pmb</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">varRdConfig</span><span class="p">.</span><span class="n">avail_vpi</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">mempool_free</span><span class="p">(</span><span class="n">pmboxq</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">mbox_mem_pool</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_max_rpi_show - Return maximum rpi</span>
<span class="cm"> * @dev: class device that is converted into a Scsi_host.</span>
<span class="cm"> * @attr: device attribute, not used.</span>
<span class="cm"> * @buf: on return contains the maximum rpi count in decimal or &quot;Unknown&quot;.</span>
<span class="cm"> *</span>
<span class="cm"> * Description:</span>
<span class="cm"> * Calls lpfc_get_hba_info() asking for just the mrpi count.</span>
<span class="cm"> * If lpfc_get_hba_info() returns zero (failure) the buffer text is set</span>
<span class="cm"> * to &quot;Unknown&quot; and the buffer length is returned, therefore the caller</span>
<span class="cm"> * must check for &quot;Unknown&quot; in the buffer to detect a failure.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns: size of formatted string.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">ssize_t</span>
<span class="nf">lpfc_max_rpi_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span>
		  <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span>  <span class="o">*</span><span class="n">shost</span> <span class="o">=</span> <span class="n">class_to_shost</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="n">vport</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="p">)</span> <span class="n">shost</span><span class="o">-&gt;</span><span class="n">hostdata</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_hba</span>   <span class="o">*</span><span class="n">phba</span> <span class="o">=</span> <span class="n">vport</span><span class="o">-&gt;</span><span class="n">phba</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">cnt</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">lpfc_get_hba_info</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cnt</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">snprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">PAGE_SIZE</span><span class="p">,</span> <span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">cnt</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">snprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">PAGE_SIZE</span><span class="p">,</span> <span class="s">&quot;Unknown</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_used_rpi_show - Return maximum rpi minus available rpi</span>
<span class="cm"> * @dev: class device that is converted into a Scsi_host.</span>
<span class="cm"> * @attr: device attribute, not used.</span>
<span class="cm"> * @buf: containing the used rpi count in decimal or &quot;Unknown&quot;.</span>
<span class="cm"> *</span>
<span class="cm"> * Description:</span>
<span class="cm"> * Calls lpfc_get_hba_info() asking for just the mrpi and arpi counts.</span>
<span class="cm"> * If lpfc_get_hba_info() returns zero (failure) the buffer text is set</span>
<span class="cm"> * to &quot;Unknown&quot; and the buffer length is returned, therefore the caller</span>
<span class="cm"> * must check for &quot;Unknown&quot; in the buffer to detect a failure.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns: size of formatted string.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">ssize_t</span>
<span class="nf">lpfc_used_rpi_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span>
		   <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span>  <span class="o">*</span><span class="n">shost</span> <span class="o">=</span> <span class="n">class_to_shost</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="n">vport</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="p">)</span> <span class="n">shost</span><span class="o">-&gt;</span><span class="n">hostdata</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_hba</span>   <span class="o">*</span><span class="n">phba</span> <span class="o">=</span> <span class="n">vport</span><span class="o">-&gt;</span><span class="n">phba</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">cnt</span><span class="p">,</span> <span class="n">acnt</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">lpfc_get_hba_info</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cnt</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">acnt</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">snprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">PAGE_SIZE</span><span class="p">,</span> <span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">cnt</span> <span class="o">-</span> <span class="n">acnt</span><span class="p">));</span>
	<span class="k">return</span> <span class="n">snprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">PAGE_SIZE</span><span class="p">,</span> <span class="s">&quot;Unknown</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_max_xri_show - Return maximum xri</span>
<span class="cm"> * @dev: class device that is converted into a Scsi_host.</span>
<span class="cm"> * @attr: device attribute, not used.</span>
<span class="cm"> * @buf: on return contains the maximum xri count in decimal or &quot;Unknown&quot;.</span>
<span class="cm"> *</span>
<span class="cm"> * Description:</span>
<span class="cm"> * Calls lpfc_get_hba_info() asking for just the mrpi count.</span>
<span class="cm"> * If lpfc_get_hba_info() returns zero (failure) the buffer text is set</span>
<span class="cm"> * to &quot;Unknown&quot; and the buffer length is returned, therefore the caller</span>
<span class="cm"> * must check for &quot;Unknown&quot; in the buffer to detect a failure.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns: size of formatted string.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">ssize_t</span>
<span class="nf">lpfc_max_xri_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span>
		  <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span>  <span class="o">*</span><span class="n">shost</span> <span class="o">=</span> <span class="n">class_to_shost</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="n">vport</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="p">)</span> <span class="n">shost</span><span class="o">-&gt;</span><span class="n">hostdata</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_hba</span>   <span class="o">*</span><span class="n">phba</span> <span class="o">=</span> <span class="n">vport</span><span class="o">-&gt;</span><span class="n">phba</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">cnt</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">lpfc_get_hba_info</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cnt</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">snprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">PAGE_SIZE</span><span class="p">,</span> <span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">cnt</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">snprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">PAGE_SIZE</span><span class="p">,</span> <span class="s">&quot;Unknown</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_used_xri_show - Return maximum xpi minus the available xpi</span>
<span class="cm"> * @dev: class device that is converted into a Scsi_host.</span>
<span class="cm"> * @attr: device attribute, not used.</span>
<span class="cm"> * @buf: on return contains the used xri count in decimal or &quot;Unknown&quot;.</span>
<span class="cm"> *</span>
<span class="cm"> * Description:</span>
<span class="cm"> * Calls lpfc_get_hba_info() asking for just the mxri and axri counts.</span>
<span class="cm"> * If lpfc_get_hba_info() returns zero (failure) the buffer text is set</span>
<span class="cm"> * to &quot;Unknown&quot; and the buffer length is returned, therefore the caller</span>
<span class="cm"> * must check for &quot;Unknown&quot; in the buffer to detect a failure.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns: size of formatted string.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">ssize_t</span>
<span class="nf">lpfc_used_xri_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span>
		   <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span>  <span class="o">*</span><span class="n">shost</span> <span class="o">=</span> <span class="n">class_to_shost</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="n">vport</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="p">)</span> <span class="n">shost</span><span class="o">-&gt;</span><span class="n">hostdata</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_hba</span>   <span class="o">*</span><span class="n">phba</span> <span class="o">=</span> <span class="n">vport</span><span class="o">-&gt;</span><span class="n">phba</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">cnt</span><span class="p">,</span> <span class="n">acnt</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">lpfc_get_hba_info</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cnt</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">acnt</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">snprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">PAGE_SIZE</span><span class="p">,</span> <span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">cnt</span> <span class="o">-</span> <span class="n">acnt</span><span class="p">));</span>
	<span class="k">return</span> <span class="n">snprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">PAGE_SIZE</span><span class="p">,</span> <span class="s">&quot;Unknown</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_max_vpi_show - Return maximum vpi</span>
<span class="cm"> * @dev: class device that is converted into a Scsi_host.</span>
<span class="cm"> * @attr: device attribute, not used.</span>
<span class="cm"> * @buf: on return contains the maximum vpi count in decimal or &quot;Unknown&quot;.</span>
<span class="cm"> *</span>
<span class="cm"> * Description:</span>
<span class="cm"> * Calls lpfc_get_hba_info() asking for just the mvpi count.</span>
<span class="cm"> * If lpfc_get_hba_info() returns zero (failure) the buffer text is set</span>
<span class="cm"> * to &quot;Unknown&quot; and the buffer length is returned, therefore the caller</span>
<span class="cm"> * must check for &quot;Unknown&quot; in the buffer to detect a failure.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns: size of formatted string.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">ssize_t</span>
<span class="nf">lpfc_max_vpi_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span>
		  <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span>  <span class="o">*</span><span class="n">shost</span> <span class="o">=</span> <span class="n">class_to_shost</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="n">vport</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="p">)</span> <span class="n">shost</span><span class="o">-&gt;</span><span class="n">hostdata</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_hba</span>   <span class="o">*</span><span class="n">phba</span> <span class="o">=</span> <span class="n">vport</span><span class="o">-&gt;</span><span class="n">phba</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">cnt</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">lpfc_get_hba_info</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cnt</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">snprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">PAGE_SIZE</span><span class="p">,</span> <span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">cnt</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">snprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">PAGE_SIZE</span><span class="p">,</span> <span class="s">&quot;Unknown</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_used_vpi_show - Return maximum vpi minus the available vpi</span>
<span class="cm"> * @dev: class device that is converted into a Scsi_host.</span>
<span class="cm"> * @attr: device attribute, not used.</span>
<span class="cm"> * @buf: on return contains the used vpi count in decimal or &quot;Unknown&quot;.</span>
<span class="cm"> *</span>
<span class="cm"> * Description:</span>
<span class="cm"> * Calls lpfc_get_hba_info() asking for just the mvpi and avpi counts.</span>
<span class="cm"> * If lpfc_get_hba_info() returns zero (failure) the buffer text is set</span>
<span class="cm"> * to &quot;Unknown&quot; and the buffer length is returned, therefore the caller</span>
<span class="cm"> * must check for &quot;Unknown&quot; in the buffer to detect a failure.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns: size of formatted string.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">ssize_t</span>
<span class="nf">lpfc_used_vpi_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span>
		   <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span>  <span class="o">*</span><span class="n">shost</span> <span class="o">=</span> <span class="n">class_to_shost</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="n">vport</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="p">)</span> <span class="n">shost</span><span class="o">-&gt;</span><span class="n">hostdata</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_hba</span>   <span class="o">*</span><span class="n">phba</span> <span class="o">=</span> <span class="n">vport</span><span class="o">-&gt;</span><span class="n">phba</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">cnt</span><span class="p">,</span> <span class="n">acnt</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">lpfc_get_hba_info</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cnt</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">acnt</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">snprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">PAGE_SIZE</span><span class="p">,</span> <span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">cnt</span> <span class="o">-</span> <span class="n">acnt</span><span class="p">));</span>
	<span class="k">return</span> <span class="n">snprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">PAGE_SIZE</span><span class="p">,</span> <span class="s">&quot;Unknown</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_npiv_info_show - Return text about NPIV support for the adapter</span>
<span class="cm"> * @dev: class device that is converted into a Scsi_host.</span>
<span class="cm"> * @attr: device attribute, not used.</span>
<span class="cm"> * @buf: text that must be interpreted to determine if npiv is supported.</span>
<span class="cm"> *</span>
<span class="cm"> * Description:</span>
<span class="cm"> * Buffer will contain text indicating npiv is not suppoerted on the port,</span>
<span class="cm"> * the port is an NPIV physical port, or it is an npiv virtual port with</span>
<span class="cm"> * the id of the vport.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns: size of formatted string.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">ssize_t</span>
<span class="nf">lpfc_npiv_info_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span>
		    <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span>  <span class="o">*</span><span class="n">shost</span> <span class="o">=</span> <span class="n">class_to_shost</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="n">vport</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="p">)</span> <span class="n">shost</span><span class="o">-&gt;</span><span class="n">hostdata</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_hba</span>   <span class="o">*</span><span class="n">phba</span> <span class="o">=</span> <span class="n">vport</span><span class="o">-&gt;</span><span class="n">phba</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">max_vpi</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">snprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">PAGE_SIZE</span><span class="p">,</span> <span class="s">&quot;NPIV Not Supported</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">port_type</span> <span class="o">==</span> <span class="n">LPFC_PHYSICAL_PORT</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">snprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">PAGE_SIZE</span><span class="p">,</span> <span class="s">&quot;NPIV Physical</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">snprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">PAGE_SIZE</span><span class="p">,</span> <span class="s">&quot;NPIV Virtual (VPI %d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">vport</span><span class="o">-&gt;</span><span class="n">vpi</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_poll_show - Return text about poll support for the adapter</span>
<span class="cm"> * @dev: class device that is converted into a Scsi_host.</span>
<span class="cm"> * @attr: device attribute, not used.</span>
<span class="cm"> * @buf: on return contains the cfg_poll in hex.</span>
<span class="cm"> *</span>
<span class="cm"> * Notes:</span>
<span class="cm"> * cfg_poll should be a lpfc_polling_flags type.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns: size of formatted string.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">ssize_t</span>
<span class="nf">lpfc_poll_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span>
	       <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span>  <span class="o">*</span><span class="n">shost</span> <span class="o">=</span> <span class="n">class_to_shost</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="n">vport</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="p">)</span> <span class="n">shost</span><span class="o">-&gt;</span><span class="n">hostdata</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_hba</span>   <span class="o">*</span><span class="n">phba</span> <span class="o">=</span> <span class="n">vport</span><span class="o">-&gt;</span><span class="n">phba</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">snprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">PAGE_SIZE</span><span class="p">,</span> <span class="s">&quot;%#x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">cfg_poll</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_poll_store - Set the value of cfg_poll for the adapter</span>
<span class="cm"> * @dev: class device that is converted into a Scsi_host.</span>
<span class="cm"> * @attr: device attribute, not used.</span>
<span class="cm"> * @buf: one or more lpfc_polling_flags values.</span>
<span class="cm"> * @count: not used.</span>
<span class="cm"> *</span>
<span class="cm"> * Notes:</span>
<span class="cm"> * buf contents converted to integer and checked for a valid value.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns:</span>
<span class="cm"> * -EINVAL if the buffer connot be converted or is out of range</span>
<span class="cm"> * length of the buf on success</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">ssize_t</span>
<span class="nf">lpfc_poll_store</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span>
		<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span>  <span class="o">*</span><span class="n">shost</span> <span class="o">=</span> <span class="n">class_to_shost</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="n">vport</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="p">)</span> <span class="n">shost</span><span class="o">-&gt;</span><span class="n">hostdata</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_hba</span>   <span class="o">*</span><span class="n">phba</span> <span class="o">=</span> <span class="n">vport</span><span class="o">-&gt;</span><span class="n">phba</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">creg_val</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">old_val</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">val</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">isdigit</span><span class="p">(</span><span class="n">buf</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sscanf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;%i&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">val</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">val</span> <span class="o">&amp;</span> <span class="mh">0x3</span><span class="p">)</span> <span class="o">!=</span> <span class="n">val</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli_rev</span> <span class="o">==</span> <span class="n">LPFC_SLI_REV4</span><span class="p">)</span>
		<span class="n">val</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">lpfc_printf_vlog</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_INIT</span><span class="p">,</span>
		<span class="s">&quot;3051 lpfc_poll changed from %d to %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">cfg_poll</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>

	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>

	<span class="n">old_val</span> <span class="o">=</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">cfg_poll</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">val</span> <span class="o">&amp;</span> <span class="n">ENABLE_FCP_RING_POLLING</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">val</span> <span class="o">&amp;</span> <span class="n">DISABLE_FCP_RING_INT</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="o">!</span><span class="p">(</span><span class="n">old_val</span> <span class="o">&amp;</span> <span class="n">DISABLE_FCP_RING_INT</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">lpfc_readl</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">HCregaddr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">creg_val</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>
				<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">creg_val</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">HC_R0INT_ENA</span> <span class="o">&lt;&lt;</span> <span class="n">LPFC_FCP_RING</span><span class="p">);</span>
			<span class="n">writel</span><span class="p">(</span><span class="n">creg_val</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">HCregaddr</span><span class="p">);</span>
			<span class="n">readl</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">HCregaddr</span><span class="p">);</span> <span class="cm">/* flush */</span>

			<span class="n">lpfc_poll_start_timer</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">val</span> <span class="o">!=</span> <span class="mh">0x0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">val</span> <span class="o">&amp;</span> <span class="n">DISABLE_FCP_RING_INT</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">old_val</span> <span class="o">&amp;</span> <span class="n">DISABLE_FCP_RING_INT</span><span class="p">))</span>
	<span class="p">{</span>
		<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>
		<span class="n">del_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">fcp_poll_timer</span><span class="p">);</span>
		<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">lpfc_readl</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">HCregaddr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">creg_val</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">creg_val</span> <span class="o">|=</span> <span class="p">(</span><span class="n">HC_R0INT_ENA</span> <span class="o">&lt;&lt;</span> <span class="n">LPFC_FCP_RING</span><span class="p">);</span>
		<span class="n">writel</span><span class="p">(</span><span class="n">creg_val</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">HCregaddr</span><span class="p">);</span>
		<span class="n">readl</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">HCregaddr</span><span class="p">);</span> <span class="cm">/* flush */</span>
	<span class="p">}</span>

	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">cfg_poll</span> <span class="o">=</span> <span class="n">val</span><span class="p">;</span>

	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">strlen</span><span class="p">(</span><span class="n">buf</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_fips_level_show - Return the current FIPS level for the HBA</span>
<span class="cm"> * @dev: class unused variable.</span>
<span class="cm"> * @attr: device attribute, not used.</span>
<span class="cm"> * @buf: on return contains the module description text.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns: size of formatted string.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">ssize_t</span>
<span class="nf">lpfc_fips_level_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>  <span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span>
		     <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span>  <span class="o">*</span><span class="n">shost</span> <span class="o">=</span> <span class="n">class_to_shost</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="n">vport</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="p">)</span> <span class="n">shost</span><span class="o">-&gt;</span><span class="n">hostdata</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_hba</span>   <span class="o">*</span><span class="n">phba</span> <span class="o">=</span> <span class="n">vport</span><span class="o">-&gt;</span><span class="n">phba</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">snprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">PAGE_SIZE</span><span class="p">,</span> <span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">fips_level</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_fips_rev_show - Return the FIPS Spec revision for the HBA</span>
<span class="cm"> * @dev: class unused variable.</span>
<span class="cm"> * @attr: device attribute, not used.</span>
<span class="cm"> * @buf: on return contains the module description text.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns: size of formatted string.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">ssize_t</span>
<span class="nf">lpfc_fips_rev_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>  <span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span>
		   <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span>  <span class="o">*</span><span class="n">shost</span> <span class="o">=</span> <span class="n">class_to_shost</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="n">vport</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="p">)</span> <span class="n">shost</span><span class="o">-&gt;</span><span class="n">hostdata</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_hba</span>   <span class="o">*</span><span class="n">phba</span> <span class="o">=</span> <span class="n">vport</span><span class="o">-&gt;</span><span class="n">phba</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">snprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">PAGE_SIZE</span><span class="p">,</span> <span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">fips_spec_rev</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_dss_show - Return the current state of dss and the configured state</span>
<span class="cm"> * @dev: class converted to a Scsi_host structure.</span>
<span class="cm"> * @attr: device attribute, not used.</span>
<span class="cm"> * @buf: on return contains the formatted text.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns: size of formatted string.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">ssize_t</span>
<span class="nf">lpfc_dss_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span>
	      <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span> <span class="o">=</span> <span class="n">class_to_shost</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="n">vport</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="p">)</span> <span class="n">shost</span><span class="o">-&gt;</span><span class="n">hostdata</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_hba</span>   <span class="o">*</span><span class="n">phba</span> <span class="o">=</span> <span class="n">vport</span><span class="o">-&gt;</span><span class="n">phba</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">snprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">PAGE_SIZE</span><span class="p">,</span> <span class="s">&quot;%s - %sOperational</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">cfg_enable_dss</span><span class="p">)</span> <span class="o">?</span> <span class="s">&quot;Enabled&quot;</span> <span class="o">:</span> <span class="s">&quot;Disabled&quot;</span><span class="p">,</span>
			<span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli3_options</span> <span class="o">&amp;</span> <span class="n">LPFC_SLI3_DSS_ENABLED</span><span class="p">)</span> <span class="o">?</span>
				<span class="s">&quot;&quot;</span> <span class="o">:</span> <span class="s">&quot;Not &quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_sriov_hw_max_virtfn_show - Return maximum number of virtual functions</span>
<span class="cm"> * @dev: class converted to a Scsi_host structure.</span>
<span class="cm"> * @attr: device attribute, not used.</span>
<span class="cm"> * @buf: on return contains the formatted support level.</span>
<span class="cm"> *</span>
<span class="cm"> * Description:</span>
<span class="cm"> * Returns the maximum number of virtual functions a physical function can</span>
<span class="cm"> * support, 0 will be returned if called on virtual function.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns: size of formatted string.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">ssize_t</span>
<span class="nf">lpfc_sriov_hw_max_virtfn_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span>
			      <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span> <span class="o">=</span> <span class="n">class_to_shost</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="n">vport</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="p">)</span> <span class="n">shost</span><span class="o">-&gt;</span><span class="n">hostdata</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span> <span class="o">=</span> <span class="n">vport</span><span class="o">-&gt;</span><span class="n">phba</span><span class="p">;</span>
	<span class="kt">uint16_t</span> <span class="n">max_nr_virtfn</span><span class="p">;</span>

	<span class="n">max_nr_virtfn</span> <span class="o">=</span> <span class="n">lpfc_sli_sriov_nr_virtfn_get</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">snprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">PAGE_SIZE</span><span class="p">,</span> <span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">max_nr_virtfn</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_param_show - Return a cfg attribute value in decimal</span>
<span class="cm"> *</span>
<span class="cm"> * Description:</span>
<span class="cm"> * Macro that given an attr e.g. hba_queue_depth expands</span>
<span class="cm"> * into a function with the name lpfc_hba_queue_depth_show.</span>
<span class="cm"> *</span>
<span class="cm"> * lpfc_##attr##_show: Return the decimal value of an adapters cfg_xxx field.</span>
<span class="cm"> * @dev: class device that is converted into a Scsi_host.</span>
<span class="cm"> * @attr: device attribute, not used.</span>
<span class="cm"> * @buf: on return contains the attribute value in decimal.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns: size of formatted string.</span>
<span class="cm"> **/</span>
<span class="cp">#define lpfc_param_show(attr)	\</span>
<span class="cp">static ssize_t \</span>
<span class="cp">lpfc_##attr##_show(struct device *dev, struct device_attribute *attr, \</span>
<span class="cp">		   char *buf) \</span>
<span class="cp">{ \</span>
<span class="cp">	struct Scsi_Host  *shost = class_to_shost(dev);\</span>
<span class="cp">	struct lpfc_vport *vport = (struct lpfc_vport *) shost-&gt;hostdata;\</span>
<span class="cp">	struct lpfc_hba   *phba = vport-&gt;phba;\</span>
<span class="cp">	uint val = 0;\</span>
<span class="cp">	val = phba-&gt;cfg_##attr;\</span>
<span class="cp">	return snprintf(buf, PAGE_SIZE, &quot;%d\n&quot;,\</span>
<span class="cp">			phba-&gt;cfg_##attr);\</span>
<span class="cp">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_param_hex_show - Return a cfg attribute value in hex</span>
<span class="cm"> *</span>
<span class="cm"> * Description:</span>
<span class="cm"> * Macro that given an attr e.g. hba_queue_depth expands</span>
<span class="cm"> * into a function with the name lpfc_hba_queue_depth_show</span>
<span class="cm"> *</span>
<span class="cm"> * lpfc_##attr##_show: Return the hex value of an adapters cfg_xxx field.</span>
<span class="cm"> * @dev: class device that is converted into a Scsi_host.</span>
<span class="cm"> * @attr: device attribute, not used.</span>
<span class="cm"> * @buf: on return contains the attribute value in hexadecimal.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns: size of formatted string.</span>
<span class="cm"> **/</span>
<span class="cp">#define lpfc_param_hex_show(attr)	\</span>
<span class="cp">static ssize_t \</span>
<span class="cp">lpfc_##attr##_show(struct device *dev, struct device_attribute *attr, \</span>
<span class="cp">		   char *buf) \</span>
<span class="cp">{ \</span>
<span class="cp">	struct Scsi_Host  *shost = class_to_shost(dev);\</span>
<span class="cp">	struct lpfc_vport *vport = (struct lpfc_vport *) shost-&gt;hostdata;\</span>
<span class="cp">	struct lpfc_hba   *phba = vport-&gt;phba;\</span>
<span class="cp">	uint val = 0;\</span>
<span class="cp">	val = phba-&gt;cfg_##attr;\</span>
<span class="cp">	return snprintf(buf, PAGE_SIZE, &quot;%#x\n&quot;,\</span>
<span class="cp">			phba-&gt;cfg_##attr);\</span>
<span class="cp">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_param_init - Initializes a cfg attribute</span>
<span class="cm"> *</span>
<span class="cm"> * Description:</span>
<span class="cm"> * Macro that given an attr e.g. hba_queue_depth expands</span>
<span class="cm"> * into a function with the name lpfc_hba_queue_depth_init. The macro also</span>
<span class="cm"> * takes a default argument, a minimum and maximum argument.</span>
<span class="cm"> *</span>
<span class="cm"> * lpfc_##attr##_init: Initializes an attribute.</span>
<span class="cm"> * @phba: pointer the the adapter structure.</span>
<span class="cm"> * @val: integer attribute value.</span>
<span class="cm"> *</span>
<span class="cm"> * Validates the min and max values then sets the adapter config field</span>
<span class="cm"> * accordingly, or uses the default if out of range and prints an error message.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns:</span>
<span class="cm"> * zero on success</span>
<span class="cm"> * -EINVAL if default used</span>
<span class="cm"> **/</span>
<span class="cp">#define lpfc_param_init(attr, default, minval, maxval)	\</span>
<span class="cp">static int \</span>
<span class="cp">lpfc_##attr##_init(struct lpfc_hba *phba, uint val) \</span>
<span class="cp">{ \</span>
<span class="cp">	if (val &gt;= minval &amp;&amp; val &lt;= maxval) {\</span>
<span class="cp">		phba-&gt;cfg_##attr = val;\</span>
<span class="cp">		return 0;\</span>
<span class="cp">	}\</span>
<span class="cp">	lpfc_printf_log(phba, KERN_ERR, LOG_INIT, \</span>
<span class="cp">			&quot;0449 lpfc_&quot;#attr&quot; attribute cannot be set to %d, &quot;\</span>
<span class="cp">			&quot;allowed range is [&quot;#minval&quot;, &quot;#maxval&quot;]\n&quot;, val); \</span>
<span class="cp">	phba-&gt;cfg_##attr = default;\</span>
<span class="cp">	return -EINVAL;\</span>
<span class="cp">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_param_set - Set a cfg attribute value</span>
<span class="cm"> *</span>
<span class="cm"> * Description:</span>
<span class="cm"> * Macro that given an attr e.g. hba_queue_depth expands</span>
<span class="cm"> * into a function with the name lpfc_hba_queue_depth_set</span>
<span class="cm"> *</span>
<span class="cm"> * lpfc_##attr##_set: Sets an attribute value.</span>
<span class="cm"> * @phba: pointer the the adapter structure.</span>
<span class="cm"> * @val: integer attribute value.</span>
<span class="cm"> *</span>
<span class="cm"> * Description:</span>
<span class="cm"> * Validates the min and max values then sets the</span>
<span class="cm"> * adapter config field if in the valid range. prints error message</span>
<span class="cm"> * and does not set the parameter if invalid.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns:</span>
<span class="cm"> * zero on success</span>
<span class="cm"> * -EINVAL if val is invalid</span>
<span class="cm"> **/</span>
<span class="cp">#define lpfc_param_set(attr, default, minval, maxval)	\</span>
<span class="cp">static int \</span>
<span class="cp">lpfc_##attr##_set(struct lpfc_hba *phba, uint val) \</span>
<span class="cp">{ \</span>
<span class="cp">	if (val &gt;= minval &amp;&amp; val &lt;= maxval) {\</span>
<span class="cp">		lpfc_printf_log(phba, KERN_ERR, LOG_INIT, \</span>
<span class="cp">			&quot;3052 lpfc_&quot; #attr &quot; changed from %d to %d\n&quot;, \</span>
<span class="cp">			phba-&gt;cfg_##attr, val); \</span>
<span class="cp">		phba-&gt;cfg_##attr = val;\</span>
<span class="cp">		return 0;\</span>
<span class="cp">	}\</span>
<span class="cp">	lpfc_printf_log(phba, KERN_ERR, LOG_INIT, \</span>
<span class="cp">			&quot;0450 lpfc_&quot;#attr&quot; attribute cannot be set to %d, &quot;\</span>
<span class="cp">			&quot;allowed range is [&quot;#minval&quot;, &quot;#maxval&quot;]\n&quot;, val); \</span>
<span class="cp">	return -EINVAL;\</span>
<span class="cp">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_param_store - Set a vport attribute value</span>
<span class="cm"> *</span>
<span class="cm"> * Description:</span>
<span class="cm"> * Macro that given an attr e.g. hba_queue_depth expands</span>
<span class="cm"> * into a function with the name lpfc_hba_queue_depth_store.</span>
<span class="cm"> *</span>
<span class="cm"> * lpfc_##attr##_store: Set an sttribute value.</span>
<span class="cm"> * @dev: class device that is converted into a Scsi_host.</span>
<span class="cm"> * @attr: device attribute, not used.</span>
<span class="cm"> * @buf: contains the attribute value in ascii.</span>
<span class="cm"> * @count: not used.</span>
<span class="cm"> *</span>
<span class="cm"> * Description:</span>
<span class="cm"> * Convert the ascii text number to an integer, then</span>
<span class="cm"> * use the lpfc_##attr##_set function to set the value.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns:</span>
<span class="cm"> * -EINVAL if val is invalid or lpfc_##attr##_set() fails</span>
<span class="cm"> * length of buffer upon success.</span>
<span class="cm"> **/</span>
<span class="cp">#define lpfc_param_store(attr)	\</span>
<span class="cp">static ssize_t \</span>
<span class="cp">lpfc_##attr##_store(struct device *dev, struct device_attribute *attr, \</span>
<span class="cp">		    const char *buf, size_t count) \</span>
<span class="cp">{ \</span>
<span class="cp">	struct Scsi_Host  *shost = class_to_shost(dev);\</span>
<span class="cp">	struct lpfc_vport *vport = (struct lpfc_vport *) shost-&gt;hostdata;\</span>
<span class="cp">	struct lpfc_hba   *phba = vport-&gt;phba;\</span>
<span class="cp">	uint val = 0;\</span>
<span class="cp">	if (!isdigit(buf[0]))\</span>
<span class="cp">		return -EINVAL;\</span>
<span class="cp">	if (sscanf(buf, &quot;%i&quot;, &amp;val) != 1)\</span>
<span class="cp">		return -EINVAL;\</span>
<span class="cp">	if (lpfc_##attr##_set(phba, val) == 0) \</span>
<span class="cp">		return strlen(buf);\</span>
<span class="cp">	else \</span>
<span class="cp">		return -EINVAL;\</span>
<span class="cp">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_vport_param_show - Return decimal formatted cfg attribute value</span>
<span class="cm"> *</span>
<span class="cm"> * Description:</span>
<span class="cm"> * Macro that given an attr e.g. hba_queue_depth expands</span>
<span class="cm"> * into a function with the name lpfc_hba_queue_depth_show</span>
<span class="cm"> *</span>
<span class="cm"> * lpfc_##attr##_show: prints the attribute value in decimal.</span>
<span class="cm"> * @dev: class device that is converted into a Scsi_host.</span>
<span class="cm"> * @attr: device attribute, not used.</span>
<span class="cm"> * @buf: on return contains the attribute value in decimal.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns: length of formatted string.</span>
<span class="cm"> **/</span>
<span class="cp">#define lpfc_vport_param_show(attr)	\</span>
<span class="cp">static ssize_t \</span>
<span class="cp">lpfc_##attr##_show(struct device *dev, struct device_attribute *attr, \</span>
<span class="cp">		   char *buf) \</span>
<span class="cp">{ \</span>
<span class="cp">	struct Scsi_Host  *shost = class_to_shost(dev);\</span>
<span class="cp">	struct lpfc_vport *vport = (struct lpfc_vport *) shost-&gt;hostdata;\</span>
<span class="cp">	uint val = 0;\</span>
<span class="cp">	val = vport-&gt;cfg_##attr;\</span>
<span class="cp">	return snprintf(buf, PAGE_SIZE, &quot;%d\n&quot;, vport-&gt;cfg_##attr);\</span>
<span class="cp">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_vport_param_hex_show - Return hex formatted attribute value</span>
<span class="cm"> *</span>
<span class="cm"> * Description:</span>
<span class="cm"> * Macro that given an attr e.g.</span>
<span class="cm"> * hba_queue_depth expands into a function with the name</span>
<span class="cm"> * lpfc_hba_queue_depth_show</span>
<span class="cm"> *</span>
<span class="cm"> * lpfc_##attr##_show: prints the attribute value in hexadecimal.</span>
<span class="cm"> * @dev: class device that is converted into a Scsi_host.</span>
<span class="cm"> * @attr: device attribute, not used.</span>
<span class="cm"> * @buf: on return contains the attribute value in hexadecimal.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns: length of formatted string.</span>
<span class="cm"> **/</span>
<span class="cp">#define lpfc_vport_param_hex_show(attr)	\</span>
<span class="cp">static ssize_t \</span>
<span class="cp">lpfc_##attr##_show(struct device *dev, struct device_attribute *attr, \</span>
<span class="cp">		   char *buf) \</span>
<span class="cp">{ \</span>
<span class="cp">	struct Scsi_Host  *shost = class_to_shost(dev);\</span>
<span class="cp">	struct lpfc_vport *vport = (struct lpfc_vport *) shost-&gt;hostdata;\</span>
<span class="cp">	uint val = 0;\</span>
<span class="cp">	val = vport-&gt;cfg_##attr;\</span>
<span class="cp">	return snprintf(buf, PAGE_SIZE, &quot;%#x\n&quot;, vport-&gt;cfg_##attr);\</span>
<span class="cp">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_vport_param_init - Initialize a vport cfg attribute</span>
<span class="cm"> *</span>
<span class="cm"> * Description:</span>
<span class="cm"> * Macro that given an attr e.g. hba_queue_depth expands</span>
<span class="cm"> * into a function with the name lpfc_hba_queue_depth_init. The macro also</span>
<span class="cm"> * takes a default argument, a minimum and maximum argument.</span>
<span class="cm"> *</span>
<span class="cm"> * lpfc_##attr##_init: validates the min and max values then sets the</span>
<span class="cm"> * adapter config field accordingly, or uses the default if out of range</span>
<span class="cm"> * and prints an error message.</span>
<span class="cm"> * @phba: pointer the the adapter structure.</span>
<span class="cm"> * @val: integer attribute value.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns:</span>
<span class="cm"> * zero on success</span>
<span class="cm"> * -EINVAL if default used</span>
<span class="cm"> **/</span>
<span class="cp">#define lpfc_vport_param_init(attr, default, minval, maxval)	\</span>
<span class="cp">static int \</span>
<span class="cp">lpfc_##attr##_init(struct lpfc_vport *vport, uint val) \</span>
<span class="cp">{ \</span>
<span class="cp">	if (val &gt;= minval &amp;&amp; val &lt;= maxval) {\</span>
<span class="cp">		vport-&gt;cfg_##attr = val;\</span>
<span class="cp">		return 0;\</span>
<span class="cp">	}\</span>
<span class="cp">	lpfc_printf_vlog(vport, KERN_ERR, LOG_INIT, \</span>
<span class="cp">			 &quot;0423 lpfc_&quot;#attr&quot; attribute cannot be set to %d, &quot;\</span>
<span class="cp">			 &quot;allowed range is [&quot;#minval&quot;, &quot;#maxval&quot;]\n&quot;, val); \</span>
<span class="cp">	vport-&gt;cfg_##attr = default;\</span>
<span class="cp">	return -EINVAL;\</span>
<span class="cp">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_vport_param_set - Set a vport cfg attribute</span>
<span class="cm"> *</span>
<span class="cm"> * Description:</span>
<span class="cm"> * Macro that given an attr e.g. hba_queue_depth expands</span>
<span class="cm"> * into a function with the name lpfc_hba_queue_depth_set</span>
<span class="cm"> *</span>
<span class="cm"> * lpfc_##attr##_set: validates the min and max values then sets the</span>
<span class="cm"> * adapter config field if in the valid range. prints error message</span>
<span class="cm"> * and does not set the parameter if invalid.</span>
<span class="cm"> * @phba: pointer the the adapter structure.</span>
<span class="cm"> * @val:	integer attribute value.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns:</span>
<span class="cm"> * zero on success</span>
<span class="cm"> * -EINVAL if val is invalid</span>
<span class="cm"> **/</span>
<span class="cp">#define lpfc_vport_param_set(attr, default, minval, maxval)	\</span>
<span class="cp">static int \</span>
<span class="cp">lpfc_##attr##_set(struct lpfc_vport *vport, uint val) \</span>
<span class="cp">{ \</span>
<span class="cp">	if (val &gt;= minval &amp;&amp; val &lt;= maxval) {\</span>
<span class="cp">		lpfc_printf_vlog(vport, KERN_ERR, LOG_INIT, \</span>
<span class="cp">			&quot;3053 lpfc_&quot; #attr &quot; changed from %d to %d\n&quot;, \</span>
<span class="cp">			vport-&gt;cfg_##attr, val); \</span>
<span class="cp">		vport-&gt;cfg_##attr = val;\</span>
<span class="cp">		return 0;\</span>
<span class="cp">	}\</span>
<span class="cp">	lpfc_printf_vlog(vport, KERN_ERR, LOG_INIT, \</span>
<span class="cp">			 &quot;0424 lpfc_&quot;#attr&quot; attribute cannot be set to %d, &quot;\</span>
<span class="cp">			 &quot;allowed range is [&quot;#minval&quot;, &quot;#maxval&quot;]\n&quot;, val); \</span>
<span class="cp">	return -EINVAL;\</span>
<span class="cp">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_vport_param_store - Set a vport attribute</span>
<span class="cm"> *</span>
<span class="cm"> * Description:</span>
<span class="cm"> * Macro that given an attr e.g. hba_queue_depth</span>
<span class="cm"> * expands into a function with the name lpfc_hba_queue_depth_store</span>
<span class="cm"> *</span>
<span class="cm"> * lpfc_##attr##_store: convert the ascii text number to an integer, then</span>
<span class="cm"> * use the lpfc_##attr##_set function to set the value.</span>
<span class="cm"> * @cdev: class device that is converted into a Scsi_host.</span>
<span class="cm"> * @buf:	contains the attribute value in decimal.</span>
<span class="cm"> * @count: not used.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns:</span>
<span class="cm"> * -EINVAL if val is invalid or lpfc_##attr##_set() fails</span>
<span class="cm"> * length of buffer upon success.</span>
<span class="cm"> **/</span>
<span class="cp">#define lpfc_vport_param_store(attr)	\</span>
<span class="cp">static ssize_t \</span>
<span class="cp">lpfc_##attr##_store(struct device *dev, struct device_attribute *attr, \</span>
<span class="cp">		    const char *buf, size_t count) \</span>
<span class="cp">{ \</span>
<span class="cp">	struct Scsi_Host  *shost = class_to_shost(dev);\</span>
<span class="cp">	struct lpfc_vport *vport = (struct lpfc_vport *) shost-&gt;hostdata;\</span>
<span class="cp">	uint val = 0;\</span>
<span class="cp">	if (!isdigit(buf[0]))\</span>
<span class="cp">		return -EINVAL;\</span>
<span class="cp">	if (sscanf(buf, &quot;%i&quot;, &amp;val) != 1)\</span>
<span class="cp">		return -EINVAL;\</span>
<span class="cp">	if (lpfc_##attr##_set(vport, val) == 0) \</span>
<span class="cp">		return strlen(buf);\</span>
<span class="cp">	else \</span>
<span class="cp">		return -EINVAL;\</span>
<span class="cp">}</span>


<span class="cp">#define LPFC_ATTR(name, defval, minval, maxval, desc) \</span>
<span class="cp">static uint lpfc_##name = defval;\</span>
<span class="cp">module_param(lpfc_##name, uint, S_IRUGO);\</span>
<span class="cp">MODULE_PARM_DESC(lpfc_##name, desc);\</span>
<span class="cp">lpfc_param_init(name, defval, minval, maxval)</span>

<span class="cp">#define LPFC_ATTR_R(name, defval, minval, maxval, desc) \</span>
<span class="cp">static uint lpfc_##name = defval;\</span>
<span class="cp">module_param(lpfc_##name, uint, S_IRUGO);\</span>
<span class="cp">MODULE_PARM_DESC(lpfc_##name, desc);\</span>
<span class="cp">lpfc_param_show(name)\</span>
<span class="cp">lpfc_param_init(name, defval, minval, maxval)\</span>
<span class="cp">static DEVICE_ATTR(lpfc_##name, S_IRUGO , lpfc_##name##_show, NULL)</span>

<span class="cp">#define LPFC_ATTR_RW(name, defval, minval, maxval, desc) \</span>
<span class="cp">static uint lpfc_##name = defval;\</span>
<span class="cp">module_param(lpfc_##name, uint, S_IRUGO);\</span>
<span class="cp">MODULE_PARM_DESC(lpfc_##name, desc);\</span>
<span class="cp">lpfc_param_show(name)\</span>
<span class="cp">lpfc_param_init(name, defval, minval, maxval)\</span>
<span class="cp">lpfc_param_set(name, defval, minval, maxval)\</span>
<span class="cp">lpfc_param_store(name)\</span>
<span class="cp">static DEVICE_ATTR(lpfc_##name, S_IRUGO | S_IWUSR,\</span>
<span class="cp">		   lpfc_##name##_show, lpfc_##name##_store)</span>

<span class="cp">#define LPFC_ATTR_HEX_R(name, defval, minval, maxval, desc) \</span>
<span class="cp">static uint lpfc_##name = defval;\</span>
<span class="cp">module_param(lpfc_##name, uint, S_IRUGO);\</span>
<span class="cp">MODULE_PARM_DESC(lpfc_##name, desc);\</span>
<span class="cp">lpfc_param_hex_show(name)\</span>
<span class="cp">lpfc_param_init(name, defval, minval, maxval)\</span>
<span class="cp">static DEVICE_ATTR(lpfc_##name, S_IRUGO , lpfc_##name##_show, NULL)</span>

<span class="cp">#define LPFC_ATTR_HEX_RW(name, defval, minval, maxval, desc) \</span>
<span class="cp">static uint lpfc_##name = defval;\</span>
<span class="cp">module_param(lpfc_##name, uint, S_IRUGO);\</span>
<span class="cp">MODULE_PARM_DESC(lpfc_##name, desc);\</span>
<span class="cp">lpfc_param_hex_show(name)\</span>
<span class="cp">lpfc_param_init(name, defval, minval, maxval)\</span>
<span class="cp">lpfc_param_set(name, defval, minval, maxval)\</span>
<span class="cp">lpfc_param_store(name)\</span>
<span class="cp">static DEVICE_ATTR(lpfc_##name, S_IRUGO | S_IWUSR,\</span>
<span class="cp">		   lpfc_##name##_show, lpfc_##name##_store)</span>

<span class="cp">#define LPFC_VPORT_ATTR(name, defval, minval, maxval, desc) \</span>
<span class="cp">static uint lpfc_##name = defval;\</span>
<span class="cp">module_param(lpfc_##name, uint, S_IRUGO);\</span>
<span class="cp">MODULE_PARM_DESC(lpfc_##name, desc);\</span>
<span class="cp">lpfc_vport_param_init(name, defval, minval, maxval)</span>

<span class="cp">#define LPFC_VPORT_ATTR_R(name, defval, minval, maxval, desc) \</span>
<span class="cp">static uint lpfc_##name = defval;\</span>
<span class="cp">module_param(lpfc_##name, uint, S_IRUGO);\</span>
<span class="cp">MODULE_PARM_DESC(lpfc_##name, desc);\</span>
<span class="cp">lpfc_vport_param_show(name)\</span>
<span class="cp">lpfc_vport_param_init(name, defval, minval, maxval)\</span>
<span class="cp">static DEVICE_ATTR(lpfc_##name, S_IRUGO , lpfc_##name##_show, NULL)</span>

<span class="cp">#define LPFC_VPORT_ATTR_RW(name, defval, minval, maxval, desc) \</span>
<span class="cp">static uint lpfc_##name = defval;\</span>
<span class="cp">module_param(lpfc_##name, uint, S_IRUGO);\</span>
<span class="cp">MODULE_PARM_DESC(lpfc_##name, desc);\</span>
<span class="cp">lpfc_vport_param_show(name)\</span>
<span class="cp">lpfc_vport_param_init(name, defval, minval, maxval)\</span>
<span class="cp">lpfc_vport_param_set(name, defval, minval, maxval)\</span>
<span class="cp">lpfc_vport_param_store(name)\</span>
<span class="cp">static DEVICE_ATTR(lpfc_##name, S_IRUGO | S_IWUSR,\</span>
<span class="cp">		   lpfc_##name##_show, lpfc_##name##_store)</span>

<span class="cp">#define LPFC_VPORT_ATTR_HEX_R(name, defval, minval, maxval, desc) \</span>
<span class="cp">static uint lpfc_##name = defval;\</span>
<span class="cp">module_param(lpfc_##name, uint, S_IRUGO);\</span>
<span class="cp">MODULE_PARM_DESC(lpfc_##name, desc);\</span>
<span class="cp">lpfc_vport_param_hex_show(name)\</span>
<span class="cp">lpfc_vport_param_init(name, defval, minval, maxval)\</span>
<span class="cp">static DEVICE_ATTR(lpfc_##name, S_IRUGO , lpfc_##name##_show, NULL)</span>

<span class="cp">#define LPFC_VPORT_ATTR_HEX_RW(name, defval, minval, maxval, desc) \</span>
<span class="cp">static uint lpfc_##name = defval;\</span>
<span class="cp">module_param(lpfc_##name, uint, S_IRUGO);\</span>
<span class="cp">MODULE_PARM_DESC(lpfc_##name, desc);\</span>
<span class="cp">lpfc_vport_param_hex_show(name)\</span>
<span class="cp">lpfc_vport_param_init(name, defval, minval, maxval)\</span>
<span class="cp">lpfc_vport_param_set(name, defval, minval, maxval)\</span>
<span class="cp">lpfc_vport_param_store(name)\</span>
<span class="cp">static DEVICE_ATTR(lpfc_##name, S_IRUGO | S_IWUSR,\</span>
<span class="cp">		   lpfc_##name##_show, lpfc_##name##_store)</span>

<span class="k">static</span> <span class="n">DEVICE_ATTR</span><span class="p">(</span><span class="n">bg_info</span><span class="p">,</span> <span class="n">S_IRUGO</span><span class="p">,</span> <span class="n">lpfc_bg_info_show</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="k">static</span> <span class="n">DEVICE_ATTR</span><span class="p">(</span><span class="n">bg_guard_err</span><span class="p">,</span> <span class="n">S_IRUGO</span><span class="p">,</span> <span class="n">lpfc_bg_guard_err_show</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="k">static</span> <span class="n">DEVICE_ATTR</span><span class="p">(</span><span class="n">bg_apptag_err</span><span class="p">,</span> <span class="n">S_IRUGO</span><span class="p">,</span> <span class="n">lpfc_bg_apptag_err_show</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="k">static</span> <span class="n">DEVICE_ATTR</span><span class="p">(</span><span class="n">bg_reftag_err</span><span class="p">,</span> <span class="n">S_IRUGO</span><span class="p">,</span> <span class="n">lpfc_bg_reftag_err_show</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="k">static</span> <span class="n">DEVICE_ATTR</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="n">S_IRUGO</span><span class="p">,</span> <span class="n">lpfc_info_show</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="k">static</span> <span class="n">DEVICE_ATTR</span><span class="p">(</span><span class="n">serialnum</span><span class="p">,</span> <span class="n">S_IRUGO</span><span class="p">,</span> <span class="n">lpfc_serialnum_show</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="k">static</span> <span class="n">DEVICE_ATTR</span><span class="p">(</span><span class="n">modeldesc</span><span class="p">,</span> <span class="n">S_IRUGO</span><span class="p">,</span> <span class="n">lpfc_modeldesc_show</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="k">static</span> <span class="n">DEVICE_ATTR</span><span class="p">(</span><span class="n">modelname</span><span class="p">,</span> <span class="n">S_IRUGO</span><span class="p">,</span> <span class="n">lpfc_modelname_show</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="k">static</span> <span class="n">DEVICE_ATTR</span><span class="p">(</span><span class="n">programtype</span><span class="p">,</span> <span class="n">S_IRUGO</span><span class="p">,</span> <span class="n">lpfc_programtype_show</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="k">static</span> <span class="n">DEVICE_ATTR</span><span class="p">(</span><span class="n">portnum</span><span class="p">,</span> <span class="n">S_IRUGO</span><span class="p">,</span> <span class="n">lpfc_vportnum_show</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="k">static</span> <span class="n">DEVICE_ATTR</span><span class="p">(</span><span class="n">fwrev</span><span class="p">,</span> <span class="n">S_IRUGO</span><span class="p">,</span> <span class="n">lpfc_fwrev_show</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="k">static</span> <span class="n">DEVICE_ATTR</span><span class="p">(</span><span class="n">hdw</span><span class="p">,</span> <span class="n">S_IRUGO</span><span class="p">,</span> <span class="n">lpfc_hdw_show</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="k">static</span> <span class="n">DEVICE_ATTR</span><span class="p">(</span><span class="n">link_state</span><span class="p">,</span> <span class="n">S_IRUGO</span> <span class="o">|</span> <span class="n">S_IWUSR</span><span class="p">,</span> <span class="n">lpfc_link_state_show</span><span class="p">,</span>
		<span class="n">lpfc_link_state_store</span><span class="p">);</span>
<span class="k">static</span> <span class="n">DEVICE_ATTR</span><span class="p">(</span><span class="n">option_rom_version</span><span class="p">,</span> <span class="n">S_IRUGO</span><span class="p">,</span>
		   <span class="n">lpfc_option_rom_version_show</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="k">static</span> <span class="n">DEVICE_ATTR</span><span class="p">(</span><span class="n">num_discovered_ports</span><span class="p">,</span> <span class="n">S_IRUGO</span><span class="p">,</span>
		   <span class="n">lpfc_num_discovered_ports_show</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="k">static</span> <span class="n">DEVICE_ATTR</span><span class="p">(</span><span class="n">menlo_mgmt_mode</span><span class="p">,</span> <span class="n">S_IRUGO</span><span class="p">,</span> <span class="n">lpfc_mlomgmt_show</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="k">static</span> <span class="n">DEVICE_ATTR</span><span class="p">(</span><span class="n">nport_evt_cnt</span><span class="p">,</span> <span class="n">S_IRUGO</span><span class="p">,</span> <span class="n">lpfc_nport_evt_cnt_show</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="k">static</span> <span class="n">DEVICE_ATTR</span><span class="p">(</span><span class="n">lpfc_drvr_version</span><span class="p">,</span> <span class="n">S_IRUGO</span><span class="p">,</span> <span class="n">lpfc_drvr_version_show</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="k">static</span> <span class="n">DEVICE_ATTR</span><span class="p">(</span><span class="n">lpfc_enable_fip</span><span class="p">,</span> <span class="n">S_IRUGO</span><span class="p">,</span> <span class="n">lpfc_enable_fip_show</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="k">static</span> <span class="n">DEVICE_ATTR</span><span class="p">(</span><span class="n">board_mode</span><span class="p">,</span> <span class="n">S_IRUGO</span> <span class="o">|</span> <span class="n">S_IWUSR</span><span class="p">,</span>
		   <span class="n">lpfc_board_mode_show</span><span class="p">,</span> <span class="n">lpfc_board_mode_store</span><span class="p">);</span>
<span class="k">static</span> <span class="n">DEVICE_ATTR</span><span class="p">(</span><span class="n">issue_reset</span><span class="p">,</span> <span class="n">S_IWUSR</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">lpfc_issue_reset</span><span class="p">);</span>
<span class="k">static</span> <span class="n">DEVICE_ATTR</span><span class="p">(</span><span class="n">max_vpi</span><span class="p">,</span> <span class="n">S_IRUGO</span><span class="p">,</span> <span class="n">lpfc_max_vpi_show</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="k">static</span> <span class="n">DEVICE_ATTR</span><span class="p">(</span><span class="n">used_vpi</span><span class="p">,</span> <span class="n">S_IRUGO</span><span class="p">,</span> <span class="n">lpfc_used_vpi_show</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="k">static</span> <span class="n">DEVICE_ATTR</span><span class="p">(</span><span class="n">max_rpi</span><span class="p">,</span> <span class="n">S_IRUGO</span><span class="p">,</span> <span class="n">lpfc_max_rpi_show</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="k">static</span> <span class="n">DEVICE_ATTR</span><span class="p">(</span><span class="n">used_rpi</span><span class="p">,</span> <span class="n">S_IRUGO</span><span class="p">,</span> <span class="n">lpfc_used_rpi_show</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="k">static</span> <span class="n">DEVICE_ATTR</span><span class="p">(</span><span class="n">max_xri</span><span class="p">,</span> <span class="n">S_IRUGO</span><span class="p">,</span> <span class="n">lpfc_max_xri_show</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="k">static</span> <span class="n">DEVICE_ATTR</span><span class="p">(</span><span class="n">used_xri</span><span class="p">,</span> <span class="n">S_IRUGO</span><span class="p">,</span> <span class="n">lpfc_used_xri_show</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="k">static</span> <span class="n">DEVICE_ATTR</span><span class="p">(</span><span class="n">npiv_info</span><span class="p">,</span> <span class="n">S_IRUGO</span><span class="p">,</span> <span class="n">lpfc_npiv_info_show</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="k">static</span> <span class="n">DEVICE_ATTR</span><span class="p">(</span><span class="n">lpfc_temp_sensor</span><span class="p">,</span> <span class="n">S_IRUGO</span><span class="p">,</span> <span class="n">lpfc_temp_sensor_show</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="k">static</span> <span class="n">DEVICE_ATTR</span><span class="p">(</span><span class="n">lpfc_fips_level</span><span class="p">,</span> <span class="n">S_IRUGO</span><span class="p">,</span> <span class="n">lpfc_fips_level_show</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="k">static</span> <span class="n">DEVICE_ATTR</span><span class="p">(</span><span class="n">lpfc_fips_rev</span><span class="p">,</span> <span class="n">S_IRUGO</span><span class="p">,</span> <span class="n">lpfc_fips_rev_show</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="k">static</span> <span class="n">DEVICE_ATTR</span><span class="p">(</span><span class="n">lpfc_dss</span><span class="p">,</span> <span class="n">S_IRUGO</span><span class="p">,</span> <span class="n">lpfc_dss_show</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="k">static</span> <span class="n">DEVICE_ATTR</span><span class="p">(</span><span class="n">lpfc_sriov_hw_max_virtfn</span><span class="p">,</span> <span class="n">S_IRUGO</span><span class="p">,</span>
		   <span class="n">lpfc_sriov_hw_max_virtfn_show</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="k">static</span> <span class="n">DEVICE_ATTR</span><span class="p">(</span><span class="n">protocol</span><span class="p">,</span> <span class="n">S_IRUGO</span><span class="p">,</span> <span class="n">lpfc_sli4_protocol_show</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">char</span> <span class="o">*</span><span class="n">lpfc_soft_wwn_key</span> <span class="o">=</span> <span class="s">&quot;C99G71SL8032A&quot;</span><span class="p">;</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_soft_wwn_enable_store - Allows setting of the wwn if the key is valid</span>
<span class="cm"> * @dev: class device that is converted into a Scsi_host.</span>
<span class="cm"> * @attr: device attribute, not used.</span>
<span class="cm"> * @buf: containing the string lpfc_soft_wwn_key.</span>
<span class="cm"> * @count: must be size of lpfc_soft_wwn_key.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns:</span>
<span class="cm"> * -EINVAL if the buffer does not contain lpfc_soft_wwn_key</span>
<span class="cm"> * length of buf indicates success</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">ssize_t</span>
<span class="nf">lpfc_soft_wwn_enable_store</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span>
			   <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span>  <span class="o">*</span><span class="n">shost</span> <span class="o">=</span> <span class="n">class_to_shost</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="n">vport</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="p">)</span> <span class="n">shost</span><span class="o">-&gt;</span><span class="n">hostdata</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_hba</span>   <span class="o">*</span><span class="n">phba</span> <span class="o">=</span> <span class="n">vport</span><span class="o">-&gt;</span><span class="n">phba</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cnt</span> <span class="o">=</span> <span class="n">count</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * We&#39;re doing a simple sanity check for soft_wwpn setting.</span>
<span class="cm">	 * We require that the user write a specific key to enable</span>
<span class="cm">	 * the soft_wwpn attribute to be settable. Once the attribute</span>
<span class="cm">	 * is written, the enable key resets. If further updates are</span>
<span class="cm">	 * desired, the key must be written again to re-enable the</span>
<span class="cm">	 * attribute.</span>
<span class="cm">	 *</span>
<span class="cm">	 * The &quot;key&quot; is not secret - it is a hardcoded string shown</span>
<span class="cm">	 * here. The intent is to protect against the random user or</span>
<span class="cm">	 * application that is just writing attributes.</span>
<span class="cm">	 */</span>

	<span class="cm">/* count may include a LF at end of string */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">buf</span><span class="p">[</span><span class="n">cnt</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;\n&#39;</span><span class="p">)</span>
		<span class="n">cnt</span><span class="o">--</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">cnt</span> <span class="o">!=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">lpfc_soft_wwn_key</span><span class="p">))</span> <span class="o">||</span>
	    <span class="p">(</span><span class="n">strncmp</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">lpfc_soft_wwn_key</span><span class="p">,</span> <span class="n">strlen</span><span class="p">(</span><span class="n">lpfc_soft_wwn_key</span><span class="p">))</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">soft_wwn_enable</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">count</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">static</span> <span class="n">DEVICE_ATTR</span><span class="p">(</span><span class="n">lpfc_soft_wwn_enable</span><span class="p">,</span> <span class="n">S_IWUSR</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span>
		   <span class="n">lpfc_soft_wwn_enable_store</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_soft_wwpn_show - Return the cfg soft ww port name of the adapter</span>
<span class="cm"> * @dev: class device that is converted into a Scsi_host.</span>
<span class="cm"> * @attr: device attribute, not used.</span>
<span class="cm"> * @buf: on return contains the wwpn in hexadecimal.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns: size of formatted string.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">ssize_t</span>
<span class="nf">lpfc_soft_wwpn_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span>
		    <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span>  <span class="o">*</span><span class="n">shost</span> <span class="o">=</span> <span class="n">class_to_shost</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="n">vport</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="p">)</span> <span class="n">shost</span><span class="o">-&gt;</span><span class="n">hostdata</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_hba</span>   <span class="o">*</span><span class="n">phba</span> <span class="o">=</span> <span class="n">vport</span><span class="o">-&gt;</span><span class="n">phba</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">snprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">PAGE_SIZE</span><span class="p">,</span> <span class="s">&quot;0x%llx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">cfg_soft_wwpn</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_soft_wwpn_store - Set the ww port name of the adapter</span>
<span class="cm"> * @dev class device that is converted into a Scsi_host.</span>
<span class="cm"> * @attr: device attribute, not used.</span>
<span class="cm"> * @buf: contains the wwpn in hexadecimal.</span>
<span class="cm"> * @count: number of wwpn bytes in buf</span>
<span class="cm"> *</span>
<span class="cm"> * Returns:</span>
<span class="cm"> * -EACCES hba reset not enabled, adapter over temp</span>
<span class="cm"> * -EINVAL soft wwn not enabled, count is invalid, invalid wwpn byte invalid</span>
<span class="cm"> * -EIO error taking adapter offline or online</span>
<span class="cm"> * value of count on success</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">ssize_t</span>
<span class="nf">lpfc_soft_wwpn_store</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span>
		     <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span>  <span class="o">*</span><span class="n">shost</span> <span class="o">=</span> <span class="n">class_to_shost</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="n">vport</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="p">)</span> <span class="n">shost</span><span class="o">-&gt;</span><span class="n">hostdata</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_hba</span>   <span class="o">*</span><span class="n">phba</span> <span class="o">=</span> <span class="n">vport</span><span class="o">-&gt;</span><span class="n">phba</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">completion</span> <span class="n">online_compl</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">stat1</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">stat2</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">cnt</span><span class="o">=</span><span class="n">count</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">wwpn</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">cfg_enable_hba_reset</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EACCES</span><span class="p">;</span>
	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">over_temp_state</span> <span class="o">==</span> <span class="n">HBA_OVER_TEMP</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EACCES</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>
	<span class="cm">/* count may include a LF at end of string */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">buf</span><span class="p">[</span><span class="n">cnt</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;\n&#39;</span><span class="p">)</span>
		<span class="n">cnt</span><span class="o">--</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">soft_wwn_enable</span> <span class="o">||</span> <span class="p">(</span><span class="n">cnt</span> <span class="o">&lt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">cnt</span> <span class="o">&gt;</span> <span class="mi">18</span><span class="p">)</span> <span class="o">||</span>
	    <span class="p">((</span><span class="n">cnt</span> <span class="o">==</span> <span class="mi">17</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="o">*</span><span class="n">buf</span><span class="o">++</span> <span class="o">!=</span> <span class="sc">&#39;x&#39;</span><span class="p">))</span> <span class="o">||</span>
	    <span class="p">((</span><span class="n">cnt</span> <span class="o">==</span> <span class="mi">18</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">((</span><span class="o">*</span><span class="n">buf</span><span class="o">++</span> <span class="o">!=</span> <span class="sc">&#39;0&#39;</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="o">*</span><span class="n">buf</span><span class="o">++</span> <span class="o">!=</span> <span class="sc">&#39;x&#39;</span><span class="p">))))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">soft_wwn_enable</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">memset</span><span class="p">(</span><span class="n">wwpn</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">wwpn</span><span class="p">));</span>

	<span class="cm">/* Validate and store the new name */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">16</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">value</span><span class="p">;</span>

		<span class="n">value</span> <span class="o">=</span> <span class="n">hex_to_bin</span><span class="p">(</span><span class="o">*</span><span class="n">buf</span><span class="o">++</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">value</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">j</span> <span class="o">=</span> <span class="p">(</span><span class="n">j</span> <span class="o">&lt;&lt;</span> <span class="mi">4</span><span class="p">)</span> <span class="o">|</span> <span class="n">value</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">%</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">wwpn</span><span class="p">[</span><span class="n">i</span><span class="o">/</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">j</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">;</span>
			<span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">cfg_soft_wwpn</span> <span class="o">=</span> <span class="n">wwn_to_u64</span><span class="p">(</span><span class="n">wwpn</span><span class="p">);</span>
	<span class="n">fc_host_port_name</span><span class="p">(</span><span class="n">shost</span><span class="p">)</span> <span class="o">=</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">cfg_soft_wwpn</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">cfg_soft_wwnn</span><span class="p">)</span>
		<span class="n">fc_host_node_name</span><span class="p">(</span><span class="n">shost</span><span class="p">)</span> <span class="o">=</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">cfg_soft_wwnn</span><span class="p">;</span>

	<span class="n">dev_printk</span><span class="p">(</span><span class="n">KERN_NOTICE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">pcidev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
		   <span class="s">&quot;lpfc%d: Reinitializing to use soft_wwpn</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">brd_no</span><span class="p">);</span>

	<span class="n">stat1</span> <span class="o">=</span> <span class="n">lpfc_do_offline</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">LPFC_EVT_OFFLINE</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">stat1</span><span class="p">)</span>
		<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_INIT</span><span class="p">,</span>
				<span class="s">&quot;0463 lpfc_soft_wwpn attribute set failed to &quot;</span>
				<span class="s">&quot;reinit adapter - %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">stat1</span><span class="p">);</span>
	<span class="n">init_completion</span><span class="p">(</span><span class="o">&amp;</span><span class="n">online_compl</span><span class="p">);</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">lpfc_workq_post_event</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">stat2</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">online_compl</span><span class="p">,</span>
				   <span class="n">LPFC_EVT_ONLINE</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">wait_for_completion</span><span class="p">(</span><span class="o">&amp;</span><span class="n">online_compl</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">stat2</span><span class="p">)</span>
		<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_INIT</span><span class="p">,</span>
				<span class="s">&quot;0464 lpfc_soft_wwpn attribute set failed to &quot;</span>
				<span class="s">&quot;reinit adapter - %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">stat2</span><span class="p">);</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">stat1</span> <span class="o">||</span> <span class="n">stat2</span><span class="p">)</span> <span class="o">?</span> <span class="o">-</span><span class="n">EIO</span> <span class="o">:</span> <span class="n">count</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">static</span> <span class="n">DEVICE_ATTR</span><span class="p">(</span><span class="n">lpfc_soft_wwpn</span><span class="p">,</span> <span class="n">S_IRUGO</span> <span class="o">|</span> <span class="n">S_IWUSR</span><span class="p">,</span>\
		   <span class="n">lpfc_soft_wwpn_show</span><span class="p">,</span> <span class="n">lpfc_soft_wwpn_store</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_soft_wwnn_show - Return the cfg soft ww node name for the adapter</span>
<span class="cm"> * @dev: class device that is converted into a Scsi_host.</span>
<span class="cm"> * @attr: device attribute, not used.</span>
<span class="cm"> * @buf: on return contains the wwnn in hexadecimal.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns: size of formatted string.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">ssize_t</span>
<span class="nf">lpfc_soft_wwnn_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span>
		    <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span> <span class="o">=</span> <span class="n">class_to_shost</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span> <span class="o">=</span> <span class="p">((</span><span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="p">)</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">hostdata</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">phba</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">snprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">PAGE_SIZE</span><span class="p">,</span> <span class="s">&quot;0x%llx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">cfg_soft_wwnn</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_soft_wwnn_store - sets the ww node name of the adapter</span>
<span class="cm"> * @cdev: class device that is converted into a Scsi_host.</span>
<span class="cm"> * @buf: contains the ww node name in hexadecimal.</span>
<span class="cm"> * @count: number of wwnn bytes in buf.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns:</span>
<span class="cm"> * -EINVAL soft wwn not enabled, count is invalid, invalid wwnn byte invalid</span>
<span class="cm"> * value of count on success</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">ssize_t</span>
<span class="nf">lpfc_soft_wwnn_store</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span>
		     <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span> <span class="o">=</span> <span class="n">class_to_shost</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span> <span class="o">=</span> <span class="p">((</span><span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="p">)</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">hostdata</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">phba</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">cnt</span><span class="o">=</span><span class="n">count</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">wwnn</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span>

	<span class="cm">/* count may include a LF at end of string */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">buf</span><span class="p">[</span><span class="n">cnt</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;\n&#39;</span><span class="p">)</span>
		<span class="n">cnt</span><span class="o">--</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">soft_wwn_enable</span> <span class="o">||</span> <span class="p">(</span><span class="n">cnt</span> <span class="o">&lt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">cnt</span> <span class="o">&gt;</span> <span class="mi">18</span><span class="p">)</span> <span class="o">||</span>
	    <span class="p">((</span><span class="n">cnt</span> <span class="o">==</span> <span class="mi">17</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="o">*</span><span class="n">buf</span><span class="o">++</span> <span class="o">!=</span> <span class="sc">&#39;x&#39;</span><span class="p">))</span> <span class="o">||</span>
	    <span class="p">((</span><span class="n">cnt</span> <span class="o">==</span> <span class="mi">18</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">((</span><span class="o">*</span><span class="n">buf</span><span class="o">++</span> <span class="o">!=</span> <span class="sc">&#39;0&#39;</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="o">*</span><span class="n">buf</span><span class="o">++</span> <span class="o">!=</span> <span class="sc">&#39;x&#39;</span><span class="p">))))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Allow wwnn to be set many times, as long as the enable is set.</span>
<span class="cm">	 * However, once the wwpn is set, everything locks.</span>
<span class="cm">	 */</span>

	<span class="n">memset</span><span class="p">(</span><span class="n">wwnn</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">wwnn</span><span class="p">));</span>

	<span class="cm">/* Validate and store the new name */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">16</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">value</span><span class="p">;</span>

		<span class="n">value</span> <span class="o">=</span> <span class="n">hex_to_bin</span><span class="p">(</span><span class="o">*</span><span class="n">buf</span><span class="o">++</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">value</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">j</span> <span class="o">=</span> <span class="p">(</span><span class="n">j</span> <span class="o">&lt;&lt;</span> <span class="mi">4</span><span class="p">)</span> <span class="o">|</span> <span class="n">value</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">%</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">wwnn</span><span class="p">[</span><span class="n">i</span><span class="o">/</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">j</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">;</span>
			<span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">cfg_soft_wwnn</span> <span class="o">=</span> <span class="n">wwn_to_u64</span><span class="p">(</span><span class="n">wwnn</span><span class="p">);</span>

	<span class="n">dev_printk</span><span class="p">(</span><span class="n">KERN_NOTICE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">pcidev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
		   <span class="s">&quot;lpfc%d: soft_wwnn set. Value will take effect upon &quot;</span>
		   <span class="s">&quot;setting of the soft_wwpn</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">brd_no</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">count</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">static</span> <span class="n">DEVICE_ATTR</span><span class="p">(</span><span class="n">lpfc_soft_wwnn</span><span class="p">,</span> <span class="n">S_IRUGO</span> <span class="o">|</span> <span class="n">S_IWUSR</span><span class="p">,</span>\
		   <span class="n">lpfc_soft_wwnn_show</span><span class="p">,</span> <span class="n">lpfc_soft_wwnn_store</span><span class="p">);</span>


<span class="k">static</span> <span class="kt">int</span> <span class="n">lpfc_poll</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="n">module_param</span><span class="p">(</span><span class="n">lpfc_poll</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="n">S_IRUGO</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">lpfc_poll</span><span class="p">,</span> <span class="s">&quot;FCP ring polling mode control:&quot;</span>
		 <span class="s">&quot; 0 - none,&quot;</span>
		 <span class="s">&quot; 1 - poll with interrupts enabled&quot;</span>
		 <span class="s">&quot; 3 - poll and disable FCP ring interrupts&quot;</span><span class="p">);</span>

<span class="k">static</span> <span class="n">DEVICE_ATTR</span><span class="p">(</span><span class="n">lpfc_poll</span><span class="p">,</span> <span class="n">S_IRUGO</span> <span class="o">|</span> <span class="n">S_IWUSR</span><span class="p">,</span>
		   <span class="n">lpfc_poll_show</span><span class="p">,</span> <span class="n">lpfc_poll_store</span><span class="p">);</span>

<span class="kt">int</span>  <span class="n">lpfc_sli_mode</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="n">module_param</span><span class="p">(</span><span class="n">lpfc_sli_mode</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="n">S_IRUGO</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">lpfc_sli_mode</span><span class="p">,</span> <span class="s">&quot;SLI mode selector:&quot;</span>
		 <span class="s">&quot; 0 - auto (SLI-3 if supported),&quot;</span>
		 <span class="s">&quot; 2 - select SLI-2 even on SLI-3 capable HBAs,&quot;</span>
		 <span class="s">&quot; 3 - select SLI-3&quot;</span><span class="p">);</span>

<span class="kt">int</span> <span class="n">lpfc_enable_npiv</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="n">module_param</span><span class="p">(</span><span class="n">lpfc_enable_npiv</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="n">S_IRUGO</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">lpfc_enable_npiv</span><span class="p">,</span> <span class="s">&quot;Enable NPIV functionality&quot;</span><span class="p">);</span>
<span class="n">lpfc_param_show</span><span class="p">(</span><span class="n">enable_npiv</span><span class="p">);</span>
<span class="n">lpfc_param_init</span><span class="p">(</span><span class="n">enable_npiv</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="k">static</span> <span class="n">DEVICE_ATTR</span><span class="p">(</span><span class="n">lpfc_enable_npiv</span><span class="p">,</span> <span class="n">S_IRUGO</span><span class="p">,</span> <span class="n">lpfc_enable_npiv_show</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

<span class="n">LPFC_ATTR_R</span><span class="p">(</span><span class="n">fcf_failover_policy</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span>
	<span class="s">&quot;FCF Fast failover=1 Priority failover=2&quot;</span><span class="p">);</span>

<span class="kt">int</span> <span class="n">lpfc_enable_rrq</span><span class="p">;</span>
<span class="n">module_param</span><span class="p">(</span><span class="n">lpfc_enable_rrq</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="n">S_IRUGO</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">lpfc_enable_rrq</span><span class="p">,</span> <span class="s">&quot;Enable RRQ functionality&quot;</span><span class="p">);</span>
<span class="n">lpfc_param_show</span><span class="p">(</span><span class="n">enable_rrq</span><span class="p">);</span>
<span class="n">lpfc_param_init</span><span class="p">(</span><span class="n">enable_rrq</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="k">static</span> <span class="n">DEVICE_ATTR</span><span class="p">(</span><span class="n">lpfc_enable_rrq</span><span class="p">,</span> <span class="n">S_IRUGO</span><span class="p">,</span> <span class="n">lpfc_enable_rrq_show</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"># lpfc_suppress_link_up:  Bring link up at initialization</span>
<span class="cm">#            0x0  = bring link up (issue MBX_INIT_LINK)</span>
<span class="cm">#            0x1  = do NOT bring link up at initialization(MBX_INIT_LINK)</span>
<span class="cm">#            0x2  = never bring up link</span>
<span class="cm"># Default value is 0.</span>
<span class="cm">*/</span>
<span class="n">LPFC_ATTR_R</span><span class="p">(</span><span class="n">suppress_link_up</span><span class="p">,</span> <span class="n">LPFC_INITIALIZE_LINK</span><span class="p">,</span> <span class="n">LPFC_INITIALIZE_LINK</span><span class="p">,</span>
		<span class="n">LPFC_DELAY_INIT_LINK_INDEFINITELY</span><span class="p">,</span>
		<span class="s">&quot;Suppress Link Up at initialization&quot;</span><span class="p">);</span>
<span class="cm">/*</span>
<span class="cm"># lpfc_cnt: Number of IOCBs allocated for ELS, CT, and ABTS</span>
<span class="cm">#       1 - (1024)</span>
<span class="cm">#       2 - (2048)</span>
<span class="cm">#       3 - (3072)</span>
<span class="cm">#       4 - (4096)</span>
<span class="cm">#       5 - (5120)</span>
<span class="cm">*/</span>
<span class="k">static</span> <span class="kt">ssize_t</span>
<span class="nf">lpfc_iocb_hw_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span>  <span class="o">*</span><span class="n">shost</span> <span class="o">=</span> <span class="n">class_to_shost</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">lpfc_hba</span>   <span class="o">*</span><span class="n">phba</span> <span class="o">=</span> <span class="p">((</span><span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="p">)</span> <span class="n">shost</span><span class="o">-&gt;</span><span class="n">hostdata</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">phba</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">snprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">PAGE_SIZE</span><span class="p">,</span> <span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">iocb_max</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">DEVICE_ATTR</span><span class="p">(</span><span class="n">iocb_hw</span><span class="p">,</span> <span class="n">S_IRUGO</span><span class="p">,</span>
			 <span class="n">lpfc_iocb_hw_show</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">ssize_t</span>
<span class="nf">lpfc_txq_hw_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span>  <span class="o">*</span><span class="n">shost</span> <span class="o">=</span> <span class="n">class_to_shost</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">lpfc_hba</span>   <span class="o">*</span><span class="n">phba</span> <span class="o">=</span> <span class="p">((</span><span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="p">)</span> <span class="n">shost</span><span class="o">-&gt;</span><span class="n">hostdata</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">phba</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">snprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">PAGE_SIZE</span><span class="p">,</span> <span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli</span><span class="p">.</span><span class="n">ring</span><span class="p">[</span><span class="n">LPFC_ELS_RING</span><span class="p">].</span><span class="n">txq_max</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">DEVICE_ATTR</span><span class="p">(</span><span class="n">txq_hw</span><span class="p">,</span> <span class="n">S_IRUGO</span><span class="p">,</span>
			 <span class="n">lpfc_txq_hw_show</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">ssize_t</span>
<span class="nf">lpfc_txcmplq_hw_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span>
 <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span>  <span class="o">*</span><span class="n">shost</span> <span class="o">=</span> <span class="n">class_to_shost</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">lpfc_hba</span>   <span class="o">*</span><span class="n">phba</span> <span class="o">=</span> <span class="p">((</span><span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="p">)</span> <span class="n">shost</span><span class="o">-&gt;</span><span class="n">hostdata</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">phba</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">snprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">PAGE_SIZE</span><span class="p">,</span> <span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli</span><span class="p">.</span><span class="n">ring</span><span class="p">[</span><span class="n">LPFC_ELS_RING</span><span class="p">].</span><span class="n">txcmplq_max</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">DEVICE_ATTR</span><span class="p">(</span><span class="n">txcmplq_hw</span><span class="p">,</span> <span class="n">S_IRUGO</span><span class="p">,</span>
			 <span class="n">lpfc_txcmplq_hw_show</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

<span class="kt">int</span> <span class="n">lpfc_iocb_cnt</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
<span class="n">module_param</span><span class="p">(</span><span class="n">lpfc_iocb_cnt</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="n">S_IRUGO</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">lpfc_iocb_cnt</span><span class="p">,</span>
	<span class="s">&quot;Number of IOCBs alloc for ELS, CT, and ABTS: 1k to 5k IOCBs&quot;</span><span class="p">);</span>
<span class="n">lpfc_param_show</span><span class="p">(</span><span class="n">iocb_cnt</span><span class="p">);</span>
<span class="n">lpfc_param_init</span><span class="p">(</span><span class="n">iocb_cnt</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">);</span>
<span class="k">static</span> <span class="n">DEVICE_ATTR</span><span class="p">(</span><span class="n">lpfc_iocb_cnt</span><span class="p">,</span> <span class="n">S_IRUGO</span><span class="p">,</span>
			 <span class="n">lpfc_iocb_cnt_show</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"># lpfc_nodev_tmo: If set, it will hold all I/O errors on devices that disappear</span>
<span class="cm"># until the timer expires. Value range is [0,255]. Default value is 30.</span>
<span class="cm">*/</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">lpfc_nodev_tmo</span> <span class="o">=</span> <span class="n">LPFC_DEF_DEVLOSS_TMO</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">lpfc_devloss_tmo</span> <span class="o">=</span> <span class="n">LPFC_DEF_DEVLOSS_TMO</span><span class="p">;</span>
<span class="n">module_param</span><span class="p">(</span><span class="n">lpfc_nodev_tmo</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">lpfc_nodev_tmo</span><span class="p">,</span>
		 <span class="s">&quot;Seconds driver will hold I/O waiting &quot;</span>
		 <span class="s">&quot;for a device to come back&quot;</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_nodev_tmo_show - Return the hba dev loss timeout value</span>
<span class="cm"> * @dev: class converted to a Scsi_host structure.</span>
<span class="cm"> * @attr: device attribute, not used.</span>
<span class="cm"> * @buf: on return contains the dev loss timeout in decimal.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns: size of formatted string.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">ssize_t</span>
<span class="nf">lpfc_nodev_tmo_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span>
		    <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span>  <span class="o">*</span><span class="n">shost</span> <span class="o">=</span> <span class="n">class_to_shost</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="n">vport</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="p">)</span> <span class="n">shost</span><span class="o">-&gt;</span><span class="n">hostdata</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">snprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">PAGE_SIZE</span><span class="p">,</span> <span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>	<span class="n">vport</span><span class="o">-&gt;</span><span class="n">cfg_devloss_tmo</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_nodev_tmo_init - Set the hba nodev timeout value</span>
<span class="cm"> * @vport: lpfc vport structure pointer.</span>
<span class="cm"> * @val: contains the nodev timeout value.</span>
<span class="cm"> *</span>
<span class="cm"> * Description:</span>
<span class="cm"> * If the devloss tmo is already set then nodev tmo is set to devloss tmo,</span>
<span class="cm"> * a kernel error message is printed and zero is returned.</span>
<span class="cm"> * Else if val is in range then nodev tmo and devloss tmo are set to val.</span>
<span class="cm"> * Otherwise nodev tmo is set to the default value.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns:</span>
<span class="cm"> * zero if already set or if val is in range</span>
<span class="cm"> * -EINVAL val out of range</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">lpfc_nodev_tmo_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="n">vport</span><span class="p">,</span> <span class="kt">int</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">cfg_devloss_tmo</span> <span class="o">!=</span> <span class="n">LPFC_DEF_DEVLOSS_TMO</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">vport</span><span class="o">-&gt;</span><span class="n">cfg_nodev_tmo</span> <span class="o">=</span> <span class="n">vport</span><span class="o">-&gt;</span><span class="n">cfg_devloss_tmo</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">val</span> <span class="o">!=</span> <span class="n">LPFC_DEF_DEVLOSS_TMO</span><span class="p">)</span>
			<span class="n">lpfc_printf_vlog</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_INIT</span><span class="p">,</span>
					 <span class="s">&quot;0407 Ignoring nodev_tmo module &quot;</span>
					 <span class="s">&quot;parameter because devloss_tmo is &quot;</span>
					 <span class="s">&quot;set.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">val</span> <span class="o">&gt;=</span> <span class="n">LPFC_MIN_DEVLOSS_TMO</span> <span class="o">&amp;&amp;</span> <span class="n">val</span> <span class="o">&lt;=</span> <span class="n">LPFC_MAX_DEVLOSS_TMO</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">vport</span><span class="o">-&gt;</span><span class="n">cfg_nodev_tmo</span> <span class="o">=</span> <span class="n">val</span><span class="p">;</span>
		<span class="n">vport</span><span class="o">-&gt;</span><span class="n">cfg_devloss_tmo</span> <span class="o">=</span> <span class="n">val</span><span class="p">;</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">lpfc_printf_vlog</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_INIT</span><span class="p">,</span>
			 <span class="s">&quot;0400 lpfc_nodev_tmo attribute cannot be set to&quot;</span>
			 <span class="s">&quot; %d, allowed range is [%d, %d]</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			 <span class="n">val</span><span class="p">,</span> <span class="n">LPFC_MIN_DEVLOSS_TMO</span><span class="p">,</span> <span class="n">LPFC_MAX_DEVLOSS_TMO</span><span class="p">);</span>
	<span class="n">vport</span><span class="o">-&gt;</span><span class="n">cfg_nodev_tmo</span> <span class="o">=</span> <span class="n">LPFC_DEF_DEVLOSS_TMO</span><span class="p">;</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_update_rport_devloss_tmo - Update dev loss tmo value</span>
<span class="cm"> * @vport: lpfc vport structure pointer.</span>
<span class="cm"> *</span>
<span class="cm"> * Description:</span>
<span class="cm"> * Update all the ndlp&#39;s dev loss tmo with the vport devloss tmo value.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">lpfc_update_rport_devloss_tmo</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="n">vport</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span>  <span class="o">*</span><span class="n">shost</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_nodelist</span>  <span class="o">*</span><span class="n">ndlp</span><span class="p">;</span>

	<span class="n">shost</span> <span class="o">=</span> <span class="n">lpfc_shost_from_vport</span><span class="p">(</span><span class="n">vport</span><span class="p">);</span>
	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">ndlp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_nodes</span><span class="p">,</span> <span class="n">nlp_listp</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">NLP_CHK_NODE_ACT</span><span class="p">(</span><span class="n">ndlp</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">rport</span><span class="p">)</span>
			<span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">rport</span><span class="o">-&gt;</span><span class="n">dev_loss_tmo</span> <span class="o">=</span> <span class="n">vport</span><span class="o">-&gt;</span><span class="n">cfg_devloss_tmo</span><span class="p">;</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_nodev_tmo_set - Set the vport nodev tmo and devloss tmo values</span>
<span class="cm"> * @vport: lpfc vport structure pointer.</span>
<span class="cm"> * @val: contains the tmo value.</span>
<span class="cm"> *</span>
<span class="cm"> * Description:</span>
<span class="cm"> * If the devloss tmo is already set or the vport dev loss tmo has changed</span>
<span class="cm"> * then a kernel error message is printed and zero is returned.</span>
<span class="cm"> * Else if val is in range then nodev tmo and devloss tmo are set to val.</span>
<span class="cm"> * Otherwise nodev tmo is set to the default value.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns:</span>
<span class="cm"> * zero if already set or if val is in range</span>
<span class="cm"> * -EINVAL val out of range</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">lpfc_nodev_tmo_set</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="n">vport</span><span class="p">,</span> <span class="kt">int</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">dev_loss_tmo_changed</span> <span class="o">||</span>
	    <span class="p">(</span><span class="n">lpfc_devloss_tmo</span> <span class="o">!=</span> <span class="n">LPFC_DEF_DEVLOSS_TMO</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">lpfc_printf_vlog</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_INIT</span><span class="p">,</span>
				 <span class="s">&quot;0401 Ignoring change to nodev_tmo &quot;</span>
				 <span class="s">&quot;because devloss_tmo is set.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">val</span> <span class="o">&gt;=</span> <span class="n">LPFC_MIN_DEVLOSS_TMO</span> <span class="o">&amp;&amp;</span> <span class="n">val</span> <span class="o">&lt;=</span> <span class="n">LPFC_MAX_DEVLOSS_TMO</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">vport</span><span class="o">-&gt;</span><span class="n">cfg_nodev_tmo</span> <span class="o">=</span> <span class="n">val</span><span class="p">;</span>
		<span class="n">vport</span><span class="o">-&gt;</span><span class="n">cfg_devloss_tmo</span> <span class="o">=</span> <span class="n">val</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * For compat: set the fc_host dev loss so new rports</span>
<span class="cm">		 * will get the value.</span>
<span class="cm">		 */</span>
		<span class="n">fc_host_dev_loss_tmo</span><span class="p">(</span><span class="n">lpfc_shost_from_vport</span><span class="p">(</span><span class="n">vport</span><span class="p">))</span> <span class="o">=</span> <span class="n">val</span><span class="p">;</span>
		<span class="n">lpfc_update_rport_devloss_tmo</span><span class="p">(</span><span class="n">vport</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">lpfc_printf_vlog</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_INIT</span><span class="p">,</span>
			 <span class="s">&quot;0403 lpfc_nodev_tmo attribute cannot be set to&quot;</span>
			 <span class="s">&quot;%d, allowed range is [%d, %d]</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			 <span class="n">val</span><span class="p">,</span> <span class="n">LPFC_MIN_DEVLOSS_TMO</span><span class="p">,</span> <span class="n">LPFC_MAX_DEVLOSS_TMO</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">lpfc_vport_param_store</span><span class="p">(</span><span class="n">nodev_tmo</span><span class="p">)</span>

<span class="k">static</span> <span class="n">DEVICE_ATTR</span><span class="p">(</span><span class="n">lpfc_nodev_tmo</span><span class="p">,</span> <span class="n">S_IRUGO</span> <span class="o">|</span> <span class="n">S_IWUSR</span><span class="p">,</span>
		   <span class="n">lpfc_nodev_tmo_show</span><span class="p">,</span> <span class="n">lpfc_nodev_tmo_store</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"># lpfc_devloss_tmo: If set, it will hold all I/O errors on devices that</span>
<span class="cm"># disappear until the timer expires. Value range is [0,255]. Default</span>
<span class="cm"># value is 30.</span>
<span class="cm">*/</span>
<span class="n">module_param</span><span class="p">(</span><span class="n">lpfc_devloss_tmo</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="n">S_IRUGO</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">lpfc_devloss_tmo</span><span class="p">,</span>
		 <span class="s">&quot;Seconds driver will hold I/O waiting &quot;</span>
		 <span class="s">&quot;for a device to come back&quot;</span><span class="p">);</span>
<span class="n">lpfc_vport_param_init</span><span class="p">(</span><span class="n">devloss_tmo</span><span class="p">,</span> <span class="n">LPFC_DEF_DEVLOSS_TMO</span><span class="p">,</span>
		      <span class="n">LPFC_MIN_DEVLOSS_TMO</span><span class="p">,</span> <span class="n">LPFC_MAX_DEVLOSS_TMO</span><span class="p">)</span>
<span class="n">lpfc_vport_param_show</span><span class="p">(</span><span class="n">devloss_tmo</span><span class="p">)</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_devloss_tmo_set - Sets vport nodev tmo, devloss tmo values, changed bit</span>
<span class="cm"> * @vport: lpfc vport structure pointer.</span>
<span class="cm"> * @val: contains the tmo value.</span>
<span class="cm"> *</span>
<span class="cm"> * Description:</span>
<span class="cm"> * If val is in a valid range then set the vport nodev tmo,</span>
<span class="cm"> * devloss tmo, also set the vport dev loss tmo changed flag.</span>
<span class="cm"> * Else a kernel error message is printed.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns:</span>
<span class="cm"> * zero if val is in range</span>
<span class="cm"> * -EINVAL val out of range</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="n">lpfc_devloss_tmo_set</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="n">vport</span><span class="p">,</span> <span class="kt">int</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">val</span> <span class="o">&gt;=</span> <span class="n">LPFC_MIN_DEVLOSS_TMO</span> <span class="o">&amp;&amp;</span> <span class="n">val</span> <span class="o">&lt;=</span> <span class="n">LPFC_MAX_DEVLOSS_TMO</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">vport</span><span class="o">-&gt;</span><span class="n">cfg_nodev_tmo</span> <span class="o">=</span> <span class="n">val</span><span class="p">;</span>
		<span class="n">vport</span><span class="o">-&gt;</span><span class="n">cfg_devloss_tmo</span> <span class="o">=</span> <span class="n">val</span><span class="p">;</span>
		<span class="n">vport</span><span class="o">-&gt;</span><span class="n">dev_loss_tmo_changed</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">fc_host_dev_loss_tmo</span><span class="p">(</span><span class="n">lpfc_shost_from_vport</span><span class="p">(</span><span class="n">vport</span><span class="p">))</span> <span class="o">=</span> <span class="n">val</span><span class="p">;</span>
		<span class="n">lpfc_update_rport_devloss_tmo</span><span class="p">(</span><span class="n">vport</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">lpfc_printf_vlog</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_INIT</span><span class="p">,</span>
			 <span class="s">&quot;0404 lpfc_devloss_tmo attribute cannot be set to&quot;</span>
			 <span class="s">&quot; %d, allowed range is [%d, %d]</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			 <span class="n">val</span><span class="p">,</span> <span class="n">LPFC_MIN_DEVLOSS_TMO</span><span class="p">,</span> <span class="n">LPFC_MAX_DEVLOSS_TMO</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">lpfc_vport_param_store</span><span class="p">(</span><span class="n">devloss_tmo</span><span class="p">)</span>
<span class="k">static</span> <span class="n">DEVICE_ATTR</span><span class="p">(</span><span class="n">lpfc_devloss_tmo</span><span class="p">,</span> <span class="n">S_IRUGO</span> <span class="o">|</span> <span class="n">S_IWUSR</span><span class="p">,</span>
		   <span class="n">lpfc_devloss_tmo_show</span><span class="p">,</span> <span class="n">lpfc_devloss_tmo_store</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"># lpfc_log_verbose: Only turn this flag on if you are willing to risk being</span>
<span class="cm"># deluged with LOTS of information.</span>
<span class="cm"># You can set a bit mask to record specific types of verbose messages:</span>
<span class="cm"># See lpfc_logmsh.h for definitions.</span>
<span class="cm">*/</span>
<span class="n">LPFC_VPORT_ATTR_HEX_RW</span><span class="p">(</span><span class="n">log_verbose</span><span class="p">,</span> <span class="mh">0x0</span><span class="p">,</span> <span class="mh">0x0</span><span class="p">,</span> <span class="mh">0xffffffff</span><span class="p">,</span>
		       <span class="s">&quot;Verbose logging bit-mask&quot;</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"># lpfc_enable_da_id: This turns on the DA_ID CT command that deregisters</span>
<span class="cm"># objects that have been registered with the nameserver after login.</span>
<span class="cm">*/</span>
<span class="n">LPFC_VPORT_ATTR_R</span><span class="p">(</span><span class="n">enable_da_id</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span>
		  <span class="s">&quot;Deregister nameserver objects before LOGO&quot;</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"># lun_queue_depth:  This parameter is used to limit the number of outstanding</span>
<span class="cm"># commands per FCP LUN. Value range is [1,128]. Default value is 30.</span>
<span class="cm">*/</span>
<span class="n">LPFC_VPORT_ATTR_R</span><span class="p">(</span><span class="n">lun_queue_depth</span><span class="p">,</span> <span class="mi">30</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">128</span><span class="p">,</span>
		  <span class="s">&quot;Max number of FCP commands we can queue to a specific LUN&quot;</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"># tgt_queue_depth:  This parameter is used to limit the number of outstanding</span>
<span class="cm"># commands per target port. Value range is [10,65535]. Default value is 65535.</span>
<span class="cm">*/</span>
<span class="n">LPFC_VPORT_ATTR_R</span><span class="p">(</span><span class="n">tgt_queue_depth</span><span class="p">,</span> <span class="mi">65535</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">65535</span><span class="p">,</span>
	<span class="s">&quot;Max number of FCP commands we can queue to a specific target port&quot;</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"># hba_queue_depth:  This parameter is used to limit the number of outstanding</span>
<span class="cm"># commands per lpfc HBA. Value range is [32,8192]. If this parameter</span>
<span class="cm"># value is greater than the maximum number of exchanges supported by the HBA,</span>
<span class="cm"># then maximum number of exchanges supported by the HBA is used to determine</span>
<span class="cm"># the hba_queue_depth.</span>
<span class="cm">*/</span>
<span class="n">LPFC_ATTR_R</span><span class="p">(</span><span class="n">hba_queue_depth</span><span class="p">,</span> <span class="mi">8192</span><span class="p">,</span> <span class="mi">32</span><span class="p">,</span> <span class="mi">8192</span><span class="p">,</span>
	    <span class="s">&quot;Max number of FCP commands we can queue to a lpfc HBA&quot;</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"># peer_port_login:  This parameter allows/prevents logins</span>
<span class="cm"># between peer ports hosted on the same physical port.</span>
<span class="cm"># When this parameter is set 0 peer ports of same physical port</span>
<span class="cm"># are not allowed to login to each other.</span>
<span class="cm"># When this parameter is set 1 peer ports of same physical port</span>
<span class="cm"># are allowed to login to each other.</span>
<span class="cm"># Default value of this parameter is 0.</span>
<span class="cm">*/</span>
<span class="n">LPFC_VPORT_ATTR_R</span><span class="p">(</span><span class="n">peer_port_login</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span>
		  <span class="s">&quot;Allow peer ports on the same physical port to login to each &quot;</span>
		  <span class="s">&quot;other.&quot;</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"># restrict_login:  This parameter allows/prevents logins</span>
<span class="cm"># between Virtual Ports and remote initiators.</span>
<span class="cm"># When this parameter is not set (0) Virtual Ports will accept PLOGIs from</span>
<span class="cm"># other initiators and will attempt to PLOGI all remote ports.</span>
<span class="cm"># When this parameter is set (1) Virtual Ports will reject PLOGIs from</span>
<span class="cm"># remote ports and will not attempt to PLOGI to other initiators.</span>
<span class="cm"># This parameter does not restrict to the physical port.</span>
<span class="cm"># This parameter does not restrict logins to Fabric resident remote ports.</span>
<span class="cm"># Default value of this parameter is 1.</span>
<span class="cm">*/</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">lpfc_restrict_login</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="n">module_param</span><span class="p">(</span><span class="n">lpfc_restrict_login</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="n">S_IRUGO</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">lpfc_restrict_login</span><span class="p">,</span>
		 <span class="s">&quot;Restrict virtual ports login to remote initiators.&quot;</span><span class="p">);</span>
<span class="n">lpfc_vport_param_show</span><span class="p">(</span><span class="n">restrict_login</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_restrict_login_init - Set the vport restrict login flag</span>
<span class="cm"> * @vport: lpfc vport structure pointer.</span>
<span class="cm"> * @val: contains the restrict login value.</span>
<span class="cm"> *</span>
<span class="cm"> * Description:</span>
<span class="cm"> * If val is not in a valid range then log a kernel error message and set</span>
<span class="cm"> * the vport restrict login to one.</span>
<span class="cm"> * If the port type is physical clear the restrict login flag and return.</span>
<span class="cm"> * Else set the restrict login flag to val.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns:</span>
<span class="cm"> * zero if val is in range</span>
<span class="cm"> * -EINVAL val out of range</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">lpfc_restrict_login_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="n">vport</span><span class="p">,</span> <span class="kt">int</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">val</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">val</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lpfc_printf_vlog</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_INIT</span><span class="p">,</span>
				 <span class="s">&quot;0422 lpfc_restrict_login attribute cannot &quot;</span>
				 <span class="s">&quot;be set to %d, allowed range is [0, 1]</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				 <span class="n">val</span><span class="p">);</span>
		<span class="n">vport</span><span class="o">-&gt;</span><span class="n">cfg_restrict_login</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">port_type</span> <span class="o">==</span> <span class="n">LPFC_PHYSICAL_PORT</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">vport</span><span class="o">-&gt;</span><span class="n">cfg_restrict_login</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">vport</span><span class="o">-&gt;</span><span class="n">cfg_restrict_login</span> <span class="o">=</span> <span class="n">val</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_restrict_login_set - Set the vport restrict login flag</span>
<span class="cm"> * @vport: lpfc vport structure pointer.</span>
<span class="cm"> * @val: contains the restrict login value.</span>
<span class="cm"> *</span>
<span class="cm"> * Description:</span>
<span class="cm"> * If val is not in a valid range then log a kernel error message and set</span>
<span class="cm"> * the vport restrict login to one.</span>
<span class="cm"> * If the port type is physical and the val is not zero log a kernel</span>
<span class="cm"> * error message, clear the restrict login flag and return zero.</span>
<span class="cm"> * Else set the restrict login flag to val.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns:</span>
<span class="cm"> * zero if val is in range</span>
<span class="cm"> * -EINVAL val out of range</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">lpfc_restrict_login_set</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="n">vport</span><span class="p">,</span> <span class="kt">int</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">val</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">val</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lpfc_printf_vlog</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_INIT</span><span class="p">,</span>
				 <span class="s">&quot;0425 lpfc_restrict_login attribute cannot &quot;</span>
				 <span class="s">&quot;be set to %d, allowed range is [0, 1]</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				 <span class="n">val</span><span class="p">);</span>
		<span class="n">vport</span><span class="o">-&gt;</span><span class="n">cfg_restrict_login</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">port_type</span> <span class="o">==</span> <span class="n">LPFC_PHYSICAL_PORT</span> <span class="o">&amp;&amp;</span> <span class="n">val</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lpfc_printf_vlog</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_INIT</span><span class="p">,</span>
				 <span class="s">&quot;0468 lpfc_restrict_login must be 0 for &quot;</span>
				 <span class="s">&quot;Physical ports.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">vport</span><span class="o">-&gt;</span><span class="n">cfg_restrict_login</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">vport</span><span class="o">-&gt;</span><span class="n">cfg_restrict_login</span> <span class="o">=</span> <span class="n">val</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">lpfc_vport_param_store</span><span class="p">(</span><span class="n">restrict_login</span><span class="p">);</span>
<span class="k">static</span> <span class="n">DEVICE_ATTR</span><span class="p">(</span><span class="n">lpfc_restrict_login</span><span class="p">,</span> <span class="n">S_IRUGO</span> <span class="o">|</span> <span class="n">S_IWUSR</span><span class="p">,</span>
		   <span class="n">lpfc_restrict_login_show</span><span class="p">,</span> <span class="n">lpfc_restrict_login_store</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"># Some disk devices have a &quot;select ID&quot; or &quot;select Target&quot; capability.</span>
<span class="cm"># From a protocol standpoint &quot;select ID&quot; usually means select the</span>
<span class="cm"># Fibre channel &quot;ALPA&quot;.  In the FC-AL Profile there is an &quot;informative</span>
<span class="cm"># annex&quot; which contains a table that maps a &quot;select ID&quot; (a number</span>
<span class="cm"># between 0 and 7F) to an ALPA.  By default, for compatibility with</span>
<span class="cm"># older drivers, the lpfc driver scans this table from low ALPA to high</span>
<span class="cm"># ALPA.</span>
<span class="cm">#</span>
<span class="cm"># Turning on the scan-down variable (on  = 1, off = 0) will</span>
<span class="cm"># cause the lpfc driver to use an inverted table, effectively</span>
<span class="cm"># scanning ALPAs from high to low. Value range is [0,1]. Default value is 1.</span>
<span class="cm">#</span>
<span class="cm"># (Note: This &quot;select ID&quot; functionality is a LOOP ONLY characteristic</span>
<span class="cm"># and will not work across a fabric. Also this parameter will take</span>
<span class="cm"># effect only in the case when ALPA map is not available.)</span>
<span class="cm">*/</span>
<span class="n">LPFC_VPORT_ATTR_R</span><span class="p">(</span><span class="n">scan_down</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span>
		  <span class="s">&quot;Start scanning for devices from highest ALPA to lowest&quot;</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"># lpfc_topology:  link topology for init link</span>
<span class="cm">#            0x0  = attempt loop mode then point-to-point</span>
<span class="cm">#            0x01 = internal loopback mode</span>
<span class="cm">#            0x02 = attempt point-to-point mode only</span>
<span class="cm">#            0x04 = attempt loop mode only</span>
<span class="cm">#            0x06 = attempt point-to-point mode then loop</span>
<span class="cm"># Set point-to-point mode if you want to run as an N_Port.</span>
<span class="cm"># Set loop mode if you want to run as an NL_Port. Value range is [0,0x6].</span>
<span class="cm"># Default value is 0.</span>
<span class="cm">*/</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_topology_set - Set the adapters topology field</span>
<span class="cm"> * @phba: lpfc_hba pointer.</span>
<span class="cm"> * @val: topology value.</span>
<span class="cm"> *</span>
<span class="cm"> * Description:</span>
<span class="cm"> * If val is in a valid range then set the adapter&#39;s topology field and</span>
<span class="cm"> * issue a lip; if the lip fails reset the topology to the old value.</span>
<span class="cm"> *</span>
<span class="cm"> * If the value is not in range log a kernel error message and return an error.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns:</span>
<span class="cm"> * zero if val is in range and lip okay</span>
<span class="cm"> * non-zero return value from lpfc_issue_lip()</span>
<span class="cm"> * -EINVAL val out of range</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">ssize_t</span>
<span class="nf">lpfc_topology_store</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span>
			<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span>  <span class="o">*</span><span class="n">shost</span> <span class="o">=</span> <span class="n">class_to_shost</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="n">vport</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="p">)</span> <span class="n">shost</span><span class="o">-&gt;</span><span class="n">hostdata</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_hba</span>   <span class="o">*</span><span class="n">phba</span> <span class="o">=</span> <span class="n">vport</span><span class="o">-&gt;</span><span class="n">phba</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">val</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">nolip</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">val_buf</span> <span class="o">=</span> <span class="n">buf</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">prev_val</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strncmp</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;nolip &quot;</span><span class="p">,</span> <span class="n">strlen</span><span class="p">(</span><span class="s">&quot;nolip &quot;</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">nolip</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">val_buf</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">buf</span><span class="p">[</span><span class="n">strlen</span><span class="p">(</span><span class="s">&quot;nolip &quot;</span><span class="p">)];</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">isdigit</span><span class="p">(</span><span class="n">val_buf</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sscanf</span><span class="p">(</span><span class="n">val_buf</span><span class="p">,</span> <span class="s">&quot;%i&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">val</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">val</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">val</span> <span class="o">&lt;=</span> <span class="mi">6</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">prev_val</span> <span class="o">=</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">cfg_topology</span><span class="p">;</span>
		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">cfg_topology</span> <span class="o">=</span> <span class="n">val</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">cfg_link_speed</span> <span class="o">==</span> <span class="n">LPFC_USER_LINK_SPEED_16G</span> <span class="o">&amp;&amp;</span>
			<span class="n">val</span> <span class="o">==</span> <span class="mi">4</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">lpfc_printf_vlog</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_INIT</span><span class="p">,</span>
				<span class="s">&quot;3113 Loop mode not supported at speed %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">phba</span><span class="o">-&gt;</span><span class="n">cfg_link_speed</span><span class="p">);</span>
			<span class="n">phba</span><span class="o">-&gt;</span><span class="n">cfg_topology</span> <span class="o">=</span> <span class="n">prev_val</span><span class="p">;</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">nolip</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">strlen</span><span class="p">(</span><span class="n">buf</span><span class="p">);</span>

		<span class="n">lpfc_printf_vlog</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_INIT</span><span class="p">,</span>
			<span class="s">&quot;3054 lpfc_topology changed from %d to %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">prev_val</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">lpfc_issue_lip</span><span class="p">(</span><span class="n">lpfc_shost_from_vport</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">pport</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">phba</span><span class="o">-&gt;</span><span class="n">cfg_topology</span> <span class="o">=</span> <span class="n">prev_val</span><span class="p">;</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="k">return</span> <span class="n">strlen</span><span class="p">(</span><span class="n">buf</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_INIT</span><span class="p">,</span>
		<span class="s">&quot;%d:0467 lpfc_topology attribute cannot be set to %d, &quot;</span>
		<span class="s">&quot;allowed range is [0, 6]</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">brd_no</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">lpfc_topology</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="n">module_param</span><span class="p">(</span><span class="n">lpfc_topology</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="n">S_IRUGO</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">lpfc_topology</span><span class="p">,</span> <span class="s">&quot;Select Fibre Channel topology&quot;</span><span class="p">);</span>
<span class="n">lpfc_param_show</span><span class="p">(</span><span class="n">topology</span><span class="p">)</span>
<span class="n">lpfc_param_init</span><span class="p">(</span><span class="n">topology</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span>
<span class="k">static</span> <span class="n">DEVICE_ATTR</span><span class="p">(</span><span class="n">lpfc_topology</span><span class="p">,</span> <span class="n">S_IRUGO</span> <span class="o">|</span> <span class="n">S_IWUSR</span><span class="p">,</span>
		<span class="n">lpfc_topology_show</span><span class="p">,</span> <span class="n">lpfc_topology_store</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_static_vport_show: Read callback function for</span>
<span class="cm"> *   lpfc_static_vport sysfs file.</span>
<span class="cm"> * @dev: Pointer to class device object.</span>
<span class="cm"> * @attr: device attribute structure.</span>
<span class="cm"> * @buf: Data buffer.</span>
<span class="cm"> *</span>
<span class="cm"> * This function is the read call back function for</span>
<span class="cm"> * lpfc_static_vport sysfs file. The lpfc_static_vport</span>
<span class="cm"> * sysfs file report the mageability of the vport.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">ssize_t</span>
<span class="nf">lpfc_static_vport_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span>
			 <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span>  <span class="o">*</span><span class="n">shost</span> <span class="o">=</span> <span class="n">class_to_shost</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="n">vport</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="p">)</span> <span class="n">shost</span><span class="o">-&gt;</span><span class="n">hostdata</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">vport_flag</span> <span class="o">&amp;</span> <span class="n">STATIC_VPORT</span><span class="p">)</span>
		<span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;1</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;0</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">strlen</span><span class="p">(</span><span class="n">buf</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Sysfs attribute to control the statistical data collection.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">DEVICE_ATTR</span><span class="p">(</span><span class="n">lpfc_static_vport</span><span class="p">,</span> <span class="n">S_IRUGO</span><span class="p">,</span>
		   <span class="n">lpfc_static_vport_show</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_stat_data_ctrl_store - write call back for lpfc_stat_data_ctrl sysfs file</span>
<span class="cm"> * @dev: Pointer to class device.</span>
<span class="cm"> * @buf: Data buffer.</span>
<span class="cm"> * @count: Size of the data buffer.</span>
<span class="cm"> *</span>
<span class="cm"> * This function get called when an user write to the lpfc_stat_data_ctrl</span>
<span class="cm"> * sysfs file. This function parse the command written to the sysfs file</span>
<span class="cm"> * and take appropriate action. These commands are used for controlling</span>
<span class="cm"> * driver statistical data collection.</span>
<span class="cm"> * Following are the command this function handles.</span>
<span class="cm"> *</span>
<span class="cm"> *    setbucket &lt;bucket_type&gt; &lt;base&gt; &lt;step&gt;</span>
<span class="cm"> *			       = Set the latency buckets.</span>
<span class="cm"> *    destroybucket            = destroy all the buckets.</span>
<span class="cm"> *    start                    = start data collection</span>
<span class="cm"> *    stop                     = stop data collection</span>
<span class="cm"> *    reset                    = reset the collected data</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">ssize_t</span>
<span class="nf">lpfc_stat_data_ctrl_store</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span>
			  <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span>  <span class="o">*</span><span class="n">shost</span> <span class="o">=</span> <span class="n">class_to_shost</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="n">vport</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="p">)</span> <span class="n">shost</span><span class="o">-&gt;</span><span class="n">hostdata</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_hba</span>   <span class="o">*</span><span class="n">phba</span> <span class="o">=</span> <span class="n">vport</span><span class="o">-&gt;</span><span class="n">phba</span><span class="p">;</span>
<span class="cp">#define LPFC_MAX_DATA_CTRL_LEN 1024</span>
	<span class="k">static</span> <span class="kt">char</span> <span class="n">bucket_data</span><span class="p">[</span><span class="n">LPFC_MAX_DATA_CTRL_LEN</span><span class="p">];</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">str_ptr</span><span class="p">,</span> <span class="o">*</span><span class="n">token</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">**</span><span class="n">vports</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">v_shost</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">bucket_type_str</span><span class="p">,</span> <span class="o">*</span><span class="n">base_str</span><span class="p">,</span> <span class="o">*</span><span class="n">step_str</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">base</span><span class="p">,</span> <span class="n">step</span><span class="p">,</span> <span class="n">bucket_type</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strncmp</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;setbucket&quot;</span><span class="p">,</span> <span class="n">strlen</span><span class="p">(</span><span class="s">&quot;setbucket&quot;</span><span class="p">)))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">strlen</span><span class="p">(</span><span class="n">buf</span><span class="p">)</span> <span class="o">&gt;</span> <span class="p">(</span><span class="n">LPFC_MAX_DATA_CTRL_LEN</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

		<span class="n">strcpy</span><span class="p">(</span><span class="n">bucket_data</span><span class="p">,</span> <span class="n">buf</span><span class="p">);</span>
		<span class="n">str_ptr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">bucket_data</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
		<span class="cm">/* Ignore this token - this is command token */</span>
		<span class="n">token</span> <span class="o">=</span> <span class="n">strsep</span><span class="p">(</span><span class="o">&amp;</span><span class="n">str_ptr</span><span class="p">,</span> <span class="s">&quot;</span><span class="se">\t</span><span class="s"> &quot;</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">token</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

		<span class="n">bucket_type_str</span> <span class="o">=</span> <span class="n">strsep</span><span class="p">(</span><span class="o">&amp;</span><span class="n">str_ptr</span><span class="p">,</span> <span class="s">&quot;</span><span class="se">\t</span><span class="s"> &quot;</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bucket_type_str</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strncmp</span><span class="p">(</span><span class="n">bucket_type_str</span><span class="p">,</span> <span class="s">&quot;linear&quot;</span><span class="p">,</span> <span class="n">strlen</span><span class="p">(</span><span class="s">&quot;linear&quot;</span><span class="p">)))</span>
			<span class="n">bucket_type</span> <span class="o">=</span> <span class="n">LPFC_LINEAR_BUCKET</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strncmp</span><span class="p">(</span><span class="n">bucket_type_str</span><span class="p">,</span> <span class="s">&quot;power2&quot;</span><span class="p">,</span> <span class="n">strlen</span><span class="p">(</span><span class="s">&quot;power2&quot;</span><span class="p">)))</span>
			<span class="n">bucket_type</span> <span class="o">=</span> <span class="n">LPFC_POWER2_BUCKET</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

		<span class="n">base_str</span> <span class="o">=</span> <span class="n">strsep</span><span class="p">(</span><span class="o">&amp;</span><span class="n">str_ptr</span><span class="p">,</span> <span class="s">&quot;</span><span class="se">\t</span><span class="s"> &quot;</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">base_str</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="n">base</span> <span class="o">=</span> <span class="n">simple_strtoul</span><span class="p">(</span><span class="n">base_str</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

		<span class="n">step_str</span> <span class="o">=</span> <span class="n">strsep</span><span class="p">(</span><span class="o">&amp;</span><span class="n">str_ptr</span><span class="p">,</span> <span class="s">&quot;</span><span class="se">\t</span><span class="s"> &quot;</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">step_str</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="n">step</span> <span class="o">=</span> <span class="n">simple_strtoul</span><span class="p">(</span><span class="n">step_str</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">step</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

		<span class="cm">/* Block the data collection for every vport */</span>
		<span class="n">vports</span> <span class="o">=</span> <span class="n">lpfc_create_vport_work_array</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">vports</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">max_vports</span> <span class="o">&amp;&amp;</span> <span class="n">vports</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">v_shost</span> <span class="o">=</span> <span class="n">lpfc_shost_from_vport</span><span class="p">(</span><span class="n">vports</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
			<span class="n">spin_lock_irq</span><span class="p">(</span><span class="n">v_shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>
			<span class="cm">/* Block and reset data collection */</span>
			<span class="n">vports</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">stat_data_blocked</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">vports</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">stat_data_enabled</span><span class="p">)</span>
				<span class="n">lpfc_vport_reset_stat_data</span><span class="p">(</span><span class="n">vports</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
			<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="n">v_shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="cm">/* Set the bucket attributes */</span>
		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">bucket_type</span> <span class="o">=</span> <span class="n">bucket_type</span><span class="p">;</span>
		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">bucket_base</span> <span class="o">=</span> <span class="n">base</span><span class="p">;</span>
		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">bucket_step</span> <span class="o">=</span> <span class="n">step</span><span class="p">;</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">max_vports</span> <span class="o">&amp;&amp;</span> <span class="n">vports</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">v_shost</span> <span class="o">=</span> <span class="n">lpfc_shost_from_vport</span><span class="p">(</span><span class="n">vports</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>

			<span class="cm">/* Unblock data collection */</span>
			<span class="n">spin_lock_irq</span><span class="p">(</span><span class="n">v_shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>
			<span class="n">vports</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">stat_data_blocked</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="n">v_shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">lpfc_destroy_vport_work_array</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">vports</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">strlen</span><span class="p">(</span><span class="n">buf</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strncmp</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;destroybucket&quot;</span><span class="p">,</span> <span class="n">strlen</span><span class="p">(</span><span class="s">&quot;destroybucket&quot;</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">vports</span> <span class="o">=</span> <span class="n">lpfc_create_vport_work_array</span><span class="p">(</span><span class="n">phba</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">vports</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">max_vports</span> <span class="o">&amp;&amp;</span> <span class="n">vports</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">v_shost</span> <span class="o">=</span> <span class="n">lpfc_shost_from_vport</span><span class="p">(</span><span class="n">vports</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
			<span class="n">spin_lock_irq</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>
			<span class="n">vports</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">stat_data_blocked</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">lpfc_free_bucket</span><span class="p">(</span><span class="n">vport</span><span class="p">);</span>
			<span class="n">vport</span><span class="o">-&gt;</span><span class="n">stat_data_enabled</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">vports</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">stat_data_blocked</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">lpfc_destroy_vport_work_array</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">vports</span><span class="p">);</span>
		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">bucket_type</span> <span class="o">=</span> <span class="n">LPFC_NO_BUCKET</span><span class="p">;</span>
		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">bucket_base</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">bucket_step</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">return</span> <span class="n">strlen</span><span class="p">(</span><span class="n">buf</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strncmp</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;start&quot;</span><span class="p">,</span> <span class="n">strlen</span><span class="p">(</span><span class="s">&quot;start&quot;</span><span class="p">)))</span> <span class="p">{</span>
		<span class="cm">/* If no buckets configured return error */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">bucket_type</span> <span class="o">==</span> <span class="n">LPFC_NO_BUCKET</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="n">spin_lock_irq</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">stat_data_enabled</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">strlen</span><span class="p">(</span><span class="n">buf</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">lpfc_alloc_bucket</span><span class="p">(</span><span class="n">vport</span><span class="p">);</span>
		<span class="n">vport</span><span class="o">-&gt;</span><span class="n">stat_data_enabled</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">strlen</span><span class="p">(</span><span class="n">buf</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strncmp</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;stop&quot;</span><span class="p">,</span> <span class="n">strlen</span><span class="p">(</span><span class="s">&quot;stop&quot;</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">spin_lock_irq</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">stat_data_enabled</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">strlen</span><span class="p">(</span><span class="n">buf</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">lpfc_free_bucket</span><span class="p">(</span><span class="n">vport</span><span class="p">);</span>
		<span class="n">vport</span><span class="o">-&gt;</span><span class="n">stat_data_enabled</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">strlen</span><span class="p">(</span><span class="n">buf</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strncmp</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;reset&quot;</span><span class="p">,</span> <span class="n">strlen</span><span class="p">(</span><span class="s">&quot;reset&quot;</span><span class="p">)))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">bucket_type</span> <span class="o">==</span> <span class="n">LPFC_NO_BUCKET</span><span class="p">)</span>
			<span class="o">||</span> <span class="o">!</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">stat_data_enabled</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">strlen</span><span class="p">(</span><span class="n">buf</span><span class="p">);</span>
		<span class="n">spin_lock_irq</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>
		<span class="n">vport</span><span class="o">-&gt;</span><span class="n">stat_data_blocked</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">lpfc_vport_reset_stat_data</span><span class="p">(</span><span class="n">vport</span><span class="p">);</span>
		<span class="n">vport</span><span class="o">-&gt;</span><span class="n">stat_data_blocked</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">strlen</span><span class="p">(</span><span class="n">buf</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/**</span>
<span class="cm"> * lpfc_stat_data_ctrl_show - Read function for lpfc_stat_data_ctrl sysfs file</span>
<span class="cm"> * @dev: Pointer to class device object.</span>
<span class="cm"> * @buf: Data buffer.</span>
<span class="cm"> *</span>
<span class="cm"> * This function is the read call back function for</span>
<span class="cm"> * lpfc_stat_data_ctrl sysfs file. This function report the</span>
<span class="cm"> * current statistical data collection state.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">ssize_t</span>
<span class="nf">lpfc_stat_data_ctrl_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span>
			 <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span>  <span class="o">*</span><span class="n">shost</span> <span class="o">=</span> <span class="n">class_to_shost</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="n">vport</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="p">)</span> <span class="n">shost</span><span class="o">-&gt;</span><span class="n">hostdata</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_hba</span>   <span class="o">*</span><span class="n">phba</span> <span class="o">=</span> <span class="n">vport</span><span class="o">-&gt;</span><span class="n">phba</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">bucket_type</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">bucket_value</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">bucket_type</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">LPFC_LINEAR_BUCKET</span>:
		<span class="n">bucket_type</span> <span class="o">=</span> <span class="s">&quot;linear&quot;</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">LPFC_POWER2_BUCKET</span>:
		<span class="n">bucket_type</span> <span class="o">=</span> <span class="s">&quot;power2&quot;</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">bucket_type</span> <span class="o">=</span> <span class="s">&quot;No Bucket&quot;</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">sprintf</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buf</span><span class="p">[</span><span class="n">index</span><span class="p">],</span> <span class="s">&quot;Statistical Data enabled :%d, &quot;</span>
		<span class="s">&quot;blocked :%d, Bucket type :%s, Bucket base :%d,&quot;</span>
		<span class="s">&quot; Bucket step :%d</span><span class="se">\n</span><span class="s">Latency Ranges :&quot;</span><span class="p">,</span>
		<span class="n">vport</span><span class="o">-&gt;</span><span class="n">stat_data_enabled</span><span class="p">,</span> <span class="n">vport</span><span class="o">-&gt;</span><span class="n">stat_data_blocked</span><span class="p">,</span>
		<span class="n">bucket_type</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">bucket_base</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">bucket_step</span><span class="p">);</span>
	<span class="n">index</span> <span class="o">=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">buf</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">bucket_type</span> <span class="o">!=</span> <span class="n">LPFC_NO_BUCKET</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">LPFC_MAX_BUCKET_COUNT</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">bucket_type</span> <span class="o">==</span> <span class="n">LPFC_LINEAR_BUCKET</span><span class="p">)</span>
				<span class="n">bucket_value</span> <span class="o">=</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">bucket_base</span> <span class="o">+</span>
					<span class="n">phba</span><span class="o">-&gt;</span><span class="n">bucket_step</span> <span class="o">*</span> <span class="n">i</span><span class="p">;</span>
			<span class="k">else</span>
				<span class="n">bucket_value</span> <span class="o">=</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">bucket_base</span> <span class="o">+</span>
				<span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">i</span><span class="p">)</span> <span class="o">*</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">bucket_step</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">index</span> <span class="o">+</span> <span class="mi">10</span> <span class="o">&gt;</span> <span class="n">PAGE_SIZE</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="n">sprintf</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buf</span><span class="p">[</span><span class="n">index</span><span class="p">],</span> <span class="s">&quot;%08ld &quot;</span><span class="p">,</span> <span class="n">bucket_value</span><span class="p">);</span>
			<span class="n">index</span> <span class="o">=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">buf</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">sprintf</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buf</span><span class="p">[</span><span class="n">index</span><span class="p">],</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">strlen</span><span class="p">(</span><span class="n">buf</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Sysfs attribute to control the statistical data collection.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">DEVICE_ATTR</span><span class="p">(</span><span class="n">lpfc_stat_data_ctrl</span><span class="p">,</span> <span class="n">S_IRUGO</span> <span class="o">|</span> <span class="n">S_IWUSR</span><span class="p">,</span>
		   <span class="n">lpfc_stat_data_ctrl_show</span><span class="p">,</span> <span class="n">lpfc_stat_data_ctrl_store</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * lpfc_drvr_stat_data: sysfs attr to get driver statistical data.</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * Each Bucket takes 11 characters and 1 new line + 17 bytes WWN</span>
<span class="cm"> * for each target.</span>
<span class="cm"> */</span>
<span class="cp">#define STAT_DATA_SIZE_PER_TARGET(NUM_BUCKETS) ((NUM_BUCKETS) * 11 + 18)</span>
<span class="cp">#define MAX_STAT_DATA_SIZE_PER_TARGET \</span>
<span class="cp">	STAT_DATA_SIZE_PER_TARGET(LPFC_MAX_BUCKET_COUNT)</span>


<span class="cm">/**</span>
<span class="cm"> * sysfs_drvr_stat_data_read - Read function for lpfc_drvr_stat_data attribute</span>
<span class="cm"> * @filp: sysfs file</span>
<span class="cm"> * @kobj: Pointer to the kernel object</span>
<span class="cm"> * @bin_attr: Attribute object</span>
<span class="cm"> * @buff: Buffer pointer</span>
<span class="cm"> * @off: File offset</span>
<span class="cm"> * @count: Buffer size</span>
<span class="cm"> *</span>
<span class="cm"> * This function is the read call back function for lpfc_drvr_stat_data</span>
<span class="cm"> * sysfs file. This function export the statistical data to user</span>
<span class="cm"> * applications.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">ssize_t</span>
<span class="nf">sysfs_drvr_stat_data_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kobject</span> <span class="o">*</span><span class="n">kobj</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">bin_attribute</span> <span class="o">*</span><span class="n">bin_attr</span><span class="p">,</span>
		<span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">off</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">kobj</span><span class="p">,</span> <span class="k">struct</span> <span class="n">device</span><span class="p">,</span>
		<span class="n">kobj</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span>  <span class="o">*</span><span class="n">shost</span> <span class="o">=</span> <span class="n">class_to_shost</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="n">vport</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="p">)</span> <span class="n">shost</span><span class="o">-&gt;</span><span class="n">hostdata</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_hba</span>   <span class="o">*</span><span class="n">phba</span> <span class="o">=</span> <span class="n">vport</span><span class="o">-&gt;</span><span class="n">phba</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">nport_index</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_nodelist</span> <span class="o">*</span><span class="n">ndlp</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">nport_index</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">off</span> <span class="o">/</span>
		<span class="n">MAX_STAT_DATA_SIZE_PER_TARGET</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">stat_data_enabled</span> <span class="o">||</span> <span class="n">vport</span><span class="o">-&gt;</span><span class="n">stat_data_blocked</span>
		<span class="o">||</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">bucket_type</span> <span class="o">==</span> <span class="n">LPFC_NO_BUCKET</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">ndlp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_nodes</span><span class="p">,</span> <span class="n">nlp_listp</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">NLP_CHK_NODE_ACT</span><span class="p">(</span><span class="n">ndlp</span><span class="p">)</span> <span class="o">||</span> <span class="o">!</span><span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">lat_data</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">nport_index</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">nport_index</span><span class="o">--</span><span class="p">;</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">((</span><span class="n">index</span> <span class="o">+</span> <span class="n">MAX_STAT_DATA_SIZE_PER_TARGET</span><span class="p">)</span>
			<span class="o">&gt;</span> <span class="n">count</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">lat_data</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="cm">/* Print the WWN */</span>
		<span class="n">sprintf</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buf</span><span class="p">[</span><span class="n">index</span><span class="p">],</span> <span class="s">&quot;%02x%02x%02x%02x%02x%02x%02x%02x:&quot;</span><span class="p">,</span>
			<span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_portname</span><span class="p">.</span><span class="n">u</span><span class="p">.</span><span class="n">wwn</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
			<span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_portname</span><span class="p">.</span><span class="n">u</span><span class="p">.</span><span class="n">wwn</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
			<span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_portname</span><span class="p">.</span><span class="n">u</span><span class="p">.</span><span class="n">wwn</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span>
			<span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_portname</span><span class="p">.</span><span class="n">u</span><span class="p">.</span><span class="n">wwn</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span>
			<span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_portname</span><span class="p">.</span><span class="n">u</span><span class="p">.</span><span class="n">wwn</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span>
			<span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_portname</span><span class="p">.</span><span class="n">u</span><span class="p">.</span><span class="n">wwn</span><span class="p">[</span><span class="mi">5</span><span class="p">],</span>
			<span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_portname</span><span class="p">.</span><span class="n">u</span><span class="p">.</span><span class="n">wwn</span><span class="p">[</span><span class="mi">6</span><span class="p">],</span>
			<span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_portname</span><span class="p">.</span><span class="n">u</span><span class="p">.</span><span class="n">wwn</span><span class="p">[</span><span class="mi">7</span><span class="p">]);</span>

		<span class="n">index</span> <span class="o">=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">buf</span><span class="p">);</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">LPFC_MAX_BUCKET_COUNT</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">sprintf</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buf</span><span class="p">[</span><span class="n">index</span><span class="p">],</span> <span class="s">&quot;%010u,&quot;</span><span class="p">,</span>
				<span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">lat_data</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">cmd_count</span><span class="p">);</span>
			<span class="n">index</span> <span class="o">=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">buf</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">sprintf</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buf</span><span class="p">[</span><span class="n">index</span><span class="p">],</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">index</span> <span class="o">=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">buf</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">index</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">bin_attribute</span> <span class="n">sysfs_drvr_stat_data_attr</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">attr</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;lpfc_drvr_stat_data&quot;</span><span class="p">,</span>
		<span class="p">.</span><span class="n">mode</span> <span class="o">=</span> <span class="n">S_IRUSR</span><span class="p">,</span>
	<span class="p">},</span>
	<span class="p">.</span><span class="n">size</span> <span class="o">=</span> <span class="n">LPFC_MAX_TARGET</span> <span class="o">*</span> <span class="n">MAX_STAT_DATA_SIZE_PER_TARGET</span><span class="p">,</span>
	<span class="p">.</span><span class="n">read</span> <span class="o">=</span> <span class="n">sysfs_drvr_stat_data_read</span><span class="p">,</span>
	<span class="p">.</span><span class="n">write</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"># lpfc_link_speed: Link speed selection for initializing the Fibre Channel</span>
<span class="cm"># connection.</span>
<span class="cm"># Value range is [0,16]. Default value is 0.</span>
<span class="cm">*/</span>
<span class="cm">/**</span>
<span class="cm"> * lpfc_link_speed_set - Set the adapters link speed</span>
<span class="cm"> * @phba: lpfc_hba pointer.</span>
<span class="cm"> * @val: link speed value.</span>
<span class="cm"> *</span>
<span class="cm"> * Description:</span>
<span class="cm"> * If val is in a valid range then set the adapter&#39;s link speed field and</span>
<span class="cm"> * issue a lip; if the lip fails reset the link speed to the old value.</span>
<span class="cm"> *</span>
<span class="cm"> * Notes:</span>
<span class="cm"> * If the value is not in range log a kernel error message and return an error.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns:</span>
<span class="cm"> * zero if val is in range and lip okay.</span>
<span class="cm"> * non-zero return value from lpfc_issue_lip()</span>
<span class="cm"> * -EINVAL val out of range</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">ssize_t</span>
<span class="nf">lpfc_link_speed_store</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span>
		<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span>  <span class="o">*</span><span class="n">shost</span> <span class="o">=</span> <span class="n">class_to_shost</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="n">vport</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="p">)</span> <span class="n">shost</span><span class="o">-&gt;</span><span class="n">hostdata</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_hba</span>   <span class="o">*</span><span class="n">phba</span> <span class="o">=</span> <span class="n">vport</span><span class="o">-&gt;</span><span class="n">phba</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">val</span> <span class="o">=</span> <span class="n">LPFC_USER_LINK_SPEED_AUTO</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">nolip</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">val_buf</span> <span class="o">=</span> <span class="n">buf</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">prev_val</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strncmp</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;nolip &quot;</span><span class="p">,</span> <span class="n">strlen</span><span class="p">(</span><span class="s">&quot;nolip &quot;</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">nolip</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">val_buf</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">buf</span><span class="p">[</span><span class="n">strlen</span><span class="p">(</span><span class="s">&quot;nolip &quot;</span><span class="p">)];</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">isdigit</span><span class="p">(</span><span class="n">val_buf</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sscanf</span><span class="p">(</span><span class="n">val_buf</span><span class="p">,</span> <span class="s">&quot;%i&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">val</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">lpfc_printf_vlog</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_INIT</span><span class="p">,</span>
		<span class="s">&quot;3055 lpfc_link_speed changed from %d to %d %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">cfg_link_speed</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">nolip</span> <span class="o">?</span> <span class="s">&quot;(nolip)&quot;</span> <span class="o">:</span> <span class="s">&quot;(lip)&quot;</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(((</span><span class="n">val</span> <span class="o">==</span> <span class="n">LPFC_USER_LINK_SPEED_1G</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">lmt</span> <span class="o">&amp;</span> <span class="n">LMT_1Gb</span><span class="p">))</span> <span class="o">||</span>
	    <span class="p">((</span><span class="n">val</span> <span class="o">==</span> <span class="n">LPFC_USER_LINK_SPEED_2G</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">lmt</span> <span class="o">&amp;</span> <span class="n">LMT_2Gb</span><span class="p">))</span> <span class="o">||</span>
	    <span class="p">((</span><span class="n">val</span> <span class="o">==</span> <span class="n">LPFC_USER_LINK_SPEED_4G</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">lmt</span> <span class="o">&amp;</span> <span class="n">LMT_4Gb</span><span class="p">))</span> <span class="o">||</span>
	    <span class="p">((</span><span class="n">val</span> <span class="o">==</span> <span class="n">LPFC_USER_LINK_SPEED_8G</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">lmt</span> <span class="o">&amp;</span> <span class="n">LMT_8Gb</span><span class="p">))</span> <span class="o">||</span>
	    <span class="p">((</span><span class="n">val</span> <span class="o">==</span> <span class="n">LPFC_USER_LINK_SPEED_10G</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">lmt</span> <span class="o">&amp;</span> <span class="n">LMT_10Gb</span><span class="p">))</span> <span class="o">||</span>
	    <span class="p">((</span><span class="n">val</span> <span class="o">==</span> <span class="n">LPFC_USER_LINK_SPEED_16G</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">lmt</span> <span class="o">&amp;</span> <span class="n">LMT_16Gb</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_INIT</span><span class="p">,</span>
				<span class="s">&quot;2879 lpfc_link_speed attribute cannot be set &quot;</span>
				<span class="s">&quot;to %d. Speed is not supported by this port.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">val</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">val</span> <span class="o">==</span> <span class="n">LPFC_USER_LINK_SPEED_16G</span> <span class="o">&amp;&amp;</span>
		 <span class="n">phba</span><span class="o">-&gt;</span><span class="n">fc_topology</span> <span class="o">==</span> <span class="n">LPFC_TOPOLOGY_LOOP</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_INIT</span><span class="p">,</span>
				<span class="s">&quot;3112 lpfc_link_speed attribute cannot be set &quot;</span>
				<span class="s">&quot;to %d. Speed is not supported in loop mode.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">val</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">val</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">val</span> <span class="o">&lt;=</span> <span class="n">LPFC_USER_LINK_SPEED_MAX</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">LPFC_USER_LINK_SPEED_BITMAP</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">val</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">prev_val</span> <span class="o">=</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">cfg_link_speed</span><span class="p">;</span>
		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">cfg_link_speed</span> <span class="o">=</span> <span class="n">val</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">nolip</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">strlen</span><span class="p">(</span><span class="n">buf</span><span class="p">);</span>

		<span class="n">err</span> <span class="o">=</span> <span class="n">lpfc_issue_lip</span><span class="p">(</span><span class="n">lpfc_shost_from_vport</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">pport</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">phba</span><span class="o">-&gt;</span><span class="n">cfg_link_speed</span> <span class="o">=</span> <span class="n">prev_val</span><span class="p">;</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="k">return</span> <span class="n">strlen</span><span class="p">(</span><span class="n">buf</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_INIT</span><span class="p">,</span>
		<span class="s">&quot;0469 lpfc_link_speed attribute cannot be set to %d, &quot;</span>
		<span class="s">&quot;allowed values are [&quot;</span><span class="n">LPFC_LINK_SPEED_STRING</span><span class="s">&quot;]</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">lpfc_link_speed</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="n">module_param</span><span class="p">(</span><span class="n">lpfc_link_speed</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="n">S_IRUGO</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">lpfc_link_speed</span><span class="p">,</span> <span class="s">&quot;Select link speed&quot;</span><span class="p">);</span>
<span class="n">lpfc_param_show</span><span class="p">(</span><span class="n">link_speed</span><span class="p">)</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_link_speed_init - Set the adapters link speed</span>
<span class="cm"> * @phba: lpfc_hba pointer.</span>
<span class="cm"> * @val: link speed value.</span>
<span class="cm"> *</span>
<span class="cm"> * Description:</span>
<span class="cm"> * If val is in a valid range then set the adapter&#39;s link speed field.</span>
<span class="cm"> *</span>
<span class="cm"> * Notes:</span>
<span class="cm"> * If the value is not in range log a kernel error message, clear the link</span>
<span class="cm"> * speed and return an error.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns:</span>
<span class="cm"> * zero if val saved.</span>
<span class="cm"> * -EINVAL val out of range</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="n">lpfc_link_speed_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">,</span> <span class="kt">int</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">val</span> <span class="o">==</span> <span class="n">LPFC_USER_LINK_SPEED_16G</span> <span class="o">&amp;&amp;</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">cfg_topology</span> <span class="o">==</span> <span class="mi">4</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_INIT</span><span class="p">,</span>
			<span class="s">&quot;3111 lpfc_link_speed of %d cannot &quot;</span>
			<span class="s">&quot;support loop mode, setting topology to default.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			 <span class="n">val</span><span class="p">);</span>
		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">cfg_topology</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">val</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">val</span> <span class="o">&lt;=</span> <span class="n">LPFC_USER_LINK_SPEED_MAX</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">LPFC_USER_LINK_SPEED_BITMAP</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">val</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">cfg_link_speed</span> <span class="o">=</span> <span class="n">val</span><span class="p">;</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_INIT</span><span class="p">,</span>
			<span class="s">&quot;0405 lpfc_link_speed attribute cannot &quot;</span>
			<span class="s">&quot;be set to %d, allowed values are &quot;</span>
			<span class="s">&quot;[&quot;</span><span class="n">LPFC_LINK_SPEED_STRING</span><span class="s">&quot;]</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">cfg_link_speed</span> <span class="o">=</span> <span class="n">LPFC_USER_LINK_SPEED_AUTO</span><span class="p">;</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">DEVICE_ATTR</span><span class="p">(</span><span class="n">lpfc_link_speed</span><span class="p">,</span> <span class="n">S_IRUGO</span> <span class="o">|</span> <span class="n">S_IWUSR</span><span class="p">,</span>
		   <span class="n">lpfc_link_speed_show</span><span class="p">,</span> <span class="n">lpfc_link_speed_store</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"># lpfc_aer_support: Support PCIe device Advanced Error Reporting (AER)</span>
<span class="cm">#       0  = aer disabled or not supported</span>
<span class="cm">#       1  = aer supported and enabled (default)</span>
<span class="cm"># Value range is [0,1]. Default value is 1.</span>
<span class="cm">*/</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_aer_support_store - Set the adapter for aer support</span>
<span class="cm"> *</span>
<span class="cm"> * @dev: class device that is converted into a Scsi_host.</span>
<span class="cm"> * @attr: device attribute, not used.</span>
<span class="cm"> * @buf: containing enable or disable aer flag.</span>
<span class="cm"> * @count: unused variable.</span>
<span class="cm"> *</span>
<span class="cm"> * Description:</span>
<span class="cm"> * If the val is 1 and currently the device&#39;s AER capability was not</span>
<span class="cm"> * enabled, invoke the kernel&#39;s enable AER helper routine, trying to</span>
<span class="cm"> * enable the device&#39;s AER capability. If the helper routine enabling</span>
<span class="cm"> * AER returns success, update the device&#39;s cfg_aer_support flag to</span>
<span class="cm"> * indicate AER is supported by the device; otherwise, if the device</span>
<span class="cm"> * AER capability is already enabled to support AER, then do nothing.</span>
<span class="cm"> *</span>
<span class="cm"> * If the val is 0 and currently the device&#39;s AER support was enabled,</span>
<span class="cm"> * invoke the kernel&#39;s disable AER helper routine. After that, update</span>
<span class="cm"> * the device&#39;s cfg_aer_support flag to indicate AER is not supported</span>
<span class="cm"> * by the device; otherwise, if the device AER capability is already</span>
<span class="cm"> * disabled from supporting AER, then do nothing.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns:</span>
<span class="cm"> * length of the buf on success if val is in range the intended mode</span>
<span class="cm"> * is supported.</span>
<span class="cm"> * -EINVAL if val out of range or intended mode is not supported.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">ssize_t</span>
<span class="nf">lpfc_aer_support_store</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span>
		       <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span> <span class="o">=</span> <span class="n">class_to_shost</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="n">vport</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="p">)</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">hostdata</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span> <span class="o">=</span> <span class="n">vport</span><span class="o">-&gt;</span><span class="n">phba</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">val</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">isdigit</span><span class="p">(</span><span class="n">buf</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sscanf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;%i&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">val</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">val</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="mi">0</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hba_flag</span> <span class="o">&amp;</span> <span class="n">HBA_AER_ENABLED</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">rc</span> <span class="o">=</span> <span class="n">pci_disable_pcie_error_reporting</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">pcidev</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>
				<span class="n">phba</span><span class="o">-&gt;</span><span class="n">hba_flag</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">HBA_AER_ENABLED</span><span class="p">;</span>
				<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>
				<span class="n">phba</span><span class="o">-&gt;</span><span class="n">cfg_aer_support</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
				<span class="n">rc</span> <span class="o">=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">buf</span><span class="p">);</span>
			<span class="p">}</span> <span class="k">else</span>
				<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">phba</span><span class="o">-&gt;</span><span class="n">cfg_aer_support</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">rc</span> <span class="o">=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">buf</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">1</span>:
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hba_flag</span> <span class="o">&amp;</span> <span class="n">HBA_AER_ENABLED</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">rc</span> <span class="o">=</span> <span class="n">pci_enable_pcie_error_reporting</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">pcidev</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>
				<span class="n">phba</span><span class="o">-&gt;</span><span class="n">hba_flag</span> <span class="o">|=</span> <span class="n">HBA_AER_ENABLED</span><span class="p">;</span>
				<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>
				<span class="n">phba</span><span class="o">-&gt;</span><span class="n">cfg_aer_support</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
				<span class="n">rc</span> <span class="o">=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">buf</span><span class="p">);</span>
			<span class="p">}</span> <span class="k">else</span>
				 <span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">phba</span><span class="o">-&gt;</span><span class="n">cfg_aer_support</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">rc</span> <span class="o">=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">buf</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">lpfc_aer_support</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="n">module_param</span><span class="p">(</span><span class="n">lpfc_aer_support</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="n">S_IRUGO</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">lpfc_aer_support</span><span class="p">,</span> <span class="s">&quot;Enable PCIe device AER support&quot;</span><span class="p">);</span>
<span class="n">lpfc_param_show</span><span class="p">(</span><span class="n">aer_support</span><span class="p">)</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_aer_support_init - Set the initial adapters aer support flag</span>
<span class="cm"> * @phba: lpfc_hba pointer.</span>
<span class="cm"> * @val: enable aer or disable aer flag.</span>
<span class="cm"> *</span>
<span class="cm"> * Description:</span>
<span class="cm"> * If val is in a valid range [0,1], then set the adapter&#39;s initial</span>
<span class="cm"> * cfg_aer_support field. It will be up to the driver&#39;s probe_one</span>
<span class="cm"> * routine to determine whether the device&#39;s AER support can be set</span>
<span class="cm"> * or not.</span>
<span class="cm"> *</span>
<span class="cm"> * Notes:</span>
<span class="cm"> * If the value is not in range log a kernel error message, and</span>
<span class="cm"> * choose the default value of setting AER support and return.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns:</span>
<span class="cm"> * zero if val saved.</span>
<span class="cm"> * -EINVAL val out of range</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="n">lpfc_aer_support_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">,</span> <span class="kt">int</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">val</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">val</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">cfg_aer_support</span> <span class="o">=</span> <span class="n">val</span><span class="p">;</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_INIT</span><span class="p">,</span>
			<span class="s">&quot;2712 lpfc_aer_support attribute value %d out &quot;</span>
			<span class="s">&quot;of range, allowed values are 0|1, setting it &quot;</span>
			<span class="s">&quot;to default value of 1</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
	<span class="cm">/* By default, try to enable AER on a device */</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">cfg_aer_support</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">DEVICE_ATTR</span><span class="p">(</span><span class="n">lpfc_aer_support</span><span class="p">,</span> <span class="n">S_IRUGO</span> <span class="o">|</span> <span class="n">S_IWUSR</span><span class="p">,</span>
		   <span class="n">lpfc_aer_support_show</span><span class="p">,</span> <span class="n">lpfc_aer_support_store</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_aer_cleanup_state - Clean up aer state to the aer enabled device</span>
<span class="cm"> * @dev: class device that is converted into a Scsi_host.</span>
<span class="cm"> * @attr: device attribute, not used.</span>
<span class="cm"> * @buf: containing flag 1 for aer cleanup state.</span>
<span class="cm"> * @count: unused variable.</span>
<span class="cm"> *</span>
<span class="cm"> * Description:</span>
<span class="cm"> * If the @buf contains 1 and the device currently has the AER support</span>
<span class="cm"> * enabled, then invokes the kernel AER helper routine</span>
<span class="cm"> * pci_cleanup_aer_uncorrect_error_status to clean up the uncorrectable</span>
<span class="cm"> * error status register.</span>
<span class="cm"> *</span>
<span class="cm"> * Notes:</span>
<span class="cm"> *</span>
<span class="cm"> * Returns:</span>
<span class="cm"> * -EINVAL if the buf does not contain the 1 or the device is not currently</span>
<span class="cm"> * enabled with the AER support.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">ssize_t</span>
<span class="nf">lpfc_aer_cleanup_state</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span>
		       <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span>  <span class="o">*</span><span class="n">shost</span> <span class="o">=</span> <span class="n">class_to_shost</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="n">vport</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="p">)</span> <span class="n">shost</span><span class="o">-&gt;</span><span class="n">hostdata</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_hba</span>   <span class="o">*</span><span class="n">phba</span> <span class="o">=</span> <span class="n">vport</span><span class="o">-&gt;</span><span class="n">phba</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">val</span><span class="p">,</span> <span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">isdigit</span><span class="p">(</span><span class="n">buf</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sscanf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;%i&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">val</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">val</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hba_flag</span> <span class="o">&amp;</span> <span class="n">HBA_AER_ENABLED</span><span class="p">)</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">pci_cleanup_aer_uncorrect_error_status</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">pcidev</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">strlen</span><span class="p">(</span><span class="n">buf</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">DEVICE_ATTR</span><span class="p">(</span><span class="n">lpfc_aer_state_cleanup</span><span class="p">,</span> <span class="n">S_IWUSR</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span>
		   <span class="n">lpfc_aer_cleanup_state</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_sriov_nr_virtfn_store - Enable the adapter for sr-iov virtual functions</span>
<span class="cm"> *</span>
<span class="cm"> * @dev: class device that is converted into a Scsi_host.</span>
<span class="cm"> * @attr: device attribute, not used.</span>
<span class="cm"> * @buf: containing the string the number of vfs to be enabled.</span>
<span class="cm"> * @count: unused variable.</span>
<span class="cm"> *</span>
<span class="cm"> * Description:</span>
<span class="cm"> * When this api is called either through user sysfs, the driver shall</span>
<span class="cm"> * try to enable or disable SR-IOV virtual functions according to the</span>
<span class="cm"> * following:</span>
<span class="cm"> *</span>
<span class="cm"> * If zero virtual function has been enabled to the physical function,</span>
<span class="cm"> * the driver shall invoke the pci enable virtual function api trying</span>
<span class="cm"> * to enable the virtual functions. If the nr_vfn provided is greater</span>
<span class="cm"> * than the maximum supported, the maximum virtual function number will</span>
<span class="cm"> * be used for invoking the api; otherwise, the nr_vfn provided shall</span>
<span class="cm"> * be used for invoking the api. If the api call returned success, the</span>
<span class="cm"> * actual number of virtual functions enabled will be set to the driver</span>
<span class="cm"> * cfg_sriov_nr_virtfn; otherwise, -EINVAL shall be returned and driver</span>
<span class="cm"> * cfg_sriov_nr_virtfn remains zero.</span>
<span class="cm"> *</span>
<span class="cm"> * If none-zero virtual functions have already been enabled to the</span>
<span class="cm"> * physical function, as reflected by the driver&#39;s cfg_sriov_nr_virtfn,</span>
<span class="cm"> * -EINVAL will be returned and the driver does nothing;</span>
<span class="cm"> *</span>
<span class="cm"> * If the nr_vfn provided is zero and none-zero virtual functions have</span>
<span class="cm"> * been enabled, as indicated by the driver&#39;s cfg_sriov_nr_virtfn, the</span>
<span class="cm"> * disabling virtual function api shall be invoded to disable all the</span>
<span class="cm"> * virtual functions and driver&#39;s cfg_sriov_nr_virtfn shall be set to</span>
<span class="cm"> * zero. Otherwise, if zero virtual function has been enabled, do</span>
<span class="cm"> * nothing.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns:</span>
<span class="cm"> * length of the buf on success if val is in range the intended mode</span>
<span class="cm"> * is supported.</span>
<span class="cm"> * -EINVAL if val out of range or intended mode is not supported.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">ssize_t</span>
<span class="nf">lpfc_sriov_nr_virtfn_store</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span>
			 <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span> <span class="o">=</span> <span class="n">class_to_shost</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="n">vport</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="p">)</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">hostdata</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span> <span class="o">=</span> <span class="n">vport</span><span class="o">-&gt;</span><span class="n">phba</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span> <span class="o">=</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">pcidev</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">val</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="cm">/* Sanity check on user data */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">isdigit</span><span class="p">(</span><span class="n">buf</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sscanf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;%i&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">val</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">val</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="cm">/* Request disabling virtual functions */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">val</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">cfg_sriov_nr_virtfn</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pci_disable_sriov</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
			<span class="n">phba</span><span class="o">-&gt;</span><span class="n">cfg_sriov_nr_virtfn</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">return</span> <span class="n">strlen</span><span class="p">(</span><span class="n">buf</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Request enabling virtual functions */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">cfg_sriov_nr_virtfn</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_INIT</span><span class="p">,</span>
				<span class="s">&quot;3018 There are %d virtual functions &quot;</span>
				<span class="s">&quot;enabled on physical function.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">phba</span><span class="o">-&gt;</span><span class="n">cfg_sriov_nr_virtfn</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EEXIST</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">val</span> <span class="o">&lt;=</span> <span class="n">LPFC_MAX_VFN_PER_PFN</span><span class="p">)</span>
		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">cfg_sriov_nr_virtfn</span> <span class="o">=</span> <span class="n">val</span><span class="p">;</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_INIT</span><span class="p">,</span>
				<span class="s">&quot;3019 Enabling %d virtual functions is not &quot;</span>
				<span class="s">&quot;allowed.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">lpfc_sli_probe_sriov_nr_virtfn</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">cfg_sriov_nr_virtfn</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">cfg_sriov_nr_virtfn</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">buf</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">lpfc_sriov_nr_virtfn</span> <span class="o">=</span> <span class="n">LPFC_DEF_VFN_PER_PFN</span><span class="p">;</span>
<span class="n">module_param</span><span class="p">(</span><span class="n">lpfc_sriov_nr_virtfn</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="n">S_IRUGO</span><span class="o">|</span><span class="n">S_IWUSR</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">lpfc_sriov_nr_virtfn</span><span class="p">,</span> <span class="s">&quot;Enable PCIe device SR-IOV virtual fn&quot;</span><span class="p">);</span>
<span class="n">lpfc_param_show</span><span class="p">(</span><span class="n">sriov_nr_virtfn</span><span class="p">)</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_sriov_nr_virtfn_init - Set the initial sr-iov virtual function enable</span>
<span class="cm"> * @phba: lpfc_hba pointer.</span>
<span class="cm"> * @val: link speed value.</span>
<span class="cm"> *</span>
<span class="cm"> * Description:</span>
<span class="cm"> * If val is in a valid range [0,255], then set the adapter&#39;s initial</span>
<span class="cm"> * cfg_sriov_nr_virtfn field. If it&#39;s greater than the maximum, the maximum</span>
<span class="cm"> * number shall be used instead. It will be up to the driver&#39;s probe_one</span>
<span class="cm"> * routine to determine whether the device&#39;s SR-IOV is supported or not.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns:</span>
<span class="cm"> * zero if val saved.</span>
<span class="cm"> * -EINVAL val out of range</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="n">lpfc_sriov_nr_virtfn_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">,</span> <span class="kt">int</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">val</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">val</span> <span class="o">&lt;=</span> <span class="n">LPFC_MAX_VFN_PER_PFN</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">cfg_sriov_nr_virtfn</span> <span class="o">=</span> <span class="n">val</span><span class="p">;</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">lpfc_printf_log</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">LOG_INIT</span><span class="p">,</span>
			<span class="s">&quot;3017 Enabling %d virtual functions is not &quot;</span>
			<span class="s">&quot;allowed.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">static</span> <span class="n">DEVICE_ATTR</span><span class="p">(</span><span class="n">lpfc_sriov_nr_virtfn</span><span class="p">,</span> <span class="n">S_IRUGO</span> <span class="o">|</span> <span class="n">S_IWUSR</span><span class="p">,</span>
		   <span class="n">lpfc_sriov_nr_virtfn_show</span><span class="p">,</span> <span class="n">lpfc_sriov_nr_virtfn_store</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"># lpfc_fcp_class:  Determines FC class to use for the FCP protocol.</span>
<span class="cm"># Value range is [2,3]. Default value is 3.</span>
<span class="cm">*/</span>
<span class="n">LPFC_VPORT_ATTR_R</span><span class="p">(</span><span class="n">fcp_class</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span>
		  <span class="s">&quot;Select Fibre Channel class of service for FCP sequences&quot;</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"># lpfc_use_adisc: Use ADISC for FCP rediscovery instead of PLOGI. Value range</span>
<span class="cm"># is [0,1]. Default value is 0.</span>
<span class="cm">*/</span>
<span class="n">LPFC_VPORT_ATTR_RW</span><span class="p">(</span><span class="n">use_adisc</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span>
		   <span class="s">&quot;Use ADISC on rediscovery to authenticate FCP devices&quot;</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"># lpfc_max_scsicmpl_time: Use scsi command completion time to control I/O queue</span>
<span class="cm"># depth. Default value is 0. When the value of this parameter is zero the</span>
<span class="cm"># SCSI command completion time is not used for controlling I/O queue depth. When</span>
<span class="cm"># the parameter is set to a non-zero value, the I/O queue depth is controlled</span>
<span class="cm"># to limit the I/O completion time to the parameter value.</span>
<span class="cm"># The value is set in milliseconds.</span>
<span class="cm">*/</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">lpfc_max_scsicmpl_time</span><span class="p">;</span>
<span class="n">module_param</span><span class="p">(</span><span class="n">lpfc_max_scsicmpl_time</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="n">S_IRUGO</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">lpfc_max_scsicmpl_time</span><span class="p">,</span>
	<span class="s">&quot;Use command completion time to control queue depth&quot;</span><span class="p">);</span>
<span class="n">lpfc_vport_param_show</span><span class="p">(</span><span class="n">max_scsicmpl_time</span><span class="p">);</span>
<span class="n">lpfc_vport_param_init</span><span class="p">(</span><span class="n">max_scsicmpl_time</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">60000</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">lpfc_max_scsicmpl_time_set</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="n">vport</span><span class="p">,</span> <span class="kt">int</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span> <span class="o">=</span> <span class="n">lpfc_shost_from_vport</span><span class="p">(</span><span class="n">vport</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">lpfc_nodelist</span> <span class="o">*</span><span class="n">ndlp</span><span class="p">,</span> <span class="o">*</span><span class="n">next_ndlp</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">val</span> <span class="o">==</span> <span class="n">vport</span><span class="o">-&gt;</span><span class="n">cfg_max_scsicmpl_time</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">val</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">val</span> <span class="o">&gt;</span> <span class="mi">60000</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="n">vport</span><span class="o">-&gt;</span><span class="n">cfg_max_scsicmpl_time</span> <span class="o">=</span> <span class="n">val</span><span class="p">;</span>

	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>
	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">ndlp</span><span class="p">,</span> <span class="n">next_ndlp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_nodes</span><span class="p">,</span> <span class="n">nlp_listp</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">NLP_CHK_NODE_ACT</span><span class="p">(</span><span class="n">ndlp</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_state</span> <span class="o">==</span> <span class="n">NLP_STE_UNUSED_NODE</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">cmd_qdepth</span> <span class="o">=</span> <span class="n">vport</span><span class="o">-&gt;</span><span class="n">cfg_tgt_queue_depth</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">lpfc_vport_param_store</span><span class="p">(</span><span class="n">max_scsicmpl_time</span><span class="p">);</span>
<span class="k">static</span> <span class="n">DEVICE_ATTR</span><span class="p">(</span><span class="n">lpfc_max_scsicmpl_time</span><span class="p">,</span> <span class="n">S_IRUGO</span> <span class="o">|</span> <span class="n">S_IWUSR</span><span class="p">,</span>
		   <span class="n">lpfc_max_scsicmpl_time_show</span><span class="p">,</span>
		   <span class="n">lpfc_max_scsicmpl_time_store</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"># lpfc_ack0: Use ACK0, instead of ACK1 for class 2 acknowledgement. Value</span>
<span class="cm"># range is [0,1]. Default value is 0.</span>
<span class="cm">*/</span>
<span class="n">LPFC_ATTR_R</span><span class="p">(</span><span class="n">ack0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="s">&quot;Enable ACK0 support&quot;</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"># lpfc_cr_delay &amp; lpfc_cr_count: Default values for I/O colaesing</span>
<span class="cm"># cr_delay (msec) or cr_count outstanding commands. cr_delay can take</span>
<span class="cm"># value [0,63]. cr_count can take value [1,255]. Default value of cr_delay</span>
<span class="cm"># is 0. Default value of cr_count is 1. The cr_count feature is disabled if</span>
<span class="cm"># cr_delay is set to 0.</span>
<span class="cm">*/</span>
<span class="n">LPFC_ATTR_RW</span><span class="p">(</span><span class="n">cr_delay</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">63</span><span class="p">,</span> <span class="s">&quot;A count of milliseconds after which an &quot;</span>
		<span class="s">&quot;interrupt response is generated&quot;</span><span class="p">);</span>

<span class="n">LPFC_ATTR_RW</span><span class="p">(</span><span class="n">cr_count</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">255</span><span class="p">,</span> <span class="s">&quot;A count of I/O completions after which an &quot;</span>
		<span class="s">&quot;interrupt response is generated&quot;</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"># lpfc_multi_ring_support:  Determines how many rings to spread available</span>
<span class="cm"># cmd/rsp IOCB entries across.</span>
<span class="cm"># Value range is [1,2]. Default value is 1.</span>
<span class="cm">*/</span>
<span class="n">LPFC_ATTR_R</span><span class="p">(</span><span class="n">multi_ring_support</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="s">&quot;Determines number of primary &quot;</span>
		<span class="s">&quot;SLI rings to spread IOCB entries across&quot;</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"># lpfc_multi_ring_rctl:  If lpfc_multi_ring_support is enabled, this</span>
<span class="cm"># identifies what rctl value to configure the additional ring for.</span>
<span class="cm"># Value range is [1,0xff]. Default value is 4 (Unsolicated Data).</span>
<span class="cm">*/</span>
<span class="n">LPFC_ATTR_R</span><span class="p">(</span><span class="n">multi_ring_rctl</span><span class="p">,</span> <span class="n">FC_RCTL_DD_UNSOL_DATA</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span>
	     <span class="mi">255</span><span class="p">,</span> <span class="s">&quot;Identifies RCTL for additional ring configuration&quot;</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"># lpfc_multi_ring_type:  If lpfc_multi_ring_support is enabled, this</span>
<span class="cm"># identifies what type value to configure the additional ring for.</span>
<span class="cm"># Value range is [1,0xff]. Default value is 5 (LLC/SNAP).</span>
<span class="cm">*/</span>
<span class="n">LPFC_ATTR_R</span><span class="p">(</span><span class="n">multi_ring_type</span><span class="p">,</span> <span class="n">FC_TYPE_IP</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span>
	     <span class="mi">255</span><span class="p">,</span> <span class="s">&quot;Identifies TYPE for additional ring configuration&quot;</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"># lpfc_fdmi_on: controls FDMI support.</span>
<span class="cm">#       0 = no FDMI support</span>
<span class="cm">#       1 = support FDMI without attribute of hostname</span>
<span class="cm">#       2 = support FDMI with attribute of hostname</span>
<span class="cm"># Value range [0,2]. Default value is 0.</span>
<span class="cm">*/</span>
<span class="n">LPFC_VPORT_ATTR_RW</span><span class="p">(</span><span class="n">fdmi_on</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="s">&quot;Enable FDMI support&quot;</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"># Specifies the maximum number of ELS cmds we can have outstanding (for</span>
<span class="cm"># discovery). Value range is [1,64]. Default value = 32.</span>
<span class="cm">*/</span>
<span class="n">LPFC_VPORT_ATTR</span><span class="p">(</span><span class="n">discovery_threads</span><span class="p">,</span> <span class="mi">32</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">64</span><span class="p">,</span> <span class="s">&quot;Maximum number of ELS commands &quot;</span>
		 <span class="s">&quot;during discovery&quot;</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"># lpfc_max_luns: maximum allowed LUN.</span>
<span class="cm"># Value range is [0,65535]. Default value is 255.</span>
<span class="cm"># NOTE: The SCSI layer might probe all allowed LUN on some old targets.</span>
<span class="cm">*/</span>
<span class="n">LPFC_VPORT_ATTR_R</span><span class="p">(</span><span class="n">max_luns</span><span class="p">,</span> <span class="mi">255</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">65535</span><span class="p">,</span> <span class="s">&quot;Maximum allowed LUN&quot;</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"># lpfc_poll_tmo: .Milliseconds driver will wait between polling FCP ring.</span>
<span class="cm"># Value range is [1,255], default value is 10.</span>
<span class="cm">*/</span>
<span class="n">LPFC_ATTR_RW</span><span class="p">(</span><span class="n">poll_tmo</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">255</span><span class="p">,</span>
	     <span class="s">&quot;Milliseconds driver will wait between polling FCP ring&quot;</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"># lpfc_use_msi: Use MSI (Message Signaled Interrupts) in systems that</span>
<span class="cm">#		support this feature</span>
<span class="cm">#       0  = MSI disabled</span>
<span class="cm">#       1  = MSI enabled</span>
<span class="cm">#       2  = MSI-X enabled (default)</span>
<span class="cm"># Value range is [0,2]. Default value is 2.</span>
<span class="cm">*/</span>
<span class="n">LPFC_ATTR_R</span><span class="p">(</span><span class="n">use_msi</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="s">&quot;Use Message Signaled Interrupts (1) or &quot;</span>
	    <span class="s">&quot;MSI-X (2), if possible&quot;</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"># lpfc_fcp_imax: Set the maximum number of fast-path FCP interrupts per second</span>
<span class="cm">#</span>
<span class="cm"># Value range is [636,651042]. Default value is 10000.</span>
<span class="cm">*/</span>
<span class="n">LPFC_ATTR_R</span><span class="p">(</span><span class="n">fcp_imax</span><span class="p">,</span> <span class="n">LPFC_FP_DEF_IMAX</span><span class="p">,</span> <span class="n">LPFC_MIM_IMAX</span><span class="p">,</span> <span class="n">LPFC_DMULT_CONST</span><span class="p">,</span>
	    <span class="s">&quot;Set the maximum number of fast-path FCP interrupts per second&quot;</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"># lpfc_fcp_wq_count: Set the number of fast-path FCP work queues</span>
<span class="cm">#</span>
<span class="cm"># Value range is [1,31]. Default value is 4.</span>
<span class="cm">*/</span>
<span class="n">LPFC_ATTR_R</span><span class="p">(</span><span class="n">fcp_wq_count</span><span class="p">,</span> <span class="n">LPFC_FP_WQN_DEF</span><span class="p">,</span> <span class="n">LPFC_FP_WQN_MIN</span><span class="p">,</span> <span class="n">LPFC_FP_WQN_MAX</span><span class="p">,</span>
	    <span class="s">&quot;Set the number of fast-path FCP work queues, if possible&quot;</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"># lpfc_fcp_eq_count: Set the number of fast-path FCP event queues</span>
<span class="cm">#</span>
<span class="cm"># Value range is [1,7]. Default value is 1.</span>
<span class="cm">*/</span>
<span class="n">LPFC_ATTR_R</span><span class="p">(</span><span class="n">fcp_eq_count</span><span class="p">,</span> <span class="n">LPFC_FP_EQN_DEF</span><span class="p">,</span> <span class="n">LPFC_FP_EQN_MIN</span><span class="p">,</span> <span class="n">LPFC_FP_EQN_MAX</span><span class="p">,</span>
	    <span class="s">&quot;Set the number of fast-path FCP event queues, if possible&quot;</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"># lpfc_enable_hba_reset: Allow or prevent HBA resets to the hardware.</span>
<span class="cm">#       0  = HBA resets disabled</span>
<span class="cm">#       1  = HBA resets enabled (default)</span>
<span class="cm"># Value range is [0,1]. Default value is 1.</span>
<span class="cm">*/</span>
<span class="n">LPFC_ATTR_R</span><span class="p">(</span><span class="n">enable_hba_reset</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="s">&quot;Enable HBA resets from the driver.&quot;</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"># lpfc_enable_hba_heartbeat: Disable HBA heartbeat timer..</span>
<span class="cm">#       0  = HBA Heartbeat disabled</span>
<span class="cm">#       1  = HBA Heartbeat enabled (default)</span>
<span class="cm"># Value range is [0,1]. Default value is 1.</span>
<span class="cm">*/</span>
<span class="n">LPFC_ATTR_R</span><span class="p">(</span><span class="n">enable_hba_heartbeat</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="s">&quot;Enable HBA Heartbeat.&quot;</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"># lpfc_enable_bg: Enable BlockGuard (Emulex&#39;s Implementation of T10-DIF)</span>
<span class="cm">#       0  = BlockGuard disabled (default)</span>
<span class="cm">#       1  = BlockGuard enabled</span>
<span class="cm"># Value range is [0,1]. Default value is 0.</span>
<span class="cm">*/</span>
<span class="n">LPFC_ATTR_R</span><span class="p">(</span><span class="n">enable_bg</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="s">&quot;Enable BlockGuard Support&quot;</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"># lpfc_prot_mask: i</span>
<span class="cm">#	- Bit mask of host protection capabilities used to register with the</span>
<span class="cm">#	  SCSI mid-layer</span>
<span class="cm"># 	- Only meaningful if BG is turned on (lpfc_enable_bg=1).</span>
<span class="cm">#	- Allows you to ultimately specify which profiles to use</span>
<span class="cm">#	- Default will result in registering capabilities for all profiles.</span>
<span class="cm">#</span>
<span class="cm">*/</span>
<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">lpfc_prot_mask</span> <span class="o">=</span> <span class="n">SHOST_DIF_TYPE1_PROTECTION</span> <span class="o">|</span>
			      <span class="n">SHOST_DIX_TYPE0_PROTECTION</span> <span class="o">|</span>
			      <span class="n">SHOST_DIX_TYPE1_PROTECTION</span><span class="p">;</span>

<span class="n">module_param</span><span class="p">(</span><span class="n">lpfc_prot_mask</span><span class="p">,</span> <span class="n">uint</span><span class="p">,</span> <span class="n">S_IRUGO</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">lpfc_prot_mask</span><span class="p">,</span> <span class="s">&quot;host protection mask&quot;</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"># lpfc_prot_guard: i</span>
<span class="cm">#	- Bit mask of protection guard types to register with the SCSI mid-layer</span>
<span class="cm"># 	- Guard types are currently either 1) IP checksum 2) T10-DIF CRC</span>
<span class="cm">#	- Allows you to ultimately specify which profiles to use</span>
<span class="cm">#	- Default will result in registering capabilities for all guard types</span>
<span class="cm">#</span>
<span class="cm">*/</span>
<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">lpfc_prot_guard</span> <span class="o">=</span> <span class="n">SHOST_DIX_GUARD_IP</span><span class="p">;</span>
<span class="n">module_param</span><span class="p">(</span><span class="n">lpfc_prot_guard</span><span class="p">,</span> <span class="n">byte</span><span class="p">,</span> <span class="n">S_IRUGO</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">lpfc_prot_guard</span><span class="p">,</span> <span class="s">&quot;host protection guard type&quot;</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Delay initial NPort discovery when Clean Address bit is cleared in</span>
<span class="cm"> * FLOGI/FDISC accept and FCID/Fabric name/Fabric portname is changed.</span>
<span class="cm"> * This parameter can have value 0 or 1.</span>
<span class="cm"> * When this parameter is set to 0, no delay is added to the initial</span>
<span class="cm"> * discovery.</span>
<span class="cm"> * When this parameter is set to non-zero value, initial Nport discovery is</span>
<span class="cm"> * delayed by ra_tov seconds when Clean Address bit is cleared in FLOGI/FDISC</span>
<span class="cm"> * accept and FCID/Fabric name/Fabric portname is changed.</span>
<span class="cm"> * Driver always delay Nport discovery for subsequent FLOGI/FDISC completion</span>
<span class="cm"> * when Clean Address bit is cleared in FLOGI/FDISC</span>
<span class="cm"> * accept and FCID/Fabric name/Fabric portname is changed.</span>
<span class="cm"> * Default value is 0.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">lpfc_delay_discovery</span><span class="p">;</span>
<span class="n">module_param</span><span class="p">(</span><span class="n">lpfc_delay_discovery</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="n">S_IRUGO</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">lpfc_delay_discovery</span><span class="p">,</span>
	<span class="s">&quot;Delay NPort discovery when Clean Address bit is cleared. &quot;</span>
	<span class="s">&quot;Allowed values: 0,1.&quot;</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * lpfc_sg_seg_cnt - Initial Maximum DMA Segment Count</span>
<span class="cm"> * This value can be set to values between 64 and 256. The default value is</span>
<span class="cm"> * 64, but may be increased to allow for larger Max I/O sizes. The scsi layer</span>
<span class="cm"> * will be allowed to request I/Os of sizes up to (MAX_SEG_COUNT * SEG_SIZE).</span>
<span class="cm"> */</span>
<span class="n">LPFC_ATTR_R</span><span class="p">(</span><span class="n">sg_seg_cnt</span><span class="p">,</span> <span class="n">LPFC_DEFAULT_SG_SEG_CNT</span><span class="p">,</span> <span class="n">LPFC_DEFAULT_SG_SEG_CNT</span><span class="p">,</span>
	    <span class="n">LPFC_MAX_SG_SEG_CNT</span><span class="p">,</span> <span class="s">&quot;Max Scatter Gather Segment Count&quot;</span><span class="p">);</span>

<span class="n">LPFC_ATTR_R</span><span class="p">(</span><span class="n">prot_sg_seg_cnt</span><span class="p">,</span> <span class="n">LPFC_DEFAULT_PROT_SG_SEG_CNT</span><span class="p">,</span>
		<span class="n">LPFC_DEFAULT_PROT_SG_SEG_CNT</span><span class="p">,</span> <span class="n">LPFC_MAX_PROT_SG_SEG_CNT</span><span class="p">,</span>
		<span class="s">&quot;Max Protection Scatter Gather Segment Count&quot;</span><span class="p">);</span>

<span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="n">lpfc_hba_attrs</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="o">&amp;</span><span class="n">dev_attr_bg_info</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">dev_attr_bg_guard_err</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">dev_attr_bg_apptag_err</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">dev_attr_bg_reftag_err</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">dev_attr_info</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">dev_attr_serialnum</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">dev_attr_modeldesc</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">dev_attr_modelname</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">dev_attr_programtype</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">dev_attr_portnum</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">dev_attr_fwrev</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">dev_attr_hdw</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">dev_attr_option_rom_version</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">dev_attr_link_state</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">dev_attr_num_discovered_ports</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">dev_attr_menlo_mgmt_mode</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">dev_attr_lpfc_drvr_version</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">dev_attr_lpfc_enable_fip</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">dev_attr_lpfc_temp_sensor</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">dev_attr_lpfc_log_verbose</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">dev_attr_lpfc_lun_queue_depth</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">dev_attr_lpfc_tgt_queue_depth</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">dev_attr_lpfc_hba_queue_depth</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">dev_attr_lpfc_peer_port_login</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">dev_attr_lpfc_nodev_tmo</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">dev_attr_lpfc_devloss_tmo</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">dev_attr_lpfc_fcp_class</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">dev_attr_lpfc_use_adisc</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">dev_attr_lpfc_ack0</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">dev_attr_lpfc_topology</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">dev_attr_lpfc_scan_down</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">dev_attr_lpfc_link_speed</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">dev_attr_lpfc_cr_delay</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">dev_attr_lpfc_cr_count</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">dev_attr_lpfc_multi_ring_support</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">dev_attr_lpfc_multi_ring_rctl</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">dev_attr_lpfc_multi_ring_type</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">dev_attr_lpfc_fdmi_on</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">dev_attr_lpfc_max_luns</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">dev_attr_lpfc_enable_npiv</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">dev_attr_lpfc_fcf_failover_policy</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">dev_attr_lpfc_enable_rrq</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">dev_attr_nport_evt_cnt</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">dev_attr_board_mode</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">dev_attr_max_vpi</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">dev_attr_used_vpi</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">dev_attr_max_rpi</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">dev_attr_used_rpi</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">dev_attr_max_xri</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">dev_attr_used_xri</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">dev_attr_npiv_info</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">dev_attr_issue_reset</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">dev_attr_lpfc_poll</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">dev_attr_lpfc_poll_tmo</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">dev_attr_lpfc_use_msi</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">dev_attr_lpfc_fcp_imax</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">dev_attr_lpfc_fcp_wq_count</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">dev_attr_lpfc_fcp_eq_count</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">dev_attr_lpfc_enable_bg</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">dev_attr_lpfc_soft_wwnn</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">dev_attr_lpfc_soft_wwpn</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">dev_attr_lpfc_soft_wwn_enable</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">dev_attr_lpfc_enable_hba_reset</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">dev_attr_lpfc_enable_hba_heartbeat</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">dev_attr_lpfc_sg_seg_cnt</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">dev_attr_lpfc_max_scsicmpl_time</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">dev_attr_lpfc_stat_data_ctrl</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">dev_attr_lpfc_prot_sg_seg_cnt</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">dev_attr_lpfc_aer_support</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">dev_attr_lpfc_aer_state_cleanup</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">dev_attr_lpfc_sriov_nr_virtfn</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">dev_attr_lpfc_suppress_link_up</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">dev_attr_lpfc_iocb_cnt</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">dev_attr_iocb_hw</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">dev_attr_txq_hw</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">dev_attr_txcmplq_hw</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">dev_attr_lpfc_fips_level</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">dev_attr_lpfc_fips_rev</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">dev_attr_lpfc_dss</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">dev_attr_lpfc_sriov_hw_max_virtfn</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">dev_attr_protocol</span><span class="p">,</span>
	<span class="nb">NULL</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="n">lpfc_vport_attrs</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="o">&amp;</span><span class="n">dev_attr_info</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">dev_attr_link_state</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">dev_attr_num_discovered_ports</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">dev_attr_lpfc_drvr_version</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">dev_attr_lpfc_log_verbose</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">dev_attr_lpfc_lun_queue_depth</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">dev_attr_lpfc_tgt_queue_depth</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">dev_attr_lpfc_nodev_tmo</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">dev_attr_lpfc_devloss_tmo</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">dev_attr_lpfc_hba_queue_depth</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">dev_attr_lpfc_peer_port_login</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">dev_attr_lpfc_restrict_login</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">dev_attr_lpfc_fcp_class</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">dev_attr_lpfc_use_adisc</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">dev_attr_lpfc_fdmi_on</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">dev_attr_lpfc_max_luns</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">dev_attr_nport_evt_cnt</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">dev_attr_npiv_info</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">dev_attr_lpfc_enable_da_id</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">dev_attr_lpfc_max_scsicmpl_time</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">dev_attr_lpfc_stat_data_ctrl</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">dev_attr_lpfc_static_vport</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">dev_attr_lpfc_fips_level</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">dev_attr_lpfc_fips_rev</span><span class="p">,</span>
	<span class="nb">NULL</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * sysfs_ctlreg_write - Write method for writing to ctlreg</span>
<span class="cm"> * @filp: open sysfs file</span>
<span class="cm"> * @kobj: kernel kobject that contains the kernel class device.</span>
<span class="cm"> * @bin_attr: kernel attributes passed to us.</span>
<span class="cm"> * @buf: contains the data to be written to the adapter IOREG space.</span>
<span class="cm"> * @off: offset into buffer to beginning of data.</span>
<span class="cm"> * @count: bytes to transfer.</span>
<span class="cm"> *</span>
<span class="cm"> * Description:</span>
<span class="cm"> * Accessed via /sys/class/scsi_host/hostxxx/ctlreg.</span>
<span class="cm"> * Uses the adapter io control registers to send buf contents to the adapter.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns:</span>
<span class="cm"> * -ERANGE off and count combo out of range</span>
<span class="cm"> * -EINVAL off, count or buff address invalid</span>
<span class="cm"> * -EPERM adapter is offline</span>
<span class="cm"> * value of count, buf contents written</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">ssize_t</span>
<span class="nf">sysfs_ctlreg_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kobject</span> <span class="o">*</span><span class="n">kobj</span><span class="p">,</span>
		   <span class="k">struct</span> <span class="n">bin_attribute</span> <span class="o">*</span><span class="n">bin_attr</span><span class="p">,</span>
		   <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">off</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">size_t</span> <span class="n">buf_off</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">kobj</span><span class="p">,</span> <span class="k">struct</span> <span class="n">device</span><span class="p">,</span> <span class="n">kobj</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span>  <span class="o">*</span><span class="n">shost</span> <span class="o">=</span> <span class="n">class_to_shost</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="n">vport</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="p">)</span> <span class="n">shost</span><span class="o">-&gt;</span><span class="n">hostdata</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_hba</span>   <span class="o">*</span><span class="n">phba</span> <span class="o">=</span> <span class="n">vport</span><span class="o">-&gt;</span><span class="n">phba</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli_rev</span> <span class="o">&gt;=</span> <span class="n">LPFC_SLI_REV4</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">off</span> <span class="o">+</span> <span class="n">count</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">FF_REG_AREA_SIZE</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ERANGE</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">&lt;=</span> <span class="n">LPFC_REG_WRITE_KEY_SIZE</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">off</span> <span class="o">%</span> <span class="mi">4</span> <span class="o">||</span> <span class="n">count</span> <span class="o">%</span> <span class="mi">4</span> <span class="o">||</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">buf</span> <span class="o">%</span> <span class="mi">4</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="cm">/* This is to protect HBA registers from accidental writes. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">memcmp</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">LPFC_REG_WRITE_KEY</span><span class="p">,</span> <span class="n">LPFC_REG_WRITE_KEY_SIZE</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_flag</span> <span class="o">&amp;</span> <span class="n">FC_OFFLINE_MODE</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>

	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">buf_off</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">buf_off</span> <span class="o">&lt;</span> <span class="n">count</span> <span class="o">-</span> <span class="n">LPFC_REG_WRITE_KEY_SIZE</span><span class="p">;</span>
			<span class="n">buf_off</span> <span class="o">+=</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">uint32_t</span><span class="p">))</span>
		<span class="n">writel</span><span class="p">(</span><span class="o">*</span><span class="p">((</span><span class="kt">uint32_t</span> <span class="o">*</span><span class="p">)(</span><span class="n">buf</span> <span class="o">+</span> <span class="n">buf_off</span> <span class="o">+</span> <span class="n">LPFC_REG_WRITE_KEY_SIZE</span><span class="p">)),</span>
		       <span class="n">phba</span><span class="o">-&gt;</span><span class="n">ctrl_regs_memmap_p</span> <span class="o">+</span> <span class="n">off</span> <span class="o">+</span> <span class="n">buf_off</span><span class="p">);</span>

	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">count</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * sysfs_ctlreg_read - Read method for reading from ctlreg</span>
<span class="cm"> * @filp: open sysfs file</span>
<span class="cm"> * @kobj: kernel kobject that contains the kernel class device.</span>
<span class="cm"> * @bin_attr: kernel attributes passed to us.</span>
<span class="cm"> * @buf: if successful contains the data from the adapter IOREG space.</span>
<span class="cm"> * @off: offset into buffer to beginning of data.</span>
<span class="cm"> * @count: bytes to transfer.</span>
<span class="cm"> *</span>
<span class="cm"> * Description:</span>
<span class="cm"> * Accessed via /sys/class/scsi_host/hostxxx/ctlreg.</span>
<span class="cm"> * Uses the adapter io control registers to read data into buf.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns:</span>
<span class="cm"> * -ERANGE off and count combo out of range</span>
<span class="cm"> * -EINVAL off, count or buff address invalid</span>
<span class="cm"> * value of count, buf contents read</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">ssize_t</span>
<span class="nf">sysfs_ctlreg_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kobject</span> <span class="o">*</span><span class="n">kobj</span><span class="p">,</span>
		  <span class="k">struct</span> <span class="n">bin_attribute</span> <span class="o">*</span><span class="n">bin_attr</span><span class="p">,</span>
		  <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">off</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">size_t</span> <span class="n">buf_off</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="o">*</span> <span class="n">tmp_ptr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">kobj</span><span class="p">,</span> <span class="k">struct</span> <span class="n">device</span><span class="p">,</span> <span class="n">kobj</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span>  <span class="o">*</span><span class="n">shost</span> <span class="o">=</span> <span class="n">class_to_shost</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="n">vport</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="p">)</span> <span class="n">shost</span><span class="o">-&gt;</span><span class="n">hostdata</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_hba</span>   <span class="o">*</span><span class="n">phba</span> <span class="o">=</span> <span class="n">vport</span><span class="o">-&gt;</span><span class="n">phba</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli_rev</span> <span class="o">&gt;=</span> <span class="n">LPFC_SLI_REV4</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">off</span> <span class="o">&gt;</span> <span class="n">FF_REG_AREA_SIZE</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ERANGE</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">off</span> <span class="o">+</span> <span class="n">count</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">FF_REG_AREA_SIZE</span><span class="p">)</span>
		<span class="n">count</span> <span class="o">=</span> <span class="n">FF_REG_AREA_SIZE</span> <span class="o">-</span> <span class="n">off</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">off</span> <span class="o">%</span> <span class="mi">4</span> <span class="o">||</span> <span class="n">count</span> <span class="o">%</span> <span class="mi">4</span> <span class="o">||</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">buf</span> <span class="o">%</span> <span class="mi">4</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">buf_off</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">buf_off</span> <span class="o">&lt;</span> <span class="n">count</span><span class="p">;</span> <span class="n">buf_off</span> <span class="o">+=</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">uint32_t</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">tmp_ptr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint32_t</span> <span class="o">*</span><span class="p">)(</span><span class="n">buf</span> <span class="o">+</span> <span class="n">buf_off</span><span class="p">);</span>
		<span class="o">*</span><span class="n">tmp_ptr</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">ctrl_regs_memmap_p</span> <span class="o">+</span> <span class="n">off</span> <span class="o">+</span> <span class="n">buf_off</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hbalock</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">count</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">bin_attribute</span> <span class="n">sysfs_ctlreg_attr</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">attr</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;ctlreg&quot;</span><span class="p">,</span>
		<span class="p">.</span><span class="n">mode</span> <span class="o">=</span> <span class="n">S_IRUSR</span> <span class="o">|</span> <span class="n">S_IWUSR</span><span class="p">,</span>
	<span class="p">},</span>
	<span class="p">.</span><span class="n">size</span> <span class="o">=</span> <span class="mi">256</span><span class="p">,</span>
	<span class="p">.</span><span class="n">read</span> <span class="o">=</span> <span class="n">sysfs_ctlreg_read</span><span class="p">,</span>
	<span class="p">.</span><span class="n">write</span> <span class="o">=</span> <span class="n">sysfs_ctlreg_write</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * sysfs_mbox_write - Write method for writing information via mbox</span>
<span class="cm"> * @filp: open sysfs file</span>
<span class="cm"> * @kobj: kernel kobject that contains the kernel class device.</span>
<span class="cm"> * @bin_attr: kernel attributes passed to us.</span>
<span class="cm"> * @buf: contains the data to be written to sysfs mbox.</span>
<span class="cm"> * @off: offset into buffer to beginning of data.</span>
<span class="cm"> * @count: bytes to transfer.</span>
<span class="cm"> *</span>
<span class="cm"> * Description:</span>
<span class="cm"> * Deprecated function. All mailbox access from user space is performed via the</span>
<span class="cm"> * bsg interface.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns:</span>
<span class="cm"> * -EPERM operation not permitted</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">ssize_t</span>
<span class="nf">sysfs_mbox_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kobject</span> <span class="o">*</span><span class="n">kobj</span><span class="p">,</span>
		 <span class="k">struct</span> <span class="n">bin_attribute</span> <span class="o">*</span><span class="n">bin_attr</span><span class="p">,</span>
		 <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">off</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * sysfs_mbox_read - Read method for reading information via mbox</span>
<span class="cm"> * @filp: open sysfs file</span>
<span class="cm"> * @kobj: kernel kobject that contains the kernel class device.</span>
<span class="cm"> * @bin_attr: kernel attributes passed to us.</span>
<span class="cm"> * @buf: contains the data to be read from sysfs mbox.</span>
<span class="cm"> * @off: offset into buffer to beginning of data.</span>
<span class="cm"> * @count: bytes to transfer.</span>
<span class="cm"> *</span>
<span class="cm"> * Description:</span>
<span class="cm"> * Deprecated function. All mailbox access from user space is performed via the</span>
<span class="cm"> * bsg interface.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns:</span>
<span class="cm"> * -EPERM operation not permitted</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">ssize_t</span>
<span class="nf">sysfs_mbox_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kobject</span> <span class="o">*</span><span class="n">kobj</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">bin_attribute</span> <span class="o">*</span><span class="n">bin_attr</span><span class="p">,</span>
		<span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">off</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">bin_attribute</span> <span class="n">sysfs_mbox_attr</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">attr</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;mbox&quot;</span><span class="p">,</span>
		<span class="p">.</span><span class="n">mode</span> <span class="o">=</span> <span class="n">S_IRUSR</span> <span class="o">|</span> <span class="n">S_IWUSR</span><span class="p">,</span>
	<span class="p">},</span>
	<span class="p">.</span><span class="n">size</span> <span class="o">=</span> <span class="n">MAILBOX_SYSFS_MAX</span><span class="p">,</span>
	<span class="p">.</span><span class="n">read</span> <span class="o">=</span> <span class="n">sysfs_mbox_read</span><span class="p">,</span>
	<span class="p">.</span><span class="n">write</span> <span class="o">=</span> <span class="n">sysfs_mbox_write</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_alloc_sysfs_attr - Creates the ctlreg and mbox entries</span>
<span class="cm"> * @vport: address of lpfc vport structure.</span>
<span class="cm"> *</span>
<span class="cm"> * Return codes:</span>
<span class="cm"> * zero on success</span>
<span class="cm"> * error return code from sysfs_create_bin_file()</span>
<span class="cm"> **/</span>
<span class="kt">int</span>
<span class="nf">lpfc_alloc_sysfs_attr</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="n">vport</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span> <span class="o">=</span> <span class="n">lpfc_shost_from_vport</span><span class="p">(</span><span class="n">vport</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">sysfs_create_bin_file</span><span class="p">(</span><span class="o">&amp;</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">shost_dev</span><span class="p">.</span><span class="n">kobj</span><span class="p">,</span>
				      <span class="o">&amp;</span><span class="n">sysfs_drvr_stat_data_attr</span><span class="p">);</span>

	<span class="cm">/* Virtual ports do not need ctrl_reg and mbox */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span> <span class="o">||</span> <span class="n">vport</span><span class="o">-&gt;</span><span class="n">port_type</span> <span class="o">==</span> <span class="n">LPFC_NPIV_PORT</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">sysfs_create_bin_file</span><span class="p">(</span><span class="o">&amp;</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">shost_dev</span><span class="p">.</span><span class="n">kobj</span><span class="p">,</span>
				      <span class="o">&amp;</span><span class="n">sysfs_ctlreg_attr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_remove_stat_attr</span><span class="p">;</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">sysfs_create_bin_file</span><span class="p">(</span><span class="o">&amp;</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">shost_dev</span><span class="p">.</span><span class="n">kobj</span><span class="p">,</span>
				      <span class="o">&amp;</span><span class="n">sysfs_mbox_attr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_remove_ctlreg_attr</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">out_remove_ctlreg_attr:</span>
	<span class="n">sysfs_remove_bin_file</span><span class="p">(</span><span class="o">&amp;</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">shost_dev</span><span class="p">.</span><span class="n">kobj</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sysfs_ctlreg_attr</span><span class="p">);</span>
<span class="nl">out_remove_stat_attr:</span>
	<span class="n">sysfs_remove_bin_file</span><span class="p">(</span><span class="o">&amp;</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">shost_dev</span><span class="p">.</span><span class="n">kobj</span><span class="p">,</span>
			<span class="o">&amp;</span><span class="n">sysfs_drvr_stat_data_attr</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_free_sysfs_attr - Removes the ctlreg and mbox entries</span>
<span class="cm"> * @vport: address of lpfc vport structure.</span>
<span class="cm"> **/</span>
<span class="kt">void</span>
<span class="nf">lpfc_free_sysfs_attr</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="n">vport</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span> <span class="o">=</span> <span class="n">lpfc_shost_from_vport</span><span class="p">(</span><span class="n">vport</span><span class="p">);</span>
	<span class="n">sysfs_remove_bin_file</span><span class="p">(</span><span class="o">&amp;</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">shost_dev</span><span class="p">.</span><span class="n">kobj</span><span class="p">,</span>
		<span class="o">&amp;</span><span class="n">sysfs_drvr_stat_data_attr</span><span class="p">);</span>
	<span class="cm">/* Virtual ports do not need ctrl_reg and mbox */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">port_type</span> <span class="o">==</span> <span class="n">LPFC_NPIV_PORT</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">sysfs_remove_bin_file</span><span class="p">(</span><span class="o">&amp;</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">shost_dev</span><span class="p">.</span><span class="n">kobj</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sysfs_mbox_attr</span><span class="p">);</span>
	<span class="n">sysfs_remove_bin_file</span><span class="p">(</span><span class="o">&amp;</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">shost_dev</span><span class="p">.</span><span class="n">kobj</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sysfs_ctlreg_attr</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * Dynamic FC Host Attributes Support</span>
<span class="cm"> */</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_get_host_port_id - Copy the vport DID into the scsi host port id</span>
<span class="cm"> * @shost: kernel scsi host pointer.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">lpfc_get_host_port_id</span><span class="p">(</span><span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="n">vport</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="p">)</span> <span class="n">shost</span><span class="o">-&gt;</span><span class="n">hostdata</span><span class="p">;</span>

	<span class="cm">/* note: fc_myDID already in cpu endianness */</span>
	<span class="n">fc_host_port_id</span><span class="p">(</span><span class="n">shost</span><span class="p">)</span> <span class="o">=</span> <span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_myDID</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_get_host_port_type - Set the value of the scsi host port type</span>
<span class="cm"> * @shost: kernel scsi host pointer.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">lpfc_get_host_port_type</span><span class="p">(</span><span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="n">vport</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="p">)</span> <span class="n">shost</span><span class="o">-&gt;</span><span class="n">hostdata</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_hba</span>   <span class="o">*</span><span class="n">phba</span> <span class="o">=</span> <span class="n">vport</span><span class="o">-&gt;</span><span class="n">phba</span><span class="p">;</span>

	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">port_type</span> <span class="o">==</span> <span class="n">LPFC_NPIV_PORT</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">fc_host_port_type</span><span class="p">(</span><span class="n">shost</span><span class="p">)</span> <span class="o">=</span> <span class="n">FC_PORTTYPE_NPIV</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">lpfc_is_link_up</span><span class="p">(</span><span class="n">phba</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">fc_topology</span> <span class="o">==</span> <span class="n">LPFC_TOPOLOGY_LOOP</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_flag</span> <span class="o">&amp;</span> <span class="n">FC_PUBLIC_LOOP</span><span class="p">)</span>
				<span class="n">fc_host_port_type</span><span class="p">(</span><span class="n">shost</span><span class="p">)</span> <span class="o">=</span> <span class="n">FC_PORTTYPE_NLPORT</span><span class="p">;</span>
			<span class="k">else</span>
				<span class="n">fc_host_port_type</span><span class="p">(</span><span class="n">shost</span><span class="p">)</span> <span class="o">=</span> <span class="n">FC_PORTTYPE_LPORT</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_flag</span> <span class="o">&amp;</span> <span class="n">FC_FABRIC</span><span class="p">)</span>
				<span class="n">fc_host_port_type</span><span class="p">(</span><span class="n">shost</span><span class="p">)</span> <span class="o">=</span> <span class="n">FC_PORTTYPE_NPORT</span><span class="p">;</span>
			<span class="k">else</span>
				<span class="n">fc_host_port_type</span><span class="p">(</span><span class="n">shost</span><span class="p">)</span> <span class="o">=</span> <span class="n">FC_PORTTYPE_PTP</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">fc_host_port_type</span><span class="p">(</span><span class="n">shost</span><span class="p">)</span> <span class="o">=</span> <span class="n">FC_PORTTYPE_UNKNOWN</span><span class="p">;</span>

	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_get_host_port_state - Set the value of the scsi host port state</span>
<span class="cm"> * @shost: kernel scsi host pointer.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">lpfc_get_host_port_state</span><span class="p">(</span><span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="n">vport</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="p">)</span> <span class="n">shost</span><span class="o">-&gt;</span><span class="n">hostdata</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_hba</span>   <span class="o">*</span><span class="n">phba</span> <span class="o">=</span> <span class="n">vport</span><span class="o">-&gt;</span><span class="n">phba</span><span class="p">;</span>

	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_flag</span> <span class="o">&amp;</span> <span class="n">FC_OFFLINE_MODE</span><span class="p">)</span>
		<span class="n">fc_host_port_state</span><span class="p">(</span><span class="n">shost</span><span class="p">)</span> <span class="o">=</span> <span class="n">FC_PORTSTATE_OFFLINE</span><span class="p">;</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">link_state</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">LPFC_LINK_UNKNOWN</span>:
		<span class="k">case</span> <span class="n">LPFC_LINK_DOWN</span>:
			<span class="n">fc_host_port_state</span><span class="p">(</span><span class="n">shost</span><span class="p">)</span> <span class="o">=</span> <span class="n">FC_PORTSTATE_LINKDOWN</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">LPFC_LINK_UP</span>:
		<span class="k">case</span> <span class="n">LPFC_CLEAR_LA</span>:
		<span class="k">case</span> <span class="n">LPFC_HBA_READY</span>:
			<span class="cm">/* Links up, reports port state accordingly */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">port_state</span> <span class="o">&lt;</span> <span class="n">LPFC_VPORT_READY</span><span class="p">)</span>
				<span class="n">fc_host_port_state</span><span class="p">(</span><span class="n">shost</span><span class="p">)</span> <span class="o">=</span>
							<span class="n">FC_PORTSTATE_BYPASSED</span><span class="p">;</span>
			<span class="k">else</span>
				<span class="n">fc_host_port_state</span><span class="p">(</span><span class="n">shost</span><span class="p">)</span> <span class="o">=</span>
							<span class="n">FC_PORTSTATE_ONLINE</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">LPFC_HBA_ERROR</span>:
			<span class="n">fc_host_port_state</span><span class="p">(</span><span class="n">shost</span><span class="p">)</span> <span class="o">=</span> <span class="n">FC_PORTSTATE_ERROR</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="nl">default:</span>
			<span class="n">fc_host_port_state</span><span class="p">(</span><span class="n">shost</span><span class="p">)</span> <span class="o">=</span> <span class="n">FC_PORTSTATE_UNKNOWN</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_get_host_speed - Set the value of the scsi host speed</span>
<span class="cm"> * @shost: kernel scsi host pointer.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">lpfc_get_host_speed</span><span class="p">(</span><span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="n">vport</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="p">)</span> <span class="n">shost</span><span class="o">-&gt;</span><span class="n">hostdata</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_hba</span>   <span class="o">*</span><span class="n">phba</span> <span class="o">=</span> <span class="n">vport</span><span class="o">-&gt;</span><span class="n">phba</span><span class="p">;</span>

	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">lpfc_is_link_up</span><span class="p">(</span><span class="n">phba</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">switch</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">fc_linkspeed</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">LPFC_LINK_SPEED_1GHZ</span>:
			<span class="n">fc_host_speed</span><span class="p">(</span><span class="n">shost</span><span class="p">)</span> <span class="o">=</span> <span class="n">FC_PORTSPEED_1GBIT</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">LPFC_LINK_SPEED_2GHZ</span>:
			<span class="n">fc_host_speed</span><span class="p">(</span><span class="n">shost</span><span class="p">)</span> <span class="o">=</span> <span class="n">FC_PORTSPEED_2GBIT</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">LPFC_LINK_SPEED_4GHZ</span>:
			<span class="n">fc_host_speed</span><span class="p">(</span><span class="n">shost</span><span class="p">)</span> <span class="o">=</span> <span class="n">FC_PORTSPEED_4GBIT</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">LPFC_LINK_SPEED_8GHZ</span>:
			<span class="n">fc_host_speed</span><span class="p">(</span><span class="n">shost</span><span class="p">)</span> <span class="o">=</span> <span class="n">FC_PORTSPEED_8GBIT</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">LPFC_LINK_SPEED_10GHZ</span>:
			<span class="n">fc_host_speed</span><span class="p">(</span><span class="n">shost</span><span class="p">)</span> <span class="o">=</span> <span class="n">FC_PORTSPEED_10GBIT</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">LPFC_LINK_SPEED_16GHZ</span>:
			<span class="n">fc_host_speed</span><span class="p">(</span><span class="n">shost</span><span class="p">)</span> <span class="o">=</span> <span class="n">FC_PORTSPEED_16GBIT</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="nl">default:</span>
			<span class="n">fc_host_speed</span><span class="p">(</span><span class="n">shost</span><span class="p">)</span> <span class="o">=</span> <span class="n">FC_PORTSPEED_UNKNOWN</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">fc_host_speed</span><span class="p">(</span><span class="n">shost</span><span class="p">)</span> <span class="o">=</span> <span class="n">FC_PORTSPEED_UNKNOWN</span><span class="p">;</span>

	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_get_host_fabric_name - Set the value of the scsi host fabric name</span>
<span class="cm"> * @shost: kernel scsi host pointer.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">lpfc_get_host_fabric_name</span> <span class="p">(</span><span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="n">vport</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="p">)</span> <span class="n">shost</span><span class="o">-&gt;</span><span class="n">hostdata</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_hba</span>   <span class="o">*</span><span class="n">phba</span> <span class="o">=</span> <span class="n">vport</span><span class="o">-&gt;</span><span class="n">phba</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">node_name</span><span class="p">;</span>

	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">port_state</span> <span class="o">&gt;</span> <span class="n">LPFC_FLOGI</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="p">((</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_flag</span> <span class="o">&amp;</span> <span class="n">FC_FABRIC</span><span class="p">)</span> <span class="o">||</span>
	     <span class="p">((</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">fc_topology</span> <span class="o">==</span> <span class="n">LPFC_TOPOLOGY_LOOP</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	      <span class="p">(</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_flag</span> <span class="o">&amp;</span> <span class="n">FC_PUBLIC_LOOP</span><span class="p">))))</span>
		<span class="n">node_name</span> <span class="o">=</span> <span class="n">wwn_to_u64</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">fc_fabparam</span><span class="p">.</span><span class="n">nodeName</span><span class="p">.</span><span class="n">u</span><span class="p">.</span><span class="n">wwn</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="cm">/* fabric is local port if there is no F/FL_Port */</span>
		<span class="n">node_name</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>

	<span class="n">fc_host_fabric_name</span><span class="p">(</span><span class="n">shost</span><span class="p">)</span> <span class="o">=</span> <span class="n">node_name</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_get_stats - Return statistical information about the adapter</span>
<span class="cm"> * @shost: kernel scsi host pointer.</span>
<span class="cm"> *</span>
<span class="cm"> * Notes:</span>
<span class="cm"> * NULL on error for link down, no mbox pool, sli2 active,</span>
<span class="cm"> * management not allowed, memory allocation error, or mbox error.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns:</span>
<span class="cm"> * NULL for error</span>
<span class="cm"> * address of the adapter host statistics</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">fc_host_statistics</span> <span class="o">*</span>
<span class="nf">lpfc_get_stats</span><span class="p">(</span><span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="n">vport</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="p">)</span> <span class="n">shost</span><span class="o">-&gt;</span><span class="n">hostdata</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_hba</span>   <span class="o">*</span><span class="n">phba</span> <span class="o">=</span> <span class="n">vport</span><span class="o">-&gt;</span><span class="n">phba</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_sli</span>   <span class="o">*</span><span class="n">psli</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fc_host_statistics</span> <span class="o">*</span><span class="n">hs</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">link_stats</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_lnk_stat</span> <span class="o">*</span> <span class="n">lso</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">psli</span><span class="o">-&gt;</span><span class="n">lnk_stat_offsets</span><span class="p">;</span>
	<span class="n">LPFC_MBOXQ_t</span> <span class="o">*</span><span class="n">pmboxq</span><span class="p">;</span>
	<span class="n">MAILBOX_t</span> <span class="o">*</span><span class="n">pmb</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">seconds</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * prevent udev from issuing mailbox commands until the port is</span>
<span class="cm">	 * configured.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">link_state</span> <span class="o">&lt;</span> <span class="n">LPFC_LINK_DOWN</span> <span class="o">||</span>
	    <span class="o">!</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">mbox_mem_pool</span> <span class="o">||</span>
	    <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli</span><span class="p">.</span><span class="n">sli_flag</span> <span class="o">&amp;</span> <span class="n">LPFC_SLI_ACTIVE</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli</span><span class="p">.</span><span class="n">sli_flag</span> <span class="o">&amp;</span> <span class="n">LPFC_BLOCK_MGMT_IO</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">pmboxq</span> <span class="o">=</span> <span class="n">mempool_alloc</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">mbox_mem_pool</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pmboxq</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">pmboxq</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span> <span class="p">(</span><span class="n">LPFC_MBOXQ_t</span><span class="p">));</span>

	<span class="n">pmb</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">pmboxq</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">mb</span><span class="p">;</span>
	<span class="n">pmb</span><span class="o">-&gt;</span><span class="n">mbxCommand</span> <span class="o">=</span> <span class="n">MBX_READ_STATUS</span><span class="p">;</span>
	<span class="n">pmb</span><span class="o">-&gt;</span><span class="n">mbxOwner</span> <span class="o">=</span> <span class="n">OWN_HOST</span><span class="p">;</span>
	<span class="n">pmboxq</span><span class="o">-&gt;</span><span class="n">context1</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">pmboxq</span><span class="o">-&gt;</span><span class="n">vport</span> <span class="o">=</span> <span class="n">vport</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_flag</span> <span class="o">&amp;</span> <span class="n">FC_OFFLINE_MODE</span><span class="p">)</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">lpfc_sli_issue_mbox</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">pmboxq</span><span class="p">,</span> <span class="n">MBX_POLL</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">lpfc_sli_issue_mbox_wait</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">pmboxq</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">fc_ratov</span> <span class="o">*</span> <span class="mi">2</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">!=</span> <span class="n">MBX_SUCCESS</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">!=</span> <span class="n">MBX_TIMEOUT</span><span class="p">)</span>
			<span class="n">mempool_free</span><span class="p">(</span><span class="n">pmboxq</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">mbox_mem_pool</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">memset</span><span class="p">(</span><span class="n">hs</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span> <span class="p">(</span><span class="k">struct</span> <span class="n">fc_host_statistics</span><span class="p">));</span>

	<span class="n">hs</span><span class="o">-&gt;</span><span class="n">tx_frames</span> <span class="o">=</span> <span class="n">pmb</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">varRdStatus</span><span class="p">.</span><span class="n">xmitFrameCnt</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * The MBX_READ_STATUS returns tx_k_bytes which has to</span>
<span class="cm">	 * converted to words</span>
<span class="cm">	 */</span>
	<span class="n">hs</span><span class="o">-&gt;</span><span class="n">tx_words</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint64_t</span><span class="p">)</span>
			<span class="p">((</span><span class="kt">uint64_t</span><span class="p">)</span><span class="n">pmb</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">varRdStatus</span><span class="p">.</span><span class="n">xmitByteCnt</span>
			<span class="o">*</span> <span class="p">(</span><span class="kt">uint64_t</span><span class="p">)</span><span class="mi">256</span><span class="p">);</span>
	<span class="n">hs</span><span class="o">-&gt;</span><span class="n">rx_frames</span> <span class="o">=</span> <span class="n">pmb</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">varRdStatus</span><span class="p">.</span><span class="n">rcvFrameCnt</span><span class="p">;</span>
	<span class="n">hs</span><span class="o">-&gt;</span><span class="n">rx_words</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint64_t</span><span class="p">)</span>
			<span class="p">((</span><span class="kt">uint64_t</span><span class="p">)</span><span class="n">pmb</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">varRdStatus</span><span class="p">.</span><span class="n">rcvByteCnt</span>
			 <span class="o">*</span> <span class="p">(</span><span class="kt">uint64_t</span><span class="p">)</span><span class="mi">256</span><span class="p">);</span>

	<span class="n">memset</span><span class="p">(</span><span class="n">pmboxq</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span> <span class="p">(</span><span class="n">LPFC_MBOXQ_t</span><span class="p">));</span>
	<span class="n">pmb</span><span class="o">-&gt;</span><span class="n">mbxCommand</span> <span class="o">=</span> <span class="n">MBX_READ_LNK_STAT</span><span class="p">;</span>
	<span class="n">pmb</span><span class="o">-&gt;</span><span class="n">mbxOwner</span> <span class="o">=</span> <span class="n">OWN_HOST</span><span class="p">;</span>
	<span class="n">pmboxq</span><span class="o">-&gt;</span><span class="n">context1</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">pmboxq</span><span class="o">-&gt;</span><span class="n">vport</span> <span class="o">=</span> <span class="n">vport</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_flag</span> <span class="o">&amp;</span> <span class="n">FC_OFFLINE_MODE</span><span class="p">)</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">lpfc_sli_issue_mbox</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">pmboxq</span><span class="p">,</span> <span class="n">MBX_POLL</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">lpfc_sli_issue_mbox_wait</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">pmboxq</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">fc_ratov</span> <span class="o">*</span> <span class="mi">2</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">!=</span> <span class="n">MBX_SUCCESS</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">!=</span> <span class="n">MBX_TIMEOUT</span><span class="p">)</span>
			<span class="n">mempool_free</span><span class="p">(</span><span class="n">pmboxq</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">mbox_mem_pool</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">hs</span><span class="o">-&gt;</span><span class="n">link_failure_count</span> <span class="o">=</span> <span class="n">pmb</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">varRdLnk</span><span class="p">.</span><span class="n">linkFailureCnt</span><span class="p">;</span>
	<span class="n">hs</span><span class="o">-&gt;</span><span class="n">loss_of_sync_count</span> <span class="o">=</span> <span class="n">pmb</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">varRdLnk</span><span class="p">.</span><span class="n">lossSyncCnt</span><span class="p">;</span>
	<span class="n">hs</span><span class="o">-&gt;</span><span class="n">loss_of_signal_count</span> <span class="o">=</span> <span class="n">pmb</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">varRdLnk</span><span class="p">.</span><span class="n">lossSignalCnt</span><span class="p">;</span>
	<span class="n">hs</span><span class="o">-&gt;</span><span class="n">prim_seq_protocol_err_count</span> <span class="o">=</span> <span class="n">pmb</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">varRdLnk</span><span class="p">.</span><span class="n">primSeqErrCnt</span><span class="p">;</span>
	<span class="n">hs</span><span class="o">-&gt;</span><span class="n">invalid_tx_word_count</span> <span class="o">=</span> <span class="n">pmb</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">varRdLnk</span><span class="p">.</span><span class="n">invalidXmitWord</span><span class="p">;</span>
	<span class="n">hs</span><span class="o">-&gt;</span><span class="n">invalid_crc_count</span> <span class="o">=</span> <span class="n">pmb</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">varRdLnk</span><span class="p">.</span><span class="n">crcCnt</span><span class="p">;</span>
	<span class="n">hs</span><span class="o">-&gt;</span><span class="n">error_frames</span> <span class="o">=</span> <span class="n">pmb</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">varRdLnk</span><span class="p">.</span><span class="n">crcCnt</span><span class="p">;</span>

	<span class="n">hs</span><span class="o">-&gt;</span><span class="n">link_failure_count</span> <span class="o">-=</span> <span class="n">lso</span><span class="o">-&gt;</span><span class="n">link_failure_count</span><span class="p">;</span>
	<span class="n">hs</span><span class="o">-&gt;</span><span class="n">loss_of_sync_count</span> <span class="o">-=</span> <span class="n">lso</span><span class="o">-&gt;</span><span class="n">loss_of_sync_count</span><span class="p">;</span>
	<span class="n">hs</span><span class="o">-&gt;</span><span class="n">loss_of_signal_count</span> <span class="o">-=</span> <span class="n">lso</span><span class="o">-&gt;</span><span class="n">loss_of_signal_count</span><span class="p">;</span>
	<span class="n">hs</span><span class="o">-&gt;</span><span class="n">prim_seq_protocol_err_count</span> <span class="o">-=</span> <span class="n">lso</span><span class="o">-&gt;</span><span class="n">prim_seq_protocol_err_count</span><span class="p">;</span>
	<span class="n">hs</span><span class="o">-&gt;</span><span class="n">invalid_tx_word_count</span> <span class="o">-=</span> <span class="n">lso</span><span class="o">-&gt;</span><span class="n">invalid_tx_word_count</span><span class="p">;</span>
	<span class="n">hs</span><span class="o">-&gt;</span><span class="n">invalid_crc_count</span> <span class="o">-=</span> <span class="n">lso</span><span class="o">-&gt;</span><span class="n">invalid_crc_count</span><span class="p">;</span>
	<span class="n">hs</span><span class="o">-&gt;</span><span class="n">error_frames</span> <span class="o">-=</span> <span class="n">lso</span><span class="o">-&gt;</span><span class="n">error_frames</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hba_flag</span> <span class="o">&amp;</span> <span class="n">HBA_FCOE_MODE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">hs</span><span class="o">-&gt;</span><span class="n">lip_count</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">hs</span><span class="o">-&gt;</span><span class="n">nos_count</span> <span class="o">=</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">link_events</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">hs</span><span class="o">-&gt;</span><span class="n">nos_count</span> <span class="o">-=</span> <span class="n">lso</span><span class="o">-&gt;</span><span class="n">link_events</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">fc_topology</span> <span class="o">==</span> <span class="n">LPFC_TOPOLOGY_LOOP</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">hs</span><span class="o">-&gt;</span><span class="n">lip_count</span> <span class="o">=</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">fc_eventTag</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">hs</span><span class="o">-&gt;</span><span class="n">lip_count</span> <span class="o">-=</span> <span class="n">lso</span><span class="o">-&gt;</span><span class="n">link_events</span><span class="p">;</span>
		<span class="n">hs</span><span class="o">-&gt;</span><span class="n">nos_count</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">hs</span><span class="o">-&gt;</span><span class="n">lip_count</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">hs</span><span class="o">-&gt;</span><span class="n">nos_count</span> <span class="o">=</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">fc_eventTag</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">hs</span><span class="o">-&gt;</span><span class="n">nos_count</span> <span class="o">-=</span> <span class="n">lso</span><span class="o">-&gt;</span><span class="n">link_events</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">hs</span><span class="o">-&gt;</span><span class="n">dumped_frames</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="n">seconds</span> <span class="o">=</span> <span class="n">get_seconds</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">seconds</span> <span class="o">&lt;</span> <span class="n">psli</span><span class="o">-&gt;</span><span class="n">stats_start</span><span class="p">)</span>
		<span class="n">hs</span><span class="o">-&gt;</span><span class="n">seconds_since_last_reset</span> <span class="o">=</span> <span class="n">seconds</span> <span class="o">+</span>
				<span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span> <span class="o">-</span> <span class="n">psli</span><span class="o">-&gt;</span><span class="n">stats_start</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">hs</span><span class="o">-&gt;</span><span class="n">seconds_since_last_reset</span> <span class="o">=</span> <span class="n">seconds</span> <span class="o">-</span> <span class="n">psli</span><span class="o">-&gt;</span><span class="n">stats_start</span><span class="p">;</span>

	<span class="n">mempool_free</span><span class="p">(</span><span class="n">pmboxq</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">mbox_mem_pool</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">hs</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_reset_stats - Copy the adapter link stats information</span>
<span class="cm"> * @shost: kernel scsi host pointer.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">lpfc_reset_stats</span><span class="p">(</span><span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="n">vport</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="p">)</span> <span class="n">shost</span><span class="o">-&gt;</span><span class="n">hostdata</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_hba</span>   <span class="o">*</span><span class="n">phba</span> <span class="o">=</span> <span class="n">vport</span><span class="o">-&gt;</span><span class="n">phba</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_sli</span>   <span class="o">*</span><span class="n">psli</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_lnk_stat</span> <span class="o">*</span><span class="n">lso</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">psli</span><span class="o">-&gt;</span><span class="n">lnk_stat_offsets</span><span class="p">;</span>
	<span class="n">LPFC_MBOXQ_t</span> <span class="o">*</span><span class="n">pmboxq</span><span class="p">;</span>
	<span class="n">MAILBOX_t</span> <span class="o">*</span><span class="n">pmb</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli</span><span class="p">.</span><span class="n">sli_flag</span> <span class="o">&amp;</span> <span class="n">LPFC_BLOCK_MGMT_IO</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">pmboxq</span> <span class="o">=</span> <span class="n">mempool_alloc</span><span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">mbox_mem_pool</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pmboxq</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">pmboxq</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">LPFC_MBOXQ_t</span><span class="p">));</span>

	<span class="n">pmb</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">pmboxq</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">mb</span><span class="p">;</span>
	<span class="n">pmb</span><span class="o">-&gt;</span><span class="n">mbxCommand</span> <span class="o">=</span> <span class="n">MBX_READ_STATUS</span><span class="p">;</span>
	<span class="n">pmb</span><span class="o">-&gt;</span><span class="n">mbxOwner</span> <span class="o">=</span> <span class="n">OWN_HOST</span><span class="p">;</span>
	<span class="n">pmb</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">varWords</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x1</span><span class="p">;</span> <span class="cm">/* reset request */</span>
	<span class="n">pmboxq</span><span class="o">-&gt;</span><span class="n">context1</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">pmboxq</span><span class="o">-&gt;</span><span class="n">vport</span> <span class="o">=</span> <span class="n">vport</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_flag</span> <span class="o">&amp;</span> <span class="n">FC_OFFLINE_MODE</span><span class="p">)</span> <span class="o">||</span>
		<span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">psli</span><span class="o">-&gt;</span><span class="n">sli_flag</span> <span class="o">&amp;</span> <span class="n">LPFC_SLI_ACTIVE</span><span class="p">)))</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">lpfc_sli_issue_mbox</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">pmboxq</span><span class="p">,</span> <span class="n">MBX_POLL</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">lpfc_sli_issue_mbox_wait</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">pmboxq</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">fc_ratov</span> <span class="o">*</span> <span class="mi">2</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">!=</span> <span class="n">MBX_SUCCESS</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">!=</span> <span class="n">MBX_TIMEOUT</span><span class="p">)</span>
			<span class="n">mempool_free</span><span class="p">(</span><span class="n">pmboxq</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">mbox_mem_pool</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">memset</span><span class="p">(</span><span class="n">pmboxq</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">LPFC_MBOXQ_t</span><span class="p">));</span>
	<span class="n">pmb</span><span class="o">-&gt;</span><span class="n">mbxCommand</span> <span class="o">=</span> <span class="n">MBX_READ_LNK_STAT</span><span class="p">;</span>
	<span class="n">pmb</span><span class="o">-&gt;</span><span class="n">mbxOwner</span> <span class="o">=</span> <span class="n">OWN_HOST</span><span class="p">;</span>
	<span class="n">pmboxq</span><span class="o">-&gt;</span><span class="n">context1</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">pmboxq</span><span class="o">-&gt;</span><span class="n">vport</span> <span class="o">=</span> <span class="n">vport</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_flag</span> <span class="o">&amp;</span> <span class="n">FC_OFFLINE_MODE</span><span class="p">)</span> <span class="o">||</span>
	    <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">psli</span><span class="o">-&gt;</span><span class="n">sli_flag</span> <span class="o">&amp;</span> <span class="n">LPFC_SLI_ACTIVE</span><span class="p">)))</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">lpfc_sli_issue_mbox</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">pmboxq</span><span class="p">,</span> <span class="n">MBX_POLL</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">lpfc_sli_issue_mbox_wait</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">pmboxq</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">fc_ratov</span> <span class="o">*</span> <span class="mi">2</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">!=</span> <span class="n">MBX_SUCCESS</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">!=</span> <span class="n">MBX_TIMEOUT</span><span class="p">)</span>
			<span class="n">mempool_free</span><span class="p">(</span> <span class="n">pmboxq</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">mbox_mem_pool</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">lso</span><span class="o">-&gt;</span><span class="n">link_failure_count</span> <span class="o">=</span> <span class="n">pmb</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">varRdLnk</span><span class="p">.</span><span class="n">linkFailureCnt</span><span class="p">;</span>
	<span class="n">lso</span><span class="o">-&gt;</span><span class="n">loss_of_sync_count</span> <span class="o">=</span> <span class="n">pmb</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">varRdLnk</span><span class="p">.</span><span class="n">lossSyncCnt</span><span class="p">;</span>
	<span class="n">lso</span><span class="o">-&gt;</span><span class="n">loss_of_signal_count</span> <span class="o">=</span> <span class="n">pmb</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">varRdLnk</span><span class="p">.</span><span class="n">lossSignalCnt</span><span class="p">;</span>
	<span class="n">lso</span><span class="o">-&gt;</span><span class="n">prim_seq_protocol_err_count</span> <span class="o">=</span> <span class="n">pmb</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">varRdLnk</span><span class="p">.</span><span class="n">primSeqErrCnt</span><span class="p">;</span>
	<span class="n">lso</span><span class="o">-&gt;</span><span class="n">invalid_tx_word_count</span> <span class="o">=</span> <span class="n">pmb</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">varRdLnk</span><span class="p">.</span><span class="n">invalidXmitWord</span><span class="p">;</span>
	<span class="n">lso</span><span class="o">-&gt;</span><span class="n">invalid_crc_count</span> <span class="o">=</span> <span class="n">pmb</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">varRdLnk</span><span class="p">.</span><span class="n">crcCnt</span><span class="p">;</span>
	<span class="n">lso</span><span class="o">-&gt;</span><span class="n">error_frames</span> <span class="o">=</span> <span class="n">pmb</span><span class="o">-&gt;</span><span class="n">un</span><span class="p">.</span><span class="n">varRdLnk</span><span class="p">.</span><span class="n">crcCnt</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">hba_flag</span> <span class="o">&amp;</span> <span class="n">HBA_FCOE_MODE</span><span class="p">)</span>
		<span class="n">lso</span><span class="o">-&gt;</span><span class="n">link_events</span> <span class="o">=</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">link_events</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">lso</span><span class="o">-&gt;</span><span class="n">link_events</span> <span class="o">=</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">fc_eventTag</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">);</span>

	<span class="n">psli</span><span class="o">-&gt;</span><span class="n">stats_start</span> <span class="o">=</span> <span class="n">get_seconds</span><span class="p">();</span>

	<span class="n">mempool_free</span><span class="p">(</span><span class="n">pmboxq</span><span class="p">,</span> <span class="n">phba</span><span class="o">-&gt;</span><span class="n">mbox_mem_pool</span><span class="p">);</span>

	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * The LPFC driver treats linkdown handling as target loss events so there</span>
<span class="cm"> * are no sysfs handlers for link_down_tmo.</span>
<span class="cm"> */</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_get_node_by_target - Return the nodelist for a target</span>
<span class="cm"> * @starget: kernel scsi target pointer.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns:</span>
<span class="cm"> * address of the node list if found</span>
<span class="cm"> * NULL target not found</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">lpfc_nodelist</span> <span class="o">*</span>
<span class="nf">lpfc_get_node_by_target</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_target</span> <span class="o">*</span><span class="n">starget</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span>  <span class="o">*</span><span class="n">shost</span> <span class="o">=</span> <span class="n">dev_to_shost</span><span class="p">(</span><span class="n">starget</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">parent</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="n">vport</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="p">)</span> <span class="n">shost</span><span class="o">-&gt;</span><span class="n">hostdata</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lpfc_nodelist</span> <span class="o">*</span><span class="n">ndlp</span><span class="p">;</span>

	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>
	<span class="cm">/* Search for this, mapped, target ID */</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">ndlp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">fc_nodes</span><span class="p">,</span> <span class="n">nlp_listp</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">NLP_CHK_NODE_ACT</span><span class="p">(</span><span class="n">ndlp</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_state</span> <span class="o">==</span> <span class="n">NLP_STE_MAPPED_NODE</span> <span class="o">&amp;&amp;</span>
		    <span class="n">starget</span><span class="o">-&gt;</span><span class="n">id</span> <span class="o">==</span> <span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_sid</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">ndlp</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_get_starget_port_id - Set the target port id to the ndlp DID or -1</span>
<span class="cm"> * @starget: kernel scsi target pointer.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">lpfc_get_starget_port_id</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_target</span> <span class="o">*</span><span class="n">starget</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpfc_nodelist</span> <span class="o">*</span><span class="n">ndlp</span> <span class="o">=</span> <span class="n">lpfc_get_node_by_target</span><span class="p">(</span><span class="n">starget</span><span class="p">);</span>

	<span class="n">fc_starget_port_id</span><span class="p">(</span><span class="n">starget</span><span class="p">)</span> <span class="o">=</span> <span class="n">ndlp</span> <span class="o">?</span> <span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_DID</span> <span class="o">:</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_get_starget_node_name - Set the target node name</span>
<span class="cm"> * @starget: kernel scsi target pointer.</span>
<span class="cm"> *</span>
<span class="cm"> * Description: Set the target node name to the ndlp node name wwn or zero.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">lpfc_get_starget_node_name</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_target</span> <span class="o">*</span><span class="n">starget</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpfc_nodelist</span> <span class="o">*</span><span class="n">ndlp</span> <span class="o">=</span> <span class="n">lpfc_get_node_by_target</span><span class="p">(</span><span class="n">starget</span><span class="p">);</span>

	<span class="n">fc_starget_node_name</span><span class="p">(</span><span class="n">starget</span><span class="p">)</span> <span class="o">=</span>
		<span class="n">ndlp</span> <span class="o">?</span> <span class="n">wwn_to_u64</span><span class="p">(</span><span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_nodename</span><span class="p">.</span><span class="n">u</span><span class="p">.</span><span class="n">wwn</span><span class="p">)</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_get_starget_port_name - Set the target port name</span>
<span class="cm"> * @starget: kernel scsi target pointer.</span>
<span class="cm"> *</span>
<span class="cm"> * Description:  set the target port name to the ndlp port name wwn or zero.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">lpfc_get_starget_port_name</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_target</span> <span class="o">*</span><span class="n">starget</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpfc_nodelist</span> <span class="o">*</span><span class="n">ndlp</span> <span class="o">=</span> <span class="n">lpfc_get_node_by_target</span><span class="p">(</span><span class="n">starget</span><span class="p">);</span>

	<span class="n">fc_starget_port_name</span><span class="p">(</span><span class="n">starget</span><span class="p">)</span> <span class="o">=</span>
		<span class="n">ndlp</span> <span class="o">?</span> <span class="n">wwn_to_u64</span><span class="p">(</span><span class="n">ndlp</span><span class="o">-&gt;</span><span class="n">nlp_portname</span><span class="p">.</span><span class="n">u</span><span class="p">.</span><span class="n">wwn</span><span class="p">)</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_set_rport_loss_tmo - Set the rport dev loss tmo</span>
<span class="cm"> * @rport: fc rport address.</span>
<span class="cm"> * @timeout: new value for dev loss tmo.</span>
<span class="cm"> *</span>
<span class="cm"> * Description:</span>
<span class="cm"> * If timeout is non zero set the dev_loss_tmo to timeout, else set</span>
<span class="cm"> * dev_loss_tmo to one.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">lpfc_set_rport_loss_tmo</span><span class="p">(</span><span class="k">struct</span> <span class="n">fc_rport</span> <span class="o">*</span><span class="n">rport</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">timeout</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">timeout</span><span class="p">)</span>
		<span class="n">rport</span><span class="o">-&gt;</span><span class="n">dev_loss_tmo</span> <span class="o">=</span> <span class="n">timeout</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">rport</span><span class="o">-&gt;</span><span class="n">dev_loss_tmo</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_rport_show_function - Return rport target information</span>
<span class="cm"> *</span>
<span class="cm"> * Description:</span>
<span class="cm"> * Macro that uses field to generate a function with the name lpfc_show_rport_</span>
<span class="cm"> *</span>
<span class="cm"> * lpfc_show_rport_##field: returns the bytes formatted in buf</span>
<span class="cm"> * @cdev: class converted to an fc_rport.</span>
<span class="cm"> * @buf: on return contains the target_field or zero.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns: size of formatted string.</span>
<span class="cm"> **/</span>
<span class="cp">#define lpfc_rport_show_function(field, format_string, sz, cast)	\</span>
<span class="cp">static ssize_t								\</span>
<span class="cp">lpfc_show_rport_##field (struct device *dev,				\</span>
<span class="cp">			 struct device_attribute *attr,			\</span>
<span class="cp">			 char *buf)					\</span>
<span class="cp">{									\</span>
<span class="cp">	struct fc_rport *rport = transport_class_to_rport(dev);		\</span>
<span class="cp">	struct lpfc_rport_data *rdata = rport-&gt;hostdata;		\</span>
<span class="cp">	return snprintf(buf, sz, format_string,				\</span>
<span class="cp">		(rdata-&gt;target) ? cast rdata-&gt;target-&gt;field : 0);	\</span>
<span class="cp">}</span>

<span class="cp">#define lpfc_rport_rd_attr(field, format_string, sz)			\</span>
<span class="cp">	lpfc_rport_show_function(field, format_string, sz, )		\</span>
<span class="cp">static FC_RPORT_ATTR(field, S_IRUGO, lpfc_show_rport_##field, NULL)</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_set_vport_symbolic_name - Set the vport&#39;s symbolic name</span>
<span class="cm"> * @fc_vport: The fc_vport who&#39;s symbolic name has been changed.</span>
<span class="cm"> *</span>
<span class="cm"> * Description:</span>
<span class="cm"> * This function is called by the transport after the @fc_vport&#39;s symbolic name</span>
<span class="cm"> * has been changed. This function re-registers the symbolic name with the</span>
<span class="cm"> * switch to propagate the change into the fabric if the vport is active.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">lpfc_set_vport_symbolic_name</span><span class="p">(</span><span class="k">struct</span> <span class="n">fc_vport</span> <span class="o">*</span><span class="n">fc_vport</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="n">vport</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">**</span><span class="p">)</span><span class="n">fc_vport</span><span class="o">-&gt;</span><span class="n">dd_data</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">vport</span><span class="o">-&gt;</span><span class="n">port_state</span> <span class="o">==</span> <span class="n">LPFC_VPORT_READY</span><span class="p">)</span>
		<span class="n">lpfc_ns_cmd</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">SLI_CTNS_RSPN_ID</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_hba_log_verbose_init - Set hba&#39;s log verbose level</span>
<span class="cm"> * @phba: Pointer to lpfc_hba struct.</span>
<span class="cm"> *</span>
<span class="cm"> * This function is called by the lpfc_get_cfgparam() routine to set the</span>
<span class="cm"> * module lpfc_log_verbose into the @phba cfg_log_verbose for use with</span>
<span class="cm"> * log message according to the module&#39;s lpfc_log_verbose parameter setting</span>
<span class="cm"> * before hba port or vport created.</span>
<span class="cm"> **/</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">lpfc_hba_log_verbose_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">verbose</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">cfg_log_verbose</span> <span class="o">=</span> <span class="n">verbose</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">fc_function_template</span> <span class="n">lpfc_transport_functions</span> <span class="o">=</span> <span class="p">{</span>
	<span class="cm">/* fixed attributes the driver supports */</span>
	<span class="p">.</span><span class="n">show_host_node_name</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
	<span class="p">.</span><span class="n">show_host_port_name</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
	<span class="p">.</span><span class="n">show_host_supported_classes</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
	<span class="p">.</span><span class="n">show_host_supported_fc4s</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
	<span class="p">.</span><span class="n">show_host_supported_speeds</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
	<span class="p">.</span><span class="n">show_host_maxframe_size</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
	<span class="p">.</span><span class="n">show_host_symbolic_name</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>

	<span class="cm">/* dynamic attributes the driver supports */</span>
	<span class="p">.</span><span class="n">get_host_port_id</span> <span class="o">=</span> <span class="n">lpfc_get_host_port_id</span><span class="p">,</span>
	<span class="p">.</span><span class="n">show_host_port_id</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>

	<span class="p">.</span><span class="n">get_host_port_type</span> <span class="o">=</span> <span class="n">lpfc_get_host_port_type</span><span class="p">,</span>
	<span class="p">.</span><span class="n">show_host_port_type</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>

	<span class="p">.</span><span class="n">get_host_port_state</span> <span class="o">=</span> <span class="n">lpfc_get_host_port_state</span><span class="p">,</span>
	<span class="p">.</span><span class="n">show_host_port_state</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>

	<span class="cm">/* active_fc4s is shown but doesn&#39;t change (thus no get function) */</span>
	<span class="p">.</span><span class="n">show_host_active_fc4s</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>

	<span class="p">.</span><span class="n">get_host_speed</span> <span class="o">=</span> <span class="n">lpfc_get_host_speed</span><span class="p">,</span>
	<span class="p">.</span><span class="n">show_host_speed</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>

	<span class="p">.</span><span class="n">get_host_fabric_name</span> <span class="o">=</span> <span class="n">lpfc_get_host_fabric_name</span><span class="p">,</span>
	<span class="p">.</span><span class="n">show_host_fabric_name</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>

	<span class="cm">/*</span>
<span class="cm">	 * The LPFC driver treats linkdown handling as target loss events</span>
<span class="cm">	 * so there are no sysfs handlers for link_down_tmo.</span>
<span class="cm">	 */</span>

	<span class="p">.</span><span class="n">get_fc_host_stats</span> <span class="o">=</span> <span class="n">lpfc_get_stats</span><span class="p">,</span>
	<span class="p">.</span><span class="n">reset_fc_host_stats</span> <span class="o">=</span> <span class="n">lpfc_reset_stats</span><span class="p">,</span>

	<span class="p">.</span><span class="n">dd_fcrport_size</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_rport_data</span><span class="p">),</span>
	<span class="p">.</span><span class="n">show_rport_maxframe_size</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
	<span class="p">.</span><span class="n">show_rport_supported_classes</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>

	<span class="p">.</span><span class="n">set_rport_dev_loss_tmo</span> <span class="o">=</span> <span class="n">lpfc_set_rport_loss_tmo</span><span class="p">,</span>
	<span class="p">.</span><span class="n">show_rport_dev_loss_tmo</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>

	<span class="p">.</span><span class="n">get_starget_port_id</span>  <span class="o">=</span> <span class="n">lpfc_get_starget_port_id</span><span class="p">,</span>
	<span class="p">.</span><span class="n">show_starget_port_id</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>

	<span class="p">.</span><span class="n">get_starget_node_name</span> <span class="o">=</span> <span class="n">lpfc_get_starget_node_name</span><span class="p">,</span>
	<span class="p">.</span><span class="n">show_starget_node_name</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>

	<span class="p">.</span><span class="n">get_starget_port_name</span> <span class="o">=</span> <span class="n">lpfc_get_starget_port_name</span><span class="p">,</span>
	<span class="p">.</span><span class="n">show_starget_port_name</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>

	<span class="p">.</span><span class="n">issue_fc_host_lip</span> <span class="o">=</span> <span class="n">lpfc_issue_lip</span><span class="p">,</span>
	<span class="p">.</span><span class="n">dev_loss_tmo_callbk</span> <span class="o">=</span> <span class="n">lpfc_dev_loss_tmo_callbk</span><span class="p">,</span>
	<span class="p">.</span><span class="n">terminate_rport_io</span> <span class="o">=</span> <span class="n">lpfc_terminate_rport_io</span><span class="p">,</span>

	<span class="p">.</span><span class="n">dd_fcvport_size</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="p">),</span>

	<span class="p">.</span><span class="n">vport_disable</span> <span class="o">=</span> <span class="n">lpfc_vport_disable</span><span class="p">,</span>

	<span class="p">.</span><span class="n">set_vport_symbolic_name</span> <span class="o">=</span> <span class="n">lpfc_set_vport_symbolic_name</span><span class="p">,</span>

	<span class="p">.</span><span class="n">bsg_request</span> <span class="o">=</span> <span class="n">lpfc_bsg_request</span><span class="p">,</span>
	<span class="p">.</span><span class="n">bsg_timeout</span> <span class="o">=</span> <span class="n">lpfc_bsg_timeout</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">fc_function_template</span> <span class="n">lpfc_vport_transport_functions</span> <span class="o">=</span> <span class="p">{</span>
	<span class="cm">/* fixed attributes the driver supports */</span>
	<span class="p">.</span><span class="n">show_host_node_name</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
	<span class="p">.</span><span class="n">show_host_port_name</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
	<span class="p">.</span><span class="n">show_host_supported_classes</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
	<span class="p">.</span><span class="n">show_host_supported_fc4s</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
	<span class="p">.</span><span class="n">show_host_supported_speeds</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
	<span class="p">.</span><span class="n">show_host_maxframe_size</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
	<span class="p">.</span><span class="n">show_host_symbolic_name</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>

	<span class="cm">/* dynamic attributes the driver supports */</span>
	<span class="p">.</span><span class="n">get_host_port_id</span> <span class="o">=</span> <span class="n">lpfc_get_host_port_id</span><span class="p">,</span>
	<span class="p">.</span><span class="n">show_host_port_id</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>

	<span class="p">.</span><span class="n">get_host_port_type</span> <span class="o">=</span> <span class="n">lpfc_get_host_port_type</span><span class="p">,</span>
	<span class="p">.</span><span class="n">show_host_port_type</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>

	<span class="p">.</span><span class="n">get_host_port_state</span> <span class="o">=</span> <span class="n">lpfc_get_host_port_state</span><span class="p">,</span>
	<span class="p">.</span><span class="n">show_host_port_state</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>

	<span class="cm">/* active_fc4s is shown but doesn&#39;t change (thus no get function) */</span>
	<span class="p">.</span><span class="n">show_host_active_fc4s</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>

	<span class="p">.</span><span class="n">get_host_speed</span> <span class="o">=</span> <span class="n">lpfc_get_host_speed</span><span class="p">,</span>
	<span class="p">.</span><span class="n">show_host_speed</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>

	<span class="p">.</span><span class="n">get_host_fabric_name</span> <span class="o">=</span> <span class="n">lpfc_get_host_fabric_name</span><span class="p">,</span>
	<span class="p">.</span><span class="n">show_host_fabric_name</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>

	<span class="cm">/*</span>
<span class="cm">	 * The LPFC driver treats linkdown handling as target loss events</span>
<span class="cm">	 * so there are no sysfs handlers for link_down_tmo.</span>
<span class="cm">	 */</span>

	<span class="p">.</span><span class="n">get_fc_host_stats</span> <span class="o">=</span> <span class="n">lpfc_get_stats</span><span class="p">,</span>
	<span class="p">.</span><span class="n">reset_fc_host_stats</span> <span class="o">=</span> <span class="n">lpfc_reset_stats</span><span class="p">,</span>

	<span class="p">.</span><span class="n">dd_fcrport_size</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_rport_data</span><span class="p">),</span>
	<span class="p">.</span><span class="n">show_rport_maxframe_size</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
	<span class="p">.</span><span class="n">show_rport_supported_classes</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>

	<span class="p">.</span><span class="n">set_rport_dev_loss_tmo</span> <span class="o">=</span> <span class="n">lpfc_set_rport_loss_tmo</span><span class="p">,</span>
	<span class="p">.</span><span class="n">show_rport_dev_loss_tmo</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>

	<span class="p">.</span><span class="n">get_starget_port_id</span>  <span class="o">=</span> <span class="n">lpfc_get_starget_port_id</span><span class="p">,</span>
	<span class="p">.</span><span class="n">show_starget_port_id</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>

	<span class="p">.</span><span class="n">get_starget_node_name</span> <span class="o">=</span> <span class="n">lpfc_get_starget_node_name</span><span class="p">,</span>
	<span class="p">.</span><span class="n">show_starget_node_name</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>

	<span class="p">.</span><span class="n">get_starget_port_name</span> <span class="o">=</span> <span class="n">lpfc_get_starget_port_name</span><span class="p">,</span>
	<span class="p">.</span><span class="n">show_starget_port_name</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>

	<span class="p">.</span><span class="n">dev_loss_tmo_callbk</span> <span class="o">=</span> <span class="n">lpfc_dev_loss_tmo_callbk</span><span class="p">,</span>
	<span class="p">.</span><span class="n">terminate_rport_io</span> <span class="o">=</span> <span class="n">lpfc_terminate_rport_io</span><span class="p">,</span>

	<span class="p">.</span><span class="n">vport_disable</span> <span class="o">=</span> <span class="n">lpfc_vport_disable</span><span class="p">,</span>

	<span class="p">.</span><span class="n">set_vport_symbolic_name</span> <span class="o">=</span> <span class="n">lpfc_set_vport_symbolic_name</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_get_cfgparam - Used during probe_one to init the adapter structure</span>
<span class="cm"> * @phba: lpfc_hba pointer.</span>
<span class="cm"> **/</span>
<span class="kt">void</span>
<span class="nf">lpfc_get_cfgparam</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_hba</span> <span class="o">*</span><span class="n">phba</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">lpfc_cr_delay_init</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">lpfc_cr_delay</span><span class="p">);</span>
	<span class="n">lpfc_cr_count_init</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">lpfc_cr_count</span><span class="p">);</span>
	<span class="n">lpfc_multi_ring_support_init</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">lpfc_multi_ring_support</span><span class="p">);</span>
	<span class="n">lpfc_multi_ring_rctl_init</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">lpfc_multi_ring_rctl</span><span class="p">);</span>
	<span class="n">lpfc_multi_ring_type_init</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">lpfc_multi_ring_type</span><span class="p">);</span>
	<span class="n">lpfc_ack0_init</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">lpfc_ack0</span><span class="p">);</span>
	<span class="n">lpfc_topology_init</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">lpfc_topology</span><span class="p">);</span>
	<span class="n">lpfc_link_speed_init</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">lpfc_link_speed</span><span class="p">);</span>
	<span class="n">lpfc_poll_tmo_init</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">lpfc_poll_tmo</span><span class="p">);</span>
	<span class="n">lpfc_enable_npiv_init</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">lpfc_enable_npiv</span><span class="p">);</span>
	<span class="n">lpfc_fcf_failover_policy_init</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">lpfc_fcf_failover_policy</span><span class="p">);</span>
	<span class="n">lpfc_enable_rrq_init</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">lpfc_enable_rrq</span><span class="p">);</span>
	<span class="n">lpfc_use_msi_init</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">lpfc_use_msi</span><span class="p">);</span>
	<span class="n">lpfc_fcp_imax_init</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">lpfc_fcp_imax</span><span class="p">);</span>
	<span class="n">lpfc_fcp_wq_count_init</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">lpfc_fcp_wq_count</span><span class="p">);</span>
	<span class="n">lpfc_fcp_eq_count_init</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">lpfc_fcp_eq_count</span><span class="p">);</span>
	<span class="n">lpfc_enable_hba_reset_init</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">lpfc_enable_hba_reset</span><span class="p">);</span>
	<span class="n">lpfc_enable_hba_heartbeat_init</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">lpfc_enable_hba_heartbeat</span><span class="p">);</span>
	<span class="n">lpfc_enable_bg_init</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">lpfc_enable_bg</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">phba</span><span class="o">-&gt;</span><span class="n">sli_rev</span> <span class="o">==</span> <span class="n">LPFC_SLI_REV4</span><span class="p">)</span>
		<span class="n">phba</span><span class="o">-&gt;</span><span class="n">cfg_poll</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">else</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">cfg_poll</span> <span class="o">=</span> <span class="n">lpfc_poll</span><span class="p">;</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">cfg_soft_wwnn</span> <span class="o">=</span> <span class="mi">0L</span><span class="p">;</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">cfg_soft_wwpn</span> <span class="o">=</span> <span class="mi">0L</span><span class="p">;</span>
	<span class="n">lpfc_sg_seg_cnt_init</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">lpfc_sg_seg_cnt</span><span class="p">);</span>
	<span class="n">lpfc_prot_sg_seg_cnt_init</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">lpfc_prot_sg_seg_cnt</span><span class="p">);</span>
	<span class="n">lpfc_hba_queue_depth_init</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">lpfc_hba_queue_depth</span><span class="p">);</span>
	<span class="n">lpfc_hba_log_verbose_init</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">lpfc_log_verbose</span><span class="p">);</span>
	<span class="n">lpfc_aer_support_init</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">lpfc_aer_support</span><span class="p">);</span>
	<span class="n">lpfc_sriov_nr_virtfn_init</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">lpfc_sriov_nr_virtfn</span><span class="p">);</span>
	<span class="n">lpfc_suppress_link_up_init</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">lpfc_suppress_link_up</span><span class="p">);</span>
	<span class="n">lpfc_iocb_cnt_init</span><span class="p">(</span><span class="n">phba</span><span class="p">,</span> <span class="n">lpfc_iocb_cnt</span><span class="p">);</span>
	<span class="n">phba</span><span class="o">-&gt;</span><span class="n">cfg_enable_dss</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * lpfc_get_vport_cfgparam - Used during port create, init the vport structure</span>
<span class="cm"> * @vport: lpfc_vport pointer.</span>
<span class="cm"> **/</span>
<span class="kt">void</span>
<span class="nf">lpfc_get_vport_cfgparam</span><span class="p">(</span><span class="k">struct</span> <span class="n">lpfc_vport</span> <span class="o">*</span><span class="n">vport</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">lpfc_log_verbose_init</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">lpfc_log_verbose</span><span class="p">);</span>
	<span class="n">lpfc_lun_queue_depth_init</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">lpfc_lun_queue_depth</span><span class="p">);</span>
	<span class="n">lpfc_tgt_queue_depth_init</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">lpfc_tgt_queue_depth</span><span class="p">);</span>
	<span class="n">lpfc_devloss_tmo_init</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">lpfc_devloss_tmo</span><span class="p">);</span>
	<span class="n">lpfc_nodev_tmo_init</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">lpfc_nodev_tmo</span><span class="p">);</span>
	<span class="n">lpfc_peer_port_login_init</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">lpfc_peer_port_login</span><span class="p">);</span>
	<span class="n">lpfc_restrict_login_init</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">lpfc_restrict_login</span><span class="p">);</span>
	<span class="n">lpfc_fcp_class_init</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">lpfc_fcp_class</span><span class="p">);</span>
	<span class="n">lpfc_use_adisc_init</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">lpfc_use_adisc</span><span class="p">);</span>
	<span class="n">lpfc_max_scsicmpl_time_init</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">lpfc_max_scsicmpl_time</span><span class="p">);</span>
	<span class="n">lpfc_fdmi_on_init</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">lpfc_fdmi_on</span><span class="p">);</span>
	<span class="n">lpfc_discovery_threads_init</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">lpfc_discovery_threads</span><span class="p">);</span>
	<span class="n">lpfc_max_luns_init</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">lpfc_max_luns</span><span class="p">);</span>
	<span class="n">lpfc_scan_down_init</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">lpfc_scan_down</span><span class="p">);</span>
	<span class="n">lpfc_enable_da_id_init</span><span class="p">(</span><span class="n">vport</span><span class="p">,</span> <span class="n">lpfc_enable_da_id</span><span class="p">);</span>
	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
