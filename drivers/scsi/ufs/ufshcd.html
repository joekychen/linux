<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › scsi › ufs › ufshcd.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>ufshcd.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Universal Flash Storage Host controller driver</span>
<span class="cm"> *</span>
<span class="cm"> * This code is based on drivers/scsi/ufs/ufshcd.c</span>
<span class="cm"> * Copyright (C) 2011-2012 Samsung India Software Operations</span>
<span class="cm"> *</span>
<span class="cm"> * Santosh Yaraganavi &lt;santosh.sy@samsung.com&gt;</span>
<span class="cm"> * Vinayak Holikatti &lt;h.vinayak@samsung.com&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or</span>
<span class="cm"> * modify it under the terms of the GNU General Public License</span>
<span class="cm"> * as published by the Free Software Foundation; either version 2</span>
<span class="cm"> * of the License, or (at your option) any later version.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is distributed in the hope that it will be useful,</span>
<span class="cm"> * but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="cm"> * GNU General Public License for more details.</span>
<span class="cm"> *</span>
<span class="cm"> * NO WARRANTY</span>
<span class="cm"> * THE PROGRAM IS PROVIDED ON AN &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR</span>
<span class="cm"> * CONDITIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED INCLUDING, WITHOUT</span>
<span class="cm"> * LIMITATION, ANY WARRANTIES OR CONDITIONS OF TITLE, NON-INFRINGEMENT,</span>
<span class="cm"> * MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. Each Recipient is</span>
<span class="cm"> * solely responsible for determining the appropriateness of using and</span>
<span class="cm"> * distributing the Program and assumes all risks associated with its</span>
<span class="cm"> * exercise of rights under this Agreement, including but not limited to</span>
<span class="cm"> * the risks and costs of program errors, damage to or loss of data,</span>
<span class="cm"> * programs or equipment, and unavailability or interruption of operations.</span>

<span class="cm"> * DISCLAIMER OF LIABILITY</span>
<span class="cm"> * NEITHER RECIPIENT NOR ANY CONTRIBUTORS SHALL HAVE ANY LIABILITY FOR ANY</span>
<span class="cm"> * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL</span>
<span class="cm"> * DAMAGES (INCLUDING WITHOUT LIMITATION LOST PROFITS), HOWEVER CAUSED AND</span>
<span class="cm"> * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR</span>
<span class="cm"> * TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE</span>
<span class="cm"> * USE OR DISTRIBUTION OF THE PROGRAM OR THE EXERCISE OF ANY RIGHTS GRANTED</span>
<span class="cm"> * HEREUNDER, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGES</span>

<span class="cm"> * You should have received a copy of the GNU General Public License</span>
<span class="cm"> * along with this program; if not, write to the Free Software</span>
<span class="cm"> * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301,</span>
<span class="cm"> * USA.</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/pci.h&gt;</span>
<span class="cp">#include &lt;linux/interrupt.h&gt;</span>
<span class="cp">#include &lt;linux/io.h&gt;</span>
<span class="cp">#include &lt;linux/delay.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/spinlock.h&gt;</span>
<span class="cp">#include &lt;linux/workqueue.h&gt;</span>
<span class="cp">#include &lt;linux/errno.h&gt;</span>
<span class="cp">#include &lt;linux/types.h&gt;</span>
<span class="cp">#include &lt;linux/wait.h&gt;</span>
<span class="cp">#include &lt;linux/bitops.h&gt;</span>

<span class="cp">#include &lt;asm/irq.h&gt;</span>
<span class="cp">#include &lt;asm/byteorder.h&gt;</span>
<span class="cp">#include &lt;scsi/scsi.h&gt;</span>
<span class="cp">#include &lt;scsi/scsi_cmnd.h&gt;</span>
<span class="cp">#include &lt;scsi/scsi_host.h&gt;</span>
<span class="cp">#include &lt;scsi/scsi_tcq.h&gt;</span>
<span class="cp">#include &lt;scsi/scsi_dbg.h&gt;</span>
<span class="cp">#include &lt;scsi/scsi_eh.h&gt;</span>

<span class="cp">#include &quot;ufs.h&quot;</span>
<span class="cp">#include &quot;ufshci.h&quot;</span>

<span class="cp">#define UFSHCD &quot;ufshcd&quot;</span>
<span class="cp">#define UFSHCD_DRIVER_VERSION &quot;0.1&quot;</span>

<span class="k">enum</span> <span class="p">{</span>
	<span class="n">UFSHCD_MAX_CHANNEL</span>	<span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	<span class="n">UFSHCD_MAX_ID</span>		<span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
	<span class="n">UFSHCD_MAX_LUNS</span>		<span class="o">=</span> <span class="mi">8</span><span class="p">,</span>
	<span class="n">UFSHCD_CMD_PER_LUN</span>	<span class="o">=</span> <span class="mi">32</span><span class="p">,</span>
	<span class="n">UFSHCD_CAN_QUEUE</span>	<span class="o">=</span> <span class="mi">32</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/* UFSHCD states */</span>
<span class="k">enum</span> <span class="p">{</span>
	<span class="n">UFSHCD_STATE_OPERATIONAL</span><span class="p">,</span>
	<span class="n">UFSHCD_STATE_RESET</span><span class="p">,</span>
	<span class="n">UFSHCD_STATE_ERROR</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/* Interrupt configuration options */</span>
<span class="k">enum</span> <span class="p">{</span>
	<span class="n">UFSHCD_INT_DISABLE</span><span class="p">,</span>
	<span class="n">UFSHCD_INT_ENABLE</span><span class="p">,</span>
	<span class="n">UFSHCD_INT_CLEAR</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/* Interrupt aggregation options */</span>
<span class="k">enum</span> <span class="p">{</span>
	<span class="n">INT_AGGR_RESET</span><span class="p">,</span>
	<span class="n">INT_AGGR_CONFIG</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct uic_command - UIC command structure</span>
<span class="cm"> * @command: UIC command</span>
<span class="cm"> * @argument1: UIC command argument 1</span>
<span class="cm"> * @argument2: UIC command argument 2</span>
<span class="cm"> * @argument3: UIC command argument 3</span>
<span class="cm"> * @cmd_active: Indicate if UIC command is outstanding</span>
<span class="cm"> * @result: UIC command result</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">uic_command</span> <span class="p">{</span>
	<span class="n">u32</span> <span class="n">command</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">argument1</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">argument2</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">argument3</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">cmd_active</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">result</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct ufs_hba - per adapter private structure</span>
<span class="cm"> * @mmio_base: UFSHCI base register address</span>
<span class="cm"> * @ucdl_base_addr: UFS Command Descriptor base address</span>
<span class="cm"> * @utrdl_base_addr: UTP Transfer Request Descriptor base address</span>
<span class="cm"> * @utmrdl_base_addr: UTP Task Management Descriptor base address</span>
<span class="cm"> * @ucdl_dma_addr: UFS Command Descriptor DMA address</span>
<span class="cm"> * @utrdl_dma_addr: UTRDL DMA address</span>
<span class="cm"> * @utmrdl_dma_addr: UTMRDL DMA address</span>
<span class="cm"> * @host: Scsi_Host instance of the driver</span>
<span class="cm"> * @pdev: PCI device handle</span>
<span class="cm"> * @lrb: local reference block</span>
<span class="cm"> * @outstanding_tasks: Bits representing outstanding task requests</span>
<span class="cm"> * @outstanding_reqs: Bits representing outstanding transfer requests</span>
<span class="cm"> * @capabilities: UFS Controller Capabilities</span>
<span class="cm"> * @nutrs: Transfer Request Queue depth supported by controller</span>
<span class="cm"> * @nutmrs: Task Management Queue depth supported by controller</span>
<span class="cm"> * @active_uic_cmd: handle of active UIC command</span>
<span class="cm"> * @ufshcd_tm_wait_queue: wait queue for task management</span>
<span class="cm"> * @tm_condition: condition variable for task management</span>
<span class="cm"> * @ufshcd_state: UFSHCD states</span>
<span class="cm"> * @int_enable_mask: Interrupt Mask Bits</span>
<span class="cm"> * @uic_workq: Work queue for UIC completion handling</span>
<span class="cm"> * @feh_workq: Work queue for fatal controller error handling</span>
<span class="cm"> * @errors: HBA errors</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ufs_hba</span> <span class="p">{</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">mmio_base</span><span class="p">;</span>

	<span class="cm">/* Virtual memory reference */</span>
	<span class="k">struct</span> <span class="n">utp_transfer_cmd_desc</span> <span class="o">*</span><span class="n">ucdl_base_addr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">utp_transfer_req_desc</span> <span class="o">*</span><span class="n">utrdl_base_addr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">utp_task_req_desc</span> <span class="o">*</span><span class="n">utmrdl_base_addr</span><span class="p">;</span>

	<span class="cm">/* DMA memory reference */</span>
	<span class="n">dma_addr_t</span> <span class="n">ucdl_dma_addr</span><span class="p">;</span>
	<span class="n">dma_addr_t</span> <span class="n">utrdl_dma_addr</span><span class="p">;</span>
	<span class="n">dma_addr_t</span> <span class="n">utmrdl_dma_addr</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">host</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">ufshcd_lrb</span> <span class="o">*</span><span class="n">lrb</span><span class="p">;</span>

	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">outstanding_tasks</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">outstanding_reqs</span><span class="p">;</span>

	<span class="n">u32</span> <span class="n">capabilities</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">nutrs</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">nutmrs</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">ufs_version</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">uic_command</span> <span class="n">active_uic_cmd</span><span class="p">;</span>
	<span class="n">wait_queue_head_t</span> <span class="n">ufshcd_tm_wait_queue</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">tm_condition</span><span class="p">;</span>

	<span class="n">u32</span> <span class="n">ufshcd_state</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">int_enable_mask</span><span class="p">;</span>

	<span class="cm">/* Work Queues */</span>
	<span class="k">struct</span> <span class="n">work_struct</span> <span class="n">uic_workq</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">work_struct</span> <span class="n">feh_workq</span><span class="p">;</span>

	<span class="cm">/* HBA Errors */</span>
	<span class="n">u32</span> <span class="n">errors</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct ufshcd_lrb - local reference block</span>
<span class="cm"> * @utr_descriptor_ptr: UTRD address of the command</span>
<span class="cm"> * @ucd_cmd_ptr: UCD address of the command</span>
<span class="cm"> * @ucd_rsp_ptr: Response UPIU address for this command</span>
<span class="cm"> * @ucd_prdt_ptr: PRDT address of the command</span>
<span class="cm"> * @cmd: pointer to SCSI command</span>
<span class="cm"> * @sense_buffer: pointer to sense buffer address of the SCSI command</span>
<span class="cm"> * @sense_bufflen: Length of the sense buffer</span>
<span class="cm"> * @scsi_status: SCSI status of the command</span>
<span class="cm"> * @command_type: SCSI, UFS, Query.</span>
<span class="cm"> * @task_tag: Task tag of the command</span>
<span class="cm"> * @lun: LUN of the command</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">ufshcd_lrb</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">utp_transfer_req_desc</span> <span class="o">*</span><span class="n">utr_descriptor_ptr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">utp_upiu_cmd</span> <span class="o">*</span><span class="n">ucd_cmd_ptr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">utp_upiu_rsp</span> <span class="o">*</span><span class="n">ucd_rsp_ptr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ufshcd_sg_entry</span> <span class="o">*</span><span class="n">ucd_prdt_ptr</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">;</span>
	<span class="n">u8</span> <span class="o">*</span><span class="n">sense_buffer</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">sense_bufflen</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">scsi_status</span><span class="p">;</span>

	<span class="kt">int</span> <span class="n">command_type</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">task_tag</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">lun</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * ufshcd_get_ufs_version - Get the UFS version supported by the HBA</span>
<span class="cm"> * @hba - Pointer to adapter instance</span>
<span class="cm"> *</span>
<span class="cm"> * Returns UFSHCI version supported by the controller</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">u32</span> <span class="nf">ufshcd_get_ufs_version</span><span class="p">(</span><span class="k">struct</span> <span class="n">ufs_hba</span> <span class="o">*</span><span class="n">hba</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">readl</span><span class="p">(</span><span class="n">hba</span><span class="o">-&gt;</span><span class="n">mmio_base</span> <span class="o">+</span> <span class="n">REG_UFS_VERSION</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ufshcd_is_device_present - Check if any device connected to</span>
<span class="cm"> *			      the host controller</span>
<span class="cm"> * @reg_hcs - host controller status register value</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 0 if device present, non-zero if no device detected</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">ufshcd_is_device_present</span><span class="p">(</span><span class="n">u32</span> <span class="n">reg_hcs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">DEVICE_PRESENT</span> <span class="o">&amp;</span> <span class="n">reg_hcs</span><span class="p">)</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ufshcd_get_tr_ocs - Get the UTRD Overall Command Status</span>
<span class="cm"> * @lrb: pointer to local command reference block</span>
<span class="cm"> *</span>
<span class="cm"> * This function is used to get the OCS field from UTRD</span>
<span class="cm"> * Returns the OCS field in the UTRD</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">ufshcd_get_tr_ocs</span><span class="p">(</span><span class="k">struct</span> <span class="n">ufshcd_lrb</span> <span class="o">*</span><span class="n">lrbp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">lrbp</span><span class="o">-&gt;</span><span class="n">utr_descriptor_ptr</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">dword_2</span> <span class="o">&amp;</span> <span class="n">MASK_OCS</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ufshcd_get_tmr_ocs - Get the UTMRD Overall Command Status</span>
<span class="cm"> * @task_req_descp: pointer to utp_task_req_desc structure</span>
<span class="cm"> *</span>
<span class="cm"> * This function is used to get the OCS field from UTMRD</span>
<span class="cm"> * Returns the OCS field in the UTMRD</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span>
<span class="nf">ufshcd_get_tmr_ocs</span><span class="p">(</span><span class="k">struct</span> <span class="n">utp_task_req_desc</span> <span class="o">*</span><span class="n">task_req_descp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">task_req_descp</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">dword_2</span> <span class="o">&amp;</span> <span class="n">MASK_OCS</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ufshcd_get_tm_free_slot - get a free slot for task management request</span>
<span class="cm"> * @hba: per adapter instance</span>
<span class="cm"> *</span>
<span class="cm"> * Returns maximum number of task management request slots in case of</span>
<span class="cm"> * task management queue full or returns the free slot number</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">ufshcd_get_tm_free_slot</span><span class="p">(</span><span class="k">struct</span> <span class="n">ufs_hba</span> <span class="o">*</span><span class="n">hba</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">find_first_zero_bit</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hba</span><span class="o">-&gt;</span><span class="n">outstanding_tasks</span><span class="p">,</span> <span class="n">hba</span><span class="o">-&gt;</span><span class="n">nutmrs</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ufshcd_utrl_clear - Clear a bit in UTRLCLR register</span>
<span class="cm"> * @hba: per adapter instance</span>
<span class="cm"> * @pos: position of the bit to be cleared</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">ufshcd_utrl_clear</span><span class="p">(</span><span class="k">struct</span> <span class="n">ufs_hba</span> <span class="o">*</span><span class="n">hba</span><span class="p">,</span> <span class="n">u32</span> <span class="n">pos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">writel</span><span class="p">(</span><span class="o">~</span><span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">pos</span><span class="p">),</span>
		<span class="p">(</span><span class="n">hba</span><span class="o">-&gt;</span><span class="n">mmio_base</span> <span class="o">+</span> <span class="n">REG_UTP_TRANSFER_REQ_LIST_CLEAR</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ufshcd_get_lists_status - Check UCRDY, UTRLRDY and UTMRLRDY</span>
<span class="cm"> * @reg: Register value of host controller status</span>
<span class="cm"> *</span>
<span class="cm"> * Returns integer, 0 on Success and positive value if failed</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">ufshcd_get_lists_status</span><span class="p">(</span><span class="n">u32</span> <span class="n">reg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * The mask 0xFF is for the following HCS register bits</span>
<span class="cm">	 * Bit		Description</span>
<span class="cm">	 *  0		Device Present</span>
<span class="cm">	 *  1		UTRLRDY</span>
<span class="cm">	 *  2		UTMRLRDY</span>
<span class="cm">	 *  3		UCRDY</span>
<span class="cm">	 *  4		HEI</span>
<span class="cm">	 *  5		DEI</span>
<span class="cm">	 * 6-7		reserved</span>
<span class="cm">	 */</span>
	<span class="k">return</span> <span class="p">(((</span><span class="n">reg</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mh">0xFF</span><span class="p">))</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">^</span> <span class="p">(</span><span class="mh">0x07</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ufshcd_get_uic_cmd_result - Get the UIC command result</span>
<span class="cm"> * @hba: Pointer to adapter instance</span>
<span class="cm"> *</span>
<span class="cm"> * This function gets the result of UIC command completion</span>
<span class="cm"> * Returns 0 on success, non zero value on error</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">ufshcd_get_uic_cmd_result</span><span class="p">(</span><span class="k">struct</span> <span class="n">ufs_hba</span> <span class="o">*</span><span class="n">hba</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">readl</span><span class="p">(</span><span class="n">hba</span><span class="o">-&gt;</span><span class="n">mmio_base</span> <span class="o">+</span> <span class="n">REG_UIC_COMMAND_ARG_2</span><span class="p">)</span> <span class="o">&amp;</span>
	       <span class="n">MASK_UIC_COMMAND_RESULT</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ufshcd_free_hba_memory - Free allocated memory for LRB, request</span>
<span class="cm"> *			    and task lists</span>
<span class="cm"> * @hba: Pointer to adapter instance</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">ufshcd_free_hba_memory</span><span class="p">(</span><span class="k">struct</span> <span class="n">ufs_hba</span> <span class="o">*</span><span class="n">hba</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">size_t</span> <span class="n">utmrdl_size</span><span class="p">,</span> <span class="n">utrdl_size</span><span class="p">,</span> <span class="n">ucdl_size</span><span class="p">;</span>

	<span class="n">kfree</span><span class="p">(</span><span class="n">hba</span><span class="o">-&gt;</span><span class="n">lrb</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">hba</span><span class="o">-&gt;</span><span class="n">utmrdl_base_addr</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">utmrdl_size</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">utp_task_req_desc</span><span class="p">)</span> <span class="o">*</span> <span class="n">hba</span><span class="o">-&gt;</span><span class="n">nutmrs</span><span class="p">;</span>
		<span class="n">dma_free_coherent</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hba</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">utmrdl_size</span><span class="p">,</span>
				  <span class="n">hba</span><span class="o">-&gt;</span><span class="n">utmrdl_base_addr</span><span class="p">,</span> <span class="n">hba</span><span class="o">-&gt;</span><span class="n">utmrdl_dma_addr</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">hba</span><span class="o">-&gt;</span><span class="n">utrdl_base_addr</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">utrdl_size</span> <span class="o">=</span>
		<span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">utp_transfer_req_desc</span><span class="p">)</span> <span class="o">*</span> <span class="n">hba</span><span class="o">-&gt;</span><span class="n">nutrs</span><span class="p">);</span>
		<span class="n">dma_free_coherent</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hba</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">utrdl_size</span><span class="p">,</span>
				  <span class="n">hba</span><span class="o">-&gt;</span><span class="n">utrdl_base_addr</span><span class="p">,</span> <span class="n">hba</span><span class="o">-&gt;</span><span class="n">utrdl_dma_addr</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">hba</span><span class="o">-&gt;</span><span class="n">ucdl_base_addr</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ucdl_size</span> <span class="o">=</span>
		<span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">utp_transfer_cmd_desc</span><span class="p">)</span> <span class="o">*</span> <span class="n">hba</span><span class="o">-&gt;</span><span class="n">nutrs</span><span class="p">);</span>
		<span class="n">dma_free_coherent</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hba</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">ucdl_size</span><span class="p">,</span>
				  <span class="n">hba</span><span class="o">-&gt;</span><span class="n">ucdl_base_addr</span><span class="p">,</span> <span class="n">hba</span><span class="o">-&gt;</span><span class="n">ucdl_dma_addr</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ufshcd_is_valid_req_rsp - checks if controller TR response is valid</span>
<span class="cm"> * @ucd_rsp_ptr: pointer to response UPIU</span>
<span class="cm"> *</span>
<span class="cm"> * This function checks the response UPIU for valid transaction type in</span>
<span class="cm"> * response field</span>
<span class="cm"> * Returns 0 on success, non-zero on failure</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span>
<span class="nf">ufshcd_is_valid_req_rsp</span><span class="p">(</span><span class="k">struct</span> <span class="n">utp_upiu_rsp</span> <span class="o">*</span><span class="n">ucd_rsp_ptr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">((</span><span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">ucd_rsp_ptr</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">dword_0</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">24</span><span class="p">)</span> <span class="o">==</span>
		 <span class="n">UPIU_TRANSACTION_RESPONSE</span><span class="p">)</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="n">DID_ERROR</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ufshcd_get_rsp_upiu_result - Get the result from response UPIU</span>
<span class="cm"> * @ucd_rsp_ptr: pointer to response UPIU</span>
<span class="cm"> *</span>
<span class="cm"> * This function gets the response status and scsi_status from response UPIU</span>
<span class="cm"> * Returns the response result code.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span>
<span class="nf">ufshcd_get_rsp_upiu_result</span><span class="p">(</span><span class="k">struct</span> <span class="n">utp_upiu_rsp</span> <span class="o">*</span><span class="n">ucd_rsp_ptr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">ucd_rsp_ptr</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">dword_1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">MASK_RSP_UPIU_RESULT</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ufshcd_config_int_aggr - Configure interrupt aggregation values.</span>
<span class="cm"> *		Currently there is no use case where we want to configure</span>
<span class="cm"> *		interrupt aggregation dynamically. So to configure interrupt</span>
<span class="cm"> *		aggregation, #define INT_AGGR_COUNTER_THRESHOLD_VALUE and</span>
<span class="cm"> *		INT_AGGR_TIMEOUT_VALUE are used.</span>
<span class="cm"> * @hba: per adapter instance</span>
<span class="cm"> * @option: Interrupt aggregation option</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">ufshcd_config_int_aggr</span><span class="p">(</span><span class="k">struct</span> <span class="n">ufs_hba</span> <span class="o">*</span><span class="n">hba</span><span class="p">,</span> <span class="kt">int</span> <span class="n">option</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">option</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">INT_AGGR_RESET</span>:
		<span class="n">writel</span><span class="p">((</span><span class="n">INT_AGGR_ENABLE</span> <span class="o">|</span>
			<span class="n">INT_AGGR_COUNTER_AND_TIMER_RESET</span><span class="p">),</span>
			<span class="p">(</span><span class="n">hba</span><span class="o">-&gt;</span><span class="n">mmio_base</span> <span class="o">+</span>
			 <span class="n">REG_UTP_TRANSFER_REQ_INT_AGG_CONTROL</span><span class="p">));</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">INT_AGGR_CONFIG</span>:
		<span class="n">writel</span><span class="p">((</span><span class="n">INT_AGGR_ENABLE</span> <span class="o">|</span>
			<span class="n">INT_AGGR_PARAM_WRITE</span> <span class="o">|</span>
			<span class="n">INT_AGGR_COUNTER_THRESHOLD_VALUE</span> <span class="o">|</span>
			<span class="n">INT_AGGR_TIMEOUT_VALUE</span><span class="p">),</span>
			<span class="p">(</span><span class="n">hba</span><span class="o">-&gt;</span><span class="n">mmio_base</span> <span class="o">+</span>
			 <span class="n">REG_UTP_TRANSFER_REQ_INT_AGG_CONTROL</span><span class="p">));</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ufshcd_enable_run_stop_reg - Enable run-stop registers,</span>
<span class="cm"> *			When run-stop registers are set to 1, it indicates the</span>
<span class="cm"> *			host controller that it can process the requests</span>
<span class="cm"> * @hba: per adapter instance</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">ufshcd_enable_run_stop_reg</span><span class="p">(</span><span class="k">struct</span> <span class="n">ufs_hba</span> <span class="o">*</span><span class="n">hba</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">UTP_TASK_REQ_LIST_RUN_STOP_BIT</span><span class="p">,</span>
	       <span class="p">(</span><span class="n">hba</span><span class="o">-&gt;</span><span class="n">mmio_base</span> <span class="o">+</span>
		<span class="n">REG_UTP_TASK_REQ_LIST_RUN_STOP</span><span class="p">));</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">UTP_TRANSFER_REQ_LIST_RUN_STOP_BIT</span><span class="p">,</span>
	       <span class="p">(</span><span class="n">hba</span><span class="o">-&gt;</span><span class="n">mmio_base</span> <span class="o">+</span>
		<span class="n">REG_UTP_TRANSFER_REQ_LIST_RUN_STOP</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ufshcd_hba_stop - Send controller to reset state</span>
<span class="cm"> * @hba: per adapter instance</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">ufshcd_hba_stop</span><span class="p">(</span><span class="k">struct</span> <span class="n">ufs_hba</span> <span class="o">*</span><span class="n">hba</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">CONTROLLER_DISABLE</span><span class="p">,</span> <span class="p">(</span><span class="n">hba</span><span class="o">-&gt;</span><span class="n">mmio_base</span> <span class="o">+</span> <span class="n">REG_CONTROLLER_ENABLE</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ufshcd_hba_start - Start controller initialization sequence</span>
<span class="cm"> * @hba: per adapter instance</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">ufshcd_hba_start</span><span class="p">(</span><span class="k">struct</span> <span class="n">ufs_hba</span> <span class="o">*</span><span class="n">hba</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">CONTROLLER_ENABLE</span> <span class="p">,</span> <span class="p">(</span><span class="n">hba</span><span class="o">-&gt;</span><span class="n">mmio_base</span> <span class="o">+</span> <span class="n">REG_CONTROLLER_ENABLE</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ufshcd_is_hba_active - Get controller state</span>
<span class="cm"> * @hba: per adapter instance</span>
<span class="cm"> *</span>
<span class="cm"> * Returns zero if controller is active, 1 otherwise</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">ufshcd_is_hba_active</span><span class="p">(</span><span class="k">struct</span> <span class="n">ufs_hba</span> <span class="o">*</span><span class="n">hba</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">readl</span><span class="p">(</span><span class="n">hba</span><span class="o">-&gt;</span><span class="n">mmio_base</span> <span class="o">+</span> <span class="n">REG_CONTROLLER_ENABLE</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x1</span><span class="p">)</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ufshcd_send_command - Send SCSI or device management commands</span>
<span class="cm"> * @hba: per adapter instance</span>
<span class="cm"> * @task_tag: Task tag of the command</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span>
<span class="kt">void</span> <span class="nf">ufshcd_send_command</span><span class="p">(</span><span class="k">struct</span> <span class="n">ufs_hba</span> <span class="o">*</span><span class="n">hba</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">task_tag</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__set_bit</span><span class="p">(</span><span class="n">task_tag</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hba</span><span class="o">-&gt;</span><span class="n">outstanding_reqs</span><span class="p">);</span>
	<span class="n">writel</span><span class="p">((</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">task_tag</span><span class="p">),</span>
	       <span class="p">(</span><span class="n">hba</span><span class="o">-&gt;</span><span class="n">mmio_base</span> <span class="o">+</span> <span class="n">REG_UTP_TRANSFER_REQ_DOOR_BELL</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ufshcd_copy_sense_data - Copy sense data in case of check condition</span>
<span class="cm"> * @lrb - pointer to local reference block</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">ufshcd_copy_sense_data</span><span class="p">(</span><span class="k">struct</span> <span class="n">ufshcd_lrb</span> <span class="o">*</span><span class="n">lrbp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">len</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">lrbp</span><span class="o">-&gt;</span><span class="n">sense_buffer</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">len</span> <span class="o">=</span> <span class="n">be16_to_cpu</span><span class="p">(</span><span class="n">lrbp</span><span class="o">-&gt;</span><span class="n">ucd_rsp_ptr</span><span class="o">-&gt;</span><span class="n">sense_data_len</span><span class="p">);</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">lrbp</span><span class="o">-&gt;</span><span class="n">sense_buffer</span><span class="p">,</span>
			<span class="n">lrbp</span><span class="o">-&gt;</span><span class="n">ucd_rsp_ptr</span><span class="o">-&gt;</span><span class="n">sense_data</span><span class="p">,</span>
			<span class="n">min_t</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">SCSI_SENSE_BUFFERSIZE</span><span class="p">));</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ufshcd_hba_capabilities - Read controller capabilities</span>
<span class="cm"> * @hba: per adapter instance</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">ufshcd_hba_capabilities</span><span class="p">(</span><span class="k">struct</span> <span class="n">ufs_hba</span> <span class="o">*</span><span class="n">hba</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">hba</span><span class="o">-&gt;</span><span class="n">capabilities</span> <span class="o">=</span>
		<span class="n">readl</span><span class="p">(</span><span class="n">hba</span><span class="o">-&gt;</span><span class="n">mmio_base</span> <span class="o">+</span> <span class="n">REG_CONTROLLER_CAPABILITIES</span><span class="p">);</span>

	<span class="cm">/* nutrs and nutmrs are 0 based values */</span>
	<span class="n">hba</span><span class="o">-&gt;</span><span class="n">nutrs</span> <span class="o">=</span> <span class="p">(</span><span class="n">hba</span><span class="o">-&gt;</span><span class="n">capabilities</span> <span class="o">&amp;</span> <span class="n">MASK_TRANSFER_REQUESTS_SLOTS</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">hba</span><span class="o">-&gt;</span><span class="n">nutmrs</span> <span class="o">=</span>
	<span class="p">((</span><span class="n">hba</span><span class="o">-&gt;</span><span class="n">capabilities</span> <span class="o">&amp;</span> <span class="n">MASK_TASK_MANAGEMENT_REQUEST_SLOTS</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ufshcd_send_uic_command - Send UIC commands to unipro layers</span>
<span class="cm"> * @hba: per adapter instance</span>
<span class="cm"> * @uic_command: UIC command</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">ufshcd_send_uic_command</span><span class="p">(</span><span class="k">struct</span> <span class="n">ufs_hba</span> <span class="o">*</span><span class="n">hba</span><span class="p">,</span> <span class="k">struct</span> <span class="n">uic_command</span> <span class="o">*</span><span class="n">uic_cmnd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Write Args */</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">uic_cmnd</span><span class="o">-&gt;</span><span class="n">argument1</span><span class="p">,</span>
	      <span class="p">(</span><span class="n">hba</span><span class="o">-&gt;</span><span class="n">mmio_base</span> <span class="o">+</span> <span class="n">REG_UIC_COMMAND_ARG_1</span><span class="p">));</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">uic_cmnd</span><span class="o">-&gt;</span><span class="n">argument2</span><span class="p">,</span>
	      <span class="p">(</span><span class="n">hba</span><span class="o">-&gt;</span><span class="n">mmio_base</span> <span class="o">+</span> <span class="n">REG_UIC_COMMAND_ARG_2</span><span class="p">));</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">uic_cmnd</span><span class="o">-&gt;</span><span class="n">argument3</span><span class="p">,</span>
	      <span class="p">(</span><span class="n">hba</span><span class="o">-&gt;</span><span class="n">mmio_base</span> <span class="o">+</span> <span class="n">REG_UIC_COMMAND_ARG_3</span><span class="p">));</span>

	<span class="cm">/* Write UIC Cmd */</span>
	<span class="n">writel</span><span class="p">((</span><span class="n">uic_cmnd</span><span class="o">-&gt;</span><span class="n">command</span> <span class="o">&amp;</span> <span class="n">COMMAND_OPCODE_MASK</span><span class="p">),</span>
	       <span class="p">(</span><span class="n">hba</span><span class="o">-&gt;</span><span class="n">mmio_base</span> <span class="o">+</span> <span class="n">REG_UIC_COMMAND</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ufshcd_map_sg - Map scatter-gather list to prdt</span>
<span class="cm"> * @lrbp - pointer to local reference block</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 0 in case of success, non-zero value in case of failure</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">ufshcd_map_sg</span><span class="p">(</span><span class="k">struct</span> <span class="n">ufshcd_lrb</span> <span class="o">*</span><span class="n">lrbp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ufshcd_sg_entry</span> <span class="o">*</span><span class="n">prd_table</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">scatterlist</span> <span class="o">*</span><span class="n">sg</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">sg_segments</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">cmd</span> <span class="o">=</span> <span class="n">lrbp</span><span class="o">-&gt;</span><span class="n">cmd</span><span class="p">;</span>
	<span class="n">sg_segments</span> <span class="o">=</span> <span class="n">scsi_dma_map</span><span class="p">(</span><span class="n">cmd</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sg_segments</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">sg_segments</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sg_segments</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lrbp</span><span class="o">-&gt;</span><span class="n">utr_descriptor_ptr</span><span class="o">-&gt;</span><span class="n">prd_table_length</span> <span class="o">=</span>
					<span class="n">cpu_to_le16</span><span class="p">((</span><span class="n">u16</span><span class="p">)</span> <span class="p">(</span><span class="n">sg_segments</span><span class="p">));</span>

		<span class="n">prd_table</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ufshcd_sg_entry</span> <span class="o">*</span><span class="p">)</span><span class="n">lrbp</span><span class="o">-&gt;</span><span class="n">ucd_prdt_ptr</span><span class="p">;</span>

		<span class="n">scsi_for_each_sg</span><span class="p">(</span><span class="n">cmd</span><span class="p">,</span> <span class="n">sg</span><span class="p">,</span> <span class="n">sg_segments</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">prd_table</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">size</span>  <span class="o">=</span>
				<span class="n">cpu_to_le32</span><span class="p">(((</span><span class="n">u32</span><span class="p">)</span> <span class="n">sg_dma_len</span><span class="p">(</span><span class="n">sg</span><span class="p">))</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
			<span class="n">prd_table</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">base_addr</span> <span class="o">=</span>
				<span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">lower_32_bits</span><span class="p">(</span><span class="n">sg</span><span class="o">-&gt;</span><span class="n">dma_address</span><span class="p">));</span>
			<span class="n">prd_table</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">upper_addr</span> <span class="o">=</span>
				<span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">upper_32_bits</span><span class="p">(</span><span class="n">sg</span><span class="o">-&gt;</span><span class="n">dma_address</span><span class="p">));</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">lrbp</span><span class="o">-&gt;</span><span class="n">utr_descriptor_ptr</span><span class="o">-&gt;</span><span class="n">prd_table_length</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ufshcd_int_config - enable/disable interrupts</span>
<span class="cm"> * @hba: per adapter instance</span>
<span class="cm"> * @option: interrupt option</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">ufshcd_int_config</span><span class="p">(</span><span class="k">struct</span> <span class="n">ufs_hba</span> <span class="o">*</span><span class="n">hba</span><span class="p">,</span> <span class="n">u32</span> <span class="n">option</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">option</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">UFSHCD_INT_ENABLE</span>:
		<span class="n">writel</span><span class="p">(</span><span class="n">hba</span><span class="o">-&gt;</span><span class="n">int_enable_mask</span><span class="p">,</span>
		      <span class="p">(</span><span class="n">hba</span><span class="o">-&gt;</span><span class="n">mmio_base</span> <span class="o">+</span> <span class="n">REG_INTERRUPT_ENABLE</span><span class="p">));</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">UFSHCD_INT_DISABLE</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">hba</span><span class="o">-&gt;</span><span class="n">ufs_version</span> <span class="o">==</span> <span class="n">UFSHCI_VERSION_10</span><span class="p">)</span>
			<span class="n">writel</span><span class="p">(</span><span class="n">INTERRUPT_DISABLE_MASK_10</span><span class="p">,</span>
			      <span class="p">(</span><span class="n">hba</span><span class="o">-&gt;</span><span class="n">mmio_base</span> <span class="o">+</span> <span class="n">REG_INTERRUPT_ENABLE</span><span class="p">));</span>
		<span class="k">else</span>
			<span class="n">writel</span><span class="p">(</span><span class="n">INTERRUPT_DISABLE_MASK_11</span><span class="p">,</span>
			       <span class="p">(</span><span class="n">hba</span><span class="o">-&gt;</span><span class="n">mmio_base</span> <span class="o">+</span> <span class="n">REG_INTERRUPT_ENABLE</span><span class="p">));</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ufshcd_compose_upiu - form UFS Protocol Information Unit(UPIU)</span>
<span class="cm"> * @lrb - pointer to local reference block</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">ufshcd_compose_upiu</span><span class="p">(</span><span class="k">struct</span> <span class="n">ufshcd_lrb</span> <span class="o">*</span><span class="n">lrbp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">utp_transfer_req_desc</span> <span class="o">*</span><span class="n">req_desc</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">utp_upiu_cmd</span> <span class="o">*</span><span class="n">ucd_cmd_ptr</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">data_direction</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">upiu_flags</span><span class="p">;</span>

	<span class="n">ucd_cmd_ptr</span> <span class="o">=</span> <span class="n">lrbp</span><span class="o">-&gt;</span><span class="n">ucd_cmd_ptr</span><span class="p">;</span>
	<span class="n">req_desc</span> <span class="o">=</span> <span class="n">lrbp</span><span class="o">-&gt;</span><span class="n">utr_descriptor_ptr</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">lrbp</span><span class="o">-&gt;</span><span class="n">command_type</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">UTP_CMD_TYPE_SCSI</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">lrbp</span><span class="o">-&gt;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">sc_data_direction</span> <span class="o">==</span> <span class="n">DMA_FROM_DEVICE</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">data_direction</span> <span class="o">=</span> <span class="n">UTP_DEVICE_TO_HOST</span><span class="p">;</span>
			<span class="n">upiu_flags</span> <span class="o">=</span> <span class="n">UPIU_CMD_FLAGS_READ</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">lrbp</span><span class="o">-&gt;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">sc_data_direction</span> <span class="o">==</span> <span class="n">DMA_TO_DEVICE</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">data_direction</span> <span class="o">=</span> <span class="n">UTP_HOST_TO_DEVICE</span><span class="p">;</span>
			<span class="n">upiu_flags</span> <span class="o">=</span> <span class="n">UPIU_CMD_FLAGS_WRITE</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">data_direction</span> <span class="o">=</span> <span class="n">UTP_NO_DATA_TRANSFER</span><span class="p">;</span>
			<span class="n">upiu_flags</span> <span class="o">=</span> <span class="n">UPIU_CMD_FLAGS_NONE</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* Transfer request descriptor header fields */</span>
		<span class="n">req_desc</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">dword_0</span> <span class="o">=</span>
			<span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">data_direction</span> <span class="o">|</span> <span class="n">UTP_SCSI_COMMAND</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * assigning invalid value for command status. Controller</span>
<span class="cm">		 * updates OCS on command completion, with the command</span>
<span class="cm">		 * status</span>
<span class="cm">		 */</span>
		<span class="n">req_desc</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">dword_2</span> <span class="o">=</span>
			<span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">OCS_INVALID_COMMAND_STATUS</span><span class="p">);</span>

		<span class="cm">/* command descriptor fields */</span>
		<span class="n">ucd_cmd_ptr</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">dword_0</span> <span class="o">=</span>
			<span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">UPIU_HEADER_DWORD</span><span class="p">(</span><span class="n">UPIU_TRANSACTION_COMMAND</span><span class="p">,</span>
						      <span class="n">upiu_flags</span><span class="p">,</span>
						      <span class="n">lrbp</span><span class="o">-&gt;</span><span class="n">lun</span><span class="p">,</span>
						      <span class="n">lrbp</span><span class="o">-&gt;</span><span class="n">task_tag</span><span class="p">));</span>
		<span class="n">ucd_cmd_ptr</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">dword_1</span> <span class="o">=</span>
			<span class="n">cpu_to_be32</span><span class="p">(</span>
				<span class="n">UPIU_HEADER_DWORD</span><span class="p">(</span><span class="n">UPIU_COMMAND_SET_TYPE_SCSI</span><span class="p">,</span>
						  <span class="mi">0</span><span class="p">,</span>
						  <span class="mi">0</span><span class="p">,</span>
						  <span class="mi">0</span><span class="p">));</span>

		<span class="cm">/* Total EHS length and Data segment length will be zero */</span>
		<span class="n">ucd_cmd_ptr</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">dword_2</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="n">ucd_cmd_ptr</span><span class="o">-&gt;</span><span class="n">exp_data_transfer_len</span> <span class="o">=</span>
			<span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">lrbp</span><span class="o">-&gt;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">transfersize</span><span class="p">);</span>

		<span class="n">memcpy</span><span class="p">(</span><span class="n">ucd_cmd_ptr</span><span class="o">-&gt;</span><span class="n">cdb</span><span class="p">,</span>
		       <span class="n">lrbp</span><span class="o">-&gt;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">,</span>
		       <span class="p">(</span><span class="n">min_t</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">short</span><span class="p">,</span>
			      <span class="n">lrbp</span><span class="o">-&gt;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">cmd_len</span><span class="p">,</span>
			      <span class="n">MAX_CDB_SIZE</span><span class="p">)));</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">UTP_CMD_TYPE_DEV_MANAGE</span>:
		<span class="cm">/* For query function implementation */</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">UTP_CMD_TYPE_UFS</span>:
		<span class="cm">/* For UFS native command implementation */</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span> <span class="cm">/* end of switch */</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ufshcd_queuecommand - main entry point for SCSI requests</span>
<span class="cm"> * @cmd: command from SCSI Midlayer</span>
<span class="cm"> * @done: call back function</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 0 for success, non-zero in case of failure</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">ufshcd_queuecommand</span><span class="p">(</span><span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">host</span><span class="p">,</span> <span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ufshcd_lrb</span> <span class="o">*</span><span class="n">lrbp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ufs_hba</span> <span class="o">*</span><span class="n">hba</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">tag</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">hba</span> <span class="o">=</span> <span class="n">shost_priv</span><span class="p">(</span><span class="n">host</span><span class="p">);</span>

	<span class="n">tag</span> <span class="o">=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">request</span><span class="o">-&gt;</span><span class="n">tag</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">hba</span><span class="o">-&gt;</span><span class="n">ufshcd_state</span> <span class="o">!=</span> <span class="n">UFSHCD_STATE_OPERATIONAL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">SCSI_MLQUEUE_HOST_BUSY</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">lrbp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">hba</span><span class="o">-&gt;</span><span class="n">lrb</span><span class="p">[</span><span class="n">tag</span><span class="p">];</span>

	<span class="n">lrbp</span><span class="o">-&gt;</span><span class="n">cmd</span> <span class="o">=</span> <span class="n">cmd</span><span class="p">;</span>
	<span class="n">lrbp</span><span class="o">-&gt;</span><span class="n">sense_bufflen</span> <span class="o">=</span> <span class="n">SCSI_SENSE_BUFFERSIZE</span><span class="p">;</span>
	<span class="n">lrbp</span><span class="o">-&gt;</span><span class="n">sense_buffer</span> <span class="o">=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">sense_buffer</span><span class="p">;</span>
	<span class="n">lrbp</span><span class="o">-&gt;</span><span class="n">task_tag</span> <span class="o">=</span> <span class="n">tag</span><span class="p">;</span>
	<span class="n">lrbp</span><span class="o">-&gt;</span><span class="n">lun</span> <span class="o">=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">lun</span><span class="p">;</span>

	<span class="n">lrbp</span><span class="o">-&gt;</span><span class="n">command_type</span> <span class="o">=</span> <span class="n">UTP_CMD_TYPE_SCSI</span><span class="p">;</span>

	<span class="cm">/* form UPIU before issuing the command */</span>
	<span class="n">ufshcd_compose_upiu</span><span class="p">(</span><span class="n">lrbp</span><span class="p">);</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">ufshcd_map_sg</span><span class="p">(</span><span class="n">lrbp</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="cm">/* issue command to the controller */</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="n">hba</span><span class="o">-&gt;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">ufshcd_send_command</span><span class="p">(</span><span class="n">hba</span><span class="p">,</span> <span class="n">tag</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="n">hba</span><span class="o">-&gt;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ufshcd_memory_alloc - allocate memory for host memory space data structures</span>
<span class="cm"> * @hba: per adapter instance</span>
<span class="cm"> *</span>
<span class="cm"> * 1. Allocate DMA memory for Command Descriptor array</span>
<span class="cm"> *	Each command descriptor consist of Command UPIU, Response UPIU and PRDT</span>
<span class="cm"> * 2. Allocate DMA memory for UTP Transfer Request Descriptor List (UTRDL).</span>
<span class="cm"> * 3. Allocate DMA memory for UTP Task Management Request Descriptor List</span>
<span class="cm"> *	(UTMRDL)</span>
<span class="cm"> * 4. Allocate memory for local reference block(lrb).</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 0 for success, non-zero in case of failure</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">ufshcd_memory_alloc</span><span class="p">(</span><span class="k">struct</span> <span class="n">ufs_hba</span> <span class="o">*</span><span class="n">hba</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">size_t</span> <span class="n">utmrdl_size</span><span class="p">,</span> <span class="n">utrdl_size</span><span class="p">,</span> <span class="n">ucdl_size</span><span class="p">;</span>

	<span class="cm">/* Allocate memory for UTP command descriptors */</span>
	<span class="n">ucdl_size</span> <span class="o">=</span> <span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">utp_transfer_cmd_desc</span><span class="p">)</span> <span class="o">*</span> <span class="n">hba</span><span class="o">-&gt;</span><span class="n">nutrs</span><span class="p">);</span>
	<span class="n">hba</span><span class="o">-&gt;</span><span class="n">ucdl_base_addr</span> <span class="o">=</span> <span class="n">dma_alloc_coherent</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hba</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
						 <span class="n">ucdl_size</span><span class="p">,</span>
						 <span class="o">&amp;</span><span class="n">hba</span><span class="o">-&gt;</span><span class="n">ucdl_dma_addr</span><span class="p">,</span>
						 <span class="n">GFP_KERNEL</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * UFSHCI requires UTP command descriptor to be 128 byte aligned.</span>
<span class="cm">	 * make sure hba-&gt;ucdl_dma_addr is aligned to PAGE_SIZE</span>
<span class="cm">	 * if hba-&gt;ucdl_dma_addr is aligned to PAGE_SIZE, then it will</span>
<span class="cm">	 * be aligned to 128 bytes as well</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hba</span><span class="o">-&gt;</span><span class="n">ucdl_base_addr</span> <span class="o">||</span>
	    <span class="n">WARN_ON</span><span class="p">(</span><span class="n">hba</span><span class="o">-&gt;</span><span class="n">ucdl_dma_addr</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">PAGE_SIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hba</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			<span class="s">&quot;Command Descriptor Memory allocation failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Allocate memory for UTP Transfer descriptors</span>
<span class="cm">	 * UFSHCI requires 1024 byte alignment of UTRD</span>
<span class="cm">	 */</span>
	<span class="n">utrdl_size</span> <span class="o">=</span> <span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">utp_transfer_req_desc</span><span class="p">)</span> <span class="o">*</span> <span class="n">hba</span><span class="o">-&gt;</span><span class="n">nutrs</span><span class="p">);</span>
	<span class="n">hba</span><span class="o">-&gt;</span><span class="n">utrdl_base_addr</span> <span class="o">=</span> <span class="n">dma_alloc_coherent</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hba</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
						  <span class="n">utrdl_size</span><span class="p">,</span>
						  <span class="o">&amp;</span><span class="n">hba</span><span class="o">-&gt;</span><span class="n">utrdl_dma_addr</span><span class="p">,</span>
						  <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hba</span><span class="o">-&gt;</span><span class="n">utrdl_base_addr</span> <span class="o">||</span>
	    <span class="n">WARN_ON</span><span class="p">(</span><span class="n">hba</span><span class="o">-&gt;</span><span class="n">utrdl_dma_addr</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">PAGE_SIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hba</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			<span class="s">&quot;Transfer Descriptor Memory allocation failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Allocate memory for UTP Task Management descriptors</span>
<span class="cm">	 * UFSHCI requires 1024 byte alignment of UTMRD</span>
<span class="cm">	 */</span>
	<span class="n">utmrdl_size</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">utp_task_req_desc</span><span class="p">)</span> <span class="o">*</span> <span class="n">hba</span><span class="o">-&gt;</span><span class="n">nutmrs</span><span class="p">;</span>
	<span class="n">hba</span><span class="o">-&gt;</span><span class="n">utmrdl_base_addr</span> <span class="o">=</span> <span class="n">dma_alloc_coherent</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hba</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
						   <span class="n">utmrdl_size</span><span class="p">,</span>
						   <span class="o">&amp;</span><span class="n">hba</span><span class="o">-&gt;</span><span class="n">utmrdl_dma_addr</span><span class="p">,</span>
						   <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hba</span><span class="o">-&gt;</span><span class="n">utmrdl_base_addr</span> <span class="o">||</span>
	    <span class="n">WARN_ON</span><span class="p">(</span><span class="n">hba</span><span class="o">-&gt;</span><span class="n">utmrdl_dma_addr</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">PAGE_SIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hba</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
		<span class="s">&quot;Task Management Descriptor Memory allocation failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Allocate memory for local reference block */</span>
	<span class="n">hba</span><span class="o">-&gt;</span><span class="n">lrb</span> <span class="o">=</span> <span class="n">kcalloc</span><span class="p">(</span><span class="n">hba</span><span class="o">-&gt;</span><span class="n">nutrs</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ufshcd_lrb</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hba</span><span class="o">-&gt;</span><span class="n">lrb</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hba</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;LRB Memory allocation failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">out:</span>
	<span class="n">ufshcd_free_hba_memory</span><span class="p">(</span><span class="n">hba</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ufshcd_host_memory_configure - configure local reference block with</span>
<span class="cm"> *				memory offsets</span>
<span class="cm"> * @hba: per adapter instance</span>
<span class="cm"> *</span>
<span class="cm"> * Configure Host memory space</span>
<span class="cm"> * 1. Update Corresponding UTRD.UCDBA and UTRD.UCDBAU with UCD DMA</span>
<span class="cm"> * address.</span>
<span class="cm"> * 2. Update each UTRD with Response UPIU offset, Response UPIU length</span>
<span class="cm"> * and PRDT offset.</span>
<span class="cm"> * 3. Save the corresponding addresses of UTRD, UCD.CMD, UCD.RSP and UCD.PRDT</span>
<span class="cm"> * into local reference block.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">ufshcd_host_memory_configure</span><span class="p">(</span><span class="k">struct</span> <span class="n">ufs_hba</span> <span class="o">*</span><span class="n">hba</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">utp_transfer_cmd_desc</span> <span class="o">*</span><span class="n">cmd_descp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">utp_transfer_req_desc</span> <span class="o">*</span><span class="n">utrdlp</span><span class="p">;</span>
	<span class="n">dma_addr_t</span> <span class="n">cmd_desc_dma_addr</span><span class="p">;</span>
	<span class="n">dma_addr_t</span> <span class="n">cmd_desc_element_addr</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">response_offset</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">prdt_offset</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">cmd_desc_size</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">utrdlp</span> <span class="o">=</span> <span class="n">hba</span><span class="o">-&gt;</span><span class="n">utrdl_base_addr</span><span class="p">;</span>
	<span class="n">cmd_descp</span> <span class="o">=</span> <span class="n">hba</span><span class="o">-&gt;</span><span class="n">ucdl_base_addr</span><span class="p">;</span>

	<span class="n">response_offset</span> <span class="o">=</span>
		<span class="n">offsetof</span><span class="p">(</span><span class="k">struct</span> <span class="n">utp_transfer_cmd_desc</span><span class="p">,</span> <span class="n">response_upiu</span><span class="p">);</span>
	<span class="n">prdt_offset</span> <span class="o">=</span>
		<span class="n">offsetof</span><span class="p">(</span><span class="k">struct</span> <span class="n">utp_transfer_cmd_desc</span><span class="p">,</span> <span class="n">prd_table</span><span class="p">);</span>

	<span class="n">cmd_desc_size</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">utp_transfer_cmd_desc</span><span class="p">);</span>
	<span class="n">cmd_desc_dma_addr</span> <span class="o">=</span> <span class="n">hba</span><span class="o">-&gt;</span><span class="n">ucdl_dma_addr</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">hba</span><span class="o">-&gt;</span><span class="n">nutrs</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Configure UTRD with command descriptor base address */</span>
		<span class="n">cmd_desc_element_addr</span> <span class="o">=</span>
				<span class="p">(</span><span class="n">cmd_desc_dma_addr</span> <span class="o">+</span> <span class="p">(</span><span class="n">cmd_desc_size</span> <span class="o">*</span> <span class="n">i</span><span class="p">));</span>
		<span class="n">utrdlp</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">command_desc_base_addr_lo</span> <span class="o">=</span>
				<span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">lower_32_bits</span><span class="p">(</span><span class="n">cmd_desc_element_addr</span><span class="p">));</span>
		<span class="n">utrdlp</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">command_desc_base_addr_hi</span> <span class="o">=</span>
				<span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">upper_32_bits</span><span class="p">(</span><span class="n">cmd_desc_element_addr</span><span class="p">));</span>

		<span class="cm">/* Response upiu and prdt offset should be in double words */</span>
		<span class="n">utrdlp</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">response_upiu_offset</span> <span class="o">=</span>
				<span class="n">cpu_to_le16</span><span class="p">((</span><span class="n">response_offset</span> <span class="o">&gt;&gt;</span> <span class="mi">2</span><span class="p">));</span>
		<span class="n">utrdlp</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">prd_table_offset</span> <span class="o">=</span>
				<span class="n">cpu_to_le16</span><span class="p">((</span><span class="n">prdt_offset</span> <span class="o">&gt;&gt;</span> <span class="mi">2</span><span class="p">));</span>
		<span class="n">utrdlp</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">response_upiu_length</span> <span class="o">=</span>
				<span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">ALIGNED_UPIU_SIZE</span><span class="p">);</span>

		<span class="n">hba</span><span class="o">-&gt;</span><span class="n">lrb</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">utr_descriptor_ptr</span> <span class="o">=</span> <span class="p">(</span><span class="n">utrdlp</span> <span class="o">+</span> <span class="n">i</span><span class="p">);</span>
		<span class="n">hba</span><span class="o">-&gt;</span><span class="n">lrb</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">ucd_cmd_ptr</span> <span class="o">=</span>
			<span class="p">(</span><span class="k">struct</span> <span class="n">utp_upiu_cmd</span> <span class="o">*</span><span class="p">)(</span><span class="n">cmd_descp</span> <span class="o">+</span> <span class="n">i</span><span class="p">);</span>
		<span class="n">hba</span><span class="o">-&gt;</span><span class="n">lrb</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">ucd_rsp_ptr</span> <span class="o">=</span>
			<span class="p">(</span><span class="k">struct</span> <span class="n">utp_upiu_rsp</span> <span class="o">*</span><span class="p">)</span><span class="n">cmd_descp</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">response_upiu</span><span class="p">;</span>
		<span class="n">hba</span><span class="o">-&gt;</span><span class="n">lrb</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">ucd_prdt_ptr</span> <span class="o">=</span>
			<span class="p">(</span><span class="k">struct</span> <span class="n">ufshcd_sg_entry</span> <span class="o">*</span><span class="p">)</span><span class="n">cmd_descp</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">prd_table</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ufshcd_dme_link_startup - Notify Unipro to perform link startup</span>
<span class="cm"> * @hba: per adapter instance</span>
<span class="cm"> *</span>
<span class="cm"> * UIC_CMD_DME_LINK_STARTUP command must be issued to Unipro layer,</span>
<span class="cm"> * in order to initialize the Unipro link startup procedure.</span>
<span class="cm"> * Once the Unipro links are up, the device connected to the controller</span>
<span class="cm"> * is detected.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 0 on success, non-zero value on failure</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">ufshcd_dme_link_startup</span><span class="p">(</span><span class="k">struct</span> <span class="n">ufs_hba</span> <span class="o">*</span><span class="n">hba</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">uic_command</span> <span class="o">*</span><span class="n">uic_cmd</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="cm">/* check if controller is ready to accept UIC commands */</span>
	<span class="k">if</span> <span class="p">(((</span><span class="n">readl</span><span class="p">(</span><span class="n">hba</span><span class="o">-&gt;</span><span class="n">mmio_base</span> <span class="o">+</span> <span class="n">REG_CONTROLLER_STATUS</span><span class="p">))</span> <span class="o">&amp;</span>
	    <span class="n">UIC_COMMAND_READY</span><span class="p">)</span> <span class="o">==</span> <span class="mh">0x0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hba</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			<span class="s">&quot;Controller not ready&quot;</span>
			<span class="s">&quot; to accept UIC commands</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="n">hba</span><span class="o">-&gt;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="cm">/* form UIC command */</span>
	<span class="n">uic_cmd</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">hba</span><span class="o">-&gt;</span><span class="n">active_uic_cmd</span><span class="p">;</span>
	<span class="n">uic_cmd</span><span class="o">-&gt;</span><span class="n">command</span> <span class="o">=</span> <span class="n">UIC_CMD_DME_LINK_STARTUP</span><span class="p">;</span>
	<span class="n">uic_cmd</span><span class="o">-&gt;</span><span class="n">argument1</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">uic_cmd</span><span class="o">-&gt;</span><span class="n">argument2</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">uic_cmd</span><span class="o">-&gt;</span><span class="n">argument3</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* enable UIC related interrupts */</span>
	<span class="n">hba</span><span class="o">-&gt;</span><span class="n">int_enable_mask</span> <span class="o">|=</span> <span class="n">UIC_COMMAND_COMPL</span><span class="p">;</span>
	<span class="n">ufshcd_int_config</span><span class="p">(</span><span class="n">hba</span><span class="p">,</span> <span class="n">UFSHCD_INT_ENABLE</span><span class="p">);</span>

	<span class="cm">/* sending UIC commands to controller */</span>
	<span class="n">ufshcd_send_uic_command</span><span class="p">(</span><span class="n">hba</span><span class="p">,</span> <span class="n">uic_cmd</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="n">hba</span><span class="o">-&gt;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ufshcd_make_hba_operational - Make UFS controller operational</span>
<span class="cm"> * @hba: per adapter instance</span>
<span class="cm"> *</span>
<span class="cm"> * To bring UFS host controller to operational state,</span>
<span class="cm"> * 1. Check if device is present</span>
<span class="cm"> * 2. Configure run-stop-registers</span>
<span class="cm"> * 3. Enable required interrupts</span>
<span class="cm"> * 4. Configure interrupt aggregation</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 0 on success, non-zero value on failure</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">ufshcd_make_hba_operational</span><span class="p">(</span><span class="k">struct</span> <span class="n">ufs_hba</span> <span class="o">*</span><span class="n">hba</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">reg</span><span class="p">;</span>

	<span class="cm">/* check if device present */</span>
	<span class="n">reg</span> <span class="o">=</span> <span class="n">readl</span><span class="p">((</span><span class="n">hba</span><span class="o">-&gt;</span><span class="n">mmio_base</span> <span class="o">+</span> <span class="n">REG_CONTROLLER_STATUS</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ufshcd_is_device_present</span><span class="p">(</span><span class="n">reg</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hba</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;cc: Device not present</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENXIO</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * UCRDY, UTMRLDY and UTRLRDY bits must be 1</span>
<span class="cm">	 * DEI, HEI bits must be 0</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">ufshcd_get_lists_status</span><span class="p">(</span><span class="n">reg</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">ufshcd_enable_run_stop_reg</span><span class="p">(</span><span class="n">hba</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hba</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			<span class="s">&quot;Host controller not ready to process requests&quot;</span><span class="p">);</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Enable required interrupts */</span>
	<span class="n">hba</span><span class="o">-&gt;</span><span class="n">int_enable_mask</span> <span class="o">|=</span> <span class="p">(</span><span class="n">UTP_TRANSFER_REQ_COMPL</span> <span class="o">|</span>
				 <span class="n">UIC_ERROR</span> <span class="o">|</span>
				 <span class="n">UTP_TASK_REQ_COMPL</span> <span class="o">|</span>
				 <span class="n">DEVICE_FATAL_ERROR</span> <span class="o">|</span>
				 <span class="n">CONTROLLER_FATAL_ERROR</span> <span class="o">|</span>
				 <span class="n">SYSTEM_BUS_FATAL_ERROR</span><span class="p">);</span>
	<span class="n">ufshcd_int_config</span><span class="p">(</span><span class="n">hba</span><span class="p">,</span> <span class="n">UFSHCD_INT_ENABLE</span><span class="p">);</span>

	<span class="cm">/* Configure interrupt aggregation */</span>
	<span class="n">ufshcd_config_int_aggr</span><span class="p">(</span><span class="n">hba</span><span class="p">,</span> <span class="n">INT_AGGR_CONFIG</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">hba</span><span class="o">-&gt;</span><span class="n">ufshcd_state</span> <span class="o">==</span> <span class="n">UFSHCD_STATE_RESET</span><span class="p">)</span>
		<span class="n">scsi_unblock_requests</span><span class="p">(</span><span class="n">hba</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">);</span>

	<span class="n">hba</span><span class="o">-&gt;</span><span class="n">ufshcd_state</span> <span class="o">=</span> <span class="n">UFSHCD_STATE_OPERATIONAL</span><span class="p">;</span>
	<span class="n">scsi_scan_host</span><span class="p">(</span><span class="n">hba</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ufshcd_hba_enable - initialize the controller</span>
<span class="cm"> * @hba: per adapter instance</span>
<span class="cm"> *</span>
<span class="cm"> * The controller resets itself and controller firmware initialization</span>
<span class="cm"> * sequence kicks off. When controller is ready it will set</span>
<span class="cm"> * the Host Controller Enable bit to 1.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 0 on success, non-zero value on failure</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">ufshcd_hba_enable</span><span class="p">(</span><span class="k">struct</span> <span class="n">ufs_hba</span> <span class="o">*</span><span class="n">hba</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">retry</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * msleep of 1 and 5 used in this function might result in msleep(20),</span>
<span class="cm">	 * but it was necessary to send the UFS FPGA to reset mode during</span>
<span class="cm">	 * development and testing of this driver. msleep can be changed to</span>
<span class="cm">	 * mdelay and retry count can be reduced based on the controller.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ufshcd_is_hba_active</span><span class="p">(</span><span class="n">hba</span><span class="p">))</span> <span class="p">{</span>

		<span class="cm">/* change controller state to &quot;reset state&quot; */</span>
		<span class="n">ufshcd_hba_stop</span><span class="p">(</span><span class="n">hba</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * This delay is based on the testing done with UFS host</span>
<span class="cm">		 * controller FPGA. The delay can be changed based on the</span>
<span class="cm">		 * host controller used.</span>
<span class="cm">		 */</span>
		<span class="n">msleep</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* start controller initialization sequence */</span>
	<span class="n">ufshcd_hba_start</span><span class="p">(</span><span class="n">hba</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * To initialize a UFS host controller HCE bit must be set to 1.</span>
<span class="cm">	 * During initialization the HCE bit value changes from 1-&gt;0-&gt;1.</span>
<span class="cm">	 * When the host controller completes initialization sequence</span>
<span class="cm">	 * it sets the value of HCE bit to 1. The same HCE bit is read back</span>
<span class="cm">	 * to check if the controller has completed initialization sequence.</span>
<span class="cm">	 * So without this delay the value HCE = 1, set in the previous</span>
<span class="cm">	 * instruction might be read back.</span>
<span class="cm">	 * This delay can be changed based on the controller.</span>
<span class="cm">	 */</span>
	<span class="n">msleep</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>

	<span class="cm">/* wait for the host controller to complete initialization */</span>
	<span class="n">retry</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">ufshcd_is_hba_active</span><span class="p">(</span><span class="n">hba</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">retry</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">retry</span><span class="o">--</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hba</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
				<span class="s">&quot;Controller enable failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">msleep</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ufshcd_initialize_hba - start the initialization process</span>
<span class="cm"> * @hba: per adapter instance</span>
<span class="cm"> *</span>
<span class="cm"> * 1. Enable the controller via ufshcd_hba_enable.</span>
<span class="cm"> * 2. Program the Transfer Request List Address with the starting address of</span>
<span class="cm"> * UTRDL.</span>
<span class="cm"> * 3. Program the Task Management Request List Address with starting address</span>
<span class="cm"> * of UTMRDL.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 0 on success, non-zero value on failure.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">ufshcd_initialize_hba</span><span class="p">(</span><span class="k">struct</span> <span class="n">ufs_hba</span> <span class="o">*</span><span class="n">hba</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ufshcd_hba_enable</span><span class="p">(</span><span class="n">hba</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>

	<span class="cm">/* Configure UTRL and UTMRL base address registers */</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">lower_32_bits</span><span class="p">(</span><span class="n">hba</span><span class="o">-&gt;</span><span class="n">utrdl_dma_addr</span><span class="p">),</span>
	       <span class="p">(</span><span class="n">hba</span><span class="o">-&gt;</span><span class="n">mmio_base</span> <span class="o">+</span> <span class="n">REG_UTP_TRANSFER_REQ_LIST_BASE_L</span><span class="p">));</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">upper_32_bits</span><span class="p">(</span><span class="n">hba</span><span class="o">-&gt;</span><span class="n">utrdl_dma_addr</span><span class="p">),</span>
	       <span class="p">(</span><span class="n">hba</span><span class="o">-&gt;</span><span class="n">mmio_base</span> <span class="o">+</span> <span class="n">REG_UTP_TRANSFER_REQ_LIST_BASE_H</span><span class="p">));</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">lower_32_bits</span><span class="p">(</span><span class="n">hba</span><span class="o">-&gt;</span><span class="n">utmrdl_dma_addr</span><span class="p">),</span>
	       <span class="p">(</span><span class="n">hba</span><span class="o">-&gt;</span><span class="n">mmio_base</span> <span class="o">+</span> <span class="n">REG_UTP_TASK_REQ_LIST_BASE_L</span><span class="p">));</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">upper_32_bits</span><span class="p">(</span><span class="n">hba</span><span class="o">-&gt;</span><span class="n">utmrdl_dma_addr</span><span class="p">),</span>
	       <span class="p">(</span><span class="n">hba</span><span class="o">-&gt;</span><span class="n">mmio_base</span> <span class="o">+</span> <span class="n">REG_UTP_TASK_REQ_LIST_BASE_H</span><span class="p">));</span>

	<span class="cm">/* Initialize unipro link startup procedure */</span>
	<span class="k">return</span> <span class="n">ufshcd_dme_link_startup</span><span class="p">(</span><span class="n">hba</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ufshcd_do_reset - reset the host controller</span>
<span class="cm"> * @hba: per adapter instance</span>
<span class="cm"> *</span>
<span class="cm"> * Returns SUCCESS/FAILED</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">ufshcd_do_reset</span><span class="p">(</span><span class="k">struct</span> <span class="n">ufs_hba</span> <span class="o">*</span><span class="n">hba</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ufshcd_lrb</span> <span class="o">*</span><span class="n">lrbp</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">tag</span><span class="p">;</span>

	<span class="cm">/* block commands from midlayer */</span>
	<span class="n">scsi_block_requests</span><span class="p">(</span><span class="n">hba</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">);</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="n">hba</span><span class="o">-&gt;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">hba</span><span class="o">-&gt;</span><span class="n">ufshcd_state</span> <span class="o">=</span> <span class="n">UFSHCD_STATE_RESET</span><span class="p">;</span>

	<span class="cm">/* send controller to reset state */</span>
	<span class="n">ufshcd_hba_stop</span><span class="p">(</span><span class="n">hba</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="n">hba</span><span class="o">-&gt;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="cm">/* abort outstanding commands */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">tag</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">tag</span> <span class="o">&lt;</span> <span class="n">hba</span><span class="o">-&gt;</span><span class="n">nutrs</span><span class="p">;</span> <span class="n">tag</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">tag</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hba</span><span class="o">-&gt;</span><span class="n">outstanding_reqs</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">lrbp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">hba</span><span class="o">-&gt;</span><span class="n">lrb</span><span class="p">[</span><span class="n">tag</span><span class="p">];</span>
			<span class="n">scsi_dma_unmap</span><span class="p">(</span><span class="n">lrbp</span><span class="o">-&gt;</span><span class="n">cmd</span><span class="p">);</span>
			<span class="n">lrbp</span><span class="o">-&gt;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">=</span> <span class="n">DID_RESET</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">;</span>
			<span class="n">lrbp</span><span class="o">-&gt;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scsi_done</span><span class="p">(</span><span class="n">lrbp</span><span class="o">-&gt;</span><span class="n">cmd</span><span class="p">);</span>
			<span class="n">lrbp</span><span class="o">-&gt;</span><span class="n">cmd</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* clear outstanding request/task bit maps */</span>
	<span class="n">hba</span><span class="o">-&gt;</span><span class="n">outstanding_reqs</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">hba</span><span class="o">-&gt;</span><span class="n">outstanding_tasks</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* start the initialization process */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ufshcd_initialize_hba</span><span class="p">(</span><span class="n">hba</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hba</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			<span class="s">&quot;Reset: Controller initialization failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">FAILED</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">SUCCESS</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ufshcd_slave_alloc - handle initial SCSI device configurations</span>
<span class="cm"> * @sdev: pointer to SCSI device</span>
<span class="cm"> *</span>
<span class="cm"> * Returns success</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">ufshcd_slave_alloc</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="n">sdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ufs_hba</span> <span class="o">*</span><span class="n">hba</span><span class="p">;</span>

	<span class="n">hba</span> <span class="o">=</span> <span class="n">shost_priv</span><span class="p">(</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">);</span>
	<span class="n">sdev</span><span class="o">-&gt;</span><span class="n">tagged_supported</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/* Mode sense(6) is not supported by UFS, so use Mode sense(10) */</span>
	<span class="n">sdev</span><span class="o">-&gt;</span><span class="n">use_10_for_ms</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">scsi_set_tag_type</span><span class="p">(</span><span class="n">sdev</span><span class="p">,</span> <span class="n">MSG_SIMPLE_TAG</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Inform SCSI Midlayer that the LUN queue depth is same as the</span>
<span class="cm">	 * controller queue depth. If a LUN queue depth is less than the</span>
<span class="cm">	 * controller queue depth and if the LUN reports</span>
<span class="cm">	 * SAM_STAT_TASK_SET_FULL, the LUN queue depth will be adjusted</span>
<span class="cm">	 * with scsi_adjust_queue_depth.</span>
<span class="cm">	 */</span>
	<span class="n">scsi_activate_tcq</span><span class="p">(</span><span class="n">sdev</span><span class="p">,</span> <span class="n">hba</span><span class="o">-&gt;</span><span class="n">nutrs</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ufshcd_slave_destroy - remove SCSI device configurations</span>
<span class="cm"> * @sdev: pointer to SCSI device</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">ufshcd_slave_destroy</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="n">sdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ufs_hba</span> <span class="o">*</span><span class="n">hba</span><span class="p">;</span>

	<span class="n">hba</span> <span class="o">=</span> <span class="n">shost_priv</span><span class="p">(</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">);</span>
	<span class="n">scsi_deactivate_tcq</span><span class="p">(</span><span class="n">sdev</span><span class="p">,</span> <span class="n">hba</span><span class="o">-&gt;</span><span class="n">nutrs</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ufshcd_task_req_compl - handle task management request completion</span>
<span class="cm"> * @hba: per adapter instance</span>
<span class="cm"> * @index: index of the completed request</span>
<span class="cm"> *</span>
<span class="cm"> * Returns SUCCESS/FAILED</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">ufshcd_task_req_compl</span><span class="p">(</span><span class="k">struct</span> <span class="n">ufs_hba</span> <span class="o">*</span><span class="n">hba</span><span class="p">,</span> <span class="n">u32</span> <span class="n">index</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">utp_task_req_desc</span> <span class="o">*</span><span class="n">task_req_descp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">utp_upiu_task_rsp</span> <span class="o">*</span><span class="n">task_rsp_upiup</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ocs_value</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">task_result</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="n">hba</span><span class="o">-&gt;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="cm">/* Clear completed tasks from outstanding_tasks */</span>
	<span class="n">__clear_bit</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hba</span><span class="o">-&gt;</span><span class="n">outstanding_tasks</span><span class="p">);</span>

	<span class="n">task_req_descp</span> <span class="o">=</span> <span class="n">hba</span><span class="o">-&gt;</span><span class="n">utmrdl_base_addr</span><span class="p">;</span>
	<span class="n">ocs_value</span> <span class="o">=</span> <span class="n">ufshcd_get_tmr_ocs</span><span class="p">(</span><span class="o">&amp;</span><span class="n">task_req_descp</span><span class="p">[</span><span class="n">index</span><span class="p">]);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ocs_value</span> <span class="o">==</span> <span class="n">OCS_SUCCESS</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">task_rsp_upiup</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">utp_upiu_task_rsp</span> <span class="o">*</span><span class="p">)</span>
				<span class="n">task_req_descp</span><span class="p">[</span><span class="n">index</span><span class="p">].</span><span class="n">task_rsp_upiu</span><span class="p">;</span>
		<span class="n">task_result</span> <span class="o">=</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">task_rsp_upiup</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">dword_1</span><span class="p">);</span>
		<span class="n">task_result</span> <span class="o">=</span> <span class="p">((</span><span class="n">task_result</span> <span class="o">&amp;</span> <span class="n">MASK_TASK_RESPONSE</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">task_result</span> <span class="o">!=</span> <span class="n">UPIU_TASK_MANAGEMENT_FUNC_COMPL</span> <span class="o">&amp;&amp;</span>
		    <span class="n">task_result</span> <span class="o">!=</span> <span class="n">UPIU_TASK_MANAGEMENT_FUNC_SUCCEEDED</span><span class="p">)</span>
			<span class="n">task_result</span> <span class="o">=</span> <span class="n">FAILED</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">task_result</span> <span class="o">=</span> <span class="n">FAILED</span><span class="p">;</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hba</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			<span class="s">&quot;trc: Invalid ocs = %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ocs_value</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="n">hba</span><span class="o">-&gt;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">task_result</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ufshcd_adjust_lun_qdepth - Update LUN queue depth if device responds with</span>
<span class="cm"> *			      SAM_STAT_TASK_SET_FULL SCSI command status.</span>
<span class="cm"> * @cmd: pointer to SCSI command</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">ufshcd_adjust_lun_qdepth</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ufs_hba</span> <span class="o">*</span><span class="n">hba</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">lun_qdepth</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">hba</span> <span class="o">=</span> <span class="n">shost_priv</span><span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * LUN queue depth can be obtained by counting outstanding commands</span>
<span class="cm">	 * on the LUN.</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">hba</span><span class="o">-&gt;</span><span class="n">nutrs</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hba</span><span class="o">-&gt;</span><span class="n">outstanding_reqs</span><span class="p">))</span> <span class="p">{</span>

			<span class="cm">/*</span>
<span class="cm">			 * Check if the outstanding command belongs</span>
<span class="cm">			 * to the LUN which reported SAM_STAT_TASK_SET_FULL.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">lun</span> <span class="o">==</span> <span class="n">hba</span><span class="o">-&gt;</span><span class="n">lrb</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">lun</span><span class="p">)</span>
				<span class="n">lun_qdepth</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * LUN queue depth will be total outstanding commands, except the</span>
<span class="cm">	 * command for which the LUN reported SAM_STAT_TASK_SET_FULL.</span>
<span class="cm">	 */</span>
	<span class="n">scsi_adjust_queue_depth</span><span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">device</span><span class="p">,</span> <span class="n">MSG_SIMPLE_TAG</span><span class="p">,</span> <span class="n">lun_qdepth</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ufshcd_scsi_cmd_status - Update SCSI command result based on SCSI status</span>
<span class="cm"> * @lrb: pointer to local reference block of completed command</span>
<span class="cm"> * @scsi_status: SCSI command status</span>
<span class="cm"> *</span>
<span class="cm"> * Returns value base on SCSI command status</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span>
<span class="nf">ufshcd_scsi_cmd_status</span><span class="p">(</span><span class="k">struct</span> <span class="n">ufshcd_lrb</span> <span class="o">*</span><span class="n">lrbp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">scsi_status</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">scsi_status</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">SAM_STAT_GOOD</span>:
		<span class="n">result</span> <span class="o">|=</span> <span class="n">DID_OK</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span> <span class="o">|</span>
			  <span class="n">COMMAND_COMPLETE</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span> <span class="o">|</span>
			  <span class="n">SAM_STAT_GOOD</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SAM_STAT_CHECK_CONDITION</span>:
		<span class="n">result</span> <span class="o">|=</span> <span class="n">DID_OK</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span> <span class="o">|</span>
			  <span class="n">COMMAND_COMPLETE</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span> <span class="o">|</span>
			  <span class="n">SAM_STAT_CHECK_CONDITION</span><span class="p">;</span>
		<span class="n">ufshcd_copy_sense_data</span><span class="p">(</span><span class="n">lrbp</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SAM_STAT_BUSY</span>:
		<span class="n">result</span> <span class="o">|=</span> <span class="n">SAM_STAT_BUSY</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SAM_STAT_TASK_SET_FULL</span>:

		<span class="cm">/*</span>
<span class="cm">		 * If a LUN reports SAM_STAT_TASK_SET_FULL, then the LUN queue</span>
<span class="cm">		 * depth needs to be adjusted to the exact number of</span>
<span class="cm">		 * outstanding commands the LUN can handle at any given time.</span>
<span class="cm">		 */</span>
		<span class="n">ufshcd_adjust_lun_qdepth</span><span class="p">(</span><span class="n">lrbp</span><span class="o">-&gt;</span><span class="n">cmd</span><span class="p">);</span>
		<span class="n">result</span> <span class="o">|=</span> <span class="n">SAM_STAT_TASK_SET_FULL</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SAM_STAT_TASK_ABORTED</span>:
		<span class="n">result</span> <span class="o">|=</span> <span class="n">SAM_STAT_TASK_ABORTED</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">result</span> <span class="o">|=</span> <span class="n">DID_ERROR</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span> <span class="cm">/* end of switch */</span>

	<span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ufshcd_transfer_rsp_status - Get overall status of the response</span>
<span class="cm"> * @hba: per adapter instance</span>
<span class="cm"> * @lrb: pointer to local reference block of completed command</span>
<span class="cm"> *</span>
<span class="cm"> * Returns result of the command to notify SCSI midlayer</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span>
<span class="nf">ufshcd_transfer_rsp_status</span><span class="p">(</span><span class="k">struct</span> <span class="n">ufs_hba</span> <span class="o">*</span><span class="n">hba</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ufshcd_lrb</span> <span class="o">*</span><span class="n">lrbp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">scsi_status</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ocs</span><span class="p">;</span>

	<span class="cm">/* overall command status of utrd */</span>
	<span class="n">ocs</span> <span class="o">=</span> <span class="n">ufshcd_get_tr_ocs</span><span class="p">(</span><span class="n">lrbp</span><span class="p">);</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">ocs</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">OCS_SUCCESS</span>:

		<span class="cm">/* check if the returned transfer response is valid */</span>
		<span class="n">result</span> <span class="o">=</span> <span class="n">ufshcd_is_valid_req_rsp</span><span class="p">(</span><span class="n">lrbp</span><span class="o">-&gt;</span><span class="n">ucd_rsp_ptr</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">result</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hba</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
				<span class="s">&quot;Invalid response = %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">result</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 * get the response UPIU result to extract</span>
<span class="cm">		 * the SCSI command status</span>
<span class="cm">		 */</span>
		<span class="n">result</span> <span class="o">=</span> <span class="n">ufshcd_get_rsp_upiu_result</span><span class="p">(</span><span class="n">lrbp</span><span class="o">-&gt;</span><span class="n">ucd_rsp_ptr</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * get the result based on SCSI status response</span>
<span class="cm">		 * to notify the SCSI midlayer of the command status</span>
<span class="cm">		 */</span>
		<span class="n">scsi_status</span> <span class="o">=</span> <span class="n">result</span> <span class="o">&amp;</span> <span class="n">MASK_SCSI_STATUS</span><span class="p">;</span>
		<span class="n">result</span> <span class="o">=</span> <span class="n">ufshcd_scsi_cmd_status</span><span class="p">(</span><span class="n">lrbp</span><span class="p">,</span> <span class="n">scsi_status</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">OCS_ABORTED</span>:
		<span class="n">result</span> <span class="o">|=</span> <span class="n">DID_ABORT</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">OCS_INVALID_CMD_TABLE_ATTR</span>:
	<span class="k">case</span> <span class="n">OCS_INVALID_PRDT_ATTR</span>:
	<span class="k">case</span> <span class="n">OCS_MISMATCH_DATA_BUF_SIZE</span>:
	<span class="k">case</span> <span class="n">OCS_MISMATCH_RESP_UPIU_SIZE</span>:
	<span class="k">case</span> <span class="n">OCS_PEER_COMM_FAILURE</span>:
	<span class="k">case</span> <span class="n">OCS_FATAL_ERROR</span>:
	<span class="nl">default:</span>
		<span class="n">result</span> <span class="o">|=</span> <span class="n">DID_ERROR</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">;</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hba</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
		<span class="s">&quot;OCS error from controller = %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ocs</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span> <span class="cm">/* end of switch */</span>

	<span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ufshcd_transfer_req_compl - handle SCSI and query command completion</span>
<span class="cm"> * @hba: per adapter instance</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">ufshcd_transfer_req_compl</span><span class="p">(</span><span class="k">struct</span> <span class="n">ufs_hba</span> <span class="o">*</span><span class="n">hba</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ufshcd_lrb</span> <span class="o">*</span><span class="n">lrb</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">completed_reqs</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">tr_doorbell</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">result</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">index</span><span class="p">;</span>

	<span class="n">lrb</span> <span class="o">=</span> <span class="n">hba</span><span class="o">-&gt;</span><span class="n">lrb</span><span class="p">;</span>
	<span class="n">tr_doorbell</span> <span class="o">=</span>
		<span class="n">readl</span><span class="p">(</span><span class="n">hba</span><span class="o">-&gt;</span><span class="n">mmio_base</span> <span class="o">+</span> <span class="n">REG_UTP_TRANSFER_REQ_DOOR_BELL</span><span class="p">);</span>
	<span class="n">completed_reqs</span> <span class="o">=</span> <span class="n">tr_doorbell</span> <span class="o">^</span> <span class="n">hba</span><span class="o">-&gt;</span><span class="n">outstanding_reqs</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="n">hba</span><span class="o">-&gt;</span><span class="n">nutrs</span><span class="p">;</span> <span class="n">index</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">completed_reqs</span><span class="p">))</span> <span class="p">{</span>

			<span class="n">result</span> <span class="o">=</span> <span class="n">ufshcd_transfer_rsp_status</span><span class="p">(</span><span class="n">hba</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">lrb</span><span class="p">[</span><span class="n">index</span><span class="p">]);</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">lrb</span><span class="p">[</span><span class="n">index</span><span class="p">].</span><span class="n">cmd</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">scsi_dma_unmap</span><span class="p">(</span><span class="n">lrb</span><span class="p">[</span><span class="n">index</span><span class="p">].</span><span class="n">cmd</span><span class="p">);</span>
				<span class="n">lrb</span><span class="p">[</span><span class="n">index</span><span class="p">].</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">=</span> <span class="n">result</span><span class="p">;</span>
				<span class="n">lrb</span><span class="p">[</span><span class="n">index</span><span class="p">].</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scsi_done</span><span class="p">(</span><span class="n">lrb</span><span class="p">[</span><span class="n">index</span><span class="p">].</span><span class="n">cmd</span><span class="p">);</span>

				<span class="cm">/* Mark completed command as NULL in LRB */</span>
				<span class="n">lrb</span><span class="p">[</span><span class="n">index</span><span class="p">].</span><span class="n">cmd</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="cm">/* end of if */</span>
	<span class="p">}</span> <span class="cm">/* end of for */</span>

	<span class="cm">/* clear corresponding bits of completed commands */</span>
	<span class="n">hba</span><span class="o">-&gt;</span><span class="n">outstanding_reqs</span> <span class="o">^=</span> <span class="n">completed_reqs</span><span class="p">;</span>

	<span class="cm">/* Reset interrupt aggregation counters */</span>
	<span class="n">ufshcd_config_int_aggr</span><span class="p">(</span><span class="n">hba</span><span class="p">,</span> <span class="n">INT_AGGR_RESET</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ufshcd_uic_cc_handler - handle UIC command completion</span>
<span class="cm"> * @work: pointer to a work queue structure</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 0 on success, non-zero value on failure</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">ufshcd_uic_cc_handler</span> <span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ufs_hba</span> <span class="o">*</span><span class="n">hba</span><span class="p">;</span>

	<span class="n">hba</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">work</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ufs_hba</span><span class="p">,</span> <span class="n">uic_workq</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">hba</span><span class="o">-&gt;</span><span class="n">active_uic_cmd</span><span class="p">.</span><span class="n">command</span> <span class="o">==</span> <span class="n">UIC_CMD_DME_LINK_STARTUP</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="o">!</span><span class="p">(</span><span class="n">ufshcd_get_uic_cmd_result</span><span class="p">(</span><span class="n">hba</span><span class="p">)))</span> <span class="p">{</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">ufshcd_make_hba_operational</span><span class="p">(</span><span class="n">hba</span><span class="p">))</span>
			<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hba</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
				<span class="s">&quot;cc: hba not operational state</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ufshcd_fatal_err_handler - handle fatal errors</span>
<span class="cm"> * @hba: per adapter instance</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">ufshcd_fatal_err_handler</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ufs_hba</span> <span class="o">*</span><span class="n">hba</span><span class="p">;</span>
	<span class="n">hba</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">work</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ufs_hba</span><span class="p">,</span> <span class="n">feh_workq</span><span class="p">);</span>

	<span class="cm">/* check if reset is already in progress */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hba</span><span class="o">-&gt;</span><span class="n">ufshcd_state</span> <span class="o">!=</span> <span class="n">UFSHCD_STATE_RESET</span><span class="p">)</span>
		<span class="n">ufshcd_do_reset</span><span class="p">(</span><span class="n">hba</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ufshcd_err_handler - Check for fatal errors</span>
<span class="cm"> * @work: pointer to a work queue structure</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">ufshcd_err_handler</span><span class="p">(</span><span class="k">struct</span> <span class="n">ufs_hba</span> <span class="o">*</span><span class="n">hba</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">reg</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">hba</span><span class="o">-&gt;</span><span class="n">errors</span> <span class="o">&amp;</span> <span class="n">INT_FATAL_ERRORS</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">fatal_eh</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">hba</span><span class="o">-&gt;</span><span class="n">errors</span> <span class="o">&amp;</span> <span class="n">UIC_ERROR</span><span class="p">)</span> <span class="p">{</span>

		<span class="n">reg</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="n">hba</span><span class="o">-&gt;</span><span class="n">mmio_base</span> <span class="o">+</span>
			    <span class="n">REG_UIC_ERROR_CODE_PHY_ADAPTER_LAYER</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">reg</span> <span class="o">&amp;</span> <span class="n">UIC_DATA_LINK_LAYER_ERROR_PA_INIT</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">fatal_eh</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span><span class="p">;</span>
<span class="nl">fatal_eh:</span>
	<span class="n">hba</span><span class="o">-&gt;</span><span class="n">ufshcd_state</span> <span class="o">=</span> <span class="n">UFSHCD_STATE_ERROR</span><span class="p">;</span>
	<span class="n">schedule_work</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hba</span><span class="o">-&gt;</span><span class="n">feh_workq</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ufshcd_tmc_handler - handle task management function completion</span>
<span class="cm"> * @hba: per adapter instance</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">ufshcd_tmc_handler</span><span class="p">(</span><span class="k">struct</span> <span class="n">ufs_hba</span> <span class="o">*</span><span class="n">hba</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">tm_doorbell</span><span class="p">;</span>

	<span class="n">tm_doorbell</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="n">hba</span><span class="o">-&gt;</span><span class="n">mmio_base</span> <span class="o">+</span> <span class="n">REG_UTP_TASK_REQ_DOOR_BELL</span><span class="p">);</span>
	<span class="n">hba</span><span class="o">-&gt;</span><span class="n">tm_condition</span> <span class="o">=</span> <span class="n">tm_doorbell</span> <span class="o">^</span> <span class="n">hba</span><span class="o">-&gt;</span><span class="n">outstanding_tasks</span><span class="p">;</span>
	<span class="n">wake_up_interruptible</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hba</span><span class="o">-&gt;</span><span class="n">ufshcd_tm_wait_queue</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ufshcd_sl_intr - Interrupt service routine</span>
<span class="cm"> * @hba: per adapter instance</span>
<span class="cm"> * @intr_status: contains interrupts generated by the controller</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">ufshcd_sl_intr</span><span class="p">(</span><span class="k">struct</span> <span class="n">ufs_hba</span> <span class="o">*</span><span class="n">hba</span><span class="p">,</span> <span class="n">u32</span> <span class="n">intr_status</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">hba</span><span class="o">-&gt;</span><span class="n">errors</span> <span class="o">=</span> <span class="n">UFSHCD_ERROR_MASK</span> <span class="o">&amp;</span> <span class="n">intr_status</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hba</span><span class="o">-&gt;</span><span class="n">errors</span><span class="p">)</span>
		<span class="n">ufshcd_err_handler</span><span class="p">(</span><span class="n">hba</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">intr_status</span> <span class="o">&amp;</span> <span class="n">UIC_COMMAND_COMPL</span><span class="p">)</span>
		<span class="n">schedule_work</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hba</span><span class="o">-&gt;</span><span class="n">uic_workq</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">intr_status</span> <span class="o">&amp;</span> <span class="n">UTP_TASK_REQ_COMPL</span><span class="p">)</span>
		<span class="n">ufshcd_tmc_handler</span><span class="p">(</span><span class="n">hba</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">intr_status</span> <span class="o">&amp;</span> <span class="n">UTP_TRANSFER_REQ_COMPL</span><span class="p">)</span>
		<span class="n">ufshcd_transfer_req_compl</span><span class="p">(</span><span class="n">hba</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ufshcd_intr - Main interrupt service routine</span>
<span class="cm"> * @irq: irq number</span>
<span class="cm"> * @__hba: pointer to adapter instance</span>
<span class="cm"> *</span>
<span class="cm"> * Returns IRQ_HANDLED - If interrupt is valid</span>
<span class="cm"> *		IRQ_NONE - If invalid interrupt</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">irqreturn_t</span> <span class="nf">ufshcd_intr</span><span class="p">(</span><span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">__hba</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">intr_status</span><span class="p">;</span>
	<span class="n">irqreturn_t</span> <span class="n">retval</span> <span class="o">=</span> <span class="n">IRQ_NONE</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ufs_hba</span> <span class="o">*</span><span class="n">hba</span> <span class="o">=</span> <span class="n">__hba</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="n">hba</span><span class="o">-&gt;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>
	<span class="n">intr_status</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="n">hba</span><span class="o">-&gt;</span><span class="n">mmio_base</span> <span class="o">+</span> <span class="n">REG_INTERRUPT_STATUS</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">intr_status</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ufshcd_sl_intr</span><span class="p">(</span><span class="n">hba</span><span class="p">,</span> <span class="n">intr_status</span><span class="p">);</span>

		<span class="cm">/* If UFSHCI 1.0 then clear interrupt status register */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">hba</span><span class="o">-&gt;</span><span class="n">ufs_version</span> <span class="o">==</span> <span class="n">UFSHCI_VERSION_10</span><span class="p">)</span>
			<span class="n">writel</span><span class="p">(</span><span class="n">intr_status</span><span class="p">,</span>
			       <span class="p">(</span><span class="n">hba</span><span class="o">-&gt;</span><span class="n">mmio_base</span> <span class="o">+</span> <span class="n">REG_INTERRUPT_STATUS</span><span class="p">));</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="n">IRQ_HANDLED</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="n">hba</span><span class="o">-&gt;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ufshcd_issue_tm_cmd - issues task management commands to controller</span>
<span class="cm"> * @hba: per adapter instance</span>
<span class="cm"> * @lrbp: pointer to local reference block</span>
<span class="cm"> *</span>
<span class="cm"> * Returns SUCCESS/FAILED</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">ufshcd_issue_tm_cmd</span><span class="p">(</span><span class="k">struct</span> <span class="n">ufs_hba</span> <span class="o">*</span><span class="n">hba</span><span class="p">,</span>
		    <span class="k">struct</span> <span class="n">ufshcd_lrb</span> <span class="o">*</span><span class="n">lrbp</span><span class="p">,</span>
		    <span class="n">u8</span> <span class="n">tm_function</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">utp_task_req_desc</span> <span class="o">*</span><span class="n">task_req_descp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">utp_upiu_task_req</span> <span class="o">*</span><span class="n">task_req_upiup</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">host</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">free_slot</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">host</span> <span class="o">=</span> <span class="n">hba</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="cm">/* If task management queue is full */</span>
	<span class="n">free_slot</span> <span class="o">=</span> <span class="n">ufshcd_get_tm_free_slot</span><span class="p">(</span><span class="n">hba</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">free_slot</span> <span class="o">&gt;=</span> <span class="n">hba</span><span class="o">-&gt;</span><span class="n">nutmrs</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hba</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Task management queue full</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">FAILED</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">task_req_descp</span> <span class="o">=</span> <span class="n">hba</span><span class="o">-&gt;</span><span class="n">utmrdl_base_addr</span><span class="p">;</span>
	<span class="n">task_req_descp</span> <span class="o">+=</span> <span class="n">free_slot</span><span class="p">;</span>

	<span class="cm">/* Configure task request descriptor */</span>
	<span class="n">task_req_descp</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">dword_0</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">UTP_REQ_DESC_INT_CMD</span><span class="p">);</span>
	<span class="n">task_req_descp</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">dword_2</span> <span class="o">=</span>
			<span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">OCS_INVALID_COMMAND_STATUS</span><span class="p">);</span>

	<span class="cm">/* Configure task request UPIU */</span>
	<span class="n">task_req_upiup</span> <span class="o">=</span>
		<span class="p">(</span><span class="k">struct</span> <span class="n">utp_upiu_task_req</span> <span class="o">*</span><span class="p">)</span> <span class="n">task_req_descp</span><span class="o">-&gt;</span><span class="n">task_req_upiu</span><span class="p">;</span>
	<span class="n">task_req_upiup</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">dword_0</span> <span class="o">=</span>
		<span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">UPIU_HEADER_DWORD</span><span class="p">(</span><span class="n">UPIU_TRANSACTION_TASK_REQ</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
					      <span class="n">lrbp</span><span class="o">-&gt;</span><span class="n">lun</span><span class="p">,</span> <span class="n">lrbp</span><span class="o">-&gt;</span><span class="n">task_tag</span><span class="p">));</span>
	<span class="n">task_req_upiup</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">dword_1</span> <span class="o">=</span>
	<span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">UPIU_HEADER_DWORD</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">tm_function</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">));</span>

	<span class="n">task_req_upiup</span><span class="o">-&gt;</span><span class="n">input_param1</span> <span class="o">=</span> <span class="n">lrbp</span><span class="o">-&gt;</span><span class="n">lun</span><span class="p">;</span>
	<span class="n">task_req_upiup</span><span class="o">-&gt;</span><span class="n">input_param1</span> <span class="o">=</span>
		<span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">task_req_upiup</span><span class="o">-&gt;</span><span class="n">input_param1</span><span class="p">);</span>
	<span class="n">task_req_upiup</span><span class="o">-&gt;</span><span class="n">input_param2</span> <span class="o">=</span> <span class="n">lrbp</span><span class="o">-&gt;</span><span class="n">task_tag</span><span class="p">;</span>
	<span class="n">task_req_upiup</span><span class="o">-&gt;</span><span class="n">input_param2</span> <span class="o">=</span>
		<span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">task_req_upiup</span><span class="o">-&gt;</span><span class="n">input_param2</span><span class="p">);</span>

	<span class="cm">/* send command to the controller */</span>
	<span class="n">__set_bit</span><span class="p">(</span><span class="n">free_slot</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hba</span><span class="o">-&gt;</span><span class="n">outstanding_tasks</span><span class="p">);</span>
	<span class="n">writel</span><span class="p">((</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">free_slot</span><span class="p">),</span>
	       <span class="p">(</span><span class="n">hba</span><span class="o">-&gt;</span><span class="n">mmio_base</span> <span class="o">+</span> <span class="n">REG_UTP_TASK_REQ_DOOR_BELL</span><span class="p">));</span>

	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="cm">/* wait until the task management command is completed */</span>
	<span class="n">err</span> <span class="o">=</span>
	<span class="n">wait_event_interruptible_timeout</span><span class="p">(</span><span class="n">hba</span><span class="o">-&gt;</span><span class="n">ufshcd_tm_wait_queue</span><span class="p">,</span>
					 <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">free_slot</span><span class="p">,</span>
					 <span class="o">&amp;</span><span class="n">hba</span><span class="o">-&gt;</span><span class="n">tm_condition</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">),</span>
					 <span class="mi">60</span> <span class="o">*</span> <span class="n">HZ</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hba</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			<span class="s">&quot;Task management command timed-out</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">FAILED</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">clear_bit</span><span class="p">(</span><span class="n">free_slot</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hba</span><span class="o">-&gt;</span><span class="n">tm_condition</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ufshcd_task_req_compl</span><span class="p">(</span><span class="n">hba</span><span class="p">,</span> <span class="n">free_slot</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ufshcd_device_reset - reset device and abort all the pending commands</span>
<span class="cm"> * @cmd: SCSI command pointer</span>
<span class="cm"> *</span>
<span class="cm"> * Returns SUCCESS/FAILED</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">ufshcd_device_reset</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">host</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ufs_hba</span> <span class="o">*</span><span class="n">hba</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">tag</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">pos</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">host</span> <span class="o">=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">;</span>
	<span class="n">hba</span> <span class="o">=</span> <span class="n">shost_priv</span><span class="p">(</span><span class="n">host</span><span class="p">);</span>
	<span class="n">tag</span> <span class="o">=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">request</span><span class="o">-&gt;</span><span class="n">tag</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">ufshcd_issue_tm_cmd</span><span class="p">(</span><span class="n">hba</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hba</span><span class="o">-&gt;</span><span class="n">lrb</span><span class="p">[</span><span class="n">tag</span><span class="p">],</span> <span class="n">UFS_LOGICAL_RESET</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">pos</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">pos</span> <span class="o">&lt;</span> <span class="n">hba</span><span class="o">-&gt;</span><span class="n">nutrs</span><span class="p">;</span> <span class="n">pos</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hba</span><span class="o">-&gt;</span><span class="n">outstanding_reqs</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="p">(</span><span class="n">hba</span><span class="o">-&gt;</span><span class="n">lrb</span><span class="p">[</span><span class="n">tag</span><span class="p">].</span><span class="n">lun</span> <span class="o">==</span> <span class="n">hba</span><span class="o">-&gt;</span><span class="n">lrb</span><span class="p">[</span><span class="n">pos</span><span class="p">].</span><span class="n">lun</span><span class="p">))</span> <span class="p">{</span>

			<span class="cm">/* clear the respective UTRLCLR register bit */</span>
			<span class="n">ufshcd_utrl_clear</span><span class="p">(</span><span class="n">hba</span><span class="p">,</span> <span class="n">pos</span><span class="p">);</span>

			<span class="n">clear_bit</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hba</span><span class="o">-&gt;</span><span class="n">outstanding_reqs</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">hba</span><span class="o">-&gt;</span><span class="n">lrb</span><span class="p">[</span><span class="n">pos</span><span class="p">].</span><span class="n">cmd</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">scsi_dma_unmap</span><span class="p">(</span><span class="n">hba</span><span class="o">-&gt;</span><span class="n">lrb</span><span class="p">[</span><span class="n">pos</span><span class="p">].</span><span class="n">cmd</span><span class="p">);</span>
				<span class="n">hba</span><span class="o">-&gt;</span><span class="n">lrb</span><span class="p">[</span><span class="n">pos</span><span class="p">].</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">=</span>
						<span class="n">DID_ABORT</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">;</span>
				<span class="n">hba</span><span class="o">-&gt;</span><span class="n">lrb</span><span class="p">[</span><span class="n">pos</span><span class="p">].</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scsi_done</span><span class="p">(</span><span class="n">cmd</span><span class="p">);</span>
				<span class="n">hba</span><span class="o">-&gt;</span><span class="n">lrb</span><span class="p">[</span><span class="n">pos</span><span class="p">].</span><span class="n">cmd</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="cm">/* end of for */</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ufshcd_host_reset - Main reset function registered with scsi layer</span>
<span class="cm"> * @cmd: SCSI command pointer</span>
<span class="cm"> *</span>
<span class="cm"> * Returns SUCCESS/FAILED</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">ufshcd_host_reset</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ufs_hba</span> <span class="o">*</span><span class="n">hba</span><span class="p">;</span>

	<span class="n">hba</span> <span class="o">=</span> <span class="n">shost_priv</span><span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">hba</span><span class="o">-&gt;</span><span class="n">ufshcd_state</span> <span class="o">==</span> <span class="n">UFSHCD_STATE_RESET</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">SUCCESS</span><span class="p">;</span>

	<span class="k">return</span> <span class="p">(</span><span class="n">ufshcd_do_reset</span><span class="p">(</span><span class="n">hba</span><span class="p">)</span> <span class="o">==</span> <span class="n">SUCCESS</span><span class="p">)</span> <span class="o">?</span> <span class="n">SUCCESS</span> <span class="o">:</span> <span class="n">FAILED</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ufshcd_abort - abort a specific command</span>
<span class="cm"> * @cmd: SCSI command pointer</span>
<span class="cm"> *</span>
<span class="cm"> * Returns SUCCESS/FAILED</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">ufshcd_abort</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">host</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ufs_hba</span> <span class="o">*</span><span class="n">hba</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">tag</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">host</span> <span class="o">=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">;</span>
	<span class="n">hba</span> <span class="o">=</span> <span class="n">shost_priv</span><span class="p">(</span><span class="n">host</span><span class="p">);</span>
	<span class="n">tag</span> <span class="o">=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">request</span><span class="o">-&gt;</span><span class="n">tag</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="cm">/* check if command is still pending */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">tag</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hba</span><span class="o">-&gt;</span><span class="n">outstanding_reqs</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">FAILED</span><span class="p">;</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">ufshcd_issue_tm_cmd</span><span class="p">(</span><span class="n">hba</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hba</span><span class="o">-&gt;</span><span class="n">lrb</span><span class="p">[</span><span class="n">tag</span><span class="p">],</span> <span class="n">UFS_ABORT_TASK</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">scsi_dma_unmap</span><span class="p">(</span><span class="n">cmd</span><span class="p">);</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="cm">/* clear the respective UTRLCLR register bit */</span>
	<span class="n">ufshcd_utrl_clear</span><span class="p">(</span><span class="n">hba</span><span class="p">,</span> <span class="n">tag</span><span class="p">);</span>

	<span class="n">__clear_bit</span><span class="p">(</span><span class="n">tag</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hba</span><span class="o">-&gt;</span><span class="n">outstanding_reqs</span><span class="p">);</span>
	<span class="n">hba</span><span class="o">-&gt;</span><span class="n">lrb</span><span class="p">[</span><span class="n">tag</span><span class="p">].</span><span class="n">cmd</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">scsi_host_template</span> <span class="n">ufshcd_driver_template</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">module</span>			<span class="o">=</span> <span class="n">THIS_MODULE</span><span class="p">,</span>
	<span class="p">.</span><span class="n">name</span>			<span class="o">=</span> <span class="n">UFSHCD</span><span class="p">,</span>
	<span class="p">.</span><span class="n">proc_name</span>		<span class="o">=</span> <span class="n">UFSHCD</span><span class="p">,</span>
	<span class="p">.</span><span class="n">queuecommand</span>		<span class="o">=</span> <span class="n">ufshcd_queuecommand</span><span class="p">,</span>
	<span class="p">.</span><span class="n">slave_alloc</span>		<span class="o">=</span> <span class="n">ufshcd_slave_alloc</span><span class="p">,</span>
	<span class="p">.</span><span class="n">slave_destroy</span>		<span class="o">=</span> <span class="n">ufshcd_slave_destroy</span><span class="p">,</span>
	<span class="p">.</span><span class="n">eh_abort_handler</span>	<span class="o">=</span> <span class="n">ufshcd_abort</span><span class="p">,</span>
	<span class="p">.</span><span class="n">eh_device_reset_handler</span> <span class="o">=</span> <span class="n">ufshcd_device_reset</span><span class="p">,</span>
	<span class="p">.</span><span class="n">eh_host_reset_handler</span>	<span class="o">=</span> <span class="n">ufshcd_host_reset</span><span class="p">,</span>
	<span class="p">.</span><span class="n">this_id</span>		<span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
	<span class="p">.</span><span class="n">sg_tablesize</span>		<span class="o">=</span> <span class="n">SG_ALL</span><span class="p">,</span>
	<span class="p">.</span><span class="n">cmd_per_lun</span>		<span class="o">=</span> <span class="n">UFSHCD_CMD_PER_LUN</span><span class="p">,</span>
	<span class="p">.</span><span class="n">can_queue</span>		<span class="o">=</span> <span class="n">UFSHCD_CAN_QUEUE</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * ufshcd_shutdown - main function to put the controller in reset state</span>
<span class="cm"> * @pdev: pointer to PCI device handle</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">ufshcd_shutdown</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ufshcd_hba_stop</span><span class="p">((</span><span class="k">struct</span> <span class="n">ufs_hba</span> <span class="o">*</span><span class="p">)</span><span class="n">pci_get_drvdata</span><span class="p">(</span><span class="n">pdev</span><span class="p">));</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_PM</span>
<span class="cm">/**</span>
<span class="cm"> * ufshcd_suspend - suspend power management function</span>
<span class="cm"> * @pdev: pointer to PCI device handle</span>
<span class="cm"> * @state: power state</span>
<span class="cm"> *</span>
<span class="cm"> * Returns -ENOSYS</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">ufshcd_suspend</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">,</span> <span class="n">pm_message_t</span> <span class="n">state</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * TODO:</span>
<span class="cm">	 * 1. Block SCSI requests from SCSI midlayer</span>
<span class="cm">	 * 2. Change the internal driver state to non operational</span>
<span class="cm">	 * 3. Set UTRLRSR and UTMRLRSR bits to zero</span>
<span class="cm">	 * 4. Wait until outstanding commands are completed</span>
<span class="cm">	 * 5. Set HCE to zero to send the UFS host controller to reset state</span>
<span class="cm">	 */</span>

	<span class="k">return</span> <span class="o">-</span><span class="n">ENOSYS</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ufshcd_resume - resume power management function</span>
<span class="cm"> * @pdev: pointer to PCI device handle</span>
<span class="cm"> *</span>
<span class="cm"> * Returns -ENOSYS</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">ufshcd_resume</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * TODO:</span>
<span class="cm">	 * 1. Set HCE to 1, to start the UFS host controller</span>
<span class="cm">	 * initialization process</span>
<span class="cm">	 * 2. Set UTRLRSR and UTMRLRSR bits to 1</span>
<span class="cm">	 * 3. Change the internal driver state to operational</span>
<span class="cm">	 * 4. Unblock SCSI requests from SCSI midlayer</span>
<span class="cm">	 */</span>

	<span class="k">return</span> <span class="o">-</span><span class="n">ENOSYS</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_PM */</span><span class="cp"></span>

<span class="cm">/**</span>
<span class="cm"> * ufshcd_hba_free - free allocated memory for</span>
<span class="cm"> *			host memory space data structures</span>
<span class="cm"> * @hba: per adapter instance</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">ufshcd_hba_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">ufs_hba</span> <span class="o">*</span><span class="n">hba</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">iounmap</span><span class="p">(</span><span class="n">hba</span><span class="o">-&gt;</span><span class="n">mmio_base</span><span class="p">);</span>
	<span class="n">ufshcd_free_hba_memory</span><span class="p">(</span><span class="n">hba</span><span class="p">);</span>
	<span class="n">pci_release_regions</span><span class="p">(</span><span class="n">hba</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ufshcd_remove - de-allocate PCI/SCSI host and host memory space</span>
<span class="cm"> *		data structure memory</span>
<span class="cm"> * @pdev - pointer to PCI handle</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">ufshcd_remove</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ufs_hba</span> <span class="o">*</span><span class="n">hba</span> <span class="o">=</span> <span class="n">pci_get_drvdata</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>

	<span class="cm">/* disable interrupts */</span>
	<span class="n">ufshcd_int_config</span><span class="p">(</span><span class="n">hba</span><span class="p">,</span> <span class="n">UFSHCD_INT_DISABLE</span><span class="p">);</span>
	<span class="n">free_irq</span><span class="p">(</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">,</span> <span class="n">hba</span><span class="p">);</span>

	<span class="n">ufshcd_hba_stop</span><span class="p">(</span><span class="n">hba</span><span class="p">);</span>
	<span class="n">ufshcd_hba_free</span><span class="p">(</span><span class="n">hba</span><span class="p">);</span>

	<span class="n">scsi_remove_host</span><span class="p">(</span><span class="n">hba</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">);</span>
	<span class="n">scsi_host_put</span><span class="p">(</span><span class="n">hba</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">);</span>
	<span class="n">pci_set_drvdata</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">pci_clear_master</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="n">pci_disable_device</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ufshcd_set_dma_mask - Set dma mask based on the controller</span>
<span class="cm"> *			 addressing capability</span>
<span class="cm"> * @pdev: PCI device structure</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 0 for success, non-zero for failure</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">ufshcd_set_dma_mask</span><span class="p">(</span><span class="k">struct</span> <span class="n">ufs_hba</span> <span class="o">*</span><span class="n">hba</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">dma_mask</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * If controller supports 64 bit addressing mode, then set the DMA</span>
<span class="cm">	 * mask to 64-bit, else set the DMA mask to 32-bit</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hba</span><span class="o">-&gt;</span><span class="n">capabilities</span> <span class="o">&amp;</span> <span class="n">MASK_64_ADDRESSING_SUPPORT</span><span class="p">)</span>
		<span class="n">dma_mask</span> <span class="o">=</span> <span class="n">DMA_BIT_MASK</span><span class="p">(</span><span class="mi">64</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">dma_mask</span> <span class="o">=</span> <span class="n">DMA_BIT_MASK</span><span class="p">(</span><span class="mi">32</span><span class="p">);</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">pci_set_dma_mask</span><span class="p">(</span><span class="n">hba</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">,</span> <span class="n">dma_mask</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">pci_set_consistent_dma_mask</span><span class="p">(</span><span class="n">hba</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">,</span> <span class="n">dma_mask</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ufshcd_probe - probe routine of the driver</span>
<span class="cm"> * @pdev: pointer to PCI device handle</span>
<span class="cm"> * @id: PCI device id</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 0 on success, non-zero value on failure</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__devinit</span>
<span class="nf">ufshcd_probe</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">pci_device_id</span> <span class="o">*</span><span class="n">id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">host</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ufs_hba</span> <span class="o">*</span><span class="n">hba</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">pci_enable_device</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;pci_enable_device failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_error</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">pci_set_master</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>

	<span class="n">host</span> <span class="o">=</span> <span class="n">scsi_host_alloc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ufshcd_driver_template</span><span class="p">,</span>
				<span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ufs_hba</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">host</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;scsi_host_alloc failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out_disable</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">hba</span> <span class="o">=</span> <span class="n">shost_priv</span><span class="p">(</span><span class="n">host</span><span class="p">);</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">pci_request_regions</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">UFSHCD</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;request regions failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_host_put</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">hba</span><span class="o">-&gt;</span><span class="n">mmio_base</span> <span class="o">=</span> <span class="n">pci_ioremap_bar</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hba</span><span class="o">-&gt;</span><span class="n">mmio_base</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;memory map failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out_release_regions</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">hba</span><span class="o">-&gt;</span><span class="n">host</span> <span class="o">=</span> <span class="n">host</span><span class="p">;</span>
	<span class="n">hba</span><span class="o">-&gt;</span><span class="n">pdev</span> <span class="o">=</span> <span class="n">pdev</span><span class="p">;</span>

	<span class="cm">/* Read capabilities registers */</span>
	<span class="n">ufshcd_hba_capabilities</span><span class="p">(</span><span class="n">hba</span><span class="p">);</span>

	<span class="cm">/* Get UFS version supported by the controller */</span>
	<span class="n">hba</span><span class="o">-&gt;</span><span class="n">ufs_version</span> <span class="o">=</span> <span class="n">ufshcd_get_ufs_version</span><span class="p">(</span><span class="n">hba</span><span class="p">);</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">ufshcd_set_dma_mask</span><span class="p">(</span><span class="n">hba</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;set dma mask failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_iounmap</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Allocate memory for host memory space */</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">ufshcd_memory_alloc</span><span class="p">(</span><span class="n">hba</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Memory allocation failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_iounmap</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Configure LRB */</span>
	<span class="n">ufshcd_host_memory_configure</span><span class="p">(</span><span class="n">hba</span><span class="p">);</span>

	<span class="n">host</span><span class="o">-&gt;</span><span class="n">can_queue</span> <span class="o">=</span> <span class="n">hba</span><span class="o">-&gt;</span><span class="n">nutrs</span><span class="p">;</span>
	<span class="n">host</span><span class="o">-&gt;</span><span class="n">cmd_per_lun</span> <span class="o">=</span> <span class="n">hba</span><span class="o">-&gt;</span><span class="n">nutrs</span><span class="p">;</span>
	<span class="n">host</span><span class="o">-&gt;</span><span class="n">max_id</span> <span class="o">=</span> <span class="n">UFSHCD_MAX_ID</span><span class="p">;</span>
	<span class="n">host</span><span class="o">-&gt;</span><span class="n">max_lun</span> <span class="o">=</span> <span class="n">UFSHCD_MAX_LUNS</span><span class="p">;</span>
	<span class="n">host</span><span class="o">-&gt;</span><span class="n">max_channel</span> <span class="o">=</span> <span class="n">UFSHCD_MAX_CHANNEL</span><span class="p">;</span>
	<span class="n">host</span><span class="o">-&gt;</span><span class="n">unique_id</span> <span class="o">=</span> <span class="n">host</span><span class="o">-&gt;</span><span class="n">host_no</span><span class="p">;</span>
	<span class="n">host</span><span class="o">-&gt;</span><span class="n">max_cmd_len</span> <span class="o">=</span> <span class="n">MAX_CDB_SIZE</span><span class="p">;</span>

	<span class="cm">/* Initailize wait queue for task management */</span>
	<span class="n">init_waitqueue_head</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hba</span><span class="o">-&gt;</span><span class="n">ufshcd_tm_wait_queue</span><span class="p">);</span>

	<span class="cm">/* Initialize work queues */</span>
	<span class="n">INIT_WORK</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hba</span><span class="o">-&gt;</span><span class="n">uic_workq</span><span class="p">,</span> <span class="n">ufshcd_uic_cc_handler</span><span class="p">);</span>
	<span class="n">INIT_WORK</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hba</span><span class="o">-&gt;</span><span class="n">feh_workq</span><span class="p">,</span> <span class="n">ufshcd_fatal_err_handler</span><span class="p">);</span>

	<span class="cm">/* IRQ registration */</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">request_irq</span><span class="p">(</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">,</span> <span class="n">ufshcd_intr</span><span class="p">,</span> <span class="n">IRQF_SHARED</span><span class="p">,</span> <span class="n">UFSHCD</span><span class="p">,</span> <span class="n">hba</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;request irq failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_lrb_free</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Enable SCSI tag mapping */</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">scsi_init_shared_tag_map</span><span class="p">(</span><span class="n">host</span><span class="p">,</span> <span class="n">host</span><span class="o">-&gt;</span><span class="n">can_queue</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;init shared queue failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_free_irq</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">pci_set_drvdata</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">hba</span><span class="p">);</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">scsi_add_host</span><span class="p">(</span><span class="n">host</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;scsi_add_host failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_free_irq</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Initialization routine */</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">ufshcd_initialize_hba</span><span class="p">(</span><span class="n">hba</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Initialization failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_free_irq</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">out_free_irq:</span>
	<span class="n">free_irq</span><span class="p">(</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">,</span> <span class="n">hba</span><span class="p">);</span>
<span class="nl">out_lrb_free:</span>
	<span class="n">ufshcd_free_hba_memory</span><span class="p">(</span><span class="n">hba</span><span class="p">);</span>
<span class="nl">out_iounmap:</span>
	<span class="n">iounmap</span><span class="p">(</span><span class="n">hba</span><span class="o">-&gt;</span><span class="n">mmio_base</span><span class="p">);</span>
<span class="nl">out_release_regions:</span>
	<span class="n">pci_release_regions</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
<span class="nl">out_host_put:</span>
	<span class="n">scsi_host_put</span><span class="p">(</span><span class="n">host</span><span class="p">);</span>
<span class="nl">out_disable:</span>
	<span class="n">pci_clear_master</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="n">pci_disable_device</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
<span class="nl">out_error:</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">DEFINE_PCI_DEVICE_TABLE</span><span class="p">(</span><span class="n">ufshcd_pci_tbl</span><span class="p">)</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">{</span> <span class="n">PCI_VENDOR_ID_SAMSUNG</span><span class="p">,</span> <span class="mh">0xC00C</span><span class="p">,</span> <span class="n">PCI_ANY_ID</span><span class="p">,</span> <span class="n">PCI_ANY_ID</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span> <span class="p">},</span>
	<span class="p">{</span> <span class="p">}</span>	<span class="cm">/* terminate list */</span>
<span class="p">};</span>

<span class="n">MODULE_DEVICE_TABLE</span><span class="p">(</span><span class="n">pci</span><span class="p">,</span> <span class="n">ufshcd_pci_tbl</span><span class="p">);</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">pci_driver</span> <span class="n">ufshcd_pci_driver</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">UFSHCD</span><span class="p">,</span>
	<span class="p">.</span><span class="n">id_table</span> <span class="o">=</span> <span class="n">ufshcd_pci_tbl</span><span class="p">,</span>
	<span class="p">.</span><span class="n">probe</span> <span class="o">=</span> <span class="n">ufshcd_probe</span><span class="p">,</span>
	<span class="p">.</span><span class="n">remove</span> <span class="o">=</span> <span class="n">__devexit_p</span><span class="p">(</span><span class="n">ufshcd_remove</span><span class="p">),</span>
	<span class="p">.</span><span class="n">shutdown</span> <span class="o">=</span> <span class="n">ufshcd_shutdown</span><span class="p">,</span>
<span class="cp">#ifdef CONFIG_PM</span>
	<span class="p">.</span><span class="n">suspend</span> <span class="o">=</span> <span class="n">ufshcd_suspend</span><span class="p">,</span>
	<span class="p">.</span><span class="n">resume</span> <span class="o">=</span> <span class="n">ufshcd_resume</span><span class="p">,</span>
<span class="cp">#endif</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * ufshcd_init - Driver registration routine</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">ufshcd_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">pci_register_driver</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ufshcd_pci_driver</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">module_init</span><span class="p">(</span><span class="n">ufshcd_init</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * ufshcd_exit - Driver exit clean-up routine</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">__exit</span> <span class="nf">ufshcd_exit</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pci_unregister_driver</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ufshcd_pci_driver</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">module_exit</span><span class="p">(</span><span class="n">ufshcd_exit</span><span class="p">);</span>


<span class="n">MODULE_AUTHOR</span><span class="p">(</span><span class="s">&quot;Santosh Yaragnavi &lt;santosh.sy@samsung.com&gt;, &quot;</span>
	      <span class="s">&quot;Vinayak Holikatti &lt;h.vinayak@samsung.com&gt;&quot;</span><span class="p">);</span>
<span class="n">MODULE_DESCRIPTION</span><span class="p">(</span><span class="s">&quot;Generic UFS host controller driver&quot;</span><span class="p">);</span>
<span class="n">MODULE_LICENSE</span><span class="p">(</span><span class="s">&quot;GPL&quot;</span><span class="p">);</span>
<span class="n">MODULE_VERSION</span><span class="p">(</span><span class="n">UFSHCD_DRIVER_VERSION</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
