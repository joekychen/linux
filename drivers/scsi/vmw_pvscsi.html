<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › scsi › vmw_pvscsi.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>vmw_pvscsi.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Linux driver for VMware&#39;s para-virtualized SCSI HBA.</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 2008-2009, VMware, Inc. All Rights Reserved.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or modify it</span>
<span class="cm"> * under the terms of the GNU General Public License as published by the</span>
<span class="cm"> * Free Software Foundation; version 2 of the License and no later version.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is distributed in the hope that it will be useful, but</span>
<span class="cm"> * WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm"> * MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, GOOD TITLE or</span>
<span class="cm"> * NON INFRINGEMENT.  See the GNU General Public License for more</span>
<span class="cm"> * details.</span>
<span class="cm"> *</span>
<span class="cm"> * You should have received a copy of the GNU General Public License</span>
<span class="cm"> * along with this program; if not, write to the Free Software</span>
<span class="cm"> * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.</span>
<span class="cm"> *</span>
<span class="cm"> * Maintained by: Arvind Kumar &lt;arvindkumar@vmware.com&gt;</span>
<span class="cm"> *</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/interrupt.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/workqueue.h&gt;</span>
<span class="cp">#include &lt;linux/pci.h&gt;</span>

<span class="cp">#include &lt;scsi/scsi.h&gt;</span>
<span class="cp">#include &lt;scsi/scsi_host.h&gt;</span>
<span class="cp">#include &lt;scsi/scsi_cmnd.h&gt;</span>
<span class="cp">#include &lt;scsi/scsi_device.h&gt;</span>

<span class="cp">#include &quot;vmw_pvscsi.h&quot;</span>

<span class="cp">#define PVSCSI_LINUX_DRIVER_DESC &quot;VMware PVSCSI driver&quot;</span>

<span class="n">MODULE_DESCRIPTION</span><span class="p">(</span><span class="n">PVSCSI_LINUX_DRIVER_DESC</span><span class="p">);</span>
<span class="n">MODULE_AUTHOR</span><span class="p">(</span><span class="s">&quot;VMware, Inc.&quot;</span><span class="p">);</span>
<span class="n">MODULE_LICENSE</span><span class="p">(</span><span class="s">&quot;GPL&quot;</span><span class="p">);</span>
<span class="n">MODULE_VERSION</span><span class="p">(</span><span class="n">PVSCSI_DRIVER_VERSION_STRING</span><span class="p">);</span>

<span class="cp">#define PVSCSI_DEFAULT_NUM_PAGES_PER_RING	8</span>
<span class="cp">#define PVSCSI_DEFAULT_NUM_PAGES_MSG_RING	1</span>
<span class="cp">#define PVSCSI_DEFAULT_QUEUE_DEPTH		64</span>
<span class="cp">#define SGL_SIZE				PAGE_SIZE</span>

<span class="k">struct</span> <span class="n">pvscsi_sg_list</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">PVSCSISGElement</span> <span class="n">sge</span><span class="p">[</span><span class="n">PVSCSI_MAX_NUM_SG_ENTRIES_PER_SEGMENT</span><span class="p">];</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">pvscsi_ctx</span> <span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * The index of the context in cmd_map serves as the context ID for a</span>
<span class="cm">	 * 1-to-1 mapping completions back to requests.</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">scsi_cmnd</span>	<span class="o">*</span><span class="n">cmd</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pvscsi_sg_list</span>	<span class="o">*</span><span class="n">sgl</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">list</span><span class="p">;</span>
	<span class="n">dma_addr_t</span>		<span class="n">dataPA</span><span class="p">;</span>
	<span class="n">dma_addr_t</span>		<span class="n">sensePA</span><span class="p">;</span>
	<span class="n">dma_addr_t</span>		<span class="n">sglPA</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">pvscsi_adapter</span> <span class="p">{</span>
	<span class="kt">char</span>				<span class="o">*</span><span class="n">mmioBase</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>			<span class="n">irq</span><span class="p">;</span>
	<span class="n">u8</span>				<span class="n">rev</span><span class="p">;</span>
	<span class="n">bool</span>				<span class="n">use_msi</span><span class="p">;</span>
	<span class="n">bool</span>				<span class="n">use_msix</span><span class="p">;</span>
	<span class="n">bool</span>				<span class="n">use_msg</span><span class="p">;</span>

	<span class="n">spinlock_t</span>			<span class="n">hw_lock</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">workqueue_struct</span>		<span class="o">*</span><span class="n">workqueue</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">work_struct</span>		<span class="n">work</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">PVSCSIRingReqDesc</span>	<span class="o">*</span><span class="n">req_ring</span><span class="p">;</span>
	<span class="kt">unsigned</span>			<span class="n">req_pages</span><span class="p">;</span>
	<span class="kt">unsigned</span>			<span class="n">req_depth</span><span class="p">;</span>
	<span class="n">dma_addr_t</span>			<span class="n">reqRingPA</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">PVSCSIRingCmpDesc</span>	<span class="o">*</span><span class="n">cmp_ring</span><span class="p">;</span>
	<span class="kt">unsigned</span>			<span class="n">cmp_pages</span><span class="p">;</span>
	<span class="n">dma_addr_t</span>			<span class="n">cmpRingPA</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">PVSCSIRingMsgDesc</span>	<span class="o">*</span><span class="n">msg_ring</span><span class="p">;</span>
	<span class="kt">unsigned</span>			<span class="n">msg_pages</span><span class="p">;</span>
	<span class="n">dma_addr_t</span>			<span class="n">msgRingPA</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">PVSCSIRingsState</span>		<span class="o">*</span><span class="n">rings_state</span><span class="p">;</span>
	<span class="n">dma_addr_t</span>			<span class="n">ringStatePA</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">pci_dev</span>			<span class="o">*</span><span class="n">dev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span>		<span class="o">*</span><span class="n">host</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">list_head</span>		<span class="n">cmd_pool</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pvscsi_ctx</span>		<span class="o">*</span><span class="n">cmd_map</span><span class="p">;</span>
<span class="p">};</span>


<span class="cm">/* Command line parameters */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">pvscsi_ring_pages</span>     <span class="o">=</span> <span class="n">PVSCSI_DEFAULT_NUM_PAGES_PER_RING</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">pvscsi_msg_ring_pages</span> <span class="o">=</span> <span class="n">PVSCSI_DEFAULT_NUM_PAGES_MSG_RING</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">pvscsi_cmd_per_lun</span>    <span class="o">=</span> <span class="n">PVSCSI_DEFAULT_QUEUE_DEPTH</span><span class="p">;</span>
<span class="k">static</span> <span class="n">bool</span> <span class="n">pvscsi_disable_msi</span><span class="p">;</span>
<span class="k">static</span> <span class="n">bool</span> <span class="n">pvscsi_disable_msix</span><span class="p">;</span>
<span class="k">static</span> <span class="n">bool</span> <span class="n">pvscsi_use_msg</span>       <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>

<span class="cp">#define PVSCSI_RW (S_IRUSR | S_IWUSR)</span>

<span class="n">module_param_named</span><span class="p">(</span><span class="n">ring_pages</span><span class="p">,</span> <span class="n">pvscsi_ring_pages</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="n">PVSCSI_RW</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">ring_pages</span><span class="p">,</span> <span class="s">&quot;Number of pages per req/cmp ring - (default=&quot;</span>
		 <span class="n">__stringify</span><span class="p">(</span><span class="n">PVSCSI_DEFAULT_NUM_PAGES_PER_RING</span><span class="p">)</span> <span class="s">&quot;)&quot;</span><span class="p">);</span>

<span class="n">module_param_named</span><span class="p">(</span><span class="n">msg_ring_pages</span><span class="p">,</span> <span class="n">pvscsi_msg_ring_pages</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="n">PVSCSI_RW</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">msg_ring_pages</span><span class="p">,</span> <span class="s">&quot;Number of pages for the msg ring - (default=&quot;</span>
		 <span class="n">__stringify</span><span class="p">(</span><span class="n">PVSCSI_DEFAULT_NUM_PAGES_MSG_RING</span><span class="p">)</span> <span class="s">&quot;)&quot;</span><span class="p">);</span>

<span class="n">module_param_named</span><span class="p">(</span><span class="n">cmd_per_lun</span><span class="p">,</span> <span class="n">pvscsi_cmd_per_lun</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="n">PVSCSI_RW</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">cmd_per_lun</span><span class="p">,</span> <span class="s">&quot;Maximum commands per lun - (default=&quot;</span>
		 <span class="n">__stringify</span><span class="p">(</span><span class="n">PVSCSI_MAX_REQ_QUEUE_DEPTH</span><span class="p">)</span> <span class="s">&quot;)&quot;</span><span class="p">);</span>

<span class="n">module_param_named</span><span class="p">(</span><span class="n">disable_msi</span><span class="p">,</span> <span class="n">pvscsi_disable_msi</span><span class="p">,</span> <span class="n">bool</span><span class="p">,</span> <span class="n">PVSCSI_RW</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">disable_msi</span><span class="p">,</span> <span class="s">&quot;Disable MSI use in driver - (default=0)&quot;</span><span class="p">);</span>

<span class="n">module_param_named</span><span class="p">(</span><span class="n">disable_msix</span><span class="p">,</span> <span class="n">pvscsi_disable_msix</span><span class="p">,</span> <span class="n">bool</span><span class="p">,</span> <span class="n">PVSCSI_RW</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">disable_msix</span><span class="p">,</span> <span class="s">&quot;Disable MSI-X use in driver - (default=0)&quot;</span><span class="p">);</span>

<span class="n">module_param_named</span><span class="p">(</span><span class="n">use_msg</span><span class="p">,</span> <span class="n">pvscsi_use_msg</span><span class="p">,</span> <span class="n">bool</span><span class="p">,</span> <span class="n">PVSCSI_RW</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">use_msg</span><span class="p">,</span> <span class="s">&quot;Use msg ring when available - (default=1)&quot;</span><span class="p">);</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">pci_device_id</span> <span class="n">pvscsi_pci_tbl</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">{</span> <span class="n">PCI_VDEVICE</span><span class="p">(</span><span class="n">VMWARE</span><span class="p">,</span> <span class="n">PCI_DEVICE_ID_VMWARE_PVSCSI</span><span class="p">)</span> <span class="p">},</span>
	<span class="p">{</span> <span class="mi">0</span> <span class="p">}</span>
<span class="p">};</span>

<span class="n">MODULE_DEVICE_TABLE</span><span class="p">(</span><span class="n">pci</span><span class="p">,</span> <span class="n">pvscsi_pci_tbl</span><span class="p">);</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">device</span> <span class="o">*</span>
<span class="nf">pvscsi_dev</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">pvscsi_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">pvscsi_ctx</span> <span class="o">*</span>
<span class="nf">pvscsi_find_context</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">pvscsi_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">,</span> <span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pvscsi_ctx</span> <span class="o">*</span><span class="n">ctx</span><span class="p">,</span> <span class="o">*</span><span class="n">end</span><span class="p">;</span>

	<span class="n">end</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">cmd_map</span><span class="p">[</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">req_depth</span><span class="p">];</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">ctx</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">cmd_map</span><span class="p">;</span> <span class="n">ctx</span> <span class="o">&lt;</span> <span class="n">end</span><span class="p">;</span> <span class="n">ctx</span><span class="o">++</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">cmd</span> <span class="o">==</span> <span class="n">cmd</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">ctx</span><span class="p">;</span>

	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">pvscsi_ctx</span> <span class="o">*</span>
<span class="nf">pvscsi_acquire_context</span><span class="p">(</span><span class="k">struct</span> <span class="n">pvscsi_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">,</span> <span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pvscsi_ctx</span> <span class="o">*</span><span class="n">ctx</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">cmd_pool</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">ctx</span> <span class="o">=</span> <span class="n">list_first_entry</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">cmd_pool</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pvscsi_ctx</span><span class="p">,</span> <span class="n">list</span><span class="p">);</span>
	<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">cmd</span> <span class="o">=</span> <span class="n">cmd</span><span class="p">;</span>
	<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ctx</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">pvscsi_release_context</span><span class="p">(</span><span class="k">struct</span> <span class="n">pvscsi_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">pvscsi_ctx</span> <span class="o">*</span><span class="n">ctx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">cmd</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">cmd_pool</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Map a pvscsi_ctx struct to a context ID field value; we map to a simple</span>
<span class="cm"> * non-zero integer. ctx always points to an entry in cmd_map array, hence</span>
<span class="cm"> * the return value is always &gt;=1.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">u64</span> <span class="nf">pvscsi_map_context</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">pvscsi_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">,</span>
			      <span class="k">const</span> <span class="k">struct</span> <span class="n">pvscsi_ctx</span> <span class="o">*</span><span class="n">ctx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">ctx</span> <span class="o">-</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">cmd_map</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">pvscsi_ctx</span> <span class="o">*</span>
<span class="nf">pvscsi_get_context</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">pvscsi_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">,</span> <span class="n">u64</span> <span class="n">context</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">cmd_map</span><span class="p">[</span><span class="n">context</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">pvscsi_reg_write</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">pvscsi_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">,</span>
			     <span class="n">u32</span> <span class="n">offset</span><span class="p">,</span> <span class="n">u32</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">mmioBase</span> <span class="o">+</span> <span class="n">offset</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">u32</span> <span class="nf">pvscsi_reg_read</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">pvscsi_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">,</span> <span class="n">u32</span> <span class="n">offset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">readl</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">mmioBase</span> <span class="o">+</span> <span class="n">offset</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">u32</span> <span class="nf">pvscsi_read_intr_status</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">pvscsi_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">pvscsi_reg_read</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">PVSCSI_REG_OFFSET_INTR_STATUS</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">pvscsi_write_intr_status</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">pvscsi_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">,</span>
				     <span class="n">u32</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pvscsi_reg_write</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">PVSCSI_REG_OFFSET_INTR_STATUS</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">pvscsi_unmask_intr</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">pvscsi_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">intr_bits</span><span class="p">;</span>

	<span class="n">intr_bits</span> <span class="o">=</span> <span class="n">PVSCSI_INTR_CMPL_MASK</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">use_msg</span><span class="p">)</span>
		<span class="n">intr_bits</span> <span class="o">|=</span> <span class="n">PVSCSI_INTR_MSG_MASK</span><span class="p">;</span>

	<span class="n">pvscsi_reg_write</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">PVSCSI_REG_OFFSET_INTR_MASK</span><span class="p">,</span> <span class="n">intr_bits</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">pvscsi_mask_intr</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">pvscsi_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pvscsi_reg_write</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">PVSCSI_REG_OFFSET_INTR_MASK</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">pvscsi_write_cmd_desc</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">pvscsi_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">,</span>
				  <span class="n">u32</span> <span class="n">cmd</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">desc</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="n">u32</span> <span class="o">*</span><span class="n">ptr</span> <span class="o">=</span> <span class="n">desc</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">len</span> <span class="o">/=</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">ptr</span><span class="p">);</span>
	<span class="n">pvscsi_reg_write</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">PVSCSI_REG_OFFSET_COMMAND</span><span class="p">,</span> <span class="n">cmd</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">len</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">pvscsi_reg_write</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span>
				 <span class="n">PVSCSI_REG_OFFSET_COMMAND_DATA</span><span class="p">,</span> <span class="n">ptr</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">pvscsi_abort_cmd</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">pvscsi_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">,</span>
			     <span class="k">const</span> <span class="k">struct</span> <span class="n">pvscsi_ctx</span> <span class="o">*</span><span class="n">ctx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">PVSCSICmdDescAbortCmd</span> <span class="n">cmd</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">0</span> <span class="p">};</span>

	<span class="n">cmd</span><span class="p">.</span><span class="n">target</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">;</span>
	<span class="n">cmd</span><span class="p">.</span><span class="n">context</span> <span class="o">=</span> <span class="n">pvscsi_map_context</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">ctx</span><span class="p">);</span>

	<span class="n">pvscsi_write_cmd_desc</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">PVSCSI_CMD_ABORT_CMD</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cmd</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">cmd</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">pvscsi_kick_rw_io</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">pvscsi_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pvscsi_reg_write</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">PVSCSI_REG_OFFSET_KICK_RW_IO</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">pvscsi_process_request_ring</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">pvscsi_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pvscsi_reg_write</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">PVSCSI_REG_OFFSET_KICK_NON_RW_IO</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">scsi_is_rw</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">op</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">op</span> <span class="o">==</span> <span class="n">READ_6</span>  <span class="o">||</span> <span class="n">op</span> <span class="o">==</span> <span class="n">WRITE_6</span> <span class="o">||</span>
	       <span class="n">op</span> <span class="o">==</span> <span class="n">READ_10</span> <span class="o">||</span> <span class="n">op</span> <span class="o">==</span> <span class="n">WRITE_10</span> <span class="o">||</span>
	       <span class="n">op</span> <span class="o">==</span> <span class="n">READ_12</span> <span class="o">||</span> <span class="n">op</span> <span class="o">==</span> <span class="n">WRITE_12</span> <span class="o">||</span>
	       <span class="n">op</span> <span class="o">==</span> <span class="n">READ_16</span> <span class="o">||</span> <span class="n">op</span> <span class="o">==</span> <span class="n">WRITE_16</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">pvscsi_kick_io</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">pvscsi_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">,</span>
			   <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">op</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">scsi_is_rw</span><span class="p">(</span><span class="n">op</span><span class="p">))</span>
		<span class="n">pvscsi_kick_rw_io</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">pvscsi_process_request_ring</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">ll_adapter_reset</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">pvscsi_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">dev_dbg</span><span class="p">(</span><span class="n">pvscsi_dev</span><span class="p">(</span><span class="n">adapter</span><span class="p">),</span> <span class="s">&quot;Adapter Reset on %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">adapter</span><span class="p">);</span>

	<span class="n">pvscsi_write_cmd_desc</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">PVSCSI_CMD_ADAPTER_RESET</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">ll_bus_reset</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">pvscsi_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">dev_dbg</span><span class="p">(</span><span class="n">pvscsi_dev</span><span class="p">(</span><span class="n">adapter</span><span class="p">),</span> <span class="s">&quot;Reseting bus on %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">adapter</span><span class="p">);</span>

	<span class="n">pvscsi_write_cmd_desc</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">PVSCSI_CMD_RESET_BUS</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">ll_device_reset</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">pvscsi_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">,</span> <span class="n">u32</span> <span class="n">target</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">PVSCSICmdDescResetDevice</span> <span class="n">cmd</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">0</span> <span class="p">};</span>

	<span class="n">dev_dbg</span><span class="p">(</span><span class="n">pvscsi_dev</span><span class="p">(</span><span class="n">adapter</span><span class="p">),</span> <span class="s">&quot;Reseting device: target=%u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">target</span><span class="p">);</span>

	<span class="n">cmd</span><span class="p">.</span><span class="n">target</span> <span class="o">=</span> <span class="n">target</span><span class="p">;</span>

	<span class="n">pvscsi_write_cmd_desc</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">PVSCSI_CMD_RESET_DEVICE</span><span class="p">,</span>
			      <span class="o">&amp;</span><span class="n">cmd</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">cmd</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">pvscsi_create_sg</span><span class="p">(</span><span class="k">struct</span> <span class="n">pvscsi_ctx</span> <span class="o">*</span><span class="n">ctx</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">scatterlist</span> <span class="o">*</span><span class="n">sg</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">PVSCSISGElement</span> <span class="o">*</span><span class="n">sge</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">count</span> <span class="o">&gt;</span> <span class="n">PVSCSI_MAX_NUM_SG_ENTRIES_PER_SEGMENT</span><span class="p">);</span>

	<span class="n">sge</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">sgl</span><span class="o">-&gt;</span><span class="n">sge</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">,</span> <span class="n">sg</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">sge</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">addr</span>   <span class="o">=</span> <span class="n">sg_dma_address</span><span class="p">(</span><span class="n">sg</span><span class="p">);</span>
		<span class="n">sge</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">length</span> <span class="o">=</span> <span class="n">sg_dma_len</span><span class="p">(</span><span class="n">sg</span><span class="p">);</span>
		<span class="n">sge</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">flags</span>  <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Map all data buffers for a command into PCI space and</span>
<span class="cm"> * setup the scatter/gather list if needed.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">pvscsi_map_buffers</span><span class="p">(</span><span class="k">struct</span> <span class="n">pvscsi_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">pvscsi_ctx</span> <span class="o">*</span><span class="n">ctx</span><span class="p">,</span> <span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">PVSCSIRingReqDesc</span> <span class="o">*</span><span class="n">e</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="n">count</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">bufflen</span> <span class="o">=</span> <span class="n">scsi_bufflen</span><span class="p">(</span><span class="n">cmd</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">scatterlist</span> <span class="o">*</span><span class="n">sg</span><span class="p">;</span>

	<span class="n">e</span><span class="o">-&gt;</span><span class="n">dataLen</span> <span class="o">=</span> <span class="n">bufflen</span><span class="p">;</span>
	<span class="n">e</span><span class="o">-&gt;</span><span class="n">dataAddr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bufflen</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">sg</span> <span class="o">=</span> <span class="n">scsi_sglist</span><span class="p">(</span><span class="n">cmd</span><span class="p">);</span>
	<span class="n">count</span> <span class="o">=</span> <span class="n">scsi_sg_count</span><span class="p">(</span><span class="n">cmd</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">segs</span> <span class="o">=</span> <span class="n">scsi_dma_map</span><span class="p">(</span><span class="n">cmd</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">segs</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pvscsi_create_sg</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">sg</span><span class="p">,</span> <span class="n">segs</span><span class="p">);</span>

			<span class="n">e</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">PVSCSI_FLAG_CMD_WITH_SG_LIST</span><span class="p">;</span>
			<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">sglPA</span> <span class="o">=</span> <span class="n">pci_map_single</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">sgl</span><span class="p">,</span>
						    <span class="n">SGL_SIZE</span><span class="p">,</span> <span class="n">PCI_DMA_TODEVICE</span><span class="p">);</span>
			<span class="n">e</span><span class="o">-&gt;</span><span class="n">dataAddr</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">sglPA</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="n">e</span><span class="o">-&gt;</span><span class="n">dataAddr</span> <span class="o">=</span> <span class="n">sg_dma_address</span><span class="p">(</span><span class="n">sg</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * In case there is no S/G list, scsi_sglist points</span>
<span class="cm">		 * directly to the buffer.</span>
<span class="cm">		 */</span>
		<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">dataPA</span> <span class="o">=</span> <span class="n">pci_map_single</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">sg</span><span class="p">,</span> <span class="n">bufflen</span><span class="p">,</span>
					     <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">sc_data_direction</span><span class="p">);</span>
		<span class="n">e</span><span class="o">-&gt;</span><span class="n">dataAddr</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">dataPA</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">pvscsi_unmap_buffers</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">pvscsi_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">pvscsi_ctx</span> <span class="o">*</span><span class="n">ctx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">bufflen</span><span class="p">;</span>

	<span class="n">cmd</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">cmd</span><span class="p">;</span>
	<span class="n">bufflen</span> <span class="o">=</span> <span class="n">scsi_bufflen</span><span class="p">(</span><span class="n">cmd</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">bufflen</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="n">count</span> <span class="o">=</span> <span class="n">scsi_sg_count</span><span class="p">(</span><span class="n">cmd</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">scsi_dma_unmap</span><span class="p">(</span><span class="n">cmd</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">sglPA</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">pci_unmap_single</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">sglPA</span><span class="p">,</span>
						 <span class="n">SGL_SIZE</span><span class="p">,</span> <span class="n">PCI_DMA_TODEVICE</span><span class="p">);</span>
				<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">sglPA</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="n">pci_unmap_single</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">dataPA</span><span class="p">,</span> <span class="n">bufflen</span><span class="p">,</span>
					 <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">sc_data_direction</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">sense_buffer</span><span class="p">)</span>
		<span class="n">pci_unmap_single</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">sensePA</span><span class="p">,</span>
				 <span class="n">SCSI_SENSE_BUFFERSIZE</span><span class="p">,</span> <span class="n">PCI_DMA_FROMDEVICE</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__devinit</span> <span class="nf">pvscsi_allocate_rings</span><span class="p">(</span><span class="k">struct</span> <span class="n">pvscsi_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rings_state</span> <span class="o">=</span> <span class="n">pci_alloc_consistent</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">PAGE_SIZE</span><span class="p">,</span>
						    <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">ringStatePA</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rings_state</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">req_pages</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">PVSCSI_MAX_NUM_PAGES_REQ_RING</span><span class="p">,</span>
				 <span class="n">pvscsi_ring_pages</span><span class="p">);</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">req_depth</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">req_pages</span>
					<span class="o">*</span> <span class="n">PVSCSI_MAX_NUM_REQ_ENTRIES_PER_PAGE</span><span class="p">;</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">req_ring</span> <span class="o">=</span> <span class="n">pci_alloc_consistent</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
						 <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">req_pages</span> <span class="o">*</span> <span class="n">PAGE_SIZE</span><span class="p">,</span>
						 <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">reqRingPA</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">req_ring</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">cmp_pages</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">PVSCSI_MAX_NUM_PAGES_CMP_RING</span><span class="p">,</span>
				 <span class="n">pvscsi_ring_pages</span><span class="p">);</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">cmp_ring</span> <span class="o">=</span> <span class="n">pci_alloc_consistent</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
						 <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">cmp_pages</span> <span class="o">*</span> <span class="n">PAGE_SIZE</span><span class="p">,</span>
						 <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">cmpRingPA</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">cmp_ring</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">IS_ALIGNED</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">ringStatePA</span><span class="p">,</span> <span class="n">PAGE_SIZE</span><span class="p">));</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">IS_ALIGNED</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">reqRingPA</span><span class="p">,</span> <span class="n">PAGE_SIZE</span><span class="p">));</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">IS_ALIGNED</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">cmpRingPA</span><span class="p">,</span> <span class="n">PAGE_SIZE</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">use_msg</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">msg_pages</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">PVSCSI_MAX_NUM_PAGES_MSG_RING</span><span class="p">,</span>
				 <span class="n">pvscsi_msg_ring_pages</span><span class="p">);</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">msg_ring</span> <span class="o">=</span> <span class="n">pci_alloc_consistent</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
						 <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">msg_pages</span> <span class="o">*</span> <span class="n">PAGE_SIZE</span><span class="p">,</span>
						 <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">msgRingPA</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">msg_ring</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">IS_ALIGNED</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">msgRingPA</span><span class="p">,</span> <span class="n">PAGE_SIZE</span><span class="p">));</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">pvscsi_setup_all_rings</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">pvscsi_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">PVSCSICmdDescSetupRings</span> <span class="n">cmd</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">0</span> <span class="p">};</span>
	<span class="n">dma_addr_t</span> <span class="n">base</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">cmd</span><span class="p">.</span><span class="n">ringsStatePPN</span>   <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">ringStatePA</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>
	<span class="n">cmd</span><span class="p">.</span><span class="n">reqRingNumPages</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">req_pages</span><span class="p">;</span>
	<span class="n">cmd</span><span class="p">.</span><span class="n">cmpRingNumPages</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">cmp_pages</span><span class="p">;</span>

	<span class="n">base</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">reqRingPA</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">req_pages</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cmd</span><span class="p">.</span><span class="n">reqRingPPNs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">base</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>
		<span class="n">base</span> <span class="o">+=</span> <span class="n">PAGE_SIZE</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">base</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">cmpRingPA</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">cmp_pages</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cmd</span><span class="p">.</span><span class="n">cmpRingPPNs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">base</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>
		<span class="n">base</span> <span class="o">+=</span> <span class="n">PAGE_SIZE</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">memset</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rings_state</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">PAGE_SIZE</span><span class="p">);</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">req_ring</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">req_pages</span> <span class="o">*</span> <span class="n">PAGE_SIZE</span><span class="p">);</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">cmp_ring</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">cmp_pages</span> <span class="o">*</span> <span class="n">PAGE_SIZE</span><span class="p">);</span>

	<span class="n">pvscsi_write_cmd_desc</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">PVSCSI_CMD_SETUP_RINGS</span><span class="p">,</span>
			      <span class="o">&amp;</span><span class="n">cmd</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">cmd</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">use_msg</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">PVSCSICmdDescSetupMsgRing</span> <span class="n">cmd_msg</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">0</span> <span class="p">};</span>

		<span class="n">cmd_msg</span><span class="p">.</span><span class="n">numPages</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">msg_pages</span><span class="p">;</span>

		<span class="n">base</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">msgRingPA</span><span class="p">;</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">msg_pages</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">cmd_msg</span><span class="p">.</span><span class="n">ringPPNs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">base</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>
			<span class="n">base</span> <span class="o">+=</span> <span class="n">PAGE_SIZE</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">memset</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">msg_ring</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">msg_pages</span> <span class="o">*</span> <span class="n">PAGE_SIZE</span><span class="p">);</span>

		<span class="n">pvscsi_write_cmd_desc</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">PVSCSI_CMD_SETUP_MSG_RING</span><span class="p">,</span>
				      <span class="o">&amp;</span><span class="n">cmd_msg</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">cmd_msg</span><span class="p">));</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Pull a completion descriptor off and pass the completion back</span>
<span class="cm"> * to the SCSI mid layer.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">pvscsi_complete_request</span><span class="p">(</span><span class="k">struct</span> <span class="n">pvscsi_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">,</span>
				    <span class="k">const</span> <span class="k">struct</span> <span class="n">PVSCSIRingCmpDesc</span> <span class="o">*</span><span class="n">e</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pvscsi_ctx</span> <span class="o">*</span><span class="n">ctx</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">btstat</span> <span class="o">=</span> <span class="n">e</span><span class="o">-&gt;</span><span class="n">hostStatus</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">sdstat</span> <span class="o">=</span> <span class="n">e</span><span class="o">-&gt;</span><span class="n">scsiStatus</span><span class="p">;</span>

	<span class="n">ctx</span> <span class="o">=</span> <span class="n">pvscsi_get_context</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">e</span><span class="o">-&gt;</span><span class="n">context</span><span class="p">);</span>
	<span class="n">cmd</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">cmd</span><span class="p">;</span>
	<span class="n">pvscsi_unmap_buffers</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">ctx</span><span class="p">);</span>
	<span class="n">pvscsi_release_context</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">ctx</span><span class="p">);</span>
	<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sdstat</span> <span class="o">!=</span> <span class="n">SAM_STAT_GOOD</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">btstat</span> <span class="o">==</span> <span class="n">BTSTAT_SUCCESS</span> <span class="o">||</span>
	     <span class="n">btstat</span> <span class="o">==</span> <span class="n">BTSTAT_LINKED_COMMAND_COMPLETED</span> <span class="o">||</span>
	     <span class="n">btstat</span> <span class="o">==</span> <span class="n">BTSTAT_LINKED_COMMAND_COMPLETED_WITH_FLAG</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">=</span> <span class="p">(</span><span class="n">DID_OK</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">|</span> <span class="n">sdstat</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sdstat</span> <span class="o">==</span> <span class="n">SAM_STAT_CHECK_CONDITION</span> <span class="o">&amp;&amp;</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">sense_buffer</span><span class="p">)</span>
			<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">|=</span> <span class="p">(</span><span class="n">DRIVER_SENSE</span> <span class="o">&lt;&lt;</span> <span class="mi">24</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">btstat</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">BTSTAT_SUCCESS</span>:
		<span class="k">case</span> <span class="n">BTSTAT_LINKED_COMMAND_COMPLETED</span>:
		<span class="k">case</span> <span class="n">BTSTAT_LINKED_COMMAND_COMPLETED_WITH_FLAG</span>:
			<span class="cm">/* If everything went fine, let&#39;s move on..  */</span>
			<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">=</span> <span class="p">(</span><span class="n">DID_OK</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">BTSTAT_DATARUN</span>:
		<span class="k">case</span> <span class="n">BTSTAT_DATA_UNDERRUN</span>:
			<span class="cm">/* Report residual data in underruns */</span>
			<span class="n">scsi_set_resid</span><span class="p">(</span><span class="n">cmd</span><span class="p">,</span> <span class="n">scsi_bufflen</span><span class="p">(</span><span class="n">cmd</span><span class="p">)</span> <span class="o">-</span> <span class="n">e</span><span class="o">-&gt;</span><span class="n">dataLen</span><span class="p">);</span>
			<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">=</span> <span class="p">(</span><span class="n">DID_ERROR</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">BTSTAT_SELTIMEO</span>:
			<span class="cm">/* Our emulation returns this for non-connected devs */</span>
			<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">=</span> <span class="p">(</span><span class="n">DID_BAD_TARGET</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">BTSTAT_LUNMISMATCH</span>:
		<span class="k">case</span> <span class="n">BTSTAT_TAGREJECT</span>:
		<span class="k">case</span> <span class="n">BTSTAT_BADMSG</span>:
			<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">=</span> <span class="p">(</span><span class="n">DRIVER_INVALID</span> <span class="o">&lt;&lt;</span> <span class="mi">24</span><span class="p">);</span>
			<span class="cm">/* fall through */</span>

		<span class="k">case</span> <span class="n">BTSTAT_HAHARDWARE</span>:
		<span class="k">case</span> <span class="n">BTSTAT_INVPHASE</span>:
		<span class="k">case</span> <span class="n">BTSTAT_HATIMEOUT</span>:
		<span class="k">case</span> <span class="n">BTSTAT_NORESPONSE</span>:
		<span class="k">case</span> <span class="n">BTSTAT_DISCONNECT</span>:
		<span class="k">case</span> <span class="n">BTSTAT_HASOFTWARE</span>:
		<span class="k">case</span> <span class="n">BTSTAT_BUSFREE</span>:
		<span class="k">case</span> <span class="n">BTSTAT_SENSFAILED</span>:
			<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">|=</span> <span class="p">(</span><span class="n">DID_ERROR</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">BTSTAT_SENTRST</span>:
		<span class="k">case</span> <span class="n">BTSTAT_RECVRST</span>:
		<span class="k">case</span> <span class="n">BTSTAT_BUSRESET</span>:
			<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">=</span> <span class="p">(</span><span class="n">DID_RESET</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">BTSTAT_ABORTQUEUE</span>:
			<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">=</span> <span class="p">(</span><span class="n">DID_ABORT</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">BTSTAT_SCSIPARITY</span>:
			<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">=</span> <span class="p">(</span><span class="n">DID_PARITY</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="nl">default:</span>
			<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">=</span> <span class="p">(</span><span class="n">DID_ERROR</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">);</span>
			<span class="n">scmd_printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span><span class="p">,</span> <span class="n">cmd</span><span class="p">,</span>
				    <span class="s">&quot;Unknown completion status: 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				    <span class="n">btstat</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">sdev_gendev</span><span class="p">,</span>
		<span class="s">&quot;cmd=%p %x ctx=%p result=0x%x status=0x%x,%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">cmd</span><span class="p">,</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">ctx</span><span class="p">,</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">result</span><span class="p">,</span> <span class="n">btstat</span><span class="p">,</span> <span class="n">sdstat</span><span class="p">);</span>

	<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scsi_done</span><span class="p">(</span><span class="n">cmd</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * barrier usage : Since the PVSCSI device is emulated, there could be cases</span>
<span class="cm"> * where we may want to serialize some accesses between the driver and the</span>
<span class="cm"> * emulation layer. We use compiler barriers instead of the more expensive</span>
<span class="cm"> * memory barriers because PVSCSI is only supported on X86 which has strong</span>
<span class="cm"> * memory access ordering.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">pvscsi_process_completion_ring</span><span class="p">(</span><span class="k">struct</span> <span class="n">pvscsi_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">PVSCSIRingsState</span> <span class="o">*</span><span class="n">s</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rings_state</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">PVSCSIRingCmpDesc</span> <span class="o">*</span><span class="n">ring</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">cmp_ring</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">cmp_entries</span> <span class="o">=</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">cmpNumEntriesLog2</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">cmpConsIdx</span> <span class="o">!=</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">cmpProdIdx</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">PVSCSIRingCmpDesc</span> <span class="o">*</span><span class="n">e</span> <span class="o">=</span> <span class="n">ring</span> <span class="o">+</span> <span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">cmpConsIdx</span> <span class="o">&amp;</span>
						      <span class="n">MASK</span><span class="p">(</span><span class="n">cmp_entries</span><span class="p">));</span>
		<span class="cm">/*</span>
<span class="cm">		 * This barrier() ensures that *e is not dereferenced while</span>
<span class="cm">		 * the device emulation still writes data into the slot.</span>
<span class="cm">		 * Since the device emulation advances s-&gt;cmpProdIdx only after</span>
<span class="cm">		 * updating the slot we want to check it first.</span>
<span class="cm">		 */</span>
		<span class="n">barrier</span><span class="p">();</span>
		<span class="n">pvscsi_complete_request</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">e</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * This barrier() ensures that compiler doesn&#39;t reorder write</span>
<span class="cm">		 * to s-&gt;cmpConsIdx before the read of (*e) inside</span>
<span class="cm">		 * pvscsi_complete_request. Otherwise, device emulation may</span>
<span class="cm">		 * overwrite *e before we had a chance to read it.</span>
<span class="cm">		 */</span>
		<span class="n">barrier</span><span class="p">();</span>
		<span class="n">s</span><span class="o">-&gt;</span><span class="n">cmpConsIdx</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Translate a Linux SCSI request into a request ring entry.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">pvscsi_queue_ring</span><span class="p">(</span><span class="k">struct</span> <span class="n">pvscsi_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">pvscsi_ctx</span> <span class="o">*</span><span class="n">ctx</span><span class="p">,</span> <span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">PVSCSIRingsState</span> <span class="o">*</span><span class="n">s</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">PVSCSIRingReqDesc</span> <span class="o">*</span><span class="n">e</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="n">sdev</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">req_entries</span><span class="p">;</span>

	<span class="n">s</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rings_state</span><span class="p">;</span>
	<span class="n">sdev</span> <span class="o">=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">device</span><span class="p">;</span>
	<span class="n">req_entries</span> <span class="o">=</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">reqNumEntriesLog2</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * If this condition holds, we might have room on the request ring, but</span>
<span class="cm">	 * we might not have room on the completion ring for the response.</span>
<span class="cm">	 * However, we have already ruled out this possibility - we would not</span>
<span class="cm">	 * have successfully allocated a context if it were true, since we only</span>
<span class="cm">	 * have one context per request entry.  Check for it anyway, since it</span>
<span class="cm">	 * would be a serious bug.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">reqProdIdx</span> <span class="o">-</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">cmpConsIdx</span> <span class="o">&gt;=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">req_entries</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">scmd_printk</span><span class="p">(</span><span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">cmd</span><span class="p">,</span> <span class="s">&quot;vmw_pvscsi: &quot;</span>
			    <span class="s">&quot;ring full: reqProdIdx=%d cmpConsIdx=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			    <span class="n">s</span><span class="o">-&gt;</span><span class="n">reqProdIdx</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">cmpConsIdx</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">e</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">req_ring</span> <span class="o">+</span> <span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">reqProdIdx</span> <span class="o">&amp;</span> <span class="n">MASK</span><span class="p">(</span><span class="n">req_entries</span><span class="p">));</span>

	<span class="n">e</span><span class="o">-&gt;</span><span class="n">bus</span>    <span class="o">=</span> <span class="n">sdev</span><span class="o">-&gt;</span><span class="n">channel</span><span class="p">;</span>
	<span class="n">e</span><span class="o">-&gt;</span><span class="n">target</span> <span class="o">=</span> <span class="n">sdev</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">;</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">lun</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">lun</span><span class="p">));</span>
	<span class="n">e</span><span class="o">-&gt;</span><span class="n">lun</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">sdev</span><span class="o">-&gt;</span><span class="n">lun</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">sense_buffer</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">sensePA</span> <span class="o">=</span> <span class="n">pci_map_single</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">sense_buffer</span><span class="p">,</span>
					      <span class="n">SCSI_SENSE_BUFFERSIZE</span><span class="p">,</span>
					      <span class="n">PCI_DMA_FROMDEVICE</span><span class="p">);</span>
		<span class="n">e</span><span class="o">-&gt;</span><span class="n">senseAddr</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">sensePA</span><span class="p">;</span>
		<span class="n">e</span><span class="o">-&gt;</span><span class="n">senseLen</span> <span class="o">=</span> <span class="n">SCSI_SENSE_BUFFERSIZE</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">e</span><span class="o">-&gt;</span><span class="n">senseLen</span>  <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">e</span><span class="o">-&gt;</span><span class="n">senseAddr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">e</span><span class="o">-&gt;</span><span class="n">cdbLen</span>   <span class="o">=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">cmd_len</span><span class="p">;</span>
	<span class="n">e</span><span class="o">-&gt;</span><span class="n">vcpuHint</span> <span class="o">=</span> <span class="n">smp_processor_id</span><span class="p">();</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">cdb</span><span class="p">,</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">,</span> <span class="n">e</span><span class="o">-&gt;</span><span class="n">cdbLen</span><span class="p">);</span>

	<span class="n">e</span><span class="o">-&gt;</span><span class="n">tag</span> <span class="o">=</span> <span class="n">SIMPLE_QUEUE_TAG</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">tagged_supported</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">tag</span> <span class="o">==</span> <span class="n">HEAD_OF_QUEUE_TAG</span> <span class="o">||</span>
	     <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">tag</span> <span class="o">==</span> <span class="n">ORDERED_QUEUE_TAG</span><span class="p">))</span>
		<span class="n">e</span><span class="o">-&gt;</span><span class="n">tag</span> <span class="o">=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">tag</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">sc_data_direction</span> <span class="o">==</span> <span class="n">DMA_FROM_DEVICE</span><span class="p">)</span>
		<span class="n">e</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">=</span> <span class="n">PVSCSI_FLAG_CMD_DIR_TOHOST</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">sc_data_direction</span> <span class="o">==</span> <span class="n">DMA_TO_DEVICE</span><span class="p">)</span>
		<span class="n">e</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">=</span> <span class="n">PVSCSI_FLAG_CMD_DIR_TODEVICE</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">sc_data_direction</span> <span class="o">==</span> <span class="n">DMA_NONE</span><span class="p">)</span>
		<span class="n">e</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">=</span> <span class="n">PVSCSI_FLAG_CMD_DIR_NONE</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">e</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">pvscsi_map_buffers</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">ctx</span><span class="p">,</span> <span class="n">cmd</span><span class="p">,</span> <span class="n">e</span><span class="p">);</span>

	<span class="n">e</span><span class="o">-&gt;</span><span class="n">context</span> <span class="o">=</span> <span class="n">pvscsi_map_context</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">ctx</span><span class="p">);</span>

	<span class="n">barrier</span><span class="p">();</span>

	<span class="n">s</span><span class="o">-&gt;</span><span class="n">reqProdIdx</span><span class="o">++</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">pvscsi_queue_lck</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">,</span> <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">done</span><span class="p">)(</span><span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="p">))</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">host</span> <span class="o">=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pvscsi_adapter</span> <span class="o">*</span><span class="n">adapter</span> <span class="o">=</span> <span class="n">shost_priv</span><span class="p">(</span><span class="n">host</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">pvscsi_ctx</span> <span class="o">*</span><span class="n">ctx</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">ctx</span> <span class="o">=</span> <span class="n">pvscsi_acquire_context</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">cmd</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ctx</span> <span class="o">||</span> <span class="n">pvscsi_queue_ring</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">ctx</span><span class="p">,</span> <span class="n">cmd</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ctx</span><span class="p">)</span>
			<span class="n">pvscsi_release_context</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">ctx</span><span class="p">);</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">SCSI_MLQUEUE_HOST_BUSY</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scsi_done</span> <span class="o">=</span> <span class="n">done</span><span class="p">;</span>

	<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">sdev_gendev</span><span class="p">,</span>
		<span class="s">&quot;queued cmd %p, ctx %p, op=%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">cmd</span><span class="p">,</span> <span class="n">ctx</span><span class="p">,</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>

	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">pvscsi_kick_io</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="nf">DEF_SCSI_QCMD</span><span class="p">(</span><span class="n">pvscsi_queue</span><span class="p">)</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">pvscsi_abort</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pvscsi_adapter</span> <span class="o">*</span><span class="n">adapter</span> <span class="o">=</span> <span class="n">shost_priv</span><span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">pvscsi_ctx</span> <span class="o">*</span><span class="n">ctx</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">scmd_printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span><span class="p">,</span> <span class="n">cmd</span><span class="p">,</span> <span class="s">&quot;task abort on host %u, %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		    <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">host_no</span><span class="p">,</span> <span class="n">cmd</span><span class="p">);</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Poll the completion ring first - we might be trying to abort</span>
<span class="cm">	 * a command that is waiting to be dispatched in the completion ring.</span>
<span class="cm">	 */</span>
	<span class="n">pvscsi_process_completion_ring</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * If there is no context for the command, it either already succeeded</span>
<span class="cm">	 * or else was never properly issued.  Not our problem.</span>
<span class="cm">	 */</span>
	<span class="n">ctx</span> <span class="o">=</span> <span class="n">pvscsi_find_context</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">cmd</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ctx</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">scmd_printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span><span class="p">,</span> <span class="n">cmd</span><span class="p">,</span> <span class="s">&quot;Failed to abort cmd %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">cmd</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">pvscsi_abort_cmd</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">ctx</span><span class="p">);</span>

	<span class="n">pvscsi_process_completion_ring</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>

<span class="nl">out:</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">SUCCESS</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Abort all outstanding requests.  This is only safe to use if the completion</span>
<span class="cm"> * ring will never be walked again or the device has been reset, because it</span>
<span class="cm"> * destroys the 1-1 mapping between context field passed to emulation and our</span>
<span class="cm"> * request structure.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">pvscsi_reset_all</span><span class="p">(</span><span class="k">struct</span> <span class="n">pvscsi_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">req_depth</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">pvscsi_ctx</span> <span class="o">*</span><span class="n">ctx</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">cmd_map</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="n">cmd</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">cmd</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">scmd_printk</span><span class="p">(</span><span class="n">KERN_ERR</span><span class="p">,</span> <span class="n">cmd</span><span class="p">,</span>
				    <span class="s">&quot;Forced reset on cmd %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">cmd</span><span class="p">);</span>
			<span class="n">pvscsi_unmap_buffers</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">ctx</span><span class="p">);</span>
			<span class="n">pvscsi_release_context</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">ctx</span><span class="p">);</span>
			<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">=</span> <span class="p">(</span><span class="n">DID_RESET</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">);</span>
			<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scsi_done</span><span class="p">(</span><span class="n">cmd</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">pvscsi_host_reset</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">host</span> <span class="o">=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pvscsi_adapter</span> <span class="o">*</span><span class="n">adapter</span> <span class="o">=</span> <span class="n">shost_priv</span><span class="p">(</span><span class="n">host</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">use_msg</span><span class="p">;</span>

	<span class="n">scmd_printk</span><span class="p">(</span><span class="n">KERN_INFO</span><span class="p">,</span> <span class="n">cmd</span><span class="p">,</span> <span class="s">&quot;SCSI Host reset</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">use_msg</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">use_msg</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">use_msg</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">use_msg</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * Now that we know that the ISR won&#39;t add more work on the</span>
<span class="cm">		 * workqueue we can safely flush any outstanding work.</span>
<span class="cm">		 */</span>
		<span class="n">flush_workqueue</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">workqueue</span><span class="p">);</span>
		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * We&#39;re going to tear down the entire ring structure and set it back</span>
<span class="cm">	 * up, so stalling new requests until all completions are flushed and</span>
<span class="cm">	 * the rings are back in place.</span>
<span class="cm">	 */</span>

	<span class="n">pvscsi_process_request_ring</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>

	<span class="n">ll_adapter_reset</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Now process any completions.  Note we do this AFTER adapter reset,</span>
<span class="cm">	 * which is strange, but stops races where completions get posted</span>
<span class="cm">	 * between processing the ring and issuing the reset.  The backend will</span>
<span class="cm">	 * not touch the ring memory after reset, so the immediately pre-reset</span>
<span class="cm">	 * completion ring state is still valid.</span>
<span class="cm">	 */</span>
	<span class="n">pvscsi_process_completion_ring</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>

	<span class="n">pvscsi_reset_all</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">use_msg</span> <span class="o">=</span> <span class="n">use_msg</span><span class="p">;</span>
	<span class="n">pvscsi_setup_all_rings</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
	<span class="n">pvscsi_unmask_intr</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>

	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">SUCCESS</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">pvscsi_bus_reset</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">host</span> <span class="o">=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pvscsi_adapter</span> <span class="o">*</span><span class="n">adapter</span> <span class="o">=</span> <span class="n">shost_priv</span><span class="p">(</span><span class="n">host</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">scmd_printk</span><span class="p">(</span><span class="n">KERN_INFO</span><span class="p">,</span> <span class="n">cmd</span><span class="p">,</span> <span class="s">&quot;SCSI Bus reset</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * We don&#39;t want to queue new requests for this bus after</span>
<span class="cm">	 * flushing all pending requests to emulation, since new</span>
<span class="cm">	 * requests could then sneak in during this bus reset phase,</span>
<span class="cm">	 * so take the lock now.</span>
<span class="cm">	 */</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">pvscsi_process_request_ring</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
	<span class="n">ll_bus_reset</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
	<span class="n">pvscsi_process_completion_ring</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>

	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">SUCCESS</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">pvscsi_device_reset</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">host</span> <span class="o">=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pvscsi_adapter</span> <span class="o">*</span><span class="n">adapter</span> <span class="o">=</span> <span class="n">shost_priv</span><span class="p">(</span><span class="n">host</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">scmd_printk</span><span class="p">(</span><span class="n">KERN_INFO</span><span class="p">,</span> <span class="n">cmd</span><span class="p">,</span> <span class="s">&quot;SCSI device reset on scsi%u:%u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		    <span class="n">host</span><span class="o">-&gt;</span><span class="n">host_no</span><span class="p">,</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * We don&#39;t want to queue new requests for this device after flushing</span>
<span class="cm">	 * all pending requests to emulation, since new requests could then</span>
<span class="cm">	 * sneak in during this device reset phase, so take the lock now.</span>
<span class="cm">	 */</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">pvscsi_process_request_ring</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
	<span class="n">ll_device_reset</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">);</span>
	<span class="n">pvscsi_process_completion_ring</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>

	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">SUCCESS</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">scsi_host_template</span> <span class="n">pvscsi_template</span><span class="p">;</span>

<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="nf">pvscsi_info</span><span class="p">(</span><span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">host</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pvscsi_adapter</span> <span class="o">*</span><span class="n">adapter</span> <span class="o">=</span> <span class="n">shost_priv</span><span class="p">(</span><span class="n">host</span><span class="p">);</span>
	<span class="k">static</span> <span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="mi">256</span><span class="p">];</span>

	<span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;VMware PVSCSI storage adapter rev %d, req/cmp/msg rings: &quot;</span>
		<span class="s">&quot;%u/%u/%u pages, cmd_per_lun=%u&quot;</span><span class="p">,</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rev</span><span class="p">,</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">req_pages</span><span class="p">,</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">cmp_pages</span><span class="p">,</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">msg_pages</span><span class="p">,</span>
		<span class="n">pvscsi_template</span><span class="p">.</span><span class="n">cmd_per_lun</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">buf</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">scsi_host_template</span> <span class="n">pvscsi_template</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">module</span>				<span class="o">=</span> <span class="n">THIS_MODULE</span><span class="p">,</span>
	<span class="p">.</span><span class="n">name</span>				<span class="o">=</span> <span class="s">&quot;VMware PVSCSI Host Adapter&quot;</span><span class="p">,</span>
	<span class="p">.</span><span class="n">proc_name</span>			<span class="o">=</span> <span class="s">&quot;vmw_pvscsi&quot;</span><span class="p">,</span>
	<span class="p">.</span><span class="n">info</span>				<span class="o">=</span> <span class="n">pvscsi_info</span><span class="p">,</span>
	<span class="p">.</span><span class="n">queuecommand</span>			<span class="o">=</span> <span class="n">pvscsi_queue</span><span class="p">,</span>
	<span class="p">.</span><span class="n">this_id</span>			<span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
	<span class="p">.</span><span class="n">sg_tablesize</span>			<span class="o">=</span> <span class="n">PVSCSI_MAX_NUM_SG_ENTRIES_PER_SEGMENT</span><span class="p">,</span>
	<span class="p">.</span><span class="n">dma_boundary</span>			<span class="o">=</span> <span class="n">UINT_MAX</span><span class="p">,</span>
	<span class="p">.</span><span class="n">max_sectors</span>			<span class="o">=</span> <span class="mh">0xffff</span><span class="p">,</span>
	<span class="p">.</span><span class="n">use_clustering</span>			<span class="o">=</span> <span class="n">ENABLE_CLUSTERING</span><span class="p">,</span>
	<span class="p">.</span><span class="n">eh_abort_handler</span>		<span class="o">=</span> <span class="n">pvscsi_abort</span><span class="p">,</span>
	<span class="p">.</span><span class="n">eh_device_reset_handler</span>	<span class="o">=</span> <span class="n">pvscsi_device_reset</span><span class="p">,</span>
	<span class="p">.</span><span class="n">eh_bus_reset_handler</span>		<span class="o">=</span> <span class="n">pvscsi_bus_reset</span><span class="p">,</span>
	<span class="p">.</span><span class="n">eh_host_reset_handler</span>		<span class="o">=</span> <span class="n">pvscsi_host_reset</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">pvscsi_process_msg</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">pvscsi_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">,</span>
			       <span class="k">const</span> <span class="k">struct</span> <span class="n">PVSCSIRingMsgDesc</span> <span class="o">*</span><span class="n">e</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">PVSCSIRingsState</span> <span class="o">*</span><span class="n">s</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rings_state</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">host</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="n">sdev</span><span class="p">;</span>

	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;vmw_pvscsi: msg type: 0x%x - MSG RING: %u/%u (%u) </span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	       <span class="n">e</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">msgProdIdx</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">msgConsIdx</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">msgNumEntriesLog2</span><span class="p">);</span>

	<span class="n">BUILD_BUG_ON</span><span class="p">(</span><span class="n">PVSCSI_MSG_LAST</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="n">PVSCSI_MSG_DEV_ADDED</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">PVSCSIMsgDescDevStatusChanged</span> <span class="o">*</span><span class="n">desc</span><span class="p">;</span>
		<span class="n">desc</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">PVSCSIMsgDescDevStatusChanged</span> <span class="o">*</span><span class="p">)</span><span class="n">e</span><span class="p">;</span>

		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span>
		       <span class="s">&quot;vmw_pvscsi: msg: device added at scsi%u:%u:%u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">desc</span><span class="o">-&gt;</span><span class="n">bus</span><span class="p">,</span> <span class="n">desc</span><span class="o">-&gt;</span><span class="n">target</span><span class="p">,</span> <span class="n">desc</span><span class="o">-&gt;</span><span class="n">lun</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">scsi_host_get</span><span class="p">(</span><span class="n">host</span><span class="p">))</span>
			<span class="k">return</span><span class="p">;</span>

		<span class="n">sdev</span> <span class="o">=</span> <span class="n">scsi_device_lookup</span><span class="p">(</span><span class="n">host</span><span class="p">,</span> <span class="n">desc</span><span class="o">-&gt;</span><span class="n">bus</span><span class="p">,</span> <span class="n">desc</span><span class="o">-&gt;</span><span class="n">target</span><span class="p">,</span>
					  <span class="n">desc</span><span class="o">-&gt;</span><span class="n">lun</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sdev</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;vmw_pvscsi: device already exists</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">scsi_device_put</span><span class="p">(</span><span class="n">sdev</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="n">scsi_add_device</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">,</span> <span class="n">desc</span><span class="o">-&gt;</span><span class="n">bus</span><span class="p">,</span>
					<span class="n">desc</span><span class="o">-&gt;</span><span class="n">target</span><span class="p">,</span> <span class="n">desc</span><span class="o">-&gt;</span><span class="n">lun</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>

		<span class="n">scsi_host_put</span><span class="p">(</span><span class="n">host</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="n">PVSCSI_MSG_DEV_REMOVED</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">PVSCSIMsgDescDevStatusChanged</span> <span class="o">*</span><span class="n">desc</span><span class="p">;</span>
		<span class="n">desc</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">PVSCSIMsgDescDevStatusChanged</span> <span class="o">*</span><span class="p">)</span><span class="n">e</span><span class="p">;</span>

		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span>
		       <span class="s">&quot;vmw_pvscsi: msg: device removed at scsi%u:%u:%u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">desc</span><span class="o">-&gt;</span><span class="n">bus</span><span class="p">,</span> <span class="n">desc</span><span class="o">-&gt;</span><span class="n">target</span><span class="p">,</span> <span class="n">desc</span><span class="o">-&gt;</span><span class="n">lun</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">scsi_host_get</span><span class="p">(</span><span class="n">host</span><span class="p">))</span>
			<span class="k">return</span><span class="p">;</span>

		<span class="n">sdev</span> <span class="o">=</span> <span class="n">scsi_device_lookup</span><span class="p">(</span><span class="n">host</span><span class="p">,</span> <span class="n">desc</span><span class="o">-&gt;</span><span class="n">bus</span><span class="p">,</span> <span class="n">desc</span><span class="o">-&gt;</span><span class="n">target</span><span class="p">,</span>
					  <span class="n">desc</span><span class="o">-&gt;</span><span class="n">lun</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sdev</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">scsi_remove_device</span><span class="p">(</span><span class="n">sdev</span><span class="p">);</span>
			<span class="n">scsi_device_put</span><span class="p">(</span><span class="n">sdev</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span>
			       <span class="s">&quot;vmw_pvscsi: failed to lookup scsi%u:%u:%u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">desc</span><span class="o">-&gt;</span><span class="n">bus</span><span class="p">,</span> <span class="n">desc</span><span class="o">-&gt;</span><span class="n">target</span><span class="p">,</span> <span class="n">desc</span><span class="o">-&gt;</span><span class="n">lun</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>

		<span class="n">scsi_host_put</span><span class="p">(</span><span class="n">host</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">pvscsi_msg_pending</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">pvscsi_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">PVSCSIRingsState</span> <span class="o">*</span><span class="n">s</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rings_state</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">msgProdIdx</span> <span class="o">!=</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">msgConsIdx</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">pvscsi_process_msg_ring</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">pvscsi_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">PVSCSIRingsState</span> <span class="o">*</span><span class="n">s</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rings_state</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">PVSCSIRingMsgDesc</span> <span class="o">*</span><span class="n">ring</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">msg_ring</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">msg_entries</span> <span class="o">=</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">msgNumEntriesLog2</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">pvscsi_msg_pending</span><span class="p">(</span><span class="n">adapter</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">PVSCSIRingMsgDesc</span> <span class="o">*</span><span class="n">e</span> <span class="o">=</span> <span class="n">ring</span> <span class="o">+</span> <span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">msgConsIdx</span> <span class="o">&amp;</span>
						      <span class="n">MASK</span><span class="p">(</span><span class="n">msg_entries</span><span class="p">));</span>

		<span class="n">barrier</span><span class="p">();</span>
		<span class="n">pvscsi_process_msg</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">e</span><span class="p">);</span>
		<span class="n">barrier</span><span class="p">();</span>
		<span class="n">s</span><span class="o">-&gt;</span><span class="n">msgConsIdx</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">pvscsi_msg_workqueue_handler</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pvscsi_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">;</span>

	<span class="n">adapter</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pvscsi_adapter</span><span class="p">,</span> <span class="n">work</span><span class="p">);</span>

	<span class="n">pvscsi_process_msg_ring</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">pvscsi_setup_msg_workqueue</span><span class="p">(</span><span class="k">struct</span> <span class="n">pvscsi_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="n">name</span><span class="p">[</span><span class="mi">32</span><span class="p">];</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pvscsi_use_msg</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">pvscsi_reg_write</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">PVSCSI_REG_OFFSET_COMMAND</span><span class="p">,</span>
			 <span class="n">PVSCSI_CMD_SETUP_MSG_RING</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pvscsi_reg_read</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">PVSCSI_REG_OFFSET_COMMAND_STATUS</span><span class="p">)</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">snprintf</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">name</span><span class="p">),</span>
		 <span class="s">&quot;vmw_pvscsi_wq_%u&quot;</span><span class="p">,</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">host_no</span><span class="p">);</span>

	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">workqueue</span> <span class="o">=</span> <span class="n">create_singlethread_workqueue</span><span class="p">(</span><span class="n">name</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">workqueue</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;vmw_pvscsi: failed to create work queue</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">INIT_WORK</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">work</span><span class="p">,</span> <span class="n">pvscsi_msg_workqueue_handler</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">irqreturn_t</span> <span class="nf">pvscsi_isr</span><span class="p">(</span><span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">devp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pvscsi_adapter</span> <span class="o">*</span><span class="n">adapter</span> <span class="o">=</span> <span class="n">devp</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">handled</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">use_msi</span> <span class="o">||</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">use_msix</span><span class="p">)</span>
		<span class="n">handled</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="n">u32</span> <span class="n">val</span> <span class="o">=</span> <span class="n">pvscsi_read_intr_status</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
		<span class="n">handled</span> <span class="o">=</span> <span class="p">(</span><span class="n">val</span> <span class="o">&amp;</span> <span class="n">PVSCSI_INTR_ALL_SUPPORTED</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">handled</span><span class="p">)</span>
			<span class="n">pvscsi_write_intr_status</span><span class="p">(</span><span class="n">devp</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">handled</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

		<span class="n">pvscsi_process_completion_ring</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">use_msg</span> <span class="o">&amp;&amp;</span> <span class="n">pvscsi_msg_pending</span><span class="p">(</span><span class="n">adapter</span><span class="p">))</span>
			<span class="n">queue_work</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">workqueue</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">work</span><span class="p">);</span>

		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">IRQ_RETVAL</span><span class="p">(</span><span class="n">handled</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">pvscsi_free_sgls</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">pvscsi_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pvscsi_ctx</span> <span class="o">*</span><span class="n">ctx</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">cmd_map</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">req_depth</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">,</span> <span class="o">++</span><span class="n">ctx</span><span class="p">)</span>
		<span class="n">free_pages</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">sgl</span><span class="p">,</span> <span class="n">get_order</span><span class="p">(</span><span class="n">SGL_SIZE</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">pvscsi_setup_msix</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">pvscsi_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">,</span>
			     <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">irq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">msix_entry</span> <span class="n">entry</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">0</span><span class="p">,</span> <span class="n">PVSCSI_VECTOR_COMPLETION</span> <span class="p">};</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">pci_enable_msix</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">entry</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

	<span class="o">*</span><span class="n">irq</span> <span class="o">=</span> <span class="n">entry</span><span class="p">.</span><span class="n">vector</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">pvscsi_shutdown_intr</span><span class="p">(</span><span class="k">struct</span> <span class="n">pvscsi_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">free_irq</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">,</span> <span class="n">adapter</span><span class="p">);</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">irq</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">use_msi</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pci_disable_msi</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">use_msi</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">use_msix</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pci_disable_msix</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">use_msix</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">pvscsi_release_resources</span><span class="p">(</span><span class="k">struct</span> <span class="n">pvscsi_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pvscsi_shutdown_intr</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">workqueue</span><span class="p">)</span>
		<span class="n">destroy_workqueue</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">workqueue</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">mmioBase</span><span class="p">)</span>
		<span class="n">pci_iounmap</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">mmioBase</span><span class="p">);</span>

	<span class="n">pci_release_regions</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">cmd_map</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pvscsi_free_sgls</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">cmd_map</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rings_state</span><span class="p">)</span>
		<span class="n">pci_free_consistent</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">PAGE_SIZE</span><span class="p">,</span>
				    <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rings_state</span><span class="p">,</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">ringStatePA</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">req_ring</span><span class="p">)</span>
		<span class="n">pci_free_consistent</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
				    <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">req_pages</span> <span class="o">*</span> <span class="n">PAGE_SIZE</span><span class="p">,</span>
				    <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">req_ring</span><span class="p">,</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">reqRingPA</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">cmp_ring</span><span class="p">)</span>
		<span class="n">pci_free_consistent</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
				    <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">cmp_pages</span> <span class="o">*</span> <span class="n">PAGE_SIZE</span><span class="p">,</span>
				    <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">cmp_ring</span><span class="p">,</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">cmpRingPA</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">msg_ring</span><span class="p">)</span>
		<span class="n">pci_free_consistent</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
				    <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">msg_pages</span> <span class="o">*</span> <span class="n">PAGE_SIZE</span><span class="p">,</span>
				    <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">msg_ring</span><span class="p">,</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">msgRingPA</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Allocate scatter gather lists.</span>
<span class="cm"> *</span>
<span class="cm"> * These are statically allocated.  Trying to be clever was not worth it.</span>
<span class="cm"> *</span>
<span class="cm"> * Dynamic allocation can fail, and we can&#39;t go deep into the memory</span>
<span class="cm"> * allocator, since we&#39;re a SCSI driver, and trying too hard to allocate</span>
<span class="cm"> * memory might generate disk I/O.  We also don&#39;t want to fail disk I/O</span>
<span class="cm"> * in that case because we can&#39;t get an allocation - the I/O could be</span>
<span class="cm"> * trying to swap out data to free memory.  Since that is pathological,</span>
<span class="cm"> * just use a statically allocated scatter list.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__devinit</span> <span class="nf">pvscsi_allocate_sg</span><span class="p">(</span><span class="k">struct</span> <span class="n">pvscsi_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pvscsi_ctx</span> <span class="o">*</span><span class="n">ctx</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">ctx</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">cmd_map</span><span class="p">;</span>
	<span class="n">BUILD_BUG_ON</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">pvscsi_sg_list</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">SGL_SIZE</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">req_depth</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">,</span> <span class="o">++</span><span class="n">ctx</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">sgl</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">__get_free_pages</span><span class="p">(</span><span class="n">GFP_KERNEL</span><span class="p">,</span>
						    <span class="n">get_order</span><span class="p">(</span><span class="n">SGL_SIZE</span><span class="p">));</span>
		<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">sglPA</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">IS_ALIGNED</span><span class="p">(((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">sgl</span><span class="p">),</span> <span class="n">PAGE_SIZE</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">sgl</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">for</span> <span class="p">(;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="o">--</span><span class="n">i</span><span class="p">,</span> <span class="o">--</span><span class="n">ctx</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">free_pages</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">sgl</span><span class="p">,</span>
					   <span class="n">get_order</span><span class="p">(</span><span class="n">SGL_SIZE</span><span class="p">));</span>
				<span class="n">ctx</span><span class="o">-&gt;</span><span class="n">sgl</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Query the device, fetch the config info and return the</span>
<span class="cm"> * maximum number of targets on the adapter. In case of</span>
<span class="cm"> * failure due to any reason return default i.e. 16.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">u32</span> <span class="nf">pvscsi_get_max_targets</span><span class="p">(</span><span class="k">struct</span> <span class="n">pvscsi_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">PVSCSICmdDescConfigCmd</span> <span class="n">cmd</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">PVSCSIConfigPageHeader</span> <span class="o">*</span><span class="n">header</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">;</span>
	<span class="n">dma_addr_t</span> <span class="n">configPagePA</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">config_page</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">numPhys</span> <span class="o">=</span> <span class="mi">16</span><span class="p">;</span>

	<span class="n">dev</span> <span class="o">=</span> <span class="n">pvscsi_dev</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
	<span class="n">config_page</span> <span class="o">=</span> <span class="n">pci_alloc_consistent</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">PAGE_SIZE</span><span class="p">,</span>
					   <span class="o">&amp;</span><span class="n">configPagePA</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">config_page</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_warn</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;vmw_pvscsi: failed to allocate memory for config page</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">exit</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">configPagePA</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">PAGE_MASK</span><span class="p">);</span>

	<span class="cm">/* Fetch config info from the device. */</span>
	<span class="n">cmd</span><span class="p">.</span><span class="n">configPageAddress</span> <span class="o">=</span> <span class="p">((</span><span class="n">u64</span><span class="p">)</span><span class="n">PVSCSI_CONFIG_CONTROLLER_ADDRESS</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">32</span><span class="p">;</span>
	<span class="n">cmd</span><span class="p">.</span><span class="n">configPageNum</span> <span class="o">=</span> <span class="n">PVSCSI_CONFIG_PAGE_CONTROLLER</span><span class="p">;</span>
	<span class="n">cmd</span><span class="p">.</span><span class="n">cmpAddr</span> <span class="o">=</span> <span class="n">configPagePA</span><span class="p">;</span>
	<span class="n">cmd</span><span class="p">.</span><span class="n">_pad</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Mark the completion page header with error values. If the device</span>
<span class="cm">	 * completes the command successfully, it sets the status values to</span>
<span class="cm">	 * indicate success.</span>
<span class="cm">	 */</span>
	<span class="n">header</span> <span class="o">=</span> <span class="n">config_page</span><span class="p">;</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">header</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span> <span class="o">*</span><span class="n">header</span><span class="p">);</span>
	<span class="n">header</span><span class="o">-&gt;</span><span class="n">hostStatus</span> <span class="o">=</span> <span class="n">BTSTAT_INVPARAM</span><span class="p">;</span>
	<span class="n">header</span><span class="o">-&gt;</span><span class="n">scsiStatus</span> <span class="o">=</span> <span class="n">SDSTAT_CHECK</span><span class="p">;</span>

	<span class="n">pvscsi_write_cmd_desc</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">PVSCSI_CMD_CONFIG</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cmd</span><span class="p">,</span> <span class="k">sizeof</span> <span class="n">cmd</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">header</span><span class="o">-&gt;</span><span class="n">hostStatus</span> <span class="o">==</span> <span class="n">BTSTAT_SUCCESS</span> <span class="o">&amp;&amp;</span>
	    <span class="n">header</span><span class="o">-&gt;</span><span class="n">scsiStatus</span> <span class="o">==</span> <span class="n">SDSTAT_GOOD</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">PVSCSIConfigPageController</span> <span class="o">*</span><span class="n">config</span><span class="p">;</span>

		<span class="n">config</span> <span class="o">=</span> <span class="n">config_page</span><span class="p">;</span>
		<span class="n">numPhys</span> <span class="o">=</span> <span class="n">config</span><span class="o">-&gt;</span><span class="n">numPhys</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">dev_warn</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;vmw_pvscsi: PVSCSI_CMD_CONFIG failed. hostStatus = 0x%x, scsiStatus = 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			 <span class="n">header</span><span class="o">-&gt;</span><span class="n">hostStatus</span><span class="p">,</span> <span class="n">header</span><span class="o">-&gt;</span><span class="n">scsiStatus</span><span class="p">);</span>
	<span class="n">pci_free_consistent</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">PAGE_SIZE</span><span class="p">,</span> <span class="n">config_page</span><span class="p">,</span> <span class="n">configPagePA</span><span class="p">);</span>
<span class="nl">exit:</span>
	<span class="k">return</span> <span class="n">numPhys</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__devinit</span> <span class="nf">pvscsi_probe</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">,</span>
				  <span class="k">const</span> <span class="k">struct</span> <span class="n">pci_device_id</span> <span class="o">*</span><span class="n">id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pvscsi_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">host</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>

	<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pci_enable_device</span><span class="p">(</span><span class="n">pdev</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">error</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pci_set_dma_mask</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">DMA_BIT_MASK</span><span class="p">(</span><span class="mi">64</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span>
	    <span class="n">pci_set_consistent_dma_mask</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">DMA_BIT_MASK</span><span class="p">(</span><span class="mi">64</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;vmw_pvscsi: using 64bit dma</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">pci_set_dma_mask</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">DMA_BIT_MASK</span><span class="p">(</span><span class="mi">32</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span>
		   <span class="n">pci_set_consistent_dma_mask</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">DMA_BIT_MASK</span><span class="p">(</span><span class="mi">32</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;vmw_pvscsi: using 32bit dma</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;vmw_pvscsi: failed to set DMA mask</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_disable_device</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">pvscsi_template</span><span class="p">.</span><span class="n">can_queue</span> <span class="o">=</span>
		<span class="n">min</span><span class="p">(</span><span class="n">PVSCSI_MAX_NUM_PAGES_REQ_RING</span><span class="p">,</span> <span class="n">pvscsi_ring_pages</span><span class="p">)</span> <span class="o">*</span>
		<span class="n">PVSCSI_MAX_NUM_REQ_ENTRIES_PER_PAGE</span><span class="p">;</span>
	<span class="n">pvscsi_template</span><span class="p">.</span><span class="n">cmd_per_lun</span> <span class="o">=</span>
		<span class="n">min</span><span class="p">(</span><span class="n">pvscsi_template</span><span class="p">.</span><span class="n">can_queue</span><span class="p">,</span> <span class="n">pvscsi_cmd_per_lun</span><span class="p">);</span>
	<span class="n">host</span> <span class="o">=</span> <span class="n">scsi_host_alloc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pvscsi_template</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">pvscsi_adapter</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">host</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;vmw_pvscsi: failed to allocate host</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_disable_device</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">adapter</span> <span class="o">=</span> <span class="n">shost_priv</span><span class="p">(</span><span class="n">host</span><span class="p">);</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">adapter</span><span class="p">));</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">dev</span>  <span class="o">=</span> <span class="n">pdev</span><span class="p">;</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">host</span> <span class="o">=</span> <span class="n">host</span><span class="p">;</span>

	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">hw_lock</span><span class="p">);</span>

	<span class="n">host</span><span class="o">-&gt;</span><span class="n">max_channel</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">host</span><span class="o">-&gt;</span><span class="n">max_id</span>      <span class="o">=</span> <span class="mi">16</span><span class="p">;</span>
	<span class="n">host</span><span class="o">-&gt;</span><span class="n">max_lun</span>     <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">host</span><span class="o">-&gt;</span><span class="n">max_cmd_len</span> <span class="o">=</span> <span class="mi">16</span><span class="p">;</span>

	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rev</span> <span class="o">=</span> <span class="n">pdev</span><span class="o">-&gt;</span><span class="n">revision</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pci_request_regions</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="s">&quot;vmw_pvscsi&quot;</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;vmw_pvscsi: pci memory selection failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_free_host</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">DEVICE_COUNT_RESOURCE</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">pci_resource_flags</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">PCI_BASE_ADDRESS_SPACE_IO</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">pci_resource_len</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">PVSCSI_MEM_SPACE_SIZE</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">DEVICE_COUNT_RESOURCE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span>
		       <span class="s">&quot;vmw_pvscsi: adapter has no suitable MMIO region</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_release_resources</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">mmioBase</span> <span class="o">=</span> <span class="n">pci_iomap</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">PVSCSI_MEM_SPACE_SIZE</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">mmioBase</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span>
		       <span class="s">&quot;vmw_pvscsi: can&#39;t iomap for BAR %d memsize %lu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">i</span><span class="p">,</span> <span class="n">PVSCSI_MEM_SPACE_SIZE</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_release_resources</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">pci_set_master</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="n">pci_set_drvdata</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">host</span><span class="p">);</span>

	<span class="n">ll_adapter_reset</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>

	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">use_msg</span> <span class="o">=</span> <span class="n">pvscsi_setup_msg_workqueue</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">pvscsi_allocate_rings</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;vmw_pvscsi: unable to allocate ring memory</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_release_resources</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Ask the device for max number of targets.</span>
<span class="cm">	 */</span>
	<span class="n">host</span><span class="o">-&gt;</span><span class="n">max_id</span> <span class="o">=</span> <span class="n">pvscsi_get_max_targets</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
	<span class="n">dev</span> <span class="o">=</span> <span class="n">pvscsi_dev</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
	<span class="n">dev_info</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;vmw_pvscsi: host-&gt;max_id: %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">host</span><span class="o">-&gt;</span><span class="n">max_id</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * From this point on we should reset the adapter if anything goes</span>
<span class="cm">	 * wrong.</span>
<span class="cm">	 */</span>
	<span class="n">pvscsi_setup_all_rings</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>

	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">cmd_map</span> <span class="o">=</span> <span class="n">kcalloc</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">req_depth</span><span class="p">,</span>
				   <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">pvscsi_ctx</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">cmd_map</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;vmw_pvscsi: failed to allocate memory.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out_reset_adapter</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">cmd_pool</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">req_depth</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">pvscsi_ctx</span> <span class="o">*</span><span class="n">ctx</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">cmd_map</span> <span class="o">+</span> <span class="n">i</span><span class="p">;</span>
		<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">cmd_pool</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">pvscsi_allocate_sg</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;vmw_pvscsi: unable to allocate s/g table</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_reset_adapter</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pvscsi_disable_msix</span> <span class="o">&amp;&amp;</span>
	    <span class="n">pvscsi_setup_msix</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;vmw_pvscsi: using MSI-X</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">use_msix</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pvscsi_disable_msi</span> <span class="o">&amp;&amp;</span> <span class="n">pci_enable_msi</span><span class="p">(</span><span class="n">pdev</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;vmw_pvscsi: using MSI</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">use_msi</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">irq</span> <span class="o">=</span> <span class="n">pdev</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;vmw_pvscsi: using INTx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">irq</span> <span class="o">=</span> <span class="n">pdev</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">;</span>
		<span class="n">flags</span> <span class="o">=</span> <span class="n">IRQF_SHARED</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">request_irq</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">,</span> <span class="n">pvscsi_isr</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span>
			    <span class="s">&quot;vmw_pvscsi&quot;</span><span class="p">,</span> <span class="n">adapter</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span>
		       <span class="s">&quot;vmw_pvscsi: unable to request IRQ: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">error</span><span class="p">);</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">irq</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out_reset_adapter</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">scsi_add_host</span><span class="p">(</span><span class="n">host</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span>
		       <span class="s">&quot;vmw_pvscsi: scsi_add_host failed: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">error</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_reset_adapter</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">dev_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;VMware PVSCSI rev %d host #%u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		 <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rev</span><span class="p">,</span> <span class="n">host</span><span class="o">-&gt;</span><span class="n">host_no</span><span class="p">);</span>

	<span class="n">pvscsi_unmask_intr</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>

	<span class="n">scsi_scan_host</span><span class="p">(</span><span class="n">host</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">out_reset_adapter:</span>
	<span class="n">ll_adapter_reset</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
<span class="nl">out_release_resources:</span>
	<span class="n">pvscsi_release_resources</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
<span class="nl">out_free_host:</span>
	<span class="n">scsi_host_put</span><span class="p">(</span><span class="n">host</span><span class="p">);</span>
<span class="nl">out_disable_device:</span>
	<span class="n">pci_set_drvdata</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">pci_disable_device</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">__pvscsi_shutdown</span><span class="p">(</span><span class="k">struct</span> <span class="n">pvscsi_adapter</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pvscsi_mask_intr</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">workqueue</span><span class="p">)</span>
		<span class="n">flush_workqueue</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">workqueue</span><span class="p">);</span>

	<span class="n">pvscsi_shutdown_intr</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>

	<span class="n">pvscsi_process_request_ring</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
	<span class="n">pvscsi_process_completion_ring</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
	<span class="n">ll_adapter_reset</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">pvscsi_shutdown</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">host</span> <span class="o">=</span> <span class="n">pci_get_drvdata</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">pvscsi_adapter</span> <span class="o">*</span><span class="n">adapter</span> <span class="o">=</span> <span class="n">shost_priv</span><span class="p">(</span><span class="n">host</span><span class="p">);</span>

	<span class="n">__pvscsi_shutdown</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">pvscsi_remove</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">host</span> <span class="o">=</span> <span class="n">pci_get_drvdata</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">pvscsi_adapter</span> <span class="o">*</span><span class="n">adapter</span> <span class="o">=</span> <span class="n">shost_priv</span><span class="p">(</span><span class="n">host</span><span class="p">);</span>

	<span class="n">scsi_remove_host</span><span class="p">(</span><span class="n">host</span><span class="p">);</span>

	<span class="n">__pvscsi_shutdown</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
	<span class="n">pvscsi_release_resources</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>

	<span class="n">scsi_host_put</span><span class="p">(</span><span class="n">host</span><span class="p">);</span>

	<span class="n">pci_set_drvdata</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">pci_disable_device</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">pci_driver</span> <span class="n">pvscsi_pci_driver</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">name</span>		<span class="o">=</span> <span class="s">&quot;vmw_pvscsi&quot;</span><span class="p">,</span>
	<span class="p">.</span><span class="n">id_table</span>	<span class="o">=</span> <span class="n">pvscsi_pci_tbl</span><span class="p">,</span>
	<span class="p">.</span><span class="n">probe</span>		<span class="o">=</span> <span class="n">pvscsi_probe</span><span class="p">,</span>
	<span class="p">.</span><span class="n">remove</span>		<span class="o">=</span> <span class="n">__devexit_p</span><span class="p">(</span><span class="n">pvscsi_remove</span><span class="p">),</span>
	<span class="p">.</span><span class="n">shutdown</span>       <span class="o">=</span> <span class="n">pvscsi_shutdown</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">pvscsi_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;%s - version %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">PVSCSI_LINUX_DRIVER_DESC</span><span class="p">,</span> <span class="n">PVSCSI_DRIVER_VERSION_STRING</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">pci_register_driver</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pvscsi_pci_driver</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__exit</span> <span class="nf">pvscsi_exit</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pci_unregister_driver</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pvscsi_pci_driver</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">module_init</span><span class="p">(</span><span class="n">pvscsi_init</span><span class="p">);</span>
<span class="n">module_exit</span><span class="p">(</span><span class="n">pvscsi_exit</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
