<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › scsi › megaraid.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>megaraid.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> *</span>
<span class="cm"> *			Linux MegaRAID device driver</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (c) 2002  LSI Logic Corporation.</span>
<span class="cm"> *</span>
<span class="cm"> *	   This program is free software; you can redistribute it and/or</span>
<span class="cm"> *	   modify it under the terms of the GNU General Public License</span>
<span class="cm"> *	   as published by the Free Software Foundation; either version</span>
<span class="cm"> *	   2 of the License, or (at your option) any later version.</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (c) 2002  Red Hat, Inc. All rights reserved.</span>
<span class="cm"> *	  - fixes</span>
<span class="cm"> *	  - speed-ups (list handling fixes, issued_list, optimizations.)</span>
<span class="cm"> *	  - lots of cleanups.</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (c) 2003  Christoph Hellwig  &lt;hch@lst.de&gt;</span>
<span class="cm"> *	  - new-style, hotplug-aware pci probing and scsi registration</span>
<span class="cm"> *</span>
<span class="cm"> * Version : v2.00.4 Mon Nov 14 14:02:43 EST 2005 - Seokmann Ju</span>
<span class="cm"> * 						&lt;Seokmann.Ju@lsil.com&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * Description: Linux device driver for LSI Logic MegaRAID controller</span>
<span class="cm"> *</span>
<span class="cm"> * Supported controllers: MegaRAID 418, 428, 438, 466, 762, 467, 471, 490, 493</span>
<span class="cm"> *					518, 520, 531, 532</span>
<span class="cm"> *</span>
<span class="cm"> * This driver is supported by LSI Logic, with assistance from Red Hat, Dell,</span>
<span class="cm"> * and others. Please send updates to the mailing list</span>
<span class="cm"> * linux-scsi@vger.kernel.org .</span>
<span class="cm"> *</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/mm.h&gt;</span>
<span class="cp">#include &lt;linux/fs.h&gt;</span>
<span class="cp">#include &lt;linux/blkdev.h&gt;</span>
<span class="cp">#include &lt;asm/uaccess.h&gt;</span>
<span class="cp">#include &lt;asm/io.h&gt;</span>
<span class="cp">#include &lt;linux/completion.h&gt;</span>
<span class="cp">#include &lt;linux/delay.h&gt;</span>
<span class="cp">#include &lt;linux/proc_fs.h&gt;</span>
<span class="cp">#include &lt;linux/reboot.h&gt;</span>
<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/list.h&gt;</span>
<span class="cp">#include &lt;linux/interrupt.h&gt;</span>
<span class="cp">#include &lt;linux/pci.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/dma-mapping.h&gt;</span>
<span class="cp">#include &lt;linux/mutex.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;scsi/scsicam.h&gt;</span>

<span class="cp">#include &quot;scsi.h&quot;</span>
<span class="cp">#include &lt;scsi/scsi_host.h&gt;</span>

<span class="cp">#include &quot;megaraid.h&quot;</span>

<span class="cp">#define MEGARAID_MODULE_VERSION &quot;2.00.4&quot;</span>

<span class="n">MODULE_AUTHOR</span> <span class="p">(</span><span class="s">&quot;sju@lsil.com&quot;</span><span class="p">);</span>
<span class="n">MODULE_DESCRIPTION</span> <span class="p">(</span><span class="s">&quot;LSI Logic MegaRAID legacy driver&quot;</span><span class="p">);</span>
<span class="n">MODULE_LICENSE</span> <span class="p">(</span><span class="s">&quot;GPL&quot;</span><span class="p">);</span>
<span class="n">MODULE_VERSION</span><span class="p">(</span><span class="n">MEGARAID_MODULE_VERSION</span><span class="p">);</span>

<span class="k">static</span> <span class="n">DEFINE_MUTEX</span><span class="p">(</span><span class="n">megadev_mutex</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">max_cmd_per_lun</span> <span class="o">=</span> <span class="n">DEF_CMD_PER_LUN</span><span class="p">;</span>
<span class="n">module_param</span><span class="p">(</span><span class="n">max_cmd_per_lun</span><span class="p">,</span> <span class="n">uint</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">max_cmd_per_lun</span><span class="p">,</span> <span class="s">&quot;Maximum number of commands which can be issued to a single LUN (default=DEF_CMD_PER_LUN=63)&quot;</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">short</span> <span class="kt">int</span> <span class="n">max_sectors_per_io</span> <span class="o">=</span> <span class="n">MAX_SECTORS_PER_IO</span><span class="p">;</span>
<span class="n">module_param</span><span class="p">(</span><span class="n">max_sectors_per_io</span><span class="p">,</span> <span class="n">ushort</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">max_sectors_per_io</span><span class="p">,</span> <span class="s">&quot;Maximum number of sectors per I/O request (default=MAX_SECTORS_PER_IO=128)&quot;</span><span class="p">);</span>


<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">short</span> <span class="kt">int</span> <span class="n">max_mbox_busy_wait</span> <span class="o">=</span> <span class="n">MBOX_BUSY_WAIT</span><span class="p">;</span>
<span class="n">module_param</span><span class="p">(</span><span class="n">max_mbox_busy_wait</span><span class="p">,</span> <span class="n">ushort</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">max_mbox_busy_wait</span><span class="p">,</span> <span class="s">&quot;Maximum wait for mailbox in microseconds if busy (default=MBOX_BUSY_WAIT=10)&quot;</span><span class="p">);</span>

<span class="cp">#define RDINDOOR(adapter)	readl((adapter)-&gt;mmio_base + 0x20)</span>
<span class="cp">#define RDOUTDOOR(adapter)	readl((adapter)-&gt;mmio_base + 0x2C)</span>
<span class="cp">#define WRINDOOR(adapter,value)	 writel(value, (adapter)-&gt;mmio_base + 0x20)</span>
<span class="cp">#define WROUTDOOR(adapter,value) writel(value, (adapter)-&gt;mmio_base + 0x2C)</span>

<span class="cm">/*</span>
<span class="cm"> * Global variables</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">hba_count</span><span class="p">;</span>
<span class="k">static</span> <span class="n">adapter_t</span> <span class="o">*</span><span class="n">hba_soft_state</span><span class="p">[</span><span class="n">MAX_CONTROLLERS</span><span class="p">];</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">proc_dir_entry</span> <span class="o">*</span><span class="n">mega_proc_dir_entry</span><span class="p">;</span>

<span class="cm">/* For controller re-ordering */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">mega_hbas</span> <span class="n">mega_hbas</span><span class="p">[</span><span class="n">MAX_CONTROLLERS</span><span class="p">];</span>

<span class="k">static</span> <span class="kt">long</span>
<span class="n">megadev_unlocked_ioctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filep</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">arg</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * The File Operations structure for the serial/ioctl interface of the driver</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">megadev_fops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">owner</span>		<span class="o">=</span> <span class="n">THIS_MODULE</span><span class="p">,</span>
	<span class="p">.</span><span class="n">unlocked_ioctl</span>	<span class="o">=</span> <span class="n">megadev_unlocked_ioctl</span><span class="p">,</span>
	<span class="p">.</span><span class="n">open</span>		<span class="o">=</span> <span class="n">megadev_open</span><span class="p">,</span>
	<span class="p">.</span><span class="n">llseek</span>		<span class="o">=</span> <span class="n">noop_llseek</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Array to structures for storing the information about the controllers. This</span>
<span class="cm"> * information is sent to the user level applications, when they do an ioctl</span>
<span class="cm"> * for this information.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">mcontroller</span> <span class="n">mcontroller</span><span class="p">[</span><span class="n">MAX_CONTROLLERS</span><span class="p">];</span>

<span class="cm">/* The current driver version */</span>
<span class="k">static</span> <span class="n">u32</span> <span class="n">driver_ver</span> <span class="o">=</span> <span class="mh">0x02000000</span><span class="p">;</span>

<span class="cm">/* major number used by the device for character interface */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">major</span><span class="p">;</span>

<span class="cp">#define IS_RAID_CH(hba, ch)	(((hba)-&gt;mega_ch_class &gt;&gt; (ch)) &amp; 0x01)</span>


<span class="cm">/*</span>
<span class="cm"> * Debug variable to print some diagnostic messages</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">trace_level</span><span class="p">;</span>

<span class="cm">/**</span>
<span class="cm"> * mega_setup_mailbox()</span>
<span class="cm"> * @adapter - pointer to our soft state</span>
<span class="cm"> *</span>
<span class="cm"> * Allocates a 8 byte aligned memory for the handshake mailbox.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">mega_setup_mailbox</span><span class="p">(</span><span class="n">adapter_t</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>	<span class="n">align</span><span class="p">;</span>

	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">una_mbox64</span> <span class="o">=</span> <span class="n">pci_alloc_consistent</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			<span class="k">sizeof</span><span class="p">(</span><span class="n">mbox64_t</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">una_mbox64_dma</span><span class="p">);</span>

	<span class="k">if</span><span class="p">(</span> <span class="o">!</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">una_mbox64</span> <span class="p">)</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
		
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">mbox</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">una_mbox64</span><span class="o">-&gt;</span><span class="n">mbox</span><span class="p">;</span>

	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">mbox</span> <span class="o">=</span> <span class="p">(</span><span class="n">mbox_t</span> <span class="o">*</span><span class="p">)((((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">mbox</span><span class="p">)</span> <span class="o">+</span> <span class="mi">15</span><span class="p">)</span> <span class="o">&amp;</span>
			<span class="p">(</span><span class="o">~</span><span class="mi">0UL</span> <span class="o">^</span> <span class="mh">0xFUL</span><span class="p">));</span>

	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">mbox64</span> <span class="o">=</span> <span class="p">(</span><span class="n">mbox64_t</span> <span class="o">*</span><span class="p">)(((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">mbox</span><span class="p">)</span> <span class="o">-</span> <span class="mi">8</span><span class="p">);</span>

	<span class="n">align</span> <span class="o">=</span> <span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">mbox</span><span class="p">)</span> <span class="o">-</span> <span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">una_mbox64</span><span class="o">-&gt;</span><span class="n">mbox</span><span class="p">);</span>

	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">mbox_dma</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">una_mbox64_dma</span> <span class="o">+</span> <span class="mi">8</span> <span class="o">+</span> <span class="n">align</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Register the mailbox if the controller is an io-mapped controller</span>
<span class="cm">	 */</span>
	<span class="k">if</span><span class="p">(</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">flag</span> <span class="o">&amp;</span> <span class="n">BOARD_IOMAP</span> <span class="p">)</span> <span class="p">{</span>

		<span class="n">outb</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">mbox_dma</span> <span class="o">&amp;</span> <span class="mh">0xFF</span><span class="p">,</span>
				<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">io_port</span> <span class="o">+</span> <span class="n">MBOX_PORT0</span><span class="p">);</span>

		<span class="n">outb</span><span class="p">((</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">mbox_dma</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xFF</span><span class="p">,</span>
				<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">io_port</span> <span class="o">+</span> <span class="n">MBOX_PORT1</span><span class="p">);</span>

		<span class="n">outb</span><span class="p">((</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">mbox_dma</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xFF</span><span class="p">,</span>
				<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">io_port</span> <span class="o">+</span> <span class="n">MBOX_PORT2</span><span class="p">);</span>

		<span class="n">outb</span><span class="p">((</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">mbox_dma</span> <span class="o">&gt;&gt;</span> <span class="mi">24</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xFF</span><span class="p">,</span>
				<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">io_port</span> <span class="o">+</span> <span class="n">MBOX_PORT3</span><span class="p">);</span>

		<span class="n">outb</span><span class="p">(</span><span class="n">ENABLE_MBOX_BYTE</span><span class="p">,</span>
				<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">io_port</span> <span class="o">+</span> <span class="n">ENABLE_MBOX_REGION</span><span class="p">);</span>

		<span class="n">irq_ack</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>

		<span class="n">irq_enable</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * mega_query_adapter()</span>
<span class="cm"> * @adapter - pointer to our soft state</span>
<span class="cm"> *</span>
<span class="cm"> * Issue the adapter inquiry commands to the controller and find out</span>
<span class="cm"> * information and parameter about the devices attached</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">mega_query_adapter</span><span class="p">(</span><span class="n">adapter_t</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">dma_addr_t</span>	<span class="n">prod_info_dma_handle</span><span class="p">;</span>
	<span class="n">mega_inquiry3</span>	<span class="o">*</span><span class="n">inquiry3</span><span class="p">;</span>
	<span class="n">u8</span>	<span class="n">raw_mbox</span><span class="p">[</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">mbox_out</span><span class="p">)];</span>
	<span class="n">mbox_t</span>	<span class="o">*</span><span class="n">mbox</span><span class="p">;</span>
	<span class="kt">int</span>	<span class="n">retval</span><span class="p">;</span>

	<span class="cm">/* Initialize adapter inquiry mailbox */</span>

	<span class="n">mbox</span> <span class="o">=</span> <span class="p">(</span><span class="n">mbox_t</span> <span class="o">*</span><span class="p">)</span><span class="n">raw_mbox</span><span class="p">;</span>

	<span class="n">memset</span><span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">mega_buffer</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">MEGA_BUFFER_SIZE</span><span class="p">);</span>
	<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mbox</span><span class="o">-&gt;</span><span class="n">m_out</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">raw_mbox</span><span class="p">));</span>

	<span class="cm">/*</span>
<span class="cm">	 * Try to issue Inquiry3 command</span>
<span class="cm">	 * if not succeeded, then issue MEGA_MBOXCMD_ADAPTERINQ command and</span>
<span class="cm">	 * update enquiry3 structure</span>
<span class="cm">	 */</span>
	<span class="n">mbox</span><span class="o">-&gt;</span><span class="n">m_out</span><span class="p">.</span><span class="n">xferaddr</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">buf_dma_handle</span><span class="p">;</span>

	<span class="n">inquiry3</span> <span class="o">=</span> <span class="p">(</span><span class="n">mega_inquiry3</span> <span class="o">*</span><span class="p">)</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">mega_buffer</span><span class="p">;</span>

	<span class="n">raw_mbox</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">FC_NEW_CONFIG</span><span class="p">;</span>		<span class="cm">/* i.e. mbox-&gt;cmd=0xA1 */</span>
	<span class="n">raw_mbox</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">NC_SUBOP_ENQUIRY3</span><span class="p">;</span>	<span class="cm">/* i.e. 0x0F */</span>
	<span class="n">raw_mbox</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">ENQ3_GET_SOLICITED_FULL</span><span class="p">;</span>	<span class="cm">/* i.e. 0x02 */</span>

	<span class="cm">/* Issue a blocking command to the card */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">retval</span> <span class="o">=</span> <span class="n">issue_scb_block</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">raw_mbox</span><span class="p">)))</span> <span class="p">{</span>
		<span class="cm">/* the adapter does not support 40ld */</span>

		<span class="n">mraid_ext_inquiry</span>	<span class="o">*</span><span class="n">ext_inq</span><span class="p">;</span>
		<span class="n">mraid_inquiry</span>		<span class="o">*</span><span class="n">inq</span><span class="p">;</span>
		<span class="n">dma_addr_t</span>		<span class="n">dma_handle</span><span class="p">;</span>

		<span class="n">ext_inq</span> <span class="o">=</span> <span class="n">pci_alloc_consistent</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
				<span class="k">sizeof</span><span class="p">(</span><span class="n">mraid_ext_inquiry</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">dma_handle</span><span class="p">);</span>

		<span class="k">if</span><span class="p">(</span> <span class="n">ext_inq</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="p">)</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

		<span class="n">inq</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ext_inq</span><span class="o">-&gt;</span><span class="n">raid_inq</span><span class="p">;</span>

		<span class="n">mbox</span><span class="o">-&gt;</span><span class="n">m_out</span><span class="p">.</span><span class="n">xferaddr</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span><span class="n">dma_handle</span><span class="p">;</span>

		<span class="cm">/*issue old 0x04 command to adapter */</span>
		<span class="n">mbox</span><span class="o">-&gt;</span><span class="n">m_out</span><span class="p">.</span><span class="n">cmd</span> <span class="o">=</span> <span class="n">MEGA_MBOXCMD_ADPEXTINQ</span><span class="p">;</span>

		<span class="n">issue_scb_block</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">raw_mbox</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * update Enquiry3 and ProductInfo structures with</span>
<span class="cm">		 * mraid_inquiry structure</span>
<span class="cm">		 */</span>
		<span class="n">mega_8_to_40ld</span><span class="p">(</span><span class="n">inq</span><span class="p">,</span> <span class="n">inquiry3</span><span class="p">,</span>
				<span class="p">(</span><span class="n">mega_product_info</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">product_info</span><span class="p">);</span>

		<span class="n">pci_free_consistent</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">mraid_ext_inquiry</span><span class="p">),</span>
				<span class="n">ext_inq</span><span class="p">,</span> <span class="n">dma_handle</span><span class="p">);</span>

	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>		<span class="cm">/*adapter supports 40ld */</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">flag</span> <span class="o">|=</span> <span class="n">BOARD_40LD</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * get product_info, which is static information and will be</span>
<span class="cm">		 * unchanged</span>
<span class="cm">		 */</span>
		<span class="n">prod_info_dma_handle</span> <span class="o">=</span> <span class="n">pci_map_single</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span>
				<span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">product_info</span><span class="p">,</span>
				<span class="k">sizeof</span><span class="p">(</span><span class="n">mega_product_info</span><span class="p">),</span> <span class="n">PCI_DMA_FROMDEVICE</span><span class="p">);</span>

		<span class="n">mbox</span><span class="o">-&gt;</span><span class="n">m_out</span><span class="p">.</span><span class="n">xferaddr</span> <span class="o">=</span> <span class="n">prod_info_dma_handle</span><span class="p">;</span>

		<span class="n">raw_mbox</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">FC_NEW_CONFIG</span><span class="p">;</span>	<span class="cm">/* i.e. mbox-&gt;cmd=0xA1 */</span>
		<span class="n">raw_mbox</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">NC_SUBOP_PRODUCT_INFO</span><span class="p">;</span>	<span class="cm">/* i.e. 0x0E */</span>

		<span class="k">if</span> <span class="p">((</span><span class="n">retval</span> <span class="o">=</span> <span class="n">issue_scb_block</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">raw_mbox</span><span class="p">)))</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span>
			<span class="s">&quot;megaraid: Product_info cmd failed with error: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">retval</span><span class="p">);</span>

		<span class="n">pci_unmap_single</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">prod_info_dma_handle</span><span class="p">,</span>
				<span class="k">sizeof</span><span class="p">(</span><span class="n">mega_product_info</span><span class="p">),</span> <span class="n">PCI_DMA_FROMDEVICE</span><span class="p">);</span>
	<span class="p">}</span>


	<span class="cm">/*</span>
<span class="cm">	 * kernel scans the channels from 0 to &lt;= max_channel</span>
<span class="cm">	 */</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">max_channel</span> <span class="o">=</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">product_info</span><span class="p">.</span><span class="n">nchannels</span> <span class="o">+</span> <span class="n">NVIRT_CHAN</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">max_id</span> <span class="o">=</span> <span class="mi">16</span><span class="p">;</span>	<span class="cm">/* max targets per channel */</span>

	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">max_lun</span> <span class="o">=</span> <span class="mi">7</span><span class="p">;</span>	<span class="cm">/* Up to 7 luns for non disk devices */</span>

	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">cmd_per_lun</span> <span class="o">=</span> <span class="n">max_cmd_per_lun</span><span class="p">;</span>

	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">numldrv</span> <span class="o">=</span> <span class="n">inquiry3</span><span class="o">-&gt;</span><span class="n">num_ldrv</span><span class="p">;</span>

	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">max_cmds</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">product_info</span><span class="p">.</span><span class="n">max_commands</span><span class="p">;</span>

	<span class="k">if</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">max_cmds</span> <span class="o">&gt;</span> <span class="n">MAX_COMMANDS</span><span class="p">)</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">max_cmds</span> <span class="o">=</span> <span class="n">MAX_COMMANDS</span><span class="p">;</span>

	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">can_queue</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">max_cmds</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Get the maximum number of scatter-gather elements supported by this</span>
<span class="cm">	 * firmware</span>
<span class="cm">	 */</span>
	<span class="n">mega_get_max_sgl</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>

	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">sg_tablesize</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">sglen</span><span class="p">;</span>


	<span class="cm">/* use HP firmware and bios version encoding</span>
<span class="cm">	   Note: fw_version[0|1] and bios_version[0|1] were originally shifted</span>
<span class="cm">	   right 8 bits making them zero. This 0 value was hardcoded to fix</span>
<span class="cm">	   sparse warnings. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">product_info</span><span class="p">.</span><span class="n">subsysvid</span> <span class="o">==</span> <span class="n">HP_SUBSYS_VID</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">sprintf</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">fw_version</span><span class="p">,</span> <span class="s">&quot;%c%d%d.%d%d&quot;</span><span class="p">,</span>
			 <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">product_info</span><span class="p">.</span><span class="n">fw_version</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span>
			 <span class="mi">0</span><span class="p">,</span>
			 <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">product_info</span><span class="p">.</span><span class="n">fw_version</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0x0f</span><span class="p">,</span>
			 <span class="mi">0</span><span class="p">,</span>
			 <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">product_info</span><span class="p">.</span><span class="n">fw_version</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0x0f</span><span class="p">);</span>
		<span class="n">sprintf</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">bios_version</span><span class="p">,</span> <span class="s">&quot;%c%d%d.%d%d&quot;</span><span class="p">,</span>
			 <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">product_info</span><span class="p">.</span><span class="n">bios_version</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span>
			 <span class="mi">0</span><span class="p">,</span>
			 <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">product_info</span><span class="p">.</span><span class="n">bios_version</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0x0f</span><span class="p">,</span>
			 <span class="mi">0</span><span class="p">,</span>
			 <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">product_info</span><span class="p">.</span><span class="n">bios_version</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0x0f</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">fw_version</span><span class="p">,</span>
				<span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">product_info</span><span class="p">.</span><span class="n">fw_version</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">fw_version</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="n">memcpy</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">bios_version</span><span class="p">,</span>
				<span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">product_info</span><span class="p">.</span><span class="n">bios_version</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>

		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">bios_version</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_NOTICE</span> <span class="s">&quot;megaraid: [%s:%s] detected %d logical drives.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">fw_version</span><span class="p">,</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">bios_version</span><span class="p">,</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">numldrv</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Do we support extended (&gt;10 bytes) cdbs</span>
<span class="cm">	 */</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">support_ext_cdb</span> <span class="o">=</span> <span class="n">mega_support_ext_cdb</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">support_ext_cdb</span><span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_NOTICE</span> <span class="s">&quot;megaraid: supports extended CDBs.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>


	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * mega_runpendq()</span>
<span class="cm"> * @adapter - pointer to our soft state</span>
<span class="cm"> *</span>
<span class="cm"> * Runs through the list of pending requests.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">mega_runpendq</span><span class="p">(</span><span class="n">adapter_t</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pending_list</span><span class="p">))</span>
		<span class="n">__mega_runpendq</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * megaraid_queue()</span>
<span class="cm"> * @scmd - Issue this scsi command</span>
<span class="cm"> * @done - the callback hook into the scsi mid-layer</span>
<span class="cm"> *</span>
<span class="cm"> * The command queuing entry point for the mid-layer.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">megaraid_queue_lck</span><span class="p">(</span><span class="n">Scsi_Cmnd</span> <span class="o">*</span><span class="n">scmd</span><span class="p">,</span> <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">done</span><span class="p">)(</span><span class="n">Scsi_Cmnd</span> <span class="o">*</span><span class="p">))</span>
<span class="p">{</span>
	<span class="n">adapter_t</span>	<span class="o">*</span><span class="n">adapter</span><span class="p">;</span>
	<span class="n">scb_t</span>	<span class="o">*</span><span class="n">scb</span><span class="p">;</span>
	<span class="kt">int</span>	<span class="n">busy</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">adapter</span> <span class="o">=</span> <span class="p">(</span><span class="n">adapter_t</span> <span class="o">*</span><span class="p">)</span><span class="n">scmd</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">hostdata</span><span class="p">;</span>

	<span class="n">scmd</span><span class="o">-&gt;</span><span class="n">scsi_done</span> <span class="o">=</span> <span class="n">done</span><span class="p">;</span>


	<span class="cm">/*</span>
<span class="cm">	 * Allocate and build a SCB request</span>
<span class="cm">	 * busy flag will be set if mega_build_cmd() command could not</span>
<span class="cm">	 * allocate scb. We will return non-zero status in that case.</span>
<span class="cm">	 * NOTE: scb can be null even though certain commands completed</span>
<span class="cm">	 * successfully, e.g., MODE_SENSE and TEST_UNIT_READY, we would</span>
<span class="cm">	 * return 0 in that case.</span>
<span class="cm">	 */</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">scb</span> <span class="o">=</span> <span class="n">mega_build_cmd</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">scmd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">busy</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">scb</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">scb</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">|=</span> <span class="n">SCB_PENDQ</span><span class="p">;</span>
	<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">scb</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pending_list</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Check if the HBA is in quiescent state, e.g., during a</span>
<span class="cm">	 * delete logical drive opertion. If it is, don&#39;t run</span>
<span class="cm">	 * the pending_list.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">quiescent</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">mega_runpendq</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>

	<span class="n">busy</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
 <span class="nl">out:</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">busy</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="nf">DEF_SCSI_QCMD</span><span class="p">(</span><span class="n">megaraid_queue</span><span class="p">)</span>

<span class="cm">/**</span>
<span class="cm"> * mega_allocate_scb()</span>
<span class="cm"> * @adapter - pointer to our soft state</span>
<span class="cm"> * @cmd - scsi command from the mid-layer</span>
<span class="cm"> *</span>
<span class="cm"> * Allocate a SCB structure. This is the central structure for controller</span>
<span class="cm"> * commands.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">scb_t</span> <span class="o">*</span>
<span class="n">mega_allocate_scb</span><span class="p">(</span><span class="n">adapter_t</span> <span class="o">*</span><span class="n">adapter</span><span class="p">,</span> <span class="n">Scsi_Cmnd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">head</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">free_list</span><span class="p">;</span>
	<span class="n">scb_t</span>	<span class="o">*</span><span class="n">scb</span><span class="p">;</span>

	<span class="cm">/* Unlink command from Free List */</span>
	<span class="k">if</span><span class="p">(</span> <span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="n">head</span><span class="p">)</span> <span class="p">)</span> <span class="p">{</span>

		<span class="n">scb</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">head</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">,</span> <span class="n">scb_t</span><span class="p">,</span> <span class="n">list</span><span class="p">);</span>

		<span class="n">list_del_init</span><span class="p">(</span><span class="n">head</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">);</span>

		<span class="n">scb</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">SCB_ACTIVE</span><span class="p">;</span>
		<span class="n">scb</span><span class="o">-&gt;</span><span class="n">cmd</span> <span class="o">=</span> <span class="n">cmd</span><span class="p">;</span>
		<span class="n">scb</span><span class="o">-&gt;</span><span class="n">dma_type</span> <span class="o">=</span> <span class="n">MEGA_DMA_TYPE_NONE</span><span class="p">;</span>

		<span class="k">return</span> <span class="n">scb</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * mega_get_ldrv_num()</span>
<span class="cm"> * @adapter - pointer to our soft state</span>
<span class="cm"> * @cmd - scsi mid layer command</span>
<span class="cm"> * @channel - channel on the controller</span>
<span class="cm"> *</span>
<span class="cm"> * Calculate the logical drive number based on the information in scsi command</span>
<span class="cm"> * and the channel number.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span>
<span class="nf">mega_get_ldrv_num</span><span class="p">(</span><span class="n">adapter_t</span> <span class="o">*</span><span class="n">adapter</span><span class="p">,</span> <span class="n">Scsi_Cmnd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">,</span> <span class="kt">int</span> <span class="n">channel</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span>		<span class="n">tgt</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">ldrv_num</span><span class="p">;</span>

	<span class="n">tgt</span> <span class="o">=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">;</span>
	
	<span class="k">if</span> <span class="p">(</span> <span class="n">tgt</span> <span class="o">&gt;</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">this_id</span> <span class="p">)</span>
		<span class="n">tgt</span><span class="o">--</span><span class="p">;</span>	<span class="cm">/* we do not get inquires for initiator id */</span>

	<span class="n">ldrv_num</span> <span class="o">=</span> <span class="p">(</span><span class="n">channel</span> <span class="o">*</span> <span class="mi">15</span><span class="p">)</span> <span class="o">+</span> <span class="n">tgt</span><span class="p">;</span>


	<span class="cm">/*</span>
<span class="cm">	 * If we have a logical drive with boot enabled, project it first</span>
<span class="cm">	 */</span>
	<span class="k">if</span><span class="p">(</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">boot_ldrv_enabled</span> <span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span><span class="p">(</span> <span class="n">ldrv_num</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">)</span> <span class="p">{</span>
			<span class="n">ldrv_num</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">boot_ldrv</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">else</span> <span class="p">{</span>
			<span class="k">if</span><span class="p">(</span> <span class="n">ldrv_num</span> <span class="o">&lt;=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">boot_ldrv</span> <span class="p">)</span> <span class="p">{</span>
				<span class="n">ldrv_num</span><span class="o">--</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * If &quot;delete logical drive&quot; feature is enabled on this controller.</span>
<span class="cm">	 * Do only if at least one delete logical drive operation was done.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Also, after logical drive deletion, instead of logical drive number,</span>
<span class="cm">	 * the value returned should be 0x80+logical drive id.</span>
<span class="cm">	 *</span>
<span class="cm">	 * These is valid only for IO commands.</span>
<span class="cm">	 */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">support_random_del</span> <span class="o">&amp;&amp;</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">read_ldidmap</span> <span class="p">)</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">READ_6</span>:	<span class="cm">/* fall through */</span>
		<span class="k">case</span> <span class="n">WRITE_6</span>:	<span class="cm">/* fall through */</span>
		<span class="k">case</span> <span class="n">READ_10</span>:	<span class="cm">/* fall through */</span>
		<span class="k">case</span> <span class="n">WRITE_10</span>:
			<span class="n">ldrv_num</span> <span class="o">+=</span> <span class="mh">0x80</span><span class="p">;</span>
		<span class="p">}</span>

	<span class="k">return</span> <span class="n">ldrv_num</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * mega_build_cmd()</span>
<span class="cm"> * @adapter - pointer to our soft state</span>
<span class="cm"> * @cmd - Prepare using this scsi command</span>
<span class="cm"> * @busy - busy flag if no resources</span>
<span class="cm"> *</span>
<span class="cm"> * Prepares a command and scatter gather list for the controller. This routine</span>
<span class="cm"> * also finds out if the commands is intended for a logical drive or a</span>
<span class="cm"> * physical device and prepares the controller command accordingly.</span>
<span class="cm"> *</span>
<span class="cm"> * We also re-order the logical drives and physical devices based on their</span>
<span class="cm"> * boot settings.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">scb_t</span> <span class="o">*</span>
<span class="nf">mega_build_cmd</span><span class="p">(</span><span class="n">adapter_t</span> <span class="o">*</span><span class="n">adapter</span><span class="p">,</span> <span class="n">Scsi_Cmnd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">busy</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">mega_ext_passthru</span>	<span class="o">*</span><span class="n">epthru</span><span class="p">;</span>
	<span class="n">mega_passthru</span>	<span class="o">*</span><span class="n">pthru</span><span class="p">;</span>
	<span class="n">scb_t</span>	<span class="o">*</span><span class="n">scb</span><span class="p">;</span>
	<span class="n">mbox_t</span>	<span class="o">*</span><span class="n">mbox</span><span class="p">;</span>
	<span class="kt">long</span>	<span class="n">seg</span><span class="p">;</span>
	<span class="kt">char</span>	<span class="n">islogical</span><span class="p">;</span>
	<span class="kt">int</span>	<span class="n">max_ldrv_num</span><span class="p">;</span>
	<span class="kt">int</span>	<span class="n">channel</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span>	<span class="n">target</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span>	<span class="n">ldrv_num</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>   <span class="cm">/* logical drive number */</span>


	<span class="cm">/*</span>
<span class="cm">	 * filter the internal and ioctl commands</span>
<span class="cm">	 */</span>
	<span class="k">if</span><span class="p">((</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">MEGA_INTERNAL_CMD</span><span class="p">))</span>
		<span class="k">return</span> <span class="p">(</span><span class="n">scb_t</span> <span class="o">*</span><span class="p">)</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">host_scribble</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * We know what channels our logical drives are on - mega_find_card()</span>
<span class="cm">	 */</span>
	<span class="n">islogical</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">logdrv_chan</span><span class="p">[</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">channel</span><span class="p">];</span>

	<span class="cm">/*</span>
<span class="cm">	 * The theory: If physical drive is chosen for boot, all the physical</span>
<span class="cm">	 * devices are exported before the logical drives, otherwise physical</span>
<span class="cm">	 * devices are pushed after logical drives, in which case - Kernel sees</span>
<span class="cm">	 * the physical devices on virtual channel which is obviously converted</span>
<span class="cm">	 * to actual channel on the HBA.</span>
<span class="cm">	 */</span>
	<span class="k">if</span><span class="p">(</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">boot_pdrv_enabled</span> <span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span><span class="p">(</span> <span class="n">islogical</span> <span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* logical channel */</span>
			<span class="n">channel</span> <span class="o">=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">channel</span> <span class="o">-</span>
				<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">product_info</span><span class="p">.</span><span class="n">nchannels</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">else</span> <span class="p">{</span>
			<span class="cm">/* this is physical channel */</span>
			<span class="n">channel</span> <span class="o">=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">channel</span><span class="p">;</span> 
			<span class="n">target</span> <span class="o">=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">;</span>

			<span class="cm">/*</span>
<span class="cm">			 * boot from a physical disk, that disk needs to be</span>
<span class="cm">			 * exposed first IF both the channels are SCSI, then</span>
<span class="cm">			 * booting from the second channel is not allowed.</span>
<span class="cm">			 */</span>
			<span class="k">if</span><span class="p">(</span> <span class="n">target</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">)</span> <span class="p">{</span>
				<span class="n">target</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">boot_pdrv_tgt</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">else</span> <span class="k">if</span><span class="p">(</span> <span class="n">target</span> <span class="o">==</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">boot_pdrv_tgt</span> <span class="p">)</span> <span class="p">{</span>
				<span class="n">target</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span><span class="p">(</span> <span class="n">islogical</span> <span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* this is the logical channel */</span>
			<span class="n">channel</span> <span class="o">=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">channel</span><span class="p">;</span>	
		<span class="p">}</span>
		<span class="k">else</span> <span class="p">{</span>
			<span class="cm">/* physical channel */</span>
			<span class="n">channel</span> <span class="o">=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">channel</span> <span class="o">-</span> <span class="n">NVIRT_CHAN</span><span class="p">;</span>	
			<span class="n">target</span> <span class="o">=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>


	<span class="k">if</span><span class="p">(</span><span class="n">islogical</span><span class="p">)</span> <span class="p">{</span>

		<span class="cm">/* have just LUN 0 for each target on virtual channels */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">lun</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">=</span> <span class="p">(</span><span class="n">DID_BAD_TARGET</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">);</span>
			<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scsi_done</span><span class="p">(</span><span class="n">cmd</span><span class="p">);</span>
			<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">ldrv_num</span> <span class="o">=</span> <span class="n">mega_get_ldrv_num</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">cmd</span><span class="p">,</span> <span class="n">channel</span><span class="p">);</span>


		<span class="n">max_ldrv_num</span> <span class="o">=</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">flag</span> <span class="o">&amp;</span> <span class="n">BOARD_40LD</span><span class="p">)</span> <span class="o">?</span>
			<span class="n">MAX_LOGICAL_DRIVES_40LD</span> <span class="o">:</span> <span class="n">MAX_LOGICAL_DRIVES_8LD</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * max_ldrv_num increases by 0x80 if some logical drive was</span>
<span class="cm">		 * deleted.</span>
<span class="cm">		 */</span>
		<span class="k">if</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">read_ldidmap</span><span class="p">)</span>
			<span class="n">max_ldrv_num</span> <span class="o">+=</span> <span class="mh">0x80</span><span class="p">;</span>

		<span class="k">if</span><span class="p">(</span><span class="n">ldrv_num</span> <span class="o">&gt;</span> <span class="n">max_ldrv_num</span> <span class="p">)</span> <span class="p">{</span>
			<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">=</span> <span class="p">(</span><span class="n">DID_BAD_TARGET</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">);</span>
			<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scsi_done</span><span class="p">(</span><span class="n">cmd</span><span class="p">);</span>
			<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>

	<span class="p">}</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span><span class="p">(</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">lun</span> <span class="o">&gt;</span> <span class="mi">7</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * Do not support lun &gt;7 for physically accessed</span>
<span class="cm">			 * devices</span>
<span class="cm">			 */</span>
			<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">=</span> <span class="p">(</span><span class="n">DID_BAD_TARGET</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">);</span>
			<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scsi_done</span><span class="p">(</span><span class="n">cmd</span><span class="p">);</span>
			<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 *</span>
<span class="cm">	 * Logical drive commands</span>
<span class="cm">	 *</span>
<span class="cm">	 */</span>
	<span class="k">if</span><span class="p">(</span><span class="n">islogical</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">TEST_UNIT_READY</span>:
<span class="cp">#if MEGA_HAVE_CLUSTERING</span>
			<span class="cm">/*</span>
<span class="cm">			 * Do we support clustering and is the support enabled</span>
<span class="cm">			 * If no, return success always</span>
<span class="cm">			 */</span>
			<span class="k">if</span><span class="p">(</span> <span class="o">!</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">has_cluster</span> <span class="p">)</span> <span class="p">{</span>
				<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">=</span> <span class="p">(</span><span class="n">DID_OK</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">);</span>
				<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scsi_done</span><span class="p">(</span><span class="n">cmd</span><span class="p">);</span>
				<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">scb</span> <span class="o">=</span> <span class="n">mega_allocate_scb</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">cmd</span><span class="p">)))</span> <span class="p">{</span>
				<span class="o">*</span><span class="n">busy</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
				<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="n">scb</span><span class="o">-&gt;</span><span class="n">raw_mbox</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">MEGA_CLUSTER_CMD</span><span class="p">;</span>
			<span class="n">scb</span><span class="o">-&gt;</span><span class="n">raw_mbox</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">MEGA_RESERVATION_STATUS</span><span class="p">;</span>
			<span class="n">scb</span><span class="o">-&gt;</span><span class="n">raw_mbox</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">ldrv_num</span><span class="p">;</span>

			<span class="n">scb</span><span class="o">-&gt;</span><span class="n">dma_direction</span> <span class="o">=</span> <span class="n">PCI_DMA_NONE</span><span class="p">;</span>

			<span class="k">return</span> <span class="n">scb</span><span class="p">;</span>
<span class="cp">#else</span>
			<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">=</span> <span class="p">(</span><span class="n">DID_OK</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">);</span>
			<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scsi_done</span><span class="p">(</span><span class="n">cmd</span><span class="p">);</span>
			<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="cp">#endif</span>

		<span class="k">case</span> <span class="n">MODE_SENSE</span>: <span class="p">{</span>
			<span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">;</span>
			<span class="k">struct</span> <span class="n">scatterlist</span> <span class="o">*</span><span class="n">sg</span><span class="p">;</span>

			<span class="n">sg</span> <span class="o">=</span> <span class="n">scsi_sglist</span><span class="p">(</span><span class="n">cmd</span><span class="p">);</span>
			<span class="n">buf</span> <span class="o">=</span> <span class="n">kmap_atomic</span><span class="p">(</span><span class="n">sg_page</span><span class="p">(</span><span class="n">sg</span><span class="p">))</span> <span class="o">+</span> <span class="n">sg</span><span class="o">-&gt;</span><span class="n">offset</span><span class="p">;</span>

			<span class="n">memset</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">4</span><span class="p">]);</span>
			<span class="n">kunmap_atomic</span><span class="p">(</span><span class="n">buf</span> <span class="o">-</span> <span class="n">sg</span><span class="o">-&gt;</span><span class="n">offset</span><span class="p">);</span>

			<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">=</span> <span class="p">(</span><span class="n">DID_OK</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">);</span>
			<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scsi_done</span><span class="p">(</span><span class="n">cmd</span><span class="p">);</span>
			<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">case</span> <span class="n">READ_CAPACITY</span>:
		<span class="k">case</span> <span class="n">INQUIRY</span>:

			<span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">flag</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1L</span> <span class="o">&lt;&lt;</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">channel</span><span class="p">)))</span> <span class="p">{</span>

				<span class="n">printk</span><span class="p">(</span><span class="n">KERN_NOTICE</span>
					<span class="s">&quot;scsi%d: scanning scsi channel %d &quot;</span><span class="p">,</span>
						<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">host_no</span><span class="p">,</span>
						<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">channel</span><span class="p">);</span>
				<span class="n">printk</span><span class="p">(</span><span class="s">&quot;for logical drives.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

				<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">flag</span> <span class="o">|=</span> <span class="p">(</span><span class="mi">1L</span> <span class="o">&lt;&lt;</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">channel</span><span class="p">);</span>
			<span class="p">}</span>

			<span class="cm">/* Allocate a SCB and initialize passthru */</span>
			<span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">scb</span> <span class="o">=</span> <span class="n">mega_allocate_scb</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">cmd</span><span class="p">)))</span> <span class="p">{</span>
				<span class="o">*</span><span class="n">busy</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
				<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">pthru</span> <span class="o">=</span> <span class="n">scb</span><span class="o">-&gt;</span><span class="n">pthru</span><span class="p">;</span>

			<span class="n">mbox</span> <span class="o">=</span> <span class="p">(</span><span class="n">mbox_t</span> <span class="o">*</span><span class="p">)</span><span class="n">scb</span><span class="o">-&gt;</span><span class="n">raw_mbox</span><span class="p">;</span>
			<span class="n">memset</span><span class="p">(</span><span class="n">mbox</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">scb</span><span class="o">-&gt;</span><span class="n">raw_mbox</span><span class="p">));</span>
			<span class="n">memset</span><span class="p">(</span><span class="n">pthru</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">mega_passthru</span><span class="p">));</span>

			<span class="n">pthru</span><span class="o">-&gt;</span><span class="n">timeout</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">pthru</span><span class="o">-&gt;</span><span class="n">ars</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">pthru</span><span class="o">-&gt;</span><span class="n">reqsenselen</span> <span class="o">=</span> <span class="mi">14</span><span class="p">;</span>
			<span class="n">pthru</span><span class="o">-&gt;</span><span class="n">islogical</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">pthru</span><span class="o">-&gt;</span><span class="n">logdrv</span> <span class="o">=</span> <span class="n">ldrv_num</span><span class="p">;</span>
			<span class="n">pthru</span><span class="o">-&gt;</span><span class="n">cdblen</span> <span class="o">=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">cmd_len</span><span class="p">;</span>
			<span class="n">memcpy</span><span class="p">(</span><span class="n">pthru</span><span class="o">-&gt;</span><span class="n">cdb</span><span class="p">,</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">,</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">cmd_len</span><span class="p">);</span>

			<span class="k">if</span><span class="p">(</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">has_64bit_addr</span> <span class="p">)</span> <span class="p">{</span>
				<span class="n">mbox</span><span class="o">-&gt;</span><span class="n">m_out</span><span class="p">.</span><span class="n">cmd</span> <span class="o">=</span> <span class="n">MEGA_MBOXCMD_PASSTHRU64</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">else</span> <span class="p">{</span>
				<span class="n">mbox</span><span class="o">-&gt;</span><span class="n">m_out</span><span class="p">.</span><span class="n">cmd</span> <span class="o">=</span> <span class="n">MEGA_MBOXCMD_PASSTHRU</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="n">scb</span><span class="o">-&gt;</span><span class="n">dma_direction</span> <span class="o">=</span> <span class="n">PCI_DMA_FROMDEVICE</span><span class="p">;</span>

			<span class="n">pthru</span><span class="o">-&gt;</span><span class="n">numsgelements</span> <span class="o">=</span> <span class="n">mega_build_sglist</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">scb</span><span class="p">,</span>
				<span class="o">&amp;</span><span class="n">pthru</span><span class="o">-&gt;</span><span class="n">dataxferaddr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pthru</span><span class="o">-&gt;</span><span class="n">dataxferlen</span><span class="p">);</span>

			<span class="n">mbox</span><span class="o">-&gt;</span><span class="n">m_out</span><span class="p">.</span><span class="n">xferaddr</span> <span class="o">=</span> <span class="n">scb</span><span class="o">-&gt;</span><span class="n">pthru_dma_addr</span><span class="p">;</span>

			<span class="k">return</span> <span class="n">scb</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">READ_6</span>:
		<span class="k">case</span> <span class="n">WRITE_6</span>:
		<span class="k">case</span> <span class="n">READ_10</span>:
		<span class="k">case</span> <span class="n">WRITE_10</span>:
		<span class="k">case</span> <span class="n">READ_12</span>:
		<span class="k">case</span> <span class="n">WRITE_12</span>:

			<span class="cm">/* Allocate a SCB and initialize mailbox */</span>
			<span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">scb</span> <span class="o">=</span> <span class="n">mega_allocate_scb</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">cmd</span><span class="p">)))</span> <span class="p">{</span>
				<span class="o">*</span><span class="n">busy</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
				<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">mbox</span> <span class="o">=</span> <span class="p">(</span><span class="n">mbox_t</span> <span class="o">*</span><span class="p">)</span><span class="n">scb</span><span class="o">-&gt;</span><span class="n">raw_mbox</span><span class="p">;</span>

			<span class="n">memset</span><span class="p">(</span><span class="n">mbox</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">scb</span><span class="o">-&gt;</span><span class="n">raw_mbox</span><span class="p">));</span>
			<span class="n">mbox</span><span class="o">-&gt;</span><span class="n">m_out</span><span class="p">.</span><span class="n">logdrv</span> <span class="o">=</span> <span class="n">ldrv_num</span><span class="p">;</span>

			<span class="cm">/*</span>
<span class="cm">			 * A little hack: 2nd bit is zero for all scsi read</span>
<span class="cm">			 * commands and is set for all scsi write commands</span>
<span class="cm">			 */</span>
			<span class="k">if</span><span class="p">(</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">has_64bit_addr</span> <span class="p">)</span> <span class="p">{</span>
				<span class="n">mbox</span><span class="o">-&gt;</span><span class="n">m_out</span><span class="p">.</span><span class="n">cmd</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">cmnd</span> <span class="o">&amp;</span> <span class="mh">0x02</span><span class="p">)</span> <span class="o">?</span>
					<span class="nl">MEGA_MBOXCMD_LWRITE64:</span>
					<span class="n">MEGA_MBOXCMD_LREAD64</span> <span class="p">;</span>
			<span class="p">}</span>
			<span class="k">else</span> <span class="p">{</span>
				<span class="n">mbox</span><span class="o">-&gt;</span><span class="n">m_out</span><span class="p">.</span><span class="n">cmd</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">cmnd</span> <span class="o">&amp;</span> <span class="mh">0x02</span><span class="p">)</span> <span class="o">?</span>
					<span class="nl">MEGA_MBOXCMD_LWRITE:</span>
					<span class="n">MEGA_MBOXCMD_LREAD</span> <span class="p">;</span>
			<span class="p">}</span>

			<span class="cm">/*</span>
<span class="cm">			 * 6-byte READ(0x08) or WRITE(0x0A) cdb</span>
<span class="cm">			 */</span>
			<span class="k">if</span><span class="p">(</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">cmd_len</span> <span class="o">==</span> <span class="mi">6</span> <span class="p">)</span> <span class="p">{</span>
				<span class="n">mbox</span><span class="o">-&gt;</span><span class="n">m_out</span><span class="p">.</span><span class="n">numsectors</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
				<span class="n">mbox</span><span class="o">-&gt;</span><span class="n">m_out</span><span class="p">.</span><span class="n">lba</span> <span class="o">=</span>
					<span class="p">((</span><span class="n">u32</span><span class="p">)</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">|</span>
					<span class="p">((</span><span class="n">u32</span><span class="p">)</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">|</span>
					<span class="p">(</span><span class="n">u32</span><span class="p">)</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>

				<span class="n">mbox</span><span class="o">-&gt;</span><span class="n">m_out</span><span class="p">.</span><span class="n">lba</span> <span class="o">&amp;=</span> <span class="mh">0x1FFFFF</span><span class="p">;</span>

<span class="cp">#if MEGA_HAVE_STATS</span>
				<span class="cm">/*</span>
<span class="cm">				 * Take modulo 0x80, since the logical drive</span>
<span class="cm">				 * number increases by 0x80 when a logical</span>
<span class="cm">				 * drive was deleted</span>
<span class="cm">				 */</span>
				<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">cmnd</span> <span class="o">==</span> <span class="n">READ_6</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">nreads</span><span class="p">[</span><span class="n">ldrv_num</span><span class="o">%</span><span class="mh">0x80</span><span class="p">]</span><span class="o">++</span><span class="p">;</span>
					<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">nreadblocks</span><span class="p">[</span><span class="n">ldrv_num</span><span class="o">%</span><span class="mh">0x80</span><span class="p">]</span> <span class="o">+=</span>
						<span class="n">mbox</span><span class="o">-&gt;</span><span class="n">m_out</span><span class="p">.</span><span class="n">numsectors</span><span class="p">;</span>
				<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
					<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">nwrites</span><span class="p">[</span><span class="n">ldrv_num</span><span class="o">%</span><span class="mh">0x80</span><span class="p">]</span><span class="o">++</span><span class="p">;</span>
					<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">nwriteblocks</span><span class="p">[</span><span class="n">ldrv_num</span><span class="o">%</span><span class="mh">0x80</span><span class="p">]</span> <span class="o">+=</span>
						<span class="n">mbox</span><span class="o">-&gt;</span><span class="n">m_out</span><span class="p">.</span><span class="n">numsectors</span><span class="p">;</span>
				<span class="p">}</span>
<span class="cp">#endif</span>
			<span class="p">}</span>

			<span class="cm">/*</span>
<span class="cm">			 * 10-byte READ(0x28) or WRITE(0x2A) cdb</span>
<span class="cm">			 */</span>
			<span class="k">if</span><span class="p">(</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">cmd_len</span> <span class="o">==</span> <span class="mi">10</span> <span class="p">)</span> <span class="p">{</span>
				<span class="n">mbox</span><span class="o">-&gt;</span><span class="n">m_out</span><span class="p">.</span><span class="n">numsectors</span> <span class="o">=</span>
					<span class="p">(</span><span class="n">u32</span><span class="p">)</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">8</span><span class="p">]</span> <span class="o">|</span>
					<span class="p">((</span><span class="n">u32</span><span class="p">)</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">);</span>
				<span class="n">mbox</span><span class="o">-&gt;</span><span class="n">m_out</span><span class="p">.</span><span class="n">lba</span> <span class="o">=</span>
					<span class="p">((</span><span class="n">u32</span><span class="p">)</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">24</span><span class="p">)</span> <span class="o">|</span>
					<span class="p">((</span><span class="n">u32</span><span class="p">)</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">|</span>
					<span class="p">((</span><span class="n">u32</span><span class="p">)</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">|</span>
					<span class="p">(</span><span class="n">u32</span><span class="p">)</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">5</span><span class="p">];</span>

<span class="cp">#if MEGA_HAVE_STATS</span>
				<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">cmnd</span> <span class="o">==</span> <span class="n">READ_10</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">nreads</span><span class="p">[</span><span class="n">ldrv_num</span><span class="o">%</span><span class="mh">0x80</span><span class="p">]</span><span class="o">++</span><span class="p">;</span>
					<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">nreadblocks</span><span class="p">[</span><span class="n">ldrv_num</span><span class="o">%</span><span class="mh">0x80</span><span class="p">]</span> <span class="o">+=</span>
						<span class="n">mbox</span><span class="o">-&gt;</span><span class="n">m_out</span><span class="p">.</span><span class="n">numsectors</span><span class="p">;</span>
				<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
					<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">nwrites</span><span class="p">[</span><span class="n">ldrv_num</span><span class="o">%</span><span class="mh">0x80</span><span class="p">]</span><span class="o">++</span><span class="p">;</span>
					<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">nwriteblocks</span><span class="p">[</span><span class="n">ldrv_num</span><span class="o">%</span><span class="mh">0x80</span><span class="p">]</span> <span class="o">+=</span>
						<span class="n">mbox</span><span class="o">-&gt;</span><span class="n">m_out</span><span class="p">.</span><span class="n">numsectors</span><span class="p">;</span>
				<span class="p">}</span>
<span class="cp">#endif</span>
			<span class="p">}</span>

			<span class="cm">/*</span>
<span class="cm">			 * 12-byte READ(0xA8) or WRITE(0xAA) cdb</span>
<span class="cm">			 */</span>
			<span class="k">if</span><span class="p">(</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">cmd_len</span> <span class="o">==</span> <span class="mi">12</span> <span class="p">)</span> <span class="p">{</span>
				<span class="n">mbox</span><span class="o">-&gt;</span><span class="n">m_out</span><span class="p">.</span><span class="n">lba</span> <span class="o">=</span>
					<span class="p">((</span><span class="n">u32</span><span class="p">)</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">24</span><span class="p">)</span> <span class="o">|</span>
					<span class="p">((</span><span class="n">u32</span><span class="p">)</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">|</span>
					<span class="p">((</span><span class="n">u32</span><span class="p">)</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">|</span>
					<span class="p">(</span><span class="n">u32</span><span class="p">)</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">5</span><span class="p">];</span>

				<span class="n">mbox</span><span class="o">-&gt;</span><span class="n">m_out</span><span class="p">.</span><span class="n">numsectors</span> <span class="o">=</span>
					<span class="p">((</span><span class="n">u32</span><span class="p">)</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">24</span><span class="p">)</span> <span class="o">|</span>
					<span class="p">((</span><span class="n">u32</span><span class="p">)</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">|</span>
					<span class="p">((</span><span class="n">u32</span><span class="p">)</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">8</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">|</span>
					<span class="p">(</span><span class="n">u32</span><span class="p">)</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">9</span><span class="p">];</span>

<span class="cp">#if MEGA_HAVE_STATS</span>
				<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">cmnd</span> <span class="o">==</span> <span class="n">READ_12</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">nreads</span><span class="p">[</span><span class="n">ldrv_num</span><span class="o">%</span><span class="mh">0x80</span><span class="p">]</span><span class="o">++</span><span class="p">;</span>
					<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">nreadblocks</span><span class="p">[</span><span class="n">ldrv_num</span><span class="o">%</span><span class="mh">0x80</span><span class="p">]</span> <span class="o">+=</span>
						<span class="n">mbox</span><span class="o">-&gt;</span><span class="n">m_out</span><span class="p">.</span><span class="n">numsectors</span><span class="p">;</span>
				<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
					<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">nwrites</span><span class="p">[</span><span class="n">ldrv_num</span><span class="o">%</span><span class="mh">0x80</span><span class="p">]</span><span class="o">++</span><span class="p">;</span>
					<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">nwriteblocks</span><span class="p">[</span><span class="n">ldrv_num</span><span class="o">%</span><span class="mh">0x80</span><span class="p">]</span> <span class="o">+=</span>
						<span class="n">mbox</span><span class="o">-&gt;</span><span class="n">m_out</span><span class="p">.</span><span class="n">numsectors</span><span class="p">;</span>
				<span class="p">}</span>
<span class="cp">#endif</span>
			<span class="p">}</span>

			<span class="cm">/*</span>
<span class="cm">			 * If it is a read command</span>
<span class="cm">			 */</span>
			<span class="k">if</span><span class="p">(</span> <span class="p">(</span><span class="o">*</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">cmnd</span> <span class="o">&amp;</span> <span class="mh">0x0F</span><span class="p">)</span> <span class="o">==</span> <span class="mh">0x08</span> <span class="p">)</span> <span class="p">{</span>
				<span class="n">scb</span><span class="o">-&gt;</span><span class="n">dma_direction</span> <span class="o">=</span> <span class="n">PCI_DMA_FROMDEVICE</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">else</span> <span class="p">{</span>
				<span class="n">scb</span><span class="o">-&gt;</span><span class="n">dma_direction</span> <span class="o">=</span> <span class="n">PCI_DMA_TODEVICE</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="cm">/* Calculate Scatter-Gather info */</span>
			<span class="n">mbox</span><span class="o">-&gt;</span><span class="n">m_out</span><span class="p">.</span><span class="n">numsgelements</span> <span class="o">=</span> <span class="n">mega_build_sglist</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">scb</span><span class="p">,</span>
					<span class="p">(</span><span class="n">u32</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">mbox</span><span class="o">-&gt;</span><span class="n">m_out</span><span class="p">.</span><span class="n">xferaddr</span><span class="p">,</span> <span class="p">(</span><span class="n">u32</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">seg</span><span class="p">);</span>

			<span class="k">return</span> <span class="n">scb</span><span class="p">;</span>

<span class="cp">#if MEGA_HAVE_CLUSTERING</span>
		<span class="k">case</span> <span class="n">RESERVE</span>:	<span class="cm">/* Fall through */</span>
		<span class="k">case</span> <span class="n">RELEASE</span>:

			<span class="cm">/*</span>
<span class="cm">			 * Do we support clustering and is the support enabled</span>
<span class="cm">			 */</span>
			<span class="k">if</span><span class="p">(</span> <span class="o">!</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">has_cluster</span> <span class="p">)</span> <span class="p">{</span>

				<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">=</span> <span class="p">(</span><span class="n">DID_BAD_TARGET</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">);</span>
				<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scsi_done</span><span class="p">(</span><span class="n">cmd</span><span class="p">);</span>
				<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="cm">/* Allocate a SCB and initialize mailbox */</span>
			<span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">scb</span> <span class="o">=</span> <span class="n">mega_allocate_scb</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">cmd</span><span class="p">)))</span> <span class="p">{</span>
				<span class="o">*</span><span class="n">busy</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
				<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="n">scb</span><span class="o">-&gt;</span><span class="n">raw_mbox</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">MEGA_CLUSTER_CMD</span><span class="p">;</span>
			<span class="n">scb</span><span class="o">-&gt;</span><span class="n">raw_mbox</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span> <span class="o">*</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">cmnd</span> <span class="o">==</span> <span class="n">RESERVE</span> <span class="p">)</span> <span class="o">?</span>
				<span class="n">MEGA_RESERVE_LD</span> <span class="o">:</span> <span class="n">MEGA_RELEASE_LD</span><span class="p">;</span>

			<span class="n">scb</span><span class="o">-&gt;</span><span class="n">raw_mbox</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">ldrv_num</span><span class="p">;</span>

			<span class="n">scb</span><span class="o">-&gt;</span><span class="n">dma_direction</span> <span class="o">=</span> <span class="n">PCI_DMA_NONE</span><span class="p">;</span>

			<span class="k">return</span> <span class="n">scb</span><span class="p">;</span>
<span class="cp">#endif</span>

		<span class="nl">default:</span>
			<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">=</span> <span class="p">(</span><span class="n">DID_BAD_TARGET</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">);</span>
			<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scsi_done</span><span class="p">(</span><span class="n">cmd</span><span class="p">);</span>
			<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Passthru drive commands</span>
<span class="cm">	 */</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* Allocate a SCB and initialize passthru */</span>
		<span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">scb</span> <span class="o">=</span> <span class="n">mega_allocate_scb</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">cmd</span><span class="p">)))</span> <span class="p">{</span>
			<span class="o">*</span><span class="n">busy</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">mbox</span> <span class="o">=</span> <span class="p">(</span><span class="n">mbox_t</span> <span class="o">*</span><span class="p">)</span><span class="n">scb</span><span class="o">-&gt;</span><span class="n">raw_mbox</span><span class="p">;</span>
		<span class="n">memset</span><span class="p">(</span><span class="n">mbox</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">scb</span><span class="o">-&gt;</span><span class="n">raw_mbox</span><span class="p">));</span>

		<span class="k">if</span><span class="p">(</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">support_ext_cdb</span> <span class="p">)</span> <span class="p">{</span>

			<span class="n">epthru</span> <span class="o">=</span> <span class="n">mega_prepare_extpassthru</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">scb</span><span class="p">,</span> <span class="n">cmd</span><span class="p">,</span>
					<span class="n">channel</span><span class="p">,</span> <span class="n">target</span><span class="p">);</span>

			<span class="n">mbox</span><span class="o">-&gt;</span><span class="n">m_out</span><span class="p">.</span><span class="n">cmd</span> <span class="o">=</span> <span class="n">MEGA_MBOXCMD_EXTPTHRU</span><span class="p">;</span>

			<span class="n">mbox</span><span class="o">-&gt;</span><span class="n">m_out</span><span class="p">.</span><span class="n">xferaddr</span> <span class="o">=</span> <span class="n">scb</span><span class="o">-&gt;</span><span class="n">epthru_dma_addr</span><span class="p">;</span>

		<span class="p">}</span>
		<span class="k">else</span> <span class="p">{</span>

			<span class="n">pthru</span> <span class="o">=</span> <span class="n">mega_prepare_passthru</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">scb</span><span class="p">,</span> <span class="n">cmd</span><span class="p">,</span>
					<span class="n">channel</span><span class="p">,</span> <span class="n">target</span><span class="p">);</span>

			<span class="cm">/* Initialize mailbox */</span>
			<span class="k">if</span><span class="p">(</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">has_64bit_addr</span> <span class="p">)</span> <span class="p">{</span>
				<span class="n">mbox</span><span class="o">-&gt;</span><span class="n">m_out</span><span class="p">.</span><span class="n">cmd</span> <span class="o">=</span> <span class="n">MEGA_MBOXCMD_PASSTHRU64</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">else</span> <span class="p">{</span>
				<span class="n">mbox</span><span class="o">-&gt;</span><span class="n">m_out</span><span class="p">.</span><span class="n">cmd</span> <span class="o">=</span> <span class="n">MEGA_MBOXCMD_PASSTHRU</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="n">mbox</span><span class="o">-&gt;</span><span class="n">m_out</span><span class="p">.</span><span class="n">xferaddr</span> <span class="o">=</span> <span class="n">scb</span><span class="o">-&gt;</span><span class="n">pthru_dma_addr</span><span class="p">;</span>

		<span class="p">}</span>
		<span class="k">return</span> <span class="n">scb</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/**</span>
<span class="cm"> * mega_prepare_passthru()</span>
<span class="cm"> * @adapter - pointer to our soft state</span>
<span class="cm"> * @scb - our scsi control block</span>
<span class="cm"> * @cmd - scsi command from the mid-layer</span>
<span class="cm"> * @channel - actual channel on the controller</span>
<span class="cm"> * @target - actual id on the controller.</span>
<span class="cm"> *</span>
<span class="cm"> * prepare a command for the scsi physical devices.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">mega_passthru</span> <span class="o">*</span>
<span class="nf">mega_prepare_passthru</span><span class="p">(</span><span class="n">adapter_t</span> <span class="o">*</span><span class="n">adapter</span><span class="p">,</span> <span class="n">scb_t</span> <span class="o">*</span><span class="n">scb</span><span class="p">,</span> <span class="n">Scsi_Cmnd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">,</span>
		<span class="kt">int</span> <span class="n">channel</span><span class="p">,</span> <span class="kt">int</span> <span class="n">target</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">mega_passthru</span> <span class="o">*</span><span class="n">pthru</span><span class="p">;</span>

	<span class="n">pthru</span> <span class="o">=</span> <span class="n">scb</span><span class="o">-&gt;</span><span class="n">pthru</span><span class="p">;</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">pthru</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span> <span class="p">(</span><span class="n">mega_passthru</span><span class="p">));</span>

	<span class="cm">/* 0=6sec/1=60sec/2=10min/3=3hrs */</span>
	<span class="n">pthru</span><span class="o">-&gt;</span><span class="n">timeout</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>

	<span class="n">pthru</span><span class="o">-&gt;</span><span class="n">ars</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">pthru</span><span class="o">-&gt;</span><span class="n">reqsenselen</span> <span class="o">=</span> <span class="mi">14</span><span class="p">;</span>
	<span class="n">pthru</span><span class="o">-&gt;</span><span class="n">islogical</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">pthru</span><span class="o">-&gt;</span><span class="n">channel</span> <span class="o">=</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">flag</span> <span class="o">&amp;</span> <span class="n">BOARD_40LD</span><span class="p">)</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="n">channel</span><span class="p">;</span>

	<span class="n">pthru</span><span class="o">-&gt;</span><span class="n">target</span> <span class="o">=</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">flag</span> <span class="o">&amp;</span> <span class="n">BOARD_40LD</span><span class="p">)</span> <span class="o">?</span>
		<span class="p">(</span><span class="n">channel</span> <span class="o">&lt;&lt;</span> <span class="mi">4</span><span class="p">)</span> <span class="o">|</span> <span class="n">target</span> <span class="o">:</span> <span class="n">target</span><span class="p">;</span>

	<span class="n">pthru</span><span class="o">-&gt;</span><span class="n">cdblen</span> <span class="o">=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">cmd_len</span><span class="p">;</span>
	<span class="n">pthru</span><span class="o">-&gt;</span><span class="n">logdrv</span> <span class="o">=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">lun</span><span class="p">;</span>

	<span class="n">memcpy</span><span class="p">(</span><span class="n">pthru</span><span class="o">-&gt;</span><span class="n">cdb</span><span class="p">,</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">,</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">cmd_len</span><span class="p">);</span>

	<span class="cm">/* Not sure about the direction */</span>
	<span class="n">scb</span><span class="o">-&gt;</span><span class="n">dma_direction</span> <span class="o">=</span> <span class="n">PCI_DMA_BIDIRECTIONAL</span><span class="p">;</span>

	<span class="cm">/* Special Code for Handling READ_CAPA/ INQ using bounce buffers */</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">INQUIRY</span>:
	<span class="k">case</span> <span class="n">READ_CAPACITY</span>:
		<span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">flag</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1L</span> <span class="o">&lt;&lt;</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">channel</span><span class="p">)))</span> <span class="p">{</span>

			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_NOTICE</span>
				<span class="s">&quot;scsi%d: scanning scsi channel %d [P%d] &quot;</span><span class="p">,</span>
					<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">host_no</span><span class="p">,</span>
					<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">channel</span><span class="p">,</span> <span class="n">channel</span><span class="p">);</span>
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot;for physical devices.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

			<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">flag</span> <span class="o">|=</span> <span class="p">(</span><span class="mi">1L</span> <span class="o">&lt;&lt;</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">channel</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="cm">/* Fall through */</span>
	<span class="nl">default:</span>
		<span class="n">pthru</span><span class="o">-&gt;</span><span class="n">numsgelements</span> <span class="o">=</span> <span class="n">mega_build_sglist</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">scb</span><span class="p">,</span>
				<span class="o">&amp;</span><span class="n">pthru</span><span class="o">-&gt;</span><span class="n">dataxferaddr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pthru</span><span class="o">-&gt;</span><span class="n">dataxferlen</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">pthru</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/**</span>
<span class="cm"> * mega_prepare_extpassthru()</span>
<span class="cm"> * @adapter - pointer to our soft state</span>
<span class="cm"> * @scb - our scsi control block</span>
<span class="cm"> * @cmd - scsi command from the mid-layer</span>
<span class="cm"> * @channel - actual channel on the controller</span>
<span class="cm"> * @target - actual id on the controller.</span>
<span class="cm"> *</span>
<span class="cm"> * prepare a command for the scsi physical devices. This rountine prepares</span>
<span class="cm"> * commands for devices which can take extended CDBs (&gt;10 bytes)</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">mega_ext_passthru</span> <span class="o">*</span>
<span class="nf">mega_prepare_extpassthru</span><span class="p">(</span><span class="n">adapter_t</span> <span class="o">*</span><span class="n">adapter</span><span class="p">,</span> <span class="n">scb_t</span> <span class="o">*</span><span class="n">scb</span><span class="p">,</span> <span class="n">Scsi_Cmnd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">,</span>
		<span class="kt">int</span> <span class="n">channel</span><span class="p">,</span> <span class="kt">int</span> <span class="n">target</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">mega_ext_passthru</span>	<span class="o">*</span><span class="n">epthru</span><span class="p">;</span>

	<span class="n">epthru</span> <span class="o">=</span> <span class="n">scb</span><span class="o">-&gt;</span><span class="n">epthru</span><span class="p">;</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">epthru</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">mega_ext_passthru</span><span class="p">));</span>

	<span class="cm">/* 0=6sec/1=60sec/2=10min/3=3hrs */</span>
	<span class="n">epthru</span><span class="o">-&gt;</span><span class="n">timeout</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>

	<span class="n">epthru</span><span class="o">-&gt;</span><span class="n">ars</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">epthru</span><span class="o">-&gt;</span><span class="n">reqsenselen</span> <span class="o">=</span> <span class="mi">14</span><span class="p">;</span>
	<span class="n">epthru</span><span class="o">-&gt;</span><span class="n">islogical</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">epthru</span><span class="o">-&gt;</span><span class="n">channel</span> <span class="o">=</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">flag</span> <span class="o">&amp;</span> <span class="n">BOARD_40LD</span><span class="p">)</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="n">channel</span><span class="p">;</span>
	<span class="n">epthru</span><span class="o">-&gt;</span><span class="n">target</span> <span class="o">=</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">flag</span> <span class="o">&amp;</span> <span class="n">BOARD_40LD</span><span class="p">)</span> <span class="o">?</span>
		<span class="p">(</span><span class="n">channel</span> <span class="o">&lt;&lt;</span> <span class="mi">4</span><span class="p">)</span> <span class="o">|</span> <span class="n">target</span> <span class="o">:</span> <span class="n">target</span><span class="p">;</span>

	<span class="n">epthru</span><span class="o">-&gt;</span><span class="n">cdblen</span> <span class="o">=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">cmd_len</span><span class="p">;</span>
	<span class="n">epthru</span><span class="o">-&gt;</span><span class="n">logdrv</span> <span class="o">=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">lun</span><span class="p">;</span>

	<span class="n">memcpy</span><span class="p">(</span><span class="n">epthru</span><span class="o">-&gt;</span><span class="n">cdb</span><span class="p">,</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">,</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">cmd_len</span><span class="p">);</span>

	<span class="cm">/* Not sure about the direction */</span>
	<span class="n">scb</span><span class="o">-&gt;</span><span class="n">dma_direction</span> <span class="o">=</span> <span class="n">PCI_DMA_BIDIRECTIONAL</span><span class="p">;</span>

	<span class="k">switch</span><span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">INQUIRY</span>:
	<span class="k">case</span> <span class="n">READ_CAPACITY</span>:
		<span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">flag</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1L</span> <span class="o">&lt;&lt;</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">channel</span><span class="p">)))</span> <span class="p">{</span>

			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_NOTICE</span>
				<span class="s">&quot;scsi%d: scanning scsi channel %d [P%d] &quot;</span><span class="p">,</span>
					<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">host_no</span><span class="p">,</span>
					<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">channel</span><span class="p">,</span> <span class="n">channel</span><span class="p">);</span>
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot;for physical devices.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

			<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">flag</span> <span class="o">|=</span> <span class="p">(</span><span class="mi">1L</span> <span class="o">&lt;&lt;</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">channel</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="cm">/* Fall through */</span>
	<span class="nl">default:</span>
		<span class="n">epthru</span><span class="o">-&gt;</span><span class="n">numsgelements</span> <span class="o">=</span> <span class="n">mega_build_sglist</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">scb</span><span class="p">,</span>
				<span class="o">&amp;</span><span class="n">epthru</span><span class="o">-&gt;</span><span class="n">dataxferaddr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">epthru</span><span class="o">-&gt;</span><span class="n">dataxferlen</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">epthru</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">__mega_runpendq</span><span class="p">(</span><span class="n">adapter_t</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">scb_t</span> <span class="o">*</span><span class="n">scb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">pos</span><span class="p">,</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>

	<span class="cm">/* Issue any pending commands to the card */</span>
	<span class="n">list_for_each_safe</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="n">next</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pending_list</span><span class="p">)</span> <span class="p">{</span>

		<span class="n">scb</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="n">scb_t</span><span class="p">,</span> <span class="n">list</span><span class="p">);</span>

		<span class="k">if</span><span class="p">(</span> <span class="o">!</span><span class="p">(</span><span class="n">scb</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">&amp;</span> <span class="n">SCB_ISSUED</span><span class="p">)</span> <span class="p">)</span> <span class="p">{</span>

			<span class="k">if</span><span class="p">(</span> <span class="n">issue_scb</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">scb</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">)</span>
				<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/**</span>
<span class="cm"> * issue_scb()</span>
<span class="cm"> * @adapter - pointer to our soft state</span>
<span class="cm"> * @scb - scsi control block</span>
<span class="cm"> *</span>
<span class="cm"> * Post a command to the card if the mailbox is available, otherwise return</span>
<span class="cm"> * busy. We also take the scb from the pending list if the mailbox is</span>
<span class="cm"> * available.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">issue_scb</span><span class="p">(</span><span class="n">adapter_t</span> <span class="o">*</span><span class="n">adapter</span><span class="p">,</span> <span class="n">scb_t</span> <span class="o">*</span><span class="n">scb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">volatile</span> <span class="n">mbox64_t</span>	<span class="o">*</span><span class="n">mbox64</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">mbox64</span><span class="p">;</span>
	<span class="k">volatile</span> <span class="n">mbox_t</span>		<span class="o">*</span><span class="n">mbox</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">mbox</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>	<span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span><span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">mbox</span><span class="o">-&gt;</span><span class="n">m_in</span><span class="p">.</span><span class="n">busy</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">do</span> <span class="p">{</span>
			<span class="n">udelay</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
			<span class="n">i</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">while</span><span class="p">(</span> <span class="n">mbox</span><span class="o">-&gt;</span><span class="n">m_in</span><span class="p">.</span><span class="n">busy</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">max_mbox_busy_wait</span><span class="p">)</span> <span class="p">);</span>

		<span class="k">if</span><span class="p">(</span><span class="n">mbox</span><span class="o">-&gt;</span><span class="n">m_in</span><span class="p">.</span><span class="n">busy</span><span class="p">)</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Copy mailbox data into host structure */</span>
	<span class="n">memcpy</span><span class="p">((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">mbox</span><span class="o">-&gt;</span><span class="n">m_out</span><span class="p">,</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">scb</span><span class="o">-&gt;</span><span class="n">raw_mbox</span><span class="p">,</span> 
			<span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">mbox_out</span><span class="p">));</span>

	<span class="n">mbox</span><span class="o">-&gt;</span><span class="n">m_out</span><span class="p">.</span><span class="n">cmdid</span> <span class="o">=</span> <span class="n">scb</span><span class="o">-&gt;</span><span class="n">idx</span><span class="p">;</span>	<span class="cm">/* Set cmdid */</span>
	<span class="n">mbox</span><span class="o">-&gt;</span><span class="n">m_in</span><span class="p">.</span><span class="n">busy</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>		<span class="cm">/* Set busy */</span>


	<span class="cm">/*</span>
<span class="cm">	 * Increment the pending queue counter</span>
<span class="cm">	 */</span>
	<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pend_cmds</span><span class="p">);</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">mbox</span><span class="o">-&gt;</span><span class="n">m_out</span><span class="p">.</span><span class="n">cmd</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">MEGA_MBOXCMD_LREAD64</span>:
	<span class="k">case</span> <span class="n">MEGA_MBOXCMD_LWRITE64</span>:
	<span class="k">case</span> <span class="n">MEGA_MBOXCMD_PASSTHRU64</span>:
	<span class="k">case</span> <span class="n">MEGA_MBOXCMD_EXTPTHRU</span>:
		<span class="n">mbox64</span><span class="o">-&gt;</span><span class="n">xfer_segment_lo</span> <span class="o">=</span> <span class="n">mbox</span><span class="o">-&gt;</span><span class="n">m_out</span><span class="p">.</span><span class="n">xferaddr</span><span class="p">;</span>
		<span class="n">mbox64</span><span class="o">-&gt;</span><span class="n">xfer_segment_hi</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">mbox</span><span class="o">-&gt;</span><span class="n">m_out</span><span class="p">.</span><span class="n">xferaddr</span> <span class="o">=</span> <span class="mh">0xFFFFFFFF</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">mbox64</span><span class="o">-&gt;</span><span class="n">xfer_segment_lo</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">mbox64</span><span class="o">-&gt;</span><span class="n">xfer_segment_hi</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * post the command</span>
<span class="cm">	 */</span>
	<span class="n">scb</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">|=</span> <span class="n">SCB_ISSUED</span><span class="p">;</span>

	<span class="k">if</span><span class="p">(</span> <span class="n">likely</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">flag</span> <span class="o">&amp;</span> <span class="n">BOARD_MEMMAP</span><span class="p">)</span> <span class="p">)</span> <span class="p">{</span>
		<span class="n">mbox</span><span class="o">-&gt;</span><span class="n">m_in</span><span class="p">.</span><span class="n">poll</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">mbox</span><span class="o">-&gt;</span><span class="n">m_in</span><span class="p">.</span><span class="n">ack</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">WRINDOOR</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">mbox_dma</span> <span class="o">|</span> <span class="mh">0x1</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="n">irq_enable</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
		<span class="n">issue_command</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Wait until the controller&#39;s mailbox is available</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span>
<span class="nf">mega_busywait_mbox</span> <span class="p">(</span><span class="n">adapter_t</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">mbox</span><span class="o">-&gt;</span><span class="n">m_in</span><span class="p">.</span><span class="n">busy</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">__mega_busywait_mbox</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * issue_scb_block()</span>
<span class="cm"> * @adapter - pointer to our soft state</span>
<span class="cm"> * @raw_mbox - the mailbox</span>
<span class="cm"> *</span>
<span class="cm"> * Issue a scb in synchronous and non-interrupt mode</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">issue_scb_block</span><span class="p">(</span><span class="n">adapter_t</span> <span class="o">*</span><span class="n">adapter</span><span class="p">,</span> <span class="n">u_char</span> <span class="o">*</span><span class="n">raw_mbox</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">volatile</span> <span class="n">mbox64_t</span> <span class="o">*</span><span class="n">mbox64</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">mbox64</span><span class="p">;</span>
	<span class="k">volatile</span> <span class="n">mbox_t</span> <span class="o">*</span><span class="n">mbox</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">mbox</span><span class="p">;</span>
	<span class="n">u8</span>	<span class="n">byte</span><span class="p">;</span>

	<span class="cm">/* Wait until mailbox is free */</span>
	<span class="k">if</span><span class="p">(</span><span class="n">mega_busywait_mbox</span> <span class="p">(</span><span class="n">adapter</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">bug_blocked_mailbox</span><span class="p">;</span>

	<span class="cm">/* Copy mailbox data into host structure */</span>
	<span class="n">memcpy</span><span class="p">((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span> <span class="n">mbox</span><span class="p">,</span> <span class="n">raw_mbox</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">mbox_out</span><span class="p">));</span>
	<span class="n">mbox</span><span class="o">-&gt;</span><span class="n">m_out</span><span class="p">.</span><span class="n">cmdid</span> <span class="o">=</span> <span class="mh">0xFE</span><span class="p">;</span>
	<span class="n">mbox</span><span class="o">-&gt;</span><span class="n">m_in</span><span class="p">.</span><span class="n">busy</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">raw_mbox</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">MEGA_MBOXCMD_LREAD64</span>:
	<span class="k">case</span> <span class="n">MEGA_MBOXCMD_LWRITE64</span>:
	<span class="k">case</span> <span class="n">MEGA_MBOXCMD_PASSTHRU64</span>:
	<span class="k">case</span> <span class="n">MEGA_MBOXCMD_EXTPTHRU</span>:
		<span class="n">mbox64</span><span class="o">-&gt;</span><span class="n">xfer_segment_lo</span> <span class="o">=</span> <span class="n">mbox</span><span class="o">-&gt;</span><span class="n">m_out</span><span class="p">.</span><span class="n">xferaddr</span><span class="p">;</span>
		<span class="n">mbox64</span><span class="o">-&gt;</span><span class="n">xfer_segment_hi</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">mbox</span><span class="o">-&gt;</span><span class="n">m_out</span><span class="p">.</span><span class="n">xferaddr</span> <span class="o">=</span> <span class="mh">0xFFFFFFFF</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">mbox64</span><span class="o">-&gt;</span><span class="n">xfer_segment_lo</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">mbox64</span><span class="o">-&gt;</span><span class="n">xfer_segment_hi</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span><span class="p">(</span> <span class="n">likely</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">flag</span> <span class="o">&amp;</span> <span class="n">BOARD_MEMMAP</span><span class="p">)</span> <span class="p">)</span> <span class="p">{</span>
		<span class="n">mbox</span><span class="o">-&gt;</span><span class="n">m_in</span><span class="p">.</span><span class="n">poll</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">mbox</span><span class="o">-&gt;</span><span class="n">m_in</span><span class="p">.</span><span class="n">ack</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">mbox</span><span class="o">-&gt;</span><span class="n">m_in</span><span class="p">.</span><span class="n">numstatus</span> <span class="o">=</span> <span class="mh">0xFF</span><span class="p">;</span>
		<span class="n">mbox</span><span class="o">-&gt;</span><span class="n">m_in</span><span class="p">.</span><span class="n">status</span> <span class="o">=</span> <span class="mh">0xFF</span><span class="p">;</span>
		<span class="n">WRINDOOR</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">mbox_dma</span> <span class="o">|</span> <span class="mh">0x1</span><span class="p">);</span>

		<span class="k">while</span><span class="p">((</span><span class="k">volatile</span> <span class="n">u8</span><span class="p">)</span><span class="n">mbox</span><span class="o">-&gt;</span><span class="n">m_in</span><span class="p">.</span><span class="n">numstatus</span> <span class="o">==</span> <span class="mh">0xFF</span><span class="p">)</span>
			<span class="n">cpu_relax</span><span class="p">();</span>

		<span class="n">mbox</span><span class="o">-&gt;</span><span class="n">m_in</span><span class="p">.</span><span class="n">numstatus</span> <span class="o">=</span> <span class="mh">0xFF</span><span class="p">;</span>

		<span class="k">while</span><span class="p">(</span> <span class="p">(</span><span class="k">volatile</span> <span class="n">u8</span><span class="p">)</span><span class="n">mbox</span><span class="o">-&gt;</span><span class="n">m_in</span><span class="p">.</span><span class="n">poll</span> <span class="o">!=</span> <span class="mh">0x77</span> <span class="p">)</span>
			<span class="n">cpu_relax</span><span class="p">();</span>

		<span class="n">mbox</span><span class="o">-&gt;</span><span class="n">m_in</span><span class="p">.</span><span class="n">poll</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">mbox</span><span class="o">-&gt;</span><span class="n">m_in</span><span class="p">.</span><span class="n">ack</span> <span class="o">=</span> <span class="mh">0x77</span><span class="p">;</span>

		<span class="n">WRINDOOR</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">mbox_dma</span> <span class="o">|</span> <span class="mh">0x2</span><span class="p">);</span>

		<span class="k">while</span><span class="p">(</span><span class="n">RDINDOOR</span><span class="p">(</span><span class="n">adapter</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x2</span><span class="p">)</span>
			<span class="n">cpu_relax</span><span class="p">();</span>
	<span class="p">}</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="n">irq_disable</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
		<span class="n">issue_command</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>

		<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="p">((</span><span class="n">byte</span> <span class="o">=</span> <span class="n">irq_state</span><span class="p">(</span><span class="n">adapter</span><span class="p">))</span> <span class="o">&amp;</span> <span class="n">INTR_VALID</span><span class="p">))</span>
			<span class="n">cpu_relax</span><span class="p">();</span>

		<span class="n">set_irq_state</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">byte</span><span class="p">);</span>
		<span class="n">irq_enable</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
		<span class="n">irq_ack</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">mbox</span><span class="o">-&gt;</span><span class="n">m_in</span><span class="p">.</span><span class="n">status</span><span class="p">;</span>

<span class="nl">bug_blocked_mailbox:</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;megaraid: Blocked mailbox......!!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">udelay</span> <span class="p">(</span><span class="mi">1000</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/**</span>
<span class="cm"> * megaraid_isr_iomapped()</span>
<span class="cm"> * @irq - irq</span>
<span class="cm"> * @devp - pointer to our soft state</span>
<span class="cm"> *</span>
<span class="cm"> * Interrupt service routine for io-mapped controllers.</span>
<span class="cm"> * Find out if our device is interrupting. If yes, acknowledge the interrupt</span>
<span class="cm"> * and service the completed commands.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">irqreturn_t</span>
<span class="nf">megaraid_isr_iomapped</span><span class="p">(</span><span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">devp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">adapter_t</span>	<span class="o">*</span><span class="n">adapter</span> <span class="o">=</span> <span class="n">devp</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>	<span class="n">flags</span><span class="p">;</span>
	<span class="n">u8</span>	<span class="n">status</span><span class="p">;</span>
	<span class="n">u8</span>	<span class="n">nstatus</span><span class="p">;</span>
	<span class="n">u8</span>	<span class="n">completed</span><span class="p">[</span><span class="n">MAX_FIRMWARE_STATUS</span><span class="p">];</span>
	<span class="n">u8</span>	<span class="n">byte</span><span class="p">;</span>
	<span class="kt">int</span>	<span class="n">handled</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>


	<span class="cm">/*</span>
<span class="cm">	 * loop till F/W has more commands for us to complete.</span>
<span class="cm">	 */</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">do</span> <span class="p">{</span>
		<span class="cm">/* Check if a valid interrupt is pending */</span>
		<span class="n">byte</span> <span class="o">=</span> <span class="n">irq_state</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
		<span class="k">if</span><span class="p">(</span> <span class="p">(</span><span class="n">byte</span> <span class="o">&amp;</span> <span class="n">VALID_INTR_BYTE</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * No more pending commands</span>
<span class="cm">			 */</span>
			<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">set_irq_state</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">byte</span><span class="p">);</span>

		<span class="k">while</span><span class="p">((</span><span class="n">nstatus</span> <span class="o">=</span> <span class="p">(</span><span class="k">volatile</span> <span class="n">u8</span><span class="p">)</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">mbox</span><span class="o">-&gt;</span><span class="n">m_in</span><span class="p">.</span><span class="n">numstatus</span><span class="p">)</span>
				<span class="o">==</span> <span class="mh">0xFF</span><span class="p">)</span>
			<span class="n">cpu_relax</span><span class="p">();</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">mbox</span><span class="o">-&gt;</span><span class="n">m_in</span><span class="p">.</span><span class="n">numstatus</span> <span class="o">=</span> <span class="mh">0xFF</span><span class="p">;</span>

		<span class="n">status</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">mbox</span><span class="o">-&gt;</span><span class="n">m_in</span><span class="p">.</span><span class="n">status</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * decrement the pending queue counter</span>
<span class="cm">		 */</span>
		<span class="n">atomic_sub</span><span class="p">(</span><span class="n">nstatus</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pend_cmds</span><span class="p">);</span>

		<span class="n">memcpy</span><span class="p">(</span><span class="n">completed</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">mbox</span><span class="o">-&gt;</span><span class="n">m_in</span><span class="p">.</span><span class="n">completed</span><span class="p">,</span> 
				<span class="n">nstatus</span><span class="p">);</span>

		<span class="cm">/* Acknowledge interrupt */</span>
		<span class="n">irq_ack</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>

		<span class="n">mega_cmd_done</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">completed</span><span class="p">,</span> <span class="n">nstatus</span><span class="p">,</span> <span class="n">status</span><span class="p">);</span>

		<span class="n">mega_rundoneq</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>

		<span class="n">handled</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

		<span class="cm">/* Loop through any pending requests */</span>
		<span class="k">if</span><span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">quiescent</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">mega_runpendq</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
		<span class="p">}</span>

	<span class="p">}</span> <span class="k">while</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>

 <span class="nl">out_unlock:</span>

	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">IRQ_RETVAL</span><span class="p">(</span><span class="n">handled</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/**</span>
<span class="cm"> * megaraid_isr_memmapped()</span>
<span class="cm"> * @irq - irq</span>
<span class="cm"> * @devp - pointer to our soft state</span>
<span class="cm"> *</span>
<span class="cm"> * Interrupt service routine for memory-mapped controllers.</span>
<span class="cm"> * Find out if our device is interrupting. If yes, acknowledge the interrupt</span>
<span class="cm"> * and service the completed commands.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">irqreturn_t</span>
<span class="nf">megaraid_isr_memmapped</span><span class="p">(</span><span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">devp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">adapter_t</span>	<span class="o">*</span><span class="n">adapter</span> <span class="o">=</span> <span class="n">devp</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>	<span class="n">flags</span><span class="p">;</span>
	<span class="n">u8</span>	<span class="n">status</span><span class="p">;</span>
	<span class="n">u32</span>	<span class="n">dword</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u8</span>	<span class="n">nstatus</span><span class="p">;</span>
	<span class="n">u8</span>	<span class="n">completed</span><span class="p">[</span><span class="n">MAX_FIRMWARE_STATUS</span><span class="p">];</span>
	<span class="kt">int</span>	<span class="n">handled</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>


	<span class="cm">/*</span>
<span class="cm">	 * loop till F/W has more commands for us to complete.</span>
<span class="cm">	 */</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">do</span> <span class="p">{</span>
		<span class="cm">/* Check if a valid interrupt is pending */</span>
		<span class="n">dword</span> <span class="o">=</span> <span class="n">RDOUTDOOR</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
		<span class="k">if</span><span class="p">(</span><span class="n">dword</span> <span class="o">!=</span> <span class="mh">0x10001234</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * No more pending commands</span>
<span class="cm">			 */</span>
			<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">WROUTDOOR</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="mh">0x10001234</span><span class="p">);</span>

		<span class="k">while</span><span class="p">((</span><span class="n">nstatus</span> <span class="o">=</span> <span class="p">(</span><span class="k">volatile</span> <span class="n">u8</span><span class="p">)</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">mbox</span><span class="o">-&gt;</span><span class="n">m_in</span><span class="p">.</span><span class="n">numstatus</span><span class="p">)</span>
				<span class="o">==</span> <span class="mh">0xFF</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">cpu_relax</span><span class="p">();</span>
		<span class="p">}</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">mbox</span><span class="o">-&gt;</span><span class="n">m_in</span><span class="p">.</span><span class="n">numstatus</span> <span class="o">=</span> <span class="mh">0xFF</span><span class="p">;</span>

		<span class="n">status</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">mbox</span><span class="o">-&gt;</span><span class="n">m_in</span><span class="p">.</span><span class="n">status</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * decrement the pending queue counter</span>
<span class="cm">		 */</span>
		<span class="n">atomic_sub</span><span class="p">(</span><span class="n">nstatus</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pend_cmds</span><span class="p">);</span>

		<span class="n">memcpy</span><span class="p">(</span><span class="n">completed</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">mbox</span><span class="o">-&gt;</span><span class="n">m_in</span><span class="p">.</span><span class="n">completed</span><span class="p">,</span> 
				<span class="n">nstatus</span><span class="p">);</span>

		<span class="cm">/* Acknowledge interrupt */</span>
		<span class="n">WRINDOOR</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="mh">0x2</span><span class="p">);</span>

		<span class="n">handled</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

		<span class="k">while</span><span class="p">(</span> <span class="n">RDINDOOR</span><span class="p">(</span><span class="n">adapter</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x02</span> <span class="p">)</span>
			<span class="n">cpu_relax</span><span class="p">();</span>

		<span class="n">mega_cmd_done</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">completed</span><span class="p">,</span> <span class="n">nstatus</span><span class="p">,</span> <span class="n">status</span><span class="p">);</span>

		<span class="n">mega_rundoneq</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>

		<span class="cm">/* Loop through any pending requests */</span>
		<span class="k">if</span><span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">quiescent</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">mega_runpendq</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
		<span class="p">}</span>

	<span class="p">}</span> <span class="k">while</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>

 <span class="nl">out_unlock:</span>

	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">IRQ_RETVAL</span><span class="p">(</span><span class="n">handled</span><span class="p">);</span>
<span class="p">}</span>
<span class="cm">/**</span>
<span class="cm"> * mega_cmd_done()</span>
<span class="cm"> * @adapter - pointer to our soft state</span>
<span class="cm"> * @completed - array of ids of completed commands</span>
<span class="cm"> * @nstatus - number of completed commands</span>
<span class="cm"> * @status - status of the last command completed</span>
<span class="cm"> *</span>
<span class="cm"> * Complete the commands and call the scsi mid-layer callback hooks.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">mega_cmd_done</span><span class="p">(</span><span class="n">adapter_t</span> <span class="o">*</span><span class="n">adapter</span><span class="p">,</span> <span class="n">u8</span> <span class="n">completed</span><span class="p">[],</span> <span class="kt">int</span> <span class="n">nstatus</span><span class="p">,</span> <span class="kt">int</span> <span class="n">status</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">mega_ext_passthru</span>	<span class="o">*</span><span class="n">epthru</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">scatterlist</span>	<span class="o">*</span><span class="n">sgl</span><span class="p">;</span>
	<span class="n">Scsi_Cmnd</span>	<span class="o">*</span><span class="n">cmd</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">mega_passthru</span>	<span class="o">*</span><span class="n">pthru</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">mbox_t</span>	<span class="o">*</span><span class="n">mbox</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">u8</span>	<span class="n">c</span><span class="p">;</span>
	<span class="n">scb_t</span>	<span class="o">*</span><span class="n">scb</span><span class="p">;</span>
	<span class="kt">int</span>	<span class="n">islogical</span><span class="p">;</span>
	<span class="kt">int</span>	<span class="n">cmdid</span><span class="p">;</span>
	<span class="kt">int</span>	<span class="n">i</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * for all the commands completed, call the mid-layer callback routine</span>
<span class="cm">	 * and free the scb.</span>
<span class="cm">	 */</span>
	<span class="k">for</span><span class="p">(</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nstatus</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span> <span class="p">)</span> <span class="p">{</span>

		<span class="n">cmdid</span> <span class="o">=</span> <span class="n">completed</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

		<span class="k">if</span><span class="p">(</span> <span class="n">cmdid</span> <span class="o">==</span> <span class="n">CMDID_INT_CMDS</span> <span class="p">)</span> <span class="p">{</span> <span class="cm">/* internal command */</span>
			<span class="n">scb</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">int_scb</span><span class="p">;</span>
			<span class="n">cmd</span> <span class="o">=</span> <span class="n">scb</span><span class="o">-&gt;</span><span class="n">cmd</span><span class="p">;</span>
			<span class="n">mbox</span> <span class="o">=</span> <span class="p">(</span><span class="n">mbox_t</span> <span class="o">*</span><span class="p">)</span><span class="n">scb</span><span class="o">-&gt;</span><span class="n">raw_mbox</span><span class="p">;</span>

			<span class="cm">/*</span>
<span class="cm">			 * Internal command interface do not fire the extended</span>
<span class="cm">			 * passthru or 64-bit passthru</span>
<span class="cm">			 */</span>
			<span class="n">pthru</span> <span class="o">=</span> <span class="n">scb</span><span class="o">-&gt;</span><span class="n">pthru</span><span class="p">;</span>

		<span class="p">}</span>
		<span class="k">else</span> <span class="p">{</span>
			<span class="n">scb</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">scb_list</span><span class="p">[</span><span class="n">cmdid</span><span class="p">];</span>

			<span class="cm">/*</span>
<span class="cm">			 * Make sure f/w has completed a valid command</span>
<span class="cm">			 */</span>
			<span class="k">if</span><span class="p">(</span> <span class="o">!</span><span class="p">(</span><span class="n">scb</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">&amp;</span> <span class="n">SCB_ISSUED</span><span class="p">)</span> <span class="o">||</span> <span class="n">scb</span><span class="o">-&gt;</span><span class="n">cmd</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="p">)</span> <span class="p">{</span>
				<span class="n">printk</span><span class="p">(</span><span class="n">KERN_CRIT</span>
					<span class="s">&quot;megaraid: invalid command &quot;</span><span class="p">);</span>
				<span class="n">printk</span><span class="p">(</span><span class="s">&quot;Id %d, scb-&gt;state:%x, scsi cmd:%p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">cmdid</span><span class="p">,</span> <span class="n">scb</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">,</span> <span class="n">scb</span><span class="o">-&gt;</span><span class="n">cmd</span><span class="p">);</span>

				<span class="k">continue</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="cm">/*</span>
<span class="cm">			 * Was a abort issued for this command</span>
<span class="cm">			 */</span>
			<span class="k">if</span><span class="p">(</span> <span class="n">scb</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">&amp;</span> <span class="n">SCB_ABORT</span> <span class="p">)</span> <span class="p">{</span>

				<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span>
				<span class="s">&quot;megaraid: aborted cmd [%x] complete.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">scb</span><span class="o">-&gt;</span><span class="n">idx</span><span class="p">);</span>

				<span class="n">scb</span><span class="o">-&gt;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">=</span> <span class="p">(</span><span class="n">DID_ABORT</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">);</span>

				<span class="n">list_add_tail</span><span class="p">(</span><span class="n">SCSI_LIST</span><span class="p">(</span><span class="n">scb</span><span class="o">-&gt;</span><span class="n">cmd</span><span class="p">),</span>
						<span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">completed_list</span><span class="p">);</span>

				<span class="n">mega_free_scb</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">scb</span><span class="p">);</span>

				<span class="k">continue</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="cm">/*</span>
<span class="cm">			 * Was a reset issued for this command</span>
<span class="cm">			 */</span>
			<span class="k">if</span><span class="p">(</span> <span class="n">scb</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">&amp;</span> <span class="n">SCB_RESET</span> <span class="p">)</span> <span class="p">{</span>

				<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span>
				<span class="s">&quot;megaraid: reset cmd [%x] complete.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">scb</span><span class="o">-&gt;</span><span class="n">idx</span><span class="p">);</span>

				<span class="n">scb</span><span class="o">-&gt;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">=</span> <span class="p">(</span><span class="n">DID_RESET</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">);</span>

				<span class="n">list_add_tail</span><span class="p">(</span><span class="n">SCSI_LIST</span><span class="p">(</span><span class="n">scb</span><span class="o">-&gt;</span><span class="n">cmd</span><span class="p">),</span>
						<span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">completed_list</span><span class="p">);</span>

				<span class="n">mega_free_scb</span> <span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">scb</span><span class="p">);</span>

				<span class="k">continue</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="n">cmd</span> <span class="o">=</span> <span class="n">scb</span><span class="o">-&gt;</span><span class="n">cmd</span><span class="p">;</span>
			<span class="n">pthru</span> <span class="o">=</span> <span class="n">scb</span><span class="o">-&gt;</span><span class="n">pthru</span><span class="p">;</span>
			<span class="n">epthru</span> <span class="o">=</span> <span class="n">scb</span><span class="o">-&gt;</span><span class="n">epthru</span><span class="p">;</span>
			<span class="n">mbox</span> <span class="o">=</span> <span class="p">(</span><span class="n">mbox_t</span> <span class="o">*</span><span class="p">)</span><span class="n">scb</span><span class="o">-&gt;</span><span class="n">raw_mbox</span><span class="p">;</span>

<span class="cp">#if MEGA_HAVE_STATS</span>
			<span class="p">{</span>

			<span class="kt">int</span>	<span class="n">logdrv</span> <span class="o">=</span> <span class="n">mbox</span><span class="o">-&gt;</span><span class="n">m_out</span><span class="p">.</span><span class="n">logdrv</span><span class="p">;</span>

			<span class="n">islogical</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">logdrv_chan</span><span class="p">[</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">channel</span><span class="p">];</span>
			<span class="cm">/*</span>
<span class="cm">			 * Maintain an error counter for the logical drive.</span>
<span class="cm">			 * Some application like SNMP agent need such</span>
<span class="cm">			 * statistics</span>
<span class="cm">			 */</span>
			<span class="k">if</span><span class="p">(</span> <span class="n">status</span> <span class="o">&amp;&amp;</span> <span class="n">islogical</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">READ_6</span> <span class="o">||</span>
						<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">READ_10</span> <span class="o">||</span>
						<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">READ_12</span><span class="p">))</span> <span class="p">{</span>
				<span class="cm">/*</span>
<span class="cm">				 * Logical drive number increases by 0x80 when</span>
<span class="cm">				 * a logical drive is deleted</span>
<span class="cm">				 */</span>
				<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rd_errors</span><span class="p">[</span><span class="n">logdrv</span><span class="o">%</span><span class="mh">0x80</span><span class="p">]</span><span class="o">++</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="k">if</span><span class="p">(</span> <span class="n">status</span> <span class="o">&amp;&amp;</span> <span class="n">islogical</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">WRITE_6</span> <span class="o">||</span>
						<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">WRITE_10</span> <span class="o">||</span>
						<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">WRITE_12</span><span class="p">))</span> <span class="p">{</span>
				<span class="cm">/*</span>
<span class="cm">				 * Logical drive number increases by 0x80 when</span>
<span class="cm">				 * a logical drive is deleted</span>
<span class="cm">				 */</span>
				<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">wr_errors</span><span class="p">[</span><span class="n">logdrv</span><span class="o">%</span><span class="mh">0x80</span><span class="p">]</span><span class="o">++</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="p">}</span>
<span class="cp">#endif</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 * Do not return the presence of hard disk on the channel so,</span>
<span class="cm">		 * inquiry sent, and returned data==hard disk or removable</span>
<span class="cm">		 * hard disk and not logical, request should return failure! -</span>
<span class="cm">		 * PJ</span>
<span class="cm">		 */</span>
		<span class="n">islogical</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">logdrv_chan</span><span class="p">[</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">channel</span><span class="p">];</span>
		<span class="k">if</span><span class="p">(</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">INQUIRY</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">islogical</span> <span class="p">)</span> <span class="p">{</span>

			<span class="n">sgl</span> <span class="o">=</span> <span class="n">scsi_sglist</span><span class="p">(</span><span class="n">cmd</span><span class="p">);</span>
			<span class="k">if</span><span class="p">(</span> <span class="n">sg_page</span><span class="p">(</span><span class="n">sgl</span><span class="p">)</span> <span class="p">)</span> <span class="p">{</span>
				<span class="n">c</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="p">)</span> <span class="n">sg_virt</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sgl</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span>
				       <span class="s">&quot;megaraid: invalid sg.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
				<span class="n">c</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="k">if</span><span class="p">(</span><span class="n">IS_RAID_CH</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">channel</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
					<span class="p">((</span><span class="n">c</span> <span class="o">&amp;</span> <span class="mh">0x1F</span> <span class="p">)</span> <span class="o">==</span> <span class="n">TYPE_DISK</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">status</span> <span class="o">=</span> <span class="mh">0xF0</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="cm">/* clear result; otherwise, success returns corrupt value */</span>
		<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="cm">/* Convert MegaRAID status to Linux error code */</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">status</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="mh">0x00</span>:	<span class="cm">/* SUCCESS , i.e. SCSI_STATUS_GOOD */</span>
			<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">|=</span> <span class="p">(</span><span class="n">DID_OK</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="mh">0x02</span>:	<span class="cm">/* ERROR_ABORTED, i.e.</span>
<span class="cm">				   SCSI_STATUS_CHECK_CONDITION */</span>

			<span class="cm">/* set sense_buffer and result fields */</span>
			<span class="k">if</span><span class="p">(</span> <span class="n">mbox</span><span class="o">-&gt;</span><span class="n">m_out</span><span class="p">.</span><span class="n">cmd</span> <span class="o">==</span> <span class="n">MEGA_MBOXCMD_PASSTHRU</span> <span class="o">||</span>
				<span class="n">mbox</span><span class="o">-&gt;</span><span class="n">m_out</span><span class="p">.</span><span class="n">cmd</span> <span class="o">==</span> <span class="n">MEGA_MBOXCMD_PASSTHRU64</span> <span class="p">)</span> <span class="p">{</span>

				<span class="n">memcpy</span><span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">sense_buffer</span><span class="p">,</span> <span class="n">pthru</span><span class="o">-&gt;</span><span class="n">reqsensearea</span><span class="p">,</span>
						<span class="mi">14</span><span class="p">);</span>

				<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">=</span> <span class="p">(</span><span class="n">DRIVER_SENSE</span> <span class="o">&lt;&lt;</span> <span class="mi">24</span><span class="p">)</span> <span class="o">|</span>
					<span class="p">(</span><span class="n">DID_OK</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">|</span>
					<span class="p">(</span><span class="n">CHECK_CONDITION</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="k">else</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">mbox</span><span class="o">-&gt;</span><span class="n">m_out</span><span class="p">.</span><span class="n">cmd</span> <span class="o">==</span> <span class="n">MEGA_MBOXCMD_EXTPTHRU</span><span class="p">)</span> <span class="p">{</span>

					<span class="n">memcpy</span><span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">sense_buffer</span><span class="p">,</span>
						<span class="n">epthru</span><span class="o">-&gt;</span><span class="n">reqsensearea</span><span class="p">,</span> <span class="mi">14</span><span class="p">);</span>

					<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">=</span> <span class="p">(</span><span class="n">DRIVER_SENSE</span> <span class="o">&lt;&lt;</span> <span class="mi">24</span><span class="p">)</span> <span class="o">|</span>
						<span class="p">(</span><span class="n">DID_OK</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">|</span>
						<span class="p">(</span><span class="n">CHECK_CONDITION</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">);</span>
				<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
					<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">sense_buffer</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x70</span><span class="p">;</span>
					<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">sense_buffer</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">ABORTED_COMMAND</span><span class="p">;</span>
					<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">|=</span> <span class="p">(</span><span class="n">CHECK_CONDITION</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">);</span>
				<span class="p">}</span>
			<span class="p">}</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="mh">0x08</span>:	<span class="cm">/* ERR_DEST_DRIVE_FAILED, i.e.</span>
<span class="cm">				   SCSI_STATUS_BUSY */</span>
			<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">|=</span> <span class="p">(</span><span class="n">DID_BUS_BUSY</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">|</span> <span class="n">status</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="nl">default:</span>
<span class="cp">#if MEGA_HAVE_CLUSTERING</span>
			<span class="cm">/*</span>
<span class="cm">			 * If TEST_UNIT_READY fails, we know</span>
<span class="cm">			 * MEGA_RESERVATION_STATUS failed</span>
<span class="cm">			 */</span>
			<span class="k">if</span><span class="p">(</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">TEST_UNIT_READY</span> <span class="p">)</span> <span class="p">{</span>
				<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">|=</span> <span class="p">(</span><span class="n">DID_ERROR</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">|</span>
					<span class="p">(</span><span class="n">RESERVATION_CONFLICT</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="k">else</span>
			<span class="cm">/*</span>
<span class="cm">			 * Error code returned is 1 if Reserve or Release</span>
<span class="cm">			 * failed or the input parameter is invalid</span>
<span class="cm">			 */</span>
			<span class="k">if</span><span class="p">(</span> <span class="n">status</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span>
				<span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">RESERVE</span> <span class="o">||</span>
					 <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">RELEASE</span><span class="p">)</span> <span class="p">)</span> <span class="p">{</span>

				<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">|=</span> <span class="p">(</span><span class="n">DID_ERROR</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">|</span>
					<span class="p">(</span><span class="n">RESERVATION_CONFLICT</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="k">else</span>
<span class="cp">#endif</span>
				<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">|=</span> <span class="p">(</span><span class="n">DID_BAD_TARGET</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">)</span><span class="o">|</span><span class="n">status</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 * Only free SCBs for the commands coming down from the</span>
<span class="cm">		 * mid-layer, not for which were issued internally</span>
<span class="cm">		 *</span>
<span class="cm">		 * For internal command, restore the status returned by the</span>
<span class="cm">		 * firmware so that user can interpret it.</span>
<span class="cm">		 */</span>
		<span class="k">if</span><span class="p">(</span> <span class="n">cmdid</span> <span class="o">==</span> <span class="n">CMDID_INT_CMDS</span> <span class="p">)</span> <span class="p">{</span> <span class="cm">/* internal command */</span>
			<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">=</span> <span class="n">status</span><span class="p">;</span>

			<span class="cm">/*</span>
<span class="cm">			 * Remove the internal command from the pending list</span>
<span class="cm">			 */</span>
			<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">scb</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
			<span class="n">scb</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">SCB_FREE</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">else</span> <span class="p">{</span>
			<span class="n">mega_free_scb</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">scb</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="cm">/* Add Scsi_Command to end of completed queue */</span>
		<span class="n">list_add_tail</span><span class="p">(</span><span class="n">SCSI_LIST</span><span class="p">(</span><span class="n">cmd</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">completed_list</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * mega_runpendq()</span>
<span class="cm"> *</span>
<span class="cm"> * Run through the list of completed requests and finish it</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">mega_rundoneq</span> <span class="p">(</span><span class="n">adapter_t</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">Scsi_Cmnd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">pos</span><span class="p">;</span>

	<span class="n">list_for_each</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">completed_list</span><span class="p">)</span> <span class="p">{</span>

		<span class="k">struct</span> <span class="n">scsi_pointer</span><span class="o">*</span> <span class="n">spos</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">scsi_pointer</span> <span class="o">*</span><span class="p">)</span><span class="n">pos</span><span class="p">;</span>

		<span class="n">cmd</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">spos</span><span class="p">,</span> <span class="n">Scsi_Cmnd</span><span class="p">,</span> <span class="n">SCp</span><span class="p">);</span>
		<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scsi_done</span><span class="p">(</span><span class="n">cmd</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">completed_list</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * Free a SCB structure</span>
<span class="cm"> * Note: We assume the scsi commands associated with this scb is not free yet.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">mega_free_scb</span><span class="p">(</span><span class="n">adapter_t</span> <span class="o">*</span><span class="n">adapter</span><span class="p">,</span> <span class="n">scb_t</span> <span class="o">*</span><span class="n">scb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">switch</span><span class="p">(</span> <span class="n">scb</span><span class="o">-&gt;</span><span class="n">dma_type</span> <span class="p">)</span> <span class="p">{</span>

	<span class="k">case</span> <span class="n">MEGA_DMA_TYPE_NONE</span>:
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">MEGA_SGLIST</span>:
		<span class="n">scsi_dma_unmap</span><span class="p">(</span><span class="n">scb</span><span class="o">-&gt;</span><span class="n">cmd</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Remove from the pending list</span>
<span class="cm">	 */</span>
	<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">scb</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>

	<span class="cm">/* Link the scb back into free list */</span>
	<span class="n">scb</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">SCB_FREE</span><span class="p">;</span>
	<span class="n">scb</span><span class="o">-&gt;</span><span class="n">cmd</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">scb</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">free_list</span><span class="p">);</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">int</span>
<span class="nf">__mega_busywait_mbox</span> <span class="p">(</span><span class="n">adapter_t</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">volatile</span> <span class="n">mbox_t</span> <span class="o">*</span><span class="n">mbox</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">mbox</span><span class="p">;</span>
	<span class="kt">long</span> <span class="n">counter</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">counter</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">counter</span> <span class="o">&lt;</span> <span class="mi">10000</span><span class="p">;</span> <span class="n">counter</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mbox</span><span class="o">-&gt;</span><span class="n">m_in</span><span class="p">.</span><span class="n">busy</span><span class="p">)</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">udelay</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span>
		<span class="n">cond_resched</span><span class="p">();</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>		<span class="cm">/* give up after 1 second */</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Copies data to SGLIST</span>
<span class="cm"> * Note: For 64 bit cards, we need a minimum of one SG element for read/write</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">mega_build_sglist</span><span class="p">(</span><span class="n">adapter_t</span> <span class="o">*</span><span class="n">adapter</span><span class="p">,</span> <span class="n">scb_t</span> <span class="o">*</span><span class="n">scb</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">scatterlist</span> <span class="o">*</span><span class="n">sg</span><span class="p">;</span>
	<span class="n">Scsi_Cmnd</span>	<span class="o">*</span><span class="n">cmd</span><span class="p">;</span>
	<span class="kt">int</span>	<span class="n">sgcnt</span><span class="p">;</span>
	<span class="kt">int</span>	<span class="n">idx</span><span class="p">;</span>

	<span class="n">cmd</span> <span class="o">=</span> <span class="n">scb</span><span class="o">-&gt;</span><span class="n">cmd</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Copy Scatter-Gather list info into controller structure.</span>
<span class="cm">	 *</span>
<span class="cm">	 * The number of sg elements returned must not exceed our limit</span>
<span class="cm">	 */</span>
	<span class="n">sgcnt</span> <span class="o">=</span> <span class="n">scsi_dma_map</span><span class="p">(</span><span class="n">cmd</span><span class="p">);</span>

	<span class="n">scb</span><span class="o">-&gt;</span><span class="n">dma_type</span> <span class="o">=</span> <span class="n">MEGA_SGLIST</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">sgcnt</span> <span class="o">&gt;</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">sglen</span> <span class="o">||</span> <span class="n">sgcnt</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">);</span>

	<span class="o">*</span><span class="n">len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">scsi_sg_count</span><span class="p">(</span><span class="n">cmd</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">has_64bit_addr</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">sg</span> <span class="o">=</span> <span class="n">scsi_sglist</span><span class="p">(</span><span class="n">cmd</span><span class="p">);</span>
		<span class="n">scb</span><span class="o">-&gt;</span><span class="n">dma_h_bulkdata</span> <span class="o">=</span> <span class="n">sg_dma_address</span><span class="p">(</span><span class="n">sg</span><span class="p">);</span>
		<span class="o">*</span><span class="n">buf</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span><span class="n">scb</span><span class="o">-&gt;</span><span class="n">dma_h_bulkdata</span><span class="p">;</span>
		<span class="o">*</span><span class="n">len</span> <span class="o">=</span> <span class="n">sg_dma_len</span><span class="p">(</span><span class="n">sg</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">scsi_for_each_sg</span><span class="p">(</span><span class="n">cmd</span><span class="p">,</span> <span class="n">sg</span><span class="p">,</span> <span class="n">sgcnt</span><span class="p">,</span> <span class="n">idx</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">has_64bit_addr</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">scb</span><span class="o">-&gt;</span><span class="n">sgl64</span><span class="p">[</span><span class="n">idx</span><span class="p">].</span><span class="n">address</span> <span class="o">=</span> <span class="n">sg_dma_address</span><span class="p">(</span><span class="n">sg</span><span class="p">);</span>
			<span class="o">*</span><span class="n">len</span> <span class="o">+=</span> <span class="n">scb</span><span class="o">-&gt;</span><span class="n">sgl64</span><span class="p">[</span><span class="n">idx</span><span class="p">].</span><span class="n">length</span> <span class="o">=</span> <span class="n">sg_dma_len</span><span class="p">(</span><span class="n">sg</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">scb</span><span class="o">-&gt;</span><span class="n">sgl</span><span class="p">[</span><span class="n">idx</span><span class="p">].</span><span class="n">address</span> <span class="o">=</span> <span class="n">sg_dma_address</span><span class="p">(</span><span class="n">sg</span><span class="p">);</span>
			<span class="o">*</span><span class="n">len</span> <span class="o">+=</span> <span class="n">scb</span><span class="o">-&gt;</span><span class="n">sgl</span><span class="p">[</span><span class="n">idx</span><span class="p">].</span><span class="n">length</span> <span class="o">=</span> <span class="n">sg_dma_len</span><span class="p">(</span><span class="n">sg</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* Reset pointer and length fields */</span>
	<span class="o">*</span><span class="n">buf</span> <span class="o">=</span> <span class="n">scb</span><span class="o">-&gt;</span><span class="n">sgl_dma_addr</span><span class="p">;</span>

	<span class="cm">/* Return count of SG requests */</span>
	<span class="k">return</span> <span class="n">sgcnt</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * mega_8_to_40ld()</span>
<span class="cm"> *</span>
<span class="cm"> * takes all info in AdapterInquiry structure and puts it into ProductInfo and</span>
<span class="cm"> * Enquiry3 structures for later use</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">mega_8_to_40ld</span><span class="p">(</span><span class="n">mraid_inquiry</span> <span class="o">*</span><span class="n">inquiry</span><span class="p">,</span> <span class="n">mega_inquiry3</span> <span class="o">*</span><span class="n">enquiry3</span><span class="p">,</span>
		<span class="n">mega_product_info</span> <span class="o">*</span><span class="n">product_info</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">product_info</span><span class="o">-&gt;</span><span class="n">max_commands</span> <span class="o">=</span> <span class="n">inquiry</span><span class="o">-&gt;</span><span class="n">adapter_info</span><span class="p">.</span><span class="n">max_commands</span><span class="p">;</span>
	<span class="n">enquiry3</span><span class="o">-&gt;</span><span class="n">rebuild_rate</span> <span class="o">=</span> <span class="n">inquiry</span><span class="o">-&gt;</span><span class="n">adapter_info</span><span class="p">.</span><span class="n">rebuild_rate</span><span class="p">;</span>
	<span class="n">product_info</span><span class="o">-&gt;</span><span class="n">nchannels</span> <span class="o">=</span> <span class="n">inquiry</span><span class="o">-&gt;</span><span class="n">adapter_info</span><span class="p">.</span><span class="n">nchannels</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">product_info</span><span class="o">-&gt;</span><span class="n">fw_version</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span>
			<span class="n">inquiry</span><span class="o">-&gt;</span><span class="n">adapter_info</span><span class="p">.</span><span class="n">fw_version</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

		<span class="n">product_info</span><span class="o">-&gt;</span><span class="n">bios_version</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span>
			<span class="n">inquiry</span><span class="o">-&gt;</span><span class="n">adapter_info</span><span class="p">.</span><span class="n">bios_version</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
	<span class="p">}</span>
	<span class="n">enquiry3</span><span class="o">-&gt;</span><span class="n">cache_flush_interval</span> <span class="o">=</span>
		<span class="n">inquiry</span><span class="o">-&gt;</span><span class="n">adapter_info</span><span class="p">.</span><span class="n">cache_flush_interval</span><span class="p">;</span>

	<span class="n">product_info</span><span class="o">-&gt;</span><span class="n">dram_size</span> <span class="o">=</span> <span class="n">inquiry</span><span class="o">-&gt;</span><span class="n">adapter_info</span><span class="p">.</span><span class="n">dram_size</span><span class="p">;</span>

	<span class="n">enquiry3</span><span class="o">-&gt;</span><span class="n">num_ldrv</span> <span class="o">=</span> <span class="n">inquiry</span><span class="o">-&gt;</span><span class="n">logdrv_info</span><span class="p">.</span><span class="n">num_ldrv</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">MAX_LOGICAL_DRIVES_8LD</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">enquiry3</span><span class="o">-&gt;</span><span class="n">ldrv_size</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">inquiry</span><span class="o">-&gt;</span><span class="n">logdrv_info</span><span class="p">.</span><span class="n">ldrv_size</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="n">enquiry3</span><span class="o">-&gt;</span><span class="n">ldrv_prop</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">inquiry</span><span class="o">-&gt;</span><span class="n">logdrv_info</span><span class="p">.</span><span class="n">ldrv_prop</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="n">enquiry3</span><span class="o">-&gt;</span><span class="n">ldrv_state</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">inquiry</span><span class="o">-&gt;</span><span class="n">logdrv_info</span><span class="p">.</span><span class="n">ldrv_state</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">MAX_PHYSICAL_DRIVES</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">enquiry3</span><span class="o">-&gt;</span><span class="n">pdrv_state</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">inquiry</span><span class="o">-&gt;</span><span class="n">pdrv_info</span><span class="p">.</span><span class="n">pdrv_state</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">mega_free_sgl</span><span class="p">(</span><span class="n">adapter_t</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">scb_t</span>	<span class="o">*</span><span class="n">scb</span><span class="p">;</span>
	<span class="kt">int</span>	<span class="n">i</span><span class="p">;</span>

	<span class="k">for</span><span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">max_cmds</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>

		<span class="n">scb</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">scb_list</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

		<span class="k">if</span><span class="p">(</span> <span class="n">scb</span><span class="o">-&gt;</span><span class="n">sgl64</span> <span class="p">)</span> <span class="p">{</span>
			<span class="n">pci_free_consistent</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
				<span class="k">sizeof</span><span class="p">(</span><span class="n">mega_sgl64</span><span class="p">)</span> <span class="o">*</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">sglen</span><span class="p">,</span>
				<span class="n">scb</span><span class="o">-&gt;</span><span class="n">sgl64</span><span class="p">,</span>
				<span class="n">scb</span><span class="o">-&gt;</span><span class="n">sgl_dma_addr</span><span class="p">);</span>

			<span class="n">scb</span><span class="o">-&gt;</span><span class="n">sgl64</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span><span class="p">(</span> <span class="n">scb</span><span class="o">-&gt;</span><span class="n">pthru</span> <span class="p">)</span> <span class="p">{</span>
			<span class="n">pci_free_consistent</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">mega_passthru</span><span class="p">),</span>
				<span class="n">scb</span><span class="o">-&gt;</span><span class="n">pthru</span><span class="p">,</span> <span class="n">scb</span><span class="o">-&gt;</span><span class="n">pthru_dma_addr</span><span class="p">);</span>

			<span class="n">scb</span><span class="o">-&gt;</span><span class="n">pthru</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span><span class="p">(</span> <span class="n">scb</span><span class="o">-&gt;</span><span class="n">epthru</span> <span class="p">)</span> <span class="p">{</span>
			<span class="n">pci_free_consistent</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
				<span class="k">sizeof</span><span class="p">(</span><span class="n">mega_ext_passthru</span><span class="p">),</span>
				<span class="n">scb</span><span class="o">-&gt;</span><span class="n">epthru</span><span class="p">,</span> <span class="n">scb</span><span class="o">-&gt;</span><span class="n">epthru_dma_addr</span><span class="p">);</span>

			<span class="n">scb</span><span class="o">-&gt;</span><span class="n">epthru</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>

	<span class="p">}</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * Get information about the card/driver</span>
<span class="cm"> */</span>
<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span>
<span class="nf">megaraid_info</span><span class="p">(</span><span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">host</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">static</span> <span class="kt">char</span> <span class="n">buffer</span><span class="p">[</span><span class="mi">512</span><span class="p">];</span>
	<span class="n">adapter_t</span> <span class="o">*</span><span class="n">adapter</span><span class="p">;</span>

	<span class="n">adapter</span> <span class="o">=</span> <span class="p">(</span><span class="n">adapter_t</span> <span class="o">*</span><span class="p">)</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">hostdata</span><span class="p">;</span>

	<span class="n">sprintf</span> <span class="p">(</span><span class="n">buffer</span><span class="p">,</span>
		 <span class="s">&quot;LSI Logic MegaRAID %s %d commands %d targs %d chans %d luns&quot;</span><span class="p">,</span>
		 <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">fw_version</span><span class="p">,</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">product_info</span><span class="p">.</span><span class="n">max_commands</span><span class="p">,</span>
		 <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">max_id</span><span class="p">,</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">max_channel</span><span class="p">,</span>
		 <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">max_lun</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">buffer</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Abort a previous SCSI request. Only commands on the pending list can be</span>
<span class="cm"> * aborted. All the commands issued to the F/W must complete.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">megaraid_abort</span><span class="p">(</span><span class="n">Scsi_Cmnd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">adapter_t</span>	<span class="o">*</span><span class="n">adapter</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">rval</span><span class="p">;</span>

	<span class="n">adapter</span> <span class="o">=</span> <span class="p">(</span><span class="n">adapter_t</span> <span class="o">*</span><span class="p">)</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">hostdata</span><span class="p">;</span>

	<span class="n">rval</span> <span class="o">=</span>  <span class="n">megaraid_abort_and_reset</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">cmd</span><span class="p">,</span> <span class="n">SCB_ABORT</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * This is required here to complete any completed requests</span>
<span class="cm">	 * to be communicated over to the mid layer.</span>
<span class="cm">	 */</span>
	<span class="n">mega_rundoneq</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">rval</span><span class="p">;</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">int</span>
<span class="nf">megaraid_reset</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">adapter_t</span>	<span class="o">*</span><span class="n">adapter</span><span class="p">;</span>
	<span class="n">megacmd_t</span>	<span class="n">mc</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">rval</span><span class="p">;</span>

	<span class="n">adapter</span> <span class="o">=</span> <span class="p">(</span><span class="n">adapter_t</span> <span class="o">*</span><span class="p">)</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">hostdata</span><span class="p">;</span>

<span class="cp">#if MEGA_HAVE_CLUSTERING</span>
	<span class="n">mc</span><span class="p">.</span><span class="n">cmd</span> <span class="o">=</span> <span class="n">MEGA_CLUSTER_CMD</span><span class="p">;</span>
	<span class="n">mc</span><span class="p">.</span><span class="n">opcode</span> <span class="o">=</span> <span class="n">MEGA_RESET_RESERVATIONS</span><span class="p">;</span>

	<span class="k">if</span><span class="p">(</span> <span class="n">mega_internal_command</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mc</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span>
				<span class="s">&quot;megaraid: reservation reset failed.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;megaraid: reservation reset.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span>
<span class="cp">#endif</span>

	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="n">rval</span> <span class="o">=</span>  <span class="n">megaraid_abort_and_reset</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">cmd</span><span class="p">,</span> <span class="n">SCB_RESET</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * This is required here to complete any completed requests</span>
<span class="cm">	 * to be communicated over to the mid layer.</span>
<span class="cm">	 */</span>
	<span class="n">mega_rundoneq</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">rval</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * megaraid_abort_and_reset()</span>
<span class="cm"> * @adapter - megaraid soft state</span>
<span class="cm"> * @cmd - scsi command to be aborted or reset</span>
<span class="cm"> * @aor - abort or reset flag</span>
<span class="cm"> *</span>
<span class="cm"> * Try to locate the scsi command in the pending queue. If found and is not</span>
<span class="cm"> * issued to the controller, abort/reset it. Otherwise return failure</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">megaraid_abort_and_reset</span><span class="p">(</span><span class="n">adapter_t</span> <span class="o">*</span><span class="n">adapter</span><span class="p">,</span> <span class="n">Scsi_Cmnd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">,</span> <span class="kt">int</span> <span class="n">aor</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="o">*</span><span class="n">pos</span><span class="p">,</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
	<span class="n">scb_t</span>			<span class="o">*</span><span class="n">scb</span><span class="p">;</span>

	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;megaraid: %s cmd=%x &lt;c=%d t=%d l=%d&gt;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	     <span class="p">(</span><span class="n">aor</span> <span class="o">==</span> <span class="n">SCB_ABORT</span><span class="p">)</span><span class="o">?</span> <span class="s">&quot;ABORTING&quot;</span><span class="o">:</span><span class="s">&quot;RESET&quot;</span><span class="p">,</span>
	     <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">channel</span><span class="p">,</span> 
	     <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">,</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">lun</span><span class="p">);</span>

	<span class="k">if</span><span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pending_list</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">FALSE</span><span class="p">;</span>

	<span class="n">list_for_each_safe</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="n">next</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pending_list</span><span class="p">)</span> <span class="p">{</span>

		<span class="n">scb</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="n">scb_t</span><span class="p">,</span> <span class="n">list</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">scb</span><span class="o">-&gt;</span><span class="n">cmd</span> <span class="o">==</span> <span class="n">cmd</span><span class="p">)</span> <span class="p">{</span> <span class="cm">/* Found command */</span>

			<span class="n">scb</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">|=</span> <span class="n">aor</span><span class="p">;</span>

			<span class="cm">/*</span>
<span class="cm">			 * Check if this command has firmware ownership. If</span>
<span class="cm">			 * yes, we cannot reset this command. Whenever f/w</span>
<span class="cm">			 * completes this command, we will return appropriate</span>
<span class="cm">			 * status from ISR.</span>
<span class="cm">			 */</span>
			<span class="k">if</span><span class="p">(</span> <span class="n">scb</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">&amp;</span> <span class="n">SCB_ISSUED</span> <span class="p">)</span> <span class="p">{</span>

				<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span>
					<span class="s">&quot;megaraid: %s[%x], fw owner.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="p">(</span><span class="n">aor</span><span class="o">==</span><span class="n">SCB_ABORT</span><span class="p">)</span> <span class="o">?</span> <span class="s">&quot;ABORTING&quot;</span><span class="o">:</span><span class="s">&quot;RESET&quot;</span><span class="p">,</span>
					<span class="n">scb</span><span class="o">-&gt;</span><span class="n">idx</span><span class="p">);</span>

				<span class="k">return</span> <span class="n">FALSE</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">else</span> <span class="p">{</span>

				<span class="cm">/*</span>
<span class="cm">				 * Not yet issued! Remove from the pending</span>
<span class="cm">				 * list</span>
<span class="cm">				 */</span>
				<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span>
					<span class="s">&quot;megaraid: %s-[%x], driver owner.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="p">(</span><span class="n">aor</span><span class="o">==</span><span class="n">SCB_ABORT</span><span class="p">)</span> <span class="o">?</span> <span class="s">&quot;ABORTING&quot;</span><span class="o">:</span><span class="s">&quot;RESET&quot;</span><span class="p">,</span>
					<span class="n">scb</span><span class="o">-&gt;</span><span class="n">idx</span><span class="p">);</span>

				<span class="n">mega_free_scb</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">scb</span><span class="p">);</span>

				<span class="k">if</span><span class="p">(</span> <span class="n">aor</span> <span class="o">==</span> <span class="n">SCB_ABORT</span> <span class="p">)</span> <span class="p">{</span>
					<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">=</span> <span class="p">(</span><span class="n">DID_ABORT</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">);</span>
				<span class="p">}</span>
				<span class="k">else</span> <span class="p">{</span>
					<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">=</span> <span class="p">(</span><span class="n">DID_RESET</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">);</span>
				<span class="p">}</span>

				<span class="n">list_add_tail</span><span class="p">(</span><span class="n">SCSI_LIST</span><span class="p">(</span><span class="n">cmd</span><span class="p">),</span>
						<span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">completed_list</span><span class="p">);</span>

				<span class="k">return</span> <span class="n">TRUE</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">FALSE</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span>
<span class="nf">make_local_pdev</span><span class="p">(</span><span class="n">adapter_t</span> <span class="o">*</span><span class="n">adapter</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">**</span><span class="n">pdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="o">*</span><span class="n">pdev</span> <span class="o">=</span> <span class="n">alloc_pci_dev</span><span class="p">();</span>

	<span class="k">if</span><span class="p">(</span> <span class="o">*</span><span class="n">pdev</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="p">)</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="n">memcpy</span><span class="p">(</span><span class="o">*</span><span class="n">pdev</span><span class="p">,</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span><span class="p">));</span>

	<span class="k">if</span><span class="p">(</span> <span class="n">pci_set_dma_mask</span><span class="p">(</span><span class="o">*</span><span class="n">pdev</span><span class="p">,</span> <span class="n">DMA_BIT_MASK</span><span class="p">(</span><span class="mi">32</span><span class="p">))</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">)</span> <span class="p">{</span>
		<span class="n">kfree</span><span class="p">(</span><span class="o">*</span><span class="n">pdev</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">free_local_pdev</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * mega_allocate_inquiry()</span>
<span class="cm"> * @dma_handle - handle returned for dma address</span>
<span class="cm"> * @pdev - handle to pci device</span>
<span class="cm"> *</span>
<span class="cm"> * allocates memory for inquiry structure</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="o">*</span>
<span class="nf">mega_allocate_inquiry</span><span class="p">(</span><span class="n">dma_addr_t</span> <span class="o">*</span><span class="n">dma_handle</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">pci_alloc_consistent</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">mega_inquiry3</span><span class="p">),</span> <span class="n">dma_handle</span><span class="p">);</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">mega_free_inquiry</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">inquiry</span><span class="p">,</span> <span class="n">dma_addr_t</span> <span class="n">dma_handle</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pci_free_consistent</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">mega_inquiry3</span><span class="p">),</span> <span class="n">inquiry</span><span class="p">,</span> <span class="n">dma_handle</span><span class="p">);</span>
<span class="p">}</span>


<span class="cp">#ifdef CONFIG_PROC_FS</span>
<span class="cm">/* Following code handles /proc fs  */</span>

<span class="cp">#define CREATE_READ_PROC(string, func)	create_proc_read_entry(string,	\</span>
<span class="cp">					S_IRUSR | S_IFREG,		\</span>
<span class="cp">					controller_proc_dir_entry,	\</span>
<span class="cp">					func, adapter)</span>

<span class="cm">/**</span>
<span class="cm"> * mega_create_proc_entry()</span>
<span class="cm"> * @index - index in soft state array</span>
<span class="cm"> * @parent - parent node for this /proc entry</span>
<span class="cm"> *</span>
<span class="cm"> * Creates /proc entries for our controllers.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">mega_create_proc_entry</span><span class="p">(</span><span class="kt">int</span> <span class="n">index</span><span class="p">,</span> <span class="k">struct</span> <span class="n">proc_dir_entry</span> <span class="o">*</span><span class="n">parent</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">proc_dir_entry</span>	<span class="o">*</span><span class="n">controller_proc_dir_entry</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">u8</span>		<span class="n">string</span><span class="p">[</span><span class="mi">64</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">0</span> <span class="p">};</span>
	<span class="n">adapter_t</span>	<span class="o">*</span><span class="n">adapter</span> <span class="o">=</span> <span class="n">hba_soft_state</span><span class="p">[</span><span class="n">index</span><span class="p">];</span>

	<span class="n">sprintf</span><span class="p">(</span><span class="n">string</span><span class="p">,</span> <span class="s">&quot;hba%d&quot;</span><span class="p">,</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">host_no</span><span class="p">);</span>

	<span class="n">controller_proc_dir_entry</span> <span class="o">=</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">controller_proc_dir_entry</span> <span class="o">=</span> <span class="n">proc_mkdir</span><span class="p">(</span><span class="n">string</span><span class="p">,</span> <span class="n">parent</span><span class="p">);</span>

	<span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">controller_proc_dir_entry</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">megaraid: proc_mkdir failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">proc_read</span> <span class="o">=</span> <span class="n">CREATE_READ_PROC</span><span class="p">(</span><span class="s">&quot;config&quot;</span><span class="p">,</span> <span class="n">proc_read_config</span><span class="p">);</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">proc_stat</span> <span class="o">=</span> <span class="n">CREATE_READ_PROC</span><span class="p">(</span><span class="s">&quot;stat&quot;</span><span class="p">,</span> <span class="n">proc_read_stat</span><span class="p">);</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">proc_mbox</span> <span class="o">=</span> <span class="n">CREATE_READ_PROC</span><span class="p">(</span><span class="s">&quot;mailbox&quot;</span><span class="p">,</span> <span class="n">proc_read_mbox</span><span class="p">);</span>
<span class="cp">#if MEGA_HAVE_ENH_PROC</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">proc_rr</span> <span class="o">=</span> <span class="n">CREATE_READ_PROC</span><span class="p">(</span><span class="s">&quot;rebuild-rate&quot;</span><span class="p">,</span> <span class="n">proc_rebuild_rate</span><span class="p">);</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">proc_battery</span> <span class="o">=</span> <span class="n">CREATE_READ_PROC</span><span class="p">(</span><span class="s">&quot;battery-status&quot;</span><span class="p">,</span>
			<span class="n">proc_battery</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Display each physical drive on its channel</span>
<span class="cm">	 */</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">proc_pdrvstat</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">CREATE_READ_PROC</span><span class="p">(</span><span class="s">&quot;diskdrives-ch0&quot;</span><span class="p">,</span>
					<span class="n">proc_pdrv_ch0</span><span class="p">);</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">proc_pdrvstat</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">CREATE_READ_PROC</span><span class="p">(</span><span class="s">&quot;diskdrives-ch1&quot;</span><span class="p">,</span>
					<span class="n">proc_pdrv_ch1</span><span class="p">);</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">proc_pdrvstat</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">CREATE_READ_PROC</span><span class="p">(</span><span class="s">&quot;diskdrives-ch2&quot;</span><span class="p">,</span>
					<span class="n">proc_pdrv_ch2</span><span class="p">);</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">proc_pdrvstat</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">CREATE_READ_PROC</span><span class="p">(</span><span class="s">&quot;diskdrives-ch3&quot;</span><span class="p">,</span>
					<span class="n">proc_pdrv_ch3</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Display a set of up to 10 logical drive through each of following</span>
<span class="cm">	 * /proc entries</span>
<span class="cm">	 */</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">proc_rdrvstat</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">CREATE_READ_PROC</span><span class="p">(</span><span class="s">&quot;raiddrives-0-9&quot;</span><span class="p">,</span>
					<span class="n">proc_rdrv_10</span><span class="p">);</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">proc_rdrvstat</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">CREATE_READ_PROC</span><span class="p">(</span><span class="s">&quot;raiddrives-10-19&quot;</span><span class="p">,</span>
					<span class="n">proc_rdrv_20</span><span class="p">);</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">proc_rdrvstat</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">CREATE_READ_PROC</span><span class="p">(</span><span class="s">&quot;raiddrives-20-29&quot;</span><span class="p">,</span>
					<span class="n">proc_rdrv_30</span><span class="p">);</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">proc_rdrvstat</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">CREATE_READ_PROC</span><span class="p">(</span><span class="s">&quot;raiddrives-30-39&quot;</span><span class="p">,</span>
					<span class="n">proc_rdrv_40</span><span class="p">);</span>
<span class="cp">#endif</span>
<span class="p">}</span>


<span class="cm">/**</span>
<span class="cm"> * proc_read_config()</span>
<span class="cm"> * @page - buffer to write the data in</span>
<span class="cm"> * @start - where the actual data has been written in page</span>
<span class="cm"> * @offset - same meaning as the read system call</span>
<span class="cm"> * @count - same meaning as the read system call</span>
<span class="cm"> * @eof - set if no more data needs to be returned</span>
<span class="cm"> * @data - pointer to our soft state</span>
<span class="cm"> *</span>
<span class="cm"> * Display configuration information about the controller.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">proc_read_config</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">start</span><span class="p">,</span> <span class="kt">off_t</span> <span class="n">offset</span><span class="p">,</span> <span class="kt">int</span> <span class="n">count</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">eof</span><span class="p">,</span>
		<span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>

	<span class="n">adapter_t</span> <span class="o">*</span><span class="n">adapter</span> <span class="o">=</span> <span class="p">(</span><span class="n">adapter_t</span> <span class="o">*</span><span class="p">)</span><span class="n">data</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">len</span> <span class="o">+=</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">page</span><span class="o">+</span><span class="n">len</span><span class="p">,</span> <span class="s">&quot;%s&quot;</span><span class="p">,</span> <span class="n">MEGARAID_VERSION</span><span class="p">);</span>

	<span class="k">if</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">product_info</span><span class="p">.</span><span class="n">product_name</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
		<span class="n">len</span> <span class="o">+=</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">page</span><span class="o">+</span><span class="n">len</span><span class="p">,</span> <span class="s">&quot;%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">product_info</span><span class="p">.</span><span class="n">product_name</span><span class="p">);</span>

	<span class="n">len</span> <span class="o">+=</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">page</span><span class="o">+</span><span class="n">len</span><span class="p">,</span> <span class="s">&quot;Controller Type: &quot;</span><span class="p">);</span>

	<span class="k">if</span><span class="p">(</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">flag</span> <span class="o">&amp;</span> <span class="n">BOARD_MEMMAP</span> <span class="p">)</span> <span class="p">{</span>
		<span class="n">len</span> <span class="o">+=</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">page</span><span class="o">+</span><span class="n">len</span><span class="p">,</span>
			<span class="s">&quot;438/466/467/471/493/518/520/531/532</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="n">len</span> <span class="o">+=</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">page</span><span class="o">+</span><span class="n">len</span><span class="p">,</span>
			<span class="s">&quot;418/428/434</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">flag</span> <span class="o">&amp;</span> <span class="n">BOARD_40LD</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">len</span> <span class="o">+=</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">page</span><span class="o">+</span><span class="n">len</span><span class="p">,</span>
				<span class="s">&quot;Controller Supports 40 Logical Drives</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">flag</span> <span class="o">&amp;</span> <span class="n">BOARD_64BIT</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">len</span> <span class="o">+=</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">page</span><span class="o">+</span><span class="n">len</span><span class="p">,</span>
		<span class="s">&quot;Controller capable of 64-bit memory addressing</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span><span class="p">(</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">has_64bit_addr</span> <span class="p">)</span> <span class="p">{</span>
		<span class="n">len</span> <span class="o">+=</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">page</span><span class="o">+</span><span class="n">len</span><span class="p">,</span>
			<span class="s">&quot;Controller using 64-bit memory addressing</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="n">len</span> <span class="o">+=</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">page</span><span class="o">+</span><span class="n">len</span><span class="p">,</span>
			<span class="s">&quot;Controller is not using 64-bit memory addressing</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">len</span> <span class="o">+=</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">page</span><span class="o">+</span><span class="n">len</span><span class="p">,</span> <span class="s">&quot;Base = %08lx, Irq = %d, &quot;</span><span class="p">,</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">,</span>
			<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">);</span>

	<span class="n">len</span> <span class="o">+=</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">page</span><span class="o">+</span><span class="n">len</span><span class="p">,</span> <span class="s">&quot;Logical Drives = %d, Channels = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">numldrv</span><span class="p">,</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">product_info</span><span class="p">.</span><span class="n">nchannels</span><span class="p">);</span>

	<span class="n">len</span> <span class="o">+=</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">page</span><span class="o">+</span><span class="n">len</span><span class="p">,</span> <span class="s">&quot;Version =%s:%s, DRAM = %dMb</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">fw_version</span><span class="p">,</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">bios_version</span><span class="p">,</span>
			<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">product_info</span><span class="p">.</span><span class="n">dram_size</span><span class="p">);</span>

	<span class="n">len</span> <span class="o">+=</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">page</span><span class="o">+</span><span class="n">len</span><span class="p">,</span>
		<span class="s">&quot;Controller Queue Depth = %d, Driver Queue Depth = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">product_info</span><span class="p">.</span><span class="n">max_commands</span><span class="p">,</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">max_cmds</span><span class="p">);</span>

	<span class="n">len</span> <span class="o">+=</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">page</span><span class="o">+</span><span class="n">len</span><span class="p">,</span> <span class="s">&quot;support_ext_cdb    = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">support_ext_cdb</span><span class="p">);</span>
	<span class="n">len</span> <span class="o">+=</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">page</span><span class="o">+</span><span class="n">len</span><span class="p">,</span> <span class="s">&quot;support_random_del = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">support_random_del</span><span class="p">);</span>
	<span class="n">len</span> <span class="o">+=</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">page</span><span class="o">+</span><span class="n">len</span><span class="p">,</span> <span class="s">&quot;boot_ldrv_enabled  = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">boot_ldrv_enabled</span><span class="p">);</span>
	<span class="n">len</span> <span class="o">+=</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">page</span><span class="o">+</span><span class="n">len</span><span class="p">,</span> <span class="s">&quot;boot_ldrv          = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">boot_ldrv</span><span class="p">);</span>
	<span class="n">len</span> <span class="o">+=</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">page</span><span class="o">+</span><span class="n">len</span><span class="p">,</span> <span class="s">&quot;boot_pdrv_enabled  = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">boot_pdrv_enabled</span><span class="p">);</span>
	<span class="n">len</span> <span class="o">+=</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">page</span><span class="o">+</span><span class="n">len</span><span class="p">,</span> <span class="s">&quot;boot_pdrv_ch       = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">boot_pdrv_ch</span><span class="p">);</span>
	<span class="n">len</span> <span class="o">+=</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">page</span><span class="o">+</span><span class="n">len</span><span class="p">,</span> <span class="s">&quot;boot_pdrv_tgt      = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">boot_pdrv_tgt</span><span class="p">);</span>
	<span class="n">len</span> <span class="o">+=</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">page</span><span class="o">+</span><span class="n">len</span><span class="p">,</span> <span class="s">&quot;quiescent          = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">quiescent</span><span class="p">));</span>
	<span class="n">len</span> <span class="o">+=</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">page</span><span class="o">+</span><span class="n">len</span><span class="p">,</span> <span class="s">&quot;has_cluster        = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">has_cluster</span><span class="p">);</span>

	<span class="n">len</span> <span class="o">+=</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">page</span><span class="o">+</span><span class="n">len</span><span class="p">,</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">Module Parameters:</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">len</span> <span class="o">+=</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">page</span><span class="o">+</span><span class="n">len</span><span class="p">,</span> <span class="s">&quot;max_cmd_per_lun    = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">max_cmd_per_lun</span><span class="p">);</span>
	<span class="n">len</span> <span class="o">+=</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">page</span><span class="o">+</span><span class="n">len</span><span class="p">,</span> <span class="s">&quot;max_sectors_per_io = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">max_sectors_per_io</span><span class="p">);</span>

	<span class="o">*</span><span class="n">eof</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">len</span><span class="p">;</span>
<span class="p">}</span>



<span class="cm">/**</span>
<span class="cm"> * proc_read_stat()</span>
<span class="cm"> * @page - buffer to write the data in</span>
<span class="cm"> * @start - where the actual data has been written in page</span>
<span class="cm"> * @offset - same meaning as the read system call</span>
<span class="cm"> * @count - same meaning as the read system call</span>
<span class="cm"> * @eof - set if no more data needs to be returned</span>
<span class="cm"> * @data - pointer to our soft state</span>
<span class="cm"> *</span>
<span class="cm"> * Diaplay statistical information about the I/O activity.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">proc_read_stat</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">start</span><span class="p">,</span> <span class="kt">off_t</span> <span class="n">offset</span><span class="p">,</span> <span class="kt">int</span> <span class="n">count</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">eof</span><span class="p">,</span>
		<span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">adapter_t</span>	<span class="o">*</span><span class="n">adapter</span><span class="p">;</span>
	<span class="kt">int</span>	<span class="n">len</span><span class="p">;</span>
	<span class="kt">int</span>	<span class="n">i</span><span class="p">;</span>

	<span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>	<span class="cm">/* avoid compilation warnings */</span>
	<span class="n">len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">adapter</span> <span class="o">=</span> <span class="p">(</span><span class="n">adapter_t</span> <span class="o">*</span><span class="p">)</span><span class="n">data</span><span class="p">;</span>

	<span class="n">len</span> <span class="o">=</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="s">&quot;Statistical Information for this controller</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">len</span> <span class="o">+=</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">page</span><span class="o">+</span><span class="n">len</span><span class="p">,</span> <span class="s">&quot;pend_cmds = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pend_cmds</span><span class="p">));</span>
<span class="cp">#if MEGA_HAVE_STATS</span>
	<span class="k">for</span><span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">numldrv</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">len</span> <span class="o">+=</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">page</span><span class="o">+</span><span class="n">len</span><span class="p">,</span> <span class="s">&quot;Logical Drive %d:</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>

		<span class="n">len</span> <span class="o">+=</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">page</span><span class="o">+</span><span class="n">len</span><span class="p">,</span>
			<span class="s">&quot;</span><span class="se">\t</span><span class="s">Reads Issued = %lu, Writes Issued = %lu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">nreads</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">nwrites</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>

		<span class="n">len</span> <span class="o">+=</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">page</span><span class="o">+</span><span class="n">len</span><span class="p">,</span>
			<span class="s">&quot;</span><span class="se">\t</span><span class="s">Sectors Read = %lu, Sectors Written = %lu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">nreadblocks</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">nwriteblocks</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>

		<span class="n">len</span> <span class="o">+=</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">page</span><span class="o">+</span><span class="n">len</span><span class="p">,</span>
			<span class="s">&quot;</span><span class="se">\t</span><span class="s">Read errors = %lu, Write errors = %lu</span><span class="se">\n\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rd_errors</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">wr_errors</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
	<span class="p">}</span>
<span class="cp">#else</span>
	<span class="n">len</span> <span class="o">+=</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">page</span><span class="o">+</span><span class="n">len</span><span class="p">,</span>
			<span class="s">&quot;IO and error counters not compiled in driver.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="cp">#endif</span>

	<span class="o">*</span><span class="n">eof</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">len</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/**</span>
<span class="cm"> * proc_read_mbox()</span>
<span class="cm"> * @page - buffer to write the data in</span>
<span class="cm"> * @start - where the actual data has been written in page</span>
<span class="cm"> * @offset - same meaning as the read system call</span>
<span class="cm"> * @count - same meaning as the read system call</span>
<span class="cm"> * @eof - set if no more data needs to be returned</span>
<span class="cm"> * @data - pointer to our soft state</span>
<span class="cm"> *</span>
<span class="cm"> * Display mailbox information for the last command issued. This information</span>
<span class="cm"> * is good for debugging.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">proc_read_mbox</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">start</span><span class="p">,</span> <span class="kt">off_t</span> <span class="n">offset</span><span class="p">,</span> <span class="kt">int</span> <span class="n">count</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">eof</span><span class="p">,</span>
		<span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>

	<span class="n">adapter_t</span>	<span class="o">*</span><span class="n">adapter</span> <span class="o">=</span> <span class="p">(</span><span class="n">adapter_t</span> <span class="o">*</span><span class="p">)</span><span class="n">data</span><span class="p">;</span>
	<span class="k">volatile</span> <span class="n">mbox_t</span>	<span class="o">*</span><span class="n">mbox</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">mbox</span><span class="p">;</span>
	<span class="kt">int</span>	<span class="n">len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">len</span> <span class="o">=</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="s">&quot;Contents of Mail Box Structure</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">len</span> <span class="o">+=</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">page</span><span class="o">+</span><span class="n">len</span><span class="p">,</span> <span class="s">&quot;  Fw Command   = 0x%02x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> 
			<span class="n">mbox</span><span class="o">-&gt;</span><span class="n">m_out</span><span class="p">.</span><span class="n">cmd</span><span class="p">);</span>
	<span class="n">len</span> <span class="o">+=</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">page</span><span class="o">+</span><span class="n">len</span><span class="p">,</span> <span class="s">&quot;  Cmd Sequence = 0x%02x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> 
			<span class="n">mbox</span><span class="o">-&gt;</span><span class="n">m_out</span><span class="p">.</span><span class="n">cmdid</span><span class="p">);</span>
	<span class="n">len</span> <span class="o">+=</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">page</span><span class="o">+</span><span class="n">len</span><span class="p">,</span> <span class="s">&quot;  No of Sectors= %04d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> 
			<span class="n">mbox</span><span class="o">-&gt;</span><span class="n">m_out</span><span class="p">.</span><span class="n">numsectors</span><span class="p">);</span>
	<span class="n">len</span> <span class="o">+=</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">page</span><span class="o">+</span><span class="n">len</span><span class="p">,</span> <span class="s">&quot;  LBA          = 0x%02x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> 
			<span class="n">mbox</span><span class="o">-&gt;</span><span class="n">m_out</span><span class="p">.</span><span class="n">lba</span><span class="p">);</span>
	<span class="n">len</span> <span class="o">+=</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">page</span><span class="o">+</span><span class="n">len</span><span class="p">,</span> <span class="s">&quot;  DTA          = 0x%08x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> 
			<span class="n">mbox</span><span class="o">-&gt;</span><span class="n">m_out</span><span class="p">.</span><span class="n">xferaddr</span><span class="p">);</span>
	<span class="n">len</span> <span class="o">+=</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">page</span><span class="o">+</span><span class="n">len</span><span class="p">,</span> <span class="s">&quot;  Logical Drive= 0x%02x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> 
			<span class="n">mbox</span><span class="o">-&gt;</span><span class="n">m_out</span><span class="p">.</span><span class="n">logdrv</span><span class="p">);</span>
	<span class="n">len</span> <span class="o">+=</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">page</span><span class="o">+</span><span class="n">len</span><span class="p">,</span> <span class="s">&quot;  No of SG Elmt= 0x%02x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">mbox</span><span class="o">-&gt;</span><span class="n">m_out</span><span class="p">.</span><span class="n">numsgelements</span><span class="p">);</span>
	<span class="n">len</span> <span class="o">+=</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">page</span><span class="o">+</span><span class="n">len</span><span class="p">,</span> <span class="s">&quot;  Busy         = %01x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> 
			<span class="n">mbox</span><span class="o">-&gt;</span><span class="n">m_in</span><span class="p">.</span><span class="n">busy</span><span class="p">);</span>
	<span class="n">len</span> <span class="o">+=</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">page</span><span class="o">+</span><span class="n">len</span><span class="p">,</span> <span class="s">&quot;  Status       = 0x%02x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> 
			<span class="n">mbox</span><span class="o">-&gt;</span><span class="n">m_in</span><span class="p">.</span><span class="n">status</span><span class="p">);</span>

	<span class="o">*</span><span class="n">eof</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">len</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/**</span>
<span class="cm"> * proc_rebuild_rate()</span>
<span class="cm"> * @page - buffer to write the data in</span>
<span class="cm"> * @start - where the actual data has been written in page</span>
<span class="cm"> * @offset - same meaning as the read system call</span>
<span class="cm"> * @count - same meaning as the read system call</span>
<span class="cm"> * @eof - set if no more data needs to be returned</span>
<span class="cm"> * @data - pointer to our soft state</span>
<span class="cm"> *</span>
<span class="cm"> * Display current rebuild rate</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">proc_rebuild_rate</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">start</span><span class="p">,</span> <span class="kt">off_t</span> <span class="n">offset</span><span class="p">,</span> <span class="kt">int</span> <span class="n">count</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">eof</span><span class="p">,</span>
		<span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">adapter_t</span>	<span class="o">*</span><span class="n">adapter</span> <span class="o">=</span> <span class="p">(</span><span class="n">adapter_t</span> <span class="o">*</span><span class="p">)</span><span class="n">data</span><span class="p">;</span>
	<span class="n">dma_addr_t</span>	<span class="n">dma_handle</span><span class="p">;</span>
	<span class="n">caddr_t</span>		<span class="n">inquiry</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pci_dev</span>	<span class="o">*</span><span class="n">pdev</span><span class="p">;</span>
	<span class="kt">int</span>	<span class="n">len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span><span class="p">(</span> <span class="n">make_local_pdev</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pdev</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">)</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">eof</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">return</span> <span class="n">len</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span><span class="p">(</span> <span class="p">(</span><span class="n">inquiry</span> <span class="o">=</span> <span class="n">mega_allocate_inquiry</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dma_handle</span><span class="p">,</span> <span class="n">pdev</span><span class="p">))</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="p">)</span> <span class="p">{</span>
		<span class="n">free_local_pdev</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
		<span class="o">*</span><span class="n">eof</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">return</span> <span class="n">len</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span><span class="p">(</span> <span class="n">mega_adapinq</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">dma_handle</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">)</span> <span class="p">{</span>

		<span class="n">len</span> <span class="o">=</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="s">&quot;Adapter inquiry failed.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;megaraid: inquiry failed.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

		<span class="n">mega_free_inquiry</span><span class="p">(</span><span class="n">inquiry</span><span class="p">,</span> <span class="n">dma_handle</span><span class="p">,</span> <span class="n">pdev</span><span class="p">);</span>

		<span class="n">free_local_pdev</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>

		<span class="o">*</span><span class="n">eof</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

		<span class="k">return</span> <span class="n">len</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span><span class="p">(</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">flag</span> <span class="o">&amp;</span> <span class="n">BOARD_40LD</span> <span class="p">)</span> <span class="p">{</span>
		<span class="n">len</span> <span class="o">=</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="s">&quot;Rebuild Rate: [%d%%]</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="p">((</span><span class="n">mega_inquiry3</span> <span class="o">*</span><span class="p">)</span><span class="n">inquiry</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">rebuild_rate</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="n">len</span> <span class="o">=</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="s">&quot;Rebuild Rate: [%d%%]</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="p">((</span><span class="n">mraid_ext_inquiry</span> <span class="o">*</span><span class="p">)</span>
			<span class="n">inquiry</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">raid_inq</span><span class="p">.</span><span class="n">adapter_info</span><span class="p">.</span><span class="n">rebuild_rate</span><span class="p">);</span>
	<span class="p">}</span>


	<span class="n">mega_free_inquiry</span><span class="p">(</span><span class="n">inquiry</span><span class="p">,</span> <span class="n">dma_handle</span><span class="p">,</span> <span class="n">pdev</span><span class="p">);</span>

	<span class="n">free_local_pdev</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>

	<span class="o">*</span><span class="n">eof</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">len</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/**</span>
<span class="cm"> * proc_battery()</span>
<span class="cm"> * @page - buffer to write the data in</span>
<span class="cm"> * @start - where the actual data has been written in page</span>
<span class="cm"> * @offset - same meaning as the read system call</span>
<span class="cm"> * @count - same meaning as the read system call</span>
<span class="cm"> * @eof - set if no more data needs to be returned</span>
<span class="cm"> * @data - pointer to our soft state</span>
<span class="cm"> *</span>
<span class="cm"> * Display information about the battery module on the controller.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">proc_battery</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">start</span><span class="p">,</span> <span class="kt">off_t</span> <span class="n">offset</span><span class="p">,</span> <span class="kt">int</span> <span class="n">count</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">eof</span><span class="p">,</span>
		<span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">adapter_t</span>	<span class="o">*</span><span class="n">adapter</span> <span class="o">=</span> <span class="p">(</span><span class="n">adapter_t</span> <span class="o">*</span><span class="p">)</span><span class="n">data</span><span class="p">;</span>
	<span class="n">dma_addr_t</span>	<span class="n">dma_handle</span><span class="p">;</span>
	<span class="n">caddr_t</span>		<span class="n">inquiry</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pci_dev</span>	<span class="o">*</span><span class="n">pdev</span><span class="p">;</span>
	<span class="n">u8</span>	<span class="n">battery_status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">char</span>	<span class="n">str</span><span class="p">[</span><span class="mi">256</span><span class="p">];</span>
	<span class="kt">int</span>	<span class="n">len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span><span class="p">(</span> <span class="n">make_local_pdev</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pdev</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">)</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">eof</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">return</span> <span class="n">len</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span><span class="p">(</span> <span class="p">(</span><span class="n">inquiry</span> <span class="o">=</span> <span class="n">mega_allocate_inquiry</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dma_handle</span><span class="p">,</span> <span class="n">pdev</span><span class="p">))</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="p">)</span> <span class="p">{</span>
		<span class="n">free_local_pdev</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
		<span class="o">*</span><span class="n">eof</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">return</span> <span class="n">len</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span><span class="p">(</span> <span class="n">mega_adapinq</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">dma_handle</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">)</span> <span class="p">{</span>

		<span class="n">len</span> <span class="o">=</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="s">&quot;Adapter inquiry failed.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;megaraid: inquiry failed.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

		<span class="n">mega_free_inquiry</span><span class="p">(</span><span class="n">inquiry</span><span class="p">,</span> <span class="n">dma_handle</span><span class="p">,</span> <span class="n">pdev</span><span class="p">);</span>

		<span class="n">free_local_pdev</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>

		<span class="o">*</span><span class="n">eof</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

		<span class="k">return</span> <span class="n">len</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span><span class="p">(</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">flag</span> <span class="o">&amp;</span> <span class="n">BOARD_40LD</span> <span class="p">)</span> <span class="p">{</span>
		<span class="n">battery_status</span> <span class="o">=</span> <span class="p">((</span><span class="n">mega_inquiry3</span> <span class="o">*</span><span class="p">)</span><span class="n">inquiry</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">battery_status</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="n">battery_status</span> <span class="o">=</span> <span class="p">((</span><span class="n">mraid_ext_inquiry</span> <span class="o">*</span><span class="p">)</span><span class="n">inquiry</span><span class="p">)</span><span class="o">-&gt;</span>
			<span class="n">raid_inq</span><span class="p">.</span><span class="n">adapter_info</span><span class="p">.</span><span class="n">battery_status</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Decode the battery status</span>
<span class="cm">	 */</span>
	<span class="n">sprintf</span><span class="p">(</span><span class="n">str</span><span class="p">,</span> <span class="s">&quot;Battery Status:[%d]&quot;</span><span class="p">,</span> <span class="n">battery_status</span><span class="p">);</span>

	<span class="k">if</span><span class="p">(</span><span class="n">battery_status</span> <span class="o">==</span> <span class="n">MEGA_BATT_CHARGE_DONE</span><span class="p">)</span>
		<span class="n">strcat</span><span class="p">(</span><span class="n">str</span><span class="p">,</span> <span class="s">&quot; Charge Done&quot;</span><span class="p">);</span>

	<span class="k">if</span><span class="p">(</span><span class="n">battery_status</span> <span class="o">&amp;</span> <span class="n">MEGA_BATT_MODULE_MISSING</span><span class="p">)</span>
		<span class="n">strcat</span><span class="p">(</span><span class="n">str</span><span class="p">,</span> <span class="s">&quot; Module Missing&quot;</span><span class="p">);</span>
	
	<span class="k">if</span><span class="p">(</span><span class="n">battery_status</span> <span class="o">&amp;</span> <span class="n">MEGA_BATT_LOW_VOLTAGE</span><span class="p">)</span>
		<span class="n">strcat</span><span class="p">(</span><span class="n">str</span><span class="p">,</span> <span class="s">&quot; Low Voltage&quot;</span><span class="p">);</span>
	
	<span class="k">if</span><span class="p">(</span><span class="n">battery_status</span> <span class="o">&amp;</span> <span class="n">MEGA_BATT_TEMP_HIGH</span><span class="p">)</span>
		<span class="n">strcat</span><span class="p">(</span><span class="n">str</span><span class="p">,</span> <span class="s">&quot; Temperature High&quot;</span><span class="p">);</span>
	
	<span class="k">if</span><span class="p">(</span><span class="n">battery_status</span> <span class="o">&amp;</span> <span class="n">MEGA_BATT_PACK_MISSING</span><span class="p">)</span>
		<span class="n">strcat</span><span class="p">(</span><span class="n">str</span><span class="p">,</span> <span class="s">&quot; Pack Missing&quot;</span><span class="p">);</span>
	
	<span class="k">if</span><span class="p">(</span><span class="n">battery_status</span> <span class="o">&amp;</span> <span class="n">MEGA_BATT_CHARGE_INPROG</span><span class="p">)</span>
		<span class="n">strcat</span><span class="p">(</span><span class="n">str</span><span class="p">,</span> <span class="s">&quot; Charge In-progress&quot;</span><span class="p">);</span>
	
	<span class="k">if</span><span class="p">(</span><span class="n">battery_status</span> <span class="o">&amp;</span> <span class="n">MEGA_BATT_CHARGE_FAIL</span><span class="p">)</span>
		<span class="n">strcat</span><span class="p">(</span><span class="n">str</span><span class="p">,</span> <span class="s">&quot; Charge Fail&quot;</span><span class="p">);</span>
	
	<span class="k">if</span><span class="p">(</span><span class="n">battery_status</span> <span class="o">&amp;</span> <span class="n">MEGA_BATT_CYCLES_EXCEEDED</span><span class="p">)</span>
		<span class="n">strcat</span><span class="p">(</span><span class="n">str</span><span class="p">,</span> <span class="s">&quot; Cycles Exceeded&quot;</span><span class="p">);</span>

	<span class="n">len</span> <span class="o">=</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="s">&quot;%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">str</span><span class="p">);</span>


	<span class="n">mega_free_inquiry</span><span class="p">(</span><span class="n">inquiry</span><span class="p">,</span> <span class="n">dma_handle</span><span class="p">,</span> <span class="n">pdev</span><span class="p">);</span>

	<span class="n">free_local_pdev</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>

	<span class="o">*</span><span class="n">eof</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">len</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/**</span>
<span class="cm"> * proc_pdrv_ch0()</span>
<span class="cm"> * @page - buffer to write the data in</span>
<span class="cm"> * @start - where the actual data has been written in page</span>
<span class="cm"> * @offset - same meaning as the read system call</span>
<span class="cm"> * @count - same meaning as the read system call</span>
<span class="cm"> * @eof - set if no more data needs to be returned</span>
<span class="cm"> * @data - pointer to our soft state</span>
<span class="cm"> *</span>
<span class="cm"> * Display information about the physical drives on physical channel 0.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">proc_pdrv_ch0</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">start</span><span class="p">,</span> <span class="kt">off_t</span> <span class="n">offset</span><span class="p">,</span> <span class="kt">int</span> <span class="n">count</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">eof</span><span class="p">,</span>
		<span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">adapter_t</span> <span class="o">*</span><span class="n">adapter</span> <span class="o">=</span> <span class="p">(</span><span class="n">adapter_t</span> <span class="o">*</span><span class="p">)</span><span class="n">data</span><span class="p">;</span>

	<span class="o">*</span><span class="n">eof</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">return</span> <span class="p">(</span><span class="n">proc_pdrv</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">page</span><span class="p">,</span> <span class="mi">0</span><span class="p">));</span>
<span class="p">}</span>


<span class="cm">/**</span>
<span class="cm"> * proc_pdrv_ch1()</span>
<span class="cm"> * @page - buffer to write the data in</span>
<span class="cm"> * @start - where the actual data has been written in page</span>
<span class="cm"> * @offset - same meaning as the read system call</span>
<span class="cm"> * @count - same meaning as the read system call</span>
<span class="cm"> * @eof - set if no more data needs to be returned</span>
<span class="cm"> * @data - pointer to our soft state</span>
<span class="cm"> *</span>
<span class="cm"> * Display information about the physical drives on physical channel 1.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">proc_pdrv_ch1</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">start</span><span class="p">,</span> <span class="kt">off_t</span> <span class="n">offset</span><span class="p">,</span> <span class="kt">int</span> <span class="n">count</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">eof</span><span class="p">,</span>
		<span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">adapter_t</span> <span class="o">*</span><span class="n">adapter</span> <span class="o">=</span> <span class="p">(</span><span class="n">adapter_t</span> <span class="o">*</span><span class="p">)</span><span class="n">data</span><span class="p">;</span>

	<span class="o">*</span><span class="n">eof</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">return</span> <span class="p">(</span><span class="n">proc_pdrv</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">page</span><span class="p">,</span> <span class="mi">1</span><span class="p">));</span>
<span class="p">}</span>


<span class="cm">/**</span>
<span class="cm"> * proc_pdrv_ch2()</span>
<span class="cm"> * @page - buffer to write the data in</span>
<span class="cm"> * @start - where the actual data has been written in page</span>
<span class="cm"> * @offset - same meaning as the read system call</span>
<span class="cm"> * @count - same meaning as the read system call</span>
<span class="cm"> * @eof - set if no more data needs to be returned</span>
<span class="cm"> * @data - pointer to our soft state</span>
<span class="cm"> *</span>
<span class="cm"> * Display information about the physical drives on physical channel 2.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">proc_pdrv_ch2</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">start</span><span class="p">,</span> <span class="kt">off_t</span> <span class="n">offset</span><span class="p">,</span> <span class="kt">int</span> <span class="n">count</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">eof</span><span class="p">,</span>
		<span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">adapter_t</span> <span class="o">*</span><span class="n">adapter</span> <span class="o">=</span> <span class="p">(</span><span class="n">adapter_t</span> <span class="o">*</span><span class="p">)</span><span class="n">data</span><span class="p">;</span>

	<span class="o">*</span><span class="n">eof</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">return</span> <span class="p">(</span><span class="n">proc_pdrv</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">page</span><span class="p">,</span> <span class="mi">2</span><span class="p">));</span>
<span class="p">}</span>


<span class="cm">/**</span>
<span class="cm"> * proc_pdrv_ch3()</span>
<span class="cm"> * @page - buffer to write the data in</span>
<span class="cm"> * @start - where the actual data has been written in page</span>
<span class="cm"> * @offset - same meaning as the read system call</span>
<span class="cm"> * @count - same meaning as the read system call</span>
<span class="cm"> * @eof - set if no more data needs to be returned</span>
<span class="cm"> * @data - pointer to our soft state</span>
<span class="cm"> *</span>
<span class="cm"> * Display information about the physical drives on physical channel 3.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">proc_pdrv_ch3</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">start</span><span class="p">,</span> <span class="kt">off_t</span> <span class="n">offset</span><span class="p">,</span> <span class="kt">int</span> <span class="n">count</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">eof</span><span class="p">,</span>
		<span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">adapter_t</span> <span class="o">*</span><span class="n">adapter</span> <span class="o">=</span> <span class="p">(</span><span class="n">adapter_t</span> <span class="o">*</span><span class="p">)</span><span class="n">data</span><span class="p">;</span>

	<span class="o">*</span><span class="n">eof</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">return</span> <span class="p">(</span><span class="n">proc_pdrv</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">page</span><span class="p">,</span> <span class="mi">3</span><span class="p">));</span>
<span class="p">}</span>


<span class="cm">/**</span>
<span class="cm"> * proc_pdrv()</span>
<span class="cm"> * @page - buffer to write the data in</span>
<span class="cm"> * @adapter - pointer to our soft state</span>
<span class="cm"> *</span>
<span class="cm"> * Display information about the physical drives.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">proc_pdrv</span><span class="p">(</span><span class="n">adapter_t</span> <span class="o">*</span><span class="n">adapter</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="kt">int</span> <span class="n">channel</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">dma_addr_t</span>	<span class="n">dma_handle</span><span class="p">;</span>
	<span class="kt">char</span>		<span class="o">*</span><span class="n">scsi_inq</span><span class="p">;</span>
	<span class="n">dma_addr_t</span>	<span class="n">scsi_inq_dma_handle</span><span class="p">;</span>
	<span class="n">caddr_t</span>		<span class="n">inquiry</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pci_dev</span>	<span class="o">*</span><span class="n">pdev</span><span class="p">;</span>
	<span class="n">u8</span>	<span class="o">*</span><span class="n">pdrv_state</span><span class="p">;</span>
	<span class="n">u8</span>	<span class="n">state</span><span class="p">;</span>
	<span class="kt">int</span>	<span class="n">tgt</span><span class="p">;</span>
	<span class="kt">int</span>	<span class="n">max_channels</span><span class="p">;</span>
	<span class="kt">int</span>	<span class="n">len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">char</span>	<span class="n">str</span><span class="p">[</span><span class="mi">80</span><span class="p">];</span>
	<span class="kt">int</span>	<span class="n">i</span><span class="p">;</span>

	<span class="k">if</span><span class="p">(</span> <span class="n">make_local_pdev</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pdev</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span> <span class="n">len</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span><span class="p">(</span> <span class="p">(</span><span class="n">inquiry</span> <span class="o">=</span> <span class="n">mega_allocate_inquiry</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dma_handle</span><span class="p">,</span> <span class="n">pdev</span><span class="p">))</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="p">)</span> <span class="p">{</span>
		<span class="k">goto</span> <span class="n">free_pdev</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span><span class="p">(</span> <span class="n">mega_adapinq</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">dma_handle</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">)</span> <span class="p">{</span>
		<span class="n">len</span> <span class="o">=</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="s">&quot;Adapter inquiry failed.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;megaraid: inquiry failed.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

		<span class="k">goto</span> <span class="n">free_inquiry</span><span class="p">;</span>
	<span class="p">}</span>


	<span class="n">scsi_inq</span> <span class="o">=</span> <span class="n">pci_alloc_consistent</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="mi">256</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">scsi_inq_dma_handle</span><span class="p">);</span>

	<span class="k">if</span><span class="p">(</span> <span class="n">scsi_inq</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="p">)</span> <span class="p">{</span>
		<span class="n">len</span> <span class="o">=</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="s">&quot;memory not available for scsi inq.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

		<span class="k">goto</span> <span class="n">free_inquiry</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span><span class="p">(</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">flag</span> <span class="o">&amp;</span> <span class="n">BOARD_40LD</span> <span class="p">)</span> <span class="p">{</span>
		<span class="n">pdrv_state</span> <span class="o">=</span> <span class="p">((</span><span class="n">mega_inquiry3</span> <span class="o">*</span><span class="p">)</span><span class="n">inquiry</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">pdrv_state</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="n">pdrv_state</span> <span class="o">=</span> <span class="p">((</span><span class="n">mraid_ext_inquiry</span> <span class="o">*</span><span class="p">)</span><span class="n">inquiry</span><span class="p">)</span><span class="o">-&gt;</span>
			<span class="n">raid_inq</span><span class="p">.</span><span class="n">pdrv_info</span><span class="p">.</span><span class="n">pdrv_state</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">max_channels</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">product_info</span><span class="p">.</span><span class="n">nchannels</span><span class="p">;</span>

	<span class="k">if</span><span class="p">(</span> <span class="n">channel</span> <span class="o">&gt;=</span> <span class="n">max_channels</span> <span class="p">)</span> <span class="p">{</span>
		<span class="k">goto</span> <span class="n">free_pci</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">for</span><span class="p">(</span> <span class="n">tgt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">tgt</span> <span class="o">&lt;=</span> <span class="n">MAX_TARGET</span><span class="p">;</span> <span class="n">tgt</span><span class="o">++</span> <span class="p">)</span> <span class="p">{</span>

		<span class="n">i</span> <span class="o">=</span> <span class="n">channel</span><span class="o">*</span><span class="mi">16</span> <span class="o">+</span> <span class="n">tgt</span><span class="p">;</span>

		<span class="n">state</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="n">pdrv_state</span> <span class="o">+</span> <span class="n">i</span><span class="p">);</span>

		<span class="k">switch</span><span class="p">(</span> <span class="n">state</span> <span class="o">&amp;</span> <span class="mh">0x0F</span> <span class="p">)</span> <span class="p">{</span>

		<span class="k">case</span> <span class="n">PDRV_ONLINE</span>:
			<span class="n">sprintf</span><span class="p">(</span><span class="n">str</span><span class="p">,</span>
			<span class="s">&quot;Channel:%2d Id:%2d State: Online&quot;</span><span class="p">,</span>
				<span class="n">channel</span><span class="p">,</span> <span class="n">tgt</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">PDRV_FAILED</span>:
			<span class="n">sprintf</span><span class="p">(</span><span class="n">str</span><span class="p">,</span>
			<span class="s">&quot;Channel:%2d Id:%2d State: Failed&quot;</span><span class="p">,</span>
				<span class="n">channel</span><span class="p">,</span> <span class="n">tgt</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">PDRV_RBLD</span>:
			<span class="n">sprintf</span><span class="p">(</span><span class="n">str</span><span class="p">,</span>
			<span class="s">&quot;Channel:%2d Id:%2d State: Rebuild&quot;</span><span class="p">,</span>
				<span class="n">channel</span><span class="p">,</span> <span class="n">tgt</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">PDRV_HOTSPARE</span>:
			<span class="n">sprintf</span><span class="p">(</span><span class="n">str</span><span class="p">,</span>
			<span class="s">&quot;Channel:%2d Id:%2d State: Hot spare&quot;</span><span class="p">,</span>
				<span class="n">channel</span><span class="p">,</span> <span class="n">tgt</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="nl">default:</span>
			<span class="n">sprintf</span><span class="p">(</span><span class="n">str</span><span class="p">,</span>
			<span class="s">&quot;Channel:%2d Id:%2d State: Un-configured&quot;</span><span class="p">,</span>
				<span class="n">channel</span><span class="p">,</span> <span class="n">tgt</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 * This interface displays inquiries for disk drives</span>
<span class="cm">		 * only. Inquries for logical drives and non-disk</span>
<span class="cm">		 * devices are available through /proc/scsi/scsi</span>
<span class="cm">		 */</span>
		<span class="n">memset</span><span class="p">(</span><span class="n">scsi_inq</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">256</span><span class="p">);</span>
		<span class="k">if</span><span class="p">(</span> <span class="n">mega_internal_dev_inquiry</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">channel</span><span class="p">,</span> <span class="n">tgt</span><span class="p">,</span>
				<span class="n">scsi_inq_dma_handle</span><span class="p">)</span> <span class="o">||</span>
				<span class="p">(</span><span class="n">scsi_inq</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0x1F</span><span class="p">)</span> <span class="o">!=</span> <span class="n">TYPE_DISK</span> <span class="p">)</span> <span class="p">{</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 * Check for overflow. We print less than 240</span>
<span class="cm">		 * characters for inquiry</span>
<span class="cm">		 */</span>
		<span class="k">if</span><span class="p">(</span> <span class="p">(</span><span class="n">len</span> <span class="o">+</span> <span class="mi">240</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">PAGE_SIZE</span> <span class="p">)</span> <span class="k">break</span><span class="p">;</span>

		<span class="n">len</span> <span class="o">+=</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">page</span><span class="o">+</span><span class="n">len</span><span class="p">,</span> <span class="s">&quot;%s.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">str</span><span class="p">);</span>

		<span class="n">len</span> <span class="o">+=</span> <span class="n">mega_print_inquiry</span><span class="p">(</span><span class="n">page</span><span class="o">+</span><span class="n">len</span><span class="p">,</span> <span class="n">scsi_inq</span><span class="p">);</span>
	<span class="p">}</span>

<span class="nl">free_pci:</span>
	<span class="n">pci_free_consistent</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="mi">256</span><span class="p">,</span> <span class="n">scsi_inq</span><span class="p">,</span> <span class="n">scsi_inq_dma_handle</span><span class="p">);</span>
<span class="nl">free_inquiry:</span>
	<span class="n">mega_free_inquiry</span><span class="p">(</span><span class="n">inquiry</span><span class="p">,</span> <span class="n">dma_handle</span><span class="p">,</span> <span class="n">pdev</span><span class="p">);</span>
<span class="nl">free_pdev:</span>
	<span class="n">free_local_pdev</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">len</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * Display scsi inquiry</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">mega_print_inquiry</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">scsi_inq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span>	<span class="n">len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span>	<span class="n">i</span><span class="p">;</span>

	<span class="n">len</span> <span class="o">=</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="s">&quot;  Vendor: &quot;</span><span class="p">);</span>
	<span class="k">for</span><span class="p">(</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">8</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">16</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span> <span class="p">)</span> <span class="p">{</span>
		<span class="n">len</span> <span class="o">+=</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">page</span><span class="o">+</span><span class="n">len</span><span class="p">,</span> <span class="s">&quot;%c&quot;</span><span class="p">,</span> <span class="n">scsi_inq</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
	<span class="p">}</span>

	<span class="n">len</span> <span class="o">+=</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">page</span><span class="o">+</span><span class="n">len</span><span class="p">,</span> <span class="s">&quot;  Model: &quot;</span><span class="p">);</span>

	<span class="k">for</span><span class="p">(</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">16</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">32</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span> <span class="p">)</span> <span class="p">{</span>
		<span class="n">len</span> <span class="o">+=</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">page</span><span class="o">+</span><span class="n">len</span><span class="p">,</span> <span class="s">&quot;%c&quot;</span><span class="p">,</span> <span class="n">scsi_inq</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
	<span class="p">}</span>

	<span class="n">len</span> <span class="o">+=</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">page</span><span class="o">+</span><span class="n">len</span><span class="p">,</span> <span class="s">&quot;  Rev: &quot;</span><span class="p">);</span>

	<span class="k">for</span><span class="p">(</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">32</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">36</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span> <span class="p">)</span> <span class="p">{</span>
		<span class="n">len</span> <span class="o">+=</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">page</span><span class="o">+</span><span class="n">len</span><span class="p">,</span> <span class="s">&quot;%c&quot;</span><span class="p">,</span> <span class="n">scsi_inq</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
	<span class="p">}</span>

	<span class="n">len</span> <span class="o">+=</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">page</span><span class="o">+</span><span class="n">len</span><span class="p">,</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="n">i</span> <span class="o">=</span> <span class="n">scsi_inq</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0x1f</span><span class="p">;</span>

	<span class="n">len</span> <span class="o">+=</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">page</span><span class="o">+</span><span class="n">len</span><span class="p">,</span> <span class="s">&quot;  Type:   %s &quot;</span><span class="p">,</span> <span class="n">scsi_device_type</span><span class="p">(</span><span class="n">i</span><span class="p">));</span>

	<span class="n">len</span> <span class="o">+=</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">page</span><span class="o">+</span><span class="n">len</span><span class="p">,</span>
	<span class="s">&quot;                 ANSI SCSI revision: %02x&quot;</span><span class="p">,</span> <span class="n">scsi_inq</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0x07</span><span class="p">);</span>

	<span class="k">if</span><span class="p">(</span> <span class="p">(</span><span class="n">scsi_inq</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0x07</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">scsi_inq</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0x0f</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="p">)</span>
		<span class="n">len</span> <span class="o">+=</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">page</span><span class="o">+</span><span class="n">len</span><span class="p">,</span> <span class="s">&quot; CCS</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">len</span> <span class="o">+=</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">page</span><span class="o">+</span><span class="n">len</span><span class="p">,</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">len</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/**</span>
<span class="cm"> * proc_rdrv_10()</span>
<span class="cm"> * @page - buffer to write the data in</span>
<span class="cm"> * @start - where the actual data has been written in page</span>
<span class="cm"> * @offset - same meaning as the read system call</span>
<span class="cm"> * @count - same meaning as the read system call</span>
<span class="cm"> * @eof - set if no more data needs to be returned</span>
<span class="cm"> * @data - pointer to our soft state</span>
<span class="cm"> *</span>
<span class="cm"> * Display real time information about the logical drives 0 through 9.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">proc_rdrv_10</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">start</span><span class="p">,</span> <span class="kt">off_t</span> <span class="n">offset</span><span class="p">,</span> <span class="kt">int</span> <span class="n">count</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">eof</span><span class="p">,</span>
		<span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">adapter_t</span> <span class="o">*</span><span class="n">adapter</span> <span class="o">=</span> <span class="p">(</span><span class="n">adapter_t</span> <span class="o">*</span><span class="p">)</span><span class="n">data</span><span class="p">;</span>

	<span class="o">*</span><span class="n">eof</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">return</span> <span class="p">(</span><span class="n">proc_rdrv</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">page</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">9</span><span class="p">));</span>
<span class="p">}</span>


<span class="cm">/**</span>
<span class="cm"> * proc_rdrv_20()</span>
<span class="cm"> * @page - buffer to write the data in</span>
<span class="cm"> * @start - where the actual data has been written in page</span>
<span class="cm"> * @offset - same meaning as the read system call</span>
<span class="cm"> * @count - same meaning as the read system call</span>
<span class="cm"> * @eof - set if no more data needs to be returned</span>
<span class="cm"> * @data - pointer to our soft state</span>
<span class="cm"> *</span>
<span class="cm"> * Display real time information about the logical drives 0 through 9.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">proc_rdrv_20</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">start</span><span class="p">,</span> <span class="kt">off_t</span> <span class="n">offset</span><span class="p">,</span> <span class="kt">int</span> <span class="n">count</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">eof</span><span class="p">,</span>
		<span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">adapter_t</span> <span class="o">*</span><span class="n">adapter</span> <span class="o">=</span> <span class="p">(</span><span class="n">adapter_t</span> <span class="o">*</span><span class="p">)</span><span class="n">data</span><span class="p">;</span>

	<span class="o">*</span><span class="n">eof</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">return</span> <span class="p">(</span><span class="n">proc_rdrv</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">page</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">19</span><span class="p">));</span>
<span class="p">}</span>


<span class="cm">/**</span>
<span class="cm"> * proc_rdrv_30()</span>
<span class="cm"> * @page - buffer to write the data in</span>
<span class="cm"> * @start - where the actual data has been written in page</span>
<span class="cm"> * @offset - same meaning as the read system call</span>
<span class="cm"> * @count - same meaning as the read system call</span>
<span class="cm"> * @eof - set if no more data needs to be returned</span>
<span class="cm"> * @data - pointer to our soft state</span>
<span class="cm"> *</span>
<span class="cm"> * Display real time information about the logical drives 0 through 9.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">proc_rdrv_30</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">start</span><span class="p">,</span> <span class="kt">off_t</span> <span class="n">offset</span><span class="p">,</span> <span class="kt">int</span> <span class="n">count</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">eof</span><span class="p">,</span>
		<span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">adapter_t</span> <span class="o">*</span><span class="n">adapter</span> <span class="o">=</span> <span class="p">(</span><span class="n">adapter_t</span> <span class="o">*</span><span class="p">)</span><span class="n">data</span><span class="p">;</span>

	<span class="o">*</span><span class="n">eof</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">return</span> <span class="p">(</span><span class="n">proc_rdrv</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">page</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">29</span><span class="p">));</span>
<span class="p">}</span>


<span class="cm">/**</span>
<span class="cm"> * proc_rdrv_40()</span>
<span class="cm"> * @page - buffer to write the data in</span>
<span class="cm"> * @start - where the actual data has been written in page</span>
<span class="cm"> * @offset - same meaning as the read system call</span>
<span class="cm"> * @count - same meaning as the read system call</span>
<span class="cm"> * @eof - set if no more data needs to be returned</span>
<span class="cm"> * @data - pointer to our soft state</span>
<span class="cm"> *</span>
<span class="cm"> * Display real time information about the logical drives 0 through 9.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">proc_rdrv_40</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">start</span><span class="p">,</span> <span class="kt">off_t</span> <span class="n">offset</span><span class="p">,</span> <span class="kt">int</span> <span class="n">count</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">eof</span><span class="p">,</span>
		<span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">adapter_t</span> <span class="o">*</span><span class="n">adapter</span> <span class="o">=</span> <span class="p">(</span><span class="n">adapter_t</span> <span class="o">*</span><span class="p">)</span><span class="n">data</span><span class="p">;</span>

	<span class="o">*</span><span class="n">eof</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">return</span> <span class="p">(</span><span class="n">proc_rdrv</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">page</span><span class="p">,</span> <span class="mi">30</span><span class="p">,</span> <span class="mi">39</span><span class="p">));</span>
<span class="p">}</span>


<span class="cm">/**</span>
<span class="cm"> * proc_rdrv()</span>
<span class="cm"> * @page - buffer to write the data in</span>
<span class="cm"> * @adapter - pointer to our soft state</span>
<span class="cm"> * @start - starting logical drive to display</span>
<span class="cm"> * @end - ending logical drive to display</span>
<span class="cm"> *</span>
<span class="cm"> * We do not print the inquiry information since its already available through</span>
<span class="cm"> * /proc/scsi/scsi interface</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">proc_rdrv</span><span class="p">(</span><span class="n">adapter_t</span> <span class="o">*</span><span class="n">adapter</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="kt">int</span> <span class="n">start</span><span class="p">,</span> <span class="kt">int</span> <span class="n">end</span> <span class="p">)</span>
<span class="p">{</span>
	<span class="n">dma_addr_t</span>	<span class="n">dma_handle</span><span class="p">;</span>
	<span class="n">logdrv_param</span>	<span class="o">*</span><span class="n">lparam</span><span class="p">;</span>
	<span class="n">megacmd_t</span>	<span class="n">mc</span><span class="p">;</span>
	<span class="kt">char</span>		<span class="o">*</span><span class="n">disk_array</span><span class="p">;</span>
	<span class="n">dma_addr_t</span>	<span class="n">disk_array_dma_handle</span><span class="p">;</span>
	<span class="n">caddr_t</span>		<span class="n">inquiry</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pci_dev</span>	<span class="o">*</span><span class="n">pdev</span><span class="p">;</span>
	<span class="n">u8</span>	<span class="o">*</span><span class="n">rdrv_state</span><span class="p">;</span>
	<span class="kt">int</span>	<span class="n">num_ldrv</span><span class="p">;</span>
	<span class="n">u32</span>	<span class="n">array_sz</span><span class="p">;</span>
	<span class="kt">int</span>	<span class="n">len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span>	<span class="n">i</span><span class="p">;</span>

	<span class="k">if</span><span class="p">(</span> <span class="n">make_local_pdev</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pdev</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span> <span class="n">len</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span><span class="p">(</span> <span class="p">(</span><span class="n">inquiry</span> <span class="o">=</span> <span class="n">mega_allocate_inquiry</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dma_handle</span><span class="p">,</span> <span class="n">pdev</span><span class="p">))</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="p">)</span> <span class="p">{</span>
		<span class="n">free_local_pdev</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">len</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span><span class="p">(</span> <span class="n">mega_adapinq</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">dma_handle</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">)</span> <span class="p">{</span>

		<span class="n">len</span> <span class="o">=</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="s">&quot;Adapter inquiry failed.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;megaraid: inquiry failed.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

		<span class="n">mega_free_inquiry</span><span class="p">(</span><span class="n">inquiry</span><span class="p">,</span> <span class="n">dma_handle</span><span class="p">,</span> <span class="n">pdev</span><span class="p">);</span>

		<span class="n">free_local_pdev</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>

		<span class="k">return</span> <span class="n">len</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mc</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">megacmd_t</span><span class="p">));</span>

	<span class="k">if</span><span class="p">(</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">flag</span> <span class="o">&amp;</span> <span class="n">BOARD_40LD</span> <span class="p">)</span> <span class="p">{</span>
		<span class="n">array_sz</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">disk_array_40ld</span><span class="p">);</span>

		<span class="n">rdrv_state</span> <span class="o">=</span> <span class="p">((</span><span class="n">mega_inquiry3</span> <span class="o">*</span><span class="p">)</span><span class="n">inquiry</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">ldrv_state</span><span class="p">;</span>

		<span class="n">num_ldrv</span> <span class="o">=</span> <span class="p">((</span><span class="n">mega_inquiry3</span> <span class="o">*</span><span class="p">)</span><span class="n">inquiry</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">num_ldrv</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="n">array_sz</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">disk_array_8ld</span><span class="p">);</span>

		<span class="n">rdrv_state</span> <span class="o">=</span> <span class="p">((</span><span class="n">mraid_ext_inquiry</span> <span class="o">*</span><span class="p">)</span><span class="n">inquiry</span><span class="p">)</span><span class="o">-&gt;</span>
			<span class="n">raid_inq</span><span class="p">.</span><span class="n">logdrv_info</span><span class="p">.</span><span class="n">ldrv_state</span><span class="p">;</span>

		<span class="n">num_ldrv</span> <span class="o">=</span> <span class="p">((</span><span class="n">mraid_ext_inquiry</span> <span class="o">*</span><span class="p">)</span><span class="n">inquiry</span><span class="p">)</span><span class="o">-&gt;</span>
			<span class="n">raid_inq</span><span class="p">.</span><span class="n">logdrv_info</span><span class="p">.</span><span class="n">num_ldrv</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">disk_array</span> <span class="o">=</span> <span class="n">pci_alloc_consistent</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">array_sz</span><span class="p">,</span>
			<span class="o">&amp;</span><span class="n">disk_array_dma_handle</span><span class="p">);</span>

	<span class="k">if</span><span class="p">(</span> <span class="n">disk_array</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="p">)</span> <span class="p">{</span>
		<span class="n">len</span> <span class="o">=</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="s">&quot;memory not available.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

		<span class="n">mega_free_inquiry</span><span class="p">(</span><span class="n">inquiry</span><span class="p">,</span> <span class="n">dma_handle</span><span class="p">,</span> <span class="n">pdev</span><span class="p">);</span>

		<span class="n">free_local_pdev</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>

		<span class="k">return</span> <span class="n">len</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">mc</span><span class="p">.</span><span class="n">xferaddr</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span><span class="n">disk_array_dma_handle</span><span class="p">;</span>

	<span class="k">if</span><span class="p">(</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">flag</span> <span class="o">&amp;</span> <span class="n">BOARD_40LD</span> <span class="p">)</span> <span class="p">{</span>
		<span class="n">mc</span><span class="p">.</span><span class="n">cmd</span> <span class="o">=</span> <span class="n">FC_NEW_CONFIG</span><span class="p">;</span>
		<span class="n">mc</span><span class="p">.</span><span class="n">opcode</span> <span class="o">=</span> <span class="n">OP_DCMD_READ_CONFIG</span><span class="p">;</span>

		<span class="k">if</span><span class="p">(</span> <span class="n">mega_internal_command</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mc</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">)</span> <span class="p">{</span>

			<span class="n">len</span> <span class="o">=</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="s">&quot;40LD read config failed.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

			<span class="n">mega_free_inquiry</span><span class="p">(</span><span class="n">inquiry</span><span class="p">,</span> <span class="n">dma_handle</span><span class="p">,</span> <span class="n">pdev</span><span class="p">);</span>

			<span class="n">pci_free_consistent</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">array_sz</span><span class="p">,</span> <span class="n">disk_array</span><span class="p">,</span>
					<span class="n">disk_array_dma_handle</span><span class="p">);</span>

			<span class="n">free_local_pdev</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>

			<span class="k">return</span> <span class="n">len</span><span class="p">;</span>
		<span class="p">}</span>

	<span class="p">}</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="n">mc</span><span class="p">.</span><span class="n">cmd</span> <span class="o">=</span> <span class="n">NEW_READ_CONFIG_8LD</span><span class="p">;</span>

		<span class="k">if</span><span class="p">(</span> <span class="n">mega_internal_command</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mc</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">)</span> <span class="p">{</span>

			<span class="n">mc</span><span class="p">.</span><span class="n">cmd</span> <span class="o">=</span> <span class="n">READ_CONFIG_8LD</span><span class="p">;</span>

			<span class="k">if</span><span class="p">(</span> <span class="n">mega_internal_command</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mc</span><span class="p">,</span>
						<span class="nb">NULL</span><span class="p">)</span> <span class="p">){</span>

				<span class="n">len</span> <span class="o">=</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">page</span><span class="p">,</span>
					<span class="s">&quot;8LD read config failed.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

				<span class="n">mega_free_inquiry</span><span class="p">(</span><span class="n">inquiry</span><span class="p">,</span> <span class="n">dma_handle</span><span class="p">,</span> <span class="n">pdev</span><span class="p">);</span>

				<span class="n">pci_free_consistent</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">array_sz</span><span class="p">,</span>
						<span class="n">disk_array</span><span class="p">,</span>
						<span class="n">disk_array_dma_handle</span><span class="p">);</span>

				<span class="n">free_local_pdev</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>

				<span class="k">return</span> <span class="n">len</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">for</span><span class="p">(</span> <span class="n">i</span> <span class="o">=</span> <span class="n">start</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="p">(</span> <span class="p">(</span><span class="n">end</span><span class="o">+</span><span class="mi">1</span> <span class="o">&lt;</span> <span class="n">num_ldrv</span><span class="p">)</span> <span class="o">?</span> <span class="n">end</span><span class="o">+</span><span class="mi">1</span> <span class="o">:</span> <span class="n">num_ldrv</span> <span class="p">);</span> <span class="n">i</span><span class="o">++</span> <span class="p">)</span> <span class="p">{</span>

		<span class="k">if</span><span class="p">(</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">flag</span> <span class="o">&amp;</span> <span class="n">BOARD_40LD</span> <span class="p">)</span> <span class="p">{</span>
			<span class="n">lparam</span> <span class="o">=</span>
			<span class="o">&amp;</span><span class="p">((</span><span class="n">disk_array_40ld</span> <span class="o">*</span><span class="p">)</span><span class="n">disk_array</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">ldrv</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">lparam</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">else</span> <span class="p">{</span>
			<span class="n">lparam</span> <span class="o">=</span>
			<span class="o">&amp;</span><span class="p">((</span><span class="n">disk_array_8ld</span> <span class="o">*</span><span class="p">)</span><span class="n">disk_array</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">ldrv</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">lparam</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 * Check for overflow. We print less than 240 characters for</span>
<span class="cm">		 * information about each logical drive.</span>
<span class="cm">		 */</span>
		<span class="k">if</span><span class="p">(</span> <span class="p">(</span><span class="n">len</span> <span class="o">+</span> <span class="mi">240</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">PAGE_SIZE</span> <span class="p">)</span> <span class="k">break</span><span class="p">;</span>

		<span class="n">len</span> <span class="o">+=</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">page</span><span class="o">+</span><span class="n">len</span><span class="p">,</span> <span class="s">&quot;Logical drive:%2d:, &quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>

		<span class="k">switch</span><span class="p">(</span> <span class="n">rdrv_state</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0x0F</span> <span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">RDRV_OFFLINE</span>:
			<span class="n">len</span> <span class="o">+=</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">page</span><span class="o">+</span><span class="n">len</span><span class="p">,</span> <span class="s">&quot;state: offline&quot;</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">RDRV_DEGRADED</span>:
			<span class="n">len</span> <span class="o">+=</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">page</span><span class="o">+</span><span class="n">len</span><span class="p">,</span> <span class="s">&quot;state: degraded&quot;</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">RDRV_OPTIMAL</span>:
			<span class="n">len</span> <span class="o">+=</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">page</span><span class="o">+</span><span class="n">len</span><span class="p">,</span> <span class="s">&quot;state: optimal&quot;</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">RDRV_DELETED</span>:
			<span class="n">len</span> <span class="o">+=</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">page</span><span class="o">+</span><span class="n">len</span><span class="p">,</span> <span class="s">&quot;state: deleted&quot;</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="nl">default:</span>
			<span class="n">len</span> <span class="o">+=</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">page</span><span class="o">+</span><span class="n">len</span><span class="p">,</span> <span class="s">&quot;state: unknown&quot;</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 * Check if check consistency or initialization is going on</span>
<span class="cm">		 * for this logical drive.</span>
<span class="cm">		 */</span>
		<span class="k">if</span><span class="p">(</span> <span class="p">(</span><span class="n">rdrv_state</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0xF0</span><span class="p">)</span> <span class="o">==</span> <span class="mh">0x20</span> <span class="p">)</span> <span class="p">{</span>
			<span class="n">len</span> <span class="o">+=</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">page</span><span class="o">+</span><span class="n">len</span><span class="p">,</span>
					<span class="s">&quot;, check-consistency in progress&quot;</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">else</span> <span class="k">if</span><span class="p">(</span> <span class="p">(</span><span class="n">rdrv_state</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0xF0</span><span class="p">)</span> <span class="o">==</span> <span class="mh">0x10</span> <span class="p">)</span> <span class="p">{</span>
			<span class="n">len</span> <span class="o">+=</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">page</span><span class="o">+</span><span class="n">len</span><span class="p">,</span>
					<span class="s">&quot;, initialization in progress&quot;</span><span class="p">);</span>
		<span class="p">}</span>
		
		<span class="n">len</span> <span class="o">+=</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">page</span><span class="o">+</span><span class="n">len</span><span class="p">,</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

		<span class="n">len</span> <span class="o">+=</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">page</span><span class="o">+</span><span class="n">len</span><span class="p">,</span> <span class="s">&quot;Span depth:%3d, &quot;</span><span class="p">,</span>
				<span class="n">lparam</span><span class="o">-&gt;</span><span class="n">span_depth</span><span class="p">);</span>

		<span class="n">len</span> <span class="o">+=</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">page</span><span class="o">+</span><span class="n">len</span><span class="p">,</span> <span class="s">&quot;RAID level:%3d, &quot;</span><span class="p">,</span>
				<span class="n">lparam</span><span class="o">-&gt;</span><span class="n">level</span><span class="p">);</span>

		<span class="n">len</span> <span class="o">+=</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">page</span><span class="o">+</span><span class="n">len</span><span class="p">,</span> <span class="s">&quot;Stripe size:%3d, &quot;</span><span class="p">,</span>
				<span class="n">lparam</span><span class="o">-&gt;</span><span class="n">stripe_sz</span> <span class="o">?</span> <span class="n">lparam</span><span class="o">-&gt;</span><span class="n">stripe_sz</span><span class="o">/</span><span class="mi">2</span><span class="o">:</span> <span class="mi">128</span><span class="p">);</span>

		<span class="n">len</span> <span class="o">+=</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">page</span><span class="o">+</span><span class="n">len</span><span class="p">,</span> <span class="s">&quot;Row size:%3d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">lparam</span><span class="o">-&gt;</span><span class="n">row_size</span><span class="p">);</span>


		<span class="n">len</span> <span class="o">+=</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">page</span><span class="o">+</span><span class="n">len</span><span class="p">,</span> <span class="s">&quot;Read Policy: &quot;</span><span class="p">);</span>

		<span class="k">switch</span><span class="p">(</span><span class="n">lparam</span><span class="o">-&gt;</span><span class="n">read_ahead</span><span class="p">)</span> <span class="p">{</span>

		<span class="k">case</span> <span class="n">NO_READ_AHEAD</span>:
			<span class="n">len</span> <span class="o">+=</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">page</span><span class="o">+</span><span class="n">len</span><span class="p">,</span> <span class="s">&quot;No read ahead, &quot;</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">READ_AHEAD</span>:
			<span class="n">len</span> <span class="o">+=</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">page</span><span class="o">+</span><span class="n">len</span><span class="p">,</span> <span class="s">&quot;Read ahead, &quot;</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">ADAP_READ_AHEAD</span>:
			<span class="n">len</span> <span class="o">+=</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">page</span><span class="o">+</span><span class="n">len</span><span class="p">,</span> <span class="s">&quot;Adaptive, &quot;</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="p">}</span>

		<span class="n">len</span> <span class="o">+=</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">page</span><span class="o">+</span><span class="n">len</span><span class="p">,</span> <span class="s">&quot;Write Policy: &quot;</span><span class="p">);</span>

		<span class="k">switch</span><span class="p">(</span><span class="n">lparam</span><span class="o">-&gt;</span><span class="n">write_mode</span><span class="p">)</span> <span class="p">{</span>

		<span class="k">case</span> <span class="n">WRMODE_WRITE_THRU</span>:
			<span class="n">len</span> <span class="o">+=</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">page</span><span class="o">+</span><span class="n">len</span><span class="p">,</span> <span class="s">&quot;Write thru, &quot;</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">WRMODE_WRITE_BACK</span>:
			<span class="n">len</span> <span class="o">+=</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">page</span><span class="o">+</span><span class="n">len</span><span class="p">,</span> <span class="s">&quot;Write back, &quot;</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">len</span> <span class="o">+=</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">page</span><span class="o">+</span><span class="n">len</span><span class="p">,</span> <span class="s">&quot;Cache Policy: &quot;</span><span class="p">);</span>

		<span class="k">switch</span><span class="p">(</span><span class="n">lparam</span><span class="o">-&gt;</span><span class="n">direct_io</span><span class="p">)</span> <span class="p">{</span>

		<span class="k">case</span> <span class="n">CACHED_IO</span>:
			<span class="n">len</span> <span class="o">+=</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">page</span><span class="o">+</span><span class="n">len</span><span class="p">,</span> <span class="s">&quot;Cached IO</span><span class="se">\n\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">DIRECT_IO</span>:
			<span class="n">len</span> <span class="o">+=</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">page</span><span class="o">+</span><span class="n">len</span><span class="p">,</span> <span class="s">&quot;Direct IO</span><span class="se">\n\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">mega_free_inquiry</span><span class="p">(</span><span class="n">inquiry</span><span class="p">,</span> <span class="n">dma_handle</span><span class="p">,</span> <span class="n">pdev</span><span class="p">);</span>

	<span class="n">pci_free_consistent</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">array_sz</span><span class="p">,</span> <span class="n">disk_array</span><span class="p">,</span>
			<span class="n">disk_array_dma_handle</span><span class="p">);</span>

	<span class="n">free_local_pdev</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">len</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#else</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">mega_create_proc_entry</span><span class="p">(</span><span class="kt">int</span> <span class="n">index</span><span class="p">,</span> <span class="k">struct</span> <span class="n">proc_dir_entry</span> <span class="o">*</span><span class="n">parent</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>
<span class="cp">#endif</span>


<span class="cm">/**</span>
<span class="cm"> * megaraid_biosparam()</span>
<span class="cm"> *</span>
<span class="cm"> * Return the disk geometry for a particular disk</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">megaraid_biosparam</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="n">sdev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">block_device</span> <span class="o">*</span><span class="n">bdev</span><span class="p">,</span>
		    <span class="n">sector_t</span> <span class="n">capacity</span><span class="p">,</span> <span class="kt">int</span> <span class="n">geom</span><span class="p">[])</span>
<span class="p">{</span>
	<span class="n">adapter_t</span>	<span class="o">*</span><span class="n">adapter</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span>	<span class="o">*</span><span class="n">bh</span><span class="p">;</span>
	<span class="kt">int</span>	<span class="n">heads</span><span class="p">;</span>
	<span class="kt">int</span>	<span class="n">sectors</span><span class="p">;</span>
	<span class="kt">int</span>	<span class="n">cylinders</span><span class="p">;</span>
	<span class="kt">int</span>	<span class="n">rval</span><span class="p">;</span>

	<span class="cm">/* Get pointer to host config structure */</span>
	<span class="n">adapter</span> <span class="o">=</span> <span class="p">(</span><span class="n">adapter_t</span> <span class="o">*</span><span class="p">)</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">hostdata</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">IS_RAID_CH</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">sdev</span><span class="o">-&gt;</span><span class="n">channel</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/* Default heads (64) &amp; sectors (32) */</span>
			<span class="n">heads</span> <span class="o">=</span> <span class="mi">64</span><span class="p">;</span>
			<span class="n">sectors</span> <span class="o">=</span> <span class="mi">32</span><span class="p">;</span>
			<span class="n">cylinders</span> <span class="o">=</span> <span class="p">(</span><span class="n">ulong</span><span class="p">)</span><span class="n">capacity</span> <span class="o">/</span> <span class="p">(</span><span class="n">heads</span> <span class="o">*</span> <span class="n">sectors</span><span class="p">);</span>

			<span class="cm">/*</span>
<span class="cm">			 * Handle extended translation size for logical drives</span>
<span class="cm">			 * &gt; 1Gb</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">ulong</span><span class="p">)</span><span class="n">capacity</span> <span class="o">&gt;=</span> <span class="mh">0x200000</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">heads</span> <span class="o">=</span> <span class="mi">255</span><span class="p">;</span>
				<span class="n">sectors</span> <span class="o">=</span> <span class="mi">63</span><span class="p">;</span>
				<span class="n">cylinders</span> <span class="o">=</span> <span class="p">(</span><span class="n">ulong</span><span class="p">)</span><span class="n">capacity</span> <span class="o">/</span> <span class="p">(</span><span class="n">heads</span> <span class="o">*</span> <span class="n">sectors</span><span class="p">);</span>
			<span class="p">}</span>

			<span class="cm">/* return result */</span>
			<span class="n">geom</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">heads</span><span class="p">;</span>
			<span class="n">geom</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">sectors</span><span class="p">;</span>
			<span class="n">geom</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">cylinders</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="n">bh</span> <span class="o">=</span> <span class="n">scsi_bios_ptable</span><span class="p">(</span><span class="n">bdev</span><span class="p">);</span>

		<span class="k">if</span><span class="p">(</span> <span class="n">bh</span> <span class="p">)</span> <span class="p">{</span>
			<span class="n">rval</span> <span class="o">=</span> <span class="n">scsi_partsize</span><span class="p">(</span><span class="n">bh</span><span class="p">,</span> <span class="n">capacity</span><span class="p">,</span>
					    <span class="o">&amp;</span><span class="n">geom</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">geom</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">geom</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
			<span class="n">kfree</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
			<span class="k">if</span><span class="p">(</span> <span class="n">rval</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span> <span class="p">)</span>
				<span class="k">return</span> <span class="n">rval</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span>
		<span class="s">&quot;megaraid: invalid partition on this disk on channel %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">sdev</span><span class="o">-&gt;</span><span class="n">channel</span><span class="p">);</span>

		<span class="cm">/* Default heads (64) &amp; sectors (32) */</span>
		<span class="n">heads</span> <span class="o">=</span> <span class="mi">64</span><span class="p">;</span>
		<span class="n">sectors</span> <span class="o">=</span> <span class="mi">32</span><span class="p">;</span>
		<span class="n">cylinders</span> <span class="o">=</span> <span class="p">(</span><span class="n">ulong</span><span class="p">)</span><span class="n">capacity</span> <span class="o">/</span> <span class="p">(</span><span class="n">heads</span> <span class="o">*</span> <span class="n">sectors</span><span class="p">);</span>

		<span class="cm">/* Handle extended translation size for logical drives &gt; 1Gb */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">ulong</span><span class="p">)</span><span class="n">capacity</span> <span class="o">&gt;=</span> <span class="mh">0x200000</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">heads</span> <span class="o">=</span> <span class="mi">255</span><span class="p">;</span>
			<span class="n">sectors</span> <span class="o">=</span> <span class="mi">63</span><span class="p">;</span>
			<span class="n">cylinders</span> <span class="o">=</span> <span class="p">(</span><span class="n">ulong</span><span class="p">)</span><span class="n">capacity</span> <span class="o">/</span> <span class="p">(</span><span class="n">heads</span> <span class="o">*</span> <span class="n">sectors</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="cm">/* return result */</span>
		<span class="n">geom</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">heads</span><span class="p">;</span>
		<span class="n">geom</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">sectors</span><span class="p">;</span>
		<span class="n">geom</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">cylinders</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * mega_init_scb()</span>
<span class="cm"> * @adapter - pointer to our soft state</span>
<span class="cm"> *</span>
<span class="cm"> * Allocate memory for the various pointers in the scb structures:</span>
<span class="cm"> * scatter-gather list pointer, passthru and extended passthru structure</span>
<span class="cm"> * pointers.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">mega_init_scb</span><span class="p">(</span><span class="n">adapter_t</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">scb_t</span>	<span class="o">*</span><span class="n">scb</span><span class="p">;</span>
	<span class="kt">int</span>	<span class="n">i</span><span class="p">;</span>

	<span class="k">for</span><span class="p">(</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">max_cmds</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span> <span class="p">)</span> <span class="p">{</span>

		<span class="n">scb</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">scb_list</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

		<span class="n">scb</span><span class="o">-&gt;</span><span class="n">sgl64</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">scb</span><span class="o">-&gt;</span><span class="n">sgl</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">scb</span><span class="o">-&gt;</span><span class="n">pthru</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">scb</span><span class="o">-&gt;</span><span class="n">epthru</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">for</span><span class="p">(</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">max_cmds</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span> <span class="p">)</span> <span class="p">{</span>

		<span class="n">scb</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">scb_list</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

		<span class="n">scb</span><span class="o">-&gt;</span><span class="n">idx</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>

		<span class="n">scb</span><span class="o">-&gt;</span><span class="n">sgl64</span> <span class="o">=</span> <span class="n">pci_alloc_consistent</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
				<span class="k">sizeof</span><span class="p">(</span><span class="n">mega_sgl64</span><span class="p">)</span> <span class="o">*</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">sglen</span><span class="p">,</span>
				<span class="o">&amp;</span><span class="n">scb</span><span class="o">-&gt;</span><span class="n">sgl_dma_addr</span><span class="p">);</span>

		<span class="n">scb</span><span class="o">-&gt;</span><span class="n">sgl</span> <span class="o">=</span> <span class="p">(</span><span class="n">mega_sglist</span> <span class="o">*</span><span class="p">)</span><span class="n">scb</span><span class="o">-&gt;</span><span class="n">sgl64</span><span class="p">;</span>

		<span class="k">if</span><span class="p">(</span> <span class="o">!</span><span class="n">scb</span><span class="o">-&gt;</span><span class="n">sgl</span> <span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;RAID: Can&#39;t allocate sglist.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">mega_free_sgl</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">scb</span><span class="o">-&gt;</span><span class="n">pthru</span> <span class="o">=</span> <span class="n">pci_alloc_consistent</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
				<span class="k">sizeof</span><span class="p">(</span><span class="n">mega_passthru</span><span class="p">),</span>
				<span class="o">&amp;</span><span class="n">scb</span><span class="o">-&gt;</span><span class="n">pthru_dma_addr</span><span class="p">);</span>

		<span class="k">if</span><span class="p">(</span> <span class="o">!</span><span class="n">scb</span><span class="o">-&gt;</span><span class="n">pthru</span> <span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;RAID: Can&#39;t allocate passthru.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">mega_free_sgl</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">scb</span><span class="o">-&gt;</span><span class="n">epthru</span> <span class="o">=</span> <span class="n">pci_alloc_consistent</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
				<span class="k">sizeof</span><span class="p">(</span><span class="n">mega_ext_passthru</span><span class="p">),</span>
				<span class="o">&amp;</span><span class="n">scb</span><span class="o">-&gt;</span><span class="n">epthru_dma_addr</span><span class="p">);</span>

		<span class="k">if</span><span class="p">(</span> <span class="o">!</span><span class="n">scb</span><span class="o">-&gt;</span><span class="n">epthru</span> <span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span>
				<span class="s">&quot;Can&#39;t allocate extended passthru.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">mega_free_sgl</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>


		<span class="n">scb</span><span class="o">-&gt;</span><span class="n">dma_type</span> <span class="o">=</span> <span class="n">MEGA_DMA_TYPE_NONE</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * Link to free list</span>
<span class="cm">		 * lock not required since we are loading the driver, so no</span>
<span class="cm">		 * commands possible right now.</span>
<span class="cm">		 */</span>
		<span class="n">scb</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">SCB_FREE</span><span class="p">;</span>
		<span class="n">scb</span><span class="o">-&gt;</span><span class="n">cmd</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">scb</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">free_list</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/**</span>
<span class="cm"> * megadev_open()</span>
<span class="cm"> * @inode - unused</span>
<span class="cm"> * @filep - unused</span>
<span class="cm"> *</span>
<span class="cm"> * Routines for the character/ioctl interface to the driver. Find out if this</span>
<span class="cm"> * is a valid open. </span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">megadev_open</span> <span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filep</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * Only allow superuser to access private ioctl interface</span>
<span class="cm">	 */</span>
	<span class="k">if</span><span class="p">(</span> <span class="o">!</span><span class="n">capable</span><span class="p">(</span><span class="n">CAP_SYS_ADMIN</span><span class="p">)</span> <span class="p">)</span> <span class="k">return</span> <span class="o">-</span><span class="n">EACCES</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/**</span>
<span class="cm"> * megadev_ioctl()</span>
<span class="cm"> * @inode - Our device inode</span>
<span class="cm"> * @filep - unused</span>
<span class="cm"> * @cmd - ioctl command</span>
<span class="cm"> * @arg - user buffer</span>
<span class="cm"> *</span>
<span class="cm"> * ioctl entry point for our private ioctl interface. We move the data in from</span>
<span class="cm"> * the user space, prepare the command (if necessary, convert the old MIMD</span>
<span class="cm"> * ioctl to new ioctl command), and issue a synchronous command to the</span>
<span class="cm"> * controller.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">megadev_ioctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filep</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">adapter_t</span>	<span class="o">*</span><span class="n">adapter</span><span class="p">;</span>
	<span class="n">nitioctl_t</span>	<span class="n">uioc</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">adapno</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">rval</span><span class="p">;</span>
	<span class="n">mega_passthru</span>	<span class="n">__user</span> <span class="o">*</span><span class="n">upthru</span><span class="p">;</span>	<span class="cm">/* user address for passthru */</span>
	<span class="n">mega_passthru</span>	<span class="o">*</span><span class="n">pthru</span><span class="p">;</span>		<span class="cm">/* copy user passthru here */</span>
	<span class="n">dma_addr_t</span>	<span class="n">pthru_dma_hndl</span><span class="p">;</span>
	<span class="kt">void</span>		<span class="o">*</span><span class="n">data</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>	<span class="cm">/* data to be transferred */</span>
	<span class="n">dma_addr_t</span>	<span class="n">data_dma_hndl</span><span class="p">;</span>	<span class="cm">/* dma handle for data xfer area */</span>
	<span class="n">megacmd_t</span>	<span class="n">mc</span><span class="p">;</span>
	<span class="n">megastat_t</span>	<span class="n">__user</span> <span class="o">*</span><span class="n">ustats</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">num_ldrv</span><span class="p">;</span>
	<span class="n">u32</span>		<span class="n">uxferaddr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pci_dev</span>	<span class="o">*</span><span class="n">pdev</span><span class="p">;</span>

	<span class="n">ustats</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span> <span class="cm">/* avoid compilation warnings */</span>
	<span class="n">num_ldrv</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Make sure only USCSICMD are issued through this interface.</span>
<span class="cm">	 * MIMD application would still fire different command.</span>
<span class="cm">	 */</span>
	<span class="k">if</span><span class="p">(</span> <span class="p">(</span><span class="n">_IOC_TYPE</span><span class="p">(</span><span class="n">cmd</span><span class="p">)</span> <span class="o">!=</span> <span class="n">MEGAIOC_MAGIC</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">cmd</span> <span class="o">!=</span> <span class="n">USCSICMD</span><span class="p">)</span> <span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Check and convert a possible MIMD command to NIT command.</span>
<span class="cm">	 * mega_m_to_n() copies the data from the user space, so we do not</span>
<span class="cm">	 * have to do it here.</span>
<span class="cm">	 * NOTE: We will need some user address to copyout the data, therefore</span>
<span class="cm">	 * the inteface layer will also provide us with the required user</span>
<span class="cm">	 * addresses.</span>
<span class="cm">	 */</span>
	<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">uioc</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">nitioctl_t</span><span class="p">));</span>
	<span class="k">if</span><span class="p">(</span> <span class="p">(</span><span class="n">rval</span> <span class="o">=</span> <span class="n">mega_m_to_n</span><span class="p">(</span> <span class="p">(</span><span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span><span class="n">arg</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">uioc</span><span class="p">))</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">)</span>
		<span class="k">return</span> <span class="n">rval</span><span class="p">;</span>


	<span class="k">switch</span><span class="p">(</span> <span class="n">uioc</span><span class="p">.</span><span class="n">opcode</span> <span class="p">)</span> <span class="p">{</span>

	<span class="k">case</span> <span class="n">GET_DRIVER_VER</span>:
		<span class="k">if</span><span class="p">(</span> <span class="n">put_user</span><span class="p">(</span><span class="n">driver_ver</span><span class="p">,</span> <span class="p">(</span><span class="n">u32</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span><span class="n">uioc</span><span class="p">.</span><span class="n">uioc_uaddr</span><span class="p">)</span> <span class="p">)</span>
			<span class="k">return</span> <span class="p">(</span><span class="o">-</span><span class="n">EFAULT</span><span class="p">);</span>

		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">GET_N_ADAP</span>:
		<span class="k">if</span><span class="p">(</span> <span class="n">put_user</span><span class="p">(</span><span class="n">hba_count</span><span class="p">,</span> <span class="p">(</span><span class="n">u32</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span><span class="n">uioc</span><span class="p">.</span><span class="n">uioc_uaddr</span><span class="p">)</span> <span class="p">)</span>
			<span class="k">return</span> <span class="p">(</span><span class="o">-</span><span class="n">EFAULT</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * Shucks. MIMD interface returns a positive value for number</span>
<span class="cm">		 * of adapters. TODO: Change it to return 0 when there is no</span>
<span class="cm">		 * applicatio using mimd interface.</span>
<span class="cm">		 */</span>
		<span class="k">return</span> <span class="n">hba_count</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">GET_ADAP_INFO</span>:

		<span class="cm">/*</span>
<span class="cm">		 * Which adapter</span>
<span class="cm">		 */</span>
		<span class="k">if</span><span class="p">(</span> <span class="p">(</span><span class="n">adapno</span> <span class="o">=</span> <span class="n">GETADAP</span><span class="p">(</span><span class="n">uioc</span><span class="p">.</span><span class="n">adapno</span><span class="p">))</span> <span class="o">&gt;=</span> <span class="n">hba_count</span> <span class="p">)</span>
			<span class="k">return</span> <span class="p">(</span><span class="o">-</span><span class="n">ENODEV</span><span class="p">);</span>

		<span class="k">if</span><span class="p">(</span> <span class="n">copy_to_user</span><span class="p">(</span><span class="n">uioc</span><span class="p">.</span><span class="n">uioc_uaddr</span><span class="p">,</span> <span class="n">mcontroller</span><span class="o">+</span><span class="n">adapno</span><span class="p">,</span>
				<span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">mcontroller</span><span class="p">))</span> <span class="p">)</span>
			<span class="k">return</span> <span class="p">(</span><span class="o">-</span><span class="n">EFAULT</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

<span class="cp">#if MEGA_HAVE_STATS</span>

	<span class="k">case</span> <span class="n">GET_STATS</span>:
		<span class="cm">/*</span>
<span class="cm">		 * Which adapter</span>
<span class="cm">		 */</span>
		<span class="k">if</span><span class="p">(</span> <span class="p">(</span><span class="n">adapno</span> <span class="o">=</span> <span class="n">GETADAP</span><span class="p">(</span><span class="n">uioc</span><span class="p">.</span><span class="n">adapno</span><span class="p">))</span> <span class="o">&gt;=</span> <span class="n">hba_count</span> <span class="p">)</span>
			<span class="k">return</span> <span class="p">(</span><span class="o">-</span><span class="n">ENODEV</span><span class="p">);</span>

		<span class="n">adapter</span> <span class="o">=</span> <span class="n">hba_soft_state</span><span class="p">[</span><span class="n">adapno</span><span class="p">];</span>

		<span class="n">ustats</span> <span class="o">=</span> <span class="n">uioc</span><span class="p">.</span><span class="n">uioc_uaddr</span><span class="p">;</span>

		<span class="k">if</span><span class="p">(</span> <span class="n">copy_from_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">num_ldrv</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ustats</span><span class="o">-&gt;</span><span class="n">num_ldrv</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">))</span> <span class="p">)</span>
			<span class="k">return</span> <span class="p">(</span><span class="o">-</span><span class="n">EFAULT</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * Check for the validity of the logical drive number</span>
<span class="cm">		 */</span>
		<span class="k">if</span><span class="p">(</span> <span class="n">num_ldrv</span> <span class="o">&gt;=</span> <span class="n">MAX_LOGICAL_DRIVES_40LD</span> <span class="p">)</span> <span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

		<span class="k">if</span><span class="p">(</span> <span class="n">copy_to_user</span><span class="p">(</span><span class="n">ustats</span><span class="o">-&gt;</span><span class="n">nreads</span><span class="p">,</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">nreads</span><span class="p">,</span>
					<span class="n">num_ldrv</span><span class="o">*</span><span class="k">sizeof</span><span class="p">(</span><span class="n">u32</span><span class="p">))</span> <span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

		<span class="k">if</span><span class="p">(</span> <span class="n">copy_to_user</span><span class="p">(</span><span class="n">ustats</span><span class="o">-&gt;</span><span class="n">nreadblocks</span><span class="p">,</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">nreadblocks</span><span class="p">,</span>
					<span class="n">num_ldrv</span><span class="o">*</span><span class="k">sizeof</span><span class="p">(</span><span class="n">u32</span><span class="p">))</span> <span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

		<span class="k">if</span><span class="p">(</span> <span class="n">copy_to_user</span><span class="p">(</span><span class="n">ustats</span><span class="o">-&gt;</span><span class="n">nwrites</span><span class="p">,</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">nwrites</span><span class="p">,</span>
					<span class="n">num_ldrv</span><span class="o">*</span><span class="k">sizeof</span><span class="p">(</span><span class="n">u32</span><span class="p">))</span> <span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

		<span class="k">if</span><span class="p">(</span> <span class="n">copy_to_user</span><span class="p">(</span><span class="n">ustats</span><span class="o">-&gt;</span><span class="n">nwriteblocks</span><span class="p">,</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">nwriteblocks</span><span class="p">,</span>
					<span class="n">num_ldrv</span><span class="o">*</span><span class="k">sizeof</span><span class="p">(</span><span class="n">u32</span><span class="p">))</span> <span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

		<span class="k">if</span><span class="p">(</span> <span class="n">copy_to_user</span><span class="p">(</span><span class="n">ustats</span><span class="o">-&gt;</span><span class="n">rd_errors</span><span class="p">,</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rd_errors</span><span class="p">,</span>
					<span class="n">num_ldrv</span><span class="o">*</span><span class="k">sizeof</span><span class="p">(</span><span class="n">u32</span><span class="p">))</span> <span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

		<span class="k">if</span><span class="p">(</span> <span class="n">copy_to_user</span><span class="p">(</span><span class="n">ustats</span><span class="o">-&gt;</span><span class="n">wr_errors</span><span class="p">,</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">wr_errors</span><span class="p">,</span>
					<span class="n">num_ldrv</span><span class="o">*</span><span class="k">sizeof</span><span class="p">(</span><span class="n">u32</span><span class="p">))</span> <span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="cp">#endif</span>
	<span class="k">case</span> <span class="n">MBOX_CMD</span>:

		<span class="cm">/*</span>
<span class="cm">		 * Which adapter</span>
<span class="cm">		 */</span>
		<span class="k">if</span><span class="p">(</span> <span class="p">(</span><span class="n">adapno</span> <span class="o">=</span> <span class="n">GETADAP</span><span class="p">(</span><span class="n">uioc</span><span class="p">.</span><span class="n">adapno</span><span class="p">))</span> <span class="o">&gt;=</span> <span class="n">hba_count</span> <span class="p">)</span>
			<span class="k">return</span> <span class="p">(</span><span class="o">-</span><span class="n">ENODEV</span><span class="p">);</span>

		<span class="n">adapter</span> <span class="o">=</span> <span class="n">hba_soft_state</span><span class="p">[</span><span class="n">adapno</span><span class="p">];</span>

		<span class="cm">/*</span>
<span class="cm">		 * Deletion of logical drive is a special case. The adapter</span>
<span class="cm">		 * should be quiescent before this command is issued.</span>
<span class="cm">		 */</span>
		<span class="k">if</span><span class="p">(</span> <span class="n">uioc</span><span class="p">.</span><span class="n">uioc_rmbox</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">FC_DEL_LOGDRV</span> <span class="o">&amp;&amp;</span>
				<span class="n">uioc</span><span class="p">.</span><span class="n">uioc_rmbox</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="n">OP_DEL_LOGDRV</span> <span class="p">)</span> <span class="p">{</span>

			<span class="cm">/*</span>
<span class="cm">			 * Do we support this feature</span>
<span class="cm">			 */</span>
			<span class="k">if</span><span class="p">(</span> <span class="o">!</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">support_random_del</span> <span class="p">)</span> <span class="p">{</span>
				<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;megaraid: logdrv &quot;</span><span class="p">);</span>
				<span class="n">printk</span><span class="p">(</span><span class="s">&quot;delete on non-supporting F/W.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

				<span class="k">return</span> <span class="p">(</span><span class="o">-</span><span class="n">EINVAL</span><span class="p">);</span>
			<span class="p">}</span>

			<span class="n">rval</span> <span class="o">=</span> <span class="n">mega_del_logdrv</span><span class="p">(</span> <span class="n">adapter</span><span class="p">,</span> <span class="n">uioc</span><span class="p">.</span><span class="n">uioc_rmbox</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="p">);</span>

			<span class="k">if</span><span class="p">(</span> <span class="n">rval</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">)</span> <span class="p">{</span>
				<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mc</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">megacmd_t</span><span class="p">));</span>

				<span class="n">mc</span><span class="p">.</span><span class="n">status</span> <span class="o">=</span> <span class="n">rval</span><span class="p">;</span>

				<span class="n">rval</span> <span class="o">=</span> <span class="n">mega_n_to_m</span><span class="p">((</span><span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span><span class="n">arg</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mc</span><span class="p">);</span>
			<span class="p">}</span>

			<span class="k">return</span> <span class="n">rval</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/*</span>
<span class="cm">		 * This interface only support the regular passthru commands.</span>
<span class="cm">		 * Reject extended passthru and 64-bit passthru</span>
<span class="cm">		 */</span>
		<span class="k">if</span><span class="p">(</span> <span class="n">uioc</span><span class="p">.</span><span class="n">uioc_rmbox</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">MEGA_MBOXCMD_PASSTHRU64</span> <span class="o">||</span>
			<span class="n">uioc</span><span class="p">.</span><span class="n">uioc_rmbox</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">MEGA_MBOXCMD_EXTPTHRU</span> <span class="p">)</span> <span class="p">{</span>

			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;megaraid: rejected passthru.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

			<span class="k">return</span> <span class="p">(</span><span class="o">-</span><span class="n">EINVAL</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 * For all internal commands, the buffer must be allocated in</span>
<span class="cm">		 * &lt;4GB address range</span>
<span class="cm">		 */</span>
		<span class="k">if</span><span class="p">(</span> <span class="n">make_local_pdev</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pdev</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>

		<span class="cm">/* Is it a passthru command or a DCMD */</span>
		<span class="k">if</span><span class="p">(</span> <span class="n">uioc</span><span class="p">.</span><span class="n">uioc_rmbox</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">MEGA_MBOXCMD_PASSTHRU</span> <span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Passthru commands */</span>

			<span class="n">pthru</span> <span class="o">=</span> <span class="n">pci_alloc_consistent</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span>
					<span class="k">sizeof</span><span class="p">(</span><span class="n">mega_passthru</span><span class="p">),</span>
					<span class="o">&amp;</span><span class="n">pthru_dma_hndl</span><span class="p">);</span>

			<span class="k">if</span><span class="p">(</span> <span class="n">pthru</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="p">)</span> <span class="p">{</span>
				<span class="n">free_local_pdev</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
				<span class="k">return</span> <span class="p">(</span><span class="o">-</span><span class="n">ENOMEM</span><span class="p">);</span>
			<span class="p">}</span>

			<span class="cm">/*</span>
<span class="cm">			 * The user passthru structure</span>
<span class="cm">			 */</span>
			<span class="n">upthru</span> <span class="o">=</span> <span class="p">(</span><span class="n">mega_passthru</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">MBOX</span><span class="p">(</span><span class="n">uioc</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">xferaddr</span><span class="p">;</span>

			<span class="cm">/*</span>
<span class="cm">			 * Copy in the user passthru here.</span>
<span class="cm">			 */</span>
			<span class="k">if</span><span class="p">(</span> <span class="n">copy_from_user</span><span class="p">(</span><span class="n">pthru</span><span class="p">,</span> <span class="n">upthru</span><span class="p">,</span>
						<span class="k">sizeof</span><span class="p">(</span><span class="n">mega_passthru</span><span class="p">))</span> <span class="p">)</span> <span class="p">{</span>

				<span class="n">pci_free_consistent</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span>
						<span class="k">sizeof</span><span class="p">(</span><span class="n">mega_passthru</span><span class="p">),</span> <span class="n">pthru</span><span class="p">,</span>
						<span class="n">pthru_dma_hndl</span><span class="p">);</span>

				<span class="n">free_local_pdev</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>

				<span class="k">return</span> <span class="p">(</span><span class="o">-</span><span class="n">EFAULT</span><span class="p">);</span>
			<span class="p">}</span>

			<span class="cm">/*</span>
<span class="cm">			 * Is there a data transfer</span>
<span class="cm">			 */</span>
			<span class="k">if</span><span class="p">(</span> <span class="n">pthru</span><span class="o">-&gt;</span><span class="n">dataxferlen</span> <span class="p">)</span> <span class="p">{</span>
				<span class="n">data</span> <span class="o">=</span> <span class="n">pci_alloc_consistent</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span>
						<span class="n">pthru</span><span class="o">-&gt;</span><span class="n">dataxferlen</span><span class="p">,</span>
						<span class="o">&amp;</span><span class="n">data_dma_hndl</span><span class="p">);</span>

				<span class="k">if</span><span class="p">(</span> <span class="n">data</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="p">)</span> <span class="p">{</span>
					<span class="n">pci_free_consistent</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span>
							<span class="k">sizeof</span><span class="p">(</span><span class="n">mega_passthru</span><span class="p">),</span>
							<span class="n">pthru</span><span class="p">,</span>
							<span class="n">pthru_dma_hndl</span><span class="p">);</span>

					<span class="n">free_local_pdev</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>

					<span class="k">return</span> <span class="p">(</span><span class="o">-</span><span class="n">ENOMEM</span><span class="p">);</span>
				<span class="p">}</span>

				<span class="cm">/*</span>
<span class="cm">				 * Save the user address and point the kernel</span>
<span class="cm">				 * address at just allocated memory</span>
<span class="cm">				 */</span>
				<span class="n">uxferaddr</span> <span class="o">=</span> <span class="n">pthru</span><span class="o">-&gt;</span><span class="n">dataxferaddr</span><span class="p">;</span>
				<span class="n">pthru</span><span class="o">-&gt;</span><span class="n">dataxferaddr</span> <span class="o">=</span> <span class="n">data_dma_hndl</span><span class="p">;</span>
			<span class="p">}</span>


			<span class="cm">/*</span>
<span class="cm">			 * Is data coming down-stream</span>
<span class="cm">			 */</span>
			<span class="k">if</span><span class="p">(</span> <span class="n">pthru</span><span class="o">-&gt;</span><span class="n">dataxferlen</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">uioc</span><span class="p">.</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">UIOC_WR</span><span class="p">)</span> <span class="p">)</span> <span class="p">{</span>
				<span class="cm">/*</span>
<span class="cm">				 * Get the user data</span>
<span class="cm">				 */</span>
				<span class="k">if</span><span class="p">(</span> <span class="n">copy_from_user</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="p">(</span><span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">uxferaddr</span><span class="p">,</span>
							<span class="n">pthru</span><span class="o">-&gt;</span><span class="n">dataxferlen</span><span class="p">)</span> <span class="p">)</span> <span class="p">{</span>
					<span class="n">rval</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="n">EFAULT</span><span class="p">);</span>
					<span class="k">goto</span> <span class="n">freemem_and_return</span><span class="p">;</span>
				<span class="p">}</span>
			<span class="p">}</span>

			<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mc</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">megacmd_t</span><span class="p">));</span>

			<span class="n">mc</span><span class="p">.</span><span class="n">cmd</span> <span class="o">=</span> <span class="n">MEGA_MBOXCMD_PASSTHRU</span><span class="p">;</span>
			<span class="n">mc</span><span class="p">.</span><span class="n">xferaddr</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span><span class="n">pthru_dma_hndl</span><span class="p">;</span>

			<span class="cm">/*</span>
<span class="cm">			 * Issue the command</span>
<span class="cm">			 */</span>
			<span class="n">mega_internal_command</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mc</span><span class="p">,</span> <span class="n">pthru</span><span class="p">);</span>

			<span class="n">rval</span> <span class="o">=</span> <span class="n">mega_n_to_m</span><span class="p">((</span><span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span><span class="n">arg</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mc</span><span class="p">);</span>

			<span class="k">if</span><span class="p">(</span> <span class="n">rval</span> <span class="p">)</span> <span class="k">goto</span> <span class="n">freemem_and_return</span><span class="p">;</span>


			<span class="cm">/*</span>
<span class="cm">			 * Is data going up-stream</span>
<span class="cm">			 */</span>
			<span class="k">if</span><span class="p">(</span> <span class="n">pthru</span><span class="o">-&gt;</span><span class="n">dataxferlen</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">uioc</span><span class="p">.</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">UIOC_RD</span><span class="p">)</span> <span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span><span class="p">(</span> <span class="n">copy_to_user</span><span class="p">((</span><span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">uxferaddr</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span>
							<span class="n">pthru</span><span class="o">-&gt;</span><span class="n">dataxferlen</span><span class="p">)</span> <span class="p">)</span> <span class="p">{</span>
					<span class="n">rval</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="n">EFAULT</span><span class="p">);</span>
				<span class="p">}</span>
			<span class="p">}</span>

			<span class="cm">/*</span>
<span class="cm">			 * Send the request sense data also, irrespective of</span>
<span class="cm">			 * whether the user has asked for it or not.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">copy_to_user</span><span class="p">(</span><span class="n">upthru</span><span class="o">-&gt;</span><span class="n">reqsensearea</span><span class="p">,</span>
					<span class="n">pthru</span><span class="o">-&gt;</span><span class="n">reqsensearea</span><span class="p">,</span> <span class="mi">14</span><span class="p">))</span>
				<span class="n">rval</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

<span class="nl">freemem_and_return:</span>
			<span class="k">if</span><span class="p">(</span> <span class="n">pthru</span><span class="o">-&gt;</span><span class="n">dataxferlen</span> <span class="p">)</span> <span class="p">{</span>
				<span class="n">pci_free_consistent</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span>
						<span class="n">pthru</span><span class="o">-&gt;</span><span class="n">dataxferlen</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span>
						<span class="n">data_dma_hndl</span><span class="p">);</span>
			<span class="p">}</span>

			<span class="n">pci_free_consistent</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">mega_passthru</span><span class="p">),</span>
					<span class="n">pthru</span><span class="p">,</span> <span class="n">pthru_dma_hndl</span><span class="p">);</span>

			<span class="n">free_local_pdev</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>

			<span class="k">return</span> <span class="n">rval</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">else</span> <span class="p">{</span>
			<span class="cm">/* DCMD commands */</span>

			<span class="cm">/*</span>
<span class="cm">			 * Is there a data transfer</span>
<span class="cm">			 */</span>
			<span class="k">if</span><span class="p">(</span> <span class="n">uioc</span><span class="p">.</span><span class="n">xferlen</span> <span class="p">)</span> <span class="p">{</span>
				<span class="n">data</span> <span class="o">=</span> <span class="n">pci_alloc_consistent</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span>
						<span class="n">uioc</span><span class="p">.</span><span class="n">xferlen</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">data_dma_hndl</span><span class="p">);</span>

				<span class="k">if</span><span class="p">(</span> <span class="n">data</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="p">)</span> <span class="p">{</span>
					<span class="n">free_local_pdev</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
					<span class="k">return</span> <span class="p">(</span><span class="o">-</span><span class="n">ENOMEM</span><span class="p">);</span>
				<span class="p">}</span>

				<span class="n">uxferaddr</span> <span class="o">=</span> <span class="n">MBOX</span><span class="p">(</span><span class="n">uioc</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">xferaddr</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="cm">/*</span>
<span class="cm">			 * Is data coming down-stream</span>
<span class="cm">			 */</span>
			<span class="k">if</span><span class="p">(</span> <span class="n">uioc</span><span class="p">.</span><span class="n">xferlen</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">uioc</span><span class="p">.</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">UIOC_WR</span><span class="p">)</span> <span class="p">)</span> <span class="p">{</span>
				<span class="cm">/*</span>
<span class="cm">				 * Get the user data</span>
<span class="cm">				 */</span>
				<span class="k">if</span><span class="p">(</span> <span class="n">copy_from_user</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="p">(</span><span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">uxferaddr</span><span class="p">,</span>
							<span class="n">uioc</span><span class="p">.</span><span class="n">xferlen</span><span class="p">)</span> <span class="p">)</span> <span class="p">{</span>

					<span class="n">pci_free_consistent</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span>
							<span class="n">uioc</span><span class="p">.</span><span class="n">xferlen</span><span class="p">,</span>
							<span class="n">data</span><span class="p">,</span> <span class="n">data_dma_hndl</span><span class="p">);</span>

					<span class="n">free_local_pdev</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>

					<span class="k">return</span> <span class="p">(</span><span class="o">-</span><span class="n">EFAULT</span><span class="p">);</span>
				<span class="p">}</span>
			<span class="p">}</span>

			<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mc</span><span class="p">,</span> <span class="n">MBOX</span><span class="p">(</span><span class="n">uioc</span><span class="p">),</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">megacmd_t</span><span class="p">));</span>

			<span class="n">mc</span><span class="p">.</span><span class="n">xferaddr</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span><span class="n">data_dma_hndl</span><span class="p">;</span>

			<span class="cm">/*</span>
<span class="cm">			 * Issue the command</span>
<span class="cm">			 */</span>
			<span class="n">mega_internal_command</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mc</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

			<span class="n">rval</span> <span class="o">=</span> <span class="n">mega_n_to_m</span><span class="p">((</span><span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span><span class="n">arg</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mc</span><span class="p">);</span>

			<span class="k">if</span><span class="p">(</span> <span class="n">rval</span> <span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span><span class="p">(</span> <span class="n">uioc</span><span class="p">.</span><span class="n">xferlen</span> <span class="p">)</span> <span class="p">{</span>
					<span class="n">pci_free_consistent</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span>
							<span class="n">uioc</span><span class="p">.</span><span class="n">xferlen</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span>
							<span class="n">data_dma_hndl</span><span class="p">);</span>
				<span class="p">}</span>

				<span class="n">free_local_pdev</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>

				<span class="k">return</span> <span class="n">rval</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="cm">/*</span>
<span class="cm">			 * Is data going up-stream</span>
<span class="cm">			 */</span>
			<span class="k">if</span><span class="p">(</span> <span class="n">uioc</span><span class="p">.</span><span class="n">xferlen</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">uioc</span><span class="p">.</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">UIOC_RD</span><span class="p">)</span> <span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span><span class="p">(</span> <span class="n">copy_to_user</span><span class="p">((</span><span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">uxferaddr</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span>
							<span class="n">uioc</span><span class="p">.</span><span class="n">xferlen</span><span class="p">)</span> <span class="p">)</span> <span class="p">{</span>

					<span class="n">rval</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="n">EFAULT</span><span class="p">);</span>
				<span class="p">}</span>
			<span class="p">}</span>

			<span class="k">if</span><span class="p">(</span> <span class="n">uioc</span><span class="p">.</span><span class="n">xferlen</span> <span class="p">)</span> <span class="p">{</span>
				<span class="n">pci_free_consistent</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span>
						<span class="n">uioc</span><span class="p">.</span><span class="n">xferlen</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span>
						<span class="n">data_dma_hndl</span><span class="p">);</span>
			<span class="p">}</span>

			<span class="n">free_local_pdev</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>

			<span class="k">return</span> <span class="n">rval</span><span class="p">;</span>
		<span class="p">}</span>

	<span class="nl">default:</span>
		<span class="k">return</span> <span class="p">(</span><span class="o">-</span><span class="n">EINVAL</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">long</span>
<span class="nf">megadev_unlocked_ioctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filep</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">megadev_mutex</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">megadev_ioctl</span><span class="p">(</span><span class="n">filep</span><span class="p">,</span> <span class="n">cmd</span><span class="p">,</span> <span class="n">arg</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">megadev_mutex</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * mega_m_to_n()</span>
<span class="cm"> * @arg - user address</span>
<span class="cm"> * @uioc - new ioctl structure</span>
<span class="cm"> *</span>
<span class="cm"> * A thin layer to convert older mimd interface ioctl structure to NIT ioctl</span>
<span class="cm"> * structure</span>
<span class="cm"> *</span>
<span class="cm"> * Converts the older mimd ioctl structure to newer NIT structure</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">mega_m_to_n</span><span class="p">(</span><span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="n">arg</span><span class="p">,</span> <span class="n">nitioctl_t</span> <span class="o">*</span><span class="n">uioc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">uioctl_t</span>	<span class="n">uioc_mimd</span><span class="p">;</span>
	<span class="kt">char</span>	<span class="n">signature</span><span class="p">[</span><span class="mi">8</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span>
	<span class="n">u8</span>	<span class="n">opcode</span><span class="p">;</span>
	<span class="n">u8</span>	<span class="n">subopcode</span><span class="p">;</span>


	<span class="cm">/*</span>
<span class="cm">	 * check is the application conforms to NIT. We do not have to do much</span>
<span class="cm">	 * in that case.</span>
<span class="cm">	 * We exploit the fact that the signature is stored in the very</span>
<span class="cm">	 * beginning of the structure.</span>
<span class="cm">	 */</span>

	<span class="k">if</span><span class="p">(</span> <span class="n">copy_from_user</span><span class="p">(</span><span class="n">signature</span><span class="p">,</span> <span class="n">arg</span><span class="p">,</span> <span class="mi">7</span><span class="p">)</span> <span class="p">)</span>
		<span class="k">return</span> <span class="p">(</span><span class="o">-</span><span class="n">EFAULT</span><span class="p">);</span>

	<span class="k">if</span><span class="p">(</span> <span class="n">memcmp</span><span class="p">(</span><span class="n">signature</span><span class="p">,</span> <span class="s">&quot;MEGANIT&quot;</span><span class="p">,</span> <span class="mi">7</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">)</span> <span class="p">{</span>

		<span class="cm">/*</span>
<span class="cm">		 * NOTE NOTE: The nit ioctl is still under flux because of</span>
<span class="cm">		 * change of mailbox definition, in HPE. No applications yet</span>
<span class="cm">		 * use this interface and let&#39;s not have applications use this</span>
<span class="cm">		 * interface till the new specifitions are in place.</span>
<span class="cm">		 */</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
<span class="cp">#if 0</span><span class="c"></span>
<span class="c">		if( copy_from_user(uioc, arg, sizeof(nitioctl_t)) )</span>
<span class="c">			return (-EFAULT);</span>
<span class="c">		return 0;</span>
<span class="cp">#endif</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Else assume we have mimd uioctl_t as arg. Convert to nitioctl_t</span>
<span class="cm">	 *</span>
<span class="cm">	 * Get the user ioctl structure</span>
<span class="cm">	 */</span>
	<span class="k">if</span><span class="p">(</span> <span class="n">copy_from_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">uioc_mimd</span><span class="p">,</span> <span class="n">arg</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">uioctl_t</span><span class="p">))</span> <span class="p">)</span>
		<span class="k">return</span> <span class="p">(</span><span class="o">-</span><span class="n">EFAULT</span><span class="p">);</span>


	<span class="cm">/*</span>
<span class="cm">	 * Get the opcode and subopcode for the commands</span>
<span class="cm">	 */</span>
	<span class="n">opcode</span> <span class="o">=</span> <span class="n">uioc_mimd</span><span class="p">.</span><span class="n">ui</span><span class="p">.</span><span class="n">fcs</span><span class="p">.</span><span class="n">opcode</span><span class="p">;</span>
	<span class="n">subopcode</span> <span class="o">=</span> <span class="n">uioc_mimd</span><span class="p">.</span><span class="n">ui</span><span class="p">.</span><span class="n">fcs</span><span class="p">.</span><span class="n">subopcode</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">opcode</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="mh">0x82</span>:

		<span class="k">switch</span> <span class="p">(</span><span class="n">subopcode</span><span class="p">)</span> <span class="p">{</span>

		<span class="k">case</span> <span class="n">MEGAIOC_QDRVRVER</span>:	<span class="cm">/* Query driver version */</span>
			<span class="n">uioc</span><span class="o">-&gt;</span><span class="n">opcode</span> <span class="o">=</span> <span class="n">GET_DRIVER_VER</span><span class="p">;</span>
			<span class="n">uioc</span><span class="o">-&gt;</span><span class="n">uioc_uaddr</span> <span class="o">=</span> <span class="n">uioc_mimd</span><span class="p">.</span><span class="n">data</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">MEGAIOC_QNADAP</span>:	<span class="cm">/* Get # of adapters */</span>
			<span class="n">uioc</span><span class="o">-&gt;</span><span class="n">opcode</span> <span class="o">=</span> <span class="n">GET_N_ADAP</span><span class="p">;</span>
			<span class="n">uioc</span><span class="o">-&gt;</span><span class="n">uioc_uaddr</span> <span class="o">=</span> <span class="n">uioc_mimd</span><span class="p">.</span><span class="n">data</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">MEGAIOC_QADAPINFO</span>:	<span class="cm">/* Get adapter information */</span>
			<span class="n">uioc</span><span class="o">-&gt;</span><span class="n">opcode</span> <span class="o">=</span> <span class="n">GET_ADAP_INFO</span><span class="p">;</span>
			<span class="n">uioc</span><span class="o">-&gt;</span><span class="n">adapno</span> <span class="o">=</span> <span class="n">uioc_mimd</span><span class="p">.</span><span class="n">ui</span><span class="p">.</span><span class="n">fcs</span><span class="p">.</span><span class="n">adapno</span><span class="p">;</span>
			<span class="n">uioc</span><span class="o">-&gt;</span><span class="n">uioc_uaddr</span> <span class="o">=</span> <span class="n">uioc_mimd</span><span class="p">.</span><span class="n">data</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="nl">default:</span>
			<span class="k">return</span><span class="p">(</span><span class="o">-</span><span class="n">EINVAL</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="k">break</span><span class="p">;</span>


	<span class="k">case</span> <span class="mh">0x81</span>:

		<span class="n">uioc</span><span class="o">-&gt;</span><span class="n">opcode</span> <span class="o">=</span> <span class="n">MBOX_CMD</span><span class="p">;</span>
		<span class="n">uioc</span><span class="o">-&gt;</span><span class="n">adapno</span> <span class="o">=</span> <span class="n">uioc_mimd</span><span class="p">.</span><span class="n">ui</span><span class="p">.</span><span class="n">fcs</span><span class="p">.</span><span class="n">adapno</span><span class="p">;</span>

		<span class="n">memcpy</span><span class="p">(</span><span class="n">uioc</span><span class="o">-&gt;</span><span class="n">uioc_rmbox</span><span class="p">,</span> <span class="n">uioc_mimd</span><span class="p">.</span><span class="n">mbox</span><span class="p">,</span> <span class="mi">18</span><span class="p">);</span>

		<span class="n">uioc</span><span class="o">-&gt;</span><span class="n">xferlen</span> <span class="o">=</span> <span class="n">uioc_mimd</span><span class="p">.</span><span class="n">ui</span><span class="p">.</span><span class="n">fcs</span><span class="p">.</span><span class="n">length</span><span class="p">;</span>

		<span class="k">if</span><span class="p">(</span> <span class="n">uioc_mimd</span><span class="p">.</span><span class="n">outlen</span> <span class="p">)</span> <span class="n">uioc</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">=</span> <span class="n">UIOC_RD</span><span class="p">;</span>
		<span class="k">if</span><span class="p">(</span> <span class="n">uioc_mimd</span><span class="p">.</span><span class="n">inlen</span> <span class="p">)</span> <span class="n">uioc</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">UIOC_WR</span><span class="p">;</span>

		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="mh">0x80</span>:

		<span class="n">uioc</span><span class="o">-&gt;</span><span class="n">opcode</span> <span class="o">=</span> <span class="n">MBOX_CMD</span><span class="p">;</span>
		<span class="n">uioc</span><span class="o">-&gt;</span><span class="n">adapno</span> <span class="o">=</span> <span class="n">uioc_mimd</span><span class="p">.</span><span class="n">ui</span><span class="p">.</span><span class="n">fcs</span><span class="p">.</span><span class="n">adapno</span><span class="p">;</span>

		<span class="n">memcpy</span><span class="p">(</span><span class="n">uioc</span><span class="o">-&gt;</span><span class="n">uioc_rmbox</span><span class="p">,</span> <span class="n">uioc_mimd</span><span class="p">.</span><span class="n">mbox</span><span class="p">,</span> <span class="mi">18</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * Choose the xferlen bigger of input and output data</span>
<span class="cm">		 */</span>
		<span class="n">uioc</span><span class="o">-&gt;</span><span class="n">xferlen</span> <span class="o">=</span> <span class="n">uioc_mimd</span><span class="p">.</span><span class="n">outlen</span> <span class="o">&gt;</span> <span class="n">uioc_mimd</span><span class="p">.</span><span class="n">inlen</span> <span class="o">?</span>
			<span class="n">uioc_mimd</span><span class="p">.</span><span class="n">outlen</span> <span class="o">:</span> <span class="n">uioc_mimd</span><span class="p">.</span><span class="n">inlen</span><span class="p">;</span>

		<span class="k">if</span><span class="p">(</span> <span class="n">uioc_mimd</span><span class="p">.</span><span class="n">outlen</span> <span class="p">)</span> <span class="n">uioc</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">=</span> <span class="n">UIOC_RD</span><span class="p">;</span>
		<span class="k">if</span><span class="p">(</span> <span class="n">uioc_mimd</span><span class="p">.</span><span class="n">inlen</span> <span class="p">)</span> <span class="n">uioc</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">UIOC_WR</span><span class="p">;</span>

		<span class="k">break</span><span class="p">;</span>

	<span class="nl">default:</span>
		<span class="k">return</span> <span class="p">(</span><span class="o">-</span><span class="n">EINVAL</span><span class="p">);</span>

	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * mega_n_to_m()</span>
<span class="cm"> * @arg - user address</span>
<span class="cm"> * @mc - mailbox command</span>
<span class="cm"> *</span>
<span class="cm"> * Updates the status information to the application, depending on application</span>
<span class="cm"> * conforms to older mimd ioctl interface or newer NIT ioctl interface</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">mega_n_to_m</span><span class="p">(</span><span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="n">arg</span><span class="p">,</span> <span class="n">megacmd_t</span> <span class="o">*</span><span class="n">mc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">nitioctl_t</span>	<span class="n">__user</span> <span class="o">*</span><span class="n">uiocp</span><span class="p">;</span>
	<span class="n">megacmd_t</span>	<span class="n">__user</span> <span class="o">*</span><span class="n">umc</span><span class="p">;</span>
	<span class="n">mega_passthru</span>	<span class="n">__user</span> <span class="o">*</span><span class="n">upthru</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">uioctl_t</span>	<span class="n">__user</span> <span class="o">*</span><span class="n">uioc_mimd</span><span class="p">;</span>
	<span class="kt">char</span>	<span class="n">signature</span><span class="p">[</span><span class="mi">8</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span>

	<span class="cm">/*</span>
<span class="cm">	 * check is the application conforms to NIT.</span>
<span class="cm">	 */</span>
	<span class="k">if</span><span class="p">(</span> <span class="n">copy_from_user</span><span class="p">(</span><span class="n">signature</span><span class="p">,</span> <span class="n">arg</span><span class="p">,</span> <span class="mi">7</span><span class="p">)</span> <span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

	<span class="k">if</span><span class="p">(</span> <span class="n">memcmp</span><span class="p">(</span><span class="n">signature</span><span class="p">,</span> <span class="s">&quot;MEGANIT&quot;</span><span class="p">,</span> <span class="mi">7</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">)</span> <span class="p">{</span>

		<span class="n">uiocp</span> <span class="o">=</span> <span class="n">arg</span><span class="p">;</span>

		<span class="k">if</span><span class="p">(</span> <span class="n">put_user</span><span class="p">(</span><span class="n">mc</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">,</span> <span class="p">(</span><span class="n">u8</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">MBOX_P</span><span class="p">(</span><span class="n">uiocp</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">)</span> <span class="p">)</span>
			<span class="k">return</span> <span class="p">(</span><span class="o">-</span><span class="n">EFAULT</span><span class="p">);</span>

		<span class="k">if</span><span class="p">(</span> <span class="n">mc</span><span class="o">-&gt;</span><span class="n">cmd</span> <span class="o">==</span> <span class="n">MEGA_MBOXCMD_PASSTHRU</span> <span class="p">)</span> <span class="p">{</span>

			<span class="n">umc</span> <span class="o">=</span> <span class="n">MBOX_P</span><span class="p">(</span><span class="n">uiocp</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">get_user</span><span class="p">(</span><span class="n">upthru</span><span class="p">,</span> <span class="p">(</span><span class="n">mega_passthru</span> <span class="n">__user</span> <span class="o">*</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">umc</span><span class="o">-&gt;</span><span class="n">xferaddr</span><span class="p">))</span>
				<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

			<span class="k">if</span><span class="p">(</span> <span class="n">put_user</span><span class="p">(</span><span class="n">mc</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">,</span> <span class="p">(</span><span class="n">u8</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">upthru</span><span class="o">-&gt;</span><span class="n">scsistatus</span><span class="p">))</span>
				<span class="k">return</span> <span class="p">(</span><span class="o">-</span><span class="n">EFAULT</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="n">uioc_mimd</span> <span class="o">=</span> <span class="n">arg</span><span class="p">;</span>

		<span class="k">if</span><span class="p">(</span> <span class="n">put_user</span><span class="p">(</span><span class="n">mc</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">,</span> <span class="p">(</span><span class="n">u8</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">uioc_mimd</span><span class="o">-&gt;</span><span class="n">mbox</span><span class="p">[</span><span class="mi">17</span><span class="p">])</span> <span class="p">)</span>
			<span class="k">return</span> <span class="p">(</span><span class="o">-</span><span class="n">EFAULT</span><span class="p">);</span>

		<span class="k">if</span><span class="p">(</span> <span class="n">mc</span><span class="o">-&gt;</span><span class="n">cmd</span> <span class="o">==</span> <span class="n">MEGA_MBOXCMD_PASSTHRU</span> <span class="p">)</span> <span class="p">{</span>

			<span class="n">umc</span> <span class="o">=</span> <span class="p">(</span><span class="n">megacmd_t</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span><span class="n">uioc_mimd</span><span class="o">-&gt;</span><span class="n">mbox</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">get_user</span><span class="p">(</span><span class="n">upthru</span><span class="p">,</span> <span class="p">(</span><span class="n">mega_passthru</span> <span class="n">__user</span> <span class="o">*</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">umc</span><span class="o">-&gt;</span><span class="n">xferaddr</span><span class="p">))</span>
				<span class="k">return</span> <span class="p">(</span><span class="o">-</span><span class="n">EFAULT</span><span class="p">);</span>

			<span class="k">if</span><span class="p">(</span> <span class="n">put_user</span><span class="p">(</span><span class="n">mc</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">,</span> <span class="p">(</span><span class="n">u8</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">upthru</span><span class="o">-&gt;</span><span class="n">scsistatus</span><span class="p">)</span> <span class="p">)</span>
				<span class="k">return</span> <span class="p">(</span><span class="o">-</span><span class="n">EFAULT</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * MEGARAID &#39;FW&#39; commands.</span>
<span class="cm"> */</span>

<span class="cm">/**</span>
<span class="cm"> * mega_is_bios_enabled()</span>
<span class="cm"> * @adapter - pointer to our soft state</span>
<span class="cm"> *</span>
<span class="cm"> * issue command to find out if the BIOS is enabled for this controller</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">mega_is_bios_enabled</span><span class="p">(</span><span class="n">adapter_t</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">char</span>	<span class="n">raw_mbox</span><span class="p">[</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">mbox_out</span><span class="p">)];</span>
	<span class="n">mbox_t</span>	<span class="o">*</span><span class="n">mbox</span><span class="p">;</span>
	<span class="kt">int</span>	<span class="n">ret</span><span class="p">;</span>

	<span class="n">mbox</span> <span class="o">=</span> <span class="p">(</span><span class="n">mbox_t</span> <span class="o">*</span><span class="p">)</span><span class="n">raw_mbox</span><span class="p">;</span>

	<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mbox</span><span class="o">-&gt;</span><span class="n">m_out</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">raw_mbox</span><span class="p">));</span>

	<span class="n">memset</span><span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">mega_buffer</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">MEGA_BUFFER_SIZE</span><span class="p">);</span>

	<span class="n">mbox</span><span class="o">-&gt;</span><span class="n">m_out</span><span class="p">.</span><span class="n">xferaddr</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">buf_dma_handle</span><span class="p">;</span>

	<span class="n">raw_mbox</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">IS_BIOS_ENABLED</span><span class="p">;</span>
	<span class="n">raw_mbox</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">GET_BIOS</span><span class="p">;</span>


	<span class="n">ret</span> <span class="o">=</span> <span class="n">issue_scb_block</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">raw_mbox</span><span class="p">);</span>

	<span class="k">return</span> <span class="o">*</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">mega_buffer</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/**</span>
<span class="cm"> * mega_enum_raid_scsi()</span>
<span class="cm"> * @adapter - pointer to our soft state</span>
<span class="cm"> *</span>
<span class="cm"> * Find out what channels are RAID/SCSI. This information is used to</span>
<span class="cm"> * differentiate the virtual channels and physical channels and to support</span>
<span class="cm"> * ROMB feature and non-disk devices.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">mega_enum_raid_scsi</span><span class="p">(</span><span class="n">adapter_t</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">raw_mbox</span><span class="p">[</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">mbox_out</span><span class="p">)];</span>
	<span class="n">mbox_t</span> <span class="o">*</span><span class="n">mbox</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">mbox</span> <span class="o">=</span> <span class="p">(</span><span class="n">mbox_t</span> <span class="o">*</span><span class="p">)</span><span class="n">raw_mbox</span><span class="p">;</span>

	<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mbox</span><span class="o">-&gt;</span><span class="n">m_out</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">raw_mbox</span><span class="p">));</span>

	<span class="cm">/*</span>
<span class="cm">	 * issue command to find out what channels are raid/scsi</span>
<span class="cm">	 */</span>
	<span class="n">raw_mbox</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">CHNL_CLASS</span><span class="p">;</span>
	<span class="n">raw_mbox</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">GET_CHNL_CLASS</span><span class="p">;</span>

	<span class="n">memset</span><span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">mega_buffer</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">MEGA_BUFFER_SIZE</span><span class="p">);</span>

	<span class="n">mbox</span><span class="o">-&gt;</span><span class="n">m_out</span><span class="p">.</span><span class="n">xferaddr</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">buf_dma_handle</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Non-ROMB firmware fail this command, so all channels</span>
<span class="cm">	 * must be shown RAID</span>
<span class="cm">	 */</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">mega_ch_class</span> <span class="o">=</span> <span class="mh">0xFF</span><span class="p">;</span>

	<span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">issue_scb_block</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">raw_mbox</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">mega_ch_class</span> <span class="o">=</span> <span class="o">*</span><span class="p">((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">mega_buffer</span><span class="p">);</span>

	<span class="p">}</span>

	<span class="k">for</span><span class="p">(</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">product_info</span><span class="p">.</span><span class="n">nchannels</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span> <span class="p">)</span> <span class="p">{</span> 
		<span class="k">if</span><span class="p">(</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">mega_ch_class</span> <span class="o">&gt;&gt;</span> <span class="n">i</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x01</span> <span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;megaraid: channel[%d] is raid.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">i</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">else</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;megaraid: channel[%d] is scsi.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">i</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/**</span>
<span class="cm"> * mega_get_boot_drv()</span>
<span class="cm"> * @adapter - pointer to our soft state</span>
<span class="cm"> *</span>
<span class="cm"> * Find out which device is the boot device. Note, any logical drive or any</span>
<span class="cm"> * phyical device (e.g., a CDROM) can be designated as a boot device.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">mega_get_boot_drv</span><span class="p">(</span><span class="n">adapter_t</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">private_bios_data</span>	<span class="o">*</span><span class="n">prv_bios_data</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span>	<span class="n">raw_mbox</span><span class="p">[</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">mbox_out</span><span class="p">)];</span>
	<span class="n">mbox_t</span>	<span class="o">*</span><span class="n">mbox</span><span class="p">;</span>
	<span class="n">u16</span>	<span class="n">cksum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u8</span>	<span class="o">*</span><span class="n">cksum_p</span><span class="p">;</span>
	<span class="n">u8</span>	<span class="n">boot_pdrv</span><span class="p">;</span>
	<span class="kt">int</span>	<span class="n">i</span><span class="p">;</span>

	<span class="n">mbox</span> <span class="o">=</span> <span class="p">(</span><span class="n">mbox_t</span> <span class="o">*</span><span class="p">)</span><span class="n">raw_mbox</span><span class="p">;</span>

	<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mbox</span><span class="o">-&gt;</span><span class="n">m_out</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">raw_mbox</span><span class="p">));</span>

	<span class="n">raw_mbox</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">BIOS_PVT_DATA</span><span class="p">;</span>
	<span class="n">raw_mbox</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">GET_BIOS_PVT_DATA</span><span class="p">;</span>

	<span class="n">memset</span><span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">mega_buffer</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">MEGA_BUFFER_SIZE</span><span class="p">);</span>

	<span class="n">mbox</span><span class="o">-&gt;</span><span class="n">m_out</span><span class="p">.</span><span class="n">xferaddr</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">buf_dma_handle</span><span class="p">;</span>

	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">boot_ldrv_enabled</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">boot_ldrv</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">boot_pdrv_enabled</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">boot_pdrv_ch</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">boot_pdrv_tgt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span><span class="p">(</span><span class="n">issue_scb_block</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">raw_mbox</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">prv_bios_data</span> <span class="o">=</span>
			<span class="p">(</span><span class="k">struct</span> <span class="n">private_bios_data</span> <span class="o">*</span><span class="p">)</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">mega_buffer</span><span class="p">;</span>

		<span class="n">cksum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">cksum_p</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">prv_bios_data</span><span class="p">;</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">14</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span> <span class="p">)</span> <span class="p">{</span>
			<span class="n">cksum</span> <span class="o">+=</span> <span class="p">(</span><span class="n">u16</span><span class="p">)(</span><span class="o">*</span><span class="n">cksum_p</span><span class="o">++</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">prv_bios_data</span><span class="o">-&gt;</span><span class="n">cksum</span> <span class="o">==</span> <span class="p">(</span><span class="n">u16</span><span class="p">)(</span><span class="mi">0</span><span class="o">-</span><span class="n">cksum</span><span class="p">)</span> <span class="p">)</span> <span class="p">{</span>

			<span class="cm">/*</span>
<span class="cm">			 * If MSB is set, a physical drive is set as boot</span>
<span class="cm">			 * device</span>
<span class="cm">			 */</span>
			<span class="k">if</span><span class="p">(</span> <span class="n">prv_bios_data</span><span class="o">-&gt;</span><span class="n">boot_drv</span> <span class="o">&amp;</span> <span class="mh">0x80</span> <span class="p">)</span> <span class="p">{</span>
				<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">boot_pdrv_enabled</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
				<span class="n">boot_pdrv</span> <span class="o">=</span> <span class="n">prv_bios_data</span><span class="o">-&gt;</span><span class="n">boot_drv</span> <span class="o">&amp;</span> <span class="mh">0x7F</span><span class="p">;</span>
				<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">boot_pdrv_ch</span> <span class="o">=</span> <span class="n">boot_pdrv</span> <span class="o">/</span> <span class="mi">16</span><span class="p">;</span>
				<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">boot_pdrv_tgt</span> <span class="o">=</span> <span class="n">boot_pdrv</span> <span class="o">%</span> <span class="mi">16</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">else</span> <span class="p">{</span>
				<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">boot_ldrv_enabled</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
				<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">boot_ldrv</span> <span class="o">=</span> <span class="n">prv_bios_data</span><span class="o">-&gt;</span><span class="n">boot_drv</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * mega_support_random_del()</span>
<span class="cm"> * @adapter - pointer to our soft state</span>
<span class="cm"> *</span>
<span class="cm"> * Find out if this controller supports random deletion and addition of</span>
<span class="cm"> * logical drives</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">mega_support_random_del</span><span class="p">(</span><span class="n">adapter_t</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">raw_mbox</span><span class="p">[</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">mbox_out</span><span class="p">)];</span>
	<span class="n">mbox_t</span> <span class="o">*</span><span class="n">mbox</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rval</span><span class="p">;</span>

	<span class="n">mbox</span> <span class="o">=</span> <span class="p">(</span><span class="n">mbox_t</span> <span class="o">*</span><span class="p">)</span><span class="n">raw_mbox</span><span class="p">;</span>

	<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mbox</span><span class="o">-&gt;</span><span class="n">m_out</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">raw_mbox</span><span class="p">));</span>

	<span class="cm">/*</span>
<span class="cm">	 * issue command</span>
<span class="cm">	 */</span>
	<span class="n">raw_mbox</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">FC_DEL_LOGDRV</span><span class="p">;</span>
	<span class="n">raw_mbox</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">OP_SUP_DEL_LOGDRV</span><span class="p">;</span>

	<span class="n">rval</span> <span class="o">=</span> <span class="n">issue_scb_block</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">raw_mbox</span><span class="p">);</span>

	<span class="k">return</span> <span class="o">!</span><span class="n">rval</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/**</span>
<span class="cm"> * mega_support_ext_cdb()</span>
<span class="cm"> * @adapter - pointer to our soft state</span>
<span class="cm"> *</span>
<span class="cm"> * Find out if this firmware support cdblen &gt; 10</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">mega_support_ext_cdb</span><span class="p">(</span><span class="n">adapter_t</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">raw_mbox</span><span class="p">[</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">mbox_out</span><span class="p">)];</span>
	<span class="n">mbox_t</span> <span class="o">*</span><span class="n">mbox</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rval</span><span class="p">;</span>

	<span class="n">mbox</span> <span class="o">=</span> <span class="p">(</span><span class="n">mbox_t</span> <span class="o">*</span><span class="p">)</span><span class="n">raw_mbox</span><span class="p">;</span>

	<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mbox</span><span class="o">-&gt;</span><span class="n">m_out</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">raw_mbox</span><span class="p">));</span>
	<span class="cm">/*</span>
<span class="cm">	 * issue command to find out if controller supports extended CDBs.</span>
<span class="cm">	 */</span>
	<span class="n">raw_mbox</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0xA4</span><span class="p">;</span>
	<span class="n">raw_mbox</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x16</span><span class="p">;</span>

	<span class="n">rval</span> <span class="o">=</span> <span class="n">issue_scb_block</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">raw_mbox</span><span class="p">);</span>

	<span class="k">return</span> <span class="o">!</span><span class="n">rval</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/**</span>
<span class="cm"> * mega_del_logdrv()</span>
<span class="cm"> * @adapter - pointer to our soft state</span>
<span class="cm"> * @logdrv - logical drive to be deleted</span>
<span class="cm"> *</span>
<span class="cm"> * Delete the specified logical drive. It is the responsibility of the user</span>
<span class="cm"> * app to let the OS know about this operation.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">mega_del_logdrv</span><span class="p">(</span><span class="n">adapter_t</span> <span class="o">*</span><span class="n">adapter</span><span class="p">,</span> <span class="kt">int</span> <span class="n">logdrv</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="n">scb_t</span> <span class="o">*</span><span class="n">scb</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rval</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Stop sending commands to the controller, queue them internally.</span>
<span class="cm">	 * When deletion is complete, ISR will flush the queue.</span>
<span class="cm">	 */</span>
	<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">quiescent</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Wait till all the issued commands are complete and there are no</span>
<span class="cm">	 * commands in the pending queue</span>
<span class="cm">	 */</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pend_cmds</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">||</span>
	       <span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pending_list</span><span class="p">))</span>
		<span class="n">msleep</span><span class="p">(</span><span class="mi">1000</span><span class="p">);</span>	<span class="cm">/* sleep for 1s */</span>

	<span class="n">rval</span> <span class="o">=</span> <span class="n">mega_do_del_logdrv</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">logdrv</span><span class="p">);</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * If delete operation was successful, add 0x80 to the logical drive</span>
<span class="cm">	 * ids for commands in the pending queue.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">read_ldidmap</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">pos</span><span class="p">;</span>
		<span class="n">list_for_each</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pending_list</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">scb</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="n">scb_t</span><span class="p">,</span> <span class="n">list</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">scb</span><span class="o">-&gt;</span><span class="n">pthru</span><span class="o">-&gt;</span><span class="n">logdrv</span> <span class="o">&lt;</span> <span class="mh">0x80</span> <span class="p">)</span>
				<span class="n">scb</span><span class="o">-&gt;</span><span class="n">pthru</span><span class="o">-&gt;</span><span class="n">logdrv</span> <span class="o">+=</span> <span class="mh">0x80</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">quiescent</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="n">mega_runpendq</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>

	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">rval</span><span class="p">;</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">int</span>
<span class="nf">mega_do_del_logdrv</span><span class="p">(</span><span class="n">adapter_t</span> <span class="o">*</span><span class="n">adapter</span><span class="p">,</span> <span class="kt">int</span> <span class="n">logdrv</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">megacmd_t</span>	<span class="n">mc</span><span class="p">;</span>
	<span class="kt">int</span>	<span class="n">rval</span><span class="p">;</span>

	<span class="n">memset</span><span class="p">(</span> <span class="o">&amp;</span><span class="n">mc</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">megacmd_t</span><span class="p">));</span>

	<span class="n">mc</span><span class="p">.</span><span class="n">cmd</span> <span class="o">=</span> <span class="n">FC_DEL_LOGDRV</span><span class="p">;</span>
	<span class="n">mc</span><span class="p">.</span><span class="n">opcode</span> <span class="o">=</span> <span class="n">OP_DEL_LOGDRV</span><span class="p">;</span>
	<span class="n">mc</span><span class="p">.</span><span class="n">subopcode</span> <span class="o">=</span> <span class="n">logdrv</span><span class="p">;</span>

	<span class="n">rval</span> <span class="o">=</span> <span class="n">mega_internal_command</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mc</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

	<span class="cm">/* log this event */</span>
	<span class="k">if</span><span class="p">(</span><span class="n">rval</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;megaraid: Delete LD-%d failed.&quot;</span><span class="p">,</span> <span class="n">logdrv</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">rval</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * After deleting first logical drive, the logical drives must be</span>
<span class="cm">	 * addressed by adding 0x80 to the logical drive id.</span>
<span class="cm">	 */</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">read_ldidmap</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">rval</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/**</span>
<span class="cm"> * mega_get_max_sgl()</span>
<span class="cm"> * @adapter - pointer to our soft state</span>
<span class="cm"> *</span>
<span class="cm"> * Find out the maximum number of scatter-gather elements supported by this</span>
<span class="cm"> * version of the firmware</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">mega_get_max_sgl</span><span class="p">(</span><span class="n">adapter_t</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">char</span>	<span class="n">raw_mbox</span><span class="p">[</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">mbox_out</span><span class="p">)];</span>
	<span class="n">mbox_t</span>	<span class="o">*</span><span class="n">mbox</span><span class="p">;</span>

	<span class="n">mbox</span> <span class="o">=</span> <span class="p">(</span><span class="n">mbox_t</span> <span class="o">*</span><span class="p">)</span><span class="n">raw_mbox</span><span class="p">;</span>

	<span class="n">memset</span><span class="p">(</span><span class="n">mbox</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">raw_mbox</span><span class="p">));</span>

	<span class="n">memset</span><span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">mega_buffer</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">MEGA_BUFFER_SIZE</span><span class="p">);</span>

	<span class="n">mbox</span><span class="o">-&gt;</span><span class="n">m_out</span><span class="p">.</span><span class="n">xferaddr</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">buf_dma_handle</span><span class="p">;</span>

	<span class="n">raw_mbox</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">MAIN_MISC_OPCODE</span><span class="p">;</span>
	<span class="n">raw_mbox</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">GET_MAX_SG_SUPPORT</span><span class="p">;</span>


	<span class="k">if</span><span class="p">(</span> <span class="n">issue_scb_block</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">raw_mbox</span><span class="p">)</span> <span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * f/w does not support this command. Choose the default value</span>
<span class="cm">		 */</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">sglen</span> <span class="o">=</span> <span class="n">MIN_SGLIST</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">sglen</span> <span class="o">=</span> <span class="o">*</span><span class="p">((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">mega_buffer</span><span class="p">);</span>
		
		<span class="cm">/*</span>
<span class="cm">		 * Make sure this is not more than the resources we are</span>
<span class="cm">		 * planning to allocate</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">sglen</span> <span class="o">&gt;</span> <span class="n">MAX_SGLIST</span> <span class="p">)</span>
			<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">sglen</span> <span class="o">=</span> <span class="n">MAX_SGLIST</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/**</span>
<span class="cm"> * mega_support_cluster()</span>
<span class="cm"> * @adapter - pointer to our soft state</span>
<span class="cm"> *</span>
<span class="cm"> * Find out if this firmware support cluster calls.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">mega_support_cluster</span><span class="p">(</span><span class="n">adapter_t</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">char</span>	<span class="n">raw_mbox</span><span class="p">[</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">mbox_out</span><span class="p">)];</span>
	<span class="n">mbox_t</span>	<span class="o">*</span><span class="n">mbox</span><span class="p">;</span>

	<span class="n">mbox</span> <span class="o">=</span> <span class="p">(</span><span class="n">mbox_t</span> <span class="o">*</span><span class="p">)</span><span class="n">raw_mbox</span><span class="p">;</span>

	<span class="n">memset</span><span class="p">(</span><span class="n">mbox</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">raw_mbox</span><span class="p">));</span>

	<span class="n">memset</span><span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">mega_buffer</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">MEGA_BUFFER_SIZE</span><span class="p">);</span>

	<span class="n">mbox</span><span class="o">-&gt;</span><span class="n">m_out</span><span class="p">.</span><span class="n">xferaddr</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">buf_dma_handle</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Try to get the initiator id. This command will succeed iff the</span>
<span class="cm">	 * clustering is available on this HBA.</span>
<span class="cm">	 */</span>
	<span class="n">raw_mbox</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">MEGA_GET_TARGET_ID</span><span class="p">;</span>

	<span class="k">if</span><span class="p">(</span> <span class="n">issue_scb_block</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">raw_mbox</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">)</span> <span class="p">{</span>

		<span class="cm">/*</span>
<span class="cm">		 * Cluster support available. Get the initiator target id.</span>
<span class="cm">		 * Tell our id to mid-layer too.</span>
<span class="cm">		 */</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">this_id</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="n">u32</span> <span class="o">*</span><span class="p">)</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">mega_buffer</span><span class="p">;</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">this_id</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">this_id</span><span class="p">;</span>

		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_PROC_FS</span>
<span class="cm">/**</span>
<span class="cm"> * mega_adapinq()</span>
<span class="cm"> * @adapter - pointer to our soft state</span>
<span class="cm"> * @dma_handle - DMA address of the buffer</span>
<span class="cm"> *</span>
<span class="cm"> * Issue internal commands while interrupts are available.</span>
<span class="cm"> * We only issue direct mailbox commands from within the driver. ioctl()</span>
<span class="cm"> * interface using these routines can issue passthru commands.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">mega_adapinq</span><span class="p">(</span><span class="n">adapter_t</span> <span class="o">*</span><span class="n">adapter</span><span class="p">,</span> <span class="n">dma_addr_t</span> <span class="n">dma_handle</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">megacmd_t</span>	<span class="n">mc</span><span class="p">;</span>

	<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mc</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">megacmd_t</span><span class="p">));</span>

	<span class="k">if</span><span class="p">(</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">flag</span> <span class="o">&amp;</span> <span class="n">BOARD_40LD</span> <span class="p">)</span> <span class="p">{</span>
		<span class="n">mc</span><span class="p">.</span><span class="n">cmd</span> <span class="o">=</span> <span class="n">FC_NEW_CONFIG</span><span class="p">;</span>
		<span class="n">mc</span><span class="p">.</span><span class="n">opcode</span> <span class="o">=</span> <span class="n">NC_SUBOP_ENQUIRY3</span><span class="p">;</span>
		<span class="n">mc</span><span class="p">.</span><span class="n">subopcode</span> <span class="o">=</span> <span class="n">ENQ3_GET_SOLICITED_FULL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="n">mc</span><span class="p">.</span><span class="n">cmd</span> <span class="o">=</span> <span class="n">MEGA_MBOXCMD_ADPEXTINQ</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">mc</span><span class="p">.</span><span class="n">xferaddr</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span><span class="n">dma_handle</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span> <span class="n">mega_internal_command</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mc</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/** mega_internal_dev_inquiry()</span>
<span class="cm"> * @adapter - pointer to our soft state</span>
<span class="cm"> * @ch - channel for this device</span>
<span class="cm"> * @tgt - ID of this device</span>
<span class="cm"> * @buf_dma_handle - DMA address of the buffer</span>
<span class="cm"> *</span>
<span class="cm"> * Issue the scsi inquiry for the specified device.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">mega_internal_dev_inquiry</span><span class="p">(</span><span class="n">adapter_t</span> <span class="o">*</span><span class="n">adapter</span><span class="p">,</span> <span class="n">u8</span> <span class="n">ch</span><span class="p">,</span> <span class="n">u8</span> <span class="n">tgt</span><span class="p">,</span>
		<span class="n">dma_addr_t</span> <span class="n">buf_dma_handle</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">mega_passthru</span>	<span class="o">*</span><span class="n">pthru</span><span class="p">;</span>
	<span class="n">dma_addr_t</span>	<span class="n">pthru_dma_handle</span><span class="p">;</span>
	<span class="n">megacmd_t</span>	<span class="n">mc</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">rval</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pci_dev</span>	<span class="o">*</span><span class="n">pdev</span><span class="p">;</span>


	<span class="cm">/*</span>
<span class="cm">	 * For all internal commands, the buffer must be allocated in &lt;4GB</span>
<span class="cm">	 * address range</span>
<span class="cm">	 */</span>
	<span class="k">if</span><span class="p">(</span> <span class="n">make_local_pdev</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pdev</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">)</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="n">pthru</span> <span class="o">=</span> <span class="n">pci_alloc_consistent</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">mega_passthru</span><span class="p">),</span>
			<span class="o">&amp;</span><span class="n">pthru_dma_handle</span><span class="p">);</span>

	<span class="k">if</span><span class="p">(</span> <span class="n">pthru</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="p">)</span> <span class="p">{</span>
		<span class="n">free_local_pdev</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">pthru</span><span class="o">-&gt;</span><span class="n">timeout</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
	<span class="n">pthru</span><span class="o">-&gt;</span><span class="n">ars</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">pthru</span><span class="o">-&gt;</span><span class="n">reqsenselen</span> <span class="o">=</span> <span class="mi">14</span><span class="p">;</span>
	<span class="n">pthru</span><span class="o">-&gt;</span><span class="n">islogical</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">pthru</span><span class="o">-&gt;</span><span class="n">channel</span> <span class="o">=</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">flag</span> <span class="o">&amp;</span> <span class="n">BOARD_40LD</span><span class="p">)</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="n">ch</span><span class="p">;</span>

	<span class="n">pthru</span><span class="o">-&gt;</span><span class="n">target</span> <span class="o">=</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">flag</span> <span class="o">&amp;</span> <span class="n">BOARD_40LD</span><span class="p">)</span> <span class="o">?</span> <span class="p">(</span><span class="n">ch</span> <span class="o">&lt;&lt;</span> <span class="mi">4</span><span class="p">)</span><span class="o">|</span><span class="n">tgt</span> <span class="o">:</span> <span class="n">tgt</span><span class="p">;</span>

	<span class="n">pthru</span><span class="o">-&gt;</span><span class="n">cdblen</span> <span class="o">=</span> <span class="mi">6</span><span class="p">;</span>

	<span class="n">pthru</span><span class="o">-&gt;</span><span class="n">cdb</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">INQUIRY</span><span class="p">;</span>
	<span class="n">pthru</span><span class="o">-&gt;</span><span class="n">cdb</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">pthru</span><span class="o">-&gt;</span><span class="n">cdb</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">pthru</span><span class="o">-&gt;</span><span class="n">cdb</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">pthru</span><span class="o">-&gt;</span><span class="n">cdb</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="mi">255</span><span class="p">;</span>
	<span class="n">pthru</span><span class="o">-&gt;</span><span class="n">cdb</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>


	<span class="n">pthru</span><span class="o">-&gt;</span><span class="n">dataxferaddr</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span><span class="n">buf_dma_handle</span><span class="p">;</span>
	<span class="n">pthru</span><span class="o">-&gt;</span><span class="n">dataxferlen</span> <span class="o">=</span> <span class="mi">256</span><span class="p">;</span>

	<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mc</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">megacmd_t</span><span class="p">));</span>

	<span class="n">mc</span><span class="p">.</span><span class="n">cmd</span> <span class="o">=</span> <span class="n">MEGA_MBOXCMD_PASSTHRU</span><span class="p">;</span>
	<span class="n">mc</span><span class="p">.</span><span class="n">xferaddr</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span><span class="n">pthru_dma_handle</span><span class="p">;</span>

	<span class="n">rval</span> <span class="o">=</span> <span class="n">mega_internal_command</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mc</span><span class="p">,</span> <span class="n">pthru</span><span class="p">);</span>

	<span class="n">pci_free_consistent</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">mega_passthru</span><span class="p">),</span> <span class="n">pthru</span><span class="p">,</span>
			<span class="n">pthru_dma_handle</span><span class="p">);</span>

	<span class="n">free_local_pdev</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">rval</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="cm">/**</span>
<span class="cm"> * mega_internal_command()</span>
<span class="cm"> * @adapter - pointer to our soft state</span>
<span class="cm"> * @mc - the mailbox command</span>
<span class="cm"> * @pthru - Passthru structure for DCDB commands</span>
<span class="cm"> *</span>
<span class="cm"> * Issue the internal commands in interrupt mode.</span>
<span class="cm"> * The last argument is the address of the passthru structure if the command</span>
<span class="cm"> * to be fired is a passthru command</span>
<span class="cm"> *</span>
<span class="cm"> * lockscope specifies whether the caller has already acquired the lock. Of</span>
<span class="cm"> * course, the caller must know which lock we are talking about.</span>
<span class="cm"> *</span>
<span class="cm"> * Note: parameter &#39;pthru&#39; is null for non-passthru commands.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">mega_internal_command</span><span class="p">(</span><span class="n">adapter_t</span> <span class="o">*</span><span class="n">adapter</span><span class="p">,</span> <span class="n">megacmd_t</span> <span class="o">*</span><span class="n">mc</span><span class="p">,</span> <span class="n">mega_passthru</span> <span class="o">*</span><span class="n">pthru</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">Scsi_Cmnd</span>	<span class="o">*</span><span class="n">scmd</span><span class="p">;</span>
	<span class="k">struct</span>	<span class="n">scsi_device</span> <span class="o">*</span><span class="n">sdev</span><span class="p">;</span>
	<span class="n">scb_t</span>	<span class="o">*</span><span class="n">scb</span><span class="p">;</span>
	<span class="kt">int</span>	<span class="n">rval</span><span class="p">;</span>

	<span class="n">scmd</span> <span class="o">=</span> <span class="n">scsi_allocate_command</span><span class="p">(</span><span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">scmd</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * The internal commands share one command id and hence are</span>
<span class="cm">	 * serialized. This is so because we want to reserve maximum number of</span>
<span class="cm">	 * available command ids for the I/O commands.</span>
<span class="cm">	 */</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">int_mtx</span><span class="p">);</span>

	<span class="n">scb</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">int_scb</span><span class="p">;</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">scb</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">scb_t</span><span class="p">));</span>

	<span class="n">sdev</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_device</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="n">scmd</span><span class="o">-&gt;</span><span class="n">device</span> <span class="o">=</span> <span class="n">sdev</span><span class="p">;</span>

	<span class="n">memset</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">int_cdb</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">int_cdb</span><span class="p">));</span>
	<span class="n">scmd</span><span class="o">-&gt;</span><span class="n">cmnd</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">int_cdb</span><span class="p">;</span>
	<span class="n">scmd</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">host</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">;</span>
	<span class="n">scmd</span><span class="o">-&gt;</span><span class="n">host_scribble</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">scb</span><span class="p">;</span>
	<span class="n">scmd</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">MEGA_INTERNAL_CMD</span><span class="p">;</span>

	<span class="n">scb</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">|=</span> <span class="n">SCB_ACTIVE</span><span class="p">;</span>
	<span class="n">scb</span><span class="o">-&gt;</span><span class="n">cmd</span> <span class="o">=</span> <span class="n">scmd</span><span class="p">;</span>

	<span class="n">memcpy</span><span class="p">(</span><span class="n">scb</span><span class="o">-&gt;</span><span class="n">raw_mbox</span><span class="p">,</span> <span class="n">mc</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">megacmd_t</span><span class="p">));</span>

	<span class="cm">/*</span>
<span class="cm">	 * Is it a passthru command</span>
<span class="cm">	 */</span>
	<span class="k">if</span><span class="p">(</span> <span class="n">mc</span><span class="o">-&gt;</span><span class="n">cmd</span> <span class="o">==</span> <span class="n">MEGA_MBOXCMD_PASSTHRU</span> <span class="p">)</span> <span class="p">{</span>

		<span class="n">scb</span><span class="o">-&gt;</span><span class="n">pthru</span> <span class="o">=</span> <span class="n">pthru</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">scb</span><span class="o">-&gt;</span><span class="n">idx</span> <span class="o">=</span> <span class="n">CMDID_INT_CMDS</span><span class="p">;</span>

	<span class="n">megaraid_queue_lck</span><span class="p">(</span><span class="n">scmd</span><span class="p">,</span> <span class="n">mega_internal_done</span><span class="p">);</span>

	<span class="n">wait_for_completion</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">int_waitq</span><span class="p">);</span>

	<span class="n">rval</span> <span class="o">=</span> <span class="n">scmd</span><span class="o">-&gt;</span><span class="n">result</span><span class="p">;</span>
	<span class="n">mc</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">=</span> <span class="n">scmd</span><span class="o">-&gt;</span><span class="n">result</span><span class="p">;</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">sdev</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Print a debug message for all failed commands. Applications can use</span>
<span class="cm">	 * this information.</span>
<span class="cm">	 */</span>
	<span class="k">if</span><span class="p">(</span> <span class="n">scmd</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">&amp;&amp;</span> <span class="n">trace_level</span> <span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;megaraid: cmd [%x, %x, %x] status:[%x]</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">mc</span><span class="o">-&gt;</span><span class="n">cmd</span><span class="p">,</span> <span class="n">mc</span><span class="o">-&gt;</span><span class="n">opcode</span><span class="p">,</span> <span class="n">mc</span><span class="o">-&gt;</span><span class="n">subopcode</span><span class="p">,</span> <span class="n">scmd</span><span class="o">-&gt;</span><span class="n">result</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">int_mtx</span><span class="p">);</span>

	<span class="n">scsi_free_command</span><span class="p">(</span><span class="n">GFP_KERNEL</span><span class="p">,</span> <span class="n">scmd</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">rval</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/**</span>
<span class="cm"> * mega_internal_done()</span>
<span class="cm"> * @scmd - internal scsi command</span>
<span class="cm"> *</span>
<span class="cm"> * Callback routine for internal commands.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">mega_internal_done</span><span class="p">(</span><span class="n">Scsi_Cmnd</span> <span class="o">*</span><span class="n">scmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">adapter_t</span>	<span class="o">*</span><span class="n">adapter</span><span class="p">;</span>

	<span class="n">adapter</span> <span class="o">=</span> <span class="p">(</span><span class="n">adapter_t</span> <span class="o">*</span><span class="p">)</span><span class="n">scmd</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">hostdata</span><span class="p">;</span>

	<span class="n">complete</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">int_waitq</span><span class="p">);</span>

<span class="p">}</span>


<span class="k">static</span> <span class="k">struct</span> <span class="n">scsi_host_template</span> <span class="n">megaraid_template</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">module</span>				<span class="o">=</span> <span class="n">THIS_MODULE</span><span class="p">,</span>
	<span class="p">.</span><span class="n">name</span>				<span class="o">=</span> <span class="s">&quot;MegaRAID&quot;</span><span class="p">,</span>
	<span class="p">.</span><span class="n">proc_name</span>			<span class="o">=</span> <span class="s">&quot;megaraid_legacy&quot;</span><span class="p">,</span>
	<span class="p">.</span><span class="n">info</span>				<span class="o">=</span> <span class="n">megaraid_info</span><span class="p">,</span>
	<span class="p">.</span><span class="n">queuecommand</span>			<span class="o">=</span> <span class="n">megaraid_queue</span><span class="p">,</span>	
	<span class="p">.</span><span class="n">bios_param</span>			<span class="o">=</span> <span class="n">megaraid_biosparam</span><span class="p">,</span>
	<span class="p">.</span><span class="n">max_sectors</span>			<span class="o">=</span> <span class="n">MAX_SECTORS_PER_IO</span><span class="p">,</span>
	<span class="p">.</span><span class="n">can_queue</span>			<span class="o">=</span> <span class="n">MAX_COMMANDS</span><span class="p">,</span>
	<span class="p">.</span><span class="n">this_id</span>			<span class="o">=</span> <span class="n">DEFAULT_INITIATOR_ID</span><span class="p">,</span>
	<span class="p">.</span><span class="n">sg_tablesize</span>			<span class="o">=</span> <span class="n">MAX_SGLIST</span><span class="p">,</span>
	<span class="p">.</span><span class="n">cmd_per_lun</span>			<span class="o">=</span> <span class="n">DEF_CMD_PER_LUN</span><span class="p">,</span>
	<span class="p">.</span><span class="n">use_clustering</span>			<span class="o">=</span> <span class="n">ENABLE_CLUSTERING</span><span class="p">,</span>
	<span class="p">.</span><span class="n">eh_abort_handler</span>		<span class="o">=</span> <span class="n">megaraid_abort</span><span class="p">,</span>
	<span class="p">.</span><span class="n">eh_device_reset_handler</span>	<span class="o">=</span> <span class="n">megaraid_reset</span><span class="p">,</span>
	<span class="p">.</span><span class="n">eh_bus_reset_handler</span>		<span class="o">=</span> <span class="n">megaraid_reset</span><span class="p">,</span>
	<span class="p">.</span><span class="n">eh_host_reset_handler</span>		<span class="o">=</span> <span class="n">megaraid_reset</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__devinit</span>
<span class="nf">megaraid_probe_one</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">pci_device_id</span> <span class="o">*</span><span class="n">id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">host</span><span class="p">;</span>
	<span class="n">adapter_t</span> <span class="o">*</span><span class="n">adapter</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">mega_baseport</span><span class="p">,</span> <span class="n">tbase</span><span class="p">,</span> <span class="n">flag</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">subsysid</span><span class="p">,</span> <span class="n">subsysvid</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">pci_bus</span><span class="p">,</span> <span class="n">pci_dev_func</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pci_enable_device</span><span class="p">(</span><span class="n">pdev</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="n">pci_set_master</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>

	<span class="n">pci_bus</span> <span class="o">=</span> <span class="n">pdev</span><span class="o">-&gt;</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">number</span><span class="p">;</span>
	<span class="n">pci_dev_func</span> <span class="o">=</span> <span class="n">pdev</span><span class="o">-&gt;</span><span class="n">devfn</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * The megaraid3 stuff reports the ID of the Intel part which is not</span>
<span class="cm">	 * remotely specific to the megaraid</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">vendor</span> <span class="o">==</span> <span class="n">PCI_VENDOR_ID_INTEL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">u16</span> <span class="n">magic</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * Don&#39;t fall over the Compaq management cards using the same</span>
<span class="cm">		 * PCI identifier</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">subsystem_vendor</span> <span class="o">==</span> <span class="n">PCI_VENDOR_ID_COMPAQ</span> <span class="o">&amp;&amp;</span>
		    <span class="n">pdev</span><span class="o">-&gt;</span><span class="n">subsystem_device</span> <span class="o">==</span> <span class="mh">0xC000</span><span class="p">)</span>
		   	<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
		<span class="cm">/* Now check the magic signature byte */</span>
		<span class="n">pci_read_config_word</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">PCI_CONF_AMISIG</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">magic</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">magic</span> <span class="o">!=</span> <span class="n">HBA_SIGNATURE_471</span> <span class="o">&amp;&amp;</span> <span class="n">magic</span> <span class="o">!=</span> <span class="n">HBA_SIGNATURE</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
		<span class="cm">/* Ok it is probably a megaraid */</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * For these vendor and device ids, signature offsets are not</span>
<span class="cm">	 * valid and 64 bit is implicit</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">id</span><span class="o">-&gt;</span><span class="n">driver_data</span> <span class="o">&amp;</span> <span class="n">BOARD_64BIT</span><span class="p">)</span>
		<span class="n">flag</span> <span class="o">|=</span> <span class="n">BOARD_64BIT</span><span class="p">;</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="n">u32</span> <span class="n">magic64</span><span class="p">;</span>

		<span class="n">pci_read_config_dword</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">PCI_CONF_AMISIG64</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">magic64</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">magic64</span> <span class="o">==</span> <span class="n">HBA_SIGNATURE_64BIT</span><span class="p">)</span>
			<span class="n">flag</span> <span class="o">|=</span> <span class="n">BOARD_64BIT</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">subsysvid</span> <span class="o">=</span> <span class="n">pdev</span><span class="o">-&gt;</span><span class="n">subsystem_vendor</span><span class="p">;</span>
	<span class="n">subsysid</span> <span class="o">=</span> <span class="n">pdev</span><span class="o">-&gt;</span><span class="n">subsystem_device</span><span class="p">;</span>

	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_NOTICE</span> <span class="s">&quot;megaraid: found 0x%4.04x:0x%4.04x:bus %d:&quot;</span><span class="p">,</span>
		<span class="n">id</span><span class="o">-&gt;</span><span class="n">vendor</span><span class="p">,</span> <span class="n">id</span><span class="o">-&gt;</span><span class="n">device</span><span class="p">,</span> <span class="n">pci_bus</span><span class="p">);</span>

	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;slot %d:func %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">PCI_SLOT</span><span class="p">(</span><span class="n">pci_dev_func</span><span class="p">),</span> <span class="n">PCI_FUNC</span><span class="p">(</span><span class="n">pci_dev_func</span><span class="p">));</span>

	<span class="cm">/* Read the base port and IRQ from PCI */</span>
	<span class="n">mega_baseport</span> <span class="o">=</span> <span class="n">pci_resource_start</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">irq</span> <span class="o">=</span> <span class="n">pdev</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">;</span>

	<span class="n">tbase</span> <span class="o">=</span> <span class="n">mega_baseport</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pci_resource_flags</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">IORESOURCE_MEM</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">flag</span> <span class="o">|=</span> <span class="n">BOARD_MEMMAP</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">request_mem_region</span><span class="p">(</span><span class="n">mega_baseport</span><span class="p">,</span> <span class="mi">128</span><span class="p">,</span> <span class="s">&quot;megaraid&quot;</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;megaraid: mem region busy!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">out_disable_device</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">mega_baseport</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">ioremap</span><span class="p">(</span><span class="n">mega_baseport</span><span class="p">,</span> <span class="mi">128</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mega_baseport</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span>
			       <span class="s">&quot;megaraid: could not map hba memory</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">out_release_region</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">flag</span> <span class="o">|=</span> <span class="n">BOARD_IOMAP</span><span class="p">;</span>
		<span class="n">mega_baseport</span> <span class="o">+=</span> <span class="mh">0x10</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">request_region</span><span class="p">(</span><span class="n">mega_baseport</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="s">&quot;megaraid&quot;</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">out_disable_device</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Initialize SCSI Host structure */</span>
	<span class="n">host</span> <span class="o">=</span> <span class="n">scsi_host_alloc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">megaraid_template</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">adapter_t</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">host</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_iounmap</span><span class="p">;</span>

	<span class="n">adapter</span> <span class="o">=</span> <span class="p">(</span><span class="n">adapter_t</span> <span class="o">*</span><span class="p">)</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">hostdata</span><span class="p">;</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">adapter_t</span><span class="p">));</span>

	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_NOTICE</span>
		<span class="s">&quot;scsi%d:Found MegaRAID controller at 0x%lx, IRQ:%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">host</span><span class="o">-&gt;</span><span class="n">host_no</span><span class="p">,</span> <span class="n">mega_baseport</span><span class="p">,</span> <span class="n">irq</span><span class="p">);</span>

	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">base</span> <span class="o">=</span> <span class="n">mega_baseport</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">flag</span> <span class="o">&amp;</span> <span class="n">BOARD_MEMMAP</span><span class="p">)</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">mmio_base</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="p">)</span> <span class="n">mega_baseport</span><span class="p">;</span>

	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">free_list</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pending_list</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">completed_list</span><span class="p">);</span>

	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">flag</span> <span class="o">=</span> <span class="n">flag</span><span class="p">;</span>
	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="n">host</span><span class="o">-&gt;</span><span class="n">cmd_per_lun</span> <span class="o">=</span> <span class="n">max_cmd_per_lun</span><span class="p">;</span>
	<span class="n">host</span><span class="o">-&gt;</span><span class="n">max_sectors</span> <span class="o">=</span> <span class="n">max_sectors_per_io</span><span class="p">;</span>

	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">dev</span> <span class="o">=</span> <span class="n">pdev</span><span class="p">;</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">host</span> <span class="o">=</span> <span class="n">host</span><span class="p">;</span>

	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">irq</span> <span class="o">=</span> <span class="n">irq</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">flag</span> <span class="o">&amp;</span> <span class="n">BOARD_MEMMAP</span><span class="p">)</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">base</span> <span class="o">=</span> <span class="n">tbase</span><span class="p">;</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">io_port</span> <span class="o">=</span> <span class="n">tbase</span><span class="p">;</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">n_io_port</span> <span class="o">=</span> <span class="mi">16</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">unique_id</span> <span class="o">=</span> <span class="p">(</span><span class="n">pci_bus</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">|</span> <span class="n">pci_dev_func</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Allocate buffer to issue internal commands.</span>
<span class="cm">	 */</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">mega_buffer</span> <span class="o">=</span> <span class="n">pci_alloc_consistent</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
		<span class="n">MEGA_BUFFER_SIZE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">buf_dma_handle</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">mega_buffer</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;megaraid: out of RAM.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_host_put</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">scb_list</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">scb_t</span><span class="p">)</span> <span class="o">*</span> <span class="n">MAX_COMMANDS</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">scb_list</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;megaraid: out of RAM.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_free_cmd_buffer</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">request_irq</span><span class="p">(</span><span class="n">irq</span><span class="p">,</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">flag</span> <span class="o">&amp;</span> <span class="n">BOARD_MEMMAP</span><span class="p">)</span> <span class="o">?</span>
				<span class="n">megaraid_isr_memmapped</span> <span class="o">:</span> <span class="n">megaraid_isr_iomapped</span><span class="p">,</span>
					<span class="n">IRQF_SHARED</span><span class="p">,</span> <span class="s">&quot;megaraid&quot;</span><span class="p">,</span> <span class="n">adapter</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span>
			<span class="s">&quot;megaraid: Couldn&#39;t register IRQ %d!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">irq</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_free_scb_list</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">mega_setup_mailbox</span><span class="p">(</span><span class="n">adapter</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out_free_irq</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">mega_query_adapter</span><span class="p">(</span><span class="n">adapter</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out_free_mbox</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Have checks for some buggy f/w</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">subsysid</span> <span class="o">==</span> <span class="mh">0x1111</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">subsysvid</span> <span class="o">==</span> <span class="mh">0x1111</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Which firmware</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strcmp</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">fw_version</span><span class="p">,</span> <span class="s">&quot;3.00&quot;</span><span class="p">)</span> <span class="o">||</span>
				<span class="o">!</span><span class="n">strcmp</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">fw_version</span><span class="p">,</span> <span class="s">&quot;3.01&quot;</span><span class="p">))</span> <span class="p">{</span>

			<span class="n">printk</span><span class="p">(</span> <span class="n">KERN_WARNING</span>
				<span class="s">&quot;megaraid: Your  card is a Dell PERC &quot;</span>
				<span class="s">&quot;2/SC RAID controller with  &quot;</span>
				<span class="s">&quot;firmware</span><span class="se">\n</span><span class="s">megaraid: 3.00 or 3.01.  &quot;</span>
				<span class="s">&quot;This driver is known to have &quot;</span>
				<span class="s">&quot;corruption issues</span><span class="se">\n</span><span class="s">megaraid: with &quot;</span>
				<span class="s">&quot;those firmware versions on this &quot;</span>
				<span class="s">&quot;specific card.  In order</span><span class="se">\n</span><span class="s">megaraid: &quot;</span>
				<span class="s">&quot;to protect your data, please upgrade &quot;</span>
				<span class="s">&quot;your firmware to version</span><span class="se">\n</span><span class="s">megaraid: &quot;</span>
				<span class="s">&quot;3.10 or later, available from the &quot;</span>
				<span class="s">&quot;Dell Technical Support web</span><span class="se">\n</span><span class="s">&quot;</span>
				<span class="s">&quot;megaraid: site at</span><span class="se">\n</span><span class="s">http://support.&quot;</span>
				<span class="s">&quot;dell.com/us/en/filelib/download/&quot;</span>
				<span class="s">&quot;index.asp?fileid=2940</span><span class="se">\n</span><span class="s">&quot;</span>
			<span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * If we have a HP 1M(0x60E7)/2M(0x60E8) controller with</span>
<span class="cm">	 * firmware H.01.07, H.01.08, and H.01.09 disable 64 bit</span>
<span class="cm">	 * support, since this firmware cannot handle 64 bit</span>
<span class="cm">	 * addressing</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">subsysvid</span> <span class="o">==</span> <span class="n">HP_SUBSYS_VID</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="p">((</span><span class="n">subsysid</span> <span class="o">==</span> <span class="mh">0x60E7</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">subsysid</span> <span class="o">==</span> <span class="mh">0x60E8</span><span class="p">)))</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * which firmware</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strcmp</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">fw_version</span><span class="p">,</span> <span class="s">&quot;H01.07&quot;</span><span class="p">)</span> <span class="o">||</span>
		    <span class="o">!</span><span class="n">strcmp</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">fw_version</span><span class="p">,</span> <span class="s">&quot;H01.08&quot;</span><span class="p">)</span> <span class="o">||</span>
		    <span class="o">!</span><span class="n">strcmp</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">fw_version</span><span class="p">,</span> <span class="s">&quot;H01.09&quot;</span><span class="p">)</span> <span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span>
				<span class="s">&quot;megaraid: Firmware H.01.07, &quot;</span>
				<span class="s">&quot;H.01.08, and H.01.09 on 1M/2M &quot;</span>
				<span class="s">&quot;controllers</span><span class="se">\n</span><span class="s">&quot;</span>
				<span class="s">&quot;megaraid: do not support 64 bit &quot;</span>
				<span class="s">&quot;addressing.</span><span class="se">\n</span><span class="s">megaraid: DISABLING &quot;</span>
				<span class="s">&quot;64 bit support.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">flag</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">BOARD_64BIT</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">mega_is_bios_enabled</span><span class="p">(</span><span class="n">adapter</span><span class="p">))</span>
		<span class="n">mega_hbas</span><span class="p">[</span><span class="n">hba_count</span><span class="p">].</span><span class="n">is_bios_enabled</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">mega_hbas</span><span class="p">[</span><span class="n">hba_count</span><span class="p">].</span><span class="n">hostdata_addr</span> <span class="o">=</span> <span class="n">adapter</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Find out which channel is raid and which is scsi. This is</span>
<span class="cm">	 * for ROMB support.</span>
<span class="cm">	 */</span>
	<span class="n">mega_enum_raid_scsi</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Find out if a logical drive is set as the boot drive. If</span>
<span class="cm">	 * there is one, will make that as the first logical drive.</span>
<span class="cm">	 * ROMB: Do we have to boot from a physical drive. Then all</span>
<span class="cm">	 * the physical drives would appear before the logical disks.</span>
<span class="cm">	 * Else, all the physical drives would be exported to the mid</span>
<span class="cm">	 * layer after logical drives.</span>
<span class="cm">	 */</span>
	<span class="n">mega_get_boot_drv</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">boot_pdrv_enabled</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">j</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">product_info</span><span class="p">.</span><span class="n">nchannels</span><span class="p">;</span>
		<span class="k">for</span><span class="p">(</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">j</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span> <span class="p">)</span>
			<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">logdrv_chan</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">for</span><span class="p">(</span> <span class="n">i</span> <span class="o">=</span> <span class="n">j</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">NVIRT_CHAN</span> <span class="o">+</span> <span class="n">j</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span> <span class="p">)</span>
			<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">logdrv_chan</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">NVIRT_CHAN</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
			<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">logdrv_chan</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">NVIRT_CHAN</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">MAX_CHANNELS</span><span class="o">+</span><span class="n">NVIRT_CHAN</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
			<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">logdrv_chan</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">mega_ch_class</span> <span class="o">&lt;&lt;=</span> <span class="n">NVIRT_CHAN</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Do we support random deletion and addition of logical</span>
<span class="cm">	 * drives</span>
<span class="cm">	 */</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">read_ldidmap</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>	<span class="cm">/* set it after first logdrv</span>
<span class="cm">						   delete cmd */</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">support_random_del</span> <span class="o">=</span> <span class="n">mega_support_random_del</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>

	<span class="cm">/* Initialize SCBs */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mega_init_scb</span><span class="p">(</span><span class="n">adapter</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out_free_mbox</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Reset the pending commands counter</span>
<span class="cm">	 */</span>
	<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pend_cmds</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Reset the adapter quiescent flag</span>
<span class="cm">	 */</span>
	<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">quiescent</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="n">hba_soft_state</span><span class="p">[</span><span class="n">hba_count</span><span class="p">]</span> <span class="o">=</span> <span class="n">adapter</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Fill in the structure which needs to be passed back to the</span>
<span class="cm">	 * application when it does an ioctl() for controller related</span>
<span class="cm">	 * information.</span>
<span class="cm">	 */</span>
	<span class="n">i</span> <span class="o">=</span> <span class="n">hba_count</span><span class="p">;</span>

	<span class="n">mcontroller</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">base</span> <span class="o">=</span> <span class="n">mega_baseport</span><span class="p">;</span>
	<span class="n">mcontroller</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">irq</span> <span class="o">=</span> <span class="n">irq</span><span class="p">;</span>
	<span class="n">mcontroller</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">numldrv</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">numldrv</span><span class="p">;</span>
	<span class="n">mcontroller</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">pcibus</span> <span class="o">=</span> <span class="n">pci_bus</span><span class="p">;</span>
	<span class="n">mcontroller</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">pcidev</span> <span class="o">=</span> <span class="n">id</span><span class="o">-&gt;</span><span class="n">device</span><span class="p">;</span>
	<span class="n">mcontroller</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">pcifun</span> <span class="o">=</span> <span class="n">PCI_FUNC</span> <span class="p">(</span><span class="n">pci_dev_func</span><span class="p">);</span>
	<span class="n">mcontroller</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">pciid</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">mcontroller</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">pcivendor</span> <span class="o">=</span> <span class="n">id</span><span class="o">-&gt;</span><span class="n">vendor</span><span class="p">;</span>
	<span class="n">mcontroller</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">pcislot</span> <span class="o">=</span> <span class="n">PCI_SLOT</span><span class="p">(</span><span class="n">pci_dev_func</span><span class="p">);</span>
	<span class="n">mcontroller</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">uid</span> <span class="o">=</span> <span class="p">(</span><span class="n">pci_bus</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">|</span> <span class="n">pci_dev_func</span><span class="p">;</span>


	<span class="cm">/* Set the Mode of addressing to 64 bit if we can */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">flag</span> <span class="o">&amp;</span> <span class="n">BOARD_64BIT</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">dma_addr_t</span><span class="p">)</span> <span class="o">==</span> <span class="mi">8</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">pci_set_dma_mask</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">DMA_BIT_MASK</span><span class="p">(</span><span class="mi">64</span><span class="p">));</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">has_64bit_addr</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span>  <span class="p">{</span>
		<span class="n">pci_set_dma_mask</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">DMA_BIT_MASK</span><span class="p">(</span><span class="mi">32</span><span class="p">));</span>
		<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">has_64bit_addr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
		
	<span class="n">mutex_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">int_mtx</span><span class="p">);</span>
	<span class="n">init_completion</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">int_waitq</span><span class="p">);</span>

	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">this_id</span> <span class="o">=</span> <span class="n">DEFAULT_INITIATOR_ID</span><span class="p">;</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">this_id</span> <span class="o">=</span> <span class="n">DEFAULT_INITIATOR_ID</span><span class="p">;</span>

<span class="cp">#if MEGA_HAVE_CLUSTERING</span>
	<span class="cm">/*</span>
<span class="cm">	 * Is cluster support enabled on this controller</span>
<span class="cm">	 * Note: In a cluster the HBAs ( the initiators ) will have</span>
<span class="cm">	 * different target IDs and we cannot assume it to be 7. Call</span>
<span class="cm">	 * to mega_support_cluster() will get the target ids also if</span>
<span class="cm">	 * the cluster support is available</span>
<span class="cm">	 */</span>
	<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">has_cluster</span> <span class="o">=</span> <span class="n">mega_support_cluster</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">has_cluster</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_NOTICE</span>
			<span class="s">&quot;megaraid: Cluster driver, initiator id:%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">this_id</span><span class="p">);</span>
	<span class="p">}</span>
<span class="cp">#endif</span>

	<span class="n">pci_set_drvdata</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">host</span><span class="p">);</span>

	<span class="n">mega_create_proc_entry</span><span class="p">(</span><span class="n">hba_count</span><span class="p">,</span> <span class="n">mega_proc_dir_entry</span><span class="p">);</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">scsi_add_host</span><span class="p">(</span><span class="n">host</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_free_mbox</span><span class="p">;</span>

	<span class="n">scsi_scan_host</span><span class="p">(</span><span class="n">host</span><span class="p">);</span>
	<span class="n">hba_count</span><span class="o">++</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

 <span class="nl">out_free_mbox:</span>
	<span class="n">pci_free_consistent</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">mbox64_t</span><span class="p">),</span>
			<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">una_mbox64</span><span class="p">,</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">una_mbox64_dma</span><span class="p">);</span>
 <span class="nl">out_free_irq:</span>
	<span class="n">free_irq</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">,</span> <span class="n">adapter</span><span class="p">);</span>
 <span class="nl">out_free_scb_list:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">scb_list</span><span class="p">);</span>
 <span class="nl">out_free_cmd_buffer:</span>
	<span class="n">pci_free_consistent</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">MEGA_BUFFER_SIZE</span><span class="p">,</span>
			<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">mega_buffer</span><span class="p">,</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">buf_dma_handle</span><span class="p">);</span>
 <span class="nl">out_host_put:</span>
	<span class="n">scsi_host_put</span><span class="p">(</span><span class="n">host</span><span class="p">);</span>
 <span class="nl">out_iounmap:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">flag</span> <span class="o">&amp;</span> <span class="n">BOARD_MEMMAP</span><span class="p">)</span>
		<span class="n">iounmap</span><span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">mega_baseport</span><span class="p">);</span>
 <span class="nl">out_release_region:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">flag</span> <span class="o">&amp;</span> <span class="n">BOARD_MEMMAP</span><span class="p">)</span>
		<span class="n">release_mem_region</span><span class="p">(</span><span class="n">tbase</span><span class="p">,</span> <span class="mi">128</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">release_region</span><span class="p">(</span><span class="n">mega_baseport</span><span class="p">,</span> <span class="mi">16</span><span class="p">);</span>
 <span class="nl">out_disable_device:</span>
	<span class="n">pci_disable_device</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
 <span class="nl">out:</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">__megaraid_shutdown</span><span class="p">(</span><span class="n">adapter_t</span> <span class="o">*</span><span class="n">adapter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u_char</span>	<span class="n">raw_mbox</span><span class="p">[</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">mbox_out</span><span class="p">)];</span>
	<span class="n">mbox_t</span>	<span class="o">*</span><span class="n">mbox</span> <span class="o">=</span> <span class="p">(</span><span class="n">mbox_t</span> <span class="o">*</span><span class="p">)</span><span class="n">raw_mbox</span><span class="p">;</span>
	<span class="kt">int</span>	<span class="n">i</span><span class="p">;</span>

	<span class="cm">/* Flush adapter cache */</span>
	<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mbox</span><span class="o">-&gt;</span><span class="n">m_out</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">raw_mbox</span><span class="p">));</span>
	<span class="n">raw_mbox</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">FLUSH_ADAPTER</span><span class="p">;</span>

	<span class="n">free_irq</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">,</span> <span class="n">adapter</span><span class="p">);</span>

	<span class="cm">/* Issue a blocking (interrupts disabled) command to the card */</span>
	<span class="n">issue_scb_block</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">raw_mbox</span><span class="p">);</span>

	<span class="cm">/* Flush disks cache */</span>
	<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mbox</span><span class="o">-&gt;</span><span class="n">m_out</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">raw_mbox</span><span class="p">));</span>
	<span class="n">raw_mbox</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">FLUSH_SYSTEM</span><span class="p">;</span>

	<span class="cm">/* Issue a blocking (interrupts disabled) command to the card */</span>
	<span class="n">issue_scb_block</span><span class="p">(</span><span class="n">adapter</span><span class="p">,</span> <span class="n">raw_mbox</span><span class="p">);</span>
	
	<span class="k">if</span> <span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">pend_cmds</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;megaraid: pending commands!!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Have a delibrate delay to make sure all the caches are</span>
<span class="cm">	 * actually flushed.</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="mi">10</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">mdelay</span><span class="p">(</span><span class="mi">1000</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__devexit</span>
<span class="nf">megaraid_remove_one</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">host</span> <span class="o">=</span> <span class="n">pci_get_drvdata</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="n">adapter_t</span> <span class="o">*</span><span class="n">adapter</span> <span class="o">=</span> <span class="p">(</span><span class="n">adapter_t</span> <span class="o">*</span><span class="p">)</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">hostdata</span><span class="p">;</span>

	<span class="n">scsi_remove_host</span><span class="p">(</span><span class="n">host</span><span class="p">);</span>

	<span class="n">__megaraid_shutdown</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>

	<span class="cm">/* Free our resources */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">flag</span> <span class="o">&amp;</span> <span class="n">BOARD_MEMMAP</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">iounmap</span><span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">);</span>
		<span class="n">release_mem_region</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">,</span> <span class="mi">128</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">release_region</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">,</span> <span class="mi">16</span><span class="p">);</span>

	<span class="n">mega_free_sgl</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_PROC_FS</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">controller_proc_dir_entry</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">remove_proc_entry</span><span class="p">(</span><span class="s">&quot;stat&quot;</span><span class="p">,</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">controller_proc_dir_entry</span><span class="p">);</span>
		<span class="n">remove_proc_entry</span><span class="p">(</span><span class="s">&quot;config&quot;</span><span class="p">,</span>
				<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">controller_proc_dir_entry</span><span class="p">);</span>
		<span class="n">remove_proc_entry</span><span class="p">(</span><span class="s">&quot;mailbox&quot;</span><span class="p">,</span>
				<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">controller_proc_dir_entry</span><span class="p">);</span>
<span class="cp">#if MEGA_HAVE_ENH_PROC</span>
		<span class="n">remove_proc_entry</span><span class="p">(</span><span class="s">&quot;rebuild-rate&quot;</span><span class="p">,</span>
				<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">controller_proc_dir_entry</span><span class="p">);</span>
		<span class="n">remove_proc_entry</span><span class="p">(</span><span class="s">&quot;battery-status&quot;</span><span class="p">,</span>
				<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">controller_proc_dir_entry</span><span class="p">);</span>

		<span class="n">remove_proc_entry</span><span class="p">(</span><span class="s">&quot;diskdrives-ch0&quot;</span><span class="p">,</span>
				<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">controller_proc_dir_entry</span><span class="p">);</span>
		<span class="n">remove_proc_entry</span><span class="p">(</span><span class="s">&quot;diskdrives-ch1&quot;</span><span class="p">,</span>
				<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">controller_proc_dir_entry</span><span class="p">);</span>
		<span class="n">remove_proc_entry</span><span class="p">(</span><span class="s">&quot;diskdrives-ch2&quot;</span><span class="p">,</span>
				<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">controller_proc_dir_entry</span><span class="p">);</span>
		<span class="n">remove_proc_entry</span><span class="p">(</span><span class="s">&quot;diskdrives-ch3&quot;</span><span class="p">,</span>
				<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">controller_proc_dir_entry</span><span class="p">);</span>

		<span class="n">remove_proc_entry</span><span class="p">(</span><span class="s">&quot;raiddrives-0-9&quot;</span><span class="p">,</span>
				<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">controller_proc_dir_entry</span><span class="p">);</span>
		<span class="n">remove_proc_entry</span><span class="p">(</span><span class="s">&quot;raiddrives-10-19&quot;</span><span class="p">,</span>
				<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">controller_proc_dir_entry</span><span class="p">);</span>
		<span class="n">remove_proc_entry</span><span class="p">(</span><span class="s">&quot;raiddrives-20-29&quot;</span><span class="p">,</span>
				<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">controller_proc_dir_entry</span><span class="p">);</span>
		<span class="n">remove_proc_entry</span><span class="p">(</span><span class="s">&quot;raiddrives-30-39&quot;</span><span class="p">,</span>
				<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">controller_proc_dir_entry</span><span class="p">);</span>
<span class="cp">#endif</span>
		<span class="p">{</span>
			<span class="kt">char</span>	<span class="n">buf</span><span class="p">[</span><span class="mi">12</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">0</span> <span class="p">};</span>
			<span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;hba%d&quot;</span><span class="p">,</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">host_no</span><span class="p">);</span>
			<span class="n">remove_proc_entry</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">mega_proc_dir_entry</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="cp">#endif</span>

	<span class="n">pci_free_consistent</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">MEGA_BUFFER_SIZE</span><span class="p">,</span>
			<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">mega_buffer</span><span class="p">,</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">buf_dma_handle</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">scb_list</span><span class="p">);</span>
	<span class="n">pci_free_consistent</span><span class="p">(</span><span class="n">adapter</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">mbox64_t</span><span class="p">),</span>
			<span class="n">adapter</span><span class="o">-&gt;</span><span class="n">una_mbox64</span><span class="p">,</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">una_mbox64_dma</span><span class="p">);</span>

	<span class="n">scsi_host_put</span><span class="p">(</span><span class="n">host</span><span class="p">);</span>
	<span class="n">pci_disable_device</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>

	<span class="n">hba_count</span><span class="o">--</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">megaraid_shutdown</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">host</span> <span class="o">=</span> <span class="n">pci_get_drvdata</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="n">adapter_t</span> <span class="o">*</span><span class="n">adapter</span> <span class="o">=</span> <span class="p">(</span><span class="n">adapter_t</span> <span class="o">*</span><span class="p">)</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">hostdata</span><span class="p">;</span>

	<span class="n">__megaraid_shutdown</span><span class="p">(</span><span class="n">adapter</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">pci_device_id</span> <span class="n">megaraid_pci_tbl</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">{</span><span class="n">PCI_VENDOR_ID_AMI</span><span class="p">,</span> <span class="n">PCI_DEVICE_ID_AMI_MEGARAID</span><span class="p">,</span>
		<span class="n">PCI_ANY_ID</span><span class="p">,</span> <span class="n">PCI_ANY_ID</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">},</span>
	<span class="p">{</span><span class="n">PCI_VENDOR_ID_AMI</span><span class="p">,</span> <span class="n">PCI_DEVICE_ID_AMI_MEGARAID2</span><span class="p">,</span>
		<span class="n">PCI_ANY_ID</span><span class="p">,</span> <span class="n">PCI_ANY_ID</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">},</span>
	<span class="p">{</span><span class="n">PCI_VENDOR_ID_INTEL</span><span class="p">,</span> <span class="n">PCI_DEVICE_ID_AMI_MEGARAID3</span><span class="p">,</span>
		<span class="n">PCI_ANY_ID</span><span class="p">,</span> <span class="n">PCI_ANY_ID</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">},</span>
	<span class="p">{</span><span class="mi">0</span><span class="p">,}</span>
<span class="p">};</span>
<span class="n">MODULE_DEVICE_TABLE</span><span class="p">(</span><span class="n">pci</span><span class="p">,</span> <span class="n">megaraid_pci_tbl</span><span class="p">);</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">pci_driver</span> <span class="n">megaraid_pci_driver</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">name</span>		<span class="o">=</span> <span class="s">&quot;megaraid_legacy&quot;</span><span class="p">,</span>
	<span class="p">.</span><span class="n">id_table</span>	<span class="o">=</span> <span class="n">megaraid_pci_tbl</span><span class="p">,</span>
	<span class="p">.</span><span class="n">probe</span>		<span class="o">=</span> <span class="n">megaraid_probe_one</span><span class="p">,</span>
	<span class="p">.</span><span class="n">remove</span>		<span class="o">=</span> <span class="n">__devexit_p</span><span class="p">(</span><span class="n">megaraid_remove_one</span><span class="p">),</span>
	<span class="p">.</span><span class="n">shutdown</span>	<span class="o">=</span> <span class="n">megaraid_shutdown</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">megaraid_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">max_cmd_per_lun</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">max_cmd_per_lun</span> <span class="o">&gt;</span> <span class="n">MAX_CMD_PER_LUN</span><span class="p">))</span>
		<span class="n">max_cmd_per_lun</span> <span class="o">=</span> <span class="n">MAX_CMD_PER_LUN</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">max_mbox_busy_wait</span> <span class="o">&gt;</span> <span class="n">MBOX_BUSY_WAIT</span><span class="p">)</span>
		<span class="n">max_mbox_busy_wait</span> <span class="o">=</span> <span class="n">MBOX_BUSY_WAIT</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_PROC_FS</span>
	<span class="n">mega_proc_dir_entry</span> <span class="o">=</span> <span class="n">proc_mkdir</span><span class="p">(</span><span class="s">&quot;megaraid&quot;</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mega_proc_dir_entry</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span>
				<span class="s">&quot;megaraid: failed to create megaraid root</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span>
<span class="cp">#endif</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">pci_register_driver</span><span class="p">(</span><span class="o">&amp;</span><span class="n">megaraid_pci_driver</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
<span class="cp">#ifdef CONFIG_PROC_FS</span>
		<span class="n">remove_proc_entry</span><span class="p">(</span><span class="s">&quot;megaraid&quot;</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="cp">#endif</span>
		<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Register the driver as a character device, for applications</span>
<span class="cm">	 * to access it for ioctls.</span>
<span class="cm">	 * First argument (major) to register_chrdev implies a dynamic</span>
<span class="cm">	 * major number allocation.</span>
<span class="cm">	 */</span>
	<span class="n">major</span> <span class="o">=</span> <span class="n">register_chrdev</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;megadev_legacy&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">megadev_fops</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">major</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span>
				<span class="s">&quot;megaraid: failed to register char device</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__exit</span> <span class="nf">megaraid_exit</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * Unregister the character device interface to the driver.</span>
<span class="cm">	 */</span>
	<span class="n">unregister_chrdev</span><span class="p">(</span><span class="n">major</span><span class="p">,</span> <span class="s">&quot;megadev_legacy&quot;</span><span class="p">);</span>

	<span class="n">pci_unregister_driver</span><span class="p">(</span><span class="o">&amp;</span><span class="n">megaraid_pci_driver</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_PROC_FS</span>
	<span class="n">remove_proc_entry</span><span class="p">(</span><span class="s">&quot;megaraid&quot;</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="n">module_init</span><span class="p">(</span><span class="n">megaraid_init</span><span class="p">);</span>
<span class="n">module_exit</span><span class="p">(</span><span class="n">megaraid_exit</span><span class="p">);</span>

<span class="cm">/* vi: set ts=8 sw=8 tw=78: */</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
