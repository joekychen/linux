<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › scsi › sym53c8xx_2 › sym_glue.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>sym_glue.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Device driver for the SYMBIOS/LSILOGIC 53C8XX and 53C1010 family </span>
<span class="cm"> * of PCI-SCSI IO processors.</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 1999-2001  Gerard Roudier &lt;groudier@free.fr&gt;</span>
<span class="cm"> * Copyright (c) 2003-2005  Matthew Wilcox &lt;matthew@wil.cx&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * This driver is derived from the Linux sym53c8xx driver.</span>
<span class="cm"> * Copyright (C) 1998-2000  Gerard Roudier</span>
<span class="cm"> *</span>
<span class="cm"> * The sym53c8xx driver is derived from the ncr53c8xx driver that had been </span>
<span class="cm"> * a port of the FreeBSD ncr driver to Linux-1.2.13.</span>
<span class="cm"> *</span>
<span class="cm"> * The original ncr driver has been written for 386bsd and FreeBSD by</span>
<span class="cm"> *         Wolfgang Stanglmeier        &lt;wolf@cologne.de&gt;</span>
<span class="cm"> *         Stefan Esser                &lt;se@mi.Uni-Koeln.de&gt;</span>
<span class="cm"> * Copyright (C) 1994  Wolfgang Stanglmeier</span>
<span class="cm"> *</span>
<span class="cm"> * Other major contributions:</span>
<span class="cm"> *</span>
<span class="cm"> * NVRAM detection and reading.</span>
<span class="cm"> * Copyright (C) 1997 Richard Waltham &lt;dormouse@farsrobt.demon.co.uk&gt;</span>
<span class="cm"> *</span>
<span class="cm"> *-----------------------------------------------------------------------------</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or modify</span>
<span class="cm"> * it under the terms of the GNU General Public License as published by</span>
<span class="cm"> * the Free Software Foundation; either version 2 of the License, or</span>
<span class="cm"> * (at your option) any later version.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is distributed in the hope that it will be useful,</span>
<span class="cm"> * but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="cm"> * GNU General Public License for more details.</span>
<span class="cm"> *</span>
<span class="cm"> * You should have received a copy of the GNU General Public License</span>
<span class="cm"> * along with this program; if not, write to the Free Software</span>
<span class="cm"> * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA</span>
<span class="cm"> */</span>
<span class="cp">#include &lt;linux/ctype.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/moduleparam.h&gt;</span>
<span class="cp">#include &lt;linux/spinlock.h&gt;</span>
<span class="cp">#include &lt;scsi/scsi.h&gt;</span>
<span class="cp">#include &lt;scsi/scsi_tcq.h&gt;</span>
<span class="cp">#include &lt;scsi/scsi_device.h&gt;</span>
<span class="cp">#include &lt;scsi/scsi_transport.h&gt;</span>

<span class="cp">#include &quot;sym_glue.h&quot;</span>
<span class="cp">#include &quot;sym_nvram.h&quot;</span>

<span class="cp">#define NAME53C		&quot;sym53c&quot;</span>
<span class="cp">#define NAME53C8XX	&quot;sym53c8xx&quot;</span>

<span class="k">struct</span> <span class="n">sym_driver_setup</span> <span class="n">sym_driver_setup</span> <span class="o">=</span> <span class="n">SYM_LINUX_DRIVER_SETUP</span><span class="p">;</span>
<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">sym_debug_flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">char</span> <span class="o">*</span><span class="n">excl_string</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">char</span> <span class="o">*</span><span class="n">safe_string</span><span class="p">;</span>
<span class="n">module_param_named</span><span class="p">(</span><span class="n">cmd_per_lun</span><span class="p">,</span> <span class="n">sym_driver_setup</span><span class="p">.</span><span class="n">max_tag</span><span class="p">,</span> <span class="n">ushort</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="n">module_param_named</span><span class="p">(</span><span class="n">burst</span><span class="p">,</span> <span class="n">sym_driver_setup</span><span class="p">.</span><span class="n">burst_order</span><span class="p">,</span> <span class="n">byte</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="n">module_param_named</span><span class="p">(</span><span class="n">led</span><span class="p">,</span> <span class="n">sym_driver_setup</span><span class="p">.</span><span class="n">scsi_led</span><span class="p">,</span> <span class="n">byte</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="n">module_param_named</span><span class="p">(</span><span class="n">diff</span><span class="p">,</span> <span class="n">sym_driver_setup</span><span class="p">.</span><span class="n">scsi_diff</span><span class="p">,</span> <span class="n">byte</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="n">module_param_named</span><span class="p">(</span><span class="n">irqm</span><span class="p">,</span> <span class="n">sym_driver_setup</span><span class="p">.</span><span class="n">irq_mode</span><span class="p">,</span> <span class="n">byte</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="n">module_param_named</span><span class="p">(</span><span class="n">buschk</span><span class="p">,</span> <span class="n">sym_driver_setup</span><span class="p">.</span><span class="n">scsi_bus_check</span><span class="p">,</span> <span class="n">byte</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="n">module_param_named</span><span class="p">(</span><span class="n">hostid</span><span class="p">,</span> <span class="n">sym_driver_setup</span><span class="p">.</span><span class="n">host_id</span><span class="p">,</span> <span class="n">byte</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="n">module_param_named</span><span class="p">(</span><span class="n">verb</span><span class="p">,</span> <span class="n">sym_driver_setup</span><span class="p">.</span><span class="n">verbose</span><span class="p">,</span> <span class="n">byte</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="n">module_param_named</span><span class="p">(</span><span class="n">debug</span><span class="p">,</span> <span class="n">sym_debug_flags</span><span class="p">,</span> <span class="n">uint</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="n">module_param_named</span><span class="p">(</span><span class="n">settle</span><span class="p">,</span> <span class="n">sym_driver_setup</span><span class="p">.</span><span class="n">settle_delay</span><span class="p">,</span> <span class="n">byte</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="n">module_param_named</span><span class="p">(</span><span class="n">nvram</span><span class="p">,</span> <span class="n">sym_driver_setup</span><span class="p">.</span><span class="n">use_nvram</span><span class="p">,</span> <span class="n">byte</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="n">module_param_named</span><span class="p">(</span><span class="n">excl</span><span class="p">,</span> <span class="n">excl_string</span><span class="p">,</span> <span class="n">charp</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="n">module_param_named</span><span class="p">(</span><span class="n">safe</span><span class="p">,</span> <span class="n">safe_string</span><span class="p">,</span> <span class="n">charp</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">cmd_per_lun</span><span class="p">,</span> <span class="s">&quot;The maximum number of tags to use by default&quot;</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">burst</span><span class="p">,</span> <span class="s">&quot;Maximum burst.  0 to disable, 255 to read from registers&quot;</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">led</span><span class="p">,</span> <span class="s">&quot;Set to 1 to enable LED support&quot;</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">diff</span><span class="p">,</span> <span class="s">&quot;0 for no differential mode, 1 for BIOS, 2 for always, 3 for not GPIO3&quot;</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">irqm</span><span class="p">,</span> <span class="s">&quot;0 for open drain, 1 to leave alone, 2 for totem pole&quot;</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">buschk</span><span class="p">,</span> <span class="s">&quot;0 to not check, 1 for detach on error, 2 for warn on error&quot;</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">hostid</span><span class="p">,</span> <span class="s">&quot;The SCSI ID to use for the host adapters&quot;</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">verb</span><span class="p">,</span> <span class="s">&quot;0 for minimal verbosity, 1 for normal, 2 for excessive&quot;</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">debug</span><span class="p">,</span> <span class="s">&quot;Set bits to enable debugging&quot;</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">settle</span><span class="p">,</span> <span class="s">&quot;Settle delay in seconds.  Default 3&quot;</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">nvram</span><span class="p">,</span> <span class="s">&quot;Option currently not used&quot;</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">excl</span><span class="p">,</span> <span class="s">&quot;List ioport addresses here to prevent controllers from being attached&quot;</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">safe</span><span class="p">,</span> <span class="s">&quot;Set other settings to a </span><span class="se">\&quot;</span><span class="s">safe mode</span><span class="se">\&quot;</span><span class="s">&quot;</span><span class="p">);</span>

<span class="n">MODULE_LICENSE</span><span class="p">(</span><span class="s">&quot;GPL&quot;</span><span class="p">);</span>
<span class="n">MODULE_VERSION</span><span class="p">(</span><span class="n">SYM_VERSION</span><span class="p">);</span>
<span class="n">MODULE_AUTHOR</span><span class="p">(</span><span class="s">&quot;Matthew Wilcox &lt;matthew@wil.cx&gt;&quot;</span><span class="p">);</span>
<span class="n">MODULE_DESCRIPTION</span><span class="p">(</span><span class="s">&quot;NCR, Symbios and LSI 8xx and 1010 PCI SCSI adapters&quot;</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">sym2_setup_params</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">excl_string</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">xi</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">p</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">xi</span> <span class="o">&lt;</span> <span class="mi">8</span><span class="p">))</span> <span class="p">{</span>
		<span class="kt">char</span> <span class="o">*</span><span class="n">next_p</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">val</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="n">simple_strtoul</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">next_p</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">sym_driver_setup</span><span class="p">.</span><span class="n">excludes</span><span class="p">[</span><span class="n">xi</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span><span class="p">;</span>
		<span class="n">p</span> <span class="o">=</span> <span class="n">next_p</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">safe_string</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">safe_string</span> <span class="o">==</span> <span class="sc">&#39;y&#39;</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">sym_driver_setup</span><span class="p">.</span><span class="n">max_tag</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">sym_driver_setup</span><span class="p">.</span><span class="n">burst_order</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">sym_driver_setup</span><span class="p">.</span><span class="n">scsi_led</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">sym_driver_setup</span><span class="p">.</span><span class="n">scsi_diff</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">sym_driver_setup</span><span class="p">.</span><span class="n">irq_mode</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">sym_driver_setup</span><span class="p">.</span><span class="n">scsi_bus_check</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
			<span class="n">sym_driver_setup</span><span class="p">.</span><span class="n">host_id</span> <span class="o">=</span> <span class="mi">7</span><span class="p">;</span>
			<span class="n">sym_driver_setup</span><span class="p">.</span><span class="n">verbose</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
			<span class="n">sym_driver_setup</span><span class="p">.</span><span class="n">settle_delay</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
			<span class="n">sym_driver_setup</span><span class="p">.</span><span class="n">use_nvram</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">safe_string</span> <span class="o">!=</span> <span class="sc">&#39;n&#39;</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="n">NAME53C8XX</span> <span class="s">&quot;Ignoring parameter %s&quot;</span>
					<span class="s">&quot; passed to safe option&quot;</span><span class="p">,</span> <span class="n">safe_string</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">scsi_transport_template</span> <span class="o">*</span><span class="n">sym2_transport_template</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> *  Driver private area in the SCSI command structure.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">sym_ucmd</span> <span class="p">{</span>		<span class="cm">/* Override the SCSI pointer structure */</span>
	<span class="k">struct</span> <span class="n">completion</span> <span class="o">*</span><span class="n">eh_done</span><span class="p">;</span>		<span class="cm">/* SCSI error handling */</span>
<span class="p">};</span>

<span class="cp">#define SYM_UCMD_PTR(cmd)  ((struct sym_ucmd *)(&amp;(cmd)-&gt;SCp))</span>
<span class="cp">#define SYM_SOFTC_PTR(cmd) sym_get_hcb(cmd-&gt;device-&gt;host)</span>

<span class="cm">/*</span>
<span class="cm"> *  Complete a pending CAM CCB.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">sym_xpt_done</span><span class="p">(</span><span class="k">struct</span> <span class="n">sym_hcb</span> <span class="o">*</span><span class="n">np</span><span class="p">,</span> <span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sym_ucmd</span> <span class="o">*</span><span class="n">ucmd</span> <span class="o">=</span> <span class="n">SYM_UCMD_PTR</span><span class="p">(</span><span class="n">cmd</span><span class="p">);</span>
	<span class="n">BUILD_BUG_ON</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_pointer</span><span class="p">)</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sym_ucmd</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ucmd</span><span class="o">-&gt;</span><span class="n">eh_done</span><span class="p">)</span>
		<span class="n">complete</span><span class="p">(</span><span class="n">ucmd</span><span class="o">-&gt;</span><span class="n">eh_done</span><span class="p">);</span>

	<span class="n">scsi_dma_unmap</span><span class="p">(</span><span class="n">cmd</span><span class="p">);</span>
	<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scsi_done</span><span class="p">(</span><span class="n">cmd</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *  Tell the SCSI layer about a BUS RESET.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">sym_xpt_async_bus_reset</span><span class="p">(</span><span class="k">struct</span> <span class="n">sym_hcb</span> <span class="o">*</span><span class="n">np</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">printf_notice</span><span class="p">(</span><span class="s">&quot;%s: SCSI BUS has been reset.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">sym_name</span><span class="p">(</span><span class="n">np</span><span class="p">));</span>
	<span class="n">np</span><span class="o">-&gt;</span><span class="n">s</span><span class="p">.</span><span class="n">settle_time</span> <span class="o">=</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="n">sym_driver_setup</span><span class="p">.</span><span class="n">settle_delay</span> <span class="o">*</span> <span class="n">HZ</span><span class="p">;</span>
	<span class="n">np</span><span class="o">-&gt;</span><span class="n">s</span><span class="p">.</span><span class="n">settle_time_valid</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sym_verbose</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">)</span>
		<span class="n">printf_info</span><span class="p">(</span><span class="s">&quot;%s: command processing suspended for %d seconds</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			    <span class="n">sym_name</span><span class="p">(</span><span class="n">np</span><span class="p">),</span> <span class="n">sym_driver_setup</span><span class="p">.</span><span class="n">settle_delay</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *  Choose the more appropriate CAM status if </span>
<span class="cm"> *  the IO encountered an extended error.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">sym_xerr_cam_status</span><span class="p">(</span><span class="kt">int</span> <span class="n">cam_status</span><span class="p">,</span> <span class="kt">int</span> <span class="n">x_status</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">x_status</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span>	<span class="p">(</span><span class="n">x_status</span> <span class="o">&amp;</span> <span class="n">XE_PARITY_ERR</span><span class="p">)</span>
			<span class="n">cam_status</span> <span class="o">=</span> <span class="n">DID_PARITY</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span>	<span class="p">(</span><span class="n">x_status</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">XE_EXTRA_DATA</span><span class="o">|</span><span class="n">XE_SODL_UNRUN</span><span class="o">|</span><span class="n">XE_SWIDE_OVRUN</span><span class="p">))</span>
			<span class="n">cam_status</span> <span class="o">=</span> <span class="n">DID_ERROR</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span>	<span class="p">(</span><span class="n">x_status</span> <span class="o">&amp;</span> <span class="n">XE_BAD_PHASE</span><span class="p">)</span>
			<span class="n">cam_status</span> <span class="o">=</span> <span class="n">DID_ERROR</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">cam_status</span> <span class="o">=</span> <span class="n">DID_ERROR</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">cam_status</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *  Build CAM result for a failed or auto-sensed IO.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">sym_set_cam_result_error</span><span class="p">(</span><span class="k">struct</span> <span class="n">sym_hcb</span> <span class="o">*</span><span class="n">np</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sym_ccb</span> <span class="o">*</span><span class="n">cp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">resid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="n">cmd</span> <span class="o">=</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">cmd</span><span class="p">;</span>
	<span class="n">u_int</span> <span class="n">cam_status</span><span class="p">,</span> <span class="n">scsi_status</span><span class="p">,</span> <span class="n">drv_status</span><span class="p">;</span>

	<span class="n">drv_status</span>  <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">cam_status</span>  <span class="o">=</span> <span class="n">DID_OK</span><span class="p">;</span>
	<span class="n">scsi_status</span> <span class="o">=</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">ssss_status</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">host_flags</span> <span class="o">&amp;</span> <span class="n">HF_SENSE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">scsi_status</span> <span class="o">=</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">sv_scsi_status</span><span class="p">;</span>
		<span class="n">resid</span> <span class="o">=</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">sv_resid</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sym_verbose</span> <span class="o">&amp;&amp;</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">sv_xerr_status</span><span class="p">)</span>
			<span class="n">sym_print_xerr</span><span class="p">(</span><span class="n">cmd</span><span class="p">,</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">sv_xerr_status</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">host_status</span> <span class="o">==</span> <span class="n">HS_COMPLETE</span> <span class="o">&amp;&amp;</span>
		    <span class="n">cp</span><span class="o">-&gt;</span><span class="n">ssss_status</span> <span class="o">==</span> <span class="n">S_GOOD</span> <span class="o">&amp;&amp;</span>
		    <span class="n">cp</span><span class="o">-&gt;</span><span class="n">xerr_status</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">cam_status</span> <span class="o">=</span> <span class="n">sym_xerr_cam_status</span><span class="p">(</span><span class="n">DID_OK</span><span class="p">,</span>
							 <span class="n">cp</span><span class="o">-&gt;</span><span class="n">sv_xerr_status</span><span class="p">);</span>
			<span class="n">drv_status</span> <span class="o">=</span> <span class="n">DRIVER_SENSE</span><span class="p">;</span>
			<span class="cm">/*</span>
<span class="cm">			 *  Bounce back the sense data to user.</span>
<span class="cm">			 */</span>
			<span class="n">memset</span><span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">sense_buffer</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">SCSI_SENSE_BUFFERSIZE</span><span class="p">);</span>
			<span class="n">memcpy</span><span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">sense_buffer</span><span class="p">,</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">sns_bbuf</span><span class="p">,</span>
			       <span class="n">min</span><span class="p">(</span><span class="n">SCSI_SENSE_BUFFERSIZE</span><span class="p">,</span> <span class="n">SYM_SNS_BBUF_LEN</span><span class="p">));</span>
<span class="cp">#if 0</span><span class="c"></span>
<span class="c">			/*</span>
<span class="c">			 *  If the device reports a UNIT ATTENTION condition </span>
<span class="c">			 *  due to a RESET condition, we should consider all </span>
<span class="c">			 *  disconnect CCBs for this unit as aborted.</span>
<span class="c">			 */</span>
<span class="c">			if (1) {</span>
<span class="c">				u_char *p;</span>
<span class="c">				p  = (u_char *) cmd-&gt;sense_data;</span>
<span class="c">				if (p[0]==0x70 &amp;&amp; p[2]==0x6 &amp;&amp; p[12]==0x29)</span>
<span class="c">					sym_clear_tasks(np, DID_ABORT,</span>
<span class="c">							cp-&gt;target,cp-&gt;lun, -1);</span>
<span class="c">			}</span>
<span class="cp">#endif</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * Error return from our internal request sense.  This</span>
<span class="cm">			 * is bad: we must clear the contingent allegiance</span>
<span class="cm">			 * condition otherwise the device will always return</span>
<span class="cm">			 * BUSY.  Use a big stick.</span>
<span class="cm">			 */</span>
			<span class="n">sym_reset_scsi_target</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">);</span>
			<span class="n">cam_status</span> <span class="o">=</span> <span class="n">DID_ERROR</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">host_status</span> <span class="o">==</span> <span class="n">HS_COMPLETE</span><span class="p">)</span> 	<span class="cm">/* Bad SCSI status */</span>
		<span class="n">cam_status</span> <span class="o">=</span> <span class="n">DID_OK</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">host_status</span> <span class="o">==</span> <span class="n">HS_SEL_TIMEOUT</span><span class="p">)</span>	<span class="cm">/* Selection timeout */</span>
		<span class="n">cam_status</span> <span class="o">=</span> <span class="n">DID_NO_CONNECT</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">host_status</span> <span class="o">==</span> <span class="n">HS_UNEXPECTED</span><span class="p">)</span>	<span class="cm">/* Unexpected BUS FREE*/</span>
		<span class="n">cam_status</span> <span class="o">=</span> <span class="n">DID_ERROR</span><span class="p">;</span>
	<span class="k">else</span> <span class="p">{</span>						<span class="cm">/* Extended error */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sym_verbose</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">sym_print_addr</span><span class="p">(</span><span class="n">cmd</span><span class="p">,</span> <span class="s">&quot;COMMAND FAILED (%x %x %x).</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">cp</span><span class="o">-&gt;</span><span class="n">host_status</span><span class="p">,</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">ssss_status</span><span class="p">,</span>
				<span class="n">cp</span><span class="o">-&gt;</span><span class="n">xerr_status</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="cm">/*</span>
<span class="cm">		 *  Set the most appropriate value for CAM status.</span>
<span class="cm">		 */</span>
		<span class="n">cam_status</span> <span class="o">=</span> <span class="n">sym_xerr_cam_status</span><span class="p">(</span><span class="n">DID_ERROR</span><span class="p">,</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">xerr_status</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">scsi_set_resid</span><span class="p">(</span><span class="n">cmd</span><span class="p">,</span> <span class="n">resid</span><span class="p">);</span>
	<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">=</span> <span class="p">(</span><span class="n">drv_status</span> <span class="o">&lt;&lt;</span> <span class="mi">24</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">cam_status</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">+</span> <span class="n">scsi_status</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">sym_scatter</span><span class="p">(</span><span class="k">struct</span> <span class="n">sym_hcb</span> <span class="o">*</span><span class="n">np</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sym_ccb</span> <span class="o">*</span><span class="n">cp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">segment</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">use_sg</span><span class="p">;</span>

	<span class="n">cp</span><span class="o">-&gt;</span><span class="n">data_len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">use_sg</span> <span class="o">=</span> <span class="n">scsi_dma_map</span><span class="p">(</span><span class="n">cmd</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">use_sg</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">scatterlist</span> <span class="o">*</span><span class="n">sg</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">sym_tcb</span> <span class="o">*</span><span class="n">tp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">target</span><span class="p">[</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">target</span><span class="p">];</span>
		<span class="k">struct</span> <span class="n">sym_tblmove</span> <span class="o">*</span><span class="n">data</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">use_sg</span> <span class="o">&gt;</span> <span class="n">SYM_CONF_MAX_SG</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">scsi_dma_unmap</span><span class="p">(</span><span class="n">cmd</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">data</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">phys</span><span class="p">.</span><span class="n">data</span><span class="p">[</span><span class="n">SYM_CONF_MAX_SG</span> <span class="o">-</span> <span class="n">use_sg</span><span class="p">];</span>

		<span class="n">scsi_for_each_sg</span><span class="p">(</span><span class="n">cmd</span><span class="p">,</span> <span class="n">sg</span><span class="p">,</span> <span class="n">use_sg</span><span class="p">,</span> <span class="n">segment</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dma_addr_t</span> <span class="n">baddr</span> <span class="o">=</span> <span class="n">sg_dma_address</span><span class="p">(</span><span class="n">sg</span><span class="p">);</span>
			<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="n">sg_dma_len</span><span class="p">(</span><span class="n">sg</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">((</span><span class="n">len</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">.</span><span class="n">wval</span> <span class="o">&amp;</span> <span class="n">EWS</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">len</span><span class="o">++</span><span class="p">;</span>
				<span class="n">cp</span><span class="o">-&gt;</span><span class="n">odd_byte_adjustment</span><span class="o">++</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="n">sym_build_sge</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">data</span><span class="p">[</span><span class="n">segment</span><span class="p">],</span> <span class="n">baddr</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
			<span class="n">cp</span><span class="o">-&gt;</span><span class="n">data_len</span> <span class="o">+=</span> <span class="n">len</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">segment</span> <span class="o">=</span> <span class="o">-</span><span class="mi">2</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">segment</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *  Queue a SCSI command.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">sym_queue_command</span><span class="p">(</span><span class="k">struct</span> <span class="n">sym_hcb</span> <span class="o">*</span><span class="n">np</span><span class="p">,</span> <span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="n">sdev</span> <span class="o">=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">device</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sym_tcb</span> <span class="o">*</span><span class="n">tp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sym_lcb</span> <span class="o">*</span><span class="n">lp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sym_ccb</span> <span class="o">*</span><span class="n">cp</span><span class="p">;</span>
	<span class="kt">int</span>	<span class="n">order</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 *  Retrieve the target descriptor.</span>
<span class="cm">	 */</span>
	<span class="n">tp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">target</span><span class="p">[</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">];</span>

	<span class="cm">/*</span>
<span class="cm">	 *  Select tagged/untagged.</span>
<span class="cm">	 */</span>
	<span class="n">lp</span> <span class="o">=</span> <span class="n">sym_lp</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">sdev</span><span class="o">-&gt;</span><span class="n">lun</span><span class="p">);</span>
	<span class="n">order</span> <span class="o">=</span> <span class="p">(</span><span class="n">lp</span> <span class="o">&amp;&amp;</span> <span class="n">lp</span><span class="o">-&gt;</span><span class="n">s</span><span class="p">.</span><span class="n">reqtags</span><span class="p">)</span> <span class="o">?</span> <span class="n">M_SIMPLE_TAG</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 *  Queue the SCSI IO.</span>
<span class="cm">	 */</span>
	<span class="n">cp</span> <span class="o">=</span> <span class="n">sym_get_ccb</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">cmd</span><span class="p">,</span> <span class="n">order</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cp</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>	<span class="cm">/* Means resource shortage */</span>
	<span class="n">sym_queue_scsiio</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">cmd</span><span class="p">,</span> <span class="n">cp</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *  Setup buffers and pointers that address the CDB.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">sym_setup_cdb</span><span class="p">(</span><span class="k">struct</span> <span class="n">sym_hcb</span> <span class="o">*</span><span class="n">np</span><span class="p">,</span> <span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sym_ccb</span> <span class="o">*</span><span class="n">cp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">cdb_buf</span><span class="p">,</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">,</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">cmd_len</span><span class="p">);</span>

	<span class="n">cp</span><span class="o">-&gt;</span><span class="n">phys</span><span class="p">.</span><span class="n">cmd</span><span class="p">.</span><span class="n">addr</span> <span class="o">=</span> <span class="n">CCB_BA</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">cdb_buf</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
	<span class="n">cp</span><span class="o">-&gt;</span><span class="n">phys</span><span class="p">.</span><span class="n">cmd</span><span class="p">.</span><span class="n">size</span> <span class="o">=</span> <span class="n">cpu_to_scr</span><span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">cmd_len</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *  Setup pointers that address the data and start the I/O.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">sym_setup_data_and_start</span><span class="p">(</span><span class="k">struct</span> <span class="n">sym_hcb</span> <span class="o">*</span><span class="n">np</span><span class="p">,</span> <span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sym_ccb</span> <span class="o">*</span><span class="n">cp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">lastp</span><span class="p">,</span> <span class="n">goalp</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">dir</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 *  Build the CDB.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sym_setup_cdb</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">cmd</span><span class="p">,</span> <span class="n">cp</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out_abort</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 *  No direction means no data.</span>
<span class="cm">	 */</span>
	<span class="n">dir</span> <span class="o">=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">sc_data_direction</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dir</span> <span class="o">!=</span> <span class="n">DMA_NONE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cp</span><span class="o">-&gt;</span><span class="n">segments</span> <span class="o">=</span> <span class="n">sym_scatter</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">cp</span><span class="p">,</span> <span class="n">cmd</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">segments</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">sym_set_cam_status</span><span class="p">(</span><span class="n">cmd</span><span class="p">,</span> <span class="n">DID_ERROR</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">out_abort</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 *  No segments means no data.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">segments</span><span class="p">)</span>
			<span class="n">dir</span> <span class="o">=</span> <span class="n">DMA_NONE</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">cp</span><span class="o">-&gt;</span><span class="n">data_len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">cp</span><span class="o">-&gt;</span><span class="n">segments</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 *  Set the data pointer.</span>
<span class="cm">	 */</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">dir</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">DMA_BIDIRECTIONAL</span>:
		<span class="n">scmd_printk</span><span class="p">(</span><span class="n">KERN_INFO</span><span class="p">,</span> <span class="n">cmd</span><span class="p">,</span> <span class="s">&quot;got DMA_BIDIRECTIONAL command&quot;</span><span class="p">);</span>
		<span class="n">sym_set_cam_status</span><span class="p">(</span><span class="n">cmd</span><span class="p">,</span> <span class="n">DID_ERROR</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_abort</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">DMA_TO_DEVICE</span>:
		<span class="n">goalp</span> <span class="o">=</span> <span class="n">SCRIPTA_BA</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">data_out2</span><span class="p">)</span> <span class="o">+</span> <span class="mi">8</span><span class="p">;</span>
		<span class="n">lastp</span> <span class="o">=</span> <span class="n">goalp</span> <span class="o">-</span> <span class="mi">8</span> <span class="o">-</span> <span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">segments</span> <span class="o">*</span> <span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="mi">4</span><span class="p">));</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">DMA_FROM_DEVICE</span>:
		<span class="n">cp</span><span class="o">-&gt;</span><span class="n">host_flags</span> <span class="o">|=</span> <span class="n">HF_DATA_IN</span><span class="p">;</span>
		<span class="n">goalp</span> <span class="o">=</span> <span class="n">SCRIPTA_BA</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">data_in2</span><span class="p">)</span> <span class="o">+</span> <span class="mi">8</span><span class="p">;</span>
		<span class="n">lastp</span> <span class="o">=</span> <span class="n">goalp</span> <span class="o">-</span> <span class="mi">8</span> <span class="o">-</span> <span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">segments</span> <span class="o">*</span> <span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="mi">4</span><span class="p">));</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">DMA_NONE</span>:
	<span class="nl">default:</span>
		<span class="n">lastp</span> <span class="o">=</span> <span class="n">goalp</span> <span class="o">=</span> <span class="n">SCRIPTB_BA</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">no_data</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 *  Set all pointers values needed by SCRIPTS.</span>
<span class="cm">	 */</span>
	<span class="n">cp</span><span class="o">-&gt;</span><span class="n">phys</span><span class="p">.</span><span class="n">head</span><span class="p">.</span><span class="n">lastp</span> <span class="o">=</span> <span class="n">cpu_to_scr</span><span class="p">(</span><span class="n">lastp</span><span class="p">);</span>
	<span class="n">cp</span><span class="o">-&gt;</span><span class="n">phys</span><span class="p">.</span><span class="n">head</span><span class="p">.</span><span class="n">savep</span> <span class="o">=</span> <span class="n">cpu_to_scr</span><span class="p">(</span><span class="n">lastp</span><span class="p">);</span>
	<span class="n">cp</span><span class="o">-&gt;</span><span class="n">startp</span>	    <span class="o">=</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">phys</span><span class="p">.</span><span class="n">head</span><span class="p">.</span><span class="n">savep</span><span class="p">;</span>
	<span class="n">cp</span><span class="o">-&gt;</span><span class="n">goalp</span>	    <span class="o">=</span> <span class="n">cpu_to_scr</span><span class="p">(</span><span class="n">goalp</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 *  When `#ifed 1&#39;, the code below makes the driver </span>
<span class="cm">	 *  panic on the first attempt to write to a SCSI device.</span>
<span class="cm">	 *  It is the first test we want to do after a driver </span>
<span class="cm">	 *  change that does not seem obviously safe. :)</span>
<span class="cm">	 */</span>
<span class="cp">#if 0</span><span class="c"></span>
<span class="c">	switch (cp-&gt;cdb_buf[0]) {</span>
<span class="c">	case 0x0A: case 0x2A: case 0xAA:</span>
<span class="c">		panic(&quot;XXXXXXXXXXXXX WRITE NOT YET ALLOWED XXXXXXXXXXXXXX\n&quot;);</span>
<span class="c">		break;</span>
<span class="c">	default:</span>
<span class="c">		break;</span>
<span class="c">	}</span>
<span class="cp">#endif</span>

	<span class="cm">/*</span>
<span class="cm">	 *	activate this job.</span>
<span class="cm">	 */</span>
	<span class="n">sym_put_start_queue</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">cp</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">out_abort:</span>
	<span class="n">sym_free_ccb</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">cp</span><span class="p">);</span>
	<span class="n">sym_xpt_done</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">cmd</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> *  timer daemon.</span>
<span class="cm"> *</span>
<span class="cm"> *  Misused to keep the driver running when</span>
<span class="cm"> *  interrupts are not configured correctly.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">sym_timer</span><span class="p">(</span><span class="k">struct</span> <span class="n">sym_hcb</span> <span class="o">*</span><span class="n">np</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">thistime</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 *  Restart the timer.</span>
<span class="cm">	 */</span>
	<span class="n">np</span><span class="o">-&gt;</span><span class="n">s</span><span class="p">.</span><span class="n">timer</span><span class="p">.</span><span class="n">expires</span> <span class="o">=</span> <span class="n">thistime</span> <span class="o">+</span> <span class="n">SYM_CONF_TIMER_INTERVAL</span><span class="p">;</span>
	<span class="n">add_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">s</span><span class="p">.</span><span class="n">timer</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 *  If we are resetting the ncr, wait for settle_time before </span>
<span class="cm">	 *  clearing it. Then command processing will be resumed.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">s</span><span class="p">.</span><span class="n">settle_time_valid</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">time_before_eq</span><span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">s</span><span class="p">.</span><span class="n">settle_time</span><span class="p">,</span> <span class="n">thistime</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">sym_verbose</span> <span class="o">&gt;=</span> <span class="mi">2</span> <span class="p">)</span>
				<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%s: command processing resumed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				       <span class="n">sym_name</span><span class="p">(</span><span class="n">np</span><span class="p">));</span>
			<span class="n">np</span><span class="o">-&gt;</span><span class="n">s</span><span class="p">.</span><span class="n">settle_time_valid</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 *	Nothing to do for now, but that may come.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">s</span><span class="p">.</span><span class="n">lasttime</span> <span class="o">+</span> <span class="mi">4</span><span class="o">*</span><span class="n">HZ</span> <span class="o">&lt;</span> <span class="n">thistime</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">np</span><span class="o">-&gt;</span><span class="n">s</span><span class="p">.</span><span class="n">lasttime</span> <span class="o">=</span> <span class="n">thistime</span><span class="p">;</span>
	<span class="p">}</span>

<span class="cp">#ifdef SYM_CONF_PCIQ_MAY_MISS_COMPLETIONS</span>
	<span class="cm">/*</span>
<span class="cm">	 *  Some way-broken PCI bridges may lead to </span>
<span class="cm">	 *  completions being lost when the clearing </span>
<span class="cm">	 *  of the INTFLY flag by the CPU occurs </span>
<span class="cm">	 *  concurrently with the chip raising this flag.</span>
<span class="cm">	 *  If this ever happen, lost completions will </span>
<span class="cm">	 * be reaped here.</span>
<span class="cm">	 */</span>
	<span class="n">sym_wakeup_done</span><span class="p">(</span><span class="n">np</span><span class="p">);</span>
<span class="cp">#endif</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> *  PCI BUS error handler.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">sym_log_bus_error</span><span class="p">(</span><span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sym_data</span> <span class="o">*</span><span class="n">sym_data</span> <span class="o">=</span> <span class="n">shost_priv</span><span class="p">(</span><span class="n">shost</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span> <span class="o">=</span> <span class="n">sym_data</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">pci_sts</span><span class="p">;</span>
	<span class="n">pci_read_config_word</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">PCI_STATUS</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pci_sts</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pci_sts</span> <span class="o">&amp;</span> <span class="mh">0xf900</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pci_write_config_word</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">PCI_STATUS</span><span class="p">,</span> <span class="n">pci_sts</span><span class="p">);</span>
		<span class="n">shost_printk</span><span class="p">(</span><span class="n">KERN_WARNING</span><span class="p">,</span> <span class="n">shost</span><span class="p">,</span>
			<span class="s">&quot;PCI bus error: status = 0x%04x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">pci_sts</span> <span class="o">&amp;</span> <span class="mh">0xf900</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * queuecommand method.  Entered with the host adapter lock held and</span>
<span class="cm"> * interrupts disabled.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">sym53c8xx_queue_command_lck</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">,</span>
					<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">done</span><span class="p">)(</span><span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="p">))</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sym_hcb</span> <span class="o">*</span><span class="n">np</span> <span class="o">=</span> <span class="n">SYM_SOFTC_PTR</span><span class="p">(</span><span class="n">cmd</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">sym_ucmd</span> <span class="o">*</span><span class="n">ucp</span> <span class="o">=</span> <span class="n">SYM_UCMD_PTR</span><span class="p">(</span><span class="n">cmd</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">sts</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scsi_done</span> <span class="o">=</span> <span class="n">done</span><span class="p">;</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">ucp</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">ucp</span><span class="p">));</span>

	<span class="cm">/*</span>
<span class="cm">	 *  Shorten our settle_time if needed for </span>
<span class="cm">	 *  this command not to time out.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">s</span><span class="p">.</span><span class="n">settle_time_valid</span> <span class="o">&amp;&amp;</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">request</span><span class="o">-&gt;</span><span class="n">timeout</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">tlimit</span> <span class="o">=</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">request</span><span class="o">-&gt;</span><span class="n">timeout</span><span class="p">;</span>
		<span class="n">tlimit</span> <span class="o">-=</span> <span class="n">SYM_CONF_TIMER_INTERVAL</span><span class="o">*</span><span class="mi">2</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">time_after</span><span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">s</span><span class="p">.</span><span class="n">settle_time</span><span class="p">,</span> <span class="n">tlimit</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">np</span><span class="o">-&gt;</span><span class="n">s</span><span class="p">.</span><span class="n">settle_time</span> <span class="o">=</span> <span class="n">tlimit</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">s</span><span class="p">.</span><span class="n">settle_time_valid</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">SCSI_MLQUEUE_HOST_BUSY</span><span class="p">;</span>

	<span class="n">sts</span> <span class="o">=</span> <span class="n">sym_queue_command</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">cmd</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sts</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">SCSI_MLQUEUE_HOST_BUSY</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="nf">DEF_SCSI_QCMD</span><span class="p">(</span><span class="n">sym53c8xx_queue_command</span><span class="p">)</span>

<span class="cm">/*</span>
<span class="cm"> *  Linux entry point of the interrupt handler.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">irqreturn_t</span> <span class="n">sym53c8xx_intr</span><span class="p">(</span><span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">dev_id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span> <span class="o">=</span> <span class="n">dev_id</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sym_data</span> <span class="o">*</span><span class="n">sym_data</span> <span class="o">=</span> <span class="n">shost_priv</span><span class="p">(</span><span class="n">shost</span><span class="p">);</span>
	<span class="n">irqreturn_t</span> <span class="n">result</span><span class="p">;</span>

	<span class="cm">/* Avoid spinloop trying to handle interrupts on frozen device */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pci_channel_offline</span><span class="p">(</span><span class="n">sym_data</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">IRQ_NONE</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">DEBUG_FLAGS</span> <span class="o">&amp;</span> <span class="n">DEBUG_TINY</span><span class="p">)</span> <span class="n">printf_debug</span> <span class="p">(</span><span class="s">&quot;[&quot;</span><span class="p">);</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>
	<span class="n">result</span> <span class="o">=</span> <span class="n">sym_interrupt</span><span class="p">(</span><span class="n">shost</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">DEBUG_FLAGS</span> <span class="o">&amp;</span> <span class="n">DEBUG_TINY</span><span class="p">)</span> <span class="n">printf_debug</span> <span class="p">(</span><span class="s">&quot;]</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *  Linux entry point of the timer handler</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">sym53c8xx_timer</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">npref</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sym_hcb</span> <span class="o">*</span><span class="n">np</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sym_hcb</span> <span class="o">*</span><span class="p">)</span><span class="n">npref</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">s</span><span class="p">.</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">sym_timer</span><span class="p">(</span><span class="n">np</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">s</span><span class="p">.</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> *  What the eh thread wants us to perform.</span>
<span class="cm"> */</span>
<span class="cp">#define SYM_EH_ABORT		0</span>
<span class="cp">#define SYM_EH_DEVICE_RESET	1</span>
<span class="cp">#define SYM_EH_BUS_RESET	2</span>
<span class="cp">#define SYM_EH_HOST_RESET	3</span>

<span class="cm">/*</span>
<span class="cm"> *  Generic method for our eh processing.</span>
<span class="cm"> *  The &#39;op&#39; argument tells what we have to do.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">sym_eh_handler</span><span class="p">(</span><span class="kt">int</span> <span class="n">op</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">opname</span><span class="p">,</span> <span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sym_ucmd</span> <span class="o">*</span><span class="n">ucmd</span> <span class="o">=</span> <span class="n">SYM_UCMD_PTR</span><span class="p">(</span><span class="n">cmd</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span> <span class="o">=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sym_data</span> <span class="o">*</span><span class="n">sym_data</span> <span class="o">=</span> <span class="n">shost_priv</span><span class="p">(</span><span class="n">shost</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span> <span class="o">=</span> <span class="n">sym_data</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sym_hcb</span> <span class="o">*</span><span class="n">np</span> <span class="o">=</span> <span class="n">sym_data</span><span class="o">-&gt;</span><span class="n">ncb</span><span class="p">;</span>
	<span class="n">SYM_QUEHEAD</span> <span class="o">*</span><span class="n">qp</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">cmd_queued</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">sts</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">completion</span> <span class="n">eh_done</span><span class="p">;</span>

	<span class="n">scmd_printk</span><span class="p">(</span><span class="n">KERN_WARNING</span><span class="p">,</span> <span class="n">cmd</span><span class="p">,</span> <span class="s">&quot;%s operation started</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">opname</span><span class="p">);</span>

	<span class="cm">/* We may be in an error condition because the PCI bus</span>
<span class="cm">	 * went down. In this case, we need to wait until the</span>
<span class="cm">	 * PCI bus is reset, the card is reset, and only then</span>
<span class="cm">	 * proceed with the scsi error recovery.  There&#39;s no</span>
<span class="cm">	 * point in hurrying; take a leisurely wait.</span>
<span class="cm">	 */</span>
<span class="cp">#define WAIT_FOR_PCI_RECOVERY	35</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pci_channel_offline</span><span class="p">(</span><span class="n">pdev</span><span class="p">))</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">finished_reset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">init_completion</span><span class="p">(</span><span class="o">&amp;</span><span class="n">eh_done</span><span class="p">);</span>
		<span class="n">spin_lock_irq</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>
		<span class="cm">/* Make sure we didn&#39;t race */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pci_channel_offline</span><span class="p">(</span><span class="n">pdev</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">BUG_ON</span><span class="p">(</span><span class="n">sym_data</span><span class="o">-&gt;</span><span class="n">io_reset</span><span class="p">);</span>
			<span class="n">sym_data</span><span class="o">-&gt;</span><span class="n">io_reset</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">eh_done</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">finished_reset</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">finished_reset</span><span class="p">)</span>
			<span class="n">finished_reset</span> <span class="o">=</span> <span class="n">wait_for_completion_timeout</span>
						<span class="p">(</span><span class="n">sym_data</span><span class="o">-&gt;</span><span class="n">io_reset</span><span class="p">,</span>
						<span class="n">WAIT_FOR_PCI_RECOVERY</span><span class="o">*</span><span class="n">HZ</span><span class="p">);</span>
		<span class="n">spin_lock_irq</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>
		<span class="n">sym_data</span><span class="o">-&gt;</span><span class="n">io_reset</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">finished_reset</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">SCSI_FAILED</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>
	<span class="cm">/* This one is queued in some place -&gt; to wait for completion */</span>
	<span class="n">FOR_EACH_QUEUED_ELEMENT</span><span class="p">(</span><span class="o">&amp;</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">busy_ccbq</span><span class="p">,</span> <span class="n">qp</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">sym_ccb</span> <span class="o">*</span><span class="n">cp</span> <span class="o">=</span> <span class="n">sym_que_entry</span><span class="p">(</span><span class="n">qp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sym_ccb</span><span class="p">,</span> <span class="n">link_ccbq</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">cmd</span> <span class="o">==</span> <span class="n">cmd</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">cmd_queued</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* Try to proceed the operation we have been asked for */</span>
	<span class="n">sts</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="k">switch</span><span class="p">(</span><span class="n">op</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">SYM_EH_ABORT</span>:
		<span class="n">sts</span> <span class="o">=</span> <span class="n">sym_abort_scsiio</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">cmd</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SYM_EH_DEVICE_RESET</span>:
		<span class="n">sts</span> <span class="o">=</span> <span class="n">sym_reset_scsi_target</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SYM_EH_BUS_RESET</span>:
		<span class="n">sym_reset_scsi_bus</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">sts</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SYM_EH_HOST_RESET</span>:
		<span class="n">sym_reset_scsi_bus</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">sym_start_up</span><span class="p">(</span><span class="n">shost</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">sts</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* On error, restore everything and cross fingers :) */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sts</span><span class="p">)</span>
		<span class="n">cmd_queued</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cmd_queued</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">init_completion</span><span class="p">(</span><span class="o">&amp;</span><span class="n">eh_done</span><span class="p">);</span>
		<span class="n">ucmd</span><span class="o">-&gt;</span><span class="n">eh_done</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">eh_done</span><span class="p">;</span>
		<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">wait_for_completion_timeout</span><span class="p">(</span><span class="o">&amp;</span><span class="n">eh_done</span><span class="p">,</span> <span class="mi">5</span><span class="o">*</span><span class="n">HZ</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">ucmd</span><span class="o">-&gt;</span><span class="n">eh_done</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="n">sts</span> <span class="o">=</span> <span class="o">-</span><span class="mi">2</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">sdev_gendev</span><span class="p">,</span> <span class="s">&quot;%s operation %s.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">opname</span><span class="p">,</span>
			<span class="n">sts</span><span class="o">==</span><span class="mi">0</span> <span class="o">?</span> <span class="s">&quot;complete&quot;</span> <span class="o">:</span><span class="n">sts</span><span class="o">==-</span><span class="mi">2</span> <span class="o">?</span> <span class="s">&quot;timed-out&quot;</span> <span class="o">:</span> <span class="s">&quot;failed&quot;</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">sts</span> <span class="o">?</span> <span class="n">SCSI_FAILED</span> <span class="o">:</span> <span class="n">SCSI_SUCCESS</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * Error handlers called from the eh thread (one thread per HBA).</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">sym53c8xx_eh_abort_handler</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">sym_eh_handler</span><span class="p">(</span><span class="n">SYM_EH_ABORT</span><span class="p">,</span> <span class="s">&quot;ABORT&quot;</span><span class="p">,</span> <span class="n">cmd</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">sym53c8xx_eh_device_reset_handler</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">sym_eh_handler</span><span class="p">(</span><span class="n">SYM_EH_DEVICE_RESET</span><span class="p">,</span> <span class="s">&quot;DEVICE RESET&quot;</span><span class="p">,</span> <span class="n">cmd</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">sym53c8xx_eh_bus_reset_handler</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">sym_eh_handler</span><span class="p">(</span><span class="n">SYM_EH_BUS_RESET</span><span class="p">,</span> <span class="s">&quot;BUS RESET&quot;</span><span class="p">,</span> <span class="n">cmd</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">sym53c8xx_eh_host_reset_handler</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">sym_eh_handler</span><span class="p">(</span><span class="n">SYM_EH_HOST_RESET</span><span class="p">,</span> <span class="s">&quot;HOST RESET&quot;</span><span class="p">,</span> <span class="n">cmd</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *  Tune device queuing depth, according to various limits.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">sym_tune_dev_queuing</span><span class="p">(</span><span class="k">struct</span> <span class="n">sym_tcb</span> <span class="o">*</span><span class="n">tp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">lun</span><span class="p">,</span> <span class="n">u_short</span> <span class="n">reqtags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sym_lcb</span> <span class="o">*</span><span class="n">lp</span> <span class="o">=</span> <span class="n">sym_lp</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">lun</span><span class="p">);</span>
	<span class="n">u_short</span>	<span class="n">oldtags</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">lp</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">oldtags</span> <span class="o">=</span> <span class="n">lp</span><span class="o">-&gt;</span><span class="n">s</span><span class="p">.</span><span class="n">reqtags</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">reqtags</span> <span class="o">&gt;</span> <span class="n">lp</span><span class="o">-&gt;</span><span class="n">s</span><span class="p">.</span><span class="n">scdev_depth</span><span class="p">)</span>
		<span class="n">reqtags</span> <span class="o">=</span> <span class="n">lp</span><span class="o">-&gt;</span><span class="n">s</span><span class="p">.</span><span class="n">scdev_depth</span><span class="p">;</span>

	<span class="n">lp</span><span class="o">-&gt;</span><span class="n">s</span><span class="p">.</span><span class="n">reqtags</span>     <span class="o">=</span> <span class="n">reqtags</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">reqtags</span> <span class="o">!=</span> <span class="n">oldtags</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">starget</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
		         <span class="s">&quot;tagged command queuing %s, command queue depth %d.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		          <span class="n">lp</span><span class="o">-&gt;</span><span class="n">s</span><span class="p">.</span><span class="n">reqtags</span> <span class="o">?</span> <span class="s">&quot;enabled&quot;</span> <span class="o">:</span> <span class="s">&quot;disabled&quot;</span><span class="p">,</span> <span class="n">reqtags</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">sym53c8xx_slave_alloc</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="n">sdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sym_hcb</span> <span class="o">*</span><span class="n">np</span> <span class="o">=</span> <span class="n">sym_get_hcb</span><span class="p">(</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">sym_tcb</span> <span class="o">*</span><span class="n">tp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">target</span><span class="p">[</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">sym_lcb</span> <span class="o">*</span><span class="n">lp</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">id</span> <span class="o">&gt;=</span> <span class="n">SYM_CONF_MAX_TARGET</span> <span class="o">||</span> <span class="n">sdev</span><span class="o">-&gt;</span><span class="n">lun</span> <span class="o">&gt;=</span> <span class="n">SYM_CONF_MAX_LUN</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENXIO</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">s</span><span class="p">.</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Fail the device init if the device is flagged NOSCAN at BOOT in</span>
<span class="cm">	 * the NVRAM.  This may speed up boot and maintain coherency with</span>
<span class="cm">	 * BIOS device numbering.  Clearing the flag allows the user to</span>
<span class="cm">	 * rescan skipped devices later.  We also return an error for</span>
<span class="cm">	 * devices not flagged for SCAN LUNS in the NVRAM since some single</span>
<span class="cm">	 * lun devices behave badly when asked for a non zero LUN.</span>
<span class="cm">	 */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">usrflags</span> <span class="o">&amp;</span> <span class="n">SYM_SCAN_BOOT_DISABLED</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">tp</span><span class="o">-&gt;</span><span class="n">usrflags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">SYM_SCAN_BOOT_DISABLED</span><span class="p">;</span>
		<span class="n">starget_printk</span><span class="p">(</span><span class="n">KERN_INFO</span><span class="p">,</span> <span class="n">sdev</span><span class="o">-&gt;</span><span class="n">sdev_target</span><span class="p">,</span>
				<span class="s">&quot;Scan at boot disabled in NVRAM</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENXIO</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">usrflags</span> <span class="o">&amp;</span> <span class="n">SYM_SCAN_LUNS_DISABLED</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">lun</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENXIO</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">starget_printk</span><span class="p">(</span><span class="n">KERN_INFO</span><span class="p">,</span> <span class="n">sdev</span><span class="o">-&gt;</span><span class="n">sdev_target</span><span class="p">,</span>
				<span class="s">&quot;Multiple LUNs disabled in NVRAM</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">lp</span> <span class="o">=</span> <span class="n">sym_alloc_lcb</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">sdev</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">,</span> <span class="n">sdev</span><span class="o">-&gt;</span><span class="n">lun</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">lp</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">nlcb</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
		<span class="n">tp</span><span class="o">-&gt;</span><span class="n">starget</span> <span class="o">=</span> <span class="n">sdev</span><span class="o">-&gt;</span><span class="n">sdev_target</span><span class="p">;</span>

	<span class="n">spi_min_period</span><span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">starget</span><span class="p">)</span> <span class="o">=</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">usr_period</span><span class="p">;</span>
	<span class="n">spi_max_width</span><span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">starget</span><span class="p">)</span> <span class="o">=</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">usr_width</span><span class="p">;</span>

	<span class="n">error</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">out:</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">s</span><span class="p">.</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Linux entry point for device queue sizing.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">sym53c8xx_slave_configure</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="n">sdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sym_hcb</span> <span class="o">*</span><span class="n">np</span> <span class="o">=</span> <span class="n">sym_get_hcb</span><span class="p">(</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">sym_tcb</span> <span class="o">*</span><span class="n">tp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">target</span><span class="p">[</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">sym_lcb</span> <span class="o">*</span><span class="n">lp</span> <span class="o">=</span> <span class="n">sym_lp</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">sdev</span><span class="o">-&gt;</span><span class="n">lun</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">reqtags</span><span class="p">,</span> <span class="n">depth_to_use</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 *  Get user flags.</span>
<span class="cm">	 */</span>
	<span class="n">lp</span><span class="o">-&gt;</span><span class="n">curr_flags</span> <span class="o">=</span> <span class="n">lp</span><span class="o">-&gt;</span><span class="n">user_flags</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 *  Select queue depth from driver setup.</span>
<span class="cm">	 *  Do not use more than configured by user.</span>
<span class="cm">	 *  Use at least 1.</span>
<span class="cm">	 *  Do not use more than our maximum.</span>
<span class="cm">	 */</span>
	<span class="n">reqtags</span> <span class="o">=</span> <span class="n">sym_driver_setup</span><span class="p">.</span><span class="n">max_tag</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">reqtags</span> <span class="o">&gt;</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">usrtags</span><span class="p">)</span>
		<span class="n">reqtags</span> <span class="o">=</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">usrtags</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">tagged_supported</span><span class="p">)</span>
		<span class="n">reqtags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">reqtags</span> <span class="o">&gt;</span> <span class="n">SYM_CONF_MAX_TAG</span><span class="p">)</span>
		<span class="n">reqtags</span> <span class="o">=</span> <span class="n">SYM_CONF_MAX_TAG</span><span class="p">;</span>
	<span class="n">depth_to_use</span> <span class="o">=</span> <span class="n">reqtags</span> <span class="o">?</span> <span class="n">reqtags</span> <span class="o">:</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">scsi_adjust_queue_depth</span><span class="p">(</span><span class="n">sdev</span><span class="p">,</span>
				<span class="n">sdev</span><span class="o">-&gt;</span><span class="n">tagged_supported</span> <span class="o">?</span> <span class="n">MSG_SIMPLE_TAG</span> <span class="o">:</span> <span class="mi">0</span><span class="p">,</span>
				<span class="n">depth_to_use</span><span class="p">);</span>
	<span class="n">lp</span><span class="o">-&gt;</span><span class="n">s</span><span class="p">.</span><span class="n">scdev_depth</span> <span class="o">=</span> <span class="n">depth_to_use</span><span class="p">;</span>
	<span class="n">sym_tune_dev_queuing</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">sdev</span><span class="o">-&gt;</span><span class="n">lun</span><span class="p">,</span> <span class="n">reqtags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">spi_initial_dv</span><span class="p">(</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">sdev_target</span><span class="p">))</span>
		<span class="n">spi_dv_device</span><span class="p">(</span><span class="n">sdev</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">sym53c8xx_slave_destroy</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="n">sdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sym_hcb</span> <span class="o">*</span><span class="n">np</span> <span class="o">=</span> <span class="n">sym_get_hcb</span><span class="p">(</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">sym_tcb</span> <span class="o">*</span><span class="n">tp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">target</span><span class="p">[</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">sym_lcb</span> <span class="o">*</span><span class="n">lp</span> <span class="o">=</span> <span class="n">sym_lp</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">sdev</span><span class="o">-&gt;</span><span class="n">lun</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="cm">/* if slave_alloc returned before allocating a sym_lcb, return */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">lp</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">s</span><span class="p">.</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">busy_itlq</span> <span class="o">||</span> <span class="n">lp</span><span class="o">-&gt;</span><span class="n">busy_itl</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * This really shouldn&#39;t happen, but we can&#39;t return an error</span>
<span class="cm">		 * so let&#39;s try to stop all on-going I/O.</span>
<span class="cm">		 */</span>
		<span class="n">starget_printk</span><span class="p">(</span><span class="n">KERN_WARNING</span><span class="p">,</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">starget</span><span class="p">,</span>
			       <span class="s">&quot;Removing busy LCB (%d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">sdev</span><span class="o">-&gt;</span><span class="n">lun</span><span class="p">);</span>
		<span class="n">sym_reset_scsi_bus</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sym_free_lcb</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">sdev</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">,</span> <span class="n">sdev</span><span class="o">-&gt;</span><span class="n">lun</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * It was the last unit for this target.</span>
<span class="cm">		 */</span>
		<span class="n">tp</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">.</span><span class="n">sval</span>        <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">tp</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">.</span><span class="n">wval</span>        <span class="o">=</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">rv_scntl3</span><span class="p">;</span>
		<span class="n">tp</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">.</span><span class="n">uval</span>        <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">tp</span><span class="o">-&gt;</span><span class="n">tgoal</span><span class="p">.</span><span class="n">check_nego</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">tp</span><span class="o">-&gt;</span><span class="n">starget</span>	     <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">s</span><span class="p">.</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *  Linux entry point for info() function</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="nf">sym53c8xx_info</span> <span class="p">(</span><span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">host</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">SYM_DRIVER_NAME</span><span class="p">;</span>
<span class="p">}</span>


<span class="cp">#ifdef SYM_LINUX_PROC_INFO_SUPPORT</span>
<span class="cm">/*</span>
<span class="cm"> *  Proc file system stuff</span>
<span class="cm"> *</span>
<span class="cm"> *  A read operation returns adapter information.</span>
<span class="cm"> *  A write operation is a control command.</span>
<span class="cm"> *  The string is parsed in the driver code and the command is passed </span>
<span class="cm"> *  to the sym_usercmd() function.</span>
<span class="cm"> */</span>

<span class="cp">#ifdef SYM_LINUX_USER_COMMAND_SUPPORT</span>

<span class="k">struct</span>	<span class="n">sym_usrcmd</span> <span class="p">{</span>
	<span class="n">u_long</span>	<span class="n">target</span><span class="p">;</span>
	<span class="n">u_long</span>	<span class="n">lun</span><span class="p">;</span>
	<span class="n">u_long</span>	<span class="n">data</span><span class="p">;</span>
	<span class="n">u_long</span>	<span class="n">cmd</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#define UC_SETSYNC      10</span>
<span class="cp">#define UC_SETTAGS	11</span>
<span class="cp">#define UC_SETDEBUG	12</span>
<span class="cp">#define UC_SETWIDE	14</span>
<span class="cp">#define UC_SETFLAG	15</span>
<span class="cp">#define UC_SETVERBOSE	17</span>
<span class="cp">#define UC_RESETDEV	18</span>
<span class="cp">#define UC_CLEARDEV	19</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">sym_exec_user_command</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sym_hcb</span> <span class="o">*</span><span class="n">np</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sym_usrcmd</span> <span class="o">*</span><span class="n">uc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sym_tcb</span> <span class="o">*</span><span class="n">tp</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">t</span><span class="p">,</span> <span class="n">l</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">uc</span><span class="o">-&gt;</span><span class="n">cmd</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="mi">0</span>: <span class="k">return</span><span class="p">;</span>

<span class="cp">#ifdef SYM_LINUX_DEBUG_CONTROL_SUPPORT</span>
	<span class="k">case</span> <span class="n">UC_SETDEBUG</span>:
		<span class="n">sym_debug_flags</span> <span class="o">=</span> <span class="n">uc</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="k">case</span> <span class="n">UC_SETVERBOSE</span>:
		<span class="n">np</span><span class="o">-&gt;</span><span class="n">verbose</span> <span class="o">=</span> <span class="n">uc</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="cm">/*</span>
<span class="cm">		 * We assume that other commands apply to targets.</span>
<span class="cm">		 * This should always be the case and avoid the below </span>
<span class="cm">		 * 4 lines to be repeated 6 times.</span>
<span class="cm">		 */</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">t</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">t</span> <span class="o">&lt;</span> <span class="n">SYM_CONF_MAX_TARGET</span><span class="p">;</span> <span class="n">t</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">((</span><span class="n">uc</span><span class="o">-&gt;</span><span class="n">target</span> <span class="o">&gt;&gt;</span> <span class="n">t</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">))</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="n">tp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">target</span><span class="p">[</span><span class="n">t</span><span class="p">];</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">nlcb</span><span class="p">)</span>
				<span class="k">continue</span><span class="p">;</span>

			<span class="k">switch</span> <span class="p">(</span><span class="n">uc</span><span class="o">-&gt;</span><span class="n">cmd</span><span class="p">)</span> <span class="p">{</span>

			<span class="k">case</span> <span class="n">UC_SETSYNC</span>:
				<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">uc</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">||</span> <span class="n">uc</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">&gt;=</span> <span class="mi">255</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">tp</span><span class="o">-&gt;</span><span class="n">tgoal</span><span class="p">.</span><span class="n">iu</span> <span class="o">=</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">tgoal</span><span class="p">.</span><span class="n">dt</span> <span class="o">=</span>
						<span class="n">tp</span><span class="o">-&gt;</span><span class="n">tgoal</span><span class="p">.</span><span class="n">qas</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
					<span class="n">tp</span><span class="o">-&gt;</span><span class="n">tgoal</span><span class="p">.</span><span class="n">offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
				<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">uc</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">&lt;=</span> <span class="mi">9</span> <span class="o">&amp;&amp;</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">minsync_dt</span><span class="p">)</span> <span class="p">{</span>
					<span class="k">if</span> <span class="p">(</span><span class="n">uc</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">&lt;</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">minsync_dt</span><span class="p">)</span>
						<span class="n">uc</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">minsync_dt</span><span class="p">;</span>
					<span class="n">tp</span><span class="o">-&gt;</span><span class="n">tgoal</span><span class="p">.</span><span class="n">iu</span> <span class="o">=</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">tgoal</span><span class="p">.</span><span class="n">dt</span> <span class="o">=</span>
						<span class="n">tp</span><span class="o">-&gt;</span><span class="n">tgoal</span><span class="p">.</span><span class="n">qas</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
					<span class="n">tp</span><span class="o">-&gt;</span><span class="n">tgoal</span><span class="p">.</span><span class="n">width</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
					<span class="n">tp</span><span class="o">-&gt;</span><span class="n">tgoal</span><span class="p">.</span><span class="n">period</span> <span class="o">=</span> <span class="n">uc</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
					<span class="n">tp</span><span class="o">-&gt;</span><span class="n">tgoal</span><span class="p">.</span><span class="n">offset</span> <span class="o">=</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">maxoffs_dt</span><span class="p">;</span>
				<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
					<span class="k">if</span> <span class="p">(</span><span class="n">uc</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">&lt;</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">minsync</span><span class="p">)</span>
						<span class="n">uc</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">minsync</span><span class="p">;</span>
					<span class="n">tp</span><span class="o">-&gt;</span><span class="n">tgoal</span><span class="p">.</span><span class="n">iu</span> <span class="o">=</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">tgoal</span><span class="p">.</span><span class="n">dt</span> <span class="o">=</span>
						<span class="n">tp</span><span class="o">-&gt;</span><span class="n">tgoal</span><span class="p">.</span><span class="n">qas</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
					<span class="n">tp</span><span class="o">-&gt;</span><span class="n">tgoal</span><span class="p">.</span><span class="n">period</span> <span class="o">=</span> <span class="n">uc</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
					<span class="n">tp</span><span class="o">-&gt;</span><span class="n">tgoal</span><span class="p">.</span><span class="n">offset</span> <span class="o">=</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">maxoffs</span><span class="p">;</span>
				<span class="p">}</span>
				<span class="n">tp</span><span class="o">-&gt;</span><span class="n">tgoal</span><span class="p">.</span><span class="n">check_nego</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="k">case</span> <span class="n">UC_SETWIDE</span>:
				<span class="n">tp</span><span class="o">-&gt;</span><span class="n">tgoal</span><span class="p">.</span><span class="n">width</span> <span class="o">=</span> <span class="n">uc</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
				<span class="n">tp</span><span class="o">-&gt;</span><span class="n">tgoal</span><span class="p">.</span><span class="n">check_nego</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="k">case</span> <span class="n">UC_SETTAGS</span>:
				<span class="k">for</span> <span class="p">(</span><span class="n">l</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">l</span> <span class="o">&lt;</span> <span class="n">SYM_CONF_MAX_LUN</span><span class="p">;</span> <span class="n">l</span><span class="o">++</span><span class="p">)</span>
					<span class="n">sym_tune_dev_queuing</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">uc</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="k">case</span> <span class="n">UC_RESETDEV</span>:
				<span class="n">tp</span><span class="o">-&gt;</span><span class="n">to_reset</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
				<span class="n">np</span><span class="o">-&gt;</span><span class="n">istat_sem</span> <span class="o">=</span> <span class="n">SEM</span><span class="p">;</span>
				<span class="n">OUTB</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">nc_istat</span><span class="p">,</span> <span class="n">SIGP</span><span class="o">|</span><span class="n">SEM</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="k">case</span> <span class="n">UC_CLEARDEV</span>:
				<span class="k">for</span> <span class="p">(</span><span class="n">l</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">l</span> <span class="o">&lt;</span> <span class="n">SYM_CONF_MAX_LUN</span><span class="p">;</span> <span class="n">l</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
					<span class="k">struct</span> <span class="n">sym_lcb</span> <span class="o">*</span><span class="n">lp</span> <span class="o">=</span> <span class="n">sym_lp</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">l</span><span class="p">);</span>
					<span class="k">if</span> <span class="p">(</span><span class="n">lp</span><span class="p">)</span> <span class="n">lp</span><span class="o">-&gt;</span><span class="n">to_clear</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
				<span class="p">}</span>
				<span class="n">np</span><span class="o">-&gt;</span><span class="n">istat_sem</span> <span class="o">=</span> <span class="n">SEM</span><span class="p">;</span>
				<span class="n">OUTB</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">nc_istat</span><span class="p">,</span> <span class="n">SIGP</span><span class="o">|</span><span class="n">SEM</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="k">case</span> <span class="n">UC_SETFLAG</span>:
				<span class="n">tp</span><span class="o">-&gt;</span><span class="n">usrflags</span> <span class="o">=</span> <span class="n">uc</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">sym_skip_spaces</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">ptr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">cnt</span><span class="p">,</span> <span class="n">c</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">cnt</span> <span class="o">=</span> <span class="n">len</span><span class="p">;</span> <span class="n">cnt</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">c</span> <span class="o">=</span> <span class="o">*</span><span class="n">ptr</span><span class="o">++</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">isspace</span><span class="p">(</span><span class="n">c</span><span class="p">);</span> <span class="n">cnt</span><span class="o">--</span><span class="p">);</span>

	<span class="k">return</span> <span class="p">(</span><span class="n">len</span> <span class="o">-</span> <span class="n">cnt</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">get_int_arg</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">ptr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">,</span> <span class="n">u_long</span> <span class="o">*</span><span class="n">pv</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">end</span><span class="p">;</span>

	<span class="o">*</span><span class="n">pv</span> <span class="o">=</span> <span class="n">simple_strtoul</span><span class="p">(</span><span class="n">ptr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">end</span><span class="p">,</span> <span class="mi">10</span><span class="p">);</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">end</span> <span class="o">-</span> <span class="n">ptr</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">is_keyword</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">ptr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">verb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">verb_len</span> <span class="o">=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">verb</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&gt;=</span> <span class="n">verb_len</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">memcmp</span><span class="p">(</span><span class="n">verb</span><span class="p">,</span> <span class="n">ptr</span><span class="p">,</span> <span class="n">verb_len</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">verb_len</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#define SKIP_SPACES(ptr, len)						\</span>
<span class="cp">	if ((arg_len = sym_skip_spaces(ptr, len)) &lt; 1)			\</span>
<span class="cp">		return -EINVAL;						\</span>
<span class="cp">	ptr += arg_len; len -= arg_len;</span>

<span class="cp">#define GET_INT_ARG(ptr, len, v)					\</span>
<span class="cp">	if (!(arg_len = get_int_arg(ptr, len, &amp;(v))))			\</span>
<span class="cp">		return -EINVAL;						\</span>
<span class="cp">	ptr += arg_len; len -= arg_len;</span>


<span class="cm">/*</span>
<span class="cm"> * Parse a control command</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">sym_user_command</span><span class="p">(</span><span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span> <span class="kt">int</span> <span class="n">length</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sym_hcb</span> <span class="o">*</span><span class="n">np</span> <span class="o">=</span> <span class="n">sym_get_hcb</span><span class="p">(</span><span class="n">shost</span><span class="p">);</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">ptr</span>	<span class="o">=</span> <span class="n">buffer</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">len</span>		<span class="o">=</span> <span class="n">length</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sym_usrcmd</span> <span class="n">cmd</span><span class="p">,</span> <span class="o">*</span><span class="n">uc</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">cmd</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">arg_len</span><span class="p">;</span>
	<span class="n">u_long</span> 		<span class="n">target</span><span class="p">;</span>

	<span class="n">memset</span><span class="p">(</span><span class="n">uc</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">uc</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">ptr</span><span class="p">[</span><span class="n">len</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;\n&#39;</span><span class="p">)</span>
		<span class="o">--</span><span class="n">len</span><span class="p">;</span>

	<span class="k">if</span>	<span class="p">((</span><span class="n">arg_len</span> <span class="o">=</span> <span class="n">is_keyword</span><span class="p">(</span><span class="n">ptr</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="s">&quot;setsync&quot;</span><span class="p">))</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">uc</span><span class="o">-&gt;</span><span class="n">cmd</span> <span class="o">=</span> <span class="n">UC_SETSYNC</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span>	<span class="p">((</span><span class="n">arg_len</span> <span class="o">=</span> <span class="n">is_keyword</span><span class="p">(</span><span class="n">ptr</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="s">&quot;settags&quot;</span><span class="p">))</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">uc</span><span class="o">-&gt;</span><span class="n">cmd</span> <span class="o">=</span> <span class="n">UC_SETTAGS</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span>	<span class="p">((</span><span class="n">arg_len</span> <span class="o">=</span> <span class="n">is_keyword</span><span class="p">(</span><span class="n">ptr</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="s">&quot;setverbose&quot;</span><span class="p">))</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">uc</span><span class="o">-&gt;</span><span class="n">cmd</span> <span class="o">=</span> <span class="n">UC_SETVERBOSE</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span>	<span class="p">((</span><span class="n">arg_len</span> <span class="o">=</span> <span class="n">is_keyword</span><span class="p">(</span><span class="n">ptr</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="s">&quot;setwide&quot;</span><span class="p">))</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">uc</span><span class="o">-&gt;</span><span class="n">cmd</span> <span class="o">=</span> <span class="n">UC_SETWIDE</span><span class="p">;</span>
<span class="cp">#ifdef SYM_LINUX_DEBUG_CONTROL_SUPPORT</span>
	<span class="k">else</span> <span class="k">if</span>	<span class="p">((</span><span class="n">arg_len</span> <span class="o">=</span> <span class="n">is_keyword</span><span class="p">(</span><span class="n">ptr</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="s">&quot;setdebug&quot;</span><span class="p">))</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">uc</span><span class="o">-&gt;</span><span class="n">cmd</span> <span class="o">=</span> <span class="n">UC_SETDEBUG</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="k">else</span> <span class="k">if</span>	<span class="p">((</span><span class="n">arg_len</span> <span class="o">=</span> <span class="n">is_keyword</span><span class="p">(</span><span class="n">ptr</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="s">&quot;setflag&quot;</span><span class="p">))</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">uc</span><span class="o">-&gt;</span><span class="n">cmd</span> <span class="o">=</span> <span class="n">UC_SETFLAG</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span>	<span class="p">((</span><span class="n">arg_len</span> <span class="o">=</span> <span class="n">is_keyword</span><span class="p">(</span><span class="n">ptr</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="s">&quot;resetdev&quot;</span><span class="p">))</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">uc</span><span class="o">-&gt;</span><span class="n">cmd</span> <span class="o">=</span> <span class="n">UC_RESETDEV</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span>	<span class="p">((</span><span class="n">arg_len</span> <span class="o">=</span> <span class="n">is_keyword</span><span class="p">(</span><span class="n">ptr</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="s">&quot;cleardev&quot;</span><span class="p">))</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">uc</span><span class="o">-&gt;</span><span class="n">cmd</span> <span class="o">=</span> <span class="n">UC_CLEARDEV</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">arg_len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="cp">#ifdef DEBUG_PROC_INFO</span>
<span class="n">printk</span><span class="p">(</span><span class="s">&quot;sym_user_command: arg_len=%d, cmd=%ld</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">arg_len</span><span class="p">,</span> <span class="n">uc</span><span class="o">-&gt;</span><span class="n">cmd</span><span class="p">);</span>
<span class="cp">#endif</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">arg_len</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="n">ptr</span> <span class="o">+=</span> <span class="n">arg_len</span><span class="p">;</span> <span class="n">len</span> <span class="o">-=</span> <span class="n">arg_len</span><span class="p">;</span>

	<span class="k">switch</span><span class="p">(</span><span class="n">uc</span><span class="o">-&gt;</span><span class="n">cmd</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">UC_SETSYNC</span>:
	<span class="k">case</span> <span class="n">UC_SETTAGS</span>:
	<span class="k">case</span> <span class="n">UC_SETWIDE</span>:
	<span class="k">case</span> <span class="n">UC_SETFLAG</span>:
	<span class="k">case</span> <span class="n">UC_RESETDEV</span>:
	<span class="k">case</span> <span class="n">UC_CLEARDEV</span>:
		<span class="n">SKIP_SPACES</span><span class="p">(</span><span class="n">ptr</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">arg_len</span> <span class="o">=</span> <span class="n">is_keyword</span><span class="p">(</span><span class="n">ptr</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="s">&quot;all&quot;</span><span class="p">))</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ptr</span> <span class="o">+=</span> <span class="n">arg_len</span><span class="p">;</span> <span class="n">len</span> <span class="o">-=</span> <span class="n">arg_len</span><span class="p">;</span>
			<span class="n">uc</span><span class="o">-&gt;</span><span class="n">target</span> <span class="o">=</span> <span class="o">~</span><span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">GET_INT_ARG</span><span class="p">(</span><span class="n">ptr</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">target</span><span class="p">);</span>
			<span class="n">uc</span><span class="o">-&gt;</span><span class="n">target</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="n">target</span><span class="p">);</span>
<span class="cp">#ifdef DEBUG_PROC_INFO</span>
<span class="n">printk</span><span class="p">(</span><span class="s">&quot;sym_user_command: target=%ld</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">target</span><span class="p">);</span>
<span class="cp">#endif</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">switch</span><span class="p">(</span><span class="n">uc</span><span class="o">-&gt;</span><span class="n">cmd</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">UC_SETVERBOSE</span>:
	<span class="k">case</span> <span class="n">UC_SETSYNC</span>:
	<span class="k">case</span> <span class="n">UC_SETTAGS</span>:
	<span class="k">case</span> <span class="n">UC_SETWIDE</span>:
		<span class="n">SKIP_SPACES</span><span class="p">(</span><span class="n">ptr</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
		<span class="n">GET_INT_ARG</span><span class="p">(</span><span class="n">ptr</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">uc</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">);</span>
<span class="cp">#ifdef DEBUG_PROC_INFO</span>
<span class="n">printk</span><span class="p">(</span><span class="s">&quot;sym_user_command: data=%ld</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">uc</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">);</span>
<span class="cp">#endif</span>
		<span class="k">break</span><span class="p">;</span>
<span class="cp">#ifdef SYM_LINUX_DEBUG_CONTROL_SUPPORT</span>
	<span class="k">case</span> <span class="n">UC_SETDEBUG</span>:
		<span class="k">while</span> <span class="p">(</span><span class="n">len</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">SKIP_SPACES</span><span class="p">(</span><span class="n">ptr</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
			<span class="k">if</span>	<span class="p">((</span><span class="n">arg_len</span> <span class="o">=</span> <span class="n">is_keyword</span><span class="p">(</span><span class="n">ptr</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="s">&quot;alloc&quot;</span><span class="p">)))</span>
				<span class="n">uc</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">|=</span> <span class="n">DEBUG_ALLOC</span><span class="p">;</span>
			<span class="k">else</span> <span class="k">if</span>	<span class="p">((</span><span class="n">arg_len</span> <span class="o">=</span> <span class="n">is_keyword</span><span class="p">(</span><span class="n">ptr</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="s">&quot;phase&quot;</span><span class="p">)))</span>
				<span class="n">uc</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">|=</span> <span class="n">DEBUG_PHASE</span><span class="p">;</span>
			<span class="k">else</span> <span class="k">if</span>	<span class="p">((</span><span class="n">arg_len</span> <span class="o">=</span> <span class="n">is_keyword</span><span class="p">(</span><span class="n">ptr</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="s">&quot;queue&quot;</span><span class="p">)))</span>
				<span class="n">uc</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">|=</span> <span class="n">DEBUG_QUEUE</span><span class="p">;</span>
			<span class="k">else</span> <span class="k">if</span>	<span class="p">((</span><span class="n">arg_len</span> <span class="o">=</span> <span class="n">is_keyword</span><span class="p">(</span><span class="n">ptr</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="s">&quot;result&quot;</span><span class="p">)))</span>
				<span class="n">uc</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">|=</span> <span class="n">DEBUG_RESULT</span><span class="p">;</span>
			<span class="k">else</span> <span class="k">if</span>	<span class="p">((</span><span class="n">arg_len</span> <span class="o">=</span> <span class="n">is_keyword</span><span class="p">(</span><span class="n">ptr</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="s">&quot;scatter&quot;</span><span class="p">)))</span>
				<span class="n">uc</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">|=</span> <span class="n">DEBUG_SCATTER</span><span class="p">;</span>
			<span class="k">else</span> <span class="k">if</span>	<span class="p">((</span><span class="n">arg_len</span> <span class="o">=</span> <span class="n">is_keyword</span><span class="p">(</span><span class="n">ptr</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="s">&quot;script&quot;</span><span class="p">)))</span>
				<span class="n">uc</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">|=</span> <span class="n">DEBUG_SCRIPT</span><span class="p">;</span>
			<span class="k">else</span> <span class="k">if</span>	<span class="p">((</span><span class="n">arg_len</span> <span class="o">=</span> <span class="n">is_keyword</span><span class="p">(</span><span class="n">ptr</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="s">&quot;tiny&quot;</span><span class="p">)))</span>
				<span class="n">uc</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">|=</span> <span class="n">DEBUG_TINY</span><span class="p">;</span>
			<span class="k">else</span> <span class="k">if</span>	<span class="p">((</span><span class="n">arg_len</span> <span class="o">=</span> <span class="n">is_keyword</span><span class="p">(</span><span class="n">ptr</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="s">&quot;timing&quot;</span><span class="p">)))</span>
				<span class="n">uc</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">|=</span> <span class="n">DEBUG_TIMING</span><span class="p">;</span>
			<span class="k">else</span> <span class="k">if</span>	<span class="p">((</span><span class="n">arg_len</span> <span class="o">=</span> <span class="n">is_keyword</span><span class="p">(</span><span class="n">ptr</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="s">&quot;nego&quot;</span><span class="p">)))</span>
				<span class="n">uc</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">|=</span> <span class="n">DEBUG_NEGO</span><span class="p">;</span>
			<span class="k">else</span> <span class="k">if</span>	<span class="p">((</span><span class="n">arg_len</span> <span class="o">=</span> <span class="n">is_keyword</span><span class="p">(</span><span class="n">ptr</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="s">&quot;tags&quot;</span><span class="p">)))</span>
				<span class="n">uc</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">|=</span> <span class="n">DEBUG_TAGS</span><span class="p">;</span>
			<span class="k">else</span> <span class="k">if</span>	<span class="p">((</span><span class="n">arg_len</span> <span class="o">=</span> <span class="n">is_keyword</span><span class="p">(</span><span class="n">ptr</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="s">&quot;pointer&quot;</span><span class="p">)))</span>
				<span class="n">uc</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">|=</span> <span class="n">DEBUG_POINTER</span><span class="p">;</span>
			<span class="k">else</span>
				<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
			<span class="n">ptr</span> <span class="o">+=</span> <span class="n">arg_len</span><span class="p">;</span> <span class="n">len</span> <span class="o">-=</span> <span class="n">arg_len</span><span class="p">;</span>
		<span class="p">}</span>
<span class="cp">#ifdef DEBUG_PROC_INFO</span>
<span class="n">printk</span><span class="p">(</span><span class="s">&quot;sym_user_command: data=%ld</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">uc</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">);</span>
<span class="cp">#endif</span>
		<span class="k">break</span><span class="p">;</span>
<span class="cp">#endif </span><span class="cm">/* SYM_LINUX_DEBUG_CONTROL_SUPPORT */</span><span class="cp"></span>
	<span class="k">case</span> <span class="n">UC_SETFLAG</span>:
		<span class="k">while</span> <span class="p">(</span><span class="n">len</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">SKIP_SPACES</span><span class="p">(</span><span class="n">ptr</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
			<span class="k">if</span>	<span class="p">((</span><span class="n">arg_len</span> <span class="o">=</span> <span class="n">is_keyword</span><span class="p">(</span><span class="n">ptr</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="s">&quot;no_disc&quot;</span><span class="p">)))</span>
				<span class="n">uc</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">SYM_DISC_ENABLED</span><span class="p">;</span>
			<span class="k">else</span>
				<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
			<span class="n">ptr</span> <span class="o">+=</span> <span class="n">arg_len</span><span class="p">;</span> <span class="n">len</span> <span class="o">-=</span> <span class="n">arg_len</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">len</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="n">sym_exec_user_command</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">uc</span><span class="p">);</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">length</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#endif	</span><span class="cm">/* SYM_LINUX_USER_COMMAND_SUPPORT */</span><span class="cp"></span>


<span class="cp">#ifdef SYM_LINUX_USER_INFO_SUPPORT</span>
<span class="cm">/*</span>
<span class="cm"> *  Informations through the proc file system.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">info_str</span> <span class="p">{</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">buffer</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">length</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">offset</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">pos</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">copy_mem_info</span><span class="p">(</span><span class="k">struct</span> <span class="n">info_str</span> <span class="o">*</span><span class="n">info</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">pos</span> <span class="o">+</span> <span class="n">len</span> <span class="o">&gt;</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">)</span>
		<span class="n">len</span> <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">length</span> <span class="o">-</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">pos</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">pos</span> <span class="o">+</span> <span class="n">len</span> <span class="o">&lt;</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">offset</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">pos</span> <span class="o">+=</span> <span class="n">len</span><span class="p">;</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">pos</span> <span class="o">&lt;</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">offset</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">data</span> <span class="o">+=</span> <span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">offset</span> <span class="o">-</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">pos</span><span class="p">);</span>
		<span class="n">len</span>  <span class="o">-=</span> <span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">offset</span> <span class="o">-</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">pos</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">buffer</span> <span class="o">+</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">pos</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">pos</span> <span class="o">+=</span> <span class="n">len</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">copy_info</span><span class="p">(</span><span class="k">struct</span> <span class="n">info_str</span> <span class="o">*</span><span class="n">info</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">fmt</span><span class="p">,</span> <span class="p">...)</span>
<span class="p">{</span>
	<span class="kt">va_list</span> <span class="n">args</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="mi">81</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">len</span><span class="p">;</span>

	<span class="n">va_start</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">fmt</span><span class="p">);</span>
	<span class="n">len</span> <span class="o">=</span> <span class="n">vsprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">fmt</span><span class="p">,</span> <span class="n">args</span><span class="p">);</span>
	<span class="n">va_end</span><span class="p">(</span><span class="n">args</span><span class="p">);</span>

	<span class="n">copy_mem_info</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">len</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *  Copy formatted information into the input buffer.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">sym_host_info</span><span class="p">(</span><span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">ptr</span><span class="p">,</span> <span class="kt">off_t</span> <span class="n">offset</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sym_data</span> <span class="o">*</span><span class="n">sym_data</span> <span class="o">=</span> <span class="n">shost_priv</span><span class="p">(</span><span class="n">shost</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span> <span class="o">=</span> <span class="n">sym_data</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sym_hcb</span> <span class="o">*</span><span class="n">np</span> <span class="o">=</span> <span class="n">sym_data</span><span class="o">-&gt;</span><span class="n">ncb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">info_str</span> <span class="n">info</span><span class="p">;</span>

	<span class="n">info</span><span class="p">.</span><span class="n">buffer</span>	<span class="o">=</span> <span class="n">ptr</span><span class="p">;</span>
	<span class="n">info</span><span class="p">.</span><span class="n">length</span>	<span class="o">=</span> <span class="n">len</span><span class="p">;</span>
	<span class="n">info</span><span class="p">.</span><span class="n">offset</span>	<span class="o">=</span> <span class="n">offset</span><span class="p">;</span>
	<span class="n">info</span><span class="p">.</span><span class="n">pos</span>	<span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">copy_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="p">,</span> <span class="s">&quot;Chip &quot;</span> <span class="n">NAME53C</span> <span class="s">&quot;%s, device id 0x%x, &quot;</span>
			 <span class="s">&quot;revision id 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">s</span><span class="p">.</span><span class="n">chip_name</span><span class="p">,</span>
			 <span class="n">pdev</span><span class="o">-&gt;</span><span class="n">device</span><span class="p">,</span> <span class="n">pdev</span><span class="o">-&gt;</span><span class="n">revision</span><span class="p">);</span>
	<span class="n">copy_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="p">,</span> <span class="s">&quot;At PCI address %s, IRQ %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			 <span class="n">pci_name</span><span class="p">(</span><span class="n">pdev</span><span class="p">),</span> <span class="n">pdev</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">);</span>
	<span class="n">copy_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="p">,</span> <span class="s">&quot;Min. period factor %d, %s SCSI BUS%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			 <span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">minsync_dt</span> <span class="o">?</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">minsync_dt</span> <span class="o">:</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">minsync</span><span class="p">),</span>
			 <span class="n">np</span><span class="o">-&gt;</span><span class="n">maxwide</span> <span class="o">?</span> <span class="s">&quot;Wide&quot;</span> <span class="o">:</span> <span class="s">&quot;Narrow&quot;</span><span class="p">,</span>
			 <span class="n">np</span><span class="o">-&gt;</span><span class="n">minsync_dt</span> <span class="o">?</span> <span class="s">&quot;, DT capable&quot;</span> <span class="o">:</span> <span class="s">&quot;&quot;</span><span class="p">);</span>

	<span class="n">copy_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="p">,</span> <span class="s">&quot;Max. started commands %d, &quot;</span>
			 <span class="s">&quot;max. commands per LUN %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			 <span class="n">SYM_CONF_MAX_START</span><span class="p">,</span> <span class="n">SYM_CONF_MAX_TAG</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">info</span><span class="p">.</span><span class="n">pos</span> <span class="o">&gt;</span> <span class="n">info</span><span class="p">.</span><span class="n">offset</span><span class="o">?</span> <span class="n">info</span><span class="p">.</span><span class="n">pos</span> <span class="o">-</span> <span class="n">info</span><span class="p">.</span><span class="n">offset</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* SYM_LINUX_USER_INFO_SUPPORT */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> *  Entry point of the scsi proc fs of the driver.</span>
<span class="cm"> *  - func = 0 means read  (returns adapter infos)</span>
<span class="cm"> *  - func = 1 means write (not yet merget from sym53c8xx)</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">sym53c8xx_proc_info</span><span class="p">(</span><span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span>
			<span class="kt">char</span> <span class="o">**</span><span class="n">start</span><span class="p">,</span> <span class="kt">off_t</span> <span class="n">offset</span><span class="p">,</span> <span class="kt">int</span> <span class="n">length</span><span class="p">,</span> <span class="kt">int</span> <span class="n">func</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">retv</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">func</span><span class="p">)</span> <span class="p">{</span>
<span class="cp">#ifdef	SYM_LINUX_USER_COMMAND_SUPPORT</span>
		<span class="n">retv</span> <span class="o">=</span> <span class="n">sym_user_command</span><span class="p">(</span><span class="n">shost</span><span class="p">,</span> <span class="n">buffer</span><span class="p">,</span> <span class="n">length</span><span class="p">);</span>
<span class="cp">#else</span>
		<span class="n">retv</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">start</span><span class="p">)</span>
			<span class="o">*</span><span class="n">start</span> <span class="o">=</span> <span class="n">buffer</span><span class="p">;</span>
<span class="cp">#ifdef SYM_LINUX_USER_INFO_SUPPORT</span>
		<span class="n">retv</span> <span class="o">=</span> <span class="n">sym_host_info</span><span class="p">(</span><span class="n">shost</span><span class="p">,</span> <span class="n">buffer</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">length</span><span class="p">);</span>
<span class="cp">#else</span>
		<span class="n">retv</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">retv</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* SYM_LINUX_PROC_INFO_SUPPORT */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * Free resources claimed by sym_iomap_device().  Note that</span>
<span class="cm"> * sym_free_resources() should be used instead of this function after calling</span>
<span class="cm"> * sym_attach().</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">__devinit</span>
<span class="nf">sym_iounmap_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">sym_device</span> <span class="o">*</span><span class="n">device</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">s</span><span class="p">.</span><span class="n">ioaddr</span><span class="p">)</span>
		<span class="n">pci_iounmap</span><span class="p">(</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">,</span> <span class="n">device</span><span class="o">-&gt;</span><span class="n">s</span><span class="p">.</span><span class="n">ioaddr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">s</span><span class="p">.</span><span class="n">ramaddr</span><span class="p">)</span>
		<span class="n">pci_iounmap</span><span class="p">(</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">,</span> <span class="n">device</span><span class="o">-&gt;</span><span class="n">s</span><span class="p">.</span><span class="n">ramaddr</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *	Free controller resources.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">sym_free_resources</span><span class="p">(</span><span class="k">struct</span> <span class="n">sym_hcb</span> <span class="o">*</span><span class="n">np</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">,</span>
		<span class="kt">int</span> <span class="n">do_free_irq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 *  Free O/S specific resources.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">do_free_irq</span><span class="p">)</span>
		<span class="n">free_irq</span><span class="p">(</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">,</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">s</span><span class="p">.</span><span class="n">host</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">s</span><span class="p">.</span><span class="n">ioaddr</span><span class="p">)</span>
		<span class="n">pci_iounmap</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">s</span><span class="p">.</span><span class="n">ioaddr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">s</span><span class="p">.</span><span class="n">ramaddr</span><span class="p">)</span>
		<span class="n">pci_iounmap</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">s</span><span class="p">.</span><span class="n">ramaddr</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 *  Free O/S independent resources.</span>
<span class="cm">	 */</span>
	<span class="n">sym_hcb_free</span><span class="p">(</span><span class="n">np</span><span class="p">);</span>

	<span class="n">sym_mfree_dma</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">np</span><span class="p">),</span> <span class="s">&quot;HCB&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *  Host attach and initialisations.</span>
<span class="cm"> *</span>
<span class="cm"> *  Allocate host data and ncb structure.</span>
<span class="cm"> *  Remap MMIO region.</span>
<span class="cm"> *  Do chip initialization.</span>
<span class="cm"> *  If all is OK, install interrupt handling and</span>
<span class="cm"> *  start the timer daemon.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span> <span class="n">__devinit</span> <span class="nf">sym_attach</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_host_template</span> <span class="o">*</span><span class="n">tpnt</span><span class="p">,</span>
		<span class="kt">int</span> <span class="n">unit</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sym_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sym_data</span> <span class="o">*</span><span class="n">sym_data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sym_hcb</span> <span class="o">*</span><span class="n">np</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sym_fw</span> <span class="o">*</span><span class="n">fw</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">do_free_irq</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;sym%d: &lt;%s&gt; rev 0x%x at pci %s irq %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">unit</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">chip</span><span class="p">.</span><span class="n">name</span><span class="p">,</span> <span class="n">pdev</span><span class="o">-&gt;</span><span class="n">revision</span><span class="p">,</span> <span class="n">pci_name</span><span class="p">(</span><span class="n">pdev</span><span class="p">),</span>
		<span class="n">pdev</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 *  Get the firmware for this chip.</span>
<span class="cm">	 */</span>
	<span class="n">fw</span> <span class="o">=</span> <span class="n">sym_find_firmware</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">chip</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">fw</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">attach_failed</span><span class="p">;</span>

	<span class="n">shost</span> <span class="o">=</span> <span class="n">scsi_host_alloc</span><span class="p">(</span><span class="n">tpnt</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">sym_data</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">shost</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">attach_failed</span><span class="p">;</span>
	<span class="n">sym_data</span> <span class="o">=</span> <span class="n">shost_priv</span><span class="p">(</span><span class="n">shost</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 *  Allocate immediately the host control block, </span>
<span class="cm">	 *  since we are only expecting to succeed. :)</span>
<span class="cm">	 *  We keep track in the HCB of all the resources that </span>
<span class="cm">	 *  are to be released on error.</span>
<span class="cm">	 */</span>
	<span class="n">np</span> <span class="o">=</span> <span class="n">__sym_calloc_dma</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">np</span><span class="p">),</span> <span class="s">&quot;HCB&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">np</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">attach_failed</span><span class="p">;</span>
	<span class="n">np</span><span class="o">-&gt;</span><span class="n">bus_dmat</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span> <span class="cm">/* Result in 1 DMA pool per HBA */</span>
	<span class="n">sym_data</span><span class="o">-&gt;</span><span class="n">ncb</span> <span class="o">=</span> <span class="n">np</span><span class="p">;</span>
	<span class="n">sym_data</span><span class="o">-&gt;</span><span class="n">pdev</span> <span class="o">=</span> <span class="n">pdev</span><span class="p">;</span>
	<span class="n">np</span><span class="o">-&gt;</span><span class="n">s</span><span class="p">.</span><span class="n">host</span> <span class="o">=</span> <span class="n">shost</span><span class="p">;</span>

	<span class="n">pci_set_drvdata</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">shost</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 *  Copy some useful infos to the HCB.</span>
<span class="cm">	 */</span>
	<span class="n">np</span><span class="o">-&gt;</span><span class="n">hcb_ba</span>	<span class="o">=</span> <span class="n">vtobus</span><span class="p">(</span><span class="n">np</span><span class="p">);</span>
	<span class="n">np</span><span class="o">-&gt;</span><span class="n">verbose</span>	<span class="o">=</span> <span class="n">sym_driver_setup</span><span class="p">.</span><span class="n">verbose</span><span class="p">;</span>
	<span class="n">np</span><span class="o">-&gt;</span><span class="n">s</span><span class="p">.</span><span class="n">unit</span>	<span class="o">=</span> <span class="n">unit</span><span class="p">;</span>
	<span class="n">np</span><span class="o">-&gt;</span><span class="n">features</span>	<span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">chip</span><span class="p">.</span><span class="n">features</span><span class="p">;</span>
	<span class="n">np</span><span class="o">-&gt;</span><span class="n">clock_divn</span>	<span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">chip</span><span class="p">.</span><span class="n">nr_divisor</span><span class="p">;</span>
	<span class="n">np</span><span class="o">-&gt;</span><span class="n">maxoffs</span>	<span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">chip</span><span class="p">.</span><span class="n">offset_max</span><span class="p">;</span>
	<span class="n">np</span><span class="o">-&gt;</span><span class="n">maxburst</span>	<span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">chip</span><span class="p">.</span><span class="n">burst_max</span><span class="p">;</span>
	<span class="n">np</span><span class="o">-&gt;</span><span class="n">myaddr</span>	<span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">host_id</span><span class="p">;</span>
	<span class="n">np</span><span class="o">-&gt;</span><span class="n">mmio_ba</span>	<span class="o">=</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">mmio_base</span><span class="p">;</span>
	<span class="n">np</span><span class="o">-&gt;</span><span class="n">ram_ba</span>	<span class="o">=</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">ram_base</span><span class="p">;</span>
	<span class="n">np</span><span class="o">-&gt;</span><span class="n">s</span><span class="p">.</span><span class="n">ioaddr</span>	<span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">s</span><span class="p">.</span><span class="n">ioaddr</span><span class="p">;</span>
	<span class="n">np</span><span class="o">-&gt;</span><span class="n">s</span><span class="p">.</span><span class="n">ramaddr</span>	<span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">s</span><span class="p">.</span><span class="n">ramaddr</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 *  Edit its name.</span>
<span class="cm">	 */</span>
	<span class="n">strlcpy</span><span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">s</span><span class="p">.</span><span class="n">chip_name</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">chip</span><span class="p">.</span><span class="n">name</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">s</span><span class="p">.</span><span class="n">chip_name</span><span class="p">));</span>
	<span class="n">sprintf</span><span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">s</span><span class="p">.</span><span class="n">inst_name</span><span class="p">,</span> <span class="s">&quot;sym%d&quot;</span><span class="p">,</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">s</span><span class="p">.</span><span class="n">unit</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">SYM_CONF_DMA_ADDRESSING_MODE</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">features</span> <span class="o">&amp;</span> <span class="n">FE_DAC</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			<span class="o">!</span><span class="n">pci_set_dma_mask</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">DMA_DAC_MASK</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">set_dac</span><span class="p">(</span><span class="n">np</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">pci_set_dma_mask</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">DMA_BIT_MASK</span><span class="p">(</span><span class="mi">32</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">printf_warning</span><span class="p">(</span><span class="s">&quot;%s: No suitable DMA available</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">sym_name</span><span class="p">(</span><span class="n">np</span><span class="p">));</span>
		<span class="k">goto</span> <span class="n">attach_failed</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sym_hcb_attach</span><span class="p">(</span><span class="n">shost</span><span class="p">,</span> <span class="n">fw</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">nvram</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">attach_failed</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 *  Install the interrupt handler.</span>
<span class="cm">	 *  If we synchonize the C code with SCRIPTS on interrupt, </span>
<span class="cm">	 *  we do not want to share the INTR line at all.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">request_irq</span><span class="p">(</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">,</span> <span class="n">sym53c8xx_intr</span><span class="p">,</span> <span class="n">IRQF_SHARED</span><span class="p">,</span> <span class="n">NAME53C8XX</span><span class="p">,</span>
			<span class="n">shost</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">printf_err</span><span class="p">(</span><span class="s">&quot;%s: request irq %u failure</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">sym_name</span><span class="p">(</span><span class="n">np</span><span class="p">),</span> <span class="n">pdev</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">attach_failed</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">do_free_irq</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 *  After SCSI devices have been opened, we cannot</span>
<span class="cm">	 *  reset the bus safely, so we do it here.</span>
<span class="cm">	 */</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sym_reset_scsi_bus</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">reset_failed</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 *  Start the SCRIPTS.</span>
<span class="cm">	 */</span>
	<span class="n">sym_start_up</span><span class="p">(</span><span class="n">shost</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 *  Start the timer daemon</span>
<span class="cm">	 */</span>
	<span class="n">init_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">s</span><span class="p">.</span><span class="n">timer</span><span class="p">);</span>
	<span class="n">np</span><span class="o">-&gt;</span><span class="n">s</span><span class="p">.</span><span class="n">timer</span><span class="p">.</span><span class="n">data</span>     <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">np</span><span class="p">;</span>
	<span class="n">np</span><span class="o">-&gt;</span><span class="n">s</span><span class="p">.</span><span class="n">timer</span><span class="p">.</span><span class="n">function</span> <span class="o">=</span> <span class="n">sym53c8xx_timer</span><span class="p">;</span>
	<span class="n">np</span><span class="o">-&gt;</span><span class="n">s</span><span class="p">.</span><span class="n">lasttime</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
	<span class="n">sym_timer</span> <span class="p">(</span><span class="n">np</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 *  Fill Linux host instance structure</span>
<span class="cm">	 *  and return success.</span>
<span class="cm">	 */</span>
	<span class="n">shost</span><span class="o">-&gt;</span><span class="n">max_channel</span>	<span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">shost</span><span class="o">-&gt;</span><span class="n">this_id</span>		<span class="o">=</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">myaddr</span><span class="p">;</span>
	<span class="n">shost</span><span class="o">-&gt;</span><span class="n">max_id</span>		<span class="o">=</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">maxwide</span> <span class="o">?</span> <span class="mi">16</span> <span class="o">:</span> <span class="mi">8</span><span class="p">;</span>
	<span class="n">shost</span><span class="o">-&gt;</span><span class="n">max_lun</span>		<span class="o">=</span> <span class="n">SYM_CONF_MAX_LUN</span><span class="p">;</span>
	<span class="n">shost</span><span class="o">-&gt;</span><span class="n">unique_id</span>	<span class="o">=</span> <span class="n">pci_resource_start</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">shost</span><span class="o">-&gt;</span><span class="n">cmd_per_lun</span>	<span class="o">=</span> <span class="n">SYM_CONF_MAX_TAG</span><span class="p">;</span>
	<span class="n">shost</span><span class="o">-&gt;</span><span class="n">can_queue</span>	<span class="o">=</span> <span class="p">(</span><span class="n">SYM_CONF_MAX_START</span><span class="o">-</span><span class="mi">2</span><span class="p">);</span>
	<span class="n">shost</span><span class="o">-&gt;</span><span class="n">sg_tablesize</span>	<span class="o">=</span> <span class="n">SYM_CONF_MAX_SG</span><span class="p">;</span>
	<span class="n">shost</span><span class="o">-&gt;</span><span class="n">max_cmd_len</span>	<span class="o">=</span> <span class="mi">16</span><span class="p">;</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">sym2_transport_template</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">shost</span><span class="o">-&gt;</span><span class="n">transportt</span>	<span class="o">=</span> <span class="n">sym2_transport_template</span><span class="p">;</span>

	<span class="cm">/* 53c896 rev 1 errata: DMA may not cross 16MB boundary */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">device</span> <span class="o">==</span> <span class="n">PCI_DEVICE_ID_NCR_53C896</span> <span class="o">&amp;&amp;</span> <span class="n">pdev</span><span class="o">-&gt;</span><span class="n">revision</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">)</span>
		<span class="n">shost</span><span class="o">-&gt;</span><span class="n">dma_boundary</span> <span class="o">=</span> <span class="mh">0xFFFFFF</span><span class="p">;</span>

	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">shost</span><span class="p">;</span>

 <span class="nl">reset_failed:</span>
	<span class="n">printf_err</span><span class="p">(</span><span class="s">&quot;%s: FATAL ERROR: CHECK SCSI BUS - CABLES, &quot;</span>
		   <span class="s">&quot;TERMINATION, DEVICE POWER etc.!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">sym_name</span><span class="p">(</span><span class="n">np</span><span class="p">));</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
 <span class="nl">attach_failed:</span>
	<span class="n">printf_info</span><span class="p">(</span><span class="s">&quot;sym%d: giving up ...</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">unit</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">np</span><span class="p">)</span>
		<span class="n">sym_free_resources</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">pdev</span><span class="p">,</span> <span class="n">do_free_irq</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">sym_iounmap_device</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">shost</span><span class="p">)</span>
		<span class="n">scsi_host_put</span><span class="p">(</span><span class="n">shost</span><span class="p">);</span>

	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
 <span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> *    Detect and try to read SYMBIOS and TEKRAM NVRAM.</span>
<span class="cm"> */</span>
<span class="cp">#if SYM_CONF_NVRAM_SUPPORT</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">__devinit</span> <span class="nf">sym_get_nvram</span><span class="p">(</span><span class="k">struct</span> <span class="n">sym_device</span> <span class="o">*</span><span class="n">devp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sym_nvram</span> <span class="o">*</span><span class="n">nvp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">devp</span><span class="o">-&gt;</span><span class="n">nvram</span> <span class="o">=</span> <span class="n">nvp</span><span class="p">;</span>
	<span class="n">nvp</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">sym_read_nvram</span><span class="p">(</span><span class="n">devp</span><span class="p">,</span> <span class="n">nvp</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#else</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">sym_get_nvram</span><span class="p">(</span><span class="k">struct</span> <span class="n">sym_device</span> <span class="o">*</span><span class="n">devp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sym_nvram</span> <span class="o">*</span><span class="n">nvp</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>
<span class="cp">#endif	</span><span class="cm">/* SYM_CONF_NVRAM_SUPPORT */</span><span class="cp"></span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__devinit</span> <span class="nf">sym_check_supported</span><span class="p">(</span><span class="k">struct</span> <span class="n">sym_device</span> <span class="o">*</span><span class="n">device</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sym_chip</span> <span class="o">*</span><span class="n">chip</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span> <span class="o">=</span> <span class="n">device</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">io_port</span> <span class="o">=</span> <span class="n">pci_resource_start</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 *  If user excluded this chip, do not initialize it.</span>
<span class="cm">	 *  I hate this code so much.  Must kill it.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">io_port</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">8</span> <span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">sym_driver_setup</span><span class="p">.</span><span class="n">excludes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">io_port</span><span class="p">)</span>
				<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Check if the chip is supported.  Then copy the chip description</span>
<span class="cm">	 * to our device structure so we can make it match the actual device</span>
<span class="cm">	 * and options.</span>
<span class="cm">	 */</span>
	<span class="n">chip</span> <span class="o">=</span> <span class="n">sym_lookup_chip_table</span><span class="p">(</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">device</span><span class="p">,</span> <span class="n">pdev</span><span class="o">-&gt;</span><span class="n">revision</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">chip</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;device not supported</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">chip</span><span class="p">,</span> <span class="n">chip</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">chip</span><span class="p">));</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Ignore Symbios chips controlled by various RAID controllers.</span>
<span class="cm"> * These controllers set value 0x52414944 at RAM end - 16.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__devinit</span> <span class="nf">sym_check_raid</span><span class="p">(</span><span class="k">struct</span> <span class="n">sym_device</span> <span class="o">*</span><span class="n">device</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ram_size</span><span class="p">,</span> <span class="n">ram_val</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">s</span><span class="p">.</span><span class="n">ramaddr</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">chip</span><span class="p">.</span><span class="n">features</span> <span class="o">&amp;</span> <span class="n">FE_RAM8K</span><span class="p">)</span>
		<span class="n">ram_size</span> <span class="o">=</span> <span class="mi">8192</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">ram_size</span> <span class="o">=</span> <span class="mi">4096</span><span class="p">;</span>

	<span class="n">ram_val</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">s</span><span class="p">.</span><span class="n">ramaddr</span> <span class="o">+</span> <span class="n">ram_size</span> <span class="o">-</span> <span class="mi">16</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ram_val</span> <span class="o">!=</span> <span class="mh">0x52414944</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">dev_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			<span class="s">&quot;not initializing, driven by RAID controller.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__devinit</span> <span class="nf">sym_set_workarounds</span><span class="p">(</span><span class="k">struct</span> <span class="n">sym_device</span> <span class="o">*</span><span class="n">device</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sym_chip</span> <span class="o">*</span><span class="n">chip</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">chip</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span> <span class="o">=</span> <span class="n">device</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">;</span>
	<span class="n">u_short</span> <span class="n">status_reg</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 *  (ITEM 12 of a DEL about the 896 I haven&#39;t yet).</span>
<span class="cm">	 *  We must ensure the chip will use WRITE AND INVALIDATE.</span>
<span class="cm">	 *  The revision number limit is for now arbitrary.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">device</span> <span class="o">==</span> <span class="n">PCI_DEVICE_ID_NCR_53C896</span> <span class="o">&amp;&amp;</span> <span class="n">pdev</span><span class="o">-&gt;</span><span class="n">revision</span> <span class="o">&lt;</span> <span class="mh">0x4</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">chip</span><span class="o">-&gt;</span><span class="n">features</span>	<span class="o">|=</span> <span class="p">(</span><span class="n">FE_WRIE</span> <span class="o">|</span> <span class="n">FE_CLSE</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* If the chip can do Memory Write Invalidate, enable it */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">features</span> <span class="o">&amp;</span> <span class="n">FE_WRIE</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pci_set_mwi</span><span class="p">(</span><span class="n">pdev</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 *  Work around for errant bit in 895A. The 66Mhz</span>
<span class="cm">	 *  capable bit is set erroneously. Clear this bit.</span>
<span class="cm">	 *  (Item 1 DEL 533)</span>
<span class="cm">	 *</span>
<span class="cm">	 *  Make sure Config space and Features agree.</span>
<span class="cm">	 *</span>
<span class="cm">	 *  Recall: writes are not normal to status register -</span>
<span class="cm">	 *  write a 1 to clear and a 0 to leave unchanged.</span>
<span class="cm">	 *  Can only reset bits.</span>
<span class="cm">	 */</span>
	<span class="n">pci_read_config_word</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">PCI_STATUS</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">status_reg</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">features</span> <span class="o">&amp;</span> <span class="n">FE_66MHZ</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">status_reg</span> <span class="o">&amp;</span> <span class="n">PCI_STATUS_66MHZ</span><span class="p">))</span>
			<span class="n">chip</span><span class="o">-&gt;</span><span class="n">features</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">FE_66MHZ</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">status_reg</span> <span class="o">&amp;</span> <span class="n">PCI_STATUS_66MHZ</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">status_reg</span> <span class="o">=</span> <span class="n">PCI_STATUS_66MHZ</span><span class="p">;</span>
			<span class="n">pci_write_config_word</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">PCI_STATUS</span><span class="p">,</span> <span class="n">status_reg</span><span class="p">);</span>
			<span class="n">pci_read_config_word</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">PCI_STATUS</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">status_reg</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Map HBA registers and on-chip SRAM (if present).</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__devinit</span>
<span class="nf">sym_iomap_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">sym_device</span> <span class="o">*</span><span class="n">device</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span> <span class="o">=</span> <span class="n">device</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pci_bus_region</span> <span class="n">bus_addr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>

	<span class="n">pcibios_resource_to_bus</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bus_addr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">resource</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
	<span class="n">device</span><span class="o">-&gt;</span><span class="n">mmio_base</span> <span class="o">=</span> <span class="n">bus_addr</span><span class="p">.</span><span class="n">start</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">chip</span><span class="p">.</span><span class="n">features</span> <span class="o">&amp;</span> <span class="n">FE_RAM</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * If the BAR is 64-bit, resource 2 will be occupied by the</span>
<span class="cm">		 * upper 32 bits</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">resource</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">flags</span><span class="p">)</span>
			<span class="n">i</span><span class="o">++</span><span class="p">;</span>
		<span class="n">pcibios_resource_to_bus</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bus_addr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">resource</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
		<span class="n">device</span><span class="o">-&gt;</span><span class="n">ram_base</span> <span class="o">=</span> <span class="n">bus_addr</span><span class="p">.</span><span class="n">start</span><span class="p">;</span>
	<span class="p">}</span>

<span class="cp">#ifdef CONFIG_SCSI_SYM53C8XX_MMIO</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">mmio_base</span><span class="p">)</span>
		<span class="n">device</span><span class="o">-&gt;</span><span class="n">s</span><span class="p">.</span><span class="n">ioaddr</span> <span class="o">=</span> <span class="n">pci_iomap</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span>
						<span class="n">pci_resource_len</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="mi">1</span><span class="p">));</span>
<span class="cp">#endif</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">s</span><span class="p">.</span><span class="n">ioaddr</span><span class="p">)</span>
		<span class="n">device</span><span class="o">-&gt;</span><span class="n">s</span><span class="p">.</span><span class="n">ioaddr</span> <span class="o">=</span> <span class="n">pci_iomap</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
						<span class="n">pci_resource_len</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="mi">0</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">s</span><span class="p">.</span><span class="n">ioaddr</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;could not map registers; giving up.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">ram_base</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">device</span><span class="o">-&gt;</span><span class="n">s</span><span class="p">.</span><span class="n">ramaddr</span> <span class="o">=</span> <span class="n">pci_iomap</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span>
						<span class="n">pci_resource_len</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">i</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">s</span><span class="p">.</span><span class="n">ramaddr</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dev_warn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
				<span class="s">&quot;could not map SRAM; continuing anyway.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">device</span><span class="o">-&gt;</span><span class="n">ram_base</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * The NCR PQS and PDS cards are constructed as a DEC bridge</span>
<span class="cm"> * behind which sits a proprietary NCR memory controller and</span>
<span class="cm"> * either four or two 53c875s as separate devices.  We can tell</span>
<span class="cm"> * if an 875 is part of a PQS/PDS or not since if it is, it will</span>
<span class="cm"> * be on the same bus as the memory controller.  In its usual</span>
<span class="cm"> * mode of operation, the 875s are slaved to the memory</span>
<span class="cm"> * controller for all transfers.  To operate with the Linux</span>
<span class="cm"> * driver, the memory controller is disabled and the 875s</span>
<span class="cm"> * freed to function independently.  The only wrinkle is that</span>
<span class="cm"> * the preset SCSI ID (which may be zero) must be read in from</span>
<span class="cm"> * a special configuration space register of the 875.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">sym_config_pqs</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sym_device</span> <span class="o">*</span><span class="n">sym_dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">slot</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">tmp</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">slot</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">slot</span> <span class="o">&lt;</span> <span class="mi">256</span><span class="p">;</span> <span class="n">slot</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">memc</span> <span class="o">=</span> <span class="n">pci_get_slot</span><span class="p">(</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">bus</span><span class="p">,</span> <span class="n">slot</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">memc</span> <span class="o">||</span> <span class="n">memc</span><span class="o">-&gt;</span><span class="n">vendor</span> <span class="o">!=</span> <span class="mh">0x101a</span> <span class="o">||</span> <span class="n">memc</span><span class="o">-&gt;</span><span class="n">device</span> <span class="o">==</span> <span class="mh">0x0009</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pci_dev_put</span><span class="p">(</span><span class="n">memc</span><span class="p">);</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* bit 1: allow individual 875 configuration */</span>
		<span class="n">pci_read_config_byte</span><span class="p">(</span><span class="n">memc</span><span class="p">,</span> <span class="mh">0x44</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tmp</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">tmp</span> <span class="o">&amp;</span> <span class="mh">0x2</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">tmp</span> <span class="o">|=</span> <span class="mh">0x2</span><span class="p">;</span>
			<span class="n">pci_write_config_byte</span><span class="p">(</span><span class="n">memc</span><span class="p">,</span> <span class="mh">0x44</span><span class="p">,</span> <span class="n">tmp</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="cm">/* bit 2: drive individual 875 interrupts to the bus */</span>
		<span class="n">pci_read_config_byte</span><span class="p">(</span><span class="n">memc</span><span class="p">,</span> <span class="mh">0x45</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tmp</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">tmp</span> <span class="o">&amp;</span> <span class="mh">0x4</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">tmp</span> <span class="o">|=</span> <span class="mh">0x4</span><span class="p">;</span>
			<span class="n">pci_write_config_byte</span><span class="p">(</span><span class="n">memc</span><span class="p">,</span> <span class="mh">0x45</span><span class="p">,</span> <span class="n">tmp</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="n">pci_dev_put</span><span class="p">(</span><span class="n">memc</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">pci_read_config_byte</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="mh">0x84</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tmp</span><span class="p">);</span>
	<span class="n">sym_dev</span><span class="o">-&gt;</span><span class="n">host_id</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *  Called before unloading the module.</span>
<span class="cm"> *  Detach the host.</span>
<span class="cm"> *  We have to free resources and halt the NCR chip.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">sym_detach</span><span class="p">(</span><span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sym_hcb</span> <span class="o">*</span><span class="n">np</span> <span class="o">=</span> <span class="n">sym_get_hcb</span><span class="p">(</span><span class="n">shost</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%s: detaching ...</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">sym_name</span><span class="p">(</span><span class="n">np</span><span class="p">));</span>

	<span class="n">del_timer_sync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">s</span><span class="p">.</span><span class="n">timer</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Reset NCR chip.</span>
<span class="cm">	 * We should use sym_soft_reset(), but we don&#39;t want to do </span>
<span class="cm">	 * so, since we may not be safe if interrupts occur.</span>
<span class="cm">	 */</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%s: resetting chip</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">sym_name</span><span class="p">(</span><span class="n">np</span><span class="p">));</span>
	<span class="n">OUTB</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">nc_istat</span><span class="p">,</span> <span class="n">SRST</span><span class="p">);</span>
	<span class="n">INB</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">nc_mbox1</span><span class="p">);</span>
	<span class="n">udelay</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
	<span class="n">OUTB</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">nc_istat</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="n">sym_free_resources</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">pdev</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">scsi_host_put</span><span class="p">(</span><span class="n">shost</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Driver host template.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">scsi_host_template</span> <span class="n">sym2_template</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">module</span>			<span class="o">=</span> <span class="n">THIS_MODULE</span><span class="p">,</span>
	<span class="p">.</span><span class="n">name</span>			<span class="o">=</span> <span class="s">&quot;sym53c8xx&quot;</span><span class="p">,</span>
	<span class="p">.</span><span class="n">info</span>			<span class="o">=</span> <span class="n">sym53c8xx_info</span><span class="p">,</span> 
	<span class="p">.</span><span class="n">queuecommand</span>		<span class="o">=</span> <span class="n">sym53c8xx_queue_command</span><span class="p">,</span>
	<span class="p">.</span><span class="n">slave_alloc</span>		<span class="o">=</span> <span class="n">sym53c8xx_slave_alloc</span><span class="p">,</span>
	<span class="p">.</span><span class="n">slave_configure</span>	<span class="o">=</span> <span class="n">sym53c8xx_slave_configure</span><span class="p">,</span>
	<span class="p">.</span><span class="n">slave_destroy</span>		<span class="o">=</span> <span class="n">sym53c8xx_slave_destroy</span><span class="p">,</span>
	<span class="p">.</span><span class="n">eh_abort_handler</span>	<span class="o">=</span> <span class="n">sym53c8xx_eh_abort_handler</span><span class="p">,</span>
	<span class="p">.</span><span class="n">eh_device_reset_handler</span> <span class="o">=</span> <span class="n">sym53c8xx_eh_device_reset_handler</span><span class="p">,</span>
	<span class="p">.</span><span class="n">eh_bus_reset_handler</span>	<span class="o">=</span> <span class="n">sym53c8xx_eh_bus_reset_handler</span><span class="p">,</span>
	<span class="p">.</span><span class="n">eh_host_reset_handler</span>	<span class="o">=</span> <span class="n">sym53c8xx_eh_host_reset_handler</span><span class="p">,</span>
	<span class="p">.</span><span class="n">this_id</span>		<span class="o">=</span> <span class="mi">7</span><span class="p">,</span>
	<span class="p">.</span><span class="n">use_clustering</span>		<span class="o">=</span> <span class="n">ENABLE_CLUSTERING</span><span class="p">,</span>
	<span class="p">.</span><span class="n">max_sectors</span>		<span class="o">=</span> <span class="mh">0xFFFF</span><span class="p">,</span>
<span class="cp">#ifdef SYM_LINUX_PROC_INFO_SUPPORT</span>
	<span class="p">.</span><span class="n">proc_info</span>		<span class="o">=</span> <span class="n">sym53c8xx_proc_info</span><span class="p">,</span>
	<span class="p">.</span><span class="n">proc_name</span>		<span class="o">=</span> <span class="n">NAME53C8XX</span><span class="p">,</span>
<span class="cp">#endif</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">attach_count</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__devinit</span> <span class="nf">sym2_probe</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">,</span>
				<span class="k">const</span> <span class="k">struct</span> <span class="n">pci_device_id</span> <span class="o">*</span><span class="n">ent</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sym_device</span> <span class="n">sym_dev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sym_nvram</span> <span class="n">nvram</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">do_iounmap</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">do_disable_device</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sym_dev</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">sym_dev</span><span class="p">));</span>
	<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nvram</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">nvram</span><span class="p">));</span>
	<span class="n">sym_dev</span><span class="p">.</span><span class="n">pdev</span> <span class="o">=</span> <span class="n">pdev</span><span class="p">;</span>
	<span class="n">sym_dev</span><span class="p">.</span><span class="n">host_id</span> <span class="o">=</span> <span class="n">SYM_SETUP_HOST_ID</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pci_enable_device</span><span class="p">(</span><span class="n">pdev</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">leave</span><span class="p">;</span>

	<span class="n">pci_set_master</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pci_request_regions</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">NAME53C8XX</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">disable</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sym_check_supported</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sym_dev</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">free</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sym_iomap_device</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sym_dev</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">free</span><span class="p">;</span>
	<span class="n">do_iounmap</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sym_check_raid</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sym_dev</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">do_disable_device</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>	<span class="cm">/* Don&#39;t disable the device */</span>
		<span class="k">goto</span> <span class="n">free</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sym_set_workarounds</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sym_dev</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">free</span><span class="p">;</span>

	<span class="n">sym_config_pqs</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sym_dev</span><span class="p">);</span>

	<span class="n">sym_get_nvram</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sym_dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">nvram</span><span class="p">);</span>

	<span class="n">do_iounmap</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="cm">/* Don&#39;t sym_iounmap_device() after sym_attach(). */</span>
	<span class="n">shost</span> <span class="o">=</span> <span class="n">sym_attach</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sym2_template</span><span class="p">,</span> <span class="n">attach_count</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sym_dev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">shost</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">free</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">scsi_add_host</span><span class="p">(</span><span class="n">shost</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">detach</span><span class="p">;</span>
	<span class="n">scsi_scan_host</span><span class="p">(</span><span class="n">shost</span><span class="p">);</span>

	<span class="n">attach_count</span><span class="o">++</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

 <span class="nl">detach:</span>
	<span class="n">sym_detach</span><span class="p">(</span><span class="n">pci_get_drvdata</span><span class="p">(</span><span class="n">pdev</span><span class="p">),</span> <span class="n">pdev</span><span class="p">);</span>
 <span class="nl">free:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">do_iounmap</span><span class="p">)</span>
		<span class="n">sym_iounmap_device</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sym_dev</span><span class="p">);</span>
	<span class="n">pci_release_regions</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
 <span class="nl">disable:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">do_disable_device</span><span class="p">)</span>
		<span class="n">pci_disable_device</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
 <span class="nl">leave:</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">sym2_remove</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span> <span class="o">=</span> <span class="n">pci_get_drvdata</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>

	<span class="n">scsi_remove_host</span><span class="p">(</span><span class="n">shost</span><span class="p">);</span>
	<span class="n">sym_detach</span><span class="p">(</span><span class="n">shost</span><span class="p">,</span> <span class="n">pdev</span><span class="p">);</span>
	<span class="n">pci_release_regions</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="n">pci_disable_device</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>

	<span class="n">attach_count</span><span class="o">--</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * sym2_io_error_detected() - called when PCI error is detected</span>
<span class="cm"> * @pdev: pointer to PCI device</span>
<span class="cm"> * @state: current state of the PCI slot</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">pci_ers_result_t</span> <span class="nf">sym2_io_error_detected</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">,</span>
                                         <span class="k">enum</span> <span class="n">pci_channel_state</span> <span class="n">state</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* If slot is permanently frozen, turn everything off */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">state</span> <span class="o">==</span> <span class="n">pci_channel_io_perm_failure</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">sym2_remove</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">PCI_ERS_RESULT_DISCONNECT</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">disable_irq</span><span class="p">(</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">);</span>
	<span class="n">pci_disable_device</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>

	<span class="cm">/* Request that MMIO be enabled, so register dump can be taken. */</span>
	<span class="k">return</span> <span class="n">PCI_ERS_RESULT_CAN_RECOVER</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * sym2_io_slot_dump - Enable MMIO and dump debug registers</span>
<span class="cm"> * @pdev: pointer to PCI device</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">pci_ers_result_t</span> <span class="nf">sym2_io_slot_dump</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span> <span class="o">=</span> <span class="n">pci_get_drvdata</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>

	<span class="n">sym_dump_registers</span><span class="p">(</span><span class="n">shost</span><span class="p">);</span>

	<span class="cm">/* Request a slot reset. */</span>
	<span class="k">return</span> <span class="n">PCI_ERS_RESULT_NEED_RESET</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * sym2_reset_workarounds - hardware-specific work-arounds</span>
<span class="cm"> *</span>
<span class="cm"> * This routine is similar to sym_set_workarounds(), except</span>
<span class="cm"> * that, at this point, we already know that the device was</span>
<span class="cm"> * successfully initialized at least once before, and so most</span>
<span class="cm"> * of the steps taken there are un-needed here.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">sym2_reset_workarounds</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u_short</span> <span class="n">status_reg</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sym_chip</span> <span class="o">*</span><span class="n">chip</span><span class="p">;</span>

	<span class="n">chip</span> <span class="o">=</span> <span class="n">sym_lookup_chip_table</span><span class="p">(</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">device</span><span class="p">,</span> <span class="n">pdev</span><span class="o">-&gt;</span><span class="n">revision</span><span class="p">);</span>

	<span class="cm">/* Work around for errant bit in 895A, in a fashion</span>
<span class="cm">	 * similar to what is done in sym_set_workarounds().</span>
<span class="cm">	 */</span>
	<span class="n">pci_read_config_word</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">PCI_STATUS</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">status_reg</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">features</span> <span class="o">&amp;</span> <span class="n">FE_66MHZ</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">status_reg</span> <span class="o">&amp;</span> <span class="n">PCI_STATUS_66MHZ</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">status_reg</span> <span class="o">=</span> <span class="n">PCI_STATUS_66MHZ</span><span class="p">;</span>
		<span class="n">pci_write_config_word</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">PCI_STATUS</span><span class="p">,</span> <span class="n">status_reg</span><span class="p">);</span>
		<span class="n">pci_read_config_word</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">PCI_STATUS</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">status_reg</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * sym2_io_slot_reset() - called when the pci bus has been reset.</span>
<span class="cm"> * @pdev: pointer to PCI device</span>
<span class="cm"> *</span>
<span class="cm"> * Restart the card from scratch.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">pci_ers_result_t</span> <span class="nf">sym2_io_slot_reset</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span> <span class="o">=</span> <span class="n">pci_get_drvdata</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">sym_hcb</span> <span class="o">*</span><span class="n">np</span> <span class="o">=</span> <span class="n">sym_get_hcb</span><span class="p">(</span><span class="n">shost</span><span class="p">);</span>

	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;%s: recovering from a PCI slot reset</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	          <span class="n">sym_name</span><span class="p">(</span><span class="n">np</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pci_enable_device</span><span class="p">(</span><span class="n">pdev</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;%s: Unable to enable after PCI reset</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		        <span class="n">sym_name</span><span class="p">(</span><span class="n">np</span><span class="p">));</span>
		<span class="k">return</span> <span class="n">PCI_ERS_RESULT_DISCONNECT</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">pci_set_master</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="n">enable_irq</span><span class="p">(</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">);</span>

	<span class="cm">/* If the chip can do Memory Write Invalidate, enable it */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">features</span> <span class="o">&amp;</span> <span class="n">FE_WRIE</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pci_set_mwi</span><span class="p">(</span><span class="n">pdev</span><span class="p">))</span>
			<span class="k">return</span> <span class="n">PCI_ERS_RESULT_DISCONNECT</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Perform work-arounds, analogous to sym_set_workarounds() */</span>
	<span class="n">sym2_reset_workarounds</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>

	<span class="cm">/* Perform host reset only on one instance of the card */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">PCI_FUNC</span><span class="p">(</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">devfn</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sym_reset_scsi_bus</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;%s: Unable to reset scsi host</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			        <span class="n">sym_name</span><span class="p">(</span><span class="n">np</span><span class="p">));</span>
			<span class="k">return</span> <span class="n">PCI_ERS_RESULT_DISCONNECT</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">sym_start_up</span><span class="p">(</span><span class="n">shost</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">PCI_ERS_RESULT_RECOVERED</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * sym2_io_resume() - resume normal ops after PCI reset</span>
<span class="cm"> * @pdev: pointer to PCI device</span>
<span class="cm"> *</span>
<span class="cm"> * Called when the error recovery driver tells us that its</span>
<span class="cm"> * OK to resume normal operation. Use completion to allow</span>
<span class="cm"> * halted scsi ops to resume.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">sym2_io_resume</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span> <span class="o">=</span> <span class="n">pci_get_drvdata</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">sym_data</span> <span class="o">*</span><span class="n">sym_data</span> <span class="o">=</span> <span class="n">shost_priv</span><span class="p">(</span><span class="n">shost</span><span class="p">);</span>

	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sym_data</span><span class="o">-&gt;</span><span class="n">io_reset</span><span class="p">)</span>
		<span class="n">complete_all</span><span class="p">(</span><span class="n">sym_data</span><span class="o">-&gt;</span><span class="n">io_reset</span><span class="p">);</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">sym2_get_signalling</span><span class="p">(</span><span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sym_hcb</span> <span class="o">*</span><span class="n">np</span> <span class="o">=</span> <span class="n">sym_get_hcb</span><span class="p">(</span><span class="n">shost</span><span class="p">);</span>
	<span class="k">enum</span> <span class="n">spi_signal_type</span> <span class="n">type</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">scsi_mode</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">SMODE_SE</span>:
		<span class="n">type</span> <span class="o">=</span> <span class="n">SPI_SIGNAL_SE</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SMODE_LVD</span>:
		<span class="n">type</span> <span class="o">=</span> <span class="n">SPI_SIGNAL_LVD</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SMODE_HVD</span>:
		<span class="n">type</span> <span class="o">=</span> <span class="n">SPI_SIGNAL_HVD</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">type</span> <span class="o">=</span> <span class="n">SPI_SIGNAL_UNKNOWN</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">spi_signalling</span><span class="p">(</span><span class="n">shost</span><span class="p">)</span> <span class="o">=</span> <span class="n">type</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">sym2_set_offset</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_target</span> <span class="o">*</span><span class="n">starget</span><span class="p">,</span> <span class="kt">int</span> <span class="n">offset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span> <span class="o">=</span> <span class="n">dev_to_shost</span><span class="p">(</span><span class="n">starget</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">parent</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">sym_hcb</span> <span class="o">*</span><span class="n">np</span> <span class="o">=</span> <span class="n">sym_get_hcb</span><span class="p">(</span><span class="n">shost</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">sym_tcb</span> <span class="o">*</span><span class="n">tp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">target</span><span class="p">[</span><span class="n">starget</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">];</span>

	<span class="n">tp</span><span class="o">-&gt;</span><span class="n">tgoal</span><span class="p">.</span><span class="n">offset</span> <span class="o">=</span> <span class="n">offset</span><span class="p">;</span>
	<span class="n">tp</span><span class="o">-&gt;</span><span class="n">tgoal</span><span class="p">.</span><span class="n">check_nego</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">sym2_set_period</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_target</span> <span class="o">*</span><span class="n">starget</span><span class="p">,</span> <span class="kt">int</span> <span class="n">period</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span> <span class="o">=</span> <span class="n">dev_to_shost</span><span class="p">(</span><span class="n">starget</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">parent</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">sym_hcb</span> <span class="o">*</span><span class="n">np</span> <span class="o">=</span> <span class="n">sym_get_hcb</span><span class="p">(</span><span class="n">shost</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">sym_tcb</span> <span class="o">*</span><span class="n">tp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">target</span><span class="p">[</span><span class="n">starget</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">];</span>

	<span class="cm">/* have to have DT for these transfers, but DT will also</span>
<span class="cm">	 * set width, so check that this is allowed */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">period</span> <span class="o">&lt;=</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">minsync</span> <span class="o">&amp;&amp;</span> <span class="n">spi_width</span><span class="p">(</span><span class="n">starget</span><span class="p">))</span>
		<span class="n">tp</span><span class="o">-&gt;</span><span class="n">tgoal</span><span class="p">.</span><span class="n">dt</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">tp</span><span class="o">-&gt;</span><span class="n">tgoal</span><span class="p">.</span><span class="n">period</span> <span class="o">=</span> <span class="n">period</span><span class="p">;</span>
	<span class="n">tp</span><span class="o">-&gt;</span><span class="n">tgoal</span><span class="p">.</span><span class="n">check_nego</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">sym2_set_width</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_target</span> <span class="o">*</span><span class="n">starget</span><span class="p">,</span> <span class="kt">int</span> <span class="n">width</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span> <span class="o">=</span> <span class="n">dev_to_shost</span><span class="p">(</span><span class="n">starget</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">parent</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">sym_hcb</span> <span class="o">*</span><span class="n">np</span> <span class="o">=</span> <span class="n">sym_get_hcb</span><span class="p">(</span><span class="n">shost</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">sym_tcb</span> <span class="o">*</span><span class="n">tp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">target</span><span class="p">[</span><span class="n">starget</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">];</span>

	<span class="cm">/* It is illegal to have DT set on narrow transfers.  If DT is</span>
<span class="cm">	 * clear, we must also clear IU and QAS.  */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">width</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">tp</span><span class="o">-&gt;</span><span class="n">tgoal</span><span class="p">.</span><span class="n">iu</span> <span class="o">=</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">tgoal</span><span class="p">.</span><span class="n">dt</span> <span class="o">=</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">tgoal</span><span class="p">.</span><span class="n">qas</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">tp</span><span class="o">-&gt;</span><span class="n">tgoal</span><span class="p">.</span><span class="n">width</span> <span class="o">=</span> <span class="n">width</span><span class="p">;</span>
	<span class="n">tp</span><span class="o">-&gt;</span><span class="n">tgoal</span><span class="p">.</span><span class="n">check_nego</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">sym2_set_dt</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_target</span> <span class="o">*</span><span class="n">starget</span><span class="p">,</span> <span class="kt">int</span> <span class="n">dt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span> <span class="o">=</span> <span class="n">dev_to_shost</span><span class="p">(</span><span class="n">starget</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">parent</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">sym_hcb</span> <span class="o">*</span><span class="n">np</span> <span class="o">=</span> <span class="n">sym_get_hcb</span><span class="p">(</span><span class="n">shost</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">sym_tcb</span> <span class="o">*</span><span class="n">tp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">target</span><span class="p">[</span><span class="n">starget</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">];</span>

	<span class="cm">/* We must clear QAS and IU if DT is clear */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dt</span><span class="p">)</span>
		<span class="n">tp</span><span class="o">-&gt;</span><span class="n">tgoal</span><span class="p">.</span><span class="n">dt</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">tp</span><span class="o">-&gt;</span><span class="n">tgoal</span><span class="p">.</span><span class="n">iu</span> <span class="o">=</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">tgoal</span><span class="p">.</span><span class="n">dt</span> <span class="o">=</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">tgoal</span><span class="p">.</span><span class="n">qas</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">tp</span><span class="o">-&gt;</span><span class="n">tgoal</span><span class="p">.</span><span class="n">check_nego</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#if 0</span><span class="c"></span>
<span class="c">static void sym2_set_iu(struct scsi_target *starget, int iu)</span>
<span class="c">{</span>
<span class="c">	struct Scsi_Host *shost = dev_to_shost(starget-&gt;dev.parent);</span>
<span class="c">	struct sym_hcb *np = sym_get_hcb(shost);</span>
<span class="c">	struct sym_tcb *tp = &amp;np-&gt;target[starget-&gt;id];</span>

<span class="c">	if (iu)</span>
<span class="c">		tp-&gt;tgoal.iu = tp-&gt;tgoal.dt = 1;</span>
<span class="c">	else</span>
<span class="c">		tp-&gt;tgoal.iu = 0;</span>
<span class="c">	tp-&gt;tgoal.check_nego = 1;</span>
<span class="c">}</span>

<span class="c">static void sym2_set_qas(struct scsi_target *starget, int qas)</span>
<span class="c">{</span>
<span class="c">	struct Scsi_Host *shost = dev_to_shost(starget-&gt;dev.parent);</span>
<span class="c">	struct sym_hcb *np = sym_get_hcb(shost);</span>
<span class="c">	struct sym_tcb *tp = &amp;np-&gt;target[starget-&gt;id];</span>

<span class="c">	if (qas)</span>
<span class="c">		tp-&gt;tgoal.dt = tp-&gt;tgoal.qas = 1;</span>
<span class="c">	else</span>
<span class="c">		tp-&gt;tgoal.qas = 0;</span>
<span class="c">	tp-&gt;tgoal.check_nego = 1;</span>
<span class="c">}</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">spi_function_template</span> <span class="n">sym2_transport_functions</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">set_offset</span>	<span class="o">=</span> <span class="n">sym2_set_offset</span><span class="p">,</span>
	<span class="p">.</span><span class="n">show_offset</span>	<span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
	<span class="p">.</span><span class="n">set_period</span>	<span class="o">=</span> <span class="n">sym2_set_period</span><span class="p">,</span>
	<span class="p">.</span><span class="n">show_period</span>	<span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
	<span class="p">.</span><span class="n">set_width</span>	<span class="o">=</span> <span class="n">sym2_set_width</span><span class="p">,</span>
	<span class="p">.</span><span class="n">show_width</span>	<span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
	<span class="p">.</span><span class="n">set_dt</span>		<span class="o">=</span> <span class="n">sym2_set_dt</span><span class="p">,</span>
	<span class="p">.</span><span class="n">show_dt</span>	<span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
<span class="cp">#if 0</span><span class="c"></span>
<span class="c">	.set_iu		= sym2_set_iu,</span>
<span class="c">	.show_iu	= 1,</span>
<span class="c">	.set_qas	= sym2_set_qas,</span>
<span class="c">	.show_qas	= 1,</span>
<span class="cp">#endif</span>
	<span class="p">.</span><span class="n">get_signalling</span>	<span class="o">=</span> <span class="n">sym2_get_signalling</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">pci_device_id</span> <span class="n">sym2_id_table</span><span class="p">[]</span> <span class="n">__devinitdata</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">{</span> <span class="n">PCI_VENDOR_ID_LSI_LOGIC</span><span class="p">,</span> <span class="n">PCI_DEVICE_ID_NCR_53C810</span><span class="p">,</span>
	  <span class="n">PCI_ANY_ID</span><span class="p">,</span> <span class="n">PCI_ANY_ID</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0UL</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">PCI_VENDOR_ID_LSI_LOGIC</span><span class="p">,</span> <span class="n">PCI_DEVICE_ID_NCR_53C820</span><span class="p">,</span>
	  <span class="n">PCI_ANY_ID</span><span class="p">,</span> <span class="n">PCI_ANY_ID</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0UL</span> <span class="p">},</span> <span class="cm">/* new */</span>
	<span class="p">{</span> <span class="n">PCI_VENDOR_ID_LSI_LOGIC</span><span class="p">,</span> <span class="n">PCI_DEVICE_ID_NCR_53C825</span><span class="p">,</span>
	  <span class="n">PCI_ANY_ID</span><span class="p">,</span> <span class="n">PCI_ANY_ID</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0UL</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">PCI_VENDOR_ID_LSI_LOGIC</span><span class="p">,</span> <span class="n">PCI_DEVICE_ID_NCR_53C815</span><span class="p">,</span>
	  <span class="n">PCI_ANY_ID</span><span class="p">,</span> <span class="n">PCI_ANY_ID</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0UL</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">PCI_VENDOR_ID_LSI_LOGIC</span><span class="p">,</span> <span class="n">PCI_DEVICE_ID_LSI_53C810AP</span><span class="p">,</span>
	  <span class="n">PCI_ANY_ID</span><span class="p">,</span> <span class="n">PCI_ANY_ID</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0UL</span> <span class="p">},</span> <span class="cm">/* new */</span>
	<span class="p">{</span> <span class="n">PCI_VENDOR_ID_LSI_LOGIC</span><span class="p">,</span> <span class="n">PCI_DEVICE_ID_NCR_53C860</span><span class="p">,</span>
	  <span class="n">PCI_ANY_ID</span><span class="p">,</span> <span class="n">PCI_ANY_ID</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0UL</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">PCI_VENDOR_ID_LSI_LOGIC</span><span class="p">,</span> <span class="n">PCI_DEVICE_ID_LSI_53C1510</span><span class="p">,</span>
	  <span class="n">PCI_ANY_ID</span><span class="p">,</span> <span class="n">PCI_ANY_ID</span><span class="p">,</span> <span class="n">PCI_CLASS_STORAGE_SCSI</span><span class="o">&lt;&lt;</span><span class="mi">8</span><span class="p">,</span>  <span class="mh">0xffff00</span><span class="p">,</span> <span class="mi">0UL</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">PCI_VENDOR_ID_LSI_LOGIC</span><span class="p">,</span> <span class="n">PCI_DEVICE_ID_NCR_53C896</span><span class="p">,</span>
	  <span class="n">PCI_ANY_ID</span><span class="p">,</span> <span class="n">PCI_ANY_ID</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0UL</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">PCI_VENDOR_ID_LSI_LOGIC</span><span class="p">,</span> <span class="n">PCI_DEVICE_ID_NCR_53C895</span><span class="p">,</span>
	  <span class="n">PCI_ANY_ID</span><span class="p">,</span> <span class="n">PCI_ANY_ID</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0UL</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">PCI_VENDOR_ID_LSI_LOGIC</span><span class="p">,</span> <span class="n">PCI_DEVICE_ID_NCR_53C885</span><span class="p">,</span>
	  <span class="n">PCI_ANY_ID</span><span class="p">,</span> <span class="n">PCI_ANY_ID</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0UL</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">PCI_VENDOR_ID_LSI_LOGIC</span><span class="p">,</span> <span class="n">PCI_DEVICE_ID_NCR_53C875</span><span class="p">,</span>
	  <span class="n">PCI_ANY_ID</span><span class="p">,</span> <span class="n">PCI_ANY_ID</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0UL</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">PCI_VENDOR_ID_LSI_LOGIC</span><span class="p">,</span> <span class="n">PCI_DEVICE_ID_NCR_53C1510</span><span class="p">,</span>
	  <span class="n">PCI_ANY_ID</span><span class="p">,</span> <span class="n">PCI_ANY_ID</span><span class="p">,</span>  <span class="n">PCI_CLASS_STORAGE_SCSI</span><span class="o">&lt;&lt;</span><span class="mi">8</span><span class="p">,</span>  <span class="mh">0xffff00</span><span class="p">,</span> <span class="mi">0UL</span> <span class="p">},</span> <span class="cm">/* new */</span>
	<span class="p">{</span> <span class="n">PCI_VENDOR_ID_LSI_LOGIC</span><span class="p">,</span> <span class="n">PCI_DEVICE_ID_LSI_53C895A</span><span class="p">,</span>
	  <span class="n">PCI_ANY_ID</span><span class="p">,</span> <span class="n">PCI_ANY_ID</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0UL</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">PCI_VENDOR_ID_LSI_LOGIC</span><span class="p">,</span> <span class="n">PCI_DEVICE_ID_LSI_53C875A</span><span class="p">,</span>
	  <span class="n">PCI_ANY_ID</span><span class="p">,</span> <span class="n">PCI_ANY_ID</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0UL</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">PCI_VENDOR_ID_LSI_LOGIC</span><span class="p">,</span> <span class="n">PCI_DEVICE_ID_LSI_53C1010_33</span><span class="p">,</span>
	  <span class="n">PCI_ANY_ID</span><span class="p">,</span> <span class="n">PCI_ANY_ID</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0UL</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">PCI_VENDOR_ID_LSI_LOGIC</span><span class="p">,</span> <span class="n">PCI_DEVICE_ID_LSI_53C1010_66</span><span class="p">,</span>
	  <span class="n">PCI_ANY_ID</span><span class="p">,</span> <span class="n">PCI_ANY_ID</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0UL</span> <span class="p">},</span>
	<span class="p">{</span> <span class="n">PCI_VENDOR_ID_LSI_LOGIC</span><span class="p">,</span> <span class="n">PCI_DEVICE_ID_NCR_53C875J</span><span class="p">,</span>
	  <span class="n">PCI_ANY_ID</span><span class="p">,</span> <span class="n">PCI_ANY_ID</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0UL</span> <span class="p">},</span>
	<span class="p">{</span> <span class="mi">0</span><span class="p">,</span> <span class="p">}</span>
<span class="p">};</span>

<span class="n">MODULE_DEVICE_TABLE</span><span class="p">(</span><span class="n">pci</span><span class="p">,</span> <span class="n">sym2_id_table</span><span class="p">);</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">pci_error_handlers</span> <span class="n">sym2_err_handler</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">error_detected</span>	<span class="o">=</span> <span class="n">sym2_io_error_detected</span><span class="p">,</span>
	<span class="p">.</span><span class="n">mmio_enabled</span>	<span class="o">=</span> <span class="n">sym2_io_slot_dump</span><span class="p">,</span>
	<span class="p">.</span><span class="n">slot_reset</span>	<span class="o">=</span> <span class="n">sym2_io_slot_reset</span><span class="p">,</span>
	<span class="p">.</span><span class="n">resume</span>		<span class="o">=</span> <span class="n">sym2_io_resume</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">pci_driver</span> <span class="n">sym2_driver</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">name</span>		<span class="o">=</span> <span class="n">NAME53C8XX</span><span class="p">,</span>
	<span class="p">.</span><span class="n">id_table</span>	<span class="o">=</span> <span class="n">sym2_id_table</span><span class="p">,</span>
	<span class="p">.</span><span class="n">probe</span>		<span class="o">=</span> <span class="n">sym2_probe</span><span class="p">,</span>
	<span class="p">.</span><span class="n">remove</span>		<span class="o">=</span> <span class="n">sym2_remove</span><span class="p">,</span>
	<span class="p">.</span><span class="n">err_handler</span> 	<span class="o">=</span> <span class="o">&amp;</span><span class="n">sym2_err_handler</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">sym2_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>

	<span class="n">sym2_setup_params</span><span class="p">();</span>
	<span class="n">sym2_transport_template</span> <span class="o">=</span> <span class="n">spi_attach_transport</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sym2_transport_functions</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sym2_transport_template</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">pci_register_driver</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sym2_driver</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="n">spi_release_transport</span><span class="p">(</span><span class="n">sym2_transport_template</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__exit</span> <span class="nf">sym2_exit</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pci_unregister_driver</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sym2_driver</span><span class="p">);</span>
	<span class="n">spi_release_transport</span><span class="p">(</span><span class="n">sym2_transport_template</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">module_init</span><span class="p">(</span><span class="n">sym2_init</span><span class="p">);</span>
<span class="n">module_exit</span><span class="p">(</span><span class="n">sym2_exit</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
