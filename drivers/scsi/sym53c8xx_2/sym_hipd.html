<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › scsi › sym53c8xx_2 › sym_hipd.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>sym_hipd.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Device driver for the SYMBIOS/LSILOGIC 53C8XX and 53C1010 family </span>
<span class="cm"> * of PCI-SCSI IO processors.</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 1999-2001  Gerard Roudier &lt;groudier@free.fr&gt;</span>
<span class="cm"> * Copyright (c) 2003-2005  Matthew Wilcox &lt;matthew@wil.cx&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * This driver is derived from the Linux sym53c8xx driver.</span>
<span class="cm"> * Copyright (C) 1998-2000  Gerard Roudier</span>
<span class="cm"> *</span>
<span class="cm"> * The sym53c8xx driver is derived from the ncr53c8xx driver that had been </span>
<span class="cm"> * a port of the FreeBSD ncr driver to Linux-1.2.13.</span>
<span class="cm"> *</span>
<span class="cm"> * The original ncr driver has been written for 386bsd and FreeBSD by</span>
<span class="cm"> *         Wolfgang Stanglmeier        &lt;wolf@cologne.de&gt;</span>
<span class="cm"> *         Stefan Esser                &lt;se@mi.Uni-Koeln.de&gt;</span>
<span class="cm"> * Copyright (C) 1994  Wolfgang Stanglmeier</span>
<span class="cm"> *</span>
<span class="cm"> * Other major contributions:</span>
<span class="cm"> *</span>
<span class="cm"> * NVRAM detection and reading.</span>
<span class="cm"> * Copyright (C) 1997 Richard Waltham &lt;dormouse@farsrobt.demon.co.uk&gt;</span>
<span class="cm"> *</span>
<span class="cm"> *-----------------------------------------------------------------------------</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or modify</span>
<span class="cm"> * it under the terms of the GNU General Public License as published by</span>
<span class="cm"> * the Free Software Foundation; either version 2 of the License, or</span>
<span class="cm"> * (at your option) any later version.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is distributed in the hope that it will be useful,</span>
<span class="cm"> * but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="cm"> * GNU General Public License for more details.</span>
<span class="cm"> *</span>
<span class="cm"> * You should have received a copy of the GNU General Public License</span>
<span class="cm"> * along with this program; if not, write to the Free Software</span>
<span class="cm"> * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;asm/param.h&gt;		</span><span class="cm">/* for timeouts in units of HZ */</span><span class="cp"></span>

<span class="cp">#include &quot;sym_glue.h&quot;</span>
<span class="cp">#include &quot;sym_nvram.h&quot;</span>

<span class="cp">#if 0</span><span class="c"></span>
<span class="c">#define SYM_DEBUG_GENERIC_SUPPORT</span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> *  Needed function prototypes.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">sym_int_ma</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sym_hcb</span> <span class="o">*</span><span class="n">np</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">sym_int_sir</span><span class="p">(</span><span class="k">struct</span> <span class="n">sym_hcb</span> <span class="o">*</span><span class="p">);</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">sym_ccb</span> <span class="o">*</span><span class="n">sym_alloc_ccb</span><span class="p">(</span><span class="k">struct</span> <span class="n">sym_hcb</span> <span class="o">*</span><span class="n">np</span><span class="p">);</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">sym_ccb</span> <span class="o">*</span><span class="n">sym_ccb_from_dsa</span><span class="p">(</span><span class="k">struct</span> <span class="n">sym_hcb</span> <span class="o">*</span><span class="n">np</span><span class="p">,</span> <span class="n">u32</span> <span class="n">dsa</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">sym_alloc_lcb_tags</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sym_hcb</span> <span class="o">*</span><span class="n">np</span><span class="p">,</span> <span class="n">u_char</span> <span class="n">tn</span><span class="p">,</span> <span class="n">u_char</span> <span class="n">ln</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">sym_complete_error</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sym_hcb</span> <span class="o">*</span><span class="n">np</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sym_ccb</span> <span class="o">*</span><span class="n">cp</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">sym_complete_ok</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sym_hcb</span> <span class="o">*</span><span class="n">np</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sym_ccb</span> <span class="o">*</span><span class="n">cp</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">sym_compute_residual</span><span class="p">(</span><span class="k">struct</span> <span class="n">sym_hcb</span> <span class="o">*</span><span class="n">np</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sym_ccb</span> <span class="o">*</span><span class="n">cp</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> *  Print a buffer in hexadecimal format with a &quot;.\n&quot; at end.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">sym_printl_hex</span><span class="p">(</span><span class="n">u_char</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="kt">int</span> <span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">n</span><span class="o">--</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">printf</span> <span class="p">(</span><span class="s">&quot; %x&quot;</span><span class="p">,</span> <span class="o">*</span><span class="n">p</span><span class="o">++</span><span class="p">);</span>
	<span class="n">printf</span> <span class="p">(</span><span class="s">&quot;.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">sym_print_msg</span><span class="p">(</span><span class="k">struct</span> <span class="n">sym_ccb</span> <span class="o">*</span><span class="n">cp</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">label</span><span class="p">,</span> <span class="n">u_char</span> <span class="o">*</span><span class="n">msg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">sym_print_addr</span><span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">cmd</span><span class="p">,</span> <span class="s">&quot;%s: &quot;</span><span class="p">,</span> <span class="n">label</span><span class="p">);</span>

	<span class="n">spi_print_msg</span><span class="p">(</span><span class="n">msg</span><span class="p">);</span>
	<span class="n">printf</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">sym_print_nego_msg</span><span class="p">(</span><span class="k">struct</span> <span class="n">sym_hcb</span> <span class="o">*</span><span class="n">np</span><span class="p">,</span> <span class="kt">int</span> <span class="n">target</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">label</span><span class="p">,</span> <span class="n">u_char</span> <span class="o">*</span><span class="n">msg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sym_tcb</span> <span class="o">*</span><span class="n">tp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">target</span><span class="p">[</span><span class="n">target</span><span class="p">];</span>
	<span class="n">dev_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">starget</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s: &quot;</span><span class="p">,</span> <span class="n">label</span><span class="p">);</span>

	<span class="n">spi_print_msg</span><span class="p">(</span><span class="n">msg</span><span class="p">);</span>
	<span class="n">printf</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *  Print something that tells about extended errors.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">sym_print_xerr</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">,</span> <span class="kt">int</span> <span class="n">x_status</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">x_status</span> <span class="o">&amp;</span> <span class="n">XE_PARITY_ERR</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">sym_print_addr</span><span class="p">(</span><span class="n">cmd</span><span class="p">,</span> <span class="s">&quot;unrecovered SCSI parity error.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">x_status</span> <span class="o">&amp;</span> <span class="n">XE_EXTRA_DATA</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">sym_print_addr</span><span class="p">(</span><span class="n">cmd</span><span class="p">,</span> <span class="s">&quot;extraneous data discarded.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">x_status</span> <span class="o">&amp;</span> <span class="n">XE_BAD_PHASE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">sym_print_addr</span><span class="p">(</span><span class="n">cmd</span><span class="p">,</span> <span class="s">&quot;illegal scsi phase (4/5).</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">x_status</span> <span class="o">&amp;</span> <span class="n">XE_SODL_UNRUN</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">sym_print_addr</span><span class="p">(</span><span class="n">cmd</span><span class="p">,</span> <span class="s">&quot;ODD transfer in DATA OUT phase.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">x_status</span> <span class="o">&amp;</span> <span class="n">XE_SWIDE_OVRUN</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">sym_print_addr</span><span class="p">(</span><span class="n">cmd</span><span class="p">,</span> <span class="s">&quot;ODD transfer in DATA IN phase.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *  Return a string for SCSI BUS mode.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">char</span> <span class="o">*</span><span class="nf">sym_scsi_bus_mode</span><span class="p">(</span><span class="kt">int</span> <span class="n">mode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">switch</span><span class="p">(</span><span class="n">mode</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">SMODE_HVD</span>:	<span class="k">return</span> <span class="s">&quot;HVD&quot;</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SMODE_SE</span>:	<span class="k">return</span> <span class="s">&quot;SE&quot;</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SMODE_LVD</span>: <span class="k">return</span> <span class="s">&quot;LVD&quot;</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="s">&quot;??&quot;</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *  Soft reset the chip.</span>
<span class="cm"> *</span>
<span class="cm"> *  Raising SRST when the chip is running may cause </span>
<span class="cm"> *  problems on dual function chips (see below).</span>
<span class="cm"> *  On the other hand, LVD devices need some delay </span>
<span class="cm"> *  to settle and report actual BUS mode in STEST4.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">sym_chip_reset</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sym_hcb</span> <span class="o">*</span><span class="n">np</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">OUTB</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">nc_istat</span><span class="p">,</span> <span class="n">SRST</span><span class="p">);</span>
	<span class="n">INB</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">nc_mbox1</span><span class="p">);</span>
	<span class="n">udelay</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
	<span class="n">OUTB</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">nc_istat</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">INB</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">nc_mbox1</span><span class="p">);</span>
	<span class="n">udelay</span><span class="p">(</span><span class="mi">2000</span><span class="p">);</span>	<span class="cm">/* For BUS MODE to settle */</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *  Really soft reset the chip.:)</span>
<span class="cm"> *</span>
<span class="cm"> *  Some 896 and 876 chip revisions may hang-up if we set </span>
<span class="cm"> *  the SRST (soft reset) bit at the wrong time when SCRIPTS </span>
<span class="cm"> *  are running.</span>
<span class="cm"> *  So, we need to abort the current operation prior to </span>
<span class="cm"> *  soft resetting the chip.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">sym_soft_reset</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sym_hcb</span> <span class="o">*</span><span class="n">np</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u_char</span> <span class="n">istat</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">features</span> <span class="o">&amp;</span> <span class="n">FE_ISTAT1</span><span class="p">)</span> <span class="o">||</span> <span class="o">!</span><span class="p">(</span><span class="n">INB</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">nc_istat1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">SCRUN</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">do_chip_reset</span><span class="p">;</span>

	<span class="n">OUTB</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">nc_istat</span><span class="p">,</span> <span class="n">CABRT</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">100000</span> <span class="p">;</span> <span class="n">i</span> <span class="p">;</span> <span class="o">--</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">istat</span> <span class="o">=</span> <span class="n">INB</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">nc_istat</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">istat</span> <span class="o">&amp;</span> <span class="n">SIP</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">INW</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">nc_sist</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">istat</span> <span class="o">&amp;</span> <span class="n">DIP</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">INB</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">nc_dstat</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">ABRT</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">udelay</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">OUTB</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">nc_istat</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">i</span><span class="p">)</span>
		<span class="n">printf</span><span class="p">(</span><span class="s">&quot;%s: unable to abort current chip operation, &quot;</span>
		       <span class="s">&quot;ISTAT=0x%02x.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">sym_name</span><span class="p">(</span><span class="n">np</span><span class="p">),</span> <span class="n">istat</span><span class="p">);</span>
<span class="nl">do_chip_reset:</span>
	<span class="n">sym_chip_reset</span><span class="p">(</span><span class="n">np</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *  Start reset process.</span>
<span class="cm"> *</span>
<span class="cm"> *  The interrupt handler will reinitialize the chip.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">sym_start_reset</span><span class="p">(</span><span class="k">struct</span> <span class="n">sym_hcb</span> <span class="o">*</span><span class="n">np</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">sym_reset_scsi_bus</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>
 
<span class="kt">int</span> <span class="nf">sym_reset_scsi_bus</span><span class="p">(</span><span class="k">struct</span> <span class="n">sym_hcb</span> <span class="o">*</span><span class="n">np</span><span class="p">,</span> <span class="kt">int</span> <span class="n">enab_int</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">term</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">retv</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">sym_soft_reset</span><span class="p">(</span><span class="n">np</span><span class="p">);</span>	<span class="cm">/* Soft reset the chip */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">enab_int</span><span class="p">)</span>
		<span class="n">OUTW</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">nc_sien</span><span class="p">,</span> <span class="n">RST</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 *  Enable Tolerant, reset IRQD if present and </span>
<span class="cm">	 *  properly set IRQ mode, prior to resetting the bus.</span>
<span class="cm">	 */</span>
	<span class="n">OUTB</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">nc_stest3</span><span class="p">,</span> <span class="n">TE</span><span class="p">);</span>
	<span class="n">OUTB</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">nc_dcntl</span><span class="p">,</span> <span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">rv_dcntl</span> <span class="o">&amp;</span> <span class="n">IRQM</span><span class="p">));</span>
	<span class="n">OUTB</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">nc_scntl1</span><span class="p">,</span> <span class="n">CRST</span><span class="p">);</span>
	<span class="n">INB</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">nc_mbox1</span><span class="p">);</span>
	<span class="n">udelay</span><span class="p">(</span><span class="mi">200</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">SYM_SETUP_SCSI_BUS_CHECK</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 *  Check for no terminators or SCSI bus shorts to ground.</span>
<span class="cm">	 *  Read SCSI data bus, data parity bits and control signals.</span>
<span class="cm">	 *  We are expecting RESET to be TRUE and other signals to be </span>
<span class="cm">	 *  FALSE.</span>
<span class="cm">	 */</span>
	<span class="n">term</span> <span class="o">=</span>	<span class="n">INB</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">nc_sstat0</span><span class="p">);</span>
	<span class="n">term</span> <span class="o">=</span>	<span class="p">((</span><span class="n">term</span> <span class="o">&amp;</span> <span class="mi">2</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">7</span><span class="p">)</span> <span class="o">+</span> <span class="p">((</span><span class="n">term</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">17</span><span class="p">);</span>	<span class="cm">/* rst sdp0 */</span>
	<span class="n">term</span> <span class="o">|=</span> <span class="p">((</span><span class="n">INB</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">nc_sstat2</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x01</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">26</span><span class="p">)</span> <span class="o">|</span>	<span class="cm">/* sdp1     */</span>
		<span class="p">((</span><span class="n">INW</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">nc_sbdl</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">)</span>   <span class="o">&lt;&lt;</span> <span class="mi">9</span><span class="p">)</span>  <span class="o">|</span>	<span class="cm">/* d7-0     */</span>
		<span class="p">((</span><span class="n">INW</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">nc_sbdl</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xff00</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">10</span><span class="p">)</span> <span class="o">|</span>	<span class="cm">/* d15-8    */</span>
		<span class="n">INB</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">nc_sbcl</span><span class="p">);</span>	<span class="cm">/* req ack bsy sel atn msg cd io    */</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">maxwide</span><span class="p">)</span>
		<span class="n">term</span> <span class="o">&amp;=</span> <span class="mh">0x3ffff</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">term</span> <span class="o">!=</span> <span class="p">(</span><span class="mi">2</span><span class="o">&lt;&lt;</span><span class="mi">7</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">printf</span><span class="p">(</span><span class="s">&quot;%s: suspicious SCSI data while resetting the BUS.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">sym_name</span><span class="p">(</span><span class="n">np</span><span class="p">));</span>
		<span class="n">printf</span><span class="p">(</span><span class="s">&quot;%s: %sdp0,d7-0,rst,req,ack,bsy,sel,atn,msg,c/d,i/o = &quot;</span>
			<span class="s">&quot;0x%lx, expecting 0x%lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">sym_name</span><span class="p">(</span><span class="n">np</span><span class="p">),</span>
			<span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">features</span> <span class="o">&amp;</span> <span class="n">FE_WIDE</span><span class="p">)</span> <span class="o">?</span> <span class="s">&quot;dp1,d15-8,&quot;</span> <span class="o">:</span> <span class="s">&quot;&quot;</span><span class="p">,</span>
			<span class="p">(</span><span class="n">u_long</span><span class="p">)</span><span class="n">term</span><span class="p">,</span> <span class="p">(</span><span class="n">u_long</span><span class="p">)(</span><span class="mi">2</span><span class="o">&lt;&lt;</span><span class="mi">7</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">SYM_SETUP_SCSI_BUS_CHECK</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
			<span class="n">retv</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
<span class="nl">out:</span>
	<span class="n">OUTB</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">nc_scntl1</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">retv</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *  Select SCSI clock frequency</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">sym_selectclock</span><span class="p">(</span><span class="k">struct</span> <span class="n">sym_hcb</span> <span class="o">*</span><span class="n">np</span><span class="p">,</span> <span class="n">u_char</span> <span class="n">scntl3</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 *  If multiplier not present or not selected, leave here.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">multiplier</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">OUTB</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">nc_scntl3</span><span class="p">,</span> <span class="n">scntl3</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sym_verbose</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">)</span>
		<span class="n">printf</span> <span class="p">(</span><span class="s">&quot;%s: enabling clock multiplier</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">sym_name</span><span class="p">(</span><span class="n">np</span><span class="p">));</span>

	<span class="n">OUTB</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">nc_stest1</span><span class="p">,</span> <span class="n">DBLEN</span><span class="p">);</span>	   <span class="cm">/* Enable clock multiplier */</span>
	<span class="cm">/*</span>
<span class="cm">	 *  Wait for the LCKFRQ bit to be set if supported by the chip.</span>
<span class="cm">	 *  Otherwise wait 50 micro-seconds (at least).</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">features</span> <span class="o">&amp;</span> <span class="n">FE_LCKFRQ</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">20</span><span class="p">;</span>
		<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">INB</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">nc_stest4</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">LCKFRQ</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">--</span><span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">udelay</span><span class="p">(</span><span class="mi">20</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">i</span><span class="p">)</span>
			<span class="n">printf</span><span class="p">(</span><span class="s">&quot;%s: the chip cannot lock the frequency</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">sym_name</span><span class="p">(</span><span class="n">np</span><span class="p">));</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">INB</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">nc_mbox1</span><span class="p">);</span>
		<span class="n">udelay</span><span class="p">(</span><span class="mi">50</span><span class="o">+</span><span class="mi">10</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">OUTB</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">nc_stest3</span><span class="p">,</span> <span class="n">HSC</span><span class="p">);</span>		<span class="cm">/* Halt the scsi clock	*/</span>
	<span class="n">OUTB</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">nc_scntl3</span><span class="p">,</span> <span class="n">scntl3</span><span class="p">);</span>
	<span class="n">OUTB</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">nc_stest1</span><span class="p">,</span> <span class="p">(</span><span class="n">DBLEN</span><span class="o">|</span><span class="n">DBLSEL</span><span class="p">));</span><span class="cm">/* Select clock multiplier	*/</span>
	<span class="n">OUTB</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">nc_stest3</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">);</span>		<span class="cm">/* Restart scsi clock 	*/</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> *  Determine the chip&#39;s clock frequency.</span>
<span class="cm"> *</span>
<span class="cm"> *  This is essential for the negotiation of the synchronous </span>
<span class="cm"> *  transfer rate.</span>
<span class="cm"> *</span>
<span class="cm"> *  Note: we have to return the correct value.</span>
<span class="cm"> *  THERE IS NO SAFE DEFAULT VALUE.</span>
<span class="cm"> *</span>
<span class="cm"> *  Most NCR/SYMBIOS boards are delivered with a 40 Mhz clock.</span>
<span class="cm"> *  53C860 and 53C875 rev. 1 support fast20 transfers but </span>
<span class="cm"> *  do not have a clock doubler and so are provided with a </span>
<span class="cm"> *  80 MHz clock. All other fast20 boards incorporate a doubler </span>
<span class="cm"> *  and so should be delivered with a 40 MHz clock.</span>
<span class="cm"> *  The recent fast40 chips (895/896/895A/1010) use a 40 Mhz base </span>
<span class="cm"> *  clock and provide a clock quadrupler (160 Mhz).</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> *  calculate SCSI clock frequency (in KHz)</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="nf">getfreq</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sym_hcb</span> <span class="o">*</span><span class="n">np</span><span class="p">,</span> <span class="kt">int</span> <span class="n">gen</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ms</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">f</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Measure GEN timer delay in order </span>
<span class="cm">	 * to calculate SCSI clock frequency</span>
<span class="cm">	 *</span>
<span class="cm">	 * This code will never execute too</span>
<span class="cm">	 * many loop iterations (if DELAY is </span>
<span class="cm">	 * reasonably correct). It could get</span>
<span class="cm">	 * too low a delay (too high a freq.)</span>
<span class="cm">	 * if the CPU is slow executing the </span>
<span class="cm">	 * loop for some reason (an NMI, for</span>
<span class="cm">	 * example). For this reason we will</span>
<span class="cm">	 * if multiple measurements are to be </span>
<span class="cm">	 * performed trust the higher delay </span>
<span class="cm">	 * (lower frequency returned).</span>
<span class="cm">	 */</span>
	<span class="n">OUTW</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">nc_sien</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>	<span class="cm">/* mask all scsi interrupts */</span>
	<span class="n">INW</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">nc_sist</span><span class="p">);</span>	<span class="cm">/* clear pending scsi interrupt */</span>
	<span class="n">OUTB</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">nc_dien</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>	<span class="cm">/* mask all dma interrupts */</span>
	<span class="n">INW</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">nc_sist</span><span class="p">);</span>	<span class="cm">/* another one, just to be sure :) */</span>
	<span class="cm">/*</span>
<span class="cm">	 * The C1010-33 core does not report GEN in SIST,</span>
<span class="cm">	 * if this interrupt is masked in SIEN.</span>
<span class="cm">	 * I don&#39;t know yet if the C1010-66 behaves the same way.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">features</span> <span class="o">&amp;</span> <span class="n">FE_C10</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">OUTW</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">nc_sien</span><span class="p">,</span> <span class="n">GEN</span><span class="p">);</span>
		<span class="n">OUTB</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">nc_istat1</span><span class="p">,</span> <span class="n">SIRQD</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">OUTB</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">nc_scntl3</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>	   <span class="cm">/* set pre-scaler to divide by 3 */</span>
	<span class="n">OUTB</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">nc_stime1</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>	   <span class="cm">/* disable general purpose timer */</span>
	<span class="n">OUTB</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">nc_stime1</span><span class="p">,</span> <span class="n">gen</span><span class="p">);</span>  <span class="cm">/* set to nominal delay of 1&lt;&lt;gen * 125us */</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">INW</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">nc_sist</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">GEN</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">ms</span><span class="o">++</span> <span class="o">&lt;</span> <span class="mi">100000</span><span class="p">)</span>
		<span class="n">udelay</span><span class="p">(</span><span class="mi">1000</span><span class="o">/</span><span class="mi">4</span><span class="p">);</span>    <span class="cm">/* count in 1/4 of ms */</span>
	<span class="n">OUTB</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">nc_stime1</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>    <span class="cm">/* disable general purpose timer */</span>
	<span class="cm">/*</span>
<span class="cm">	 * Undo C1010-33 specific settings.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">features</span> <span class="o">&amp;</span> <span class="n">FE_C10</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">OUTW</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">nc_sien</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">OUTB</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">nc_istat1</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>
 	<span class="cm">/*</span>
<span class="cm"> 	 * set prescaler to divide by whatever 0 means</span>
<span class="cm"> 	 * 0 ought to choose divide by 2, but appears</span>
<span class="cm"> 	 * to set divide by 3.5 mode in my 53c810 ...</span>
<span class="cm"> 	 */</span>
 	<span class="n">OUTB</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">nc_scntl3</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

  	<span class="cm">/*</span>
<span class="cm"> 	 * adjust for prescaler, and convert into KHz </span>
<span class="cm">  	 */</span>
	<span class="n">f</span> <span class="o">=</span> <span class="n">ms</span> <span class="o">?</span> <span class="p">((</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">gen</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="mi">4340</span><span class="o">*</span><span class="mi">4</span><span class="p">))</span> <span class="o">/</span> <span class="n">ms</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * The C1010-33 result is biased by a factor </span>
<span class="cm">	 * of 2/3 compared to earlier chips.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">features</span> <span class="o">&amp;</span> <span class="n">FE_C10</span><span class="p">)</span>
		<span class="n">f</span> <span class="o">=</span> <span class="p">(</span><span class="n">f</span> <span class="o">*</span> <span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="mi">3</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sym_verbose</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">)</span>
		<span class="n">printf</span> <span class="p">(</span><span class="s">&quot;%s: Delay (GEN=%d): %u msec, %u KHz</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">sym_name</span><span class="p">(</span><span class="n">np</span><span class="p">),</span> <span class="n">gen</span><span class="p">,</span> <span class="n">ms</span><span class="o">/</span><span class="mi">4</span><span class="p">,</span> <span class="n">f</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">f</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="nf">sym_getfreq</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sym_hcb</span> <span class="o">*</span><span class="n">np</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u_int</span> <span class="n">f1</span><span class="p">,</span> <span class="n">f2</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">gen</span> <span class="o">=</span> <span class="mi">8</span><span class="p">;</span>

	<span class="n">getfreq</span> <span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">gen</span><span class="p">);</span>	<span class="cm">/* throw away first result */</span>
	<span class="n">f1</span> <span class="o">=</span> <span class="n">getfreq</span> <span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">gen</span><span class="p">);</span>
	<span class="n">f2</span> <span class="o">=</span> <span class="n">getfreq</span> <span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">gen</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">f1</span> <span class="o">&gt;</span> <span class="n">f2</span><span class="p">)</span> <span class="n">f1</span> <span class="o">=</span> <span class="n">f2</span><span class="p">;</span>		<span class="cm">/* trust lower result	*/</span>
	<span class="k">return</span> <span class="n">f1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *  Get/probe chip SCSI clock frequency</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">sym_getclock</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sym_hcb</span> <span class="o">*</span><span class="n">np</span><span class="p">,</span> <span class="kt">int</span> <span class="n">mult</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">scntl3</span> <span class="o">=</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">sv_scntl3</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">stest1</span> <span class="o">=</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">sv_stest1</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">f1</span><span class="p">;</span>

	<span class="n">np</span><span class="o">-&gt;</span><span class="n">multiplier</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">f1</span> <span class="o">=</span> <span class="mi">40000</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 *  True with 875/895/896/895A with clock multiplier selected</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mult</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">stest1</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">DBLEN</span><span class="o">+</span><span class="n">DBLSEL</span><span class="p">))</span> <span class="o">==</span> <span class="n">DBLEN</span><span class="o">+</span><span class="n">DBLSEL</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sym_verbose</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">)</span>
			<span class="n">printf</span> <span class="p">(</span><span class="s">&quot;%s: clock multiplier found</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">sym_name</span><span class="p">(</span><span class="n">np</span><span class="p">));</span>
		<span class="n">np</span><span class="o">-&gt;</span><span class="n">multiplier</span> <span class="o">=</span> <span class="n">mult</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 *  If multiplier not found or scntl3 not 7,5,3,</span>
<span class="cm">	 *  reset chip and get frequency from general purpose timer.</span>
<span class="cm">	 *  Otherwise trust scntl3 BIOS setting.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">multiplier</span> <span class="o">!=</span> <span class="n">mult</span> <span class="o">||</span> <span class="p">(</span><span class="n">scntl3</span> <span class="o">&amp;</span> <span class="mi">7</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">3</span> <span class="o">||</span> <span class="o">!</span><span class="p">(</span><span class="n">scntl3</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">OUTB</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">nc_stest1</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>		<span class="cm">/* make sure doubler is OFF */</span>
		<span class="n">f1</span> <span class="o">=</span> <span class="n">sym_getfreq</span> <span class="p">(</span><span class="n">np</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">sym_verbose</span><span class="p">)</span>
			<span class="n">printf</span> <span class="p">(</span><span class="s">&quot;%s: chip clock is %uKHz</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">sym_name</span><span class="p">(</span><span class="n">np</span><span class="p">),</span> <span class="n">f1</span><span class="p">);</span>

		<span class="k">if</span>	<span class="p">(</span><span class="n">f1</span> <span class="o">&lt;</span>	<span class="mi">45000</span><span class="p">)</span>		<span class="n">f1</span> <span class="o">=</span>  <span class="mi">40000</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">f1</span> <span class="o">&lt;</span>	<span class="mi">55000</span><span class="p">)</span>		<span class="n">f1</span> <span class="o">=</span>  <span class="mi">50000</span><span class="p">;</span>
		<span class="k">else</span>				<span class="n">f1</span> <span class="o">=</span>  <span class="mi">80000</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">f1</span> <span class="o">&lt;</span> <span class="mi">80000</span> <span class="o">&amp;&amp;</span> <span class="n">mult</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">sym_verbose</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">)</span>
				<span class="n">printf</span> <span class="p">(</span><span class="s">&quot;%s: clock multiplier assumed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">sym_name</span><span class="p">(</span><span class="n">np</span><span class="p">));</span>
			<span class="n">np</span><span class="o">-&gt;</span><span class="n">multiplier</span>	<span class="o">=</span> <span class="n">mult</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span>	<span class="p">((</span><span class="n">scntl3</span> <span class="o">&amp;</span> <span class="mi">7</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">)</span>	<span class="n">f1</span> <span class="o">=</span>  <span class="mi">40000</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span>	<span class="p">((</span><span class="n">scntl3</span> <span class="o">&amp;</span> <span class="mi">7</span><span class="p">)</span> <span class="o">==</span> <span class="mi">5</span><span class="p">)</span>	<span class="n">f1</span> <span class="o">=</span>  <span class="mi">80000</span><span class="p">;</span>
		<span class="k">else</span> 				<span class="n">f1</span> <span class="o">=</span> <span class="mi">160000</span><span class="p">;</span>

		<span class="n">f1</span> <span class="o">/=</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">multiplier</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 *  Compute controller synchronous parameters.</span>
<span class="cm">	 */</span>
	<span class="n">f1</span>		<span class="o">*=</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">multiplier</span><span class="p">;</span>
	<span class="n">np</span><span class="o">-&gt;</span><span class="n">clock_khz</span>	<span class="o">=</span> <span class="n">f1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *  Get/probe PCI clock frequency</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">sym_getpciclock</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sym_hcb</span> <span class="o">*</span><span class="n">np</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">f</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 *  For now, we only need to know about the actual </span>
<span class="cm">	 *  PCI BUS clock frequency for C1010-66 chips.</span>
<span class="cm">	 */</span>
<span class="cp">#if 1</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">features</span> <span class="o">&amp;</span> <span class="n">FE_66MHZ</span><span class="p">)</span> <span class="p">{</span>
<span class="cp">#else</span>
	<span class="k">if</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
<span class="cp">#endif</span>
		<span class="n">OUTB</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">nc_stest1</span><span class="p">,</span> <span class="n">SCLK</span><span class="p">);</span> <span class="cm">/* Use the PCI clock as SCSI clock */</span>
		<span class="n">f</span> <span class="o">=</span> <span class="n">sym_getfreq</span><span class="p">(</span><span class="n">np</span><span class="p">);</span>
		<span class="n">OUTB</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">nc_stest1</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">np</span><span class="o">-&gt;</span><span class="n">pciclk_khz</span> <span class="o">=</span> <span class="n">f</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">f</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *  SYMBIOS chip clock divisor table.</span>
<span class="cm"> *</span>
<span class="cm"> *  Divisors are multiplied by 10,000,000 in order to make </span>
<span class="cm"> *  calculations more simple.</span>
<span class="cm"> */</span>
<span class="cp">#define _5M 5000000</span>
<span class="k">static</span> <span class="k">const</span> <span class="n">u32</span> <span class="n">div_10M</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">2</span><span class="o">*</span><span class="n">_5M</span><span class="p">,</span> <span class="mi">3</span><span class="o">*</span><span class="n">_5M</span><span class="p">,</span> <span class="mi">4</span><span class="o">*</span><span class="n">_5M</span><span class="p">,</span> <span class="mi">6</span><span class="o">*</span><span class="n">_5M</span><span class="p">,</span> <span class="mi">8</span><span class="o">*</span><span class="n">_5M</span><span class="p">,</span> <span class="mi">12</span><span class="o">*</span><span class="n">_5M</span><span class="p">,</span> <span class="mi">16</span><span class="o">*</span><span class="n">_5M</span><span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> *  Get clock factor and sync divisor for a given </span>
<span class="cm"> *  synchronous factor period.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> 
<span class="n">sym_getsync</span><span class="p">(</span><span class="k">struct</span> <span class="n">sym_hcb</span> <span class="o">*</span><span class="n">np</span><span class="p">,</span> <span class="n">u_char</span> <span class="n">dt</span><span class="p">,</span> <span class="n">u_char</span> <span class="n">sfac</span><span class="p">,</span> <span class="n">u_char</span> <span class="o">*</span><span class="n">divp</span><span class="p">,</span> <span class="n">u_char</span> <span class="o">*</span><span class="n">fakp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span>	<span class="n">clk</span> <span class="o">=</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">clock_khz</span><span class="p">;</span>	<span class="cm">/* SCSI clock frequency in kHz	*/</span>
	<span class="kt">int</span>	<span class="n">div</span> <span class="o">=</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">clock_divn</span><span class="p">;</span>	<span class="cm">/* Number of divisors supported	*/</span>
	<span class="n">u32</span>	<span class="n">fak</span><span class="p">;</span>			<span class="cm">/* Sync factor in sxfer		*/</span>
	<span class="n">u32</span>	<span class="n">per</span><span class="p">;</span>			<span class="cm">/* Period in tenths of ns	*/</span>
	<span class="n">u32</span>	<span class="n">kpc</span><span class="p">;</span>			<span class="cm">/* (per * clk)			*/</span>
	<span class="kt">int</span>	<span class="n">ret</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 *  Compute the synchronous period in tenths of nano-seconds</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dt</span> <span class="o">&amp;&amp;</span> <span class="n">sfac</span> <span class="o">&lt;=</span> <span class="mi">9</span><span class="p">)</span>	<span class="n">per</span> <span class="o">=</span> <span class="mi">125</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span>	<span class="p">(</span><span class="n">sfac</span> <span class="o">&lt;=</span> <span class="mi">10</span><span class="p">)</span>	<span class="n">per</span> <span class="o">=</span> <span class="mi">250</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span>	<span class="p">(</span><span class="n">sfac</span> <span class="o">==</span> <span class="mi">11</span><span class="p">)</span>	<span class="n">per</span> <span class="o">=</span> <span class="mi">303</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span>	<span class="p">(</span><span class="n">sfac</span> <span class="o">==</span> <span class="mi">12</span><span class="p">)</span>	<span class="n">per</span> <span class="o">=</span> <span class="mi">500</span><span class="p">;</span>
	<span class="k">else</span>			<span class="n">per</span> <span class="o">=</span> <span class="mi">40</span> <span class="o">*</span> <span class="n">sfac</span><span class="p">;</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">per</span><span class="p">;</span>

	<span class="n">kpc</span> <span class="o">=</span> <span class="n">per</span> <span class="o">*</span> <span class="n">clk</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dt</span><span class="p">)</span>
		<span class="n">kpc</span> <span class="o">&lt;&lt;=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 *  For earliest C10 revision 0, we cannot use extra </span>
<span class="cm">	 *  clocks for the setting of the SCSI clocking.</span>
<span class="cm">	 *  Note that this limits the lowest sync data transfer </span>
<span class="cm">	 *  to 5 Mega-transfers per second and may result in</span>
<span class="cm">	 *  using higher clock divisors.</span>
<span class="cm">	 */</span>
<span class="cp">#if 1</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">features</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">FE_C10</span><span class="o">|</span><span class="n">FE_U3EN</span><span class="p">))</span> <span class="o">==</span> <span class="n">FE_C10</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 *  Look for the lowest clock divisor that allows an </span>
<span class="cm">		 *  output speed not faster than the period.</span>
<span class="cm">		 */</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">div</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="o">--</span><span class="n">div</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">kpc</span> <span class="o">&gt;</span> <span class="p">(</span><span class="n">div_10M</span><span class="p">[</span><span class="n">div</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">))</span> <span class="p">{</span>
				<span class="o">++</span><span class="n">div</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="n">fak</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>			<span class="cm">/* No extra clocks */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">div</span> <span class="o">==</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">clock_divn</span><span class="p">)</span> <span class="p">{</span>	<span class="cm">/* Are we too fast ? */</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="o">*</span><span class="n">divp</span> <span class="o">=</span> <span class="n">div</span><span class="p">;</span>
		<span class="o">*</span><span class="n">fakp</span> <span class="o">=</span> <span class="n">fak</span><span class="p">;</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="p">}</span>
<span class="cp">#endif</span>

	<span class="cm">/*</span>
<span class="cm">	 *  Look for the greatest clock divisor that allows an </span>
<span class="cm">	 *  input speed faster than the period.</span>
<span class="cm">	 */</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">div</span><span class="o">--</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">kpc</span> <span class="o">&gt;=</span> <span class="p">(</span><span class="n">div_10M</span><span class="p">[</span><span class="n">div</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">))</span> <span class="k">break</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 *  Calculate the lowest clock factor that allows an output </span>
<span class="cm">	 *  speed not faster than the period, and the max output speed.</span>
<span class="cm">	 *  If fak &gt;= 1 we will set both XCLKH_ST and XCLKH_DT.</span>
<span class="cm">	 *  If fak &gt;= 2 we will also set XCLKS_ST and XCLKS_DT.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dt</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">fak</span> <span class="o">=</span> <span class="p">(</span><span class="n">kpc</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">div_10M</span><span class="p">[</span><span class="n">div</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">-</span> <span class="mi">2</span><span class="p">;</span>
		<span class="cm">/* ret = ((2+fak)*div_10M[div])/np-&gt;clock_khz; */</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">fak</span> <span class="o">=</span> <span class="p">(</span><span class="n">kpc</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">div_10M</span><span class="p">[</span><span class="n">div</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">-</span> <span class="mi">4</span><span class="p">;</span>
		<span class="cm">/* ret = ((4+fak)*div_10M[div])/np-&gt;clock_khz; */</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 *  Check against our hardware limits, or bugs :).</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">fak</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">fak</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 *  Compute and return sync parameters.</span>
<span class="cm">	 */</span>
	<span class="o">*</span><span class="n">divp</span> <span class="o">=</span> <span class="n">div</span><span class="p">;</span>
	<span class="o">*</span><span class="n">fakp</span> <span class="o">=</span> <span class="n">fak</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *  SYMBIOS chips allow burst lengths of 2, 4, 8, 16, 32, 64,</span>
<span class="cm"> *  128 transfers. All chips support at least 16 transfers </span>
<span class="cm"> *  bursts. The 825A, 875 and 895 chips support bursts of up </span>
<span class="cm"> *  to 128 transfers and the 895A and 896 support bursts of up</span>
<span class="cm"> *  to 64 transfers. All other chips support up to 16 </span>
<span class="cm"> *  transfers bursts.</span>
<span class="cm"> *</span>
<span class="cm"> *  For PCI 32 bit data transfers each transfer is a DWORD.</span>
<span class="cm"> *  It is a QUADWORD (8 bytes) for PCI 64 bit data transfers.</span>
<span class="cm"> *</span>
<span class="cm"> *  We use log base 2 (burst length) as internal code, with </span>
<span class="cm"> *  value 0 meaning &quot;burst disabled&quot;.</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> *  Burst length from burst code.</span>
<span class="cm"> */</span>
<span class="cp">#define burst_length(bc) (!(bc))? 0 : 1 &lt;&lt; (bc)</span>

<span class="cm">/*</span>
<span class="cm"> *  Burst code from io register bits.</span>
<span class="cm"> */</span>
<span class="cp">#define burst_code(dmode, ctest4, ctest5) \</span>
<span class="cp">	(ctest4) &amp; 0x80? 0 : (((dmode) &amp; 0xc0) &gt;&gt; 6) + ((ctest5) &amp; 0x04) + 1</span>

<span class="cm">/*</span>
<span class="cm"> *  Set initial io register bits from burst code.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="n">sym_init_burst</span><span class="p">(</span><span class="k">struct</span> <span class="n">sym_hcb</span> <span class="o">*</span><span class="n">np</span><span class="p">,</span> <span class="n">u_char</span> <span class="n">bc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">np</span><span class="o">-&gt;</span><span class="n">rv_ctest4</span>	<span class="o">&amp;=</span> <span class="o">~</span><span class="mh">0x80</span><span class="p">;</span>
	<span class="n">np</span><span class="o">-&gt;</span><span class="n">rv_dmode</span>	<span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="mh">0x3</span> <span class="o">&lt;&lt;</span> <span class="mi">6</span><span class="p">);</span>
	<span class="n">np</span><span class="o">-&gt;</span><span class="n">rv_ctest5</span>	<span class="o">&amp;=</span> <span class="o">~</span><span class="mh">0x4</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bc</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">np</span><span class="o">-&gt;</span><span class="n">rv_ctest4</span>	<span class="o">|=</span> <span class="mh">0x80</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="o">--</span><span class="n">bc</span><span class="p">;</span>
		<span class="n">np</span><span class="o">-&gt;</span><span class="n">rv_dmode</span>	<span class="o">|=</span> <span class="p">((</span><span class="n">bc</span> <span class="o">&amp;</span> <span class="mh">0x3</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">6</span><span class="p">);</span>
		<span class="n">np</span><span class="o">-&gt;</span><span class="n">rv_ctest5</span>	<span class="o">|=</span> <span class="p">(</span><span class="n">bc</span> <span class="o">&amp;</span> <span class="mh">0x4</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *  Save initial settings of some IO registers.</span>
<span class="cm"> *  Assumed to have been set by BIOS.</span>
<span class="cm"> *  We cannot reset the chip prior to reading the </span>
<span class="cm"> *  IO registers, since informations will be lost.</span>
<span class="cm"> *  Since the SCRIPTS processor may be running, this </span>
<span class="cm"> *  is not safe on paper, but it seems to work quite </span>
<span class="cm"> *  well. :)</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">sym_save_initial_setting</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sym_hcb</span> <span class="o">*</span><span class="n">np</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">np</span><span class="o">-&gt;</span><span class="n">sv_scntl0</span>	<span class="o">=</span> <span class="n">INB</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">nc_scntl0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x0a</span><span class="p">;</span>
	<span class="n">np</span><span class="o">-&gt;</span><span class="n">sv_scntl3</span>	<span class="o">=</span> <span class="n">INB</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">nc_scntl3</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x07</span><span class="p">;</span>
	<span class="n">np</span><span class="o">-&gt;</span><span class="n">sv_dmode</span>	<span class="o">=</span> <span class="n">INB</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">nc_dmode</span><span class="p">)</span>  <span class="o">&amp;</span> <span class="mh">0xce</span><span class="p">;</span>
	<span class="n">np</span><span class="o">-&gt;</span><span class="n">sv_dcntl</span>	<span class="o">=</span> <span class="n">INB</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">nc_dcntl</span><span class="p">)</span>  <span class="o">&amp;</span> <span class="mh">0xa8</span><span class="p">;</span>
	<span class="n">np</span><span class="o">-&gt;</span><span class="n">sv_ctest3</span>	<span class="o">=</span> <span class="n">INB</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">nc_ctest3</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x01</span><span class="p">;</span>
	<span class="n">np</span><span class="o">-&gt;</span><span class="n">sv_ctest4</span>	<span class="o">=</span> <span class="n">INB</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">nc_ctest4</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x80</span><span class="p">;</span>
	<span class="n">np</span><span class="o">-&gt;</span><span class="n">sv_gpcntl</span>	<span class="o">=</span> <span class="n">INB</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">nc_gpcntl</span><span class="p">);</span>
	<span class="n">np</span><span class="o">-&gt;</span><span class="n">sv_stest1</span>	<span class="o">=</span> <span class="n">INB</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">nc_stest1</span><span class="p">);</span>
	<span class="n">np</span><span class="o">-&gt;</span><span class="n">sv_stest2</span>	<span class="o">=</span> <span class="n">INB</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">nc_stest2</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x20</span><span class="p">;</span>
	<span class="n">np</span><span class="o">-&gt;</span><span class="n">sv_stest4</span>	<span class="o">=</span> <span class="n">INB</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">nc_stest4</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">features</span> <span class="o">&amp;</span> <span class="n">FE_C10</span><span class="p">)</span> <span class="p">{</span>	<span class="cm">/* Always large DMA fifo + ultra3 */</span>
		<span class="n">np</span><span class="o">-&gt;</span><span class="n">sv_scntl4</span>	<span class="o">=</span> <span class="n">INB</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">nc_scntl4</span><span class="p">);</span>
		<span class="n">np</span><span class="o">-&gt;</span><span class="n">sv_ctest5</span>	<span class="o">=</span> <span class="n">INB</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">nc_ctest5</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x04</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">else</span>
		<span class="n">np</span><span class="o">-&gt;</span><span class="n">sv_ctest5</span>	<span class="o">=</span> <span class="n">INB</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">nc_ctest5</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x24</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *  Set SCSI BUS mode.</span>
<span class="cm"> *  - LVD capable chips (895/895A/896/1010) report the current BUS mode</span>
<span class="cm"> *    through the STEST4 IO register.</span>
<span class="cm"> *  - For previous generation chips (825/825A/875), the user has to tell us</span>
<span class="cm"> *    how to check against HVD, since a 100% safe algorithm is not possible.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">sym_set_bus_mode</span><span class="p">(</span><span class="k">struct</span> <span class="n">sym_hcb</span> <span class="o">*</span><span class="n">np</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sym_nvram</span> <span class="o">*</span><span class="n">nvram</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">scsi_mode</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">np</span><span class="o">-&gt;</span><span class="n">scsi_mode</span> <span class="o">=</span> <span class="n">SMODE_SE</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">features</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">FE_ULTRA2</span><span class="o">|</span><span class="n">FE_ULTRA3</span><span class="p">))</span>
		<span class="n">np</span><span class="o">-&gt;</span><span class="n">scsi_mode</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">sv_stest4</span> <span class="o">&amp;</span> <span class="n">SMODE</span><span class="p">);</span>
	<span class="k">else</span> <span class="k">if</span>	<span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">features</span> <span class="o">&amp;</span> <span class="n">FE_DIFF</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">SYM_SETUP_SCSI_DIFF</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">sv_scntl3</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">sv_stest2</span> <span class="o">&amp;</span> <span class="mh">0x20</span><span class="p">)</span>
					<span class="n">np</span><span class="o">-&gt;</span><span class="n">scsi_mode</span> <span class="o">=</span> <span class="n">SMODE_HVD</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">nvram</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="n">SYM_SYMBIOS_NVRAM</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">INB</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">nc_gpreg</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x08</span><span class="p">))</span>
					<span class="n">np</span><span class="o">-&gt;</span><span class="n">scsi_mode</span> <span class="o">=</span> <span class="n">SMODE_HVD</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">SYM_SETUP_SCSI_DIFF</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span>
			<span class="n">np</span><span class="o">-&gt;</span><span class="n">scsi_mode</span> <span class="o">=</span> <span class="n">SMODE_HVD</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">scsi_mode</span> <span class="o">==</span> <span class="n">SMODE_HVD</span><span class="p">)</span>
		<span class="n">np</span><span class="o">-&gt;</span><span class="n">rv_stest2</span> <span class="o">|=</span> <span class="mh">0x20</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *  Prepare io register values used by sym_start_up() </span>
<span class="cm"> *  according to selected and supported features.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">sym_prepare_setting</span><span class="p">(</span><span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sym_hcb</span> <span class="o">*</span><span class="n">np</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sym_nvram</span> <span class="o">*</span><span class="n">nvram</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sym_data</span> <span class="o">*</span><span class="n">sym_data</span> <span class="o">=</span> <span class="n">shost_priv</span><span class="p">(</span><span class="n">shost</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span> <span class="o">=</span> <span class="n">sym_data</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">;</span>
	<span class="n">u_char</span>	<span class="n">burst_max</span><span class="p">;</span>
	<span class="n">u32</span>	<span class="n">period</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">np</span><span class="o">-&gt;</span><span class="n">maxwide</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">features</span> <span class="o">&amp;</span> <span class="n">FE_WIDE</span><span class="p">)</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 *  Guess the frequency of the chip&#39;s clock.</span>
<span class="cm">	 */</span>
	<span class="k">if</span>	<span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">features</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">FE_ULTRA3</span> <span class="o">|</span> <span class="n">FE_ULTRA2</span><span class="p">))</span>
		<span class="n">np</span><span class="o">-&gt;</span><span class="n">clock_khz</span> <span class="o">=</span> <span class="mi">160000</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span>	<span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">features</span> <span class="o">&amp;</span> <span class="n">FE_ULTRA</span><span class="p">)</span>
		<span class="n">np</span><span class="o">-&gt;</span><span class="n">clock_khz</span> <span class="o">=</span> <span class="mi">80000</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">np</span><span class="o">-&gt;</span><span class="n">clock_khz</span> <span class="o">=</span> <span class="mi">40000</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 *  Get the clock multiplier factor.</span>
<span class="cm"> 	 */</span>
	<span class="k">if</span>	<span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">features</span> <span class="o">&amp;</span> <span class="n">FE_QUAD</span><span class="p">)</span>
		<span class="n">np</span><span class="o">-&gt;</span><span class="n">multiplier</span>	<span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span>	<span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">features</span> <span class="o">&amp;</span> <span class="n">FE_DBLR</span><span class="p">)</span>
		<span class="n">np</span><span class="o">-&gt;</span><span class="n">multiplier</span>	<span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">np</span><span class="o">-&gt;</span><span class="n">multiplier</span>	<span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 *  Measure SCSI clock frequency for chips </span>
<span class="cm">	 *  it may vary from assumed one.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">features</span> <span class="o">&amp;</span> <span class="n">FE_VARCLK</span><span class="p">)</span>
		<span class="n">sym_getclock</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">multiplier</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Divisor to be used for async (timer pre-scaler).</span>
<span class="cm">	 */</span>
	<span class="n">i</span> <span class="o">=</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">clock_divn</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">--</span><span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="mi">10ul</span> <span class="o">*</span> <span class="n">SYM_CONF_MIN_ASYNC</span> <span class="o">*</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">clock_khz</span> <span class="o">&gt;</span> <span class="n">div_10M</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">{</span>
			<span class="o">++</span><span class="n">i</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">np</span><span class="o">-&gt;</span><span class="n">rv_scntl3</span> <span class="o">=</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * The C1010 uses hardwired divisors for async.</span>
<span class="cm">	 * So, we just throw away, the async. divisor.:-)</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">features</span> <span class="o">&amp;</span> <span class="n">FE_C10</span><span class="p">)</span>
		<span class="n">np</span><span class="o">-&gt;</span><span class="n">rv_scntl3</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Minimum synchronous period factor supported by the chip.</span>
<span class="cm">	 * Btw, &#39;period&#39; is in tenths of nanoseconds.</span>
<span class="cm">	 */</span>
	<span class="n">period</span> <span class="o">=</span> <span class="p">(</span><span class="mi">4</span> <span class="o">*</span> <span class="n">div_10M</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">clock_khz</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">clock_khz</span><span class="p">;</span>

	<span class="k">if</span>	<span class="p">(</span><span class="n">period</span> <span class="o">&lt;=</span> <span class="mi">250</span><span class="p">)</span>		<span class="n">np</span><span class="o">-&gt;</span><span class="n">minsync</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span>	<span class="p">(</span><span class="n">period</span> <span class="o">&lt;=</span> <span class="mi">303</span><span class="p">)</span>		<span class="n">np</span><span class="o">-&gt;</span><span class="n">minsync</span> <span class="o">=</span> <span class="mi">11</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span>	<span class="p">(</span><span class="n">period</span> <span class="o">&lt;=</span> <span class="mi">500</span><span class="p">)</span>		<span class="n">np</span><span class="o">-&gt;</span><span class="n">minsync</span> <span class="o">=</span> <span class="mi">12</span><span class="p">;</span>
	<span class="k">else</span>				<span class="n">np</span><span class="o">-&gt;</span><span class="n">minsync</span> <span class="o">=</span> <span class="p">(</span><span class="n">period</span> <span class="o">+</span> <span class="mi">40</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">40</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Check against chip SCSI standard support (SCSI-2,ULTRA,ULTRA2).</span>
<span class="cm">	 */</span>
	<span class="k">if</span>	<span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">minsync</span> <span class="o">&lt;</span> <span class="mi">25</span> <span class="o">&amp;&amp;</span>
		 <span class="o">!</span><span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">features</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">FE_ULTRA</span><span class="o">|</span><span class="n">FE_ULTRA2</span><span class="o">|</span><span class="n">FE_ULTRA3</span><span class="p">)))</span>
		<span class="n">np</span><span class="o">-&gt;</span><span class="n">minsync</span> <span class="o">=</span> <span class="mi">25</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span>	<span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">minsync</span> <span class="o">&lt;</span> <span class="mi">12</span> <span class="o">&amp;&amp;</span>
		 <span class="o">!</span><span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">features</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">FE_ULTRA2</span><span class="o">|</span><span class="n">FE_ULTRA3</span><span class="p">)))</span>
		<span class="n">np</span><span class="o">-&gt;</span><span class="n">minsync</span> <span class="o">=</span> <span class="mi">12</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Maximum synchronous period factor supported by the chip.</span>
<span class="cm">	 */</span>
	<span class="n">period</span> <span class="o">=</span> <span class="p">(</span><span class="mi">11</span> <span class="o">*</span> <span class="n">div_10M</span><span class="p">[</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">clock_divn</span> <span class="o">-</span> <span class="mi">1</span><span class="p">])</span> <span class="o">/</span> <span class="p">(</span><span class="mi">4</span> <span class="o">*</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">clock_khz</span><span class="p">);</span>
	<span class="n">np</span><span class="o">-&gt;</span><span class="n">maxsync</span> <span class="o">=</span> <span class="n">period</span> <span class="o">&gt;</span> <span class="mi">2540</span> <span class="o">?</span> <span class="mi">254</span> <span class="o">:</span> <span class="n">period</span> <span class="o">/</span> <span class="mi">10</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * If chip is a C1010, guess the sync limits in DT mode.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">features</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">FE_C10</span><span class="o">|</span><span class="n">FE_ULTRA3</span><span class="p">))</span> <span class="o">==</span> <span class="p">(</span><span class="n">FE_C10</span><span class="o">|</span><span class="n">FE_ULTRA3</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">clock_khz</span> <span class="o">==</span> <span class="mi">160000</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">np</span><span class="o">-&gt;</span><span class="n">minsync_dt</span> <span class="o">=</span> <span class="mi">9</span><span class="p">;</span>
			<span class="n">np</span><span class="o">-&gt;</span><span class="n">maxsync_dt</span> <span class="o">=</span> <span class="mi">50</span><span class="p">;</span>
			<span class="n">np</span><span class="o">-&gt;</span><span class="n">maxoffs_dt</span> <span class="o">=</span> <span class="n">nvram</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">?</span> <span class="mi">62</span> <span class="o">:</span> <span class="mi">31</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	
	<span class="cm">/*</span>
<span class="cm">	 *  64 bit addressing  (895A/896/1010) ?</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">features</span> <span class="o">&amp;</span> <span class="n">FE_DAC</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">use_dac</span><span class="p">(</span><span class="n">np</span><span class="p">))</span>
			<span class="n">np</span><span class="o">-&gt;</span><span class="n">rv_ccntl1</span> <span class="o">|=</span> <span class="p">(</span><span class="n">DDAC</span><span class="p">);</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">SYM_CONF_DMA_ADDRESSING_MODE</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
			<span class="n">np</span><span class="o">-&gt;</span><span class="n">rv_ccntl1</span> <span class="o">|=</span> <span class="p">(</span><span class="n">XTIMOD</span> <span class="o">|</span> <span class="n">EXTIBMV</span><span class="p">);</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">SYM_CONF_DMA_ADDRESSING_MODE</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span>
			<span class="n">np</span><span class="o">-&gt;</span><span class="n">rv_ccntl1</span> <span class="o">|=</span> <span class="p">(</span><span class="mi">0</span> <span class="o">|</span> <span class="n">EXTIBMV</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 *  Phase mismatch handled by SCRIPTS (895A/896/1010) ?</span>
<span class="cm">  	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">features</span> <span class="o">&amp;</span> <span class="n">FE_NOPM</span><span class="p">)</span>
		<span class="n">np</span><span class="o">-&gt;</span><span class="n">rv_ccntl0</span>	<span class="o">|=</span> <span class="p">(</span><span class="n">ENPMJ</span><span class="p">);</span>

 	<span class="cm">/*</span>
<span class="cm">	 *  C1010-33 Errata: Part Number:609-039638 (rev. 1) is fixed.</span>
<span class="cm">	 *  In dual channel mode, contention occurs if internal cycles</span>
<span class="cm">	 *  are used. Disable internal cycles.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">device</span> <span class="o">==</span> <span class="n">PCI_DEVICE_ID_LSI_53C1010_33</span> <span class="o">&amp;&amp;</span>
	    <span class="n">pdev</span><span class="o">-&gt;</span><span class="n">revision</span> <span class="o">&lt;</span> <span class="mh">0x1</span><span class="p">)</span>
		<span class="n">np</span><span class="o">-&gt;</span><span class="n">rv_ccntl0</span>	<span class="o">|=</span>  <span class="n">DILS</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 *  Select burst length (dwords)</span>
<span class="cm">	 */</span>
	<span class="n">burst_max</span>	<span class="o">=</span> <span class="n">SYM_SETUP_BURST_ORDER</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">burst_max</span> <span class="o">==</span> <span class="mi">255</span><span class="p">)</span>
		<span class="n">burst_max</span> <span class="o">=</span> <span class="n">burst_code</span><span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">sv_dmode</span><span class="p">,</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">sv_ctest4</span><span class="p">,</span>
				       <span class="n">np</span><span class="o">-&gt;</span><span class="n">sv_ctest5</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">burst_max</span> <span class="o">&gt;</span> <span class="mi">7</span><span class="p">)</span>
		<span class="n">burst_max</span> <span class="o">=</span> <span class="mi">7</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">burst_max</span> <span class="o">&gt;</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">maxburst</span><span class="p">)</span>
		<span class="n">burst_max</span> <span class="o">=</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">maxburst</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 *  DEL 352 - 53C810 Rev x11 - Part Number 609-0392140 - ITEM 2.</span>
<span class="cm">	 *  This chip and the 860 Rev 1 may wrongly use PCI cache line </span>
<span class="cm">	 *  based transactions on LOAD/STORE instructions. So we have </span>
<span class="cm">	 *  to prevent these chips from using such PCI transactions in </span>
<span class="cm">	 *  this driver. The generic ncr driver that does not use </span>
<span class="cm">	 *  LOAD/STORE instructions does not need this work-around.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">device</span> <span class="o">==</span> <span class="n">PCI_DEVICE_ID_NCR_53C810</span> <span class="o">&amp;&amp;</span>
	     <span class="n">pdev</span><span class="o">-&gt;</span><span class="n">revision</span> <span class="o">&gt;=</span> <span class="mh">0x10</span> <span class="o">&amp;&amp;</span> <span class="n">pdev</span><span class="o">-&gt;</span><span class="n">revision</span> <span class="o">&lt;=</span> <span class="mh">0x11</span><span class="p">)</span> <span class="o">||</span>
	    <span class="p">(</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">device</span> <span class="o">==</span> <span class="n">PCI_DEVICE_ID_NCR_53C860</span> <span class="o">&amp;&amp;</span>
	     <span class="n">pdev</span><span class="o">-&gt;</span><span class="n">revision</span> <span class="o">&lt;=</span> <span class="mh">0x1</span><span class="p">))</span>
		<span class="n">np</span><span class="o">-&gt;</span><span class="n">features</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">FE_WRIE</span><span class="o">|</span><span class="n">FE_ERL</span><span class="o">|</span><span class="n">FE_ERMP</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 *  Select all supported special features.</span>
<span class="cm">	 *  If we are using on-board RAM for scripts, prefetch (PFEN) </span>
<span class="cm">	 *  does not help, but burst op fetch (BOF) does.</span>
<span class="cm">	 *  Disabling PFEN makes sure BOF will be used.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">features</span> <span class="o">&amp;</span> <span class="n">FE_ERL</span><span class="p">)</span>
		<span class="n">np</span><span class="o">-&gt;</span><span class="n">rv_dmode</span>	<span class="o">|=</span> <span class="n">ERL</span><span class="p">;</span>		<span class="cm">/* Enable Read Line */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">features</span> <span class="o">&amp;</span> <span class="n">FE_BOF</span><span class="p">)</span>
		<span class="n">np</span><span class="o">-&gt;</span><span class="n">rv_dmode</span>	<span class="o">|=</span> <span class="n">BOF</span><span class="p">;</span>		<span class="cm">/* Burst Opcode Fetch */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">features</span> <span class="o">&amp;</span> <span class="n">FE_ERMP</span><span class="p">)</span>
		<span class="n">np</span><span class="o">-&gt;</span><span class="n">rv_dmode</span>	<span class="o">|=</span> <span class="n">ERMP</span><span class="p">;</span>	<span class="cm">/* Enable Read Multiple */</span>
<span class="cp">#if 1</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">features</span> <span class="o">&amp;</span> <span class="n">FE_PFEN</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">ram_ba</span><span class="p">)</span>
<span class="cp">#else</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">features</span> <span class="o">&amp;</span> <span class="n">FE_PFEN</span><span class="p">)</span>
<span class="cp">#endif</span>
		<span class="n">np</span><span class="o">-&gt;</span><span class="n">rv_dcntl</span>	<span class="o">|=</span> <span class="n">PFEN</span><span class="p">;</span>	<span class="cm">/* Prefetch Enable */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">features</span> <span class="o">&amp;</span> <span class="n">FE_CLSE</span><span class="p">)</span>
		<span class="n">np</span><span class="o">-&gt;</span><span class="n">rv_dcntl</span>	<span class="o">|=</span> <span class="n">CLSE</span><span class="p">;</span>	<span class="cm">/* Cache Line Size Enable */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">features</span> <span class="o">&amp;</span> <span class="n">FE_WRIE</span><span class="p">)</span>
		<span class="n">np</span><span class="o">-&gt;</span><span class="n">rv_ctest3</span>	<span class="o">|=</span> <span class="n">WRIE</span><span class="p">;</span>	<span class="cm">/* Write and Invalidate */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">features</span> <span class="o">&amp;</span> <span class="n">FE_DFS</span><span class="p">)</span>
		<span class="n">np</span><span class="o">-&gt;</span><span class="n">rv_ctest5</span>	<span class="o">|=</span> <span class="n">DFS</span><span class="p">;</span>		<span class="cm">/* Dma Fifo Size */</span>

	<span class="cm">/*</span>
<span class="cm">	 *  Select some other</span>
<span class="cm">	 */</span>
	<span class="n">np</span><span class="o">-&gt;</span><span class="n">rv_ctest4</span>	<span class="o">|=</span> <span class="n">MPEE</span><span class="p">;</span> <span class="cm">/* Master parity checking */</span>
	<span class="n">np</span><span class="o">-&gt;</span><span class="n">rv_scntl0</span>	<span class="o">|=</span> <span class="mh">0x0a</span><span class="p">;</span> <span class="cm">/*  full arb., ena parity, par-&gt;ATN  */</span>

	<span class="cm">/*</span>
<span class="cm">	 *  Get parity checking, host ID and verbose mode from NVRAM</span>
<span class="cm">	 */</span>
	<span class="n">np</span><span class="o">-&gt;</span><span class="n">myaddr</span> <span class="o">=</span> <span class="mi">255</span><span class="p">;</span>
	<span class="n">np</span><span class="o">-&gt;</span><span class="n">scsi_mode</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">sym_nvram_setup_host</span><span class="p">(</span><span class="n">shost</span><span class="p">,</span> <span class="n">np</span><span class="p">,</span> <span class="n">nvram</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 *  Get SCSI addr of host adapter (set by bios?).</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">myaddr</span> <span class="o">==</span> <span class="mi">255</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">np</span><span class="o">-&gt;</span><span class="n">myaddr</span> <span class="o">=</span> <span class="n">INB</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">nc_scid</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x07</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">myaddr</span><span class="p">)</span>
			<span class="n">np</span><span class="o">-&gt;</span><span class="n">myaddr</span> <span class="o">=</span> <span class="n">SYM_SETUP_HOST_ID</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 *  Prepare initial io register bits for burst length</span>
<span class="cm">	 */</span>
	<span class="n">sym_init_burst</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">burst_max</span><span class="p">);</span>

	<span class="n">sym_set_bus_mode</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">nvram</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 *  Set LED support from SCRIPTS.</span>
<span class="cm">	 *  Ignore this feature for boards known to use a </span>
<span class="cm">	 *  specific GPIO wiring and for the 895A, 896 </span>
<span class="cm">	 *  and 1010 that drive the LED directly.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">SYM_SETUP_SCSI_LED</span> <span class="o">||</span> 
	     <span class="p">(</span><span class="n">nvram</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="n">SYM_SYMBIOS_NVRAM</span> <span class="o">||</span>
	      <span class="p">(</span><span class="n">nvram</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="n">SYM_TEKRAM_NVRAM</span> <span class="o">&amp;&amp;</span>
	       <span class="n">pdev</span><span class="o">-&gt;</span><span class="n">device</span> <span class="o">==</span> <span class="n">PCI_DEVICE_ID_NCR_53C895</span><span class="p">)))</span> <span class="o">&amp;&amp;</span>
	    <span class="o">!</span><span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">features</span> <span class="o">&amp;</span> <span class="n">FE_LEDC</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">sv_gpcntl</span> <span class="o">&amp;</span> <span class="mh">0x01</span><span class="p">))</span>
		<span class="n">np</span><span class="o">-&gt;</span><span class="n">features</span> <span class="o">|=</span> <span class="n">FE_LED0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 *  Set irq mode.</span>
<span class="cm">	 */</span>
	<span class="k">switch</span><span class="p">(</span><span class="n">SYM_SETUP_IRQ_MODE</span> <span class="o">&amp;</span> <span class="mi">3</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="mi">2</span>:
		<span class="n">np</span><span class="o">-&gt;</span><span class="n">rv_dcntl</span>	<span class="o">|=</span> <span class="n">IRQM</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">1</span>:
		<span class="n">np</span><span class="o">-&gt;</span><span class="n">rv_dcntl</span>	<span class="o">|=</span> <span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">sv_dcntl</span> <span class="o">&amp;</span> <span class="n">IRQM</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 *  Configure targets according to driver setup.</span>
<span class="cm">	 *  If NVRAM present get targets setup from NVRAM.</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">SYM_CONF_MAX_TARGET</span> <span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">sym_tcb</span> <span class="o">*</span><span class="n">tp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">target</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

		<span class="n">tp</span><span class="o">-&gt;</span><span class="n">usrflags</span> <span class="o">|=</span> <span class="p">(</span><span class="n">SYM_DISC_ENABLED</span> <span class="o">|</span> <span class="n">SYM_TAGS_ENABLED</span><span class="p">);</span>
		<span class="n">tp</span><span class="o">-&gt;</span><span class="n">usrtags</span> <span class="o">=</span> <span class="n">SYM_SETUP_MAX_TAG</span><span class="p">;</span>
		<span class="n">tp</span><span class="o">-&gt;</span><span class="n">usr_width</span> <span class="o">=</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">maxwide</span><span class="p">;</span>
		<span class="n">tp</span><span class="o">-&gt;</span><span class="n">usr_period</span> <span class="o">=</span> <span class="mi">9</span><span class="p">;</span>

		<span class="n">sym_nvram_setup_target</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">nvram</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">usrtags</span><span class="p">)</span>
			<span class="n">tp</span><span class="o">-&gt;</span><span class="n">usrflags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">SYM_TAGS_ENABLED</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 *  Let user know about the settings.</span>
<span class="cm">	 */</span>
	<span class="n">printf</span><span class="p">(</span><span class="s">&quot;%s: %s, ID %d, Fast-%d, %s, %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">sym_name</span><span class="p">(</span><span class="n">np</span><span class="p">),</span>
		<span class="n">sym_nvram_type</span><span class="p">(</span><span class="n">nvram</span><span class="p">),</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">myaddr</span><span class="p">,</span>
		<span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">features</span> <span class="o">&amp;</span> <span class="n">FE_ULTRA3</span><span class="p">)</span> <span class="o">?</span> <span class="mi">80</span> <span class="o">:</span> 
		<span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">features</span> <span class="o">&amp;</span> <span class="n">FE_ULTRA2</span><span class="p">)</span> <span class="o">?</span> <span class="mi">40</span> <span class="o">:</span> 
		<span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">features</span> <span class="o">&amp;</span> <span class="n">FE_ULTRA</span><span class="p">)</span>  <span class="o">?</span> <span class="mi">20</span> <span class="o">:</span> <span class="mi">10</span><span class="p">,</span>
		<span class="n">sym_scsi_bus_mode</span><span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">scsi_mode</span><span class="p">),</span>
		<span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">rv_scntl0</span> <span class="o">&amp;</span> <span class="mh">0xa</span><span class="p">)</span>	<span class="o">?</span> <span class="s">&quot;parity checking&quot;</span> <span class="o">:</span> <span class="s">&quot;NO parity&quot;</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 *  Tell him more on demand.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sym_verbose</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printf</span><span class="p">(</span><span class="s">&quot;%s: %s IRQ line driver%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">sym_name</span><span class="p">(</span><span class="n">np</span><span class="p">),</span>
			<span class="n">np</span><span class="o">-&gt;</span><span class="n">rv_dcntl</span> <span class="o">&amp;</span> <span class="n">IRQM</span> <span class="o">?</span> <span class="s">&quot;totem pole&quot;</span> <span class="o">:</span> <span class="s">&quot;open drain&quot;</span><span class="p">,</span>
			<span class="n">np</span><span class="o">-&gt;</span><span class="n">ram_ba</span> <span class="o">?</span> <span class="s">&quot;, using on-chip SRAM&quot;</span> <span class="o">:</span> <span class="s">&quot;&quot;</span><span class="p">);</span>
		<span class="n">printf</span><span class="p">(</span><span class="s">&quot;%s: using %s firmware.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">sym_name</span><span class="p">(</span><span class="n">np</span><span class="p">),</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">fw_name</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">features</span> <span class="o">&amp;</span> <span class="n">FE_NOPM</span><span class="p">)</span>
			<span class="n">printf</span><span class="p">(</span><span class="s">&quot;%s: handling phase mismatch from SCRIPTS.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> 
			       <span class="n">sym_name</span><span class="p">(</span><span class="n">np</span><span class="p">));</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 *  And still more.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sym_verbose</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printf</span> <span class="p">(</span><span class="s">&quot;%s: initial SCNTL3/DMODE/DCNTL/CTEST3/4/5 = &quot;</span>
			<span class="s">&quot;(hex) %02x/%02x/%02x/%02x/%02x/%02x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">sym_name</span><span class="p">(</span><span class="n">np</span><span class="p">),</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">sv_scntl3</span><span class="p">,</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">sv_dmode</span><span class="p">,</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">sv_dcntl</span><span class="p">,</span>
			<span class="n">np</span><span class="o">-&gt;</span><span class="n">sv_ctest3</span><span class="p">,</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">sv_ctest4</span><span class="p">,</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">sv_ctest5</span><span class="p">);</span>

		<span class="n">printf</span> <span class="p">(</span><span class="s">&quot;%s: final   SCNTL3/DMODE/DCNTL/CTEST3/4/5 = &quot;</span>
			<span class="s">&quot;(hex) %02x/%02x/%02x/%02x/%02x/%02x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">sym_name</span><span class="p">(</span><span class="n">np</span><span class="p">),</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">rv_scntl3</span><span class="p">,</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">rv_dmode</span><span class="p">,</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">rv_dcntl</span><span class="p">,</span>
			<span class="n">np</span><span class="o">-&gt;</span><span class="n">rv_ctest3</span><span class="p">,</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">rv_ctest4</span><span class="p">,</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">rv_ctest5</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *  Test the pci bus snoop logic :-(</span>
<span class="cm"> *</span>
<span class="cm"> *  Has to be called with interrupts disabled.</span>
<span class="cm"> */</span>
<span class="cp">#ifdef CONFIG_SCSI_SYM53C8XX_MMIO</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">sym_regtest</span><span class="p">(</span><span class="k">struct</span> <span class="n">sym_hcb</span> <span class="o">*</span><span class="n">np</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">register</span> <span class="k">volatile</span> <span class="n">u32</span> <span class="n">data</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 *  chip registers may NOT be cached.</span>
<span class="cm">	 *  write 0xffffffff to a read only register area,</span>
<span class="cm">	 *  and try to read it back.</span>
<span class="cm">	 */</span>
	<span class="n">data</span> <span class="o">=</span> <span class="mh">0xffffffff</span><span class="p">;</span>
	<span class="n">OUTL</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">nc_dstat</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>
	<span class="n">data</span> <span class="o">=</span> <span class="n">INL</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">nc_dstat</span><span class="p">);</span>
<span class="cp">#if 1</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">data</span> <span class="o">==</span> <span class="mh">0xffffffff</span><span class="p">)</span> <span class="p">{</span>
<span class="cp">#else</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">data</span> <span class="o">&amp;</span> <span class="mh">0xe2f0fffd</span><span class="p">)</span> <span class="o">!=</span> <span class="mh">0x02000080</span><span class="p">)</span> <span class="p">{</span>
<span class="cp">#endif</span>
		<span class="n">printf</span> <span class="p">(</span><span class="s">&quot;CACHE TEST FAILED: reg dstat-sstat2 readback %x.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="p">(</span><span class="kt">unsigned</span><span class="p">)</span> <span class="n">data</span><span class="p">);</span>
		<span class="k">return</span> <span class="mh">0x10</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#else</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="n">sym_regtest</span><span class="p">(</span><span class="k">struct</span> <span class="n">sym_hcb</span> <span class="o">*</span><span class="n">np</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">sym_snooptest</span><span class="p">(</span><span class="k">struct</span> <span class="n">sym_hcb</span> <span class="o">*</span><span class="n">np</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">sym_rd</span><span class="p">,</span> <span class="n">sym_wr</span><span class="p">,</span> <span class="n">sym_bk</span><span class="p">,</span> <span class="n">host_rd</span><span class="p">,</span> <span class="n">host_wr</span><span class="p">,</span> <span class="n">pc</span><span class="p">,</span> <span class="n">dstat</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">sym_regtest</span><span class="p">(</span><span class="n">np</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="nl">restart_test:</span>
	<span class="cm">/*</span>
<span class="cm">	 *  Enable Master Parity Checking as we intend </span>
<span class="cm">	 *  to enable it for normal operations.</span>
<span class="cm">	 */</span>
	<span class="n">OUTB</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">nc_ctest4</span><span class="p">,</span> <span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">rv_ctest4</span> <span class="o">&amp;</span> <span class="n">MPEE</span><span class="p">));</span>
	<span class="cm">/*</span>
<span class="cm">	 *  init</span>
<span class="cm">	 */</span>
	<span class="n">pc</span>  <span class="o">=</span> <span class="n">SCRIPTZ_BA</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">snooptest</span><span class="p">);</span>
	<span class="n">host_wr</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">sym_wr</span>  <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 *  Set memory and register.</span>
<span class="cm">	 */</span>
	<span class="n">np</span><span class="o">-&gt;</span><span class="n">scratch</span> <span class="o">=</span> <span class="n">cpu_to_scr</span><span class="p">(</span><span class="n">host_wr</span><span class="p">);</span>
	<span class="n">OUTL</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">nc_temp</span><span class="p">,</span> <span class="n">sym_wr</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 *  Start script (exchange values)</span>
<span class="cm">	 */</span>
	<span class="n">OUTL</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">nc_dsa</span><span class="p">,</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">hcb_ba</span><span class="p">);</span>
	<span class="n">OUTL_DSP</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">pc</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 *  Wait &#39;til done (with timeout)</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">SYM_SNOOP_TIMEOUT</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">INB</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">nc_istat</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">INTF</span><span class="o">|</span><span class="n">SIP</span><span class="o">|</span><span class="n">DIP</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i</span><span class="o">&gt;=</span><span class="n">SYM_SNOOP_TIMEOUT</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printf</span> <span class="p">(</span><span class="s">&quot;CACHE TEST FAILED: timeout.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="p">(</span><span class="mh">0x20</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 *  Check for fatal DMA errors.</span>
<span class="cm">	 */</span>
	<span class="n">dstat</span> <span class="o">=</span> <span class="n">INB</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">nc_dstat</span><span class="p">);</span>
<span class="cp">#if 1	</span><span class="cm">/* Band aiding for broken hardwares that fail PCI parity */</span><span class="cp"></span>
	<span class="k">if</span> <span class="p">((</span><span class="n">dstat</span> <span class="o">&amp;</span> <span class="n">MDPE</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">rv_ctest4</span> <span class="o">&amp;</span> <span class="n">MPEE</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">printf</span> <span class="p">(</span><span class="s">&quot;%s: PCI DATA PARITY ERROR DETECTED - &quot;</span>
			<span class="s">&quot;DISABLING MASTER DATA PARITY CHECKING.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">sym_name</span><span class="p">(</span><span class="n">np</span><span class="p">));</span>
		<span class="n">np</span><span class="o">-&gt;</span><span class="n">rv_ctest4</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">MPEE</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">restart_test</span><span class="p">;</span>
	<span class="p">}</span>
<span class="cp">#endif</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dstat</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">MDPE</span><span class="o">|</span><span class="n">BF</span><span class="o">|</span><span class="n">IID</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">printf</span> <span class="p">(</span><span class="s">&quot;CACHE TEST FAILED: DMA error (dstat=0x%02x).&quot;</span><span class="p">,</span> <span class="n">dstat</span><span class="p">);</span>
		<span class="k">return</span> <span class="p">(</span><span class="mh">0x80</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 *  Save termination position.</span>
<span class="cm">	 */</span>
	<span class="n">pc</span> <span class="o">=</span> <span class="n">INL</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">nc_dsp</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 *  Read memory and register.</span>
<span class="cm">	 */</span>
	<span class="n">host_rd</span> <span class="o">=</span> <span class="n">scr_to_cpu</span><span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">scratch</span><span class="p">);</span>
	<span class="n">sym_rd</span>  <span class="o">=</span> <span class="n">INL</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">nc_scratcha</span><span class="p">);</span>
	<span class="n">sym_bk</span>  <span class="o">=</span> <span class="n">INL</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">nc_temp</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 *  Check termination position.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pc</span> <span class="o">!=</span> <span class="n">SCRIPTZ_BA</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">snoopend</span><span class="p">)</span><span class="o">+</span><span class="mi">8</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printf</span> <span class="p">(</span><span class="s">&quot;CACHE TEST FAILED: script execution failed.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">printf</span> <span class="p">(</span><span class="s">&quot;start=%08lx, pc=%08lx, end=%08lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> 
			<span class="p">(</span><span class="n">u_long</span><span class="p">)</span> <span class="n">SCRIPTZ_BA</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">snooptest</span><span class="p">),</span> <span class="p">(</span><span class="n">u_long</span><span class="p">)</span> <span class="n">pc</span><span class="p">,</span>
			<span class="p">(</span><span class="n">u_long</span><span class="p">)</span> <span class="n">SCRIPTZ_BA</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">snoopend</span><span class="p">)</span> <span class="o">+</span><span class="mi">8</span><span class="p">);</span>
		<span class="k">return</span> <span class="p">(</span><span class="mh">0x40</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 *  Show results.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">host_wr</span> <span class="o">!=</span> <span class="n">sym_rd</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printf</span> <span class="p">(</span><span class="s">&quot;CACHE TEST FAILED: host wrote %d, chip read %d.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="n">host_wr</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="n">sym_rd</span><span class="p">);</span>
		<span class="n">err</span> <span class="o">|=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">host_rd</span> <span class="o">!=</span> <span class="n">sym_wr</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printf</span> <span class="p">(</span><span class="s">&quot;CACHE TEST FAILED: chip wrote %d, host read %d.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="n">sym_wr</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="n">host_rd</span><span class="p">);</span>
		<span class="n">err</span> <span class="o">|=</span> <span class="mi">2</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sym_bk</span> <span class="o">!=</span> <span class="n">sym_wr</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printf</span> <span class="p">(</span><span class="s">&quot;CACHE TEST FAILED: chip wrote %d, read back %d.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="n">sym_wr</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="n">sym_bk</span><span class="p">);</span>
		<span class="n">err</span> <span class="o">|=</span> <span class="mi">4</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *  log message for real hard errors</span>
<span class="cm"> *</span>
<span class="cm"> *  sym0 targ 0?: ERROR (ds:si) (so-si-sd) (sx/s3/s4) @ name (dsp:dbc).</span>
<span class="cm"> *  	      reg: r0 r1 r2 r3 r4 r5 r6 ..... rf.</span>
<span class="cm"> *</span>
<span class="cm"> *  exception register:</span>
<span class="cm"> *  	ds:	dstat</span>
<span class="cm"> *  	si:	sist</span>
<span class="cm"> *</span>
<span class="cm"> *  SCSI bus lines:</span>
<span class="cm"> *  	so:	control lines as driven by chip.</span>
<span class="cm"> *  	si:	control lines as seen by chip.</span>
<span class="cm"> *  	sd:	scsi data lines as seen by chip.</span>
<span class="cm"> *</span>
<span class="cm"> *  wide/fastmode:</span>
<span class="cm"> *  	sx:	sxfer  (see the manual)</span>
<span class="cm"> *  	s3:	scntl3 (see the manual)</span>
<span class="cm"> *  	s4:	scntl4 (see the manual)</span>
<span class="cm"> *</span>
<span class="cm"> *  current script command:</span>
<span class="cm"> *  	dsp:	script address (relative to start of script).</span>
<span class="cm"> *  	dbc:	first word of script command.</span>
<span class="cm"> *</span>
<span class="cm"> *  First 24 register of the chip:</span>
<span class="cm"> *  	r0..rf</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">sym_log_hard_error</span><span class="p">(</span><span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span><span class="p">,</span> <span class="n">u_short</span> <span class="n">sist</span><span class="p">,</span> <span class="n">u_char</span> <span class="n">dstat</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sym_hcb</span> <span class="o">*</span><span class="n">np</span> <span class="o">=</span> <span class="n">sym_get_hcb</span><span class="p">(</span><span class="n">shost</span><span class="p">);</span>
	<span class="n">u32</span>	<span class="n">dsp</span><span class="p">;</span>
	<span class="kt">int</span>	<span class="n">script_ofs</span><span class="p">;</span>
	<span class="kt">int</span>	<span class="n">script_size</span><span class="p">;</span>
	<span class="kt">char</span>	<span class="o">*</span><span class="n">script_name</span><span class="p">;</span>
	<span class="n">u_char</span>	<span class="o">*</span><span class="n">script_base</span><span class="p">;</span>
	<span class="kt">int</span>	<span class="n">i</span><span class="p">;</span>

	<span class="n">dsp</span>	<span class="o">=</span> <span class="n">INL</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">nc_dsp</span><span class="p">);</span>

	<span class="k">if</span>	<span class="p">(</span><span class="n">dsp</span> <span class="o">&gt;</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">scripta_ba</span> <span class="o">&amp;&amp;</span>
		 <span class="n">dsp</span> <span class="o">&lt;=</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">scripta_ba</span> <span class="o">+</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">scripta_sz</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">script_ofs</span>	<span class="o">=</span> <span class="n">dsp</span> <span class="o">-</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">scripta_ba</span><span class="p">;</span>
		<span class="n">script_size</span>	<span class="o">=</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">scripta_sz</span><span class="p">;</span>
		<span class="n">script_base</span>	<span class="o">=</span> <span class="p">(</span><span class="n">u_char</span> <span class="o">*</span><span class="p">)</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">scripta0</span><span class="p">;</span>
		<span class="n">script_name</span>	<span class="o">=</span> <span class="s">&quot;scripta&quot;</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">scriptb_ba</span> <span class="o">&lt;</span> <span class="n">dsp</span> <span class="o">&amp;&amp;</span> 
		 <span class="n">dsp</span> <span class="o">&lt;=</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">scriptb_ba</span> <span class="o">+</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">scriptb_sz</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">script_ofs</span>	<span class="o">=</span> <span class="n">dsp</span> <span class="o">-</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">scriptb_ba</span><span class="p">;</span>
		<span class="n">script_size</span>	<span class="o">=</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">scriptb_sz</span><span class="p">;</span>
		<span class="n">script_base</span>	<span class="o">=</span> <span class="p">(</span><span class="n">u_char</span> <span class="o">*</span><span class="p">)</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">scriptb0</span><span class="p">;</span>
		<span class="n">script_name</span>	<span class="o">=</span> <span class="s">&quot;scriptb&quot;</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">script_ofs</span>	<span class="o">=</span> <span class="n">dsp</span><span class="p">;</span>
		<span class="n">script_size</span>	<span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">script_base</span>	<span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">script_name</span>	<span class="o">=</span> <span class="s">&quot;mem&quot;</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">printf</span> <span class="p">(</span><span class="s">&quot;%s:%d: ERROR (%x:%x) (%x-%x-%x) (%x/%x/%x) @ (%s %x:%08x).</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">sym_name</span><span class="p">(</span><span class="n">np</span><span class="p">),</span> <span class="p">(</span><span class="kt">unsigned</span><span class="p">)</span><span class="n">INB</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">nc_sdid</span><span class="p">)</span><span class="o">&amp;</span><span class="mh">0x0f</span><span class="p">,</span> <span class="n">dstat</span><span class="p">,</span> <span class="n">sist</span><span class="p">,</span>
		<span class="p">(</span><span class="kt">unsigned</span><span class="p">)</span><span class="n">INB</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">nc_socl</span><span class="p">),</span> <span class="p">(</span><span class="kt">unsigned</span><span class="p">)</span><span class="n">INB</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">nc_sbcl</span><span class="p">),</span>
		<span class="p">(</span><span class="kt">unsigned</span><span class="p">)</span><span class="n">INB</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">nc_sbdl</span><span class="p">),</span> <span class="p">(</span><span class="kt">unsigned</span><span class="p">)</span><span class="n">INB</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">nc_sxfer</span><span class="p">),</span>
		<span class="p">(</span><span class="kt">unsigned</span><span class="p">)</span><span class="n">INB</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">nc_scntl3</span><span class="p">),</span>
		<span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">features</span> <span class="o">&amp;</span> <span class="n">FE_C10</span><span class="p">)</span> <span class="o">?</span>  <span class="p">(</span><span class="kt">unsigned</span><span class="p">)</span><span class="n">INB</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">nc_scntl4</span><span class="p">)</span> <span class="o">:</span> <span class="mi">0</span><span class="p">,</span>
		<span class="n">script_name</span><span class="p">,</span> <span class="n">script_ofs</span><span class="p">,</span>   <span class="p">(</span><span class="kt">unsigned</span><span class="p">)</span><span class="n">INL</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">nc_dbc</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(((</span><span class="n">script_ofs</span> <span class="o">&amp;</span> <span class="mi">3</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="kt">unsigned</span><span class="p">)</span><span class="n">script_ofs</span> <span class="o">&lt;</span> <span class="n">script_size</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printf</span> <span class="p">(</span><span class="s">&quot;%s: script cmd = %08x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">sym_name</span><span class="p">(</span><span class="n">np</span><span class="p">),</span>
			<span class="n">scr_to_cpu</span><span class="p">((</span><span class="kt">int</span><span class="p">)</span> <span class="o">*</span><span class="p">(</span><span class="n">u32</span> <span class="o">*</span><span class="p">)(</span><span class="n">script_base</span> <span class="o">+</span> <span class="n">script_ofs</span><span class="p">)));</span>
	<span class="p">}</span>

	<span class="n">printf</span><span class="p">(</span><span class="s">&quot;%s: regdump:&quot;</span><span class="p">,</span> <span class="n">sym_name</span><span class="p">(</span><span class="n">np</span><span class="p">));</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">24</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">printf</span><span class="p">(</span><span class="s">&quot; %02x&quot;</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span><span class="p">)</span><span class="n">INB_OFF</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">i</span><span class="p">));</span>
	<span class="n">printf</span><span class="p">(</span><span class="s">&quot;.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 *  PCI BUS error.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dstat</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">MDPE</span><span class="o">|</span><span class="n">BF</span><span class="p">))</span>
		<span class="n">sym_log_bus_error</span><span class="p">(</span><span class="n">shost</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">sym_dump_registers</span><span class="p">(</span><span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sym_hcb</span> <span class="o">*</span><span class="n">np</span> <span class="o">=</span> <span class="n">sym_get_hcb</span><span class="p">(</span><span class="n">shost</span><span class="p">);</span>
	<span class="n">u_short</span> <span class="n">sist</span><span class="p">;</span>
	<span class="n">u_char</span> <span class="n">dstat</span><span class="p">;</span>

	<span class="n">sist</span> <span class="o">=</span> <span class="n">INW</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">nc_sist</span><span class="p">);</span>
	<span class="n">dstat</span> <span class="o">=</span> <span class="n">INB</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">nc_dstat</span><span class="p">);</span>
	<span class="n">sym_log_hard_error</span><span class="p">(</span><span class="n">shost</span><span class="p">,</span> <span class="n">sist</span><span class="p">,</span> <span class="n">dstat</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">sym_chip</span> <span class="n">sym_dev_table</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
 <span class="p">{</span><span class="n">PCI_DEVICE_ID_NCR_53C810</span><span class="p">,</span> <span class="mh">0x0f</span><span class="p">,</span> <span class="s">&quot;810&quot;</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">64</span><span class="p">,</span>
 <span class="n">FE_ERL</span><span class="p">}</span>
 <span class="p">,</span>
<span class="cp">#ifdef SYM_DEBUG_GENERIC_SUPPORT</span>
 <span class="p">{</span><span class="n">PCI_DEVICE_ID_NCR_53C810</span><span class="p">,</span> <span class="mh">0xff</span><span class="p">,</span> <span class="s">&quot;810a&quot;</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span>  <span class="mi">8</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span>
 <span class="n">FE_BOF</span><span class="p">}</span>
 <span class="p">,</span>
<span class="cp">#else</span>
 <span class="p">{</span><span class="n">PCI_DEVICE_ID_NCR_53C810</span><span class="p">,</span> <span class="mh">0xff</span><span class="p">,</span> <span class="s">&quot;810a&quot;</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span>  <span class="mi">8</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span>
 <span class="n">FE_CACHE_SET</span><span class="o">|</span><span class="n">FE_LDSTR</span><span class="o">|</span><span class="n">FE_PFEN</span><span class="o">|</span><span class="n">FE_BOF</span><span class="p">}</span>
 <span class="p">,</span>
<span class="cp">#endif</span>
 <span class="p">{</span><span class="n">PCI_DEVICE_ID_NCR_53C815</span><span class="p">,</span> <span class="mh">0xff</span><span class="p">,</span> <span class="s">&quot;815&quot;</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span>  <span class="mi">8</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">64</span><span class="p">,</span>
 <span class="n">FE_BOF</span><span class="o">|</span><span class="n">FE_ERL</span><span class="p">}</span>
 <span class="p">,</span>
 <span class="p">{</span><span class="n">PCI_DEVICE_ID_NCR_53C825</span><span class="p">,</span> <span class="mh">0x0f</span><span class="p">,</span> <span class="s">&quot;825&quot;</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span>  <span class="mi">8</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">64</span><span class="p">,</span>
 <span class="n">FE_WIDE</span><span class="o">|</span><span class="n">FE_BOF</span><span class="o">|</span><span class="n">FE_ERL</span><span class="o">|</span><span class="n">FE_DIFF</span><span class="p">}</span>
 <span class="p">,</span>
 <span class="p">{</span><span class="n">PCI_DEVICE_ID_NCR_53C825</span><span class="p">,</span> <span class="mh">0xff</span><span class="p">,</span> <span class="s">&quot;825a&quot;</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span>  <span class="mi">8</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span>
 <span class="n">FE_WIDE</span><span class="o">|</span><span class="n">FE_CACHE0_SET</span><span class="o">|</span><span class="n">FE_BOF</span><span class="o">|</span><span class="n">FE_DFS</span><span class="o">|</span><span class="n">FE_LDSTR</span><span class="o">|</span><span class="n">FE_PFEN</span><span class="o">|</span><span class="n">FE_RAM</span><span class="o">|</span><span class="n">FE_DIFF</span><span class="p">}</span>
 <span class="p">,</span>
 <span class="p">{</span><span class="n">PCI_DEVICE_ID_NCR_53C860</span><span class="p">,</span> <span class="mh">0xff</span><span class="p">,</span> <span class="s">&quot;860&quot;</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span>  <span class="mi">8</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span>
 <span class="n">FE_ULTRA</span><span class="o">|</span><span class="n">FE_CACHE_SET</span><span class="o">|</span><span class="n">FE_BOF</span><span class="o">|</span><span class="n">FE_LDSTR</span><span class="o">|</span><span class="n">FE_PFEN</span><span class="p">}</span>
 <span class="p">,</span>
 <span class="p">{</span><span class="n">PCI_DEVICE_ID_NCR_53C875</span><span class="p">,</span> <span class="mh">0x01</span><span class="p">,</span> <span class="s">&quot;875&quot;</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span>
 <span class="n">FE_WIDE</span><span class="o">|</span><span class="n">FE_ULTRA</span><span class="o">|</span><span class="n">FE_CACHE0_SET</span><span class="o">|</span><span class="n">FE_BOF</span><span class="o">|</span><span class="n">FE_DFS</span><span class="o">|</span><span class="n">FE_LDSTR</span><span class="o">|</span><span class="n">FE_PFEN</span><span class="o">|</span>
 <span class="n">FE_RAM</span><span class="o">|</span><span class="n">FE_DIFF</span><span class="o">|</span><span class="n">FE_VARCLK</span><span class="p">}</span>
 <span class="p">,</span>
 <span class="p">{</span><span class="n">PCI_DEVICE_ID_NCR_53C875</span><span class="p">,</span> <span class="mh">0xff</span><span class="p">,</span> <span class="s">&quot;875&quot;</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span>
 <span class="n">FE_WIDE</span><span class="o">|</span><span class="n">FE_ULTRA</span><span class="o">|</span><span class="n">FE_DBLR</span><span class="o">|</span><span class="n">FE_CACHE0_SET</span><span class="o">|</span><span class="n">FE_BOF</span><span class="o">|</span><span class="n">FE_DFS</span><span class="o">|</span><span class="n">FE_LDSTR</span><span class="o">|</span><span class="n">FE_PFEN</span><span class="o">|</span>
 <span class="n">FE_RAM</span><span class="o">|</span><span class="n">FE_DIFF</span><span class="o">|</span><span class="n">FE_VARCLK</span><span class="p">}</span>
 <span class="p">,</span>
 <span class="p">{</span><span class="n">PCI_DEVICE_ID_NCR_53C875J</span><span class="p">,</span> <span class="mh">0xff</span><span class="p">,</span> <span class="s">&quot;875J&quot;</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span>
 <span class="n">FE_WIDE</span><span class="o">|</span><span class="n">FE_ULTRA</span><span class="o">|</span><span class="n">FE_DBLR</span><span class="o">|</span><span class="n">FE_CACHE0_SET</span><span class="o">|</span><span class="n">FE_BOF</span><span class="o">|</span><span class="n">FE_DFS</span><span class="o">|</span><span class="n">FE_LDSTR</span><span class="o">|</span><span class="n">FE_PFEN</span><span class="o">|</span>
 <span class="n">FE_RAM</span><span class="o">|</span><span class="n">FE_DIFF</span><span class="o">|</span><span class="n">FE_VARCLK</span><span class="p">}</span>
 <span class="p">,</span>
 <span class="p">{</span><span class="n">PCI_DEVICE_ID_NCR_53C885</span><span class="p">,</span> <span class="mh">0xff</span><span class="p">,</span> <span class="s">&quot;885&quot;</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span>
 <span class="n">FE_WIDE</span><span class="o">|</span><span class="n">FE_ULTRA</span><span class="o">|</span><span class="n">FE_DBLR</span><span class="o">|</span><span class="n">FE_CACHE0_SET</span><span class="o">|</span><span class="n">FE_BOF</span><span class="o">|</span><span class="n">FE_DFS</span><span class="o">|</span><span class="n">FE_LDSTR</span><span class="o">|</span><span class="n">FE_PFEN</span><span class="o">|</span>
 <span class="n">FE_RAM</span><span class="o">|</span><span class="n">FE_DIFF</span><span class="o">|</span><span class="n">FE_VARCLK</span><span class="p">}</span>
 <span class="p">,</span>
<span class="cp">#ifdef SYM_DEBUG_GENERIC_SUPPORT</span>
 <span class="p">{</span><span class="n">PCI_DEVICE_ID_NCR_53C895</span><span class="p">,</span> <span class="mh">0xff</span><span class="p">,</span> <span class="s">&quot;895&quot;</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">31</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span>
 <span class="n">FE_WIDE</span><span class="o">|</span><span class="n">FE_ULTRA2</span><span class="o">|</span><span class="n">FE_QUAD</span><span class="o">|</span><span class="n">FE_CACHE_SET</span><span class="o">|</span><span class="n">FE_BOF</span><span class="o">|</span><span class="n">FE_DFS</span><span class="o">|</span>
 <span class="n">FE_RAM</span><span class="o">|</span><span class="n">FE_LCKFRQ</span><span class="p">}</span>
 <span class="p">,</span>
<span class="cp">#else</span>
 <span class="p">{</span><span class="n">PCI_DEVICE_ID_NCR_53C895</span><span class="p">,</span> <span class="mh">0xff</span><span class="p">,</span> <span class="s">&quot;895&quot;</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">31</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span>
 <span class="n">FE_WIDE</span><span class="o">|</span><span class="n">FE_ULTRA2</span><span class="o">|</span><span class="n">FE_QUAD</span><span class="o">|</span><span class="n">FE_CACHE_SET</span><span class="o">|</span><span class="n">FE_BOF</span><span class="o">|</span><span class="n">FE_DFS</span><span class="o">|</span><span class="n">FE_LDSTR</span><span class="o">|</span><span class="n">FE_PFEN</span><span class="o">|</span>
 <span class="n">FE_RAM</span><span class="o">|</span><span class="n">FE_LCKFRQ</span><span class="p">}</span>
 <span class="p">,</span>
<span class="cp">#endif</span>
 <span class="p">{</span><span class="n">PCI_DEVICE_ID_NCR_53C896</span><span class="p">,</span> <span class="mh">0xff</span><span class="p">,</span> <span class="s">&quot;896&quot;</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">31</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span>
 <span class="n">FE_WIDE</span><span class="o">|</span><span class="n">FE_ULTRA2</span><span class="o">|</span><span class="n">FE_QUAD</span><span class="o">|</span><span class="n">FE_CACHE_SET</span><span class="o">|</span><span class="n">FE_BOF</span><span class="o">|</span><span class="n">FE_DFS</span><span class="o">|</span><span class="n">FE_LDSTR</span><span class="o">|</span><span class="n">FE_PFEN</span><span class="o">|</span>
 <span class="n">FE_RAM</span><span class="o">|</span><span class="n">FE_RAM8K</span><span class="o">|</span><span class="n">FE_64BIT</span><span class="o">|</span><span class="n">FE_DAC</span><span class="o">|</span><span class="n">FE_IO256</span><span class="o">|</span><span class="n">FE_NOPM</span><span class="o">|</span><span class="n">FE_LEDC</span><span class="o">|</span><span class="n">FE_LCKFRQ</span><span class="p">}</span>
 <span class="p">,</span>
 <span class="p">{</span><span class="n">PCI_DEVICE_ID_LSI_53C895A</span><span class="p">,</span> <span class="mh">0xff</span><span class="p">,</span> <span class="s">&quot;895a&quot;</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">31</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span>
 <span class="n">FE_WIDE</span><span class="o">|</span><span class="n">FE_ULTRA2</span><span class="o">|</span><span class="n">FE_QUAD</span><span class="o">|</span><span class="n">FE_CACHE_SET</span><span class="o">|</span><span class="n">FE_BOF</span><span class="o">|</span><span class="n">FE_DFS</span><span class="o">|</span><span class="n">FE_LDSTR</span><span class="o">|</span><span class="n">FE_PFEN</span><span class="o">|</span>
 <span class="n">FE_RAM</span><span class="o">|</span><span class="n">FE_RAM8K</span><span class="o">|</span><span class="n">FE_DAC</span><span class="o">|</span><span class="n">FE_IO256</span><span class="o">|</span><span class="n">FE_NOPM</span><span class="o">|</span><span class="n">FE_LEDC</span><span class="o">|</span><span class="n">FE_LCKFRQ</span><span class="p">}</span>
 <span class="p">,</span>
 <span class="p">{</span><span class="n">PCI_DEVICE_ID_LSI_53C875A</span><span class="p">,</span> <span class="mh">0xff</span><span class="p">,</span> <span class="s">&quot;875a&quot;</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">31</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span>
 <span class="n">FE_WIDE</span><span class="o">|</span><span class="n">FE_ULTRA</span><span class="o">|</span><span class="n">FE_QUAD</span><span class="o">|</span><span class="n">FE_CACHE_SET</span><span class="o">|</span><span class="n">FE_BOF</span><span class="o">|</span><span class="n">FE_DFS</span><span class="o">|</span><span class="n">FE_LDSTR</span><span class="o">|</span><span class="n">FE_PFEN</span><span class="o">|</span>
 <span class="n">FE_RAM</span><span class="o">|</span><span class="n">FE_DAC</span><span class="o">|</span><span class="n">FE_IO256</span><span class="o">|</span><span class="n">FE_NOPM</span><span class="o">|</span><span class="n">FE_LEDC</span><span class="o">|</span><span class="n">FE_LCKFRQ</span><span class="p">}</span>
 <span class="p">,</span>
 <span class="p">{</span><span class="n">PCI_DEVICE_ID_LSI_53C1010_33</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="s">&quot;1010-33&quot;</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">31</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span>
 <span class="n">FE_WIDE</span><span class="o">|</span><span class="n">FE_ULTRA3</span><span class="o">|</span><span class="n">FE_QUAD</span><span class="o">|</span><span class="n">FE_CACHE_SET</span><span class="o">|</span><span class="n">FE_BOF</span><span class="o">|</span><span class="n">FE_DFBC</span><span class="o">|</span><span class="n">FE_LDSTR</span><span class="o">|</span><span class="n">FE_PFEN</span><span class="o">|</span>
 <span class="n">FE_RAM</span><span class="o">|</span><span class="n">FE_RAM8K</span><span class="o">|</span><span class="n">FE_64BIT</span><span class="o">|</span><span class="n">FE_DAC</span><span class="o">|</span><span class="n">FE_IO256</span><span class="o">|</span><span class="n">FE_NOPM</span><span class="o">|</span><span class="n">FE_LEDC</span><span class="o">|</span><span class="n">FE_CRC</span><span class="o">|</span>
 <span class="n">FE_C10</span><span class="p">}</span>
 <span class="p">,</span>
 <span class="p">{</span><span class="n">PCI_DEVICE_ID_LSI_53C1010_33</span><span class="p">,</span> <span class="mh">0xff</span><span class="p">,</span> <span class="s">&quot;1010-33&quot;</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">31</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span>
 <span class="n">FE_WIDE</span><span class="o">|</span><span class="n">FE_ULTRA3</span><span class="o">|</span><span class="n">FE_QUAD</span><span class="o">|</span><span class="n">FE_CACHE_SET</span><span class="o">|</span><span class="n">FE_BOF</span><span class="o">|</span><span class="n">FE_DFBC</span><span class="o">|</span><span class="n">FE_LDSTR</span><span class="o">|</span><span class="n">FE_PFEN</span><span class="o">|</span>
 <span class="n">FE_RAM</span><span class="o">|</span><span class="n">FE_RAM8K</span><span class="o">|</span><span class="n">FE_64BIT</span><span class="o">|</span><span class="n">FE_DAC</span><span class="o">|</span><span class="n">FE_IO256</span><span class="o">|</span><span class="n">FE_NOPM</span><span class="o">|</span><span class="n">FE_LEDC</span><span class="o">|</span><span class="n">FE_CRC</span><span class="o">|</span>
 <span class="n">FE_C10</span><span class="o">|</span><span class="n">FE_U3EN</span><span class="p">}</span>
 <span class="p">,</span>
 <span class="p">{</span><span class="n">PCI_DEVICE_ID_LSI_53C1010_66</span><span class="p">,</span> <span class="mh">0xff</span><span class="p">,</span> <span class="s">&quot;1010-66&quot;</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">31</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span>
 <span class="n">FE_WIDE</span><span class="o">|</span><span class="n">FE_ULTRA3</span><span class="o">|</span><span class="n">FE_QUAD</span><span class="o">|</span><span class="n">FE_CACHE_SET</span><span class="o">|</span><span class="n">FE_BOF</span><span class="o">|</span><span class="n">FE_DFBC</span><span class="o">|</span><span class="n">FE_LDSTR</span><span class="o">|</span><span class="n">FE_PFEN</span><span class="o">|</span>
 <span class="n">FE_RAM</span><span class="o">|</span><span class="n">FE_RAM8K</span><span class="o">|</span><span class="n">FE_64BIT</span><span class="o">|</span><span class="n">FE_DAC</span><span class="o">|</span><span class="n">FE_IO256</span><span class="o">|</span><span class="n">FE_NOPM</span><span class="o">|</span><span class="n">FE_LEDC</span><span class="o">|</span><span class="n">FE_66MHZ</span><span class="o">|</span><span class="n">FE_CRC</span><span class="o">|</span>
 <span class="n">FE_C10</span><span class="o">|</span><span class="n">FE_U3EN</span><span class="p">}</span>
 <span class="p">,</span>
 <span class="p">{</span><span class="n">PCI_DEVICE_ID_LSI_53C1510</span><span class="p">,</span> <span class="mh">0xff</span><span class="p">,</span> <span class="s">&quot;1510d&quot;</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">31</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span>
 <span class="n">FE_WIDE</span><span class="o">|</span><span class="n">FE_ULTRA2</span><span class="o">|</span><span class="n">FE_QUAD</span><span class="o">|</span><span class="n">FE_CACHE_SET</span><span class="o">|</span><span class="n">FE_BOF</span><span class="o">|</span><span class="n">FE_DFS</span><span class="o">|</span><span class="n">FE_LDSTR</span><span class="o">|</span><span class="n">FE_PFEN</span><span class="o">|</span>
 <span class="n">FE_RAM</span><span class="o">|</span><span class="n">FE_IO256</span><span class="o">|</span><span class="n">FE_LEDC</span><span class="p">}</span>
<span class="p">};</span>

<span class="cp">#define sym_num_devs (ARRAY_SIZE(sym_dev_table))</span>

<span class="cm">/*</span>
<span class="cm"> *  Look up the chip table.</span>
<span class="cm"> *</span>
<span class="cm"> *  Return a pointer to the chip entry if found, </span>
<span class="cm"> *  zero otherwise.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">sym_chip</span> <span class="o">*</span>
<span class="n">sym_lookup_chip_table</span> <span class="p">(</span><span class="n">u_short</span> <span class="n">device_id</span><span class="p">,</span> <span class="n">u_char</span> <span class="n">revision</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span>	<span class="n">sym_chip</span> <span class="o">*</span><span class="n">chip</span><span class="p">;</span>
	<span class="kt">int</span>	<span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">sym_num_devs</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">chip</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">sym_dev_table</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">device_id</span> <span class="o">!=</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">device_id</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">revision</span> <span class="o">&gt;</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">revision_id</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="k">return</span> <span class="n">chip</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#if SYM_CONF_DMA_ADDRESSING_MODE == 2</span>
<span class="cm">/*</span>
<span class="cm"> *  Lookup the 64 bit DMA segments map.</span>
<span class="cm"> *  This is only used if the direct mapping </span>
<span class="cm"> *  has been unsuccessful.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">sym_lookup_dmap</span><span class="p">(</span><span class="k">struct</span> <span class="n">sym_hcb</span> <span class="o">*</span><span class="n">np</span><span class="p">,</span> <span class="n">u32</span> <span class="n">h</span><span class="p">,</span> <span class="kt">int</span> <span class="n">s</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">use_dac</span><span class="p">(</span><span class="n">np</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">weird</span><span class="p">;</span>

	<span class="cm">/* Look up existing mappings */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">SYM_DMAP_SIZE</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">h</span> <span class="o">==</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">dmap_bah</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
			<span class="k">return</span> <span class="n">i</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* If direct mapping is free, get it */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">dmap_bah</span><span class="p">[</span><span class="n">s</span><span class="p">])</span>
		<span class="k">goto</span> <span class="n">new</span><span class="p">;</span>
	<span class="cm">/* Collision -&gt; lookup free mappings */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">s</span> <span class="o">=</span> <span class="n">SYM_DMAP_SIZE</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="n">s</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">;</span> <span class="n">s</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">dmap_bah</span><span class="p">[</span><span class="n">s</span><span class="p">])</span>
			<span class="k">goto</span> <span class="n">new</span><span class="p">;</span>
	<span class="p">}</span>
<span class="nl">weird:</span>
	<span class="n">panic</span><span class="p">(</span><span class="s">&quot;sym: ran out of 64 bit DMA segment registers&quot;</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="nl">new:</span>
	<span class="n">np</span><span class="o">-&gt;</span><span class="n">dmap_bah</span><span class="p">[</span><span class="n">s</span><span class="p">]</span> <span class="o">=</span> <span class="n">h</span><span class="p">;</span>
	<span class="n">np</span><span class="o">-&gt;</span><span class="n">dmap_dirty</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">s</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *  Update IO registers scratch C..R so they will be </span>
<span class="cm"> *  in sync. with queued CCB expectations.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">sym_update_dmap_regs</span><span class="p">(</span><span class="k">struct</span> <span class="n">sym_hcb</span> <span class="o">*</span><span class="n">np</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">o</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">dmap_dirty</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">o</span> <span class="o">=</span> <span class="n">offsetof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sym_reg</span><span class="p">,</span> <span class="n">nc_scrx</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">SYM_DMAP_SIZE</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">OUTL_OFF</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">o</span><span class="p">,</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">dmap_bah</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
		<span class="n">o</span> <span class="o">+=</span> <span class="mi">4</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">np</span><span class="o">-&gt;</span><span class="n">dmap_dirty</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="cm">/* Enforce all the fiddly SPI rules and the chip limitations */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">sym_check_goals</span><span class="p">(</span><span class="k">struct</span> <span class="n">sym_hcb</span> <span class="o">*</span><span class="n">np</span><span class="p">,</span> <span class="k">struct</span> <span class="n">scsi_target</span> <span class="o">*</span><span class="n">starget</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">sym_trans</span> <span class="o">*</span><span class="n">goal</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">spi_support_wide</span><span class="p">(</span><span class="n">starget</span><span class="p">))</span>
		<span class="n">goal</span><span class="o">-&gt;</span><span class="n">width</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">spi_support_sync</span><span class="p">(</span><span class="n">starget</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">goal</span><span class="o">-&gt;</span><span class="n">iu</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">goal</span><span class="o">-&gt;</span><span class="n">dt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">goal</span><span class="o">-&gt;</span><span class="n">qas</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">goal</span><span class="o">-&gt;</span><span class="n">offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">spi_support_dt</span><span class="p">(</span><span class="n">starget</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">spi_support_dt_only</span><span class="p">(</span><span class="n">starget</span><span class="p">))</span>
			<span class="n">goal</span><span class="o">-&gt;</span><span class="n">dt</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">goal</span><span class="o">-&gt;</span><span class="n">offset</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">goal</span><span class="o">-&gt;</span><span class="n">dt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">goal</span><span class="o">-&gt;</span><span class="n">dt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Some targets fail to properly negotiate DT in SE mode */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">scsi_mode</span> <span class="o">!=</span> <span class="n">SMODE_LVD</span><span class="p">)</span> <span class="o">||</span> <span class="o">!</span><span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">features</span> <span class="o">&amp;</span> <span class="n">FE_U3EN</span><span class="p">))</span>
		<span class="n">goal</span><span class="o">-&gt;</span><span class="n">dt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">goal</span><span class="o">-&gt;</span><span class="n">dt</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* all DT transfers must be wide */</span>
		<span class="n">goal</span><span class="o">-&gt;</span><span class="n">width</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">goal</span><span class="o">-&gt;</span><span class="n">offset</span> <span class="o">&gt;</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">maxoffs_dt</span><span class="p">)</span>
			<span class="n">goal</span><span class="o">-&gt;</span><span class="n">offset</span> <span class="o">=</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">maxoffs_dt</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">goal</span><span class="o">-&gt;</span><span class="n">period</span> <span class="o">&lt;</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">minsync_dt</span><span class="p">)</span>
			<span class="n">goal</span><span class="o">-&gt;</span><span class="n">period</span> <span class="o">=</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">minsync_dt</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">goal</span><span class="o">-&gt;</span><span class="n">period</span> <span class="o">&gt;</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">maxsync_dt</span><span class="p">)</span>
			<span class="n">goal</span><span class="o">-&gt;</span><span class="n">period</span> <span class="o">=</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">maxsync_dt</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">goal</span><span class="o">-&gt;</span><span class="n">iu</span> <span class="o">=</span> <span class="n">goal</span><span class="o">-&gt;</span><span class="n">qas</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">goal</span><span class="o">-&gt;</span><span class="n">offset</span> <span class="o">&gt;</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">maxoffs</span><span class="p">)</span>
			<span class="n">goal</span><span class="o">-&gt;</span><span class="n">offset</span> <span class="o">=</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">maxoffs</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">goal</span><span class="o">-&gt;</span><span class="n">period</span> <span class="o">&lt;</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">minsync</span><span class="p">)</span>
			<span class="n">goal</span><span class="o">-&gt;</span><span class="n">period</span> <span class="o">=</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">minsync</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">goal</span><span class="o">-&gt;</span><span class="n">period</span> <span class="o">&gt;</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">maxsync</span><span class="p">)</span>
			<span class="n">goal</span><span class="o">-&gt;</span><span class="n">period</span> <span class="o">=</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">maxsync</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *  Prepare the next negotiation message if needed.</span>
<span class="cm"> *</span>
<span class="cm"> *  Fill in the part of message buffer that contains the </span>
<span class="cm"> *  negotiation and the nego_status field of the CCB.</span>
<span class="cm"> *  Returns the size of the message in bytes.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">sym_prepare_nego</span><span class="p">(</span><span class="k">struct</span> <span class="n">sym_hcb</span> <span class="o">*</span><span class="n">np</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sym_ccb</span> <span class="o">*</span><span class="n">cp</span><span class="p">,</span> <span class="n">u_char</span> <span class="o">*</span><span class="n">msgptr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sym_tcb</span> <span class="o">*</span><span class="n">tp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">target</span><span class="p">[</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">target</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">scsi_target</span> <span class="o">*</span><span class="n">starget</span> <span class="o">=</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">starget</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sym_trans</span> <span class="o">*</span><span class="n">goal</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">tgoal</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">msglen</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">nego</span><span class="p">;</span>

	<span class="n">sym_check_goals</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">starget</span><span class="p">,</span> <span class="n">goal</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Many devices implement PPR in a buggy way, so only use it if we</span>
<span class="cm">	 * really want to.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">goal</span><span class="o">-&gt;</span><span class="n">renego</span> <span class="o">==</span> <span class="n">NS_PPR</span> <span class="o">||</span> <span class="p">(</span><span class="n">goal</span><span class="o">-&gt;</span><span class="n">offset</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">goal</span><span class="o">-&gt;</span><span class="n">iu</span> <span class="o">||</span> <span class="n">goal</span><span class="o">-&gt;</span><span class="n">dt</span> <span class="o">||</span> <span class="n">goal</span><span class="o">-&gt;</span><span class="n">qas</span> <span class="o">||</span> <span class="p">(</span><span class="n">goal</span><span class="o">-&gt;</span><span class="n">period</span> <span class="o">&lt;</span> <span class="mh">0xa</span><span class="p">))))</span> <span class="p">{</span>
		<span class="n">nego</span> <span class="o">=</span> <span class="n">NS_PPR</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">goal</span><span class="o">-&gt;</span><span class="n">renego</span> <span class="o">==</span> <span class="n">NS_WIDE</span> <span class="o">||</span> <span class="n">goal</span><span class="o">-&gt;</span><span class="n">width</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">nego</span> <span class="o">=</span> <span class="n">NS_WIDE</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">goal</span><span class="o">-&gt;</span><span class="n">renego</span> <span class="o">==</span> <span class="n">NS_SYNC</span> <span class="o">||</span> <span class="n">goal</span><span class="o">-&gt;</span><span class="n">offset</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">nego</span> <span class="o">=</span> <span class="n">NS_SYNC</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">goal</span><span class="o">-&gt;</span><span class="n">check_nego</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">nego</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">nego</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">NS_SYNC</span>:
		<span class="n">msglen</span> <span class="o">+=</span> <span class="n">spi_populate_sync_msg</span><span class="p">(</span><span class="n">msgptr</span> <span class="o">+</span> <span class="n">msglen</span><span class="p">,</span> <span class="n">goal</span><span class="o">-&gt;</span><span class="n">period</span><span class="p">,</span>
				<span class="n">goal</span><span class="o">-&gt;</span><span class="n">offset</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">NS_WIDE</span>:
		<span class="n">msglen</span> <span class="o">+=</span> <span class="n">spi_populate_width_msg</span><span class="p">(</span><span class="n">msgptr</span> <span class="o">+</span> <span class="n">msglen</span><span class="p">,</span> <span class="n">goal</span><span class="o">-&gt;</span><span class="n">width</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">NS_PPR</span>:
		<span class="n">msglen</span> <span class="o">+=</span> <span class="n">spi_populate_ppr_msg</span><span class="p">(</span><span class="n">msgptr</span> <span class="o">+</span> <span class="n">msglen</span><span class="p">,</span> <span class="n">goal</span><span class="o">-&gt;</span><span class="n">period</span><span class="p">,</span>
				<span class="n">goal</span><span class="o">-&gt;</span><span class="n">offset</span><span class="p">,</span> <span class="n">goal</span><span class="o">-&gt;</span><span class="n">width</span><span class="p">,</span>
				<span class="p">(</span><span class="n">goal</span><span class="o">-&gt;</span><span class="n">iu</span> <span class="o">?</span> <span class="n">PPR_OPT_IU</span> <span class="o">:</span> <span class="mi">0</span><span class="p">)</span> <span class="o">|</span>
					<span class="p">(</span><span class="n">goal</span><span class="o">-&gt;</span><span class="n">dt</span> <span class="o">?</span> <span class="n">PPR_OPT_DT</span> <span class="o">:</span> <span class="mi">0</span><span class="p">)</span> <span class="o">|</span>
					<span class="p">(</span><span class="n">goal</span><span class="o">-&gt;</span><span class="n">qas</span> <span class="o">?</span> <span class="n">PPR_OPT_QAS</span> <span class="o">:</span> <span class="mi">0</span><span class="p">));</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">cp</span><span class="o">-&gt;</span><span class="n">nego_status</span> <span class="o">=</span> <span class="n">nego</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">nego</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">tp</span><span class="o">-&gt;</span><span class="n">nego_cp</span> <span class="o">=</span> <span class="n">cp</span><span class="p">;</span> <span class="cm">/* Keep track a nego will be performed */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">DEBUG_FLAGS</span> <span class="o">&amp;</span> <span class="n">DEBUG_NEGO</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">sym_print_nego_msg</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">target</span><span class="p">,</span> 
					  <span class="n">nego</span> <span class="o">==</span> <span class="n">NS_SYNC</span> <span class="o">?</span> <span class="s">&quot;sync msgout&quot;</span> <span class="o">:</span>
					  <span class="n">nego</span> <span class="o">==</span> <span class="n">NS_WIDE</span> <span class="o">?</span> <span class="s">&quot;wide msgout&quot;</span> <span class="o">:</span>
					  <span class="s">&quot;ppr msgout&quot;</span><span class="p">,</span> <span class="n">msgptr</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">msglen</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *  Insert a job into the start queue.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">sym_put_start_queue</span><span class="p">(</span><span class="k">struct</span> <span class="n">sym_hcb</span> <span class="o">*</span><span class="n">np</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sym_ccb</span> <span class="o">*</span><span class="n">cp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u_short</span>	<span class="n">qidx</span><span class="p">;</span>

<span class="cp">#ifdef SYM_CONF_IARB_SUPPORT</span>
	<span class="cm">/*</span>
<span class="cm">	 *  If the previously queued CCB is not yet done, </span>
<span class="cm">	 *  set the IARB hint. The SCRIPTS will go with IARB </span>
<span class="cm">	 *  for this job when starting the previous one.</span>
<span class="cm">	 *  We leave devices a chance to win arbitration by </span>
<span class="cm">	 *  not using more than &#39;iarb_max&#39; consecutive </span>
<span class="cm">	 *  immediate arbitrations.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">last_cp</span> <span class="o">&amp;&amp;</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">iarb_count</span> <span class="o">&lt;</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">iarb_max</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">np</span><span class="o">-&gt;</span><span class="n">last_cp</span><span class="o">-&gt;</span><span class="n">host_flags</span> <span class="o">|=</span> <span class="n">HF_HINT_IARB</span><span class="p">;</span>
		<span class="o">++</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">iarb_count</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">else</span>
		<span class="n">np</span><span class="o">-&gt;</span><span class="n">iarb_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">np</span><span class="o">-&gt;</span><span class="n">last_cp</span> <span class="o">=</span> <span class="n">cp</span><span class="p">;</span>
<span class="cp">#endif</span>

<span class="cp">#if   SYM_CONF_DMA_ADDRESSING_MODE == 2</span>
	<span class="cm">/*</span>
<span class="cm">	 *  Make SCRIPTS aware of the 64 bit DMA </span>
<span class="cm">	 *  segment registers not being up-to-date.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">dmap_dirty</span><span class="p">)</span>
		<span class="n">cp</span><span class="o">-&gt;</span><span class="n">host_xflags</span> <span class="o">|=</span> <span class="n">HX_DMAP_DIRTY</span><span class="p">;</span>
<span class="cp">#endif</span>

	<span class="cm">/*</span>
<span class="cm">	 *  Insert first the idle task and then our job.</span>
<span class="cm">	 *  The MBs should ensure proper ordering.</span>
<span class="cm">	 */</span>
	<span class="n">qidx</span> <span class="o">=</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">squeueput</span> <span class="o">+</span> <span class="mi">2</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">qidx</span> <span class="o">&gt;=</span> <span class="n">MAX_QUEUE</span><span class="o">*</span><span class="mi">2</span><span class="p">)</span> <span class="n">qidx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">np</span><span class="o">-&gt;</span><span class="n">squeue</span> <span class="p">[</span><span class="n">qidx</span><span class="p">]</span>	   <span class="o">=</span> <span class="n">cpu_to_scr</span><span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">idletask_ba</span><span class="p">);</span>
	<span class="n">MEMORY_WRITE_BARRIER</span><span class="p">();</span>
	<span class="n">np</span><span class="o">-&gt;</span><span class="n">squeue</span> <span class="p">[</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">squeueput</span><span class="p">]</span> <span class="o">=</span> <span class="n">cpu_to_scr</span><span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">ccb_ba</span><span class="p">);</span>

	<span class="n">np</span><span class="o">-&gt;</span><span class="n">squeueput</span> <span class="o">=</span> <span class="n">qidx</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">DEBUG_FLAGS</span> <span class="o">&amp;</span> <span class="n">DEBUG_QUEUE</span><span class="p">)</span>
		<span class="n">scmd_printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span><span class="p">,</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">cmd</span><span class="p">,</span> <span class="s">&quot;queuepos=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
							<span class="n">np</span><span class="o">-&gt;</span><span class="n">squeueput</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 *  Script processor may be waiting for reselect.</span>
<span class="cm">	 *  Wake it up.</span>
<span class="cm">	 */</span>
	<span class="n">MEMORY_WRITE_BARRIER</span><span class="p">();</span>
	<span class="n">OUTB</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">nc_istat</span><span class="p">,</span> <span class="n">SIGP</span><span class="o">|</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">istat_sem</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#ifdef SYM_OPT_HANDLE_DEVICE_QUEUEING</span>
<span class="cm">/*</span>
<span class="cm"> *  Start next ready-to-start CCBs.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">sym_start_next_ccbs</span><span class="p">(</span><span class="k">struct</span> <span class="n">sym_hcb</span> <span class="o">*</span><span class="n">np</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sym_lcb</span> <span class="o">*</span><span class="n">lp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">maxn</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">SYM_QUEHEAD</span> <span class="o">*</span><span class="n">qp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sym_ccb</span> <span class="o">*</span><span class="n">cp</span><span class="p">;</span>

	<span class="cm">/* </span>
<span class="cm">	 *  Paranoia, as usual. :-)</span>
<span class="cm">	 */</span>
	<span class="n">assert</span><span class="p">(</span><span class="o">!</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">started_tags</span> <span class="o">||</span> <span class="o">!</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">started_no_tag</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 *  Try to start as many commands as asked by caller.</span>
<span class="cm">	 *  Prevent from having both tagged and untagged </span>
<span class="cm">	 *  commands queued to the device at the same time.</span>
<span class="cm">	 */</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">maxn</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">qp</span> <span class="o">=</span> <span class="n">sym_remque_head</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">waiting_ccbq</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">qp</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">cp</span> <span class="o">=</span> <span class="n">sym_que_entry</span><span class="p">(</span><span class="n">qp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sym_ccb</span><span class="p">,</span> <span class="n">link2_ccbq</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">tag</span> <span class="o">!=</span> <span class="n">NO_TAG</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">started_no_tag</span> <span class="o">||</span>
			    <span class="n">lp</span><span class="o">-&gt;</span><span class="n">started_tags</span> <span class="o">&gt;=</span> <span class="n">lp</span><span class="o">-&gt;</span><span class="n">started_max</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">sym_insque_head</span><span class="p">(</span><span class="n">qp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">waiting_ccbq</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">lp</span><span class="o">-&gt;</span><span class="n">itlq_tbl</span><span class="p">[</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">tag</span><span class="p">]</span> <span class="o">=</span> <span class="n">cpu_to_scr</span><span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">ccb_ba</span><span class="p">);</span>
			<span class="n">lp</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">.</span><span class="n">resel_sa</span> <span class="o">=</span>
				<span class="n">cpu_to_scr</span><span class="p">(</span><span class="n">SCRIPTA_BA</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">resel_tag</span><span class="p">));</span>
			<span class="o">++</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">started_tags</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">started_no_tag</span> <span class="o">||</span> <span class="n">lp</span><span class="o">-&gt;</span><span class="n">started_tags</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">sym_insque_head</span><span class="p">(</span><span class="n">qp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">waiting_ccbq</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">lp</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">.</span><span class="n">itl_task_sa</span> <span class="o">=</span> <span class="n">cpu_to_scr</span><span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">ccb_ba</span><span class="p">);</span>
			<span class="n">lp</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">.</span><span class="n">resel_sa</span> <span class="o">=</span>
			      <span class="n">cpu_to_scr</span><span class="p">(</span><span class="n">SCRIPTA_BA</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">resel_no_tag</span><span class="p">));</span>
			<span class="o">++</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">started_no_tag</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">cp</span><span class="o">-&gt;</span><span class="n">started</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">sym_insque_tail</span><span class="p">(</span><span class="n">qp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">started_ccbq</span><span class="p">);</span>
		<span class="n">sym_put_start_queue</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">cp</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* SYM_OPT_HANDLE_DEVICE_QUEUEING */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> *  The chip may have completed jobs. Look at the DONE QUEUE.</span>
<span class="cm"> *</span>
<span class="cm"> *  On paper, memory read barriers may be needed here to </span>
<span class="cm"> *  prevent out of order LOADs by the CPU from having </span>
<span class="cm"> *  prefetched stale data prior to DMA having occurred.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">sym_wakeup_done</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sym_hcb</span> <span class="o">*</span><span class="n">np</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sym_ccb</span> <span class="o">*</span><span class="n">cp</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">n</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">dsa</span><span class="p">;</span>

	<span class="n">n</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">i</span> <span class="o">=</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">dqueueget</span><span class="p">;</span>

	<span class="cm">/* MEMORY_READ_BARRIER(); */</span>
	<span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dsa</span> <span class="o">=</span> <span class="n">scr_to_cpu</span><span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">dqueue</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dsa</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">np</span><span class="o">-&gt;</span><span class="n">dqueue</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">i</span> <span class="o">=</span> <span class="n">i</span><span class="o">+</span><span class="mi">2</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">MAX_QUEUE</span><span class="o">*</span><span class="mi">2</span><span class="p">)</span>
			<span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="n">cp</span> <span class="o">=</span> <span class="n">sym_ccb_from_dsa</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">dsa</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cp</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">MEMORY_READ_BARRIER</span><span class="p">();</span>
			<span class="n">sym_complete_ok</span> <span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">cp</span><span class="p">);</span>
			<span class="o">++</span><span class="n">n</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">else</span>
			<span class="n">printf</span> <span class="p">(</span><span class="s">&quot;%s: bad DSA (%x) in done queue.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">sym_name</span><span class="p">(</span><span class="n">np</span><span class="p">),</span> <span class="p">(</span><span class="n">u_int</span><span class="p">)</span> <span class="n">dsa</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">np</span><span class="o">-&gt;</span><span class="n">dqueueget</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">n</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *  Complete all CCBs queued to the COMP queue.</span>
<span class="cm"> *</span>
<span class="cm"> *  These CCBs are assumed:</span>
<span class="cm"> *  - Not to be referenced either by devices or </span>
<span class="cm"> *    SCRIPTS-related queues and datas.</span>
<span class="cm"> *  - To have to be completed with an error condition </span>
<span class="cm"> *    or requeued.</span>
<span class="cm"> *</span>
<span class="cm"> *  The device queue freeze count is incremented </span>
<span class="cm"> *  for each CCB that does not prevent this.</span>
<span class="cm"> *  This function is called when all CCBs involved </span>
<span class="cm"> *  in error handling/recovery have been reaped.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">sym_flush_comp_queue</span><span class="p">(</span><span class="k">struct</span> <span class="n">sym_hcb</span> <span class="o">*</span><span class="n">np</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cam_status</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">SYM_QUEHEAD</span> <span class="o">*</span><span class="n">qp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sym_ccb</span> <span class="o">*</span><span class="n">cp</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">((</span><span class="n">qp</span> <span class="o">=</span> <span class="n">sym_remque_head</span><span class="p">(</span><span class="o">&amp;</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">comp_ccbq</span><span class="p">))</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">;</span>
		<span class="n">cp</span> <span class="o">=</span> <span class="n">sym_que_entry</span><span class="p">(</span><span class="n">qp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sym_ccb</span><span class="p">,</span> <span class="n">link_ccbq</span><span class="p">);</span>
		<span class="n">sym_insque_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">link_ccbq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">busy_ccbq</span><span class="p">);</span>
		<span class="cm">/* Leave quiet CCBs waiting for resources */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">host_status</span> <span class="o">==</span> <span class="n">HS_WAIT</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="n">cmd</span> <span class="o">=</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">cmd</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cam_status</span><span class="p">)</span>
			<span class="n">sym_set_cam_status</span><span class="p">(</span><span class="n">cmd</span><span class="p">,</span> <span class="n">cam_status</span><span class="p">);</span>
<span class="cp">#ifdef SYM_OPT_HANDLE_DEVICE_QUEUEING</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sym_get_cam_status</span><span class="p">(</span><span class="n">cmd</span><span class="p">)</span> <span class="o">==</span> <span class="n">DID_SOFT_ERROR</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">sym_tcb</span> <span class="o">*</span><span class="n">tp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">target</span><span class="p">[</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">target</span><span class="p">];</span>
			<span class="k">struct</span> <span class="n">sym_lcb</span> <span class="o">*</span><span class="n">lp</span> <span class="o">=</span> <span class="n">sym_lp</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">lun</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">lp</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">sym_remque</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">link2_ccbq</span><span class="p">);</span>
				<span class="n">sym_insque_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">link2_ccbq</span><span class="p">,</span>
				                <span class="o">&amp;</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">waiting_ccbq</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">started</span><span class="p">)</span> <span class="p">{</span>
					<span class="k">if</span> <span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">tag</span> <span class="o">!=</span> <span class="n">NO_TAG</span><span class="p">)</span>
						<span class="o">--</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">started_tags</span><span class="p">;</span>
					<span class="k">else</span>
						<span class="o">--</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">started_no_tag</span><span class="p">;</span>
				<span class="p">}</span>
			<span class="p">}</span>
			<span class="n">cp</span><span class="o">-&gt;</span><span class="n">started</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>
<span class="cp">#endif</span>
		<span class="n">sym_free_ccb</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">cp</span><span class="p">);</span>
		<span class="n">sym_xpt_done</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">cmd</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *  Complete all active CCBs with error.</span>
<span class="cm"> *  Used on CHIP/SCSI RESET.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">sym_flush_busy_queue</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sym_hcb</span> <span class="o">*</span><span class="n">np</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cam_status</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 *  Move all active CCBs to the COMP queue </span>
<span class="cm">	 *  and flush this queue.</span>
<span class="cm">	 */</span>
	<span class="n">sym_que_splice</span><span class="p">(</span><span class="o">&amp;</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">busy_ccbq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">comp_ccbq</span><span class="p">);</span>
	<span class="n">sym_que_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">busy_ccbq</span><span class="p">);</span>
	<span class="n">sym_flush_comp_queue</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">cam_status</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *  Start chip.</span>
<span class="cm"> *</span>
<span class="cm"> *  &#39;reason&#39; means:</span>
<span class="cm"> *     0: initialisation.</span>
<span class="cm"> *     1: SCSI BUS RESET delivered or received.</span>
<span class="cm"> *     2: SCSI BUS MODE changed.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">sym_start_up</span><span class="p">(</span><span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span><span class="p">,</span> <span class="kt">int</span> <span class="n">reason</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sym_data</span> <span class="o">*</span><span class="n">sym_data</span> <span class="o">=</span> <span class="n">shost_priv</span><span class="p">(</span><span class="n">shost</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span> <span class="o">=</span> <span class="n">sym_data</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sym_hcb</span> <span class="o">*</span><span class="n">np</span> <span class="o">=</span> <span class="n">sym_data</span><span class="o">-&gt;</span><span class="n">ncb</span><span class="p">;</span>
 	<span class="kt">int</span>	<span class="n">i</span><span class="p">;</span>
	<span class="n">u32</span>	<span class="n">phys</span><span class="p">;</span>

 	<span class="cm">/*</span>
<span class="cm">	 *  Reset chip if asked, otherwise just clear fifos.</span>
<span class="cm"> 	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">reason</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
		<span class="n">sym_soft_reset</span><span class="p">(</span><span class="n">np</span><span class="p">);</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="n">OUTB</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">nc_stest3</span><span class="p">,</span> <span class="n">TE</span><span class="o">|</span><span class="n">CSF</span><span class="p">);</span>
		<span class="n">OUTONB</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">nc_ctest3</span><span class="p">,</span> <span class="n">CLF</span><span class="p">);</span>
	<span class="p">}</span>
 
	<span class="cm">/*</span>
<span class="cm">	 *  Clear Start Queue</span>
<span class="cm">	 */</span>
	<span class="n">phys</span> <span class="o">=</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">squeue_ba</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">MAX_QUEUE</span><span class="o">*</span><span class="mi">2</span><span class="p">;</span> <span class="n">i</span> <span class="o">+=</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">np</span><span class="o">-&gt;</span><span class="n">squeue</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>   <span class="o">=</span> <span class="n">cpu_to_scr</span><span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">idletask_ba</span><span class="p">);</span>
		<span class="n">np</span><span class="o">-&gt;</span><span class="n">squeue</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">cpu_to_scr</span><span class="p">(</span><span class="n">phys</span> <span class="o">+</span> <span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="mi">4</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">np</span><span class="o">-&gt;</span><span class="n">squeue</span><span class="p">[</span><span class="n">MAX_QUEUE</span><span class="o">*</span><span class="mi">2</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">cpu_to_scr</span><span class="p">(</span><span class="n">phys</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 *  Start at first entry.</span>
<span class="cm">	 */</span>
	<span class="n">np</span><span class="o">-&gt;</span><span class="n">squeueput</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 *  Clear Done Queue</span>
<span class="cm">	 */</span>
	<span class="n">phys</span> <span class="o">=</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">dqueue_ba</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">MAX_QUEUE</span><span class="o">*</span><span class="mi">2</span><span class="p">;</span> <span class="n">i</span> <span class="o">+=</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">np</span><span class="o">-&gt;</span><span class="n">dqueue</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>   <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">np</span><span class="o">-&gt;</span><span class="n">dqueue</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">cpu_to_scr</span><span class="p">(</span><span class="n">phys</span> <span class="o">+</span> <span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="mi">4</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">np</span><span class="o">-&gt;</span><span class="n">dqueue</span><span class="p">[</span><span class="n">MAX_QUEUE</span><span class="o">*</span><span class="mi">2</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">cpu_to_scr</span><span class="p">(</span><span class="n">phys</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 *  Start at first entry.</span>
<span class="cm">	 */</span>
	<span class="n">np</span><span class="o">-&gt;</span><span class="n">dqueueget</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 *  Install patches in scripts.</span>
<span class="cm">	 *  This also let point to first position the start </span>
<span class="cm">	 *  and done queue pointers used from SCRIPTS.</span>
<span class="cm">	 */</span>
	<span class="n">np</span><span class="o">-&gt;</span><span class="n">fw_patch</span><span class="p">(</span><span class="n">shost</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 *  Wakeup all pending jobs.</span>
<span class="cm">	 */</span>
	<span class="n">sym_flush_busy_queue</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">DID_RESET</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 *  Init chip.</span>
<span class="cm">	 */</span>
	<span class="n">OUTB</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">nc_istat</span><span class="p">,</span>  <span class="mh">0x00</span><span class="p">);</span>			<span class="cm">/*  Remove Reset, abort */</span>
	<span class="n">INB</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">nc_mbox1</span><span class="p">);</span>
	<span class="n">udelay</span><span class="p">(</span><span class="mi">2000</span><span class="p">);</span> <span class="cm">/* The 895 needs time for the bus mode to settle */</span>

	<span class="n">OUTB</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">nc_scntl0</span><span class="p">,</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">rv_scntl0</span> <span class="o">|</span> <span class="mh">0xc0</span><span class="p">);</span>
					<span class="cm">/*  full arb., ena parity, par-&gt;ATN  */</span>
	<span class="n">OUTB</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">nc_scntl1</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">);</span>		<span class="cm">/*  odd parity, and remove CRST!! */</span>

	<span class="n">sym_selectclock</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">rv_scntl3</span><span class="p">);</span>	<span class="cm">/* Select SCSI clock */</span>

	<span class="n">OUTB</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">nc_scid</span>  <span class="p">,</span> <span class="n">RRE</span><span class="o">|</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">myaddr</span><span class="p">);</span>	<span class="cm">/* Adapter SCSI address */</span>
	<span class="n">OUTW</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">nc_respid</span><span class="p">,</span> <span class="mi">1ul</span><span class="o">&lt;&lt;</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">myaddr</span><span class="p">);</span>	<span class="cm">/* Id to respond to */</span>
	<span class="n">OUTB</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">nc_istat</span> <span class="p">,</span> <span class="n">SIGP</span>	<span class="p">);</span>		<span class="cm">/*  Signal Process */</span>
	<span class="n">OUTB</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">nc_dmode</span> <span class="p">,</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">rv_dmode</span><span class="p">);</span>		<span class="cm">/* Burst length, dma mode */</span>
	<span class="n">OUTB</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">nc_ctest5</span><span class="p">,</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">rv_ctest5</span><span class="p">);</span>	<span class="cm">/* Large fifo + large burst */</span>

	<span class="n">OUTB</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">nc_dcntl</span> <span class="p">,</span> <span class="n">NOCOM</span><span class="o">|</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">rv_dcntl</span><span class="p">);</span>	<span class="cm">/* Protect SFBR */</span>
	<span class="n">OUTB</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">nc_ctest3</span><span class="p">,</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">rv_ctest3</span><span class="p">);</span>	<span class="cm">/* Write and invalidate */</span>
	<span class="n">OUTB</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">nc_ctest4</span><span class="p">,</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">rv_ctest4</span><span class="p">);</span>	<span class="cm">/* Master parity checking */</span>

	<span class="cm">/* Extended Sreq/Sack filtering not supported on the C10 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">features</span> <span class="o">&amp;</span> <span class="n">FE_C10</span><span class="p">)</span>
		<span class="n">OUTB</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">nc_stest2</span><span class="p">,</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">rv_stest2</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">OUTB</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">nc_stest2</span><span class="p">,</span> <span class="n">EXT</span><span class="o">|</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">rv_stest2</span><span class="p">);</span>

	<span class="n">OUTB</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">nc_stest3</span><span class="p">,</span> <span class="n">TE</span><span class="p">);</span>			<span class="cm">/* TolerANT enable */</span>
	<span class="n">OUTB</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">nc_stime0</span><span class="p">,</span> <span class="mh">0x0c</span><span class="p">);</span>			<span class="cm">/* HTH disabled  STO 0.25 sec */</span>

	<span class="cm">/*</span>
<span class="cm">	 *  For now, disable AIP generation on C1010-66.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">device</span> <span class="o">==</span> <span class="n">PCI_DEVICE_ID_LSI_53C1010_66</span><span class="p">)</span>
		<span class="n">OUTB</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">nc_aipcntl1</span><span class="p">,</span> <span class="n">DISAIP</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 *  C10101 rev. 0 errata.</span>
<span class="cm">	 *  Errant SGE&#39;s when in narrow. Write bits 4 &amp; 5 of</span>
<span class="cm">	 *  STEST1 register to disable SGE. We probably should do </span>
<span class="cm">	 *  that from SCRIPTS for each selection/reselection, but </span>
<span class="cm">	 *  I just don&#39;t want. :)</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">device</span> <span class="o">==</span> <span class="n">PCI_DEVICE_ID_LSI_53C1010_33</span> <span class="o">&amp;&amp;</span>
	    <span class="n">pdev</span><span class="o">-&gt;</span><span class="n">revision</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">)</span>
		<span class="n">OUTB</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">nc_stest1</span><span class="p">,</span> <span class="n">INB</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">nc_stest1</span><span class="p">)</span> <span class="o">|</span> <span class="mh">0x30</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 *  DEL 441 - 53C876 Rev 5 - Part Number 609-0392787/2788 - ITEM 2.</span>
<span class="cm">	 *  Disable overlapped arbitration for some dual function devices, </span>
<span class="cm">	 *  regardless revision id (kind of post-chip-design feature. ;-))</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">device</span> <span class="o">==</span> <span class="n">PCI_DEVICE_ID_NCR_53C875</span><span class="p">)</span>
		<span class="n">OUTB</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">nc_ctest0</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">5</span><span class="p">));</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">device</span> <span class="o">==</span> <span class="n">PCI_DEVICE_ID_NCR_53C896</span><span class="p">)</span>
		<span class="n">np</span><span class="o">-&gt;</span><span class="n">rv_ccntl0</span> <span class="o">|=</span> <span class="n">DPR</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 *  Write CCNTL0/CCNTL1 for chips capable of 64 bit addressing </span>
<span class="cm">	 *  and/or hardware phase mismatch, since only such chips </span>
<span class="cm">	 *  seem to support those IO registers.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">features</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">FE_DAC</span><span class="o">|</span><span class="n">FE_NOPM</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">OUTB</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">nc_ccntl0</span><span class="p">,</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">rv_ccntl0</span><span class="p">);</span>
		<span class="n">OUTB</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">nc_ccntl1</span><span class="p">,</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">rv_ccntl1</span><span class="p">);</span>
	<span class="p">}</span>

<span class="cp">#if	SYM_CONF_DMA_ADDRESSING_MODE == 2</span>
	<span class="cm">/*</span>
<span class="cm">	 *  Set up scratch C and DRS IO registers to map the 32 bit </span>
<span class="cm">	 *  DMA address range our data structures are located in.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">use_dac</span><span class="p">(</span><span class="n">np</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">np</span><span class="o">-&gt;</span><span class="n">dmap_bah</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>	<span class="cm">/* ??? */</span>
		<span class="n">OUTL</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">nc_scrx</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">dmap_bah</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
		<span class="n">OUTL</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">nc_drs</span><span class="p">,</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">dmap_bah</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
	<span class="p">}</span>
<span class="cp">#endif</span>

	<span class="cm">/*</span>
<span class="cm">	 *  If phase mismatch handled by scripts (895A/896/1010),</span>
<span class="cm">	 *  set PM jump addresses.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">features</span> <span class="o">&amp;</span> <span class="n">FE_NOPM</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">OUTL</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">nc_pmjad1</span><span class="p">,</span> <span class="n">SCRIPTB_BA</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">pm_handle</span><span class="p">));</span>
		<span class="n">OUTL</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">nc_pmjad2</span><span class="p">,</span> <span class="n">SCRIPTB_BA</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">pm_handle</span><span class="p">));</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 *    Enable GPIO0 pin for writing if LED support from SCRIPTS.</span>
<span class="cm">	 *    Also set GPIO5 and clear GPIO6 if hardware LED control.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">features</span> <span class="o">&amp;</span> <span class="n">FE_LED0</span><span class="p">)</span>
		<span class="n">OUTB</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">nc_gpcntl</span><span class="p">,</span> <span class="n">INB</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">nc_gpcntl</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="mh">0x01</span><span class="p">);</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">features</span> <span class="o">&amp;</span> <span class="n">FE_LEDC</span><span class="p">)</span>
		<span class="n">OUTB</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">nc_gpcntl</span><span class="p">,</span> <span class="p">(</span><span class="n">INB</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">nc_gpcntl</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="mh">0x41</span><span class="p">)</span> <span class="o">|</span> <span class="mh">0x20</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 *      enable ints</span>
<span class="cm">	 */</span>
	<span class="n">OUTW</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">nc_sien</span> <span class="p">,</span> <span class="n">STO</span><span class="o">|</span><span class="n">HTH</span><span class="o">|</span><span class="n">MA</span><span class="o">|</span><span class="n">SGE</span><span class="o">|</span><span class="n">UDC</span><span class="o">|</span><span class="n">RST</span><span class="o">|</span><span class="n">PAR</span><span class="p">);</span>
	<span class="n">OUTB</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">nc_dien</span> <span class="p">,</span> <span class="n">MDPE</span><span class="o">|</span><span class="n">BF</span><span class="o">|</span><span class="n">SSI</span><span class="o">|</span><span class="n">SIR</span><span class="o">|</span><span class="n">IID</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 *  For 895/6 enable SBMC interrupt and save current SCSI bus mode.</span>
<span class="cm">	 *  Try to eat the spurious SBMC interrupt that may occur when </span>
<span class="cm">	 *  we reset the chip but not the SCSI BUS (at initialization).</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">features</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">FE_ULTRA2</span><span class="o">|</span><span class="n">FE_ULTRA3</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">OUTONW</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">nc_sien</span><span class="p">,</span> <span class="n">SBMC</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">reason</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">INB</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">nc_mbox1</span><span class="p">);</span>
			<span class="n">mdelay</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span>
			<span class="n">INW</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">nc_sist</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">np</span><span class="o">-&gt;</span><span class="n">scsi_mode</span> <span class="o">=</span> <span class="n">INB</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">nc_stest4</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">SMODE</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 *  Fill in target structure.</span>
<span class="cm">	 *  Reinitialize usrsync.</span>
<span class="cm">	 *  Reinitialize usrwide.</span>
<span class="cm">	 *  Prepare sync negotiation according to actual SCSI bus mode.</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">SYM_CONF_MAX_TARGET</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">sym_tcb</span> <span class="o">*</span><span class="n">tp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">target</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

		<span class="n">tp</span><span class="o">-&gt;</span><span class="n">to_reset</span>  <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">tp</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">.</span><span class="n">sval</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">tp</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">.</span><span class="n">wval</span> <span class="o">=</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">rv_scntl3</span><span class="p">;</span>
		<span class="n">tp</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">.</span><span class="n">uval</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">lun0p</span><span class="p">)</span>
			<span class="n">tp</span><span class="o">-&gt;</span><span class="n">lun0p</span><span class="o">-&gt;</span><span class="n">to_clear</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">lunmp</span><span class="p">)</span> <span class="p">{</span>
			<span class="kt">int</span> <span class="n">ln</span><span class="p">;</span>

			<span class="k">for</span> <span class="p">(</span><span class="n">ln</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">ln</span> <span class="o">&lt;</span> <span class="n">SYM_CONF_MAX_LUN</span><span class="p">;</span> <span class="n">ln</span><span class="o">++</span><span class="p">)</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">lunmp</span><span class="p">[</span><span class="n">ln</span><span class="p">])</span>
					<span class="n">tp</span><span class="o">-&gt;</span><span class="n">lunmp</span><span class="p">[</span><span class="n">ln</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">to_clear</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 *  Download SCSI SCRIPTS to on-chip RAM if present,</span>
<span class="cm">	 *  and start script processor.</span>
<span class="cm">	 *  We do the download preferently from the CPU.</span>
<span class="cm">	 *  For platforms that may not support PCI memory mapping,</span>
<span class="cm">	 *  we use simple SCRIPTS that performs MEMORY MOVEs.</span>
<span class="cm">	 */</span>
	<span class="n">phys</span> <span class="o">=</span> <span class="n">SCRIPTA_BA</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">init</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">ram_ba</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sym_verbose</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">)</span>
			<span class="n">printf</span><span class="p">(</span><span class="s">&quot;%s: Downloading SCSI SCRIPTS.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">sym_name</span><span class="p">(</span><span class="n">np</span><span class="p">));</span>
		<span class="n">memcpy_toio</span><span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">s</span><span class="p">.</span><span class="n">ramaddr</span><span class="p">,</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">scripta0</span><span class="p">,</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">scripta_sz</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">features</span> <span class="o">&amp;</span> <span class="n">FE_RAM8K</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">memcpy_toio</span><span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">s</span><span class="p">.</span><span class="n">ramaddr</span> <span class="o">+</span> <span class="mi">4096</span><span class="p">,</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">scriptb0</span><span class="p">,</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">scriptb_sz</span><span class="p">);</span>
			<span class="n">phys</span> <span class="o">=</span> <span class="n">scr_to_cpu</span><span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">scr_ram_seg</span><span class="p">);</span>
			<span class="n">OUTL</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">nc_mmws</span><span class="p">,</span> <span class="n">phys</span><span class="p">);</span>
			<span class="n">OUTL</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">nc_mmrs</span><span class="p">,</span> <span class="n">phys</span><span class="p">);</span>
			<span class="n">OUTL</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">nc_sfs</span><span class="p">,</span>  <span class="n">phys</span><span class="p">);</span>
			<span class="n">phys</span> <span class="o">=</span> <span class="n">SCRIPTB_BA</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">start64</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">np</span><span class="o">-&gt;</span><span class="n">istat_sem</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">OUTL</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">nc_dsa</span><span class="p">,</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">hcb_ba</span><span class="p">);</span>
	<span class="n">OUTL_DSP</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">phys</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 *  Notify the XPT about the RESET condition.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">reason</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">sym_xpt_async_bus_reset</span><span class="p">(</span><span class="n">np</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *  Switch trans mode for current job and its target.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">sym_settrans</span><span class="p">(</span><span class="k">struct</span> <span class="n">sym_hcb</span> <span class="o">*</span><span class="n">np</span><span class="p">,</span> <span class="kt">int</span> <span class="n">target</span><span class="p">,</span> <span class="n">u_char</span> <span class="n">opts</span><span class="p">,</span> <span class="n">u_char</span> <span class="n">ofs</span><span class="p">,</span>
			 <span class="n">u_char</span> <span class="n">per</span><span class="p">,</span> <span class="n">u_char</span> <span class="n">wide</span><span class="p">,</span> <span class="n">u_char</span> <span class="n">div</span><span class="p">,</span> <span class="n">u_char</span> <span class="n">fak</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">SYM_QUEHEAD</span> <span class="o">*</span><span class="n">qp</span><span class="p">;</span>
	<span class="n">u_char</span> <span class="n">sval</span><span class="p">,</span> <span class="n">wval</span><span class="p">,</span> <span class="n">uval</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sym_tcb</span> <span class="o">*</span><span class="n">tp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">target</span><span class="p">[</span><span class="n">target</span><span class="p">];</span>

	<span class="n">assert</span><span class="p">(</span><span class="n">target</span> <span class="o">==</span> <span class="p">(</span><span class="n">INB</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">nc_sdid</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x0f</span><span class="p">));</span>

	<span class="n">sval</span> <span class="o">=</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">.</span><span class="n">sval</span><span class="p">;</span>
	<span class="n">wval</span> <span class="o">=</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">.</span><span class="n">wval</span><span class="p">;</span>
	<span class="n">uval</span> <span class="o">=</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">.</span><span class="n">uval</span><span class="p">;</span>

<span class="cp">#if 0</span><span class="c"></span>
<span class="c">	printf(&quot;XXXX sval=%x wval=%x uval=%x (%x)\n&quot;, </span>
<span class="c">		sval, wval, uval, np-&gt;rv_scntl3);</span>
<span class="cp">#endif</span>
	<span class="cm">/*</span>
<span class="cm">	 *  Set the offset.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">features</span> <span class="o">&amp;</span> <span class="n">FE_C10</span><span class="p">))</span>
		<span class="n">sval</span> <span class="o">=</span> <span class="p">(</span><span class="n">sval</span> <span class="o">&amp;</span> <span class="o">~</span><span class="mh">0x1f</span><span class="p">)</span> <span class="o">|</span> <span class="n">ofs</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">sval</span> <span class="o">=</span> <span class="p">(</span><span class="n">sval</span> <span class="o">&amp;</span> <span class="o">~</span><span class="mh">0x3f</span><span class="p">)</span> <span class="o">|</span> <span class="n">ofs</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 *  Set the sync divisor and extra clock factor.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ofs</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">wval</span> <span class="o">=</span> <span class="p">(</span><span class="n">wval</span> <span class="o">&amp;</span> <span class="o">~</span><span class="mh">0x70</span><span class="p">)</span> <span class="o">|</span> <span class="p">((</span><span class="n">div</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">4</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">features</span> <span class="o">&amp;</span> <span class="n">FE_C10</span><span class="p">))</span>
			<span class="n">sval</span> <span class="o">=</span> <span class="p">(</span><span class="n">sval</span> <span class="o">&amp;</span> <span class="o">~</span><span class="mh">0xe0</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">fak</span> <span class="o">&lt;&lt;</span> <span class="mi">5</span><span class="p">);</span>
		<span class="k">else</span> <span class="p">{</span>
			<span class="n">uval</span> <span class="o">=</span> <span class="n">uval</span> <span class="o">&amp;</span> <span class="o">~</span><span class="p">(</span><span class="n">XCLKH_ST</span><span class="o">|</span><span class="n">XCLKH_DT</span><span class="o">|</span><span class="n">XCLKS_ST</span><span class="o">|</span><span class="n">XCLKS_DT</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">fak</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">)</span> <span class="n">uval</span> <span class="o">|=</span> <span class="p">(</span><span class="n">XCLKH_ST</span><span class="o">|</span><span class="n">XCLKH_DT</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">fak</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">)</span> <span class="n">uval</span> <span class="o">|=</span> <span class="p">(</span><span class="n">XCLKS_ST</span><span class="o">|</span><span class="n">XCLKS_DT</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 *  Set the bus width.</span>
<span class="cm">	 */</span>
	<span class="n">wval</span> <span class="o">=</span> <span class="n">wval</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">EWS</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">wide</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">wval</span> <span class="o">|=</span> <span class="n">EWS</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 *  Set misc. ultra enable bits.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">features</span> <span class="o">&amp;</span> <span class="n">FE_C10</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">uval</span> <span class="o">=</span> <span class="n">uval</span> <span class="o">&amp;</span> <span class="o">~</span><span class="p">(</span><span class="n">U3EN</span><span class="o">|</span><span class="n">AIPCKEN</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">opts</span><span class="p">)</span>	<span class="p">{</span>
			<span class="n">assert</span><span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">features</span> <span class="o">&amp;</span> <span class="n">FE_U3EN</span><span class="p">);</span>
			<span class="n">uval</span> <span class="o">|=</span> <span class="n">U3EN</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">wval</span> <span class="o">=</span> <span class="n">wval</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">ULTRA</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">per</span> <span class="o">&lt;=</span> <span class="mi">12</span><span class="p">)</span>	<span class="n">wval</span> <span class="o">|=</span> <span class="n">ULTRA</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 *   Stop there if sync parameters are unchanged.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">.</span><span class="n">sval</span> <span class="o">==</span> <span class="n">sval</span> <span class="o">&amp;&amp;</span> 
	    <span class="n">tp</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">.</span><span class="n">wval</span> <span class="o">==</span> <span class="n">wval</span> <span class="o">&amp;&amp;</span>
	    <span class="n">tp</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">.</span><span class="n">uval</span> <span class="o">==</span> <span class="n">uval</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">tp</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">.</span><span class="n">sval</span> <span class="o">=</span> <span class="n">sval</span><span class="p">;</span>
	<span class="n">tp</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">.</span><span class="n">wval</span> <span class="o">=</span> <span class="n">wval</span><span class="p">;</span>
	<span class="n">tp</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">.</span><span class="n">uval</span> <span class="o">=</span> <span class="n">uval</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 *  Disable extended Sreq/Sack filtering if per &lt; 50.</span>
<span class="cm">	 *  Not supported on the C1010.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">per</span> <span class="o">&lt;</span> <span class="mi">50</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">features</span> <span class="o">&amp;</span> <span class="n">FE_C10</span><span class="p">))</span>
		<span class="n">OUTOFFB</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">nc_stest2</span><span class="p">,</span> <span class="n">EXT</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 *  set actual value and sync_status</span>
<span class="cm">	 */</span>
	<span class="n">OUTB</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">nc_sxfer</span><span class="p">,</span>  <span class="n">tp</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">.</span><span class="n">sval</span><span class="p">);</span>
	<span class="n">OUTB</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">nc_scntl3</span><span class="p">,</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">.</span><span class="n">wval</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">features</span> <span class="o">&amp;</span> <span class="n">FE_C10</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">OUTB</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">nc_scntl4</span><span class="p">,</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">.</span><span class="n">uval</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 *  patch ALL busy ccbs of this target.</span>
<span class="cm">	 */</span>
	<span class="n">FOR_EACH_QUEUED_ELEMENT</span><span class="p">(</span><span class="o">&amp;</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">busy_ccbq</span><span class="p">,</span> <span class="n">qp</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">sym_ccb</span> <span class="o">*</span><span class="n">cp</span><span class="p">;</span>
		<span class="n">cp</span> <span class="o">=</span> <span class="n">sym_que_entry</span><span class="p">(</span><span class="n">qp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sym_ccb</span><span class="p">,</span> <span class="n">link_ccbq</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">target</span> <span class="o">!=</span> <span class="n">target</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="n">cp</span><span class="o">-&gt;</span><span class="n">phys</span><span class="p">.</span><span class="n">select</span><span class="p">.</span><span class="n">sel_scntl3</span> <span class="o">=</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">.</span><span class="n">wval</span><span class="p">;</span>
		<span class="n">cp</span><span class="o">-&gt;</span><span class="n">phys</span><span class="p">.</span><span class="n">select</span><span class="p">.</span><span class="n">sel_sxfer</span>  <span class="o">=</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">.</span><span class="n">sval</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">features</span> <span class="o">&amp;</span> <span class="n">FE_C10</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">cp</span><span class="o">-&gt;</span><span class="n">phys</span><span class="p">.</span><span class="n">select</span><span class="p">.</span><span class="n">sel_scntl4</span> <span class="o">=</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">.</span><span class="n">uval</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">sym_announce_transfer_rate</span><span class="p">(</span><span class="k">struct</span> <span class="n">sym_tcb</span> <span class="o">*</span><span class="n">tp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">scsi_target</span> <span class="o">*</span><span class="n">starget</span> <span class="o">=</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">starget</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">tprint</span><span class="p">.</span><span class="n">period</span> <span class="o">!=</span> <span class="n">spi_period</span><span class="p">(</span><span class="n">starget</span><span class="p">)</span> <span class="o">||</span>
	    <span class="n">tp</span><span class="o">-&gt;</span><span class="n">tprint</span><span class="p">.</span><span class="n">offset</span> <span class="o">!=</span> <span class="n">spi_offset</span><span class="p">(</span><span class="n">starget</span><span class="p">)</span> <span class="o">||</span>
	    <span class="n">tp</span><span class="o">-&gt;</span><span class="n">tprint</span><span class="p">.</span><span class="n">width</span> <span class="o">!=</span> <span class="n">spi_width</span><span class="p">(</span><span class="n">starget</span><span class="p">)</span> <span class="o">||</span>
	    <span class="n">tp</span><span class="o">-&gt;</span><span class="n">tprint</span><span class="p">.</span><span class="n">iu</span> <span class="o">!=</span> <span class="n">spi_iu</span><span class="p">(</span><span class="n">starget</span><span class="p">)</span> <span class="o">||</span>
	    <span class="n">tp</span><span class="o">-&gt;</span><span class="n">tprint</span><span class="p">.</span><span class="n">dt</span> <span class="o">!=</span> <span class="n">spi_dt</span><span class="p">(</span><span class="n">starget</span><span class="p">)</span> <span class="o">||</span>
	    <span class="n">tp</span><span class="o">-&gt;</span><span class="n">tprint</span><span class="p">.</span><span class="n">qas</span> <span class="o">!=</span> <span class="n">spi_qas</span><span class="p">(</span><span class="n">starget</span><span class="p">)</span> <span class="o">||</span>
	    <span class="o">!</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">tprint</span><span class="p">.</span><span class="n">check_nego</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">tp</span><span class="o">-&gt;</span><span class="n">tprint</span><span class="p">.</span><span class="n">period</span> <span class="o">=</span> <span class="n">spi_period</span><span class="p">(</span><span class="n">starget</span><span class="p">);</span>
		<span class="n">tp</span><span class="o">-&gt;</span><span class="n">tprint</span><span class="p">.</span><span class="n">offset</span> <span class="o">=</span> <span class="n">spi_offset</span><span class="p">(</span><span class="n">starget</span><span class="p">);</span>
		<span class="n">tp</span><span class="o">-&gt;</span><span class="n">tprint</span><span class="p">.</span><span class="n">width</span> <span class="o">=</span> <span class="n">spi_width</span><span class="p">(</span><span class="n">starget</span><span class="p">);</span>
		<span class="n">tp</span><span class="o">-&gt;</span><span class="n">tprint</span><span class="p">.</span><span class="n">iu</span> <span class="o">=</span> <span class="n">spi_iu</span><span class="p">(</span><span class="n">starget</span><span class="p">);</span>
		<span class="n">tp</span><span class="o">-&gt;</span><span class="n">tprint</span><span class="p">.</span><span class="n">dt</span> <span class="o">=</span> <span class="n">spi_dt</span><span class="p">(</span><span class="n">starget</span><span class="p">);</span>
		<span class="n">tp</span><span class="o">-&gt;</span><span class="n">tprint</span><span class="p">.</span><span class="n">qas</span> <span class="o">=</span> <span class="n">spi_qas</span><span class="p">(</span><span class="n">starget</span><span class="p">);</span>
		<span class="n">tp</span><span class="o">-&gt;</span><span class="n">tprint</span><span class="p">.</span><span class="n">check_nego</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

		<span class="n">spi_display_xfer_agreement</span><span class="p">(</span><span class="n">starget</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *  We received a WDTR.</span>
<span class="cm"> *  Let everything be aware of the changes.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">sym_setwide</span><span class="p">(</span><span class="k">struct</span> <span class="n">sym_hcb</span> <span class="o">*</span><span class="n">np</span><span class="p">,</span> <span class="kt">int</span> <span class="n">target</span><span class="p">,</span> <span class="n">u_char</span> <span class="n">wide</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sym_tcb</span> <span class="o">*</span><span class="n">tp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">target</span><span class="p">[</span><span class="n">target</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">scsi_target</span> <span class="o">*</span><span class="n">starget</span> <span class="o">=</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">starget</span><span class="p">;</span>

	<span class="n">sym_settrans</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">wide</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">wide</span><span class="p">)</span>
		<span class="n">tp</span><span class="o">-&gt;</span><span class="n">tgoal</span><span class="p">.</span><span class="n">renego</span> <span class="o">=</span> <span class="n">NS_WIDE</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">tp</span><span class="o">-&gt;</span><span class="n">tgoal</span><span class="p">.</span><span class="n">renego</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">tp</span><span class="o">-&gt;</span><span class="n">tgoal</span><span class="p">.</span><span class="n">check_nego</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">tp</span><span class="o">-&gt;</span><span class="n">tgoal</span><span class="p">.</span><span class="n">width</span> <span class="o">=</span> <span class="n">wide</span><span class="p">;</span>
	<span class="n">spi_offset</span><span class="p">(</span><span class="n">starget</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">spi_period</span><span class="p">(</span><span class="n">starget</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">spi_width</span><span class="p">(</span><span class="n">starget</span><span class="p">)</span> <span class="o">=</span> <span class="n">wide</span><span class="p">;</span>
	<span class="n">spi_iu</span><span class="p">(</span><span class="n">starget</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">spi_dt</span><span class="p">(</span><span class="n">starget</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">spi_qas</span><span class="p">(</span><span class="n">starget</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sym_verbose</span> <span class="o">&gt;=</span> <span class="mi">3</span><span class="p">)</span>
		<span class="n">sym_announce_transfer_rate</span><span class="p">(</span><span class="n">tp</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *  We received a SDTR.</span>
<span class="cm"> *  Let everything be aware of the changes.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="n">sym_setsync</span><span class="p">(</span><span class="k">struct</span> <span class="n">sym_hcb</span> <span class="o">*</span><span class="n">np</span><span class="p">,</span> <span class="kt">int</span> <span class="n">target</span><span class="p">,</span>
            <span class="n">u_char</span> <span class="n">ofs</span><span class="p">,</span> <span class="n">u_char</span> <span class="n">per</span><span class="p">,</span> <span class="n">u_char</span> <span class="n">div</span><span class="p">,</span> <span class="n">u_char</span> <span class="n">fak</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sym_tcb</span> <span class="o">*</span><span class="n">tp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">target</span><span class="p">[</span><span class="n">target</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">scsi_target</span> <span class="o">*</span><span class="n">starget</span> <span class="o">=</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">starget</span><span class="p">;</span>
	<span class="n">u_char</span> <span class="n">wide</span> <span class="o">=</span> <span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">.</span><span class="n">wval</span> <span class="o">&amp;</span> <span class="n">EWS</span><span class="p">)</span> <span class="o">?</span> <span class="n">BUS_16_BIT</span> <span class="o">:</span> <span class="n">BUS_8_BIT</span><span class="p">;</span>

	<span class="n">sym_settrans</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">ofs</span><span class="p">,</span> <span class="n">per</span><span class="p">,</span> <span class="n">wide</span><span class="p">,</span> <span class="n">div</span><span class="p">,</span> <span class="n">fak</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">wide</span><span class="p">)</span>
		<span class="n">tp</span><span class="o">-&gt;</span><span class="n">tgoal</span><span class="p">.</span><span class="n">renego</span> <span class="o">=</span> <span class="n">NS_WIDE</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">ofs</span><span class="p">)</span>
		<span class="n">tp</span><span class="o">-&gt;</span><span class="n">tgoal</span><span class="p">.</span><span class="n">renego</span> <span class="o">=</span> <span class="n">NS_SYNC</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">tp</span><span class="o">-&gt;</span><span class="n">tgoal</span><span class="p">.</span><span class="n">renego</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">spi_period</span><span class="p">(</span><span class="n">starget</span><span class="p">)</span> <span class="o">=</span> <span class="n">per</span><span class="p">;</span>
	<span class="n">spi_offset</span><span class="p">(</span><span class="n">starget</span><span class="p">)</span> <span class="o">=</span> <span class="n">ofs</span><span class="p">;</span>
	<span class="n">spi_iu</span><span class="p">(</span><span class="n">starget</span><span class="p">)</span> <span class="o">=</span> <span class="n">spi_dt</span><span class="p">(</span><span class="n">starget</span><span class="p">)</span> <span class="o">=</span> <span class="n">spi_qas</span><span class="p">(</span><span class="n">starget</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">tgoal</span><span class="p">.</span><span class="n">dt</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">tgoal</span><span class="p">.</span><span class="n">iu</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">tgoal</span><span class="p">.</span><span class="n">qas</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">tp</span><span class="o">-&gt;</span><span class="n">tgoal</span><span class="p">.</span><span class="n">period</span> <span class="o">=</span> <span class="n">per</span><span class="p">;</span>
		<span class="n">tp</span><span class="o">-&gt;</span><span class="n">tgoal</span><span class="p">.</span><span class="n">offset</span> <span class="o">=</span> <span class="n">ofs</span><span class="p">;</span>
		<span class="n">tp</span><span class="o">-&gt;</span><span class="n">tgoal</span><span class="p">.</span><span class="n">check_nego</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">sym_announce_transfer_rate</span><span class="p">(</span><span class="n">tp</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *  We received a PPR.</span>
<span class="cm"> *  Let everything be aware of the changes.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> 
<span class="n">sym_setpprot</span><span class="p">(</span><span class="k">struct</span> <span class="n">sym_hcb</span> <span class="o">*</span><span class="n">np</span><span class="p">,</span> <span class="kt">int</span> <span class="n">target</span><span class="p">,</span> <span class="n">u_char</span> <span class="n">opts</span><span class="p">,</span> <span class="n">u_char</span> <span class="n">ofs</span><span class="p">,</span>
             <span class="n">u_char</span> <span class="n">per</span><span class="p">,</span> <span class="n">u_char</span> <span class="n">wide</span><span class="p">,</span> <span class="n">u_char</span> <span class="n">div</span><span class="p">,</span> <span class="n">u_char</span> <span class="n">fak</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sym_tcb</span> <span class="o">*</span><span class="n">tp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">target</span><span class="p">[</span><span class="n">target</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">scsi_target</span> <span class="o">*</span><span class="n">starget</span> <span class="o">=</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">starget</span><span class="p">;</span>

	<span class="n">sym_settrans</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">opts</span><span class="p">,</span> <span class="n">ofs</span><span class="p">,</span> <span class="n">per</span><span class="p">,</span> <span class="n">wide</span><span class="p">,</span> <span class="n">div</span><span class="p">,</span> <span class="n">fak</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">wide</span> <span class="o">||</span> <span class="n">ofs</span><span class="p">)</span>
		<span class="n">tp</span><span class="o">-&gt;</span><span class="n">tgoal</span><span class="p">.</span><span class="n">renego</span> <span class="o">=</span> <span class="n">NS_PPR</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">tp</span><span class="o">-&gt;</span><span class="n">tgoal</span><span class="p">.</span><span class="n">renego</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">spi_width</span><span class="p">(</span><span class="n">starget</span><span class="p">)</span> <span class="o">=</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">tgoal</span><span class="p">.</span><span class="n">width</span> <span class="o">=</span> <span class="n">wide</span><span class="p">;</span>
	<span class="n">spi_period</span><span class="p">(</span><span class="n">starget</span><span class="p">)</span> <span class="o">=</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">tgoal</span><span class="p">.</span><span class="n">period</span> <span class="o">=</span> <span class="n">per</span><span class="p">;</span>
	<span class="n">spi_offset</span><span class="p">(</span><span class="n">starget</span><span class="p">)</span> <span class="o">=</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">tgoal</span><span class="p">.</span><span class="n">offset</span> <span class="o">=</span> <span class="n">ofs</span><span class="p">;</span>
	<span class="n">spi_iu</span><span class="p">(</span><span class="n">starget</span><span class="p">)</span> <span class="o">=</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">tgoal</span><span class="p">.</span><span class="n">iu</span> <span class="o">=</span> <span class="o">!!</span><span class="p">(</span><span class="n">opts</span> <span class="o">&amp;</span> <span class="n">PPR_OPT_IU</span><span class="p">);</span>
	<span class="n">spi_dt</span><span class="p">(</span><span class="n">starget</span><span class="p">)</span> <span class="o">=</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">tgoal</span><span class="p">.</span><span class="n">dt</span> <span class="o">=</span> <span class="o">!!</span><span class="p">(</span><span class="n">opts</span> <span class="o">&amp;</span> <span class="n">PPR_OPT_DT</span><span class="p">);</span>
	<span class="n">spi_qas</span><span class="p">(</span><span class="n">starget</span><span class="p">)</span> <span class="o">=</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">tgoal</span><span class="p">.</span><span class="n">qas</span> <span class="o">=</span> <span class="o">!!</span><span class="p">(</span><span class="n">opts</span> <span class="o">&amp;</span> <span class="n">PPR_OPT_QAS</span><span class="p">);</span>
	<span class="n">tp</span><span class="o">-&gt;</span><span class="n">tgoal</span><span class="p">.</span><span class="n">check_nego</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">sym_announce_transfer_rate</span><span class="p">(</span><span class="n">tp</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *  generic recovery from scsi interrupt</span>
<span class="cm"> *</span>
<span class="cm"> *  The doc says that when the chip gets an SCSI interrupt,</span>
<span class="cm"> *  it tries to stop in an orderly fashion, by completing </span>
<span class="cm"> *  an instruction fetch that had started or by flushing </span>
<span class="cm"> *  the DMA fifo for a write to memory that was executing.</span>
<span class="cm"> *  Such a fashion is not enough to know if the instruction </span>
<span class="cm"> *  that was just before the current DSP value has been </span>
<span class="cm"> *  executed or not.</span>
<span class="cm"> *</span>
<span class="cm"> *  There are some small SCRIPTS sections that deal with </span>
<span class="cm"> *  the start queue and the done queue that may break any </span>
<span class="cm"> *  assomption from the C code if we are interrupted </span>
<span class="cm"> *  inside, so we reset if this happens. Btw, since these </span>
<span class="cm"> *  SCRIPTS sections are executed while the SCRIPTS hasn&#39;t </span>
<span class="cm"> *  started SCSI operations, it is very unlikely to happen.</span>
<span class="cm"> *</span>
<span class="cm"> *  All the driver data structures are supposed to be </span>
<span class="cm"> *  allocated from the same 4 GB memory window, so there </span>
<span class="cm"> *  is a 1 to 1 relationship between DSA and driver data </span>
<span class="cm"> *  structures. Since we are careful :) to invalidate the </span>
<span class="cm"> *  DSA when we complete a command or when the SCRIPTS </span>
<span class="cm"> *  pushes a DSA into a queue, we can trust it when it </span>
<span class="cm"> *  points to a CCB.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">sym_recover_scsi_int</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sym_hcb</span> <span class="o">*</span><span class="n">np</span><span class="p">,</span> <span class="n">u_char</span> <span class="n">hsts</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span>	<span class="n">dsp</span>	<span class="o">=</span> <span class="n">INL</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">nc_dsp</span><span class="p">);</span>
	<span class="n">u32</span>	<span class="n">dsa</span>	<span class="o">=</span> <span class="n">INL</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">nc_dsa</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">sym_ccb</span> <span class="o">*</span><span class="n">cp</span>	<span class="o">=</span> <span class="n">sym_ccb_from_dsa</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">dsa</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 *  If we haven&#39;t been interrupted inside the SCRIPTS </span>
<span class="cm">	 *  critical pathes, we can safely restart the SCRIPTS </span>
<span class="cm">	 *  and trust the DSA value if it matches a CCB.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="o">!</span><span class="p">(</span><span class="n">dsp</span> <span class="o">&gt;</span> <span class="n">SCRIPTA_BA</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">getjob_begin</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	       <span class="n">dsp</span> <span class="o">&lt;</span> <span class="n">SCRIPTA_BA</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">getjob_end</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">dsp</span> <span class="o">&gt;</span> <span class="n">SCRIPTA_BA</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">ungetjob</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	       <span class="n">dsp</span> <span class="o">&lt;</span> <span class="n">SCRIPTA_BA</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">reselect</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">dsp</span> <span class="o">&gt;</span> <span class="n">SCRIPTB_BA</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">sel_for_abort</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	       <span class="n">dsp</span> <span class="o">&lt;</span> <span class="n">SCRIPTB_BA</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">sel_for_abort_1</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">dsp</span> <span class="o">&gt;</span> <span class="n">SCRIPTA_BA</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">done</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	       <span class="n">dsp</span> <span class="o">&lt;</span> <span class="n">SCRIPTA_BA</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">done_end</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">OUTB</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">nc_ctest3</span><span class="p">,</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">rv_ctest3</span> <span class="o">|</span> <span class="n">CLF</span><span class="p">);</span> <span class="cm">/* clear dma fifo  */</span>
		<span class="n">OUTB</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">nc_stest3</span><span class="p">,</span> <span class="n">TE</span><span class="o">|</span><span class="n">CSF</span><span class="p">);</span>		<span class="cm">/* clear scsi fifo */</span>
		<span class="cm">/*</span>
<span class="cm">		 *  If we have a CCB, let the SCRIPTS call us back for </span>
<span class="cm">		 *  the handling of the error with SCRATCHA filled with </span>
<span class="cm">		 *  STARTPOS. This way, we will be able to freeze the </span>
<span class="cm">		 *  device queue and requeue awaiting IOs.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cp</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">cp</span><span class="o">-&gt;</span><span class="n">host_status</span> <span class="o">=</span> <span class="n">hsts</span><span class="p">;</span>
			<span class="n">OUTL_DSP</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">SCRIPTA_BA</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">complete_error</span><span class="p">));</span>
		<span class="p">}</span>
		<span class="cm">/*</span>
<span class="cm">		 *  Otherwise just restart the SCRIPTS.</span>
<span class="cm">		 */</span>
		<span class="k">else</span> <span class="p">{</span>
			<span class="n">OUTL</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">nc_dsa</span><span class="p">,</span> <span class="mh">0xffffff</span><span class="p">);</span>
			<span class="n">OUTL_DSP</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">SCRIPTA_BA</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">start</span><span class="p">));</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">else</span>
		<span class="k">goto</span> <span class="n">reset_all</span><span class="p">;</span>

	<span class="k">return</span><span class="p">;</span>

<span class="nl">reset_all:</span>
	<span class="n">sym_start_reset</span><span class="p">(</span><span class="n">np</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *  chip exception handler for selection timeout</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">sym_int_sto</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sym_hcb</span> <span class="o">*</span><span class="n">np</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">dsp</span>	<span class="o">=</span> <span class="n">INL</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">nc_dsp</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">DEBUG_FLAGS</span> <span class="o">&amp;</span> <span class="n">DEBUG_TINY</span><span class="p">)</span> <span class="n">printf</span> <span class="p">(</span><span class="s">&quot;T&quot;</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dsp</span> <span class="o">==</span> <span class="n">SCRIPTA_BA</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">wf_sel_done</span><span class="p">)</span> <span class="o">+</span> <span class="mi">8</span><span class="p">)</span>
		<span class="n">sym_recover_scsi_int</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">HS_SEL_TIMEOUT</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">sym_start_reset</span><span class="p">(</span><span class="n">np</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *  chip exception handler for unexpected disconnect</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">sym_int_udc</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sym_hcb</span> <span class="o">*</span><span class="n">np</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">printf</span> <span class="p">(</span><span class="s">&quot;%s: unexpected disconnect</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">sym_name</span><span class="p">(</span><span class="n">np</span><span class="p">));</span>
	<span class="n">sym_recover_scsi_int</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">HS_UNEXPECTED</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *  chip exception handler for SCSI bus mode change</span>
<span class="cm"> *</span>
<span class="cm"> *  spi2-r12 11.2.3 says a transceiver mode change must </span>
<span class="cm"> *  generate a reset event and a device that detects a reset </span>
<span class="cm"> *  event shall initiate a hard reset. It says also that a</span>
<span class="cm"> *  device that detects a mode change shall set data transfer </span>
<span class="cm"> *  mode to eight bit asynchronous, etc...</span>
<span class="cm"> *  So, just reinitializing all except chip should be enough.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">sym_int_sbmc</span><span class="p">(</span><span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sym_hcb</span> <span class="o">*</span><span class="n">np</span> <span class="o">=</span> <span class="n">sym_get_hcb</span><span class="p">(</span><span class="n">shost</span><span class="p">);</span>
	<span class="n">u_char</span> <span class="n">scsi_mode</span> <span class="o">=</span> <span class="n">INB</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">nc_stest4</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">SMODE</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 *  Notify user.</span>
<span class="cm">	 */</span>
	<span class="n">printf</span><span class="p">(</span><span class="s">&quot;%s: SCSI BUS mode change from %s to %s.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">sym_name</span><span class="p">(</span><span class="n">np</span><span class="p">),</span>
		<span class="n">sym_scsi_bus_mode</span><span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">scsi_mode</span><span class="p">),</span> <span class="n">sym_scsi_bus_mode</span><span class="p">(</span><span class="n">scsi_mode</span><span class="p">));</span>

	<span class="cm">/*</span>
<span class="cm">	 *  Should suspend command processing for a few seconds and </span>
<span class="cm">	 *  reinitialize all except the chip.</span>
<span class="cm">	 */</span>
	<span class="n">sym_start_up</span><span class="p">(</span><span class="n">shost</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *  chip exception handler for SCSI parity error.</span>
<span class="cm"> *</span>
<span class="cm"> *  When the chip detects a SCSI parity error and is </span>
<span class="cm"> *  currently executing a (CH)MOV instruction, it does </span>
<span class="cm"> *  not interrupt immediately, but tries to finish the </span>
<span class="cm"> *  transfer of the current scatter entry before </span>
<span class="cm"> *  interrupting. The following situations may occur:</span>
<span class="cm"> *</span>
<span class="cm"> *  - The complete scatter entry has been transferred </span>
<span class="cm"> *    without the device having changed phase.</span>
<span class="cm"> *    The chip will then interrupt with the DSP pointing </span>
<span class="cm"> *    to the instruction that follows the MOV.</span>
<span class="cm"> *</span>
<span class="cm"> *  - A phase mismatch occurs before the MOV finished </span>
<span class="cm"> *    and phase errors are to be handled by the C code.</span>
<span class="cm"> *    The chip will then interrupt with both PAR and MA </span>
<span class="cm"> *    conditions set.</span>
<span class="cm"> *</span>
<span class="cm"> *  - A phase mismatch occurs before the MOV finished and </span>
<span class="cm"> *    phase errors are to be handled by SCRIPTS.</span>
<span class="cm"> *    The chip will load the DSP with the phase mismatch </span>
<span class="cm"> *    JUMP address and interrupt the host processor.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">sym_int_par</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sym_hcb</span> <span class="o">*</span><span class="n">np</span><span class="p">,</span> <span class="n">u_short</span> <span class="n">sist</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u_char</span>	<span class="n">hsts</span>	<span class="o">=</span> <span class="n">INB</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">HS_PRT</span><span class="p">);</span>
	<span class="n">u32</span>	<span class="n">dsp</span>	<span class="o">=</span> <span class="n">INL</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">nc_dsp</span><span class="p">);</span>
	<span class="n">u32</span>	<span class="n">dbc</span>	<span class="o">=</span> <span class="n">INL</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">nc_dbc</span><span class="p">);</span>
	<span class="n">u32</span>	<span class="n">dsa</span>	<span class="o">=</span> <span class="n">INL</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">nc_dsa</span><span class="p">);</span>
	<span class="n">u_char</span>	<span class="n">sbcl</span>	<span class="o">=</span> <span class="n">INB</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">nc_sbcl</span><span class="p">);</span>
	<span class="n">u_char</span>	<span class="n">cmd</span>	<span class="o">=</span> <span class="n">dbc</span> <span class="o">&gt;&gt;</span> <span class="mi">24</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">phase</span>	<span class="o">=</span> <span class="n">cmd</span> <span class="o">&amp;</span> <span class="mi">7</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sym_ccb</span> <span class="o">*</span><span class="n">cp</span>	<span class="o">=</span> <span class="n">sym_ccb_from_dsa</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">dsa</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">printk_ratelimit</span><span class="p">())</span>
		<span class="n">printf</span><span class="p">(</span><span class="s">&quot;%s: SCSI parity error detected: SCR1=%d DBC=%x SBCL=%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">sym_name</span><span class="p">(</span><span class="n">np</span><span class="p">),</span> <span class="n">hsts</span><span class="p">,</span> <span class="n">dbc</span><span class="p">,</span> <span class="n">sbcl</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 *  Check that the chip is connected to the SCSI BUS.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">INB</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">nc_scntl1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">ISCON</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">sym_recover_scsi_int</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">HS_UNEXPECTED</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 *  If the nexus is not clearly identified, reset the bus.</span>
<span class="cm">	 *  We will try to do better later.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cp</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">reset_all</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 *  Check instruction was a MOV, direction was INPUT and </span>
<span class="cm">	 *  ATN is asserted.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">cmd</span> <span class="o">&amp;</span> <span class="mh">0xc0</span><span class="p">)</span> <span class="o">||</span> <span class="o">!</span><span class="p">(</span><span class="n">phase</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">||</span> <span class="o">!</span><span class="p">(</span><span class="n">sbcl</span> <span class="o">&amp;</span> <span class="mh">0x8</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">reset_all</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 *  Keep track of the parity error.</span>
<span class="cm">	 */</span>
	<span class="n">OUTONB</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">HF_PRT</span><span class="p">,</span> <span class="n">HF_EXT_ERR</span><span class="p">);</span>
	<span class="n">cp</span><span class="o">-&gt;</span><span class="n">xerr_status</span> <span class="o">|=</span> <span class="n">XE_PARITY_ERR</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 *  Prepare the message to send to the device.</span>
<span class="cm">	 */</span>
	<span class="n">np</span><span class="o">-&gt;</span><span class="n">msgout</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">phase</span> <span class="o">==</span> <span class="mi">7</span><span class="p">)</span> <span class="o">?</span> <span class="n">M_PARITY</span> <span class="o">:</span> <span class="n">M_ID_ERROR</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 *  If the old phase was DATA IN phase, we have to deal with</span>
<span class="cm">	 *  the 3 situations described above.</span>
<span class="cm">	 *  For other input phases (MSG IN and STATUS), the device </span>
<span class="cm">	 *  must resend the whole thing that failed parity checking </span>
<span class="cm">	 *  or signal error. So, jumping to dispatcher should be OK.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">phase</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">||</span> <span class="n">phase</span> <span class="o">==</span> <span class="mi">5</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Phase mismatch handled by SCRIPTS */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dsp</span> <span class="o">==</span> <span class="n">SCRIPTB_BA</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">pm_handle</span><span class="p">))</span>
			<span class="n">OUTL_DSP</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">dsp</span><span class="p">);</span>
		<span class="cm">/* Phase mismatch handled by the C code */</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">sist</span> <span class="o">&amp;</span> <span class="n">MA</span><span class="p">)</span>
			<span class="n">sym_int_ma</span> <span class="p">(</span><span class="n">np</span><span class="p">);</span>
		<span class="cm">/* No phase mismatch occurred */</span>
		<span class="k">else</span> <span class="p">{</span>
			<span class="n">sym_set_script_dp</span> <span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">cp</span><span class="p">,</span> <span class="n">dsp</span><span class="p">);</span>
			<span class="n">OUTL_DSP</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">SCRIPTA_BA</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">dispatch</span><span class="p">));</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">phase</span> <span class="o">==</span> <span class="mi">7</span><span class="p">)</span>	<span class="cm">/* We definitely cannot handle parity errors */</span>
<span class="cp">#if 1				</span><span class="cm">/* in message-in phase due to the relection  */</span><span class="cp"></span>
		<span class="k">goto</span> <span class="n">reset_all</span><span class="p">;</span> <span class="cm">/* path and various message anticipations.   */</span>
<span class="cp">#else</span>
		<span class="n">OUTL_DSP</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">SCRIPTA_BA</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">clrack</span><span class="p">));</span>
<span class="cp">#endif</span>
	<span class="k">else</span>
		<span class="n">OUTL_DSP</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">SCRIPTA_BA</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">dispatch</span><span class="p">));</span>
	<span class="k">return</span><span class="p">;</span>

<span class="nl">reset_all:</span>
	<span class="n">sym_start_reset</span><span class="p">(</span><span class="n">np</span><span class="p">);</span>
	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *  chip exception handler for phase errors.</span>
<span class="cm"> *</span>
<span class="cm"> *  We have to construct a new transfer descriptor,</span>
<span class="cm"> *  to transfer the rest of the current block.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">sym_int_ma</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sym_hcb</span> <span class="o">*</span><span class="n">np</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span>	<span class="n">dbc</span><span class="p">;</span>
	<span class="n">u32</span>	<span class="n">rest</span><span class="p">;</span>
	<span class="n">u32</span>	<span class="n">dsp</span><span class="p">;</span>
	<span class="n">u32</span>	<span class="n">dsa</span><span class="p">;</span>
	<span class="n">u32</span>	<span class="n">nxtdsp</span><span class="p">;</span>
	<span class="n">u32</span>	<span class="o">*</span><span class="n">vdsp</span><span class="p">;</span>
	<span class="n">u32</span>	<span class="n">oadr</span><span class="p">,</span> <span class="n">olen</span><span class="p">;</span>
	<span class="n">u32</span>	<span class="o">*</span><span class="n">tblp</span><span class="p">;</span>
        <span class="n">u32</span>	<span class="n">newcmd</span><span class="p">;</span>
	<span class="n">u_int</span>	<span class="n">delta</span><span class="p">;</span>
	<span class="n">u_char</span>	<span class="n">cmd</span><span class="p">;</span>
	<span class="n">u_char</span>	<span class="n">hflags</span><span class="p">,</span> <span class="n">hflags0</span><span class="p">;</span>
	<span class="k">struct</span>	<span class="n">sym_pmc</span> <span class="o">*</span><span class="n">pm</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sym_ccb</span> <span class="o">*</span><span class="n">cp</span><span class="p">;</span>

	<span class="n">dsp</span>	<span class="o">=</span> <span class="n">INL</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">nc_dsp</span><span class="p">);</span>
	<span class="n">dbc</span>	<span class="o">=</span> <span class="n">INL</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">nc_dbc</span><span class="p">);</span>
	<span class="n">dsa</span>	<span class="o">=</span> <span class="n">INL</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">nc_dsa</span><span class="p">);</span>

	<span class="n">cmd</span>	<span class="o">=</span> <span class="n">dbc</span> <span class="o">&gt;&gt;</span> <span class="mi">24</span><span class="p">;</span>
	<span class="n">rest</span>	<span class="o">=</span> <span class="n">dbc</span> <span class="o">&amp;</span> <span class="mh">0xffffff</span><span class="p">;</span>
	<span class="n">delta</span>	<span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 *  locate matching cp if any.</span>
<span class="cm">	 */</span>
	<span class="n">cp</span> <span class="o">=</span> <span class="n">sym_ccb_from_dsa</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">dsa</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 *  Donnot take into account dma fifo and various buffers in </span>
<span class="cm">	 *  INPUT phase since the chip flushes everything before </span>
<span class="cm">	 *  raising the MA interrupt for interrupted INPUT phases.</span>
<span class="cm">	 *  For DATA IN phase, we will check for the SWIDE later.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">cmd</span> <span class="o">&amp;</span> <span class="mi">7</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">cmd</span> <span class="o">&amp;</span> <span class="mi">7</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">5</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">u_char</span> <span class="n">ss0</span><span class="p">,</span> <span class="n">ss2</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">features</span> <span class="o">&amp;</span> <span class="n">FE_DFBC</span><span class="p">)</span>
			<span class="n">delta</span> <span class="o">=</span> <span class="n">INW</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">nc_dfbc</span><span class="p">);</span>
		<span class="k">else</span> <span class="p">{</span>
			<span class="n">u32</span> <span class="n">dfifo</span><span class="p">;</span>

			<span class="cm">/*</span>
<span class="cm">			 * Read DFIFO, CTEST[4-6] using 1 PCI bus ownership.</span>
<span class="cm">			 */</span>
			<span class="n">dfifo</span> <span class="o">=</span> <span class="n">INL</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">nc_dfifo</span><span class="p">);</span>

			<span class="cm">/*</span>
<span class="cm">			 *  Calculate remaining bytes in DMA fifo.</span>
<span class="cm">			 *  (CTEST5 = dfifo &gt;&gt; 16)</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">dfifo</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">DFS</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">))</span>
				<span class="n">delta</span> <span class="o">=</span> <span class="p">((((</span><span class="n">dfifo</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x300</span><span class="p">)</span> <span class="o">|</span>
				          <span class="p">(</span><span class="n">dfifo</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">))</span> <span class="o">-</span> <span class="n">rest</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x3ff</span><span class="p">;</span>
			<span class="k">else</span>
				<span class="n">delta</span> <span class="o">=</span> <span class="p">((</span><span class="n">dfifo</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">)</span> <span class="o">-</span> <span class="n">rest</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x7f</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 *  The data in the dma fifo has not been transferred to</span>
<span class="cm">		 *  the target -&gt; add the amount to the rest</span>
<span class="cm">		 *  and clear the data.</span>
<span class="cm">		 *  Check the sstat2 register in case of wide transfer.</span>
<span class="cm">		 */</span>
		<span class="n">rest</span> <span class="o">+=</span> <span class="n">delta</span><span class="p">;</span>
		<span class="n">ss0</span>  <span class="o">=</span> <span class="n">INB</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">nc_sstat0</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ss0</span> <span class="o">&amp;</span> <span class="n">OLF</span><span class="p">)</span> <span class="n">rest</span><span class="o">++</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">features</span> <span class="o">&amp;</span> <span class="n">FE_C10</span><span class="p">))</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ss0</span> <span class="o">&amp;</span> <span class="n">ORF</span><span class="p">)</span> <span class="n">rest</span><span class="o">++</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cp</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">phys</span><span class="p">.</span><span class="n">select</span><span class="p">.</span><span class="n">sel_scntl3</span> <span class="o">&amp;</span> <span class="n">EWS</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">ss2</span> <span class="o">=</span> <span class="n">INB</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">nc_sstat2</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ss2</span> <span class="o">&amp;</span> <span class="n">OLF1</span><span class="p">)</span> <span class="n">rest</span><span class="o">++</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">features</span> <span class="o">&amp;</span> <span class="n">FE_C10</span><span class="p">))</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">ss2</span> <span class="o">&amp;</span> <span class="n">ORF1</span><span class="p">)</span> <span class="n">rest</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 *  Clear fifos.</span>
<span class="cm">		 */</span>
		<span class="n">OUTB</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">nc_ctest3</span><span class="p">,</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">rv_ctest3</span> <span class="o">|</span> <span class="n">CLF</span><span class="p">);</span>	<span class="cm">/* dma fifo  */</span>
		<span class="n">OUTB</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">nc_stest3</span><span class="p">,</span> <span class="n">TE</span><span class="o">|</span><span class="n">CSF</span><span class="p">);</span>		<span class="cm">/* scsi fifo */</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 *  log the information</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">DEBUG_FLAGS</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">DEBUG_TINY</span><span class="o">|</span><span class="n">DEBUG_PHASE</span><span class="p">))</span>
		<span class="n">printf</span> <span class="p">(</span><span class="s">&quot;P%x%x RL=%d D=%d &quot;</span><span class="p">,</span> <span class="n">cmd</span><span class="o">&amp;</span><span class="mi">7</span><span class="p">,</span> <span class="n">INB</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">nc_sbcl</span><span class="p">)</span><span class="o">&amp;</span><span class="mi">7</span><span class="p">,</span>
			<span class="p">(</span><span class="kt">unsigned</span><span class="p">)</span> <span class="n">rest</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span><span class="p">)</span> <span class="n">delta</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 *  try to find the interrupted script command,</span>
<span class="cm">	 *  and the address at which to continue.</span>
<span class="cm">	 */</span>
	<span class="n">vdsp</span>	<span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">nxtdsp</span>	<span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span>	<span class="p">(</span><span class="n">dsp</span> <span class="o">&gt;</span>  <span class="n">np</span><span class="o">-&gt;</span><span class="n">scripta_ba</span> <span class="o">&amp;&amp;</span>
		 <span class="n">dsp</span> <span class="o">&lt;=</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">scripta_ba</span> <span class="o">+</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">scripta_sz</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">vdsp</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span> <span class="o">*</span><span class="p">)((</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">scripta0</span> <span class="o">+</span> <span class="p">(</span><span class="n">dsp</span><span class="o">-</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">scripta_ba</span><span class="o">-</span><span class="mi">8</span><span class="p">));</span>
		<span class="n">nxtdsp</span> <span class="o">=</span> <span class="n">dsp</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">else</span> <span class="k">if</span>	<span class="p">(</span><span class="n">dsp</span> <span class="o">&gt;</span>  <span class="n">np</span><span class="o">-&gt;</span><span class="n">scriptb_ba</span> <span class="o">&amp;&amp;</span>
		 <span class="n">dsp</span> <span class="o">&lt;=</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">scriptb_ba</span> <span class="o">+</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">scriptb_sz</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">vdsp</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span> <span class="o">*</span><span class="p">)((</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">scriptb0</span> <span class="o">+</span> <span class="p">(</span><span class="n">dsp</span><span class="o">-</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">scriptb_ba</span><span class="o">-</span><span class="mi">8</span><span class="p">));</span>
		<span class="n">nxtdsp</span> <span class="o">=</span> <span class="n">dsp</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 *  log the information</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">DEBUG_FLAGS</span> <span class="o">&amp;</span> <span class="n">DEBUG_PHASE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printf</span> <span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">CP=%p DSP=%x NXT=%x VDSP=%p CMD=%x &quot;</span><span class="p">,</span>
			<span class="n">cp</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span><span class="p">)</span><span class="n">dsp</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span><span class="p">)</span><span class="n">nxtdsp</span><span class="p">,</span> <span class="n">vdsp</span><span class="p">,</span> <span class="n">cmd</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">vdsp</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printf</span> <span class="p">(</span><span class="s">&quot;%s: interrupted SCRIPT address not found.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> 
			<span class="n">sym_name</span> <span class="p">(</span><span class="n">np</span><span class="p">));</span>
		<span class="k">goto</span> <span class="n">reset_all</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cp</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printf</span> <span class="p">(</span><span class="s">&quot;%s: SCSI phase error fixup: CCB already dequeued.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> 
			<span class="n">sym_name</span> <span class="p">(</span><span class="n">np</span><span class="p">));</span>
		<span class="k">goto</span> <span class="n">reset_all</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 *  get old startaddress and old length.</span>
<span class="cm">	 */</span>
	<span class="n">oadr</span> <span class="o">=</span> <span class="n">scr_to_cpu</span><span class="p">(</span><span class="n">vdsp</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span> <span class="o">&amp;</span> <span class="mh">0x10</span><span class="p">)</span> <span class="p">{</span>	<span class="cm">/* Table indirect */</span>
		<span class="n">tblp</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span> <span class="o">*</span><span class="p">)</span> <span class="p">((</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">phys</span> <span class="o">+</span> <span class="n">oadr</span><span class="p">);</span>
		<span class="n">olen</span> <span class="o">=</span> <span class="n">scr_to_cpu</span><span class="p">(</span><span class="n">tblp</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
		<span class="n">oadr</span> <span class="o">=</span> <span class="n">scr_to_cpu</span><span class="p">(</span><span class="n">tblp</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">tblp</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span> <span class="o">*</span><span class="p">)</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">olen</span> <span class="o">=</span> <span class="n">scr_to_cpu</span><span class="p">(</span><span class="n">vdsp</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&amp;</span> <span class="mh">0xffffff</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">DEBUG_FLAGS</span> <span class="o">&amp;</span> <span class="n">DEBUG_PHASE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printf</span> <span class="p">(</span><span class="s">&quot;OCMD=%x</span><span class="se">\n</span><span class="s">TBLP=%p OLEN=%x OADR=%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="p">(</span><span class="kt">unsigned</span><span class="p">)</span> <span class="p">(</span><span class="n">scr_to_cpu</span><span class="p">(</span><span class="n">vdsp</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&gt;&gt;</span> <span class="mi">24</span><span class="p">),</span>
			<span class="n">tblp</span><span class="p">,</span>
			<span class="p">(</span><span class="kt">unsigned</span><span class="p">)</span> <span class="n">olen</span><span class="p">,</span>
			<span class="p">(</span><span class="kt">unsigned</span><span class="p">)</span> <span class="n">oadr</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 *  check cmd against assumed interrupted script command.</span>
<span class="cm">	 *  If dt data phase, the MOVE instruction hasn&#39;t bit 4 of </span>
<span class="cm">	 *  the phase.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(((</span><span class="n">cmd</span> <span class="o">&amp;</span> <span class="mi">2</span><span class="p">)</span> <span class="o">?</span> <span class="n">cmd</span> <span class="o">:</span> <span class="p">(</span><span class="n">cmd</span> <span class="o">&amp;</span> <span class="o">~</span><span class="mi">4</span><span class="p">))</span> <span class="o">!=</span> <span class="p">(</span><span class="n">scr_to_cpu</span><span class="p">(</span><span class="n">vdsp</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&gt;&gt;</span> <span class="mi">24</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">sym_print_addr</span><span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">cmd</span><span class="p">,</span>
			<span class="s">&quot;internal error: cmd=%02x != %02x=(vdsp[0] &gt;&gt; 24)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">cmd</span><span class="p">,</span> <span class="n">scr_to_cpu</span><span class="p">(</span><span class="n">vdsp</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&gt;&gt;</span> <span class="mi">24</span><span class="p">);</span>

		<span class="k">goto</span> <span class="n">reset_all</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 *  if old phase not dataphase, leave here.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span> <span class="o">&amp;</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">sym_print_addr</span><span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">cmd</span><span class="p">,</span>
			<span class="s">&quot;phase change %x-%x %d@%08x resid=%d.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">cmd</span><span class="o">&amp;</span><span class="mi">7</span><span class="p">,</span> <span class="n">INB</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">nc_sbcl</span><span class="p">)</span><span class="o">&amp;</span><span class="mi">7</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span><span class="p">)</span><span class="n">olen</span><span class="p">,</span>
			<span class="p">(</span><span class="kt">unsigned</span><span class="p">)</span><span class="n">oadr</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span><span class="p">)</span><span class="n">rest</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">unexpected_phase</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 *  Choose the correct PM save area.</span>
<span class="cm">	 *</span>
<span class="cm">	 *  Look at the PM_SAVE SCRIPT if you want to understand </span>
<span class="cm">	 *  this stuff. The equivalent code is implemented in </span>
<span class="cm">	 *  SCRIPTS for the 895A, 896 and 1010 that are able to </span>
<span class="cm">	 *  handle PM from the SCRIPTS processor.</span>
<span class="cm">	 */</span>
	<span class="n">hflags0</span> <span class="o">=</span> <span class="n">INB</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">HF_PRT</span><span class="p">);</span>
	<span class="n">hflags</span> <span class="o">=</span> <span class="n">hflags0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">hflags</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">HF_IN_PM0</span> <span class="o">|</span> <span class="n">HF_IN_PM1</span> <span class="o">|</span> <span class="n">HF_DP_SAVED</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">hflags</span> <span class="o">&amp;</span> <span class="n">HF_IN_PM0</span><span class="p">)</span>
			<span class="n">nxtdsp</span> <span class="o">=</span> <span class="n">scr_to_cpu</span><span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">phys</span><span class="p">.</span><span class="n">pm0</span><span class="p">.</span><span class="n">ret</span><span class="p">);</span>
		<span class="k">else</span> <span class="k">if</span>	<span class="p">(</span><span class="n">hflags</span> <span class="o">&amp;</span> <span class="n">HF_IN_PM1</span><span class="p">)</span>
			<span class="n">nxtdsp</span> <span class="o">=</span> <span class="n">scr_to_cpu</span><span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">phys</span><span class="p">.</span><span class="n">pm1</span><span class="p">.</span><span class="n">ret</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">hflags</span> <span class="o">&amp;</span> <span class="n">HF_DP_SAVED</span><span class="p">)</span>
			<span class="n">hflags</span> <span class="o">^=</span> <span class="n">HF_ACT_PM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">hflags</span> <span class="o">&amp;</span> <span class="n">HF_ACT_PM</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">pm</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">phys</span><span class="p">.</span><span class="n">pm0</span><span class="p">;</span>
		<span class="n">newcmd</span> <span class="o">=</span> <span class="n">SCRIPTA_BA</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">pm0_data</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="n">pm</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">phys</span><span class="p">.</span><span class="n">pm1</span><span class="p">;</span>
		<span class="n">newcmd</span> <span class="o">=</span> <span class="n">SCRIPTA_BA</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">pm1_data</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">hflags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">HF_IN_PM0</span> <span class="o">|</span> <span class="n">HF_IN_PM1</span> <span class="o">|</span> <span class="n">HF_DP_SAVED</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hflags</span> <span class="o">!=</span> <span class="n">hflags0</span><span class="p">)</span>
		<span class="n">OUTB</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">HF_PRT</span><span class="p">,</span> <span class="n">hflags</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 *  fillin the phase mismatch context</span>
<span class="cm">	 */</span>
	<span class="n">pm</span><span class="o">-&gt;</span><span class="n">sg</span><span class="p">.</span><span class="n">addr</span> <span class="o">=</span> <span class="n">cpu_to_scr</span><span class="p">(</span><span class="n">oadr</span> <span class="o">+</span> <span class="n">olen</span> <span class="o">-</span> <span class="n">rest</span><span class="p">);</span>
	<span class="n">pm</span><span class="o">-&gt;</span><span class="n">sg</span><span class="p">.</span><span class="n">size</span> <span class="o">=</span> <span class="n">cpu_to_scr</span><span class="p">(</span><span class="n">rest</span><span class="p">);</span>
	<span class="n">pm</span><span class="o">-&gt;</span><span class="n">ret</span>     <span class="o">=</span> <span class="n">cpu_to_scr</span><span class="p">(</span><span class="n">nxtdsp</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 *  If we have a SWIDE,</span>
<span class="cm">	 *  - prepare the address to write the SWIDE from SCRIPTS,</span>
<span class="cm">	 *  - compute the SCRIPTS address to restart from,</span>
<span class="cm">	 *  - move current data pointer context by one byte.</span>
<span class="cm">	 */</span>
	<span class="n">nxtdsp</span> <span class="o">=</span> <span class="n">SCRIPTA_BA</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">dispatch</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">cmd</span> <span class="o">&amp;</span> <span class="mi">7</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">cp</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">phys</span><span class="p">.</span><span class="n">select</span><span class="p">.</span><span class="n">sel_scntl3</span> <span class="o">&amp;</span> <span class="n">EWS</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">INB</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">nc_scntl2</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">WSR</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">u32</span> <span class="n">tmp</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 *  Set up the table indirect for the MOVE</span>
<span class="cm">		 *  of the residual byte and adjust the data </span>
<span class="cm">		 *  pointer context.</span>
<span class="cm">		 */</span>
		<span class="n">tmp</span> <span class="o">=</span> <span class="n">scr_to_cpu</span><span class="p">(</span><span class="n">pm</span><span class="o">-&gt;</span><span class="n">sg</span><span class="p">.</span><span class="n">addr</span><span class="p">);</span>
		<span class="n">cp</span><span class="o">-&gt;</span><span class="n">phys</span><span class="p">.</span><span class="n">wresid</span><span class="p">.</span><span class="n">addr</span> <span class="o">=</span> <span class="n">cpu_to_scr</span><span class="p">(</span><span class="n">tmp</span><span class="p">);</span>
		<span class="n">pm</span><span class="o">-&gt;</span><span class="n">sg</span><span class="p">.</span><span class="n">addr</span> <span class="o">=</span> <span class="n">cpu_to_scr</span><span class="p">(</span><span class="n">tmp</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">tmp</span> <span class="o">=</span> <span class="n">scr_to_cpu</span><span class="p">(</span><span class="n">pm</span><span class="o">-&gt;</span><span class="n">sg</span><span class="p">.</span><span class="n">size</span><span class="p">);</span>
		<span class="n">cp</span><span class="o">-&gt;</span><span class="n">phys</span><span class="p">.</span><span class="n">wresid</span><span class="p">.</span><span class="n">size</span> <span class="o">=</span> <span class="n">cpu_to_scr</span><span class="p">((</span><span class="n">tmp</span><span class="o">&amp;</span><span class="mh">0xff000000</span><span class="p">)</span> <span class="o">|</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">pm</span><span class="o">-&gt;</span><span class="n">sg</span><span class="p">.</span><span class="n">size</span> <span class="o">=</span> <span class="n">cpu_to_scr</span><span class="p">(</span><span class="n">tmp</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 *  If only the residual byte is to be moved, </span>
<span class="cm">		 *  no PM context is needed.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">tmp</span><span class="o">&amp;</span><span class="mh">0xffffff</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
			<span class="n">newcmd</span> <span class="o">=</span> <span class="n">pm</span><span class="o">-&gt;</span><span class="n">ret</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 *  Prepare the address of SCRIPTS that will </span>
<span class="cm">		 *  move the residual byte to memory.</span>
<span class="cm">		 */</span>
		<span class="n">nxtdsp</span> <span class="o">=</span> <span class="n">SCRIPTB_BA</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">wsr_ma_helper</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">DEBUG_FLAGS</span> <span class="o">&amp;</span> <span class="n">DEBUG_PHASE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">sym_print_addr</span><span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">cmd</span><span class="p">,</span> <span class="s">&quot;PM %x %x %x / %x %x %x.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">hflags0</span><span class="p">,</span> <span class="n">hflags</span><span class="p">,</span> <span class="n">newcmd</span><span class="p">,</span>
			<span class="p">(</span><span class="kt">unsigned</span><span class="p">)</span><span class="n">scr_to_cpu</span><span class="p">(</span><span class="n">pm</span><span class="o">-&gt;</span><span class="n">sg</span><span class="p">.</span><span class="n">addr</span><span class="p">),</span>
			<span class="p">(</span><span class="kt">unsigned</span><span class="p">)</span><span class="n">scr_to_cpu</span><span class="p">(</span><span class="n">pm</span><span class="o">-&gt;</span><span class="n">sg</span><span class="p">.</span><span class="n">size</span><span class="p">),</span>
			<span class="p">(</span><span class="kt">unsigned</span><span class="p">)</span><span class="n">scr_to_cpu</span><span class="p">(</span><span class="n">pm</span><span class="o">-&gt;</span><span class="n">ret</span><span class="p">));</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 *  Restart the SCRIPTS processor.</span>
<span class="cm">	 */</span>
	<span class="n">sym_set_script_dp</span> <span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">cp</span><span class="p">,</span> <span class="n">newcmd</span><span class="p">);</span>
	<span class="n">OUTL_DSP</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">nxtdsp</span><span class="p">);</span>
	<span class="k">return</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 *  Unexpected phase changes that occurs when the current phase </span>
<span class="cm">	 *  is not a DATA IN or DATA OUT phase are due to error conditions.</span>
<span class="cm">	 *  Such event may only happen when the SCRIPTS is using a </span>
<span class="cm">	 *  multibyte SCSI MOVE.</span>
<span class="cm">	 *</span>
<span class="cm">	 *  Phase change		Some possible cause</span>
<span class="cm">	 *</span>
<span class="cm">	 *  COMMAND  --&gt; MSG IN	SCSI parity error detected by target.</span>
<span class="cm">	 *  COMMAND  --&gt; STATUS	Bad command or refused by target.</span>
<span class="cm">	 *  MSG OUT  --&gt; MSG IN     Message rejected by target.</span>
<span class="cm">	 *  MSG OUT  --&gt; COMMAND    Bogus target that discards extended</span>
<span class="cm">	 *  			negotiation messages.</span>
<span class="cm">	 *</span>
<span class="cm">	 *  The code below does not care of the new phase and so </span>
<span class="cm">	 *  trusts the target. Why to annoy it ?</span>
<span class="cm">	 *  If the interrupted phase is COMMAND phase, we restart at</span>
<span class="cm">	 *  dispatcher.</span>
<span class="cm">	 *  If a target does not get all the messages after selection, </span>
<span class="cm">	 *  the code assumes blindly that the target discards extended </span>
<span class="cm">	 *  messages and clears the negotiation status.</span>
<span class="cm">	 *  If the target does not want all our response to negotiation,</span>
<span class="cm">	 *  we force a SIR_NEGO_PROTO interrupt (it is a hack that avoids </span>
<span class="cm">	 *  bloat for such a should_not_happen situation).</span>
<span class="cm">	 *  In all other situation, we reset the BUS.</span>
<span class="cm">	 *  Are these assumptions reasonable ? (Wait and see ...)</span>
<span class="cm">	 */</span>
<span class="nl">unexpected_phase:</span>
	<span class="n">dsp</span> <span class="o">-=</span> <span class="mi">8</span><span class="p">;</span>
	<span class="n">nxtdsp</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">cmd</span> <span class="o">&amp;</span> <span class="mi">7</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="mi">2</span>:	<span class="cm">/* COMMAND phase */</span>
		<span class="n">nxtdsp</span> <span class="o">=</span> <span class="n">SCRIPTA_BA</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">dispatch</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
<span class="cp">#if 0</span><span class="c"></span>
<span class="c">	case 3:	/* STATUS  phase */</span>
<span class="c">		nxtdsp = SCRIPTA_BA(np, dispatch);</span>
<span class="c">		break;</span>
<span class="cp">#endif</span>
	<span class="k">case</span> <span class="mi">6</span>:	<span class="cm">/* MSG OUT phase */</span>
		<span class="cm">/*</span>
<span class="cm">		 *  If the device may want to use untagged when we want </span>
<span class="cm">		 *  tagged, we prepare an IDENTIFY without disc. granted, </span>
<span class="cm">		 *  since we will not be able to handle reselect.</span>
<span class="cm">		 *  Otherwise, we just don&#39;t care.</span>
<span class="cm">		 */</span>
		<span class="k">if</span>	<span class="p">(</span><span class="n">dsp</span> <span class="o">==</span> <span class="n">SCRIPTA_BA</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">send_ident</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">tag</span> <span class="o">!=</span> <span class="n">NO_TAG</span> <span class="o">&amp;&amp;</span> <span class="n">olen</span> <span class="o">-</span> <span class="n">rest</span> <span class="o">&lt;=</span> <span class="mi">3</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">cp</span><span class="o">-&gt;</span><span class="n">host_status</span> <span class="o">=</span> <span class="n">HS_BUSY</span><span class="p">;</span>
				<span class="n">np</span><span class="o">-&gt;</span><span class="n">msgout</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">IDENTIFY</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">lun</span><span class="p">);</span>
				<span class="n">nxtdsp</span> <span class="o">=</span> <span class="n">SCRIPTB_BA</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">ident_break_atn</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="k">else</span>
				<span class="n">nxtdsp</span> <span class="o">=</span> <span class="n">SCRIPTB_BA</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">ident_break</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">else</span> <span class="k">if</span>	<span class="p">(</span><span class="n">dsp</span> <span class="o">==</span> <span class="n">SCRIPTB_BA</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">send_wdtr</span><span class="p">)</span> <span class="o">||</span>
			 <span class="n">dsp</span> <span class="o">==</span> <span class="n">SCRIPTB_BA</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">send_sdtr</span><span class="p">)</span> <span class="o">||</span>
			 <span class="n">dsp</span> <span class="o">==</span> <span class="n">SCRIPTB_BA</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">send_ppr</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">nxtdsp</span> <span class="o">=</span> <span class="n">SCRIPTB_BA</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">nego_bad_phase</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">dsp</span> <span class="o">==</span> <span class="n">SCRIPTB_BA</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">send_ppr</span><span class="p">))</span> <span class="p">{</span>
				<span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">device</span><span class="p">;</span>
				<span class="n">dev</span><span class="o">-&gt;</span><span class="n">ppr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
<span class="cp">#if 0</span><span class="c"></span>
<span class="c">	case 7:	/* MSG IN  phase */</span>
<span class="c">		nxtdsp = SCRIPTA_BA(np, clrack);</span>
<span class="c">		break;</span>
<span class="cp">#endif</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">nxtdsp</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">OUTL_DSP</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">nxtdsp</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

<span class="nl">reset_all:</span>
	<span class="n">sym_start_reset</span><span class="p">(</span><span class="n">np</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *  chip interrupt handler</span>
<span class="cm"> *</span>
<span class="cm"> *  In normal situations, interrupt conditions occur one at </span>
<span class="cm"> *  a time. But when something bad happens on the SCSI BUS, </span>
<span class="cm"> *  the chip may raise several interrupt flags before </span>
<span class="cm"> *  stopping and interrupting the CPU. The additionnal </span>
<span class="cm"> *  interrupt flags are stacked in some extra registers </span>
<span class="cm"> *  after the SIP and/or DIP flag has been raised in the </span>
<span class="cm"> *  ISTAT. After the CPU has read the interrupt condition </span>
<span class="cm"> *  flag from SIST or DSTAT, the chip unstacks the other </span>
<span class="cm"> *  interrupt flags and sets the corresponding bits in </span>
<span class="cm"> *  SIST or DSTAT. Since the chip starts stacking once the </span>
<span class="cm"> *  SIP or DIP flag is set, there is a small window of time </span>
<span class="cm"> *  where the stacking does not occur.</span>
<span class="cm"> *</span>
<span class="cm"> *  Typically, multiple interrupt conditions may happen in </span>
<span class="cm"> *  the following situations:</span>
<span class="cm"> *</span>
<span class="cm"> *  - SCSI parity error + Phase mismatch  (PAR|MA)</span>
<span class="cm"> *    When an parity error is detected in input phase </span>
<span class="cm"> *    and the device switches to msg-in phase inside a </span>
<span class="cm"> *    block MOV.</span>
<span class="cm"> *  - SCSI parity error + Unexpected disconnect (PAR|UDC)</span>
<span class="cm"> *    When a stupid device does not want to handle the </span>
<span class="cm"> *    recovery of an SCSI parity error.</span>
<span class="cm"> *  - Some combinations of STO, PAR, UDC, ...</span>
<span class="cm"> *    When using non compliant SCSI stuff, when user is </span>
<span class="cm"> *    doing non compliant hot tampering on the BUS, when </span>
<span class="cm"> *    something really bad happens to a device, etc ...</span>
<span class="cm"> *</span>
<span class="cm"> *  The heuristic suggested by SYMBIOS to handle </span>
<span class="cm"> *  multiple interrupts is to try unstacking all </span>
<span class="cm"> *  interrupts conditions and to handle them on some </span>
<span class="cm"> *  priority based on error severity.</span>
<span class="cm"> *  This will work when the unstacking has been </span>
<span class="cm"> *  successful, but we cannot be 100 % sure of that, </span>
<span class="cm"> *  since the CPU may have been faster to unstack than </span>
<span class="cm"> *  the chip is able to stack. Hmmm ... But it seems that </span>
<span class="cm"> *  such a situation is very unlikely to happen.</span>
<span class="cm"> *</span>
<span class="cm"> *  If this happen, for example STO caught by the CPU </span>
<span class="cm"> *  then UDC happenning before the CPU have restarted </span>
<span class="cm"> *  the SCRIPTS, the driver may wrongly complete the </span>
<span class="cm"> *  same command on UDC, since the SCRIPTS didn&#39;t restart </span>
<span class="cm"> *  and the DSA still points to the same command.</span>
<span class="cm"> *  We avoid this situation by setting the DSA to an </span>
<span class="cm"> *  invalid value when the CCB is completed and before </span>
<span class="cm"> *  restarting the SCRIPTS.</span>
<span class="cm"> *</span>
<span class="cm"> *  Another issue is that we need some section of our </span>
<span class="cm"> *  recovery procedures to be somehow uninterruptible but </span>
<span class="cm"> *  the SCRIPTS processor does not provides such a </span>
<span class="cm"> *  feature. For this reason, we handle recovery preferently </span>
<span class="cm"> *  from the C code and check against some SCRIPTS critical </span>
<span class="cm"> *  sections from the C code.</span>
<span class="cm"> *</span>
<span class="cm"> *  Hopefully, the interrupt handling of the driver is now </span>
<span class="cm"> *  able to resist to weird BUS error conditions, but donnot </span>
<span class="cm"> *  ask me for any guarantee that it will never fail. :-)</span>
<span class="cm"> *  Use at your own decision and risk.</span>
<span class="cm"> */</span>

<span class="n">irqreturn_t</span> <span class="n">sym_interrupt</span><span class="p">(</span><span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sym_data</span> <span class="o">*</span><span class="n">sym_data</span> <span class="o">=</span> <span class="n">shost_priv</span><span class="p">(</span><span class="n">shost</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">sym_hcb</span> <span class="o">*</span><span class="n">np</span> <span class="o">=</span> <span class="n">sym_data</span><span class="o">-&gt;</span><span class="n">ncb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span> <span class="o">=</span> <span class="n">sym_data</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">;</span>
	<span class="n">u_char</span>	<span class="n">istat</span><span class="p">,</span> <span class="n">istatc</span><span class="p">;</span>
	<span class="n">u_char</span>	<span class="n">dstat</span><span class="p">;</span>
	<span class="n">u_short</span>	<span class="n">sist</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 *  interrupt on the fly ?</span>
<span class="cm">	 *  (SCRIPTS may still be running)</span>
<span class="cm">	 *</span>
<span class="cm">	 *  A `dummy read&#39; is needed to ensure that the </span>
<span class="cm">	 *  clear of the INTF flag reaches the device </span>
<span class="cm">	 *  and that posted writes are flushed to memory</span>
<span class="cm">	 *  before the scanning of the DONE queue.</span>
<span class="cm">	 *  Note that SCRIPTS also (dummy) read to memory </span>
<span class="cm">	 *  prior to deliver the INTF interrupt condition.</span>
<span class="cm">	 */</span>
	<span class="n">istat</span> <span class="o">=</span> <span class="n">INB</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">nc_istat</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">istat</span> <span class="o">&amp;</span> <span class="n">INTF</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">OUTB</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">nc_istat</span><span class="p">,</span> <span class="p">(</span><span class="n">istat</span> <span class="o">&amp;</span> <span class="n">SIGP</span><span class="p">)</span> <span class="o">|</span> <span class="n">INTF</span> <span class="o">|</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">istat_sem</span><span class="p">);</span>
		<span class="n">istat</span> <span class="o">|=</span> <span class="n">INB</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">nc_istat</span><span class="p">);</span>		<span class="cm">/* DUMMY READ */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">DEBUG_FLAGS</span> <span class="o">&amp;</span> <span class="n">DEBUG_TINY</span><span class="p">)</span> <span class="n">printf</span> <span class="p">(</span><span class="s">&quot;F &quot;</span><span class="p">);</span>
		<span class="n">sym_wakeup_done</span><span class="p">(</span><span class="n">np</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">istat</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">SIP</span><span class="o">|</span><span class="n">DIP</span><span class="p">)))</span>
		<span class="k">return</span> <span class="p">(</span><span class="n">istat</span> <span class="o">&amp;</span> <span class="n">INTF</span><span class="p">)</span> <span class="o">?</span> <span class="n">IRQ_HANDLED</span> <span class="o">:</span> <span class="n">IRQ_NONE</span><span class="p">;</span>

<span class="cp">#if 0</span><span class="c">	/* We should never get this one */</span>
<span class="c">	if (istat &amp; CABRT)</span>
<span class="c">		OUTB(np, nc_istat, CABRT);</span>
<span class="cp">#endif</span>

	<span class="cm">/*</span>
<span class="cm">	 *  PAR and MA interrupts may occur at the same time,</span>
<span class="cm">	 *  and we need to know of both in order to handle </span>
<span class="cm">	 *  this situation properly. We try to unstack SCSI </span>
<span class="cm">	 *  interrupts for that reason. BTW, I dislike a LOT </span>
<span class="cm">	 *  such a loop inside the interrupt routine.</span>
<span class="cm">	 *  Even if DMA interrupt stacking is very unlikely to </span>
<span class="cm">	 *  happen, we also try unstacking these ones, since </span>
<span class="cm">	 *  this has no performance impact.</span>
<span class="cm">	 */</span>
	<span class="n">sist</span>	<span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">dstat</span>	<span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">istatc</span>	<span class="o">=</span> <span class="n">istat</span><span class="p">;</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">istatc</span> <span class="o">&amp;</span> <span class="n">SIP</span><span class="p">)</span>
			<span class="n">sist</span>  <span class="o">|=</span> <span class="n">INW</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">nc_sist</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">istatc</span> <span class="o">&amp;</span> <span class="n">DIP</span><span class="p">)</span>
			<span class="n">dstat</span> <span class="o">|=</span> <span class="n">INB</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">nc_dstat</span><span class="p">);</span>
		<span class="n">istatc</span> <span class="o">=</span> <span class="n">INB</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">nc_istat</span><span class="p">);</span>
		<span class="n">istat</span> <span class="o">|=</span> <span class="n">istatc</span><span class="p">;</span>

		<span class="cm">/* Prevent deadlock waiting on a condition that may</span>
<span class="cm">		 * never clear. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">sist</span> <span class="o">==</span> <span class="mh">0xffff</span> <span class="o">&amp;&amp;</span> <span class="n">dstat</span> <span class="o">==</span> <span class="mh">0xff</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">pci_channel_offline</span><span class="p">(</span><span class="n">pdev</span><span class="p">))</span>
				<span class="k">return</span> <span class="n">IRQ_NONE</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">istatc</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">SIP</span><span class="o">|</span><span class="n">DIP</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">DEBUG_FLAGS</span> <span class="o">&amp;</span> <span class="n">DEBUG_TINY</span><span class="p">)</span>
		<span class="n">printf</span> <span class="p">(</span><span class="s">&quot;&lt;%d|%x:%x|%x:%x&gt;&quot;</span><span class="p">,</span>
			<span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">INB</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">nc_scr0</span><span class="p">),</span>
			<span class="n">dstat</span><span class="p">,</span><span class="n">sist</span><span class="p">,</span>
			<span class="p">(</span><span class="kt">unsigned</span><span class="p">)</span><span class="n">INL</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">nc_dsp</span><span class="p">),</span>
			<span class="p">(</span><span class="kt">unsigned</span><span class="p">)</span><span class="n">INL</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">nc_dbc</span><span class="p">));</span>
	<span class="cm">/*</span>
<span class="cm">	 *  On paper, a memory read barrier may be needed here to </span>
<span class="cm">	 *  prevent out of order LOADs by the CPU from having </span>
<span class="cm">	 *  prefetched stale data prior to DMA having occurred.</span>
<span class="cm">	 *  And since we are paranoid ... :)</span>
<span class="cm">	 */</span>
	<span class="n">MEMORY_READ_BARRIER</span><span class="p">();</span>

	<span class="cm">/*</span>
<span class="cm">	 *  First, interrupts we want to service cleanly.</span>
<span class="cm">	 *</span>
<span class="cm">	 *  Phase mismatch (MA) is the most frequent interrupt </span>
<span class="cm">	 *  for chip earlier than the 896 and so we have to service </span>
<span class="cm">	 *  it as quickly as possible.</span>
<span class="cm">	 *  A SCSI parity error (PAR) may be combined with a phase </span>
<span class="cm">	 *  mismatch condition (MA).</span>
<span class="cm">	 *  Programmed interrupts (SIR) are used to call the C code </span>
<span class="cm">	 *  from SCRIPTS.</span>
<span class="cm">	 *  The single step interrupt (SSI) is not used in this </span>
<span class="cm">	 *  driver.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">sist</span>  <span class="o">&amp;</span> <span class="p">(</span><span class="n">STO</span><span class="o">|</span><span class="n">GEN</span><span class="o">|</span><span class="n">HTH</span><span class="o">|</span><span class="n">SGE</span><span class="o">|</span><span class="n">UDC</span><span class="o">|</span><span class="n">SBMC</span><span class="o">|</span><span class="n">RST</span><span class="p">))</span> <span class="o">&amp;&amp;</span>
	    <span class="o">!</span><span class="p">(</span><span class="n">dstat</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">MDPE</span><span class="o">|</span><span class="n">BF</span><span class="o">|</span><span class="n">ABRT</span><span class="o">|</span><span class="n">IID</span><span class="p">)))</span> <span class="p">{</span>
		<span class="k">if</span>	<span class="p">(</span><span class="n">sist</span> <span class="o">&amp;</span> <span class="n">PAR</span><span class="p">)</span>	<span class="n">sym_int_par</span> <span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">sist</span><span class="p">);</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">sist</span> <span class="o">&amp;</span> <span class="n">MA</span><span class="p">)</span>	<span class="n">sym_int_ma</span> <span class="p">(</span><span class="n">np</span><span class="p">);</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">dstat</span> <span class="o">&amp;</span> <span class="n">SIR</span><span class="p">)</span>	<span class="n">sym_int_sir</span><span class="p">(</span><span class="n">np</span><span class="p">);</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">dstat</span> <span class="o">&amp;</span> <span class="n">SSI</span><span class="p">)</span>	<span class="n">OUTONB_STD</span><span class="p">();</span>
		<span class="k">else</span>			<span class="k">goto</span> <span class="n">unknown_int</span><span class="p">;</span>
		<span class="k">return</span> <span class="n">IRQ_HANDLED</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 *  Now, interrupts that donnot happen in normal </span>
<span class="cm">	 *  situations and that we may need to recover from.</span>
<span class="cm">	 *</span>
<span class="cm">	 *  On SCSI RESET (RST), we reset everything.</span>
<span class="cm">	 *  On SCSI BUS MODE CHANGE (SBMC), we complete all </span>
<span class="cm">	 *  active CCBs with RESET status, prepare all devices </span>
<span class="cm">	 *  for negotiating again and restart the SCRIPTS.</span>
<span class="cm">	 *  On STO and UDC, we complete the CCB with the corres- </span>
<span class="cm">	 *  ponding status and restart the SCRIPTS.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sist</span> <span class="o">&amp;</span> <span class="n">RST</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printf</span><span class="p">(</span><span class="s">&quot;%s: SCSI BUS reset detected.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">sym_name</span><span class="p">(</span><span class="n">np</span><span class="p">));</span>
		<span class="n">sym_start_up</span><span class="p">(</span><span class="n">shost</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">IRQ_HANDLED</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">OUTB</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">nc_ctest3</span><span class="p">,</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">rv_ctest3</span> <span class="o">|</span> <span class="n">CLF</span><span class="p">);</span>	<span class="cm">/* clear dma fifo  */</span>
	<span class="n">OUTB</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">nc_stest3</span><span class="p">,</span> <span class="n">TE</span><span class="o">|</span><span class="n">CSF</span><span class="p">);</span>		<span class="cm">/* clear scsi fifo */</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">sist</span>  <span class="o">&amp;</span> <span class="p">(</span><span class="n">GEN</span><span class="o">|</span><span class="n">HTH</span><span class="o">|</span><span class="n">SGE</span><span class="p">))</span> <span class="o">&amp;&amp;</span>
	    <span class="o">!</span><span class="p">(</span><span class="n">dstat</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">MDPE</span><span class="o">|</span><span class="n">BF</span><span class="o">|</span><span class="n">ABRT</span><span class="o">|</span><span class="n">IID</span><span class="p">)))</span> <span class="p">{</span>
		<span class="k">if</span>	<span class="p">(</span><span class="n">sist</span> <span class="o">&amp;</span> <span class="n">SBMC</span><span class="p">)</span>	<span class="n">sym_int_sbmc</span><span class="p">(</span><span class="n">shost</span><span class="p">);</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">sist</span> <span class="o">&amp;</span> <span class="n">STO</span><span class="p">)</span>	<span class="n">sym_int_sto</span> <span class="p">(</span><span class="n">np</span><span class="p">);</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">sist</span> <span class="o">&amp;</span> <span class="n">UDC</span><span class="p">)</span>	<span class="n">sym_int_udc</span> <span class="p">(</span><span class="n">np</span><span class="p">);</span>
		<span class="k">else</span>			<span class="k">goto</span> <span class="n">unknown_int</span><span class="p">;</span>
		<span class="k">return</span> <span class="n">IRQ_HANDLED</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 *  Now, interrupts we are not able to recover cleanly.</span>
<span class="cm">	 *</span>
<span class="cm">	 *  Log message for hard errors.</span>
<span class="cm">	 *  Reset everything.</span>
<span class="cm">	 */</span>

	<span class="n">sym_log_hard_error</span><span class="p">(</span><span class="n">shost</span><span class="p">,</span> <span class="n">sist</span><span class="p">,</span> <span class="n">dstat</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">sist</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">GEN</span><span class="o">|</span><span class="n">HTH</span><span class="o">|</span><span class="n">SGE</span><span class="p">))</span> <span class="o">||</span>
		<span class="p">(</span><span class="n">dstat</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">MDPE</span><span class="o">|</span><span class="n">BF</span><span class="o">|</span><span class="n">ABRT</span><span class="o">|</span><span class="n">IID</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">sym_start_reset</span><span class="p">(</span><span class="n">np</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">IRQ_HANDLED</span><span class="p">;</span>
	<span class="p">}</span>

<span class="nl">unknown_int:</span>
	<span class="cm">/*</span>
<span class="cm">	 *  We just miss the cause of the interrupt. :(</span>
<span class="cm">	 *  Print a message. The timeout will do the real work.</span>
<span class="cm">	 */</span>
	<span class="n">printf</span><span class="p">(</span>	<span class="s">&quot;%s: unknown interrupt(s) ignored, &quot;</span>
		<span class="s">&quot;ISTAT=0x%x DSTAT=0x%x SIST=0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">sym_name</span><span class="p">(</span><span class="n">np</span><span class="p">),</span> <span class="n">istat</span><span class="p">,</span> <span class="n">dstat</span><span class="p">,</span> <span class="n">sist</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">IRQ_NONE</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *  Dequeue from the START queue all CCBs that match </span>
<span class="cm"> *  a given target/lun/task condition (-1 means all),</span>
<span class="cm"> *  and move them from the BUSY queue to the COMP queue </span>
<span class="cm"> *  with DID_SOFT_ERROR status condition.</span>
<span class="cm"> *  This function is used during error handling/recovery.</span>
<span class="cm"> *  It is called with SCRIPTS not running.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> 
<span class="n">sym_dequeue_from_squeue</span><span class="p">(</span><span class="k">struct</span> <span class="n">sym_hcb</span> <span class="o">*</span><span class="n">np</span><span class="p">,</span> <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="kt">int</span> <span class="n">target</span><span class="p">,</span> <span class="kt">int</span> <span class="n">lun</span><span class="p">,</span> <span class="kt">int</span> <span class="n">task</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">j</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sym_ccb</span> <span class="o">*</span><span class="n">cp</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 *  Make sure the starting index is within range.</span>
<span class="cm">	 */</span>
	<span class="n">assert</span><span class="p">((</span><span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="o">*</span><span class="n">MAX_QUEUE</span><span class="p">));</span>

	<span class="cm">/*</span>
<span class="cm">	 *  Walk until end of START queue and dequeue every job </span>
<span class="cm">	 *  that matches the target/lun/task condition.</span>
<span class="cm">	 */</span>
	<span class="n">j</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">i</span> <span class="o">!=</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">squeueput</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cp</span> <span class="o">=</span> <span class="n">sym_ccb_from_dsa</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">scr_to_cpu</span><span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">squeue</span><span class="p">[</span><span class="n">i</span><span class="p">]));</span>
		<span class="n">assert</span><span class="p">(</span><span class="n">cp</span><span class="p">);</span>
<span class="cp">#ifdef SYM_CONF_IARB_SUPPORT</span>
		<span class="cm">/* Forget hints for IARB, they may be no longer relevant */</span>
		<span class="n">cp</span><span class="o">-&gt;</span><span class="n">host_flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">HF_HINT_IARB</span><span class="p">;</span>
<span class="cp">#endif</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">target</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="o">||</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">target</span> <span class="o">==</span> <span class="n">target</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="p">(</span><span class="n">lun</span>    <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="o">||</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">lun</span>    <span class="o">==</span> <span class="n">lun</span><span class="p">)</span>    <span class="o">&amp;&amp;</span>
		    <span class="p">(</span><span class="n">task</span>   <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="o">||</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">tag</span>    <span class="o">==</span> <span class="n">task</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">sym_set_cam_status</span><span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">cmd</span><span class="p">,</span> <span class="n">DID_SOFT_ERROR</span><span class="p">);</span>
			<span class="n">sym_remque</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">link_ccbq</span><span class="p">);</span>
			<span class="n">sym_insque_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">link_ccbq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">comp_ccbq</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">else</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">!=</span> <span class="n">j</span><span class="p">)</span>
				<span class="n">np</span><span class="o">-&gt;</span><span class="n">squeue</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">squeue</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">j</span> <span class="o">+=</span> <span class="mi">2</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">MAX_QUEUE</span><span class="o">*</span><span class="mi">2</span><span class="p">)</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">i</span> <span class="o">+=</span> <span class="mi">2</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">MAX_QUEUE</span><span class="o">*</span><span class="mi">2</span><span class="p">)</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">!=</span> <span class="n">j</span><span class="p">)</span>		<span class="cm">/* Copy back the idle task if needed */</span>
		<span class="n">np</span><span class="o">-&gt;</span><span class="n">squeue</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">squeue</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
	<span class="n">np</span><span class="o">-&gt;</span><span class="n">squeueput</span> <span class="o">=</span> <span class="n">j</span><span class="p">;</span>	<span class="cm">/* Update our current start queue pointer */</span>

	<span class="k">return</span> <span class="p">(</span><span class="n">i</span> <span class="o">-</span> <span class="n">j</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *  chip handler for bad SCSI status condition</span>
<span class="cm"> *</span>
<span class="cm"> *  In case of bad SCSI status, we unqueue all the tasks </span>
<span class="cm"> *  currently queued to the controller but not yet started </span>
<span class="cm"> *  and then restart the SCRIPTS processor immediately.</span>
<span class="cm"> *</span>
<span class="cm"> *  QUEUE FULL and BUSY conditions are handled the same way.</span>
<span class="cm"> *  Basically all the not yet started tasks are requeued in </span>
<span class="cm"> *  device queue and the queue is frozen until a completion.</span>
<span class="cm"> *</span>
<span class="cm"> *  For CHECK CONDITION and COMMAND TERMINATED status, we use </span>
<span class="cm"> *  the CCB of the failed command to prepare a REQUEST SENSE </span>
<span class="cm"> *  SCSI command and queue it to the controller queue.</span>
<span class="cm"> *</span>
<span class="cm"> *  SCRATCHA is assumed to have been loaded with STARTPOS </span>
<span class="cm"> *  before the SCRIPTS called the C code.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">sym_sir_bad_scsi_status</span><span class="p">(</span><span class="k">struct</span> <span class="n">sym_hcb</span> <span class="o">*</span><span class="n">np</span><span class="p">,</span> <span class="kt">int</span> <span class="n">num</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sym_ccb</span> <span class="o">*</span><span class="n">cp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span>		<span class="n">startp</span><span class="p">;</span>
	<span class="n">u_char</span>		<span class="n">s_status</span> <span class="o">=</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">ssss_status</span><span class="p">;</span>
	<span class="n">u_char</span>		<span class="n">h_flags</span>  <span class="o">=</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">host_flags</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">msglen</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">i</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 *  Compute the index of the next job to start from SCRIPTS.</span>
<span class="cm">	 */</span>
	<span class="n">i</span> <span class="o">=</span> <span class="p">(</span><span class="n">INL</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">nc_scratcha</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">squeue_ba</span><span class="p">)</span> <span class="o">/</span> <span class="mi">4</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 *  The last CCB queued used for IARB hint may be </span>
<span class="cm">	 *  no longer relevant. Forget it.</span>
<span class="cm">	 */</span>
<span class="cp">#ifdef SYM_CONF_IARB_SUPPORT</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">last_cp</span><span class="p">)</span>
		<span class="n">np</span><span class="o">-&gt;</span><span class="n">last_cp</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="cp">#endif</span>

	<span class="cm">/*</span>
<span class="cm">	 *  Now deal with the SCSI status.</span>
<span class="cm">	 */</span>
	<span class="k">switch</span><span class="p">(</span><span class="n">s_status</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">S_BUSY</span>:
	<span class="k">case</span> <span class="n">S_QUEUE_FULL</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">sym_verbose</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">sym_print_addr</span><span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">cmd</span><span class="p">,</span> <span class="s">&quot;%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			        <span class="n">s_status</span> <span class="o">==</span> <span class="n">S_BUSY</span> <span class="o">?</span> <span class="s">&quot;BUSY&quot;</span> <span class="o">:</span> <span class="s">&quot;QUEUE FULL</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="nl">default:</span>	<span class="cm">/* S_INT, S_INT_COND_MET, S_CONFLICT */</span>
		<span class="n">sym_complete_error</span> <span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">cp</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">S_TERMINATED</span>:
	<span class="k">case</span> <span class="n">S_CHECK_COND</span>:
		<span class="cm">/*</span>
<span class="cm">		 *  If we get an SCSI error when requesting sense, give up.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">h_flags</span> <span class="o">&amp;</span> <span class="n">HF_SENSE</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">sym_complete_error</span> <span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">cp</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 *  Dequeue all queued CCBs for that device not yet started,</span>
<span class="cm">		 *  and restart the SCRIPTS processor immediately.</span>
<span class="cm">		 */</span>
		<span class="n">sym_dequeue_from_squeue</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">target</span><span class="p">,</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">lun</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>
		<span class="n">OUTL_DSP</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">SCRIPTA_BA</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">start</span><span class="p">));</span>

 		<span class="cm">/*</span>
<span class="cm">		 *  Save some info of the actual IO.</span>
<span class="cm">		 *  Compute the data residual.</span>
<span class="cm">		 */</span>
		<span class="n">cp</span><span class="o">-&gt;</span><span class="n">sv_scsi_status</span> <span class="o">=</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">ssss_status</span><span class="p">;</span>
		<span class="n">cp</span><span class="o">-&gt;</span><span class="n">sv_xerr_status</span> <span class="o">=</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">xerr_status</span><span class="p">;</span>
		<span class="n">cp</span><span class="o">-&gt;</span><span class="n">sv_resid</span> <span class="o">=</span> <span class="n">sym_compute_residual</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">cp</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 *  Prepare all needed data structures for </span>
<span class="cm">		 *  requesting sense data.</span>
<span class="cm">		 */</span>

		<span class="n">cp</span><span class="o">-&gt;</span><span class="n">scsi_smsg2</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">IDENTIFY</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">lun</span><span class="p">);</span>
		<span class="n">msglen</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 *  If we are currently using anything different from </span>
<span class="cm">		 *  async. 8 bit data transfers with that target,</span>
<span class="cm">		 *  start a negotiation, since the device may want </span>
<span class="cm">		 *  to report us a UNIT ATTENTION condition due to </span>
<span class="cm">		 *  a cause we currently ignore, and we donnot want </span>
<span class="cm">		 *  to be stuck with WIDE and/or SYNC data transfer.</span>
<span class="cm">		 *</span>
<span class="cm">		 *  cp-&gt;nego_status is filled by sym_prepare_nego().</span>
<span class="cm">		 */</span>
		<span class="n">cp</span><span class="o">-&gt;</span><span class="n">nego_status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">msglen</span> <span class="o">+=</span> <span class="n">sym_prepare_nego</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">cp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">scsi_smsg2</span><span class="p">[</span><span class="n">msglen</span><span class="p">]);</span>
		<span class="cm">/*</span>
<span class="cm">		 *  Message table indirect structure.</span>
<span class="cm">		 */</span>
		<span class="n">cp</span><span class="o">-&gt;</span><span class="n">phys</span><span class="p">.</span><span class="n">smsg</span><span class="p">.</span><span class="n">addr</span>	<span class="o">=</span> <span class="n">CCB_BA</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">scsi_smsg2</span><span class="p">);</span>
		<span class="n">cp</span><span class="o">-&gt;</span><span class="n">phys</span><span class="p">.</span><span class="n">smsg</span><span class="p">.</span><span class="n">size</span>	<span class="o">=</span> <span class="n">cpu_to_scr</span><span class="p">(</span><span class="n">msglen</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 *  sense command</span>
<span class="cm">		 */</span>
		<span class="n">cp</span><span class="o">-&gt;</span><span class="n">phys</span><span class="p">.</span><span class="n">cmd</span><span class="p">.</span><span class="n">addr</span>	<span class="o">=</span> <span class="n">CCB_BA</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">sensecmd</span><span class="p">);</span>
		<span class="n">cp</span><span class="o">-&gt;</span><span class="n">phys</span><span class="p">.</span><span class="n">cmd</span><span class="p">.</span><span class="n">size</span>	<span class="o">=</span> <span class="n">cpu_to_scr</span><span class="p">(</span><span class="mi">6</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 *  patch requested size into sense command</span>
<span class="cm">		 */</span>
		<span class="n">cp</span><span class="o">-&gt;</span><span class="n">sensecmd</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>		<span class="o">=</span> <span class="n">REQUEST_SENSE</span><span class="p">;</span>
		<span class="n">cp</span><span class="o">-&gt;</span><span class="n">sensecmd</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>		<span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">scsi_level</span> <span class="o">&lt;=</span> <span class="n">SCSI_2</span> <span class="o">&amp;&amp;</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">lun</span> <span class="o">&lt;=</span> <span class="mi">7</span><span class="p">)</span>
			<span class="n">cp</span><span class="o">-&gt;</span><span class="n">sensecmd</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>	<span class="o">=</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">lun</span> <span class="o">&lt;&lt;</span> <span class="mi">5</span><span class="p">;</span>
		<span class="n">cp</span><span class="o">-&gt;</span><span class="n">sensecmd</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span>		<span class="o">=</span> <span class="n">SYM_SNS_BBUF_LEN</span><span class="p">;</span>
		<span class="n">cp</span><span class="o">-&gt;</span><span class="n">data_len</span>		<span class="o">=</span> <span class="n">SYM_SNS_BBUF_LEN</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 *  sense data</span>
<span class="cm">		 */</span>
		<span class="n">memset</span><span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">sns_bbuf</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">SYM_SNS_BBUF_LEN</span><span class="p">);</span>
		<span class="n">cp</span><span class="o">-&gt;</span><span class="n">phys</span><span class="p">.</span><span class="n">sense</span><span class="p">.</span><span class="n">addr</span>	<span class="o">=</span> <span class="n">CCB_BA</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">sns_bbuf</span><span class="p">);</span>
		<span class="n">cp</span><span class="o">-&gt;</span><span class="n">phys</span><span class="p">.</span><span class="n">sense</span><span class="p">.</span><span class="n">size</span>	<span class="o">=</span> <span class="n">cpu_to_scr</span><span class="p">(</span><span class="n">SYM_SNS_BBUF_LEN</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 *  requeue the command.</span>
<span class="cm">		 */</span>
		<span class="n">startp</span> <span class="o">=</span> <span class="n">SCRIPTB_BA</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">sdata_in</span><span class="p">);</span>

		<span class="n">cp</span><span class="o">-&gt;</span><span class="n">phys</span><span class="p">.</span><span class="n">head</span><span class="p">.</span><span class="n">savep</span>	<span class="o">=</span> <span class="n">cpu_to_scr</span><span class="p">(</span><span class="n">startp</span><span class="p">);</span>
		<span class="n">cp</span><span class="o">-&gt;</span><span class="n">phys</span><span class="p">.</span><span class="n">head</span><span class="p">.</span><span class="n">lastp</span>	<span class="o">=</span> <span class="n">cpu_to_scr</span><span class="p">(</span><span class="n">startp</span><span class="p">);</span>
		<span class="n">cp</span><span class="o">-&gt;</span><span class="n">startp</span>		<span class="o">=</span> <span class="n">cpu_to_scr</span><span class="p">(</span><span class="n">startp</span><span class="p">);</span>
		<span class="n">cp</span><span class="o">-&gt;</span><span class="n">goalp</span>		<span class="o">=</span> <span class="n">cpu_to_scr</span><span class="p">(</span><span class="n">startp</span> <span class="o">+</span> <span class="mi">16</span><span class="p">);</span>

		<span class="n">cp</span><span class="o">-&gt;</span><span class="n">host_xflags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">cp</span><span class="o">-&gt;</span><span class="n">host_status</span>	<span class="o">=</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">nego_status</span> <span class="o">?</span> <span class="n">HS_NEGOTIATE</span> <span class="o">:</span> <span class="n">HS_BUSY</span><span class="p">;</span>
		<span class="n">cp</span><span class="o">-&gt;</span><span class="n">ssss_status</span> <span class="o">=</span> <span class="n">S_ILLEGAL</span><span class="p">;</span>
		<span class="n">cp</span><span class="o">-&gt;</span><span class="n">host_flags</span>	<span class="o">=</span> <span class="p">(</span><span class="n">HF_SENSE</span><span class="o">|</span><span class="n">HF_DATA_IN</span><span class="p">);</span>
		<span class="n">cp</span><span class="o">-&gt;</span><span class="n">xerr_status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">cp</span><span class="o">-&gt;</span><span class="n">extra_bytes</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="n">cp</span><span class="o">-&gt;</span><span class="n">phys</span><span class="p">.</span><span class="n">head</span><span class="p">.</span><span class="n">go</span><span class="p">.</span><span class="n">start</span> <span class="o">=</span> <span class="n">cpu_to_scr</span><span class="p">(</span><span class="n">SCRIPTA_BA</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">select</span><span class="p">));</span>

		<span class="cm">/*</span>
<span class="cm">		 *  Requeue the command.</span>
<span class="cm">		 */</span>
		<span class="n">sym_put_start_queue</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">cp</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 *  Give back to upper layer everything we have dequeued.</span>
<span class="cm">		 */</span>
		<span class="n">sym_flush_comp_queue</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *  After a device has accepted some management message </span>
<span class="cm"> *  as BUS DEVICE RESET, ABORT TASK, etc ..., or when </span>
<span class="cm"> *  a device signals a UNIT ATTENTION condition, some </span>
<span class="cm"> *  tasks are thrown away by the device. We are required </span>
<span class="cm"> *  to reflect that on our tasks list since the device </span>
<span class="cm"> *  will never complete these tasks.</span>
<span class="cm"> *</span>
<span class="cm"> *  This function move from the BUSY queue to the COMP </span>
<span class="cm"> *  queue all disconnected CCBs for a given target that </span>
<span class="cm"> *  match the following criteria:</span>
<span class="cm"> *  - lun=-1  means any logical UNIT otherwise a given one.</span>
<span class="cm"> *  - task=-1 means any task, otherwise a given one.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">sym_clear_tasks</span><span class="p">(</span><span class="k">struct</span> <span class="n">sym_hcb</span> <span class="o">*</span><span class="n">np</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cam_status</span><span class="p">,</span> <span class="kt">int</span> <span class="n">target</span><span class="p">,</span> <span class="kt">int</span> <span class="n">lun</span><span class="p">,</span> <span class="kt">int</span> <span class="n">task</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">SYM_QUEHEAD</span> <span class="n">qtmp</span><span class="p">,</span> <span class="o">*</span><span class="n">qp</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sym_ccb</span> <span class="o">*</span><span class="n">cp</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 *  Move the entire BUSY queue to our temporary queue.</span>
<span class="cm">	 */</span>
	<span class="n">sym_que_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">qtmp</span><span class="p">);</span>
	<span class="n">sym_que_splice</span><span class="p">(</span><span class="o">&amp;</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">busy_ccbq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">qtmp</span><span class="p">);</span>
	<span class="n">sym_que_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">busy_ccbq</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 *  Put all CCBs that matches our criteria into </span>
<span class="cm">	 *  the COMP queue and put back other ones into </span>
<span class="cm">	 *  the BUSY queue.</span>
<span class="cm">	 */</span>
	<span class="k">while</span> <span class="p">((</span><span class="n">qp</span> <span class="o">=</span> <span class="n">sym_remque_head</span><span class="p">(</span><span class="o">&amp;</span><span class="n">qtmp</span><span class="p">))</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">;</span>
		<span class="n">cp</span> <span class="o">=</span> <span class="n">sym_que_entry</span><span class="p">(</span><span class="n">qp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sym_ccb</span><span class="p">,</span> <span class="n">link_ccbq</span><span class="p">);</span>
		<span class="n">cmd</span> <span class="o">=</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">cmd</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">host_status</span> <span class="o">!=</span> <span class="n">HS_DISCONNECT</span> <span class="o">||</span>
		    <span class="n">cp</span><span class="o">-&gt;</span><span class="n">target</span> <span class="o">!=</span> <span class="n">target</span>	     <span class="o">||</span>
		    <span class="p">(</span><span class="n">lun</span>  <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">lun</span> <span class="o">!=</span> <span class="n">lun</span><span class="p">)</span>   <span class="o">||</span>
		    <span class="p">(</span><span class="n">task</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span> <span class="o">&amp;&amp;</span> 
			<span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">tag</span> <span class="o">!=</span> <span class="n">NO_TAG</span> <span class="o">&amp;&amp;</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">scsi_smsg</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">!=</span> <span class="n">task</span><span class="p">)))</span> <span class="p">{</span>
			<span class="n">sym_insque_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">link_ccbq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">busy_ccbq</span><span class="p">);</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">sym_insque_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">link_ccbq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">comp_ccbq</span><span class="p">);</span>

		<span class="cm">/* Preserve the software timeout condition */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sym_get_cam_status</span><span class="p">(</span><span class="n">cmd</span><span class="p">)</span> <span class="o">!=</span> <span class="n">DID_TIME_OUT</span><span class="p">)</span>
			<span class="n">sym_set_cam_status</span><span class="p">(</span><span class="n">cmd</span><span class="p">,</span> <span class="n">cam_status</span><span class="p">);</span>
		<span class="o">++</span><span class="n">i</span><span class="p">;</span>
<span class="cp">#if 0</span><span class="c"></span>
<span class="c">printf(&quot;XXXX TASK @%p CLEARED\n&quot;, cp);</span>
<span class="cp">#endif</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">i</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *  chip handler for TASKS recovery</span>
<span class="cm"> *</span>
<span class="cm"> *  We cannot safely abort a command, while the SCRIPTS </span>
<span class="cm"> *  processor is running, since we just would be in race </span>
<span class="cm"> *  with it.</span>
<span class="cm"> *</span>
<span class="cm"> *  As long as we have tasks to abort, we keep the SEM </span>
<span class="cm"> *  bit set in the ISTAT. When this bit is set, the </span>
<span class="cm"> *  SCRIPTS processor interrupts (SIR_SCRIPT_STOPPED) </span>
<span class="cm"> *  each time it enters the scheduler.</span>
<span class="cm"> *</span>
<span class="cm"> *  If we have to reset a target, clear tasks of a unit,</span>
<span class="cm"> *  or to perform the abort of a disconnected job, we </span>
<span class="cm"> *  restart the SCRIPTS for selecting the target. Once </span>
<span class="cm"> *  selected, the SCRIPTS interrupts (SIR_TARGET_SELECTED).</span>
<span class="cm"> *  If it loses arbitration, the SCRIPTS will interrupt again </span>
<span class="cm"> *  the next time it will enter its scheduler, and so on ...</span>
<span class="cm"> *</span>
<span class="cm"> *  On SIR_TARGET_SELECTED, we scan for the more </span>
<span class="cm"> *  appropriate thing to do:</span>
<span class="cm"> *</span>
<span class="cm"> *  - If nothing, we just sent a M_ABORT message to the </span>
<span class="cm"> *    target to get rid of the useless SCSI bus ownership.</span>
<span class="cm"> *    According to the specs, no tasks shall be affected.</span>
<span class="cm"> *  - If the target is to be reset, we send it a M_RESET </span>
<span class="cm"> *    message.</span>
<span class="cm"> *  - If a logical UNIT is to be cleared , we send the </span>
<span class="cm"> *    IDENTIFY(lun) + M_ABORT.</span>
<span class="cm"> *  - If an untagged task is to be aborted, we send the </span>
<span class="cm"> *    IDENTIFY(lun) + M_ABORT.</span>
<span class="cm"> *  - If a tagged task is to be aborted, we send the </span>
<span class="cm"> *    IDENTIFY(lun) + task attributes + M_ABORT_TAG.</span>
<span class="cm"> *</span>
<span class="cm"> *  Once our &#39;kiss of death&#39; :) message has been accepted </span>
<span class="cm"> *  by the target, the SCRIPTS interrupts again </span>
<span class="cm"> *  (SIR_ABORT_SENT). On this interrupt, we complete </span>
<span class="cm"> *  all the CCBs that should have been aborted by the </span>
<span class="cm"> *  target according to our message.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">sym_sir_task_recovery</span><span class="p">(</span><span class="k">struct</span> <span class="n">sym_hcb</span> <span class="o">*</span><span class="n">np</span><span class="p">,</span> <span class="kt">int</span> <span class="n">num</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">SYM_QUEHEAD</span> <span class="o">*</span><span class="n">qp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sym_ccb</span> <span class="o">*</span><span class="n">cp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sym_tcb</span> <span class="o">*</span><span class="n">tp</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span> <span class="cm">/* gcc isn&#39;t quite smart enough yet */</span>
	<span class="k">struct</span> <span class="n">scsi_target</span> <span class="o">*</span><span class="n">starget</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">target</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">lun</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">task</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">k</span><span class="p">;</span>

	<span class="k">switch</span><span class="p">(</span><span class="n">num</span><span class="p">)</span> <span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 *  The SCRIPTS processor stopped before starting</span>
<span class="cm">	 *  the next command in order to allow us to perform </span>
<span class="cm">	 *  some task recovery.</span>
<span class="cm">	 */</span>
	<span class="k">case</span> <span class="n">SIR_SCRIPT_STOPPED</span>:
		<span class="cm">/*</span>
<span class="cm">		 *  Do we have any target to reset or unit to clear ?</span>
<span class="cm">		 */</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">SYM_CONF_MAX_TARGET</span> <span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">tp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">target</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">to_reset</span> <span class="o">||</span> 
			    <span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">lun0p</span> <span class="o">&amp;&amp;</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">lun0p</span><span class="o">-&gt;</span><span class="n">to_clear</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">target</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">lunmp</span><span class="p">)</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="k">for</span> <span class="p">(</span><span class="n">k</span> <span class="o">=</span> <span class="mi">1</span> <span class="p">;</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="n">SYM_CONF_MAX_LUN</span> <span class="p">;</span> <span class="n">k</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">lunmp</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">lunmp</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">to_clear</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">target</span>	<span class="o">=</span> <span class="n">i</span><span class="p">;</span>
					<span class="k">break</span><span class="p">;</span>
				<span class="p">}</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">target</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 *  If not, walk the busy queue for any </span>
<span class="cm">		 *  disconnected CCB to be aborted.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">target</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">FOR_EACH_QUEUED_ELEMENT</span><span class="p">(</span><span class="o">&amp;</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">busy_ccbq</span><span class="p">,</span> <span class="n">qp</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">cp</span> <span class="o">=</span> <span class="n">sym_que_entry</span><span class="p">(</span><span class="n">qp</span><span class="p">,</span><span class="k">struct</span> <span class="n">sym_ccb</span><span class="p">,</span><span class="n">link_ccbq</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">host_status</span> <span class="o">!=</span> <span class="n">HS_DISCONNECT</span><span class="p">)</span>
					<span class="k">continue</span><span class="p">;</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">to_abort</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">target</span> <span class="o">=</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">target</span><span class="p">;</span>
					<span class="k">break</span><span class="p">;</span>
				<span class="p">}</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 *  If some target is to be selected, </span>
<span class="cm">		 *  prepare and start the selection.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">target</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">tp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">target</span><span class="p">[</span><span class="n">target</span><span class="p">];</span>
			<span class="n">np</span><span class="o">-&gt;</span><span class="n">abrt_sel</span><span class="p">.</span><span class="n">sel_id</span>	<span class="o">=</span> <span class="n">target</span><span class="p">;</span>
			<span class="n">np</span><span class="o">-&gt;</span><span class="n">abrt_sel</span><span class="p">.</span><span class="n">sel_scntl3</span> <span class="o">=</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">.</span><span class="n">wval</span><span class="p">;</span>
			<span class="n">np</span><span class="o">-&gt;</span><span class="n">abrt_sel</span><span class="p">.</span><span class="n">sel_sxfer</span>  <span class="o">=</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">.</span><span class="n">sval</span><span class="p">;</span>
			<span class="n">OUTL</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">nc_dsa</span><span class="p">,</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">hcb_ba</span><span class="p">);</span>
			<span class="n">OUTL_DSP</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">SCRIPTB_BA</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">sel_for_abort</span><span class="p">));</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 *  Now look for a CCB to abort that haven&#39;t started yet.</span>
<span class="cm">		 *  Btw, the SCRIPTS processor is still stopped, so </span>
<span class="cm">		 *  we are not in race.</span>
<span class="cm">		 */</span>
		<span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">cp</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">FOR_EACH_QUEUED_ELEMENT</span><span class="p">(</span><span class="o">&amp;</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">busy_ccbq</span><span class="p">,</span> <span class="n">qp</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">cp</span> <span class="o">=</span> <span class="n">sym_que_entry</span><span class="p">(</span><span class="n">qp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sym_ccb</span><span class="p">,</span> <span class="n">link_ccbq</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">host_status</span> <span class="o">!=</span> <span class="n">HS_BUSY</span> <span class="o">&amp;&amp;</span>
			    <span class="n">cp</span><span class="o">-&gt;</span><span class="n">host_status</span> <span class="o">!=</span> <span class="n">HS_NEGOTIATE</span><span class="p">)</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">to_abort</span><span class="p">)</span>
				<span class="k">continue</span><span class="p">;</span>
<span class="cp">#ifdef SYM_CONF_IARB_SUPPORT</span>
			<span class="cm">/*</span>
<span class="cm">			 *    If we are using IMMEDIATE ARBITRATION, we donnot </span>
<span class="cm">			 *    want to cancel the last queued CCB, since the </span>
<span class="cm">			 *    SCRIPTS may have anticipated the selection.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">cp</span> <span class="o">==</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">last_cp</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">cp</span><span class="o">-&gt;</span><span class="n">to_abort</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="p">}</span>
<span class="cp">#endif</span>
			<span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>	<span class="cm">/* Means we have found some */</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 *  We are done, so we donnot need </span>
<span class="cm">			 *  to synchronize with the SCRIPTS anylonger.</span>
<span class="cm">			 *  Remove the SEM flag from the ISTAT.</span>
<span class="cm">			 */</span>
			<span class="n">np</span><span class="o">-&gt;</span><span class="n">istat_sem</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">OUTB</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">nc_istat</span><span class="p">,</span> <span class="n">SIGP</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/*</span>
<span class="cm">		 *  Compute index of next position in the start </span>
<span class="cm">		 *  queue the SCRIPTS intends to start and dequeue </span>
<span class="cm">		 *  all CCBs for that device that haven&#39;t been started.</span>
<span class="cm">		 */</span>
		<span class="n">i</span> <span class="o">=</span> <span class="p">(</span><span class="n">INL</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">nc_scratcha</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">squeue_ba</span><span class="p">)</span> <span class="o">/</span> <span class="mi">4</span><span class="p">;</span>
		<span class="n">i</span> <span class="o">=</span> <span class="n">sym_dequeue_from_squeue</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">target</span><span class="p">,</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">lun</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 *  Make sure at least our IO to abort has been dequeued.</span>
<span class="cm">		 */</span>
<span class="cp">#ifndef SYM_OPT_HANDLE_DEVICE_QUEUEING</span>
		<span class="n">assert</span><span class="p">(</span><span class="n">i</span> <span class="o">&amp;&amp;</span> <span class="n">sym_get_cam_status</span><span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">cmd</span><span class="p">)</span> <span class="o">==</span> <span class="n">DID_SOFT_ERROR</span><span class="p">);</span>
<span class="cp">#else</span>
		<span class="n">sym_remque</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">link_ccbq</span><span class="p">);</span>
		<span class="n">sym_insque_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">link_ccbq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">comp_ccbq</span><span class="p">);</span>
<span class="cp">#endif</span>
		<span class="cm">/*</span>
<span class="cm">		 *  Keep track in cam status of the reason of the abort.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">to_abort</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span>
			<span class="n">sym_set_cam_status</span><span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">cmd</span><span class="p">,</span> <span class="n">DID_TIME_OUT</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">sym_set_cam_status</span><span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">cmd</span><span class="p">,</span> <span class="n">DID_ABORT</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 *  Complete with error everything that we have dequeued.</span>
<span class="cm">	 	 */</span>
		<span class="n">sym_flush_comp_queue</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 *  The SCRIPTS processor has selected a target </span>
<span class="cm">	 *  we may have some manual recovery to perform for.</span>
<span class="cm">	 */</span>
	<span class="k">case</span> <span class="n">SIR_TARGET_SELECTED</span>:
		<span class="n">target</span> <span class="o">=</span> <span class="n">INB</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">nc_sdid</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xf</span><span class="p">;</span>
		<span class="n">tp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">target</span><span class="p">[</span><span class="n">target</span><span class="p">];</span>

		<span class="n">np</span><span class="o">-&gt;</span><span class="n">abrt_tbl</span><span class="p">.</span><span class="n">addr</span> <span class="o">=</span> <span class="n">cpu_to_scr</span><span class="p">(</span><span class="n">vtobus</span><span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">abrt_msg</span><span class="p">));</span>

		<span class="cm">/*</span>
<span class="cm">		 *  If the target is to be reset, prepare a </span>
<span class="cm">		 *  M_RESET message and clear the to_reset flag </span>
<span class="cm">		 *  since we donnot expect this operation to fail.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">to_reset</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">np</span><span class="o">-&gt;</span><span class="n">abrt_msg</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">M_RESET</span><span class="p">;</span>
			<span class="n">np</span><span class="o">-&gt;</span><span class="n">abrt_tbl</span><span class="p">.</span><span class="n">size</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">tp</span><span class="o">-&gt;</span><span class="n">to_reset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 *  Otherwise, look for some logical unit to be cleared.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">lun0p</span> <span class="o">&amp;&amp;</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">lun0p</span><span class="o">-&gt;</span><span class="n">to_clear</span><span class="p">)</span>
			<span class="n">lun</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">lunmp</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">for</span> <span class="p">(</span><span class="n">k</span> <span class="o">=</span> <span class="mi">1</span> <span class="p">;</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="n">SYM_CONF_MAX_LUN</span> <span class="p">;</span> <span class="n">k</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">lunmp</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">lunmp</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">to_clear</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">lun</span> <span class="o">=</span> <span class="n">k</span><span class="p">;</span>
					<span class="k">break</span><span class="p">;</span>
				<span class="p">}</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 *  If a logical unit is to be cleared, prepare </span>
<span class="cm">		 *  an IDENTIFY(lun) + ABORT MESSAGE.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">lun</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">sym_lcb</span> <span class="o">*</span><span class="n">lp</span> <span class="o">=</span> <span class="n">sym_lp</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">lun</span><span class="p">);</span>
			<span class="n">lp</span><span class="o">-&gt;</span><span class="n">to_clear</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="cm">/* We don&#39;t expect to fail here */</span>
			<span class="n">np</span><span class="o">-&gt;</span><span class="n">abrt_msg</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">IDENTIFY</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">lun</span><span class="p">);</span>
			<span class="n">np</span><span class="o">-&gt;</span><span class="n">abrt_msg</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">M_ABORT</span><span class="p">;</span>
			<span class="n">np</span><span class="o">-&gt;</span><span class="n">abrt_tbl</span><span class="p">.</span><span class="n">size</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 *  Otherwise, look for some disconnected job to </span>
<span class="cm">		 *  abort for this target.</span>
<span class="cm">		 */</span>
		<span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">cp</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">FOR_EACH_QUEUED_ELEMENT</span><span class="p">(</span><span class="o">&amp;</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">busy_ccbq</span><span class="p">,</span> <span class="n">qp</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">cp</span> <span class="o">=</span> <span class="n">sym_que_entry</span><span class="p">(</span><span class="n">qp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sym_ccb</span><span class="p">,</span> <span class="n">link_ccbq</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">host_status</span> <span class="o">!=</span> <span class="n">HS_DISCONNECT</span><span class="p">)</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">target</span> <span class="o">!=</span> <span class="n">target</span><span class="p">)</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">to_abort</span><span class="p">)</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>	<span class="cm">/* Means we have some */</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 *  If we have none, probably since the device has </span>
<span class="cm">		 *  completed the command before we won abitration,</span>
<span class="cm">		 *  send a M_ABORT message without IDENTIFY.</span>
<span class="cm">		 *  According to the specs, the device must just </span>
<span class="cm">		 *  disconnect the BUS and not abort any task.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">np</span><span class="o">-&gt;</span><span class="n">abrt_msg</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">M_ABORT</span><span class="p">;</span>
			<span class="n">np</span><span class="o">-&gt;</span><span class="n">abrt_tbl</span><span class="p">.</span><span class="n">size</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 *  We have some task to abort.</span>
<span class="cm">		 *  Set the IDENTIFY(lun)</span>
<span class="cm">		 */</span>
		<span class="n">np</span><span class="o">-&gt;</span><span class="n">abrt_msg</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">IDENTIFY</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">lun</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 *  If we want to abort an untagged command, we </span>
<span class="cm">		 *  will send a IDENTIFY + M_ABORT.</span>
<span class="cm">		 *  Otherwise (tagged command), we will send </span>
<span class="cm">		 *  a IDENTITFY + task attributes + ABORT TAG.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">tag</span> <span class="o">==</span> <span class="n">NO_TAG</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">np</span><span class="o">-&gt;</span><span class="n">abrt_msg</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">M_ABORT</span><span class="p">;</span>
			<span class="n">np</span><span class="o">-&gt;</span><span class="n">abrt_tbl</span><span class="p">.</span><span class="n">size</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">np</span><span class="o">-&gt;</span><span class="n">abrt_msg</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">scsi_smsg</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
			<span class="n">np</span><span class="o">-&gt;</span><span class="n">abrt_msg</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">scsi_smsg</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
			<span class="n">np</span><span class="o">-&gt;</span><span class="n">abrt_msg</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">M_ABORT_TAG</span><span class="p">;</span>
			<span class="n">np</span><span class="o">-&gt;</span><span class="n">abrt_tbl</span><span class="p">.</span><span class="n">size</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/*</span>
<span class="cm">		 *  Keep track of software timeout condition, since the </span>
<span class="cm">		 *  peripheral driver may not count retries on abort </span>
<span class="cm">		 *  conditions not due to timeout.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">to_abort</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span>
			<span class="n">sym_set_cam_status</span><span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">cmd</span><span class="p">,</span> <span class="n">DID_TIME_OUT</span><span class="p">);</span>
		<span class="n">cp</span><span class="o">-&gt;</span><span class="n">to_abort</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="cm">/* We donnot expect to fail here */</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 *  The target has accepted our message and switched </span>
<span class="cm">	 *  to BUS FREE phase as we expected.</span>
<span class="cm">	 */</span>
	<span class="k">case</span> <span class="n">SIR_ABORT_SENT</span>:
		<span class="n">target</span> <span class="o">=</span> <span class="n">INB</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">nc_sdid</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xf</span><span class="p">;</span>
		<span class="n">tp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">target</span><span class="p">[</span><span class="n">target</span><span class="p">];</span>
		<span class="n">starget</span> <span class="o">=</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">starget</span><span class="p">;</span>
		
		<span class="cm">/*</span>
<span class="cm">		**  If we didn&#39;t abort anything, leave here.</span>
<span class="cm">		*/</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">abrt_msg</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">M_ABORT</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 *  If we sent a M_RESET, then a hardware reset has </span>
<span class="cm">		 *  been performed by the target.</span>
<span class="cm">		 *  - Reset everything to async 8 bit</span>
<span class="cm">		 *  - Tell ourself to negotiate next time :-)</span>
<span class="cm">		 *  - Prepare to clear all disconnected CCBs for </span>
<span class="cm">		 *    this target from our task list (lun=task=-1)</span>
<span class="cm">		 */</span>
		<span class="n">lun</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">task</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">abrt_msg</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">M_RESET</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">tp</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">.</span><span class="n">sval</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">tp</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">.</span><span class="n">wval</span> <span class="o">=</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">rv_scntl3</span><span class="p">;</span>
			<span class="n">tp</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">.</span><span class="n">uval</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">spi_period</span><span class="p">(</span><span class="n">starget</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">spi_offset</span><span class="p">(</span><span class="n">starget</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">spi_width</span><span class="p">(</span><span class="n">starget</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">spi_iu</span><span class="p">(</span><span class="n">starget</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">spi_dt</span><span class="p">(</span><span class="n">starget</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">spi_qas</span><span class="p">(</span><span class="n">starget</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">tp</span><span class="o">-&gt;</span><span class="n">tgoal</span><span class="p">.</span><span class="n">check_nego</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">tp</span><span class="o">-&gt;</span><span class="n">tgoal</span><span class="p">.</span><span class="n">renego</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 *  Otherwise, check for the LUN and TASK(s) </span>
<span class="cm">		 *  concerned by the cancelation.</span>
<span class="cm">		 *  If it is not ABORT_TAG then it is CLEAR_QUEUE </span>
<span class="cm">		 *  or an ABORT message :-)</span>
<span class="cm">		 */</span>
		<span class="k">else</span> <span class="p">{</span>
			<span class="n">lun</span> <span class="o">=</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">abrt_msg</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0x3f</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">abrt_msg</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">M_ABORT_TAG</span><span class="p">)</span>
				<span class="n">task</span> <span class="o">=</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">abrt_msg</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 *  Complete all the CCBs the device should have </span>
<span class="cm">		 *  aborted due to our &#39;kiss of death&#39; message.</span>
<span class="cm">		 */</span>
		<span class="n">i</span> <span class="o">=</span> <span class="p">(</span><span class="n">INL</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">nc_scratcha</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">squeue_ba</span><span class="p">)</span> <span class="o">/</span> <span class="mi">4</span><span class="p">;</span>
		<span class="n">sym_dequeue_from_squeue</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">lun</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>
		<span class="n">sym_clear_tasks</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">DID_ABORT</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">lun</span><span class="p">,</span> <span class="n">task</span><span class="p">);</span>
		<span class="n">sym_flush_comp_queue</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

 		<span class="cm">/*</span>
<span class="cm">		 *  If we sent a BDR, make upper layer aware of that.</span>
<span class="cm"> 		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">abrt_msg</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">M_RESET</span><span class="p">)</span>
			<span class="n">starget_printk</span><span class="p">(</span><span class="n">KERN_NOTICE</span><span class="p">,</span> <span class="n">starget</span><span class="p">,</span>
							<span class="s">&quot;has been reset</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 *  Print to the log the message we intend to send.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">num</span> <span class="o">==</span> <span class="n">SIR_TARGET_SELECTED</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">starget</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;control msgout:&quot;</span><span class="p">);</span>
		<span class="n">sym_printl_hex</span><span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">abrt_msg</span><span class="p">,</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">abrt_tbl</span><span class="p">.</span><span class="n">size</span><span class="p">);</span>
		<span class="n">np</span><span class="o">-&gt;</span><span class="n">abrt_tbl</span><span class="p">.</span><span class="n">size</span> <span class="o">=</span> <span class="n">cpu_to_scr</span><span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">abrt_tbl</span><span class="p">.</span><span class="n">size</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 *  Let the SCRIPTS processor continue.</span>
<span class="cm">	 */</span>
	<span class="n">OUTONB_STD</span><span class="p">();</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *  Gerard&#39;s alchemy:) that deals with with the data </span>
<span class="cm"> *  pointer for both MDP and the residual calculation.</span>
<span class="cm"> *</span>
<span class="cm"> *  I didn&#39;t want to bloat the code by more than 200 </span>
<span class="cm"> *  lines for the handling of both MDP and the residual.</span>
<span class="cm"> *  This has been achieved by using a data pointer </span>
<span class="cm"> *  representation consisting in an index in the data </span>
<span class="cm"> *  array (dp_sg) and a negative offset (dp_ofs) that </span>
<span class="cm"> *  have the following meaning:</span>
<span class="cm"> *</span>
<span class="cm"> *  - dp_sg = SYM_CONF_MAX_SG</span>
<span class="cm"> *    we are at the end of the data script.</span>
<span class="cm"> *  - dp_sg &lt; SYM_CONF_MAX_SG</span>
<span class="cm"> *    dp_sg points to the next entry of the scatter array </span>
<span class="cm"> *    we want to transfer.</span>
<span class="cm"> *  - dp_ofs &lt; 0</span>
<span class="cm"> *    dp_ofs represents the residual of bytes of the </span>
<span class="cm"> *    previous entry scatter entry we will send first.</span>
<span class="cm"> *  - dp_ofs = 0</span>
<span class="cm"> *    no residual to send first.</span>
<span class="cm"> *</span>
<span class="cm"> *  The function sym_evaluate_dp() accepts an arbitray </span>
<span class="cm"> *  offset (basically from the MDP message) and returns </span>
<span class="cm"> *  the corresponding values of dp_sg and dp_ofs.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">sym_evaluate_dp</span><span class="p">(</span><span class="k">struct</span> <span class="n">sym_hcb</span> <span class="o">*</span><span class="n">np</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sym_ccb</span> <span class="o">*</span><span class="n">cp</span><span class="p">,</span> <span class="n">u32</span> <span class="n">scr</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">ofs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span>	<span class="n">dp_scr</span><span class="p">;</span>
	<span class="kt">int</span>	<span class="n">dp_ofs</span><span class="p">,</span> <span class="n">dp_sg</span><span class="p">,</span> <span class="n">dp_sgmin</span><span class="p">;</span>
	<span class="kt">int</span>	<span class="n">tmp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sym_pmc</span> <span class="o">*</span><span class="n">pm</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 *  Compute the resulted data pointer in term of a script </span>
<span class="cm">	 *  address within some DATA script and a signed byte offset.</span>
<span class="cm">	 */</span>
	<span class="n">dp_scr</span> <span class="o">=</span> <span class="n">scr</span><span class="p">;</span>
	<span class="n">dp_ofs</span> <span class="o">=</span> <span class="o">*</span><span class="n">ofs</span><span class="p">;</span>
	<span class="k">if</span>	<span class="p">(</span><span class="n">dp_scr</span> <span class="o">==</span> <span class="n">SCRIPTA_BA</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">pm0_data</span><span class="p">))</span>
		<span class="n">pm</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">phys</span><span class="p">.</span><span class="n">pm0</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">dp_scr</span> <span class="o">==</span> <span class="n">SCRIPTA_BA</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">pm1_data</span><span class="p">))</span>
		<span class="n">pm</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">phys</span><span class="p">.</span><span class="n">pm1</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">pm</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pm</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dp_scr</span>  <span class="o">=</span> <span class="n">scr_to_cpu</span><span class="p">(</span><span class="n">pm</span><span class="o">-&gt;</span><span class="n">ret</span><span class="p">);</span>
		<span class="n">dp_ofs</span> <span class="o">-=</span> <span class="n">scr_to_cpu</span><span class="p">(</span><span class="n">pm</span><span class="o">-&gt;</span><span class="n">sg</span><span class="p">.</span><span class="n">size</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x00ffffff</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 *  If we are auto-sensing, then we are done.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">host_flags</span> <span class="o">&amp;</span> <span class="n">HF_SENSE</span><span class="p">)</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">ofs</span> <span class="o">=</span> <span class="n">dp_ofs</span><span class="p">;</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 *  Deduce the index of the sg entry.</span>
<span class="cm">	 *  Keep track of the index of the first valid entry.</span>
<span class="cm">	 *  If result is dp_sg = SYM_CONF_MAX_SG, then we are at the </span>
<span class="cm">	 *  end of the data.</span>
<span class="cm">	 */</span>
	<span class="n">tmp</span> <span class="o">=</span> <span class="n">scr_to_cpu</span><span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">goalp</span><span class="p">);</span>
	<span class="n">dp_sg</span> <span class="o">=</span> <span class="n">SYM_CONF_MAX_SG</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dp_scr</span> <span class="o">!=</span> <span class="n">tmp</span><span class="p">)</span>
		<span class="n">dp_sg</span> <span class="o">-=</span> <span class="p">(</span><span class="n">tmp</span> <span class="o">-</span> <span class="mi">8</span> <span class="o">-</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">dp_scr</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="mi">4</span><span class="p">);</span>
	<span class="n">dp_sgmin</span> <span class="o">=</span> <span class="n">SYM_CONF_MAX_SG</span> <span class="o">-</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">segments</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 *  Move to the sg entry the data pointer belongs to.</span>
<span class="cm">	 *</span>
<span class="cm">	 *  If we are inside the data area, we expect result to be:</span>
<span class="cm">	 *</span>
<span class="cm">	 *  Either,</span>
<span class="cm">	 *      dp_ofs = 0 and dp_sg is the index of the sg entry</span>
<span class="cm">	 *      the data pointer belongs to (or the end of the data)</span>
<span class="cm">	 *  Or,</span>
<span class="cm">	 *      dp_ofs &lt; 0 and dp_sg is the index of the sg entry </span>
<span class="cm">	 *      the data pointer belongs to + 1.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dp_ofs</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">n</span><span class="p">;</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">dp_sg</span> <span class="o">&gt;</span> <span class="n">dp_sgmin</span><span class="p">)</span> <span class="p">{</span>
			<span class="o">--</span><span class="n">dp_sg</span><span class="p">;</span>
			<span class="n">tmp</span> <span class="o">=</span> <span class="n">scr_to_cpu</span><span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">phys</span><span class="p">.</span><span class="n">data</span><span class="p">[</span><span class="n">dp_sg</span><span class="p">].</span><span class="n">size</span><span class="p">);</span>
			<span class="n">n</span> <span class="o">=</span> <span class="n">dp_ofs</span> <span class="o">+</span> <span class="p">(</span><span class="n">tmp</span> <span class="o">&amp;</span> <span class="mh">0xffffff</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="o">++</span><span class="n">dp_sg</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">dp_ofs</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">dp_ofs</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">dp_sg</span> <span class="o">&lt;</span> <span class="n">SYM_CONF_MAX_SG</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">tmp</span> <span class="o">=</span> <span class="n">scr_to_cpu</span><span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">phys</span><span class="p">.</span><span class="n">data</span><span class="p">[</span><span class="n">dp_sg</span><span class="p">].</span><span class="n">size</span><span class="p">);</span>
			<span class="n">dp_ofs</span> <span class="o">-=</span> <span class="p">(</span><span class="n">tmp</span> <span class="o">&amp;</span> <span class="mh">0xffffff</span><span class="p">);</span>
			<span class="o">++</span><span class="n">dp_sg</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">dp_ofs</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 *  Make sure the data pointer is inside the data area.</span>
<span class="cm">	 *  If not, return some error.</span>
<span class="cm">	 */</span>
	<span class="k">if</span>	<span class="p">(</span><span class="n">dp_sg</span> <span class="o">&lt;</span> <span class="n">dp_sgmin</span> <span class="o">||</span> <span class="p">(</span><span class="n">dp_sg</span> <span class="o">==</span> <span class="n">dp_sgmin</span> <span class="o">&amp;&amp;</span> <span class="n">dp_ofs</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out_err</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span>	<span class="p">(</span><span class="n">dp_sg</span> <span class="o">&gt;</span> <span class="n">SYM_CONF_MAX_SG</span> <span class="o">||</span>
		 <span class="p">(</span><span class="n">dp_sg</span> <span class="o">==</span> <span class="n">SYM_CONF_MAX_SG</span> <span class="o">&amp;&amp;</span> <span class="n">dp_ofs</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out_err</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 *  Save the extreme pointer if needed.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dp_sg</span> <span class="o">&gt;</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">ext_sg</span> <span class="o">||</span>
            <span class="p">(</span><span class="n">dp_sg</span> <span class="o">==</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">ext_sg</span> <span class="o">&amp;&amp;</span> <span class="n">dp_ofs</span> <span class="o">&gt;</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">ext_ofs</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">cp</span><span class="o">-&gt;</span><span class="n">ext_sg</span>  <span class="o">=</span> <span class="n">dp_sg</span><span class="p">;</span>
		<span class="n">cp</span><span class="o">-&gt;</span><span class="n">ext_ofs</span> <span class="o">=</span> <span class="n">dp_ofs</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 *  Return data.</span>
<span class="cm">	 */</span>
	<span class="o">*</span><span class="n">ofs</span> <span class="o">=</span> <span class="n">dp_ofs</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">dp_sg</span><span class="p">;</span>

<span class="nl">out_err:</span>
	<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *  chip handler for MODIFY DATA POINTER MESSAGE</span>
<span class="cm"> *</span>
<span class="cm"> *  We also call this function on IGNORE WIDE RESIDUE </span>
<span class="cm"> *  messages that do not match a SWIDE full condition.</span>
<span class="cm"> *  Btw, we assume in that situation that such a message </span>
<span class="cm"> *  is equivalent to a MODIFY DATA POINTER (offset=-1).</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">sym_modify_dp</span><span class="p">(</span><span class="k">struct</span> <span class="n">sym_hcb</span> <span class="o">*</span><span class="n">np</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sym_tcb</span> <span class="o">*</span><span class="n">tp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sym_ccb</span> <span class="o">*</span><span class="n">cp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">ofs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">dp_ofs</span>	<span class="o">=</span> <span class="n">ofs</span><span class="p">;</span>
	<span class="n">u32</span>	<span class="n">dp_scr</span>	<span class="o">=</span> <span class="n">sym_get_script_dp</span> <span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">cp</span><span class="p">);</span>
	<span class="n">u32</span>	<span class="n">dp_ret</span><span class="p">;</span>
	<span class="n">u32</span>	<span class="n">tmp</span><span class="p">;</span>
	<span class="n">u_char</span>	<span class="n">hflags</span><span class="p">;</span>
	<span class="kt">int</span>	<span class="n">dp_sg</span><span class="p">;</span>
	<span class="k">struct</span>	<span class="n">sym_pmc</span> <span class="o">*</span><span class="n">pm</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 *  Not supported for auto-sense.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">host_flags</span> <span class="o">&amp;</span> <span class="n">HF_SENSE</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_reject</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 *  Apply our alchemy:) (see comments in sym_evaluate_dp()), </span>
<span class="cm">	 *  to the resulted data pointer.</span>
<span class="cm">	 */</span>
	<span class="n">dp_sg</span> <span class="o">=</span> <span class="n">sym_evaluate_dp</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">cp</span><span class="p">,</span> <span class="n">dp_scr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dp_ofs</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dp_sg</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_reject</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 *  And our alchemy:) allows to easily calculate the data </span>
<span class="cm">	 *  script address we want to return for the next data phase.</span>
<span class="cm">	 */</span>
	<span class="n">dp_ret</span> <span class="o">=</span> <span class="n">cpu_to_scr</span><span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">goalp</span><span class="p">);</span>
	<span class="n">dp_ret</span> <span class="o">=</span> <span class="n">dp_ret</span> <span class="o">-</span> <span class="mi">8</span> <span class="o">-</span> <span class="p">(</span><span class="n">SYM_CONF_MAX_SG</span> <span class="o">-</span> <span class="n">dp_sg</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="mi">4</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 *  If offset / scatter entry is zero we donnot need </span>
<span class="cm">	 *  a context for the new current data pointer.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dp_ofs</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dp_scr</span> <span class="o">=</span> <span class="n">dp_ret</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out_ok</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 *  Get a context for the new current data pointer.</span>
<span class="cm">	 */</span>
	<span class="n">hflags</span> <span class="o">=</span> <span class="n">INB</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">HF_PRT</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">hflags</span> <span class="o">&amp;</span> <span class="n">HF_DP_SAVED</span><span class="p">)</span>
		<span class="n">hflags</span> <span class="o">^=</span> <span class="n">HF_ACT_PM</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">hflags</span> <span class="o">&amp;</span> <span class="n">HF_ACT_PM</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">pm</span>  <span class="o">=</span> <span class="o">&amp;</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">phys</span><span class="p">.</span><span class="n">pm0</span><span class="p">;</span>
		<span class="n">dp_scr</span> <span class="o">=</span> <span class="n">SCRIPTA_BA</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">pm0_data</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="n">pm</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">phys</span><span class="p">.</span><span class="n">pm1</span><span class="p">;</span>
		<span class="n">dp_scr</span> <span class="o">=</span> <span class="n">SCRIPTA_BA</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">pm1_data</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">hflags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">HF_DP_SAVED</span><span class="p">);</span>

	<span class="n">OUTB</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">HF_PRT</span><span class="p">,</span> <span class="n">hflags</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 *  Set up the new current data pointer.</span>
<span class="cm">	 *  ofs &lt; 0 there, and for the next data phase, we </span>
<span class="cm">	 *  want to transfer part of the data of the sg entry </span>
<span class="cm">	 *  corresponding to index dp_sg-1 prior to returning </span>
<span class="cm">	 *  to the main data script.</span>
<span class="cm">	 */</span>
	<span class="n">pm</span><span class="o">-&gt;</span><span class="n">ret</span> <span class="o">=</span> <span class="n">cpu_to_scr</span><span class="p">(</span><span class="n">dp_ret</span><span class="p">);</span>
	<span class="n">tmp</span>  <span class="o">=</span> <span class="n">scr_to_cpu</span><span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">phys</span><span class="p">.</span><span class="n">data</span><span class="p">[</span><span class="n">dp_sg</span><span class="o">-</span><span class="mi">1</span><span class="p">].</span><span class="n">addr</span><span class="p">);</span>
	<span class="n">tmp</span> <span class="o">+=</span> <span class="n">scr_to_cpu</span><span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">phys</span><span class="p">.</span><span class="n">data</span><span class="p">[</span><span class="n">dp_sg</span><span class="o">-</span><span class="mi">1</span><span class="p">].</span><span class="n">size</span><span class="p">)</span> <span class="o">+</span> <span class="n">dp_ofs</span><span class="p">;</span>
	<span class="n">pm</span><span class="o">-&gt;</span><span class="n">sg</span><span class="p">.</span><span class="n">addr</span> <span class="o">=</span> <span class="n">cpu_to_scr</span><span class="p">(</span><span class="n">tmp</span><span class="p">);</span>
	<span class="n">pm</span><span class="o">-&gt;</span><span class="n">sg</span><span class="p">.</span><span class="n">size</span> <span class="o">=</span> <span class="n">cpu_to_scr</span><span class="p">(</span><span class="o">-</span><span class="n">dp_ofs</span><span class="p">);</span>

<span class="nl">out_ok:</span>
	<span class="n">sym_set_script_dp</span> <span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">cp</span><span class="p">,</span> <span class="n">dp_scr</span><span class="p">);</span>
	<span class="n">OUTL_DSP</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">SCRIPTA_BA</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">clrack</span><span class="p">));</span>
	<span class="k">return</span><span class="p">;</span>

<span class="nl">out_reject:</span>
	<span class="n">OUTL_DSP</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">SCRIPTB_BA</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">msg_bad</span><span class="p">));</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> *  chip calculation of the data residual.</span>
<span class="cm"> *</span>
<span class="cm"> *  As I used to say, the requirement of data residual </span>
<span class="cm"> *  in SCSI is broken, useless and cannot be achieved </span>
<span class="cm"> *  without huge complexity.</span>
<span class="cm"> *  But most OSes and even the official CAM require it.</span>
<span class="cm"> *  When stupidity happens to be so widely spread inside </span>
<span class="cm"> *  a community, it gets hard to convince.</span>
<span class="cm"> *</span>
<span class="cm"> *  Anyway, I don&#39;t care, since I am not going to use </span>
<span class="cm"> *  any software that considers this data residual as </span>
<span class="cm"> *  a relevant information. :)</span>
<span class="cm"> */</span>

<span class="kt">int</span> <span class="n">sym_compute_residual</span><span class="p">(</span><span class="k">struct</span> <span class="n">sym_hcb</span> <span class="o">*</span><span class="n">np</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sym_ccb</span> <span class="o">*</span><span class="n">cp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">dp_sg</span><span class="p">,</span> <span class="n">dp_sgmin</span><span class="p">,</span> <span class="n">resid</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">dp_ofs</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 *  Check for some data lost or just thrown away.</span>
<span class="cm">	 *  We are not required to be quite accurate in this </span>
<span class="cm">	 *  situation. Btw, if we are odd for output and the </span>
<span class="cm">	 *  device claims some more data, it may well happen </span>
<span class="cm">	 *  than our residual be zero. :-)</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">xerr_status</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">XE_EXTRA_DATA</span><span class="o">|</span><span class="n">XE_SODL_UNRUN</span><span class="o">|</span><span class="n">XE_SWIDE_OVRUN</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">xerr_status</span> <span class="o">&amp;</span> <span class="n">XE_EXTRA_DATA</span><span class="p">)</span>
			<span class="n">resid</span> <span class="o">-=</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">extra_bytes</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">xerr_status</span> <span class="o">&amp;</span> <span class="n">XE_SODL_UNRUN</span><span class="p">)</span>
			<span class="o">++</span><span class="n">resid</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">xerr_status</span> <span class="o">&amp;</span> <span class="n">XE_SWIDE_OVRUN</span><span class="p">)</span>
			<span class="o">--</span><span class="n">resid</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 *  If all data has been transferred,</span>
<span class="cm">	 *  there is no residual.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">phys</span><span class="p">.</span><span class="n">head</span><span class="p">.</span><span class="n">lastp</span> <span class="o">==</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">goalp</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">resid</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 *  If no data transfer occurs, or if the data</span>
<span class="cm">	 *  pointer is weird, return full residual.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">startp</span> <span class="o">==</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">phys</span><span class="p">.</span><span class="n">head</span><span class="p">.</span><span class="n">lastp</span> <span class="o">||</span>
	    <span class="n">sym_evaluate_dp</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">cp</span><span class="p">,</span> <span class="n">scr_to_cpu</span><span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">phys</span><span class="p">.</span><span class="n">head</span><span class="p">.</span><span class="n">lastp</span><span class="p">),</span>
			    <span class="o">&amp;</span><span class="n">dp_ofs</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">data_len</span> <span class="o">-</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">odd_byte_adjustment</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 *  If we were auto-sensing, then we are done.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">host_flags</span> <span class="o">&amp;</span> <span class="n">HF_SENSE</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">dp_ofs</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 *  We are now full comfortable in the computation </span>
<span class="cm">	 *  of the data residual (2&#39;s complement).</span>
<span class="cm">	 */</span>
	<span class="n">dp_sgmin</span> <span class="o">=</span> <span class="n">SYM_CONF_MAX_SG</span> <span class="o">-</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">segments</span><span class="p">;</span>
	<span class="n">resid</span> <span class="o">=</span> <span class="o">-</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">ext_ofs</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">dp_sg</span> <span class="o">=</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">ext_sg</span><span class="p">;</span> <span class="n">dp_sg</span> <span class="o">&lt;</span> <span class="n">SYM_CONF_MAX_SG</span><span class="p">;</span> <span class="o">++</span><span class="n">dp_sg</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">u_int</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">scr_to_cpu</span><span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">phys</span><span class="p">.</span><span class="n">data</span><span class="p">[</span><span class="n">dp_sg</span><span class="p">].</span><span class="n">size</span><span class="p">);</span>
		<span class="n">resid</span> <span class="o">+=</span> <span class="p">(</span><span class="n">tmp</span> <span class="o">&amp;</span> <span class="mh">0xffffff</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">resid</span> <span class="o">-=</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">odd_byte_adjustment</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 *  Hopefully, the result is not too wrong.</span>
<span class="cm">	 */</span>
	<span class="k">return</span> <span class="n">resid</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *  Negotiation for WIDE and SYNCHRONOUS DATA TRANSFER.</span>
<span class="cm"> *</span>
<span class="cm"> *  When we try to negotiate, we append the negotiation message</span>
<span class="cm"> *  to the identify and (maybe) simple tag message.</span>
<span class="cm"> *  The host status field is set to HS_NEGOTIATE to mark this</span>
<span class="cm"> *  situation.</span>
<span class="cm"> *</span>
<span class="cm"> *  If the target doesn&#39;t answer this message immediately</span>
<span class="cm"> *  (as required by the standard), the SIR_NEGO_FAILED interrupt</span>
<span class="cm"> *  will be raised eventually.</span>
<span class="cm"> *  The handler removes the HS_NEGOTIATE status, and sets the</span>
<span class="cm"> *  negotiated value to the default (async / nowide).</span>
<span class="cm"> *</span>
<span class="cm"> *  If we receive a matching answer immediately, we check it</span>
<span class="cm"> *  for validity, and set the values.</span>
<span class="cm"> *</span>
<span class="cm"> *  If we receive a Reject message immediately, we assume the</span>
<span class="cm"> *  negotiation has failed, and fall back to standard values.</span>
<span class="cm"> *</span>
<span class="cm"> *  If we receive a negotiation message while not in HS_NEGOTIATE</span>
<span class="cm"> *  state, it&#39;s a target initiated negotiation. We prepare a</span>
<span class="cm"> *  (hopefully) valid answer, set our parameters, and send back </span>
<span class="cm"> *  this answer to the target.</span>
<span class="cm"> *</span>
<span class="cm"> *  If the target doesn&#39;t fetch the answer (no message out phase),</span>
<span class="cm"> *  we assume the negotiation has failed, and fall back to default</span>
<span class="cm"> *  settings (SIR_NEGO_PROTO interrupt).</span>
<span class="cm"> *</span>
<span class="cm"> *  When we set the values, we adjust them in all ccbs belonging </span>
<span class="cm"> *  to this target, in the controller&#39;s register, and in the &quot;phys&quot;</span>
<span class="cm"> *  field of the controller&#39;s struct sym_hcb.</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> *  chip handler for SYNCHRONOUS DATA TRANSFER REQUEST (SDTR) message.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>  
<span class="n">sym_sync_nego_check</span><span class="p">(</span><span class="k">struct</span> <span class="n">sym_hcb</span> <span class="o">*</span><span class="n">np</span><span class="p">,</span> <span class="kt">int</span> <span class="n">req</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sym_ccb</span> <span class="o">*</span><span class="n">cp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">target</span> <span class="o">=</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">target</span><span class="p">;</span>
	<span class="n">u_char</span>	<span class="n">chg</span><span class="p">,</span> <span class="n">ofs</span><span class="p">,</span> <span class="n">per</span><span class="p">,</span> <span class="n">fak</span><span class="p">,</span> <span class="n">div</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">DEBUG_FLAGS</span> <span class="o">&amp;</span> <span class="n">DEBUG_NEGO</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">sym_print_nego_msg</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="s">&quot;sync msgin&quot;</span><span class="p">,</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">msgin</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 *  Get requested values.</span>
<span class="cm">	 */</span>
	<span class="n">chg</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">per</span> <span class="o">=</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">msgin</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
	<span class="n">ofs</span> <span class="o">=</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">msgin</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>

	<span class="cm">/*</span>
<span class="cm">	 *  Check values against our limits.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ofs</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ofs</span> <span class="o">&gt;</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">maxoffs</span><span class="p">)</span>
			<span class="p">{</span><span class="n">chg</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">ofs</span> <span class="o">=</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">maxoffs</span><span class="p">;}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ofs</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">per</span> <span class="o">&lt;</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">minsync</span><span class="p">)</span>
			<span class="p">{</span><span class="n">chg</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">per</span> <span class="o">=</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">minsync</span><span class="p">;}</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 *  Get new chip synchronous parameters value.</span>
<span class="cm">	 */</span>
	<span class="n">div</span> <span class="o">=</span> <span class="n">fak</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ofs</span> <span class="o">&amp;&amp;</span> <span class="n">sym_getsync</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">per</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">div</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fak</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">reject_it</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">DEBUG_FLAGS</span> <span class="o">&amp;</span> <span class="n">DEBUG_NEGO</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">sym_print_addr</span><span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">cmd</span><span class="p">,</span>
				<span class="s">&quot;sdtr: ofs=%d per=%d div=%d fak=%d chg=%d.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">ofs</span><span class="p">,</span> <span class="n">per</span><span class="p">,</span> <span class="n">div</span><span class="p">,</span> <span class="n">fak</span><span class="p">,</span> <span class="n">chg</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 *  If it was an answer we want to change, </span>
<span class="cm">	 *  then it isn&#39;t acceptable. Reject it.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">req</span> <span class="o">&amp;&amp;</span> <span class="n">chg</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">reject_it</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 *  Apply new values.</span>
<span class="cm">	 */</span>
	<span class="n">sym_setsync</span> <span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">ofs</span><span class="p">,</span> <span class="n">per</span><span class="p">,</span> <span class="n">div</span><span class="p">,</span> <span class="n">fak</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 *  It was an answer. We are done.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">req</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 *  It was a request. Prepare an answer message.</span>
<span class="cm">	 */</span>
	<span class="n">spi_populate_sync_msg</span><span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">msgout</span><span class="p">,</span> <span class="n">per</span><span class="p">,</span> <span class="n">ofs</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">DEBUG_FLAGS</span> <span class="o">&amp;</span> <span class="n">DEBUG_NEGO</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">sym_print_nego_msg</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="s">&quot;sync msgout&quot;</span><span class="p">,</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">msgout</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">np</span><span class="o">-&gt;</span><span class="n">msgin</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">M_NOOP</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">reject_it:</span>
	<span class="n">sym_setsync</span> <span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">sym_sync_nego</span><span class="p">(</span><span class="k">struct</span> <span class="n">sym_hcb</span> <span class="o">*</span><span class="n">np</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sym_tcb</span> <span class="o">*</span><span class="n">tp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sym_ccb</span> <span class="o">*</span><span class="n">cp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">req</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">result</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 *  Request or answer ?</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">INB</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">HS_PRT</span><span class="p">)</span> <span class="o">==</span> <span class="n">HS_NEGOTIATE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">OUTB</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">HS_PRT</span><span class="p">,</span> <span class="n">HS_BUSY</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">nego_status</span> <span class="o">&amp;&amp;</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">nego_status</span> <span class="o">!=</span> <span class="n">NS_SYNC</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">reject_it</span><span class="p">;</span>
		<span class="n">req</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 *  Check and apply new values.</span>
<span class="cm">	 */</span>
	<span class="n">result</span> <span class="o">=</span> <span class="n">sym_sync_nego_check</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">req</span><span class="p">,</span> <span class="n">cp</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">result</span><span class="p">)</span>	<span class="cm">/* Not acceptable, reject it */</span>
		<span class="k">goto</span> <span class="n">reject_it</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">req</span><span class="p">)</span> <span class="p">{</span>	<span class="cm">/* Was a request, send response. */</span>
		<span class="n">cp</span><span class="o">-&gt;</span><span class="n">nego_status</span> <span class="o">=</span> <span class="n">NS_SYNC</span><span class="p">;</span>
		<span class="n">OUTL_DSP</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">SCRIPTB_BA</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">sdtr_resp</span><span class="p">));</span>
	<span class="p">}</span>
	<span class="k">else</span>		<span class="cm">/* Was a response, we are done. */</span>
		<span class="n">OUTL_DSP</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">SCRIPTA_BA</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">clrack</span><span class="p">));</span>
	<span class="k">return</span><span class="p">;</span>

<span class="nl">reject_it:</span>
	<span class="n">OUTL_DSP</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">SCRIPTB_BA</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">msg_bad</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *  chip handler for PARALLEL PROTOCOL REQUEST (PPR) message.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> 
<span class="n">sym_ppr_nego_check</span><span class="p">(</span><span class="k">struct</span> <span class="n">sym_hcb</span> <span class="o">*</span><span class="n">np</span><span class="p">,</span> <span class="kt">int</span> <span class="n">req</span><span class="p">,</span> <span class="kt">int</span> <span class="n">target</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sym_tcb</span> <span class="o">*</span><span class="n">tp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">target</span><span class="p">[</span><span class="n">target</span><span class="p">];</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">fak</span><span class="p">,</span> <span class="n">div</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">dt</span><span class="p">,</span> <span class="n">chg</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">per</span> <span class="o">=</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">msgin</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">ofs</span> <span class="o">=</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">msgin</span><span class="p">[</span><span class="mi">5</span><span class="p">];</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">wide</span> <span class="o">=</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">msgin</span><span class="p">[</span><span class="mi">6</span><span class="p">];</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">opts</span> <span class="o">=</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">msgin</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">PPR_OPT_MASK</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">DEBUG_FLAGS</span> <span class="o">&amp;</span> <span class="n">DEBUG_NEGO</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">sym_print_nego_msg</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="s">&quot;ppr msgin&quot;</span><span class="p">,</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">msgin</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 *  Check values against our limits.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">wide</span> <span class="o">&gt;</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">maxwide</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">chg</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">wide</span> <span class="o">=</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">maxwide</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">wide</span> <span class="o">||</span> <span class="o">!</span><span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">features</span> <span class="o">&amp;</span> <span class="n">FE_U3EN</span><span class="p">))</span>
		<span class="n">opts</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">opts</span> <span class="o">!=</span> <span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">msgin</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">PPR_OPT_MASK</span><span class="p">))</span>
		<span class="n">chg</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">dt</span> <span class="o">=</span> <span class="n">opts</span> <span class="o">&amp;</span> <span class="n">PPR_OPT_DT</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ofs</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">maxoffs</span> <span class="o">=</span> <span class="n">dt</span> <span class="o">?</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">maxoffs_dt</span> <span class="o">:</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">maxoffs</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ofs</span> <span class="o">&gt;</span> <span class="n">maxoffs</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">chg</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">ofs</span> <span class="o">=</span> <span class="n">maxoffs</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ofs</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">minsync</span> <span class="o">=</span> <span class="n">dt</span> <span class="o">?</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">minsync_dt</span> <span class="o">:</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">minsync</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">per</span> <span class="o">&lt;</span> <span class="n">minsync</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">chg</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">per</span> <span class="o">=</span> <span class="n">minsync</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 *  Get new chip synchronous parameters value.</span>
<span class="cm">	 */</span>
	<span class="n">div</span> <span class="o">=</span> <span class="n">fak</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ofs</span> <span class="o">&amp;&amp;</span> <span class="n">sym_getsync</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">per</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">div</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fak</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">reject_it</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 *  If it was an answer we want to change, </span>
<span class="cm">	 *  then it isn&#39;t acceptable. Reject it.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">req</span> <span class="o">&amp;&amp;</span> <span class="n">chg</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">reject_it</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 *  Apply new values.</span>
<span class="cm">	 */</span>
	<span class="n">sym_setpprot</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">opts</span><span class="p">,</span> <span class="n">ofs</span><span class="p">,</span> <span class="n">per</span><span class="p">,</span> <span class="n">wide</span><span class="p">,</span> <span class="n">div</span><span class="p">,</span> <span class="n">fak</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 *  It was an answer. We are done.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">req</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 *  It was a request. Prepare an answer message.</span>
<span class="cm">	 */</span>
	<span class="n">spi_populate_ppr_msg</span><span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">msgout</span><span class="p">,</span> <span class="n">per</span><span class="p">,</span> <span class="n">ofs</span><span class="p">,</span> <span class="n">wide</span><span class="p">,</span> <span class="n">opts</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">DEBUG_FLAGS</span> <span class="o">&amp;</span> <span class="n">DEBUG_NEGO</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">sym_print_nego_msg</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="s">&quot;ppr msgout&quot;</span><span class="p">,</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">msgout</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">np</span><span class="o">-&gt;</span><span class="n">msgin</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">M_NOOP</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">reject_it:</span>
	<span class="n">sym_setpprot</span> <span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 *  If it is a device response that should result in  </span>
<span class="cm">	 *  ST, we may want to try a legacy negotiation later.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">req</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">opts</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">tp</span><span class="o">-&gt;</span><span class="n">tgoal</span><span class="p">.</span><span class="n">period</span> <span class="o">=</span> <span class="n">per</span><span class="p">;</span>
		<span class="n">tp</span><span class="o">-&gt;</span><span class="n">tgoal</span><span class="p">.</span><span class="n">offset</span> <span class="o">=</span> <span class="n">ofs</span><span class="p">;</span>
		<span class="n">tp</span><span class="o">-&gt;</span><span class="n">tgoal</span><span class="p">.</span><span class="n">width</span> <span class="o">=</span> <span class="n">wide</span><span class="p">;</span>
		<span class="n">tp</span><span class="o">-&gt;</span><span class="n">tgoal</span><span class="p">.</span><span class="n">iu</span> <span class="o">=</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">tgoal</span><span class="p">.</span><span class="n">dt</span> <span class="o">=</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">tgoal</span><span class="p">.</span><span class="n">qas</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">tp</span><span class="o">-&gt;</span><span class="n">tgoal</span><span class="p">.</span><span class="n">check_nego</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">sym_ppr_nego</span><span class="p">(</span><span class="k">struct</span> <span class="n">sym_hcb</span> <span class="o">*</span><span class="n">np</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sym_tcb</span> <span class="o">*</span><span class="n">tp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sym_ccb</span> <span class="o">*</span><span class="n">cp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">req</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">result</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 *  Request or answer ?</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">INB</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">HS_PRT</span><span class="p">)</span> <span class="o">==</span> <span class="n">HS_NEGOTIATE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">OUTB</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">HS_PRT</span><span class="p">,</span> <span class="n">HS_BUSY</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">nego_status</span> <span class="o">&amp;&amp;</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">nego_status</span> <span class="o">!=</span> <span class="n">NS_PPR</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">reject_it</span><span class="p">;</span>
		<span class="n">req</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 *  Check and apply new values.</span>
<span class="cm">	 */</span>
	<span class="n">result</span> <span class="o">=</span> <span class="n">sym_ppr_nego_check</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">req</span><span class="p">,</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">target</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">result</span><span class="p">)</span>	<span class="cm">/* Not acceptable, reject it */</span>
		<span class="k">goto</span> <span class="n">reject_it</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">req</span><span class="p">)</span> <span class="p">{</span>	<span class="cm">/* Was a request, send response. */</span>
		<span class="n">cp</span><span class="o">-&gt;</span><span class="n">nego_status</span> <span class="o">=</span> <span class="n">NS_PPR</span><span class="p">;</span>
		<span class="n">OUTL_DSP</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">SCRIPTB_BA</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">ppr_resp</span><span class="p">));</span>
	<span class="p">}</span>
	<span class="k">else</span>		<span class="cm">/* Was a response, we are done. */</span>
		<span class="n">OUTL_DSP</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">SCRIPTA_BA</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">clrack</span><span class="p">));</span>
	<span class="k">return</span><span class="p">;</span>

<span class="nl">reject_it:</span>
	<span class="n">OUTL_DSP</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">SCRIPTB_BA</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">msg_bad</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *  chip handler for WIDE DATA TRANSFER REQUEST (WDTR) message.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>  
<span class="n">sym_wide_nego_check</span><span class="p">(</span><span class="k">struct</span> <span class="n">sym_hcb</span> <span class="o">*</span><span class="n">np</span><span class="p">,</span> <span class="kt">int</span> <span class="n">req</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sym_ccb</span> <span class="o">*</span><span class="n">cp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">target</span> <span class="o">=</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">target</span><span class="p">;</span>
	<span class="n">u_char</span>	<span class="n">chg</span><span class="p">,</span> <span class="n">wide</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">DEBUG_FLAGS</span> <span class="o">&amp;</span> <span class="n">DEBUG_NEGO</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">sym_print_nego_msg</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="s">&quot;wide msgin&quot;</span><span class="p">,</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">msgin</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 *  Get requested values.</span>
<span class="cm">	 */</span>
	<span class="n">chg</span>  <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">wide</span> <span class="o">=</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">msgin</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>

	<span class="cm">/*</span>
<span class="cm">	 *  Check values against our limits.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">wide</span> <span class="o">&gt;</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">maxwide</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">chg</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">wide</span> <span class="o">=</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">maxwide</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">DEBUG_FLAGS</span> <span class="o">&amp;</span> <span class="n">DEBUG_NEGO</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">sym_print_addr</span><span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">cmd</span><span class="p">,</span> <span class="s">&quot;wdtr: wide=%d chg=%d.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">wide</span><span class="p">,</span> <span class="n">chg</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 *  If it was an answer we want to change, </span>
<span class="cm">	 *  then it isn&#39;t acceptable. Reject it.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">req</span> <span class="o">&amp;&amp;</span> <span class="n">chg</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">reject_it</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 *  Apply new values.</span>
<span class="cm">	 */</span>
	<span class="n">sym_setwide</span> <span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">wide</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 *  It was an answer. We are done.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">req</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 *  It was a request. Prepare an answer message.</span>
<span class="cm">	 */</span>
	<span class="n">spi_populate_width_msg</span><span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">msgout</span><span class="p">,</span> <span class="n">wide</span><span class="p">);</span>

	<span class="n">np</span><span class="o">-&gt;</span><span class="n">msgin</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">M_NOOP</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">DEBUG_FLAGS</span> <span class="o">&amp;</span> <span class="n">DEBUG_NEGO</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">sym_print_nego_msg</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="s">&quot;wide msgout&quot;</span><span class="p">,</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">msgout</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">reject_it:</span>
	<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">sym_wide_nego</span><span class="p">(</span><span class="k">struct</span> <span class="n">sym_hcb</span> <span class="o">*</span><span class="n">np</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sym_tcb</span> <span class="o">*</span><span class="n">tp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sym_ccb</span> <span class="o">*</span><span class="n">cp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">req</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">result</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 *  Request or answer ?</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">INB</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">HS_PRT</span><span class="p">)</span> <span class="o">==</span> <span class="n">HS_NEGOTIATE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">OUTB</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">HS_PRT</span><span class="p">,</span> <span class="n">HS_BUSY</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">nego_status</span> <span class="o">&amp;&amp;</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">nego_status</span> <span class="o">!=</span> <span class="n">NS_WIDE</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">reject_it</span><span class="p">;</span>
		<span class="n">req</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 *  Check and apply new values.</span>
<span class="cm">	 */</span>
	<span class="n">result</span> <span class="o">=</span> <span class="n">sym_wide_nego_check</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">req</span><span class="p">,</span> <span class="n">cp</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">result</span><span class="p">)</span>	<span class="cm">/* Not acceptable, reject it */</span>
		<span class="k">goto</span> <span class="n">reject_it</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">req</span><span class="p">)</span> <span class="p">{</span>	<span class="cm">/* Was a request, send response. */</span>
		<span class="n">cp</span><span class="o">-&gt;</span><span class="n">nego_status</span> <span class="o">=</span> <span class="n">NS_WIDE</span><span class="p">;</span>
		<span class="n">OUTL_DSP</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">SCRIPTB_BA</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">wdtr_resp</span><span class="p">));</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>		<span class="cm">/* Was a response. */</span>
		<span class="cm">/*</span>
<span class="cm">		 * Negotiate for SYNC immediately after WIDE response.</span>
<span class="cm">		 * This allows to negotiate for both WIDE and SYNC on </span>
<span class="cm">		 * a single SCSI command (Suggested by Justin Gibbs).</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">tgoal</span><span class="p">.</span><span class="n">offset</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">spi_populate_sync_msg</span><span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">msgout</span><span class="p">,</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">tgoal</span><span class="p">.</span><span class="n">period</span><span class="p">,</span>
					<span class="n">tp</span><span class="o">-&gt;</span><span class="n">tgoal</span><span class="p">.</span><span class="n">offset</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">DEBUG_FLAGS</span> <span class="o">&amp;</span> <span class="n">DEBUG_NEGO</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">sym_print_nego_msg</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">target</span><span class="p">,</span>
				                   <span class="s">&quot;sync msgout&quot;</span><span class="p">,</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">msgout</span><span class="p">);</span>
			<span class="p">}</span>

			<span class="n">cp</span><span class="o">-&gt;</span><span class="n">nego_status</span> <span class="o">=</span> <span class="n">NS_SYNC</span><span class="p">;</span>
			<span class="n">OUTB</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">HS_PRT</span><span class="p">,</span> <span class="n">HS_NEGOTIATE</span><span class="p">);</span>
			<span class="n">OUTL_DSP</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">SCRIPTB_BA</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">sdtr_resp</span><span class="p">));</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="n">OUTL_DSP</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">SCRIPTA_BA</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">clrack</span><span class="p">));</span>
	<span class="p">}</span>

	<span class="k">return</span><span class="p">;</span>

<span class="nl">reject_it:</span>
	<span class="n">OUTL_DSP</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">SCRIPTB_BA</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">msg_bad</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *  Reset DT, SYNC or WIDE to default settings.</span>
<span class="cm"> *</span>
<span class="cm"> *  Called when a negotiation does not succeed either </span>
<span class="cm"> *  on rejection or on protocol error.</span>
<span class="cm"> *</span>
<span class="cm"> *  A target that understands a PPR message should never </span>
<span class="cm"> *  reject it, and messing with it is very unlikely.</span>
<span class="cm"> *  So, if a PPR makes problems, we may just want to </span>
<span class="cm"> *  try a legacy negotiation later.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">sym_nego_default</span><span class="p">(</span><span class="k">struct</span> <span class="n">sym_hcb</span> <span class="o">*</span><span class="n">np</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sym_tcb</span> <span class="o">*</span><span class="n">tp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sym_ccb</span> <span class="o">*</span><span class="n">cp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">nego_status</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">NS_PPR</span>:
<span class="cp">#if 0</span><span class="c"></span>
<span class="c">		sym_setpprot (np, cp-&gt;target, 0, 0, 0, 0, 0, 0);</span>
<span class="cp">#else</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">tgoal</span><span class="p">.</span><span class="n">period</span> <span class="o">&lt;</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">minsync</span><span class="p">)</span>
			<span class="n">tp</span><span class="o">-&gt;</span><span class="n">tgoal</span><span class="p">.</span><span class="n">period</span> <span class="o">=</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">minsync</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">tgoal</span><span class="p">.</span><span class="n">offset</span> <span class="o">&gt;</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">maxoffs</span><span class="p">)</span>
			<span class="n">tp</span><span class="o">-&gt;</span><span class="n">tgoal</span><span class="p">.</span><span class="n">offset</span> <span class="o">=</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">maxoffs</span><span class="p">;</span>
		<span class="n">tp</span><span class="o">-&gt;</span><span class="n">tgoal</span><span class="p">.</span><span class="n">iu</span> <span class="o">=</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">tgoal</span><span class="p">.</span><span class="n">dt</span> <span class="o">=</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">tgoal</span><span class="p">.</span><span class="n">qas</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">tp</span><span class="o">-&gt;</span><span class="n">tgoal</span><span class="p">.</span><span class="n">check_nego</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="cp">#endif</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">NS_SYNC</span>:
		<span class="n">sym_setsync</span> <span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">target</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">NS_WIDE</span>:
		<span class="n">sym_setwide</span> <span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">target</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">np</span><span class="o">-&gt;</span><span class="n">msgin</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">M_NOOP</span><span class="p">;</span>
	<span class="n">np</span><span class="o">-&gt;</span><span class="n">msgout</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">M_NOOP</span><span class="p">;</span>
	<span class="n">cp</span><span class="o">-&gt;</span><span class="n">nego_status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *  chip handler for MESSAGE REJECT received in response to </span>
<span class="cm"> *  PPR, WIDE or SYNCHRONOUS negotiation.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">sym_nego_rejected</span><span class="p">(</span><span class="k">struct</span> <span class="n">sym_hcb</span> <span class="o">*</span><span class="n">np</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sym_tcb</span> <span class="o">*</span><span class="n">tp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sym_ccb</span> <span class="o">*</span><span class="n">cp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">sym_nego_default</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">tp</span><span class="p">,</span> <span class="n">cp</span><span class="p">);</span>
	<span class="n">OUTB</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">HS_PRT</span><span class="p">,</span> <span class="n">HS_BUSY</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *  chip exception handler for programmed interrupts.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">sym_int_sir</span><span class="p">(</span><span class="k">struct</span> <span class="n">sym_hcb</span> <span class="o">*</span><span class="n">np</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u_char</span>	<span class="n">num</span>	<span class="o">=</span> <span class="n">INB</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">nc_dsps</span><span class="p">);</span>
	<span class="n">u32</span>	<span class="n">dsa</span>	<span class="o">=</span> <span class="n">INL</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">nc_dsa</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">sym_ccb</span> <span class="o">*</span><span class="n">cp</span>	<span class="o">=</span> <span class="n">sym_ccb_from_dsa</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">dsa</span><span class="p">);</span>
	<span class="n">u_char</span>	<span class="n">target</span>	<span class="o">=</span> <span class="n">INB</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">nc_sdid</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x0f</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sym_tcb</span> <span class="o">*</span><span class="n">tp</span>	<span class="o">=</span> <span class="o">&amp;</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">target</span><span class="p">[</span><span class="n">target</span><span class="p">];</span>
	<span class="kt">int</span>	<span class="n">tmp</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">DEBUG_FLAGS</span> <span class="o">&amp;</span> <span class="n">DEBUG_TINY</span><span class="p">)</span> <span class="n">printf</span> <span class="p">(</span><span class="s">&quot;I#%d&quot;</span><span class="p">,</span> <span class="n">num</span><span class="p">);</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">num</span><span class="p">)</span> <span class="p">{</span>
<span class="cp">#if   SYM_CONF_DMA_ADDRESSING_MODE == 2</span>
	<span class="cm">/*</span>
<span class="cm">	 *  SCRIPTS tell us that we may have to update </span>
<span class="cm">	 *  64 bit DMA segment registers.</span>
<span class="cm">	 */</span>
	<span class="k">case</span> <span class="n">SIR_DMAP_DIRTY</span>:
		<span class="n">sym_update_dmap_regs</span><span class="p">(</span><span class="n">np</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="cm">/*</span>
<span class="cm">	 *  Command has been completed with error condition </span>
<span class="cm">	 *  or has been auto-sensed.</span>
<span class="cm">	 */</span>
	<span class="k">case</span> <span class="n">SIR_COMPLETE_ERROR</span>:
		<span class="n">sym_complete_error</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">cp</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 *  The C code is currently trying to recover from something.</span>
<span class="cm">	 *  Typically, user want to abort some command.</span>
<span class="cm">	 */</span>
	<span class="k">case</span> <span class="n">SIR_SCRIPT_STOPPED</span>:
	<span class="k">case</span> <span class="n">SIR_TARGET_SELECTED</span>:
	<span class="k">case</span> <span class="n">SIR_ABORT_SENT</span>:
		<span class="n">sym_sir_task_recovery</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">num</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 *  The device didn&#39;t go to MSG OUT phase after having </span>
<span class="cm">	 *  been selected with ATN.  We do not want to handle that.</span>
<span class="cm">	 */</span>
	<span class="k">case</span> <span class="n">SIR_SEL_ATN_NO_MSG_OUT</span>:
		<span class="n">scmd_printk</span><span class="p">(</span><span class="n">KERN_WARNING</span><span class="p">,</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">cmd</span><span class="p">,</span>
				<span class="s">&quot;No MSG OUT phase after selection with ATN</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_stuck</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 *  The device didn&#39;t switch to MSG IN phase after </span>
<span class="cm">	 *  having reselected the initiator.</span>
<span class="cm">	 */</span>
	<span class="k">case</span> <span class="n">SIR_RESEL_NO_MSG_IN</span>:
		<span class="n">scmd_printk</span><span class="p">(</span><span class="n">KERN_WARNING</span><span class="p">,</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">cmd</span><span class="p">,</span>
				<span class="s">&quot;No MSG IN phase after reselection</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_stuck</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 *  After reselection, the device sent a message that wasn&#39;t </span>
<span class="cm">	 *  an IDENTIFY.</span>
<span class="cm">	 */</span>
	<span class="k">case</span> <span class="n">SIR_RESEL_NO_IDENTIFY</span>:
		<span class="n">scmd_printk</span><span class="p">(</span><span class="n">KERN_WARNING</span><span class="p">,</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">cmd</span><span class="p">,</span>
				<span class="s">&quot;No IDENTIFY after reselection</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_stuck</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 *  The device reselected a LUN we do not know about.</span>
<span class="cm">	 */</span>
	<span class="k">case</span> <span class="n">SIR_RESEL_BAD_LUN</span>:
		<span class="n">np</span><span class="o">-&gt;</span><span class="n">msgout</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">M_RESET</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 *  The device reselected for an untagged nexus and we </span>
<span class="cm">	 *  haven&#39;t any.</span>
<span class="cm">	 */</span>
	<span class="k">case</span> <span class="n">SIR_RESEL_BAD_I_T_L</span>:
		<span class="n">np</span><span class="o">-&gt;</span><span class="n">msgout</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">M_ABORT</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * The device reselected for a tagged nexus that we do not have.</span>
<span class="cm">	 */</span>
	<span class="k">case</span> <span class="n">SIR_RESEL_BAD_I_T_L_Q</span>:
		<span class="n">np</span><span class="o">-&gt;</span><span class="n">msgout</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">M_ABORT_TAG</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 *  The SCRIPTS let us know that the device has grabbed </span>
<span class="cm">	 *  our message and will abort the job.</span>
<span class="cm">	 */</span>
	<span class="k">case</span> <span class="n">SIR_RESEL_ABORTED</span>:
		<span class="n">np</span><span class="o">-&gt;</span><span class="n">lastmsg</span> <span class="o">=</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">msgout</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
		<span class="n">np</span><span class="o">-&gt;</span><span class="n">msgout</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">M_NOOP</span><span class="p">;</span>
		<span class="n">scmd_printk</span><span class="p">(</span><span class="n">KERN_WARNING</span><span class="p">,</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">cmd</span><span class="p">,</span>
			<span class="s">&quot;message %x sent on bad reselection</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">lastmsg</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 *  The SCRIPTS let us know that a message has been </span>
<span class="cm">	 *  successfully sent to the device.</span>
<span class="cm">	 */</span>
	<span class="k">case</span> <span class="n">SIR_MSG_OUT_DONE</span>:
		<span class="n">np</span><span class="o">-&gt;</span><span class="n">lastmsg</span> <span class="o">=</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">msgout</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
		<span class="n">np</span><span class="o">-&gt;</span><span class="n">msgout</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">M_NOOP</span><span class="p">;</span>
		<span class="cm">/* Should we really care of that */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">lastmsg</span> <span class="o">==</span> <span class="n">M_PARITY</span> <span class="o">||</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">lastmsg</span> <span class="o">==</span> <span class="n">M_ID_ERROR</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">cp</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">cp</span><span class="o">-&gt;</span><span class="n">xerr_status</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">XE_PARITY_ERR</span><span class="p">;</span>
				<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">xerr_status</span><span class="p">)</span>
					<span class="n">OUTOFFB</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">HF_PRT</span><span class="p">,</span> <span class="n">HF_EXT_ERR</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 *  The device didn&#39;t send a GOOD SCSI status.</span>
<span class="cm">	 *  We may have some work to do prior to allow </span>
<span class="cm">	 *  the SCRIPTS processor to continue.</span>
<span class="cm">	 */</span>
	<span class="k">case</span> <span class="n">SIR_BAD_SCSI_STATUS</span>:
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cp</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="n">sym_sir_bad_scsi_status</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">num</span><span class="p">,</span> <span class="n">cp</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 *  We are asked by the SCRIPTS to prepare a </span>
<span class="cm">	 *  REJECT message.</span>
<span class="cm">	 */</span>
	<span class="k">case</span> <span class="n">SIR_REJECT_TO_SEND</span>:
		<span class="n">sym_print_msg</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="s">&quot;M_REJECT to send for &quot;</span><span class="p">,</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">msgin</span><span class="p">);</span>
		<span class="n">np</span><span class="o">-&gt;</span><span class="n">msgout</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">M_REJECT</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 *  We have been ODD at the end of a DATA IN </span>
<span class="cm">	 *  transfer and the device didn&#39;t send a </span>
<span class="cm">	 *  IGNORE WIDE RESIDUE message.</span>
<span class="cm">	 *  It is a data overrun condition.</span>
<span class="cm">	 */</span>
	<span class="k">case</span> <span class="n">SIR_SWIDE_OVERRUN</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">cp</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">OUTONB</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">HF_PRT</span><span class="p">,</span> <span class="n">HF_EXT_ERR</span><span class="p">);</span>
			<span class="n">cp</span><span class="o">-&gt;</span><span class="n">xerr_status</span> <span class="o">|=</span> <span class="n">XE_SWIDE_OVRUN</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 *  We have been ODD at the end of a DATA OUT </span>
<span class="cm">	 *  transfer.</span>
<span class="cm">	 *  It is a data underrun condition.</span>
<span class="cm">	 */</span>
	<span class="k">case</span> <span class="n">SIR_SODL_UNDERRUN</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">cp</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">OUTONB</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">HF_PRT</span><span class="p">,</span> <span class="n">HF_EXT_ERR</span><span class="p">);</span>
			<span class="n">cp</span><span class="o">-&gt;</span><span class="n">xerr_status</span> <span class="o">|=</span> <span class="n">XE_SODL_UNRUN</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 *  The device wants us to tranfer more data than </span>
<span class="cm">	 *  expected or in the wrong direction.</span>
<span class="cm">	 *  The number of extra bytes is in scratcha.</span>
<span class="cm">	 *  It is a data overrun condition.</span>
<span class="cm">	 */</span>
	<span class="k">case</span> <span class="n">SIR_DATA_OVERRUN</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">cp</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">OUTONB</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">HF_PRT</span><span class="p">,</span> <span class="n">HF_EXT_ERR</span><span class="p">);</span>
			<span class="n">cp</span><span class="o">-&gt;</span><span class="n">xerr_status</span> <span class="o">|=</span> <span class="n">XE_EXTRA_DATA</span><span class="p">;</span>
			<span class="n">cp</span><span class="o">-&gt;</span><span class="n">extra_bytes</span> <span class="o">+=</span> <span class="n">INL</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">nc_scratcha</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 *  The device switched to an illegal phase (4/5).</span>
<span class="cm">	 */</span>
	<span class="k">case</span> <span class="n">SIR_BAD_PHASE</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">cp</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">OUTONB</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">HF_PRT</span><span class="p">,</span> <span class="n">HF_EXT_ERR</span><span class="p">);</span>
			<span class="n">cp</span><span class="o">-&gt;</span><span class="n">xerr_status</span> <span class="o">|=</span> <span class="n">XE_BAD_PHASE</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 *  We received a message.</span>
<span class="cm">	 */</span>
	<span class="k">case</span> <span class="n">SIR_MSG_RECEIVED</span>:
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cp</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out_stuck</span><span class="p">;</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">msgin</span> <span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 *  We received an extended message.</span>
<span class="cm">		 *  We handle MODIFY DATA POINTER, SDTR, WDTR </span>
<span class="cm">		 *  and reject all other extended messages.</span>
<span class="cm">		 */</span>
		<span class="k">case</span> <span class="n">M_EXTENDED</span>:
			<span class="k">switch</span> <span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">msgin</span> <span class="p">[</span><span class="mi">2</span><span class="p">])</span> <span class="p">{</span>
			<span class="k">case</span> <span class="n">M_X_MODIFY_DP</span>:
				<span class="k">if</span> <span class="p">(</span><span class="n">DEBUG_FLAGS</span> <span class="o">&amp;</span> <span class="n">DEBUG_POINTER</span><span class="p">)</span>
					<span class="n">sym_print_msg</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="s">&quot;extended msg &quot;</span><span class="p">,</span>
						      <span class="n">np</span><span class="o">-&gt;</span><span class="n">msgin</span><span class="p">);</span>
				<span class="n">tmp</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">msgin</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">&lt;&lt;</span><span class="mi">24</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">msgin</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span><span class="o">&lt;&lt;</span><span class="mi">16</span><span class="p">)</span> <span class="o">+</span> 
				      <span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">msgin</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span><span class="o">&lt;&lt;</span><span class="mi">8</span><span class="p">)</span>  <span class="o">+</span> <span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">msgin</span><span class="p">[</span><span class="mi">6</span><span class="p">]);</span>
				<span class="n">sym_modify_dp</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">tp</span><span class="p">,</span> <span class="n">cp</span><span class="p">,</span> <span class="n">tmp</span><span class="p">);</span>
				<span class="k">return</span><span class="p">;</span>
			<span class="k">case</span> <span class="n">M_X_SYNC_REQ</span>:
				<span class="n">sym_sync_nego</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">tp</span><span class="p">,</span> <span class="n">cp</span><span class="p">);</span>
				<span class="k">return</span><span class="p">;</span>
			<span class="k">case</span> <span class="n">M_X_PPR_REQ</span>:
				<span class="n">sym_ppr_nego</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">tp</span><span class="p">,</span> <span class="n">cp</span><span class="p">);</span>
				<span class="k">return</span><span class="p">;</span>
			<span class="k">case</span> <span class="n">M_X_WIDE_REQ</span>:
				<span class="n">sym_wide_nego</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">tp</span><span class="p">,</span> <span class="n">cp</span><span class="p">);</span>
				<span class="k">return</span><span class="p">;</span>
			<span class="nl">default:</span>
				<span class="k">goto</span> <span class="n">out_reject</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 *  We received a 1/2 byte message not handled from SCRIPTS.</span>
<span class="cm">		 *  We are only expecting MESSAGE REJECT and IGNORE WIDE </span>
<span class="cm">		 *  RESIDUE messages that haven&#39;t been anticipated by </span>
<span class="cm">		 *  SCRIPTS on SWIDE full condition. Unanticipated IGNORE </span>
<span class="cm">		 *  WIDE RESIDUE messages are aliased as MODIFY DP (-1).</span>
<span class="cm">		 */</span>
		<span class="k">case</span> <span class="n">M_IGN_RESIDUE</span>:
			<span class="k">if</span> <span class="p">(</span><span class="n">DEBUG_FLAGS</span> <span class="o">&amp;</span> <span class="n">DEBUG_POINTER</span><span class="p">)</span>
				<span class="n">sym_print_msg</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="s">&quot;1 or 2 byte &quot;</span><span class="p">,</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">msgin</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">host_flags</span> <span class="o">&amp;</span> <span class="n">HF_SENSE</span><span class="p">)</span>
				<span class="n">OUTL_DSP</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">SCRIPTA_BA</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">clrack</span><span class="p">));</span>
			<span class="k">else</span>
				<span class="n">sym_modify_dp</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">tp</span><span class="p">,</span> <span class="n">cp</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">M_REJECT</span>:
			<span class="k">if</span> <span class="p">(</span><span class="n">INB</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">HS_PRT</span><span class="p">)</span> <span class="o">==</span> <span class="n">HS_NEGOTIATE</span><span class="p">)</span>
				<span class="n">sym_nego_rejected</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">tp</span><span class="p">,</span> <span class="n">cp</span><span class="p">);</span>
			<span class="k">else</span> <span class="p">{</span>
				<span class="n">sym_print_addr</span><span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">cmd</span><span class="p">,</span>
					<span class="s">&quot;M_REJECT received (%x:%x).</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">scr_to_cpu</span><span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">lastmsg</span><span class="p">),</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">msgout</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
			<span class="p">}</span>
			<span class="k">goto</span> <span class="n">out_clrack</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="nl">default:</span>
			<span class="k">goto</span> <span class="n">out_reject</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 *  We received an unknown message.</span>
<span class="cm">	 *  Ignore all MSG IN phases and reject it.</span>
<span class="cm">	 */</span>
	<span class="k">case</span> <span class="n">SIR_MSG_WEIRD</span>:
		<span class="n">sym_print_msg</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="s">&quot;WEIRD message received&quot;</span><span class="p">,</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">msgin</span><span class="p">);</span>
		<span class="n">OUTL_DSP</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">SCRIPTB_BA</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">msg_weird</span><span class="p">));</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 *  Negotiation failed.</span>
<span class="cm">	 *  Target does not send us the reply.</span>
<span class="cm">	 *  Remove the HS_NEGOTIATE status.</span>
<span class="cm">	 */</span>
	<span class="k">case</span> <span class="n">SIR_NEGO_FAILED</span>:
		<span class="n">OUTB</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">HS_PRT</span><span class="p">,</span> <span class="n">HS_BUSY</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 *  Negotiation failed.</span>
<span class="cm">	 *  Target does not want answer message.</span>
<span class="cm">	 */</span>
	<span class="k">case</span> <span class="n">SIR_NEGO_PROTO</span>:
		<span class="n">sym_nego_default</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">tp</span><span class="p">,</span> <span class="n">cp</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

<span class="nl">out:</span>
	<span class="n">OUTONB_STD</span><span class="p">();</span>
	<span class="k">return</span><span class="p">;</span>
<span class="nl">out_reject:</span>
	<span class="n">OUTL_DSP</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">SCRIPTB_BA</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">msg_bad</span><span class="p">));</span>
	<span class="k">return</span><span class="p">;</span>
<span class="nl">out_clrack:</span>
	<span class="n">OUTL_DSP</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">SCRIPTA_BA</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">clrack</span><span class="p">));</span>
	<span class="k">return</span><span class="p">;</span>
<span class="nl">out_stuck:</span>
	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *  Acquire a control block</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">sym_ccb</span> <span class="o">*</span><span class="n">sym_get_ccb</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sym_hcb</span> <span class="o">*</span><span class="n">np</span><span class="p">,</span> <span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">,</span> <span class="n">u_char</span> <span class="n">tag_order</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u_char</span> <span class="n">tn</span> <span class="o">=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">;</span>
	<span class="n">u_char</span> <span class="n">ln</span> <span class="o">=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">lun</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sym_tcb</span> <span class="o">*</span><span class="n">tp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">target</span><span class="p">[</span><span class="n">tn</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">sym_lcb</span> <span class="o">*</span><span class="n">lp</span> <span class="o">=</span> <span class="n">sym_lp</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">ln</span><span class="p">);</span>
	<span class="n">u_short</span> <span class="n">tag</span> <span class="o">=</span> <span class="n">NO_TAG</span><span class="p">;</span>
	<span class="n">SYM_QUEHEAD</span> <span class="o">*</span><span class="n">qp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sym_ccb</span> <span class="o">*</span><span class="n">cp</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 *  Look for a free CCB</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sym_que_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">free_ccbq</span><span class="p">))</span>
		<span class="n">sym_alloc_ccb</span><span class="p">(</span><span class="n">np</span><span class="p">);</span>
	<span class="n">qp</span> <span class="o">=</span> <span class="n">sym_remque_head</span><span class="p">(</span><span class="o">&amp;</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">free_ccbq</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">qp</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="n">cp</span> <span class="o">=</span> <span class="n">sym_que_entry</span><span class="p">(</span><span class="n">qp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sym_ccb</span><span class="p">,</span> <span class="n">link_ccbq</span><span class="p">);</span>

	<span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 *  If we have been asked for a tagged command.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tag_order</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 *  Debugging purpose.</span>
<span class="cm">			 */</span>
<span class="cp">#ifndef SYM_OPT_HANDLE_DEVICE_QUEUEING</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">busy_itl</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">out_free</span><span class="p">;</span>
<span class="cp">#endif</span>
			<span class="cm">/*</span>
<span class="cm">			 *  Allocate resources for tags if not yet.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">cb_tags</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">sym_alloc_lcb_tags</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">tn</span><span class="p">,</span> <span class="n">ln</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">cb_tags</span><span class="p">)</span>
					<span class="k">goto</span> <span class="n">out_free</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="cm">/*</span>
<span class="cm">			 *  Get a tag for this SCSI IO and set up</span>
<span class="cm">			 *  the CCB bus address for reselection, </span>
<span class="cm">			 *  and count it for this LUN.</span>
<span class="cm">			 *  Toggle reselect path to tagged.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">busy_itlq</span> <span class="o">&lt;</span> <span class="n">SYM_CONF_MAX_TASK</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">tag</span> <span class="o">=</span> <span class="n">lp</span><span class="o">-&gt;</span><span class="n">cb_tags</span><span class="p">[</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">ia_tag</span><span class="p">];</span>
				<span class="k">if</span> <span class="p">(</span><span class="o">++</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">ia_tag</span> <span class="o">==</span> <span class="n">SYM_CONF_MAX_TASK</span><span class="p">)</span>
					<span class="n">lp</span><span class="o">-&gt;</span><span class="n">ia_tag</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
				<span class="o">++</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">busy_itlq</span><span class="p">;</span>
<span class="cp">#ifndef SYM_OPT_HANDLE_DEVICE_QUEUEING</span>
				<span class="n">lp</span><span class="o">-&gt;</span><span class="n">itlq_tbl</span><span class="p">[</span><span class="n">tag</span><span class="p">]</span> <span class="o">=</span> <span class="n">cpu_to_scr</span><span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">ccb_ba</span><span class="p">);</span>
				<span class="n">lp</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">.</span><span class="n">resel_sa</span> <span class="o">=</span>
					<span class="n">cpu_to_scr</span><span class="p">(</span><span class="n">SCRIPTA_BA</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">resel_tag</span><span class="p">));</span>
<span class="cp">#endif</span>
<span class="cp">#ifdef SYM_OPT_LIMIT_COMMAND_REORDERING</span>
				<span class="n">cp</span><span class="o">-&gt;</span><span class="n">tags_si</span> <span class="o">=</span> <span class="n">lp</span><span class="o">-&gt;</span><span class="n">tags_si</span><span class="p">;</span>
				<span class="o">++</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">tags_sum</span><span class="p">[</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">tags_si</span><span class="p">];</span>
				<span class="o">++</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">tags_since</span><span class="p">;</span>
<span class="cp">#endif</span>
			<span class="p">}</span>
			<span class="k">else</span>
				<span class="k">goto</span> <span class="n">out_free</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/*</span>
<span class="cm">		 *  This command will not be tagged.</span>
<span class="cm">		 *  If we already have either a tagged or untagged </span>
<span class="cm">		 *  one, refuse to overlap this untagged one.</span>
<span class="cm">		 */</span>
		<span class="k">else</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 *  Debugging purpose.</span>
<span class="cm">			 */</span>
<span class="cp">#ifndef SYM_OPT_HANDLE_DEVICE_QUEUEING</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">busy_itl</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">lp</span><span class="o">-&gt;</span><span class="n">busy_itlq</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">out_free</span><span class="p">;</span>
<span class="cp">#endif</span>
			<span class="cm">/*</span>
<span class="cm">			 *  Count this nexus for this LUN.</span>
<span class="cm">			 *  Set up the CCB bus address for reselection.</span>
<span class="cm">			 *  Toggle reselect path to untagged.</span>
<span class="cm">			 */</span>
			<span class="o">++</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">busy_itl</span><span class="p">;</span>
<span class="cp">#ifndef SYM_OPT_HANDLE_DEVICE_QUEUEING</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">busy_itl</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">lp</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">.</span><span class="n">itl_task_sa</span> <span class="o">=</span> <span class="n">cpu_to_scr</span><span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">ccb_ba</span><span class="p">);</span>
				<span class="n">lp</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">.</span><span class="n">resel_sa</span> <span class="o">=</span>
				      <span class="n">cpu_to_scr</span><span class="p">(</span><span class="n">SCRIPTA_BA</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">resel_no_tag</span><span class="p">));</span>
			<span class="p">}</span>
			<span class="k">else</span>
				<span class="k">goto</span> <span class="n">out_free</span><span class="p">;</span>
<span class="cp">#endif</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 *  Put the CCB into the busy queue.</span>
<span class="cm">	 */</span>
	<span class="n">sym_insque_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">link_ccbq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">busy_ccbq</span><span class="p">);</span>
<span class="cp">#ifdef SYM_OPT_HANDLE_DEVICE_QUEUEING</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">lp</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">sym_remque</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">link2_ccbq</span><span class="p">);</span>
		<span class="n">sym_insque_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">link2_ccbq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">waiting_ccbq</span><span class="p">);</span>
	<span class="p">}</span>

<span class="cp">#endif</span>
	<span class="n">cp</span><span class="o">-&gt;</span><span class="n">to_abort</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">cp</span><span class="o">-&gt;</span><span class="n">odd_byte_adjustment</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">cp</span><span class="o">-&gt;</span><span class="n">tag</span>	   <span class="o">=</span> <span class="n">tag</span><span class="p">;</span>
	<span class="n">cp</span><span class="o">-&gt;</span><span class="n">order</span>  <span class="o">=</span> <span class="n">tag_order</span><span class="p">;</span>
	<span class="n">cp</span><span class="o">-&gt;</span><span class="n">target</span> <span class="o">=</span> <span class="n">tn</span><span class="p">;</span>
	<span class="n">cp</span><span class="o">-&gt;</span><span class="n">lun</span>    <span class="o">=</span> <span class="n">ln</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">DEBUG_FLAGS</span> <span class="o">&amp;</span> <span class="n">DEBUG_TAGS</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">sym_print_addr</span><span class="p">(</span><span class="n">cmd</span><span class="p">,</span> <span class="s">&quot;ccb @%p using tag %d.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">cp</span><span class="p">,</span> <span class="n">tag</span><span class="p">);</span>
	<span class="p">}</span>

<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">cp</span><span class="p">;</span>
<span class="nl">out_free:</span>
	<span class="n">sym_insque_head</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">link_ccbq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">free_ccbq</span><span class="p">);</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *  Release one control block</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">sym_free_ccb</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sym_hcb</span> <span class="o">*</span><span class="n">np</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sym_ccb</span> <span class="o">*</span><span class="n">cp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sym_tcb</span> <span class="o">*</span><span class="n">tp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">target</span><span class="p">[</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">target</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">sym_lcb</span> <span class="o">*</span><span class="n">lp</span> <span class="o">=</span> <span class="n">sym_lp</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">lun</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">DEBUG_FLAGS</span> <span class="o">&amp;</span> <span class="n">DEBUG_TAGS</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">sym_print_addr</span><span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">cmd</span><span class="p">,</span> <span class="s">&quot;ccb @%p freeing tag %d.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">cp</span><span class="p">,</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">tag</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 *  If LCB available,</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">lp</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 *  If tagged, release the tag, set the relect path </span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">tag</span> <span class="o">!=</span> <span class="n">NO_TAG</span><span class="p">)</span> <span class="p">{</span>
<span class="cp">#ifdef SYM_OPT_LIMIT_COMMAND_REORDERING</span>
			<span class="o">--</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">tags_sum</span><span class="p">[</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">tags_si</span><span class="p">];</span>
<span class="cp">#endif</span>
			<span class="cm">/*</span>
<span class="cm">			 *  Free the tag value.</span>
<span class="cm">			 */</span>
			<span class="n">lp</span><span class="o">-&gt;</span><span class="n">cb_tags</span><span class="p">[</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">if_tag</span><span class="p">]</span> <span class="o">=</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">tag</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">++</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">if_tag</span> <span class="o">==</span> <span class="n">SYM_CONF_MAX_TASK</span><span class="p">)</span>
				<span class="n">lp</span><span class="o">-&gt;</span><span class="n">if_tag</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="cm">/*</span>
<span class="cm">			 *  Make the reselect path invalid, </span>
<span class="cm">			 *  and uncount this CCB.</span>
<span class="cm">			 */</span>
			<span class="n">lp</span><span class="o">-&gt;</span><span class="n">itlq_tbl</span><span class="p">[</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">tag</span><span class="p">]</span> <span class="o">=</span> <span class="n">cpu_to_scr</span><span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">bad_itlq_ba</span><span class="p">);</span>
			<span class="o">--</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">busy_itlq</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>	<span class="cm">/* Untagged */</span>
			<span class="cm">/*</span>
<span class="cm">			 *  Make the reselect path invalid, </span>
<span class="cm">			 *  and uncount this CCB.</span>
<span class="cm">			 */</span>
			<span class="n">lp</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">.</span><span class="n">itl_task_sa</span> <span class="o">=</span> <span class="n">cpu_to_scr</span><span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">bad_itl_ba</span><span class="p">);</span>
			<span class="o">--</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">busy_itl</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/*</span>
<span class="cm">		 *  If no JOB active, make the LUN reselect path invalid.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">busy_itlq</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">lp</span><span class="o">-&gt;</span><span class="n">busy_itl</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">lp</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">.</span><span class="n">resel_sa</span> <span class="o">=</span>
				<span class="n">cpu_to_scr</span><span class="p">(</span><span class="n">SCRIPTB_BA</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">resel_bad_lun</span><span class="p">));</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 *  We donnot queue more than 1 ccb per target </span>
<span class="cm">	 *  with negotiation at any time. If this ccb was </span>
<span class="cm">	 *  used for negotiation, clear this info in the tcb.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cp</span> <span class="o">==</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">nego_cp</span><span class="p">)</span>
		<span class="n">tp</span><span class="o">-&gt;</span><span class="n">nego_cp</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

<span class="cp">#ifdef SYM_CONF_IARB_SUPPORT</span>
	<span class="cm">/*</span>
<span class="cm">	 *  If we just complete the last queued CCB,</span>
<span class="cm">	 *  clear this info that is no longer relevant.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cp</span> <span class="o">==</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">last_cp</span><span class="p">)</span>
		<span class="n">np</span><span class="o">-&gt;</span><span class="n">last_cp</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="cp">#endif</span>

	<span class="cm">/*</span>
<span class="cm">	 *  Make this CCB available.</span>
<span class="cm">	 */</span>
	<span class="n">cp</span><span class="o">-&gt;</span><span class="n">cmd</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">cp</span><span class="o">-&gt;</span><span class="n">host_status</span> <span class="o">=</span> <span class="n">HS_IDLE</span><span class="p">;</span>
	<span class="n">sym_remque</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">link_ccbq</span><span class="p">);</span>
	<span class="n">sym_insque_head</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">link_ccbq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">free_ccbq</span><span class="p">);</span>

<span class="cp">#ifdef SYM_OPT_HANDLE_DEVICE_QUEUEING</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">lp</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">sym_remque</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">link2_ccbq</span><span class="p">);</span>
		<span class="n">sym_insque_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">link2_ccbq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">dummy_ccbq</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">started</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">tag</span> <span class="o">!=</span> <span class="n">NO_TAG</span><span class="p">)</span>
				<span class="o">--</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">started_tags</span><span class="p">;</span>
			<span class="k">else</span>
				<span class="o">--</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">started_no_tag</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">cp</span><span class="o">-&gt;</span><span class="n">started</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *  Allocate a CCB from memory and initialize its fixed part.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">sym_ccb</span> <span class="o">*</span><span class="n">sym_alloc_ccb</span><span class="p">(</span><span class="k">struct</span> <span class="n">sym_hcb</span> <span class="o">*</span><span class="n">np</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sym_ccb</span> <span class="o">*</span><span class="n">cp</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">hcode</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 *  Prevent from allocating more CCBs than we can </span>
<span class="cm">	 *  queue to the controller.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">actccbs</span> <span class="o">&gt;=</span> <span class="n">SYM_CONF_MAX_START</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 *  Allocate memory for this CCB.</span>
<span class="cm">	 */</span>
	<span class="n">cp</span> <span class="o">=</span> <span class="n">sym_calloc_dma</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sym_ccb</span><span class="p">),</span> <span class="s">&quot;CCB&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cp</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_free</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 *  Count it.</span>
<span class="cm">	 */</span>
	<span class="n">np</span><span class="o">-&gt;</span><span class="n">actccbs</span><span class="o">++</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 *  Compute the bus address of this ccb.</span>
<span class="cm">	 */</span>
	<span class="n">cp</span><span class="o">-&gt;</span><span class="n">ccb_ba</span> <span class="o">=</span> <span class="n">vtobus</span><span class="p">(</span><span class="n">cp</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 *  Insert this ccb into the hashed list.</span>
<span class="cm">	 */</span>
	<span class="n">hcode</span> <span class="o">=</span> <span class="n">CCB_HASH_CODE</span><span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">ccb_ba</span><span class="p">);</span>
	<span class="n">cp</span><span class="o">-&gt;</span><span class="n">link_ccbh</span> <span class="o">=</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">ccbh</span><span class="p">[</span><span class="n">hcode</span><span class="p">];</span>
	<span class="n">np</span><span class="o">-&gt;</span><span class="n">ccbh</span><span class="p">[</span><span class="n">hcode</span><span class="p">]</span> <span class="o">=</span> <span class="n">cp</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 *  Initialyze the start and restart actions.</span>
<span class="cm">	 */</span>
	<span class="n">cp</span><span class="o">-&gt;</span><span class="n">phys</span><span class="p">.</span><span class="n">head</span><span class="p">.</span><span class="n">go</span><span class="p">.</span><span class="n">start</span>   <span class="o">=</span> <span class="n">cpu_to_scr</span><span class="p">(</span><span class="n">SCRIPTA_BA</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">idle</span><span class="p">));</span>
	<span class="n">cp</span><span class="o">-&gt;</span><span class="n">phys</span><span class="p">.</span><span class="n">head</span><span class="p">.</span><span class="n">go</span><span class="p">.</span><span class="n">restart</span> <span class="o">=</span> <span class="n">cpu_to_scr</span><span class="p">(</span><span class="n">SCRIPTB_BA</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">bad_i_t_l</span><span class="p">));</span>

 	<span class="cm">/*</span>
<span class="cm">	 *  Initilialyze some other fields.</span>
<span class="cm">	 */</span>
	<span class="n">cp</span><span class="o">-&gt;</span><span class="n">phys</span><span class="p">.</span><span class="n">smsg_ext</span><span class="p">.</span><span class="n">addr</span> <span class="o">=</span> <span class="n">cpu_to_scr</span><span class="p">(</span><span class="n">HCB_BA</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">msgin</span><span class="p">[</span><span class="mi">2</span><span class="p">]));</span>

	<span class="cm">/*</span>
<span class="cm">	 *  Chain into free ccb queue.</span>
<span class="cm">	 */</span>
	<span class="n">sym_insque_head</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">link_ccbq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">free_ccbq</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 *  Chain into optionnal lists.</span>
<span class="cm">	 */</span>
<span class="cp">#ifdef SYM_OPT_HANDLE_DEVICE_QUEUEING</span>
	<span class="n">sym_insque_head</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">link2_ccbq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">dummy_ccbq</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="k">return</span> <span class="n">cp</span><span class="p">;</span>
<span class="nl">out_free:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cp</span><span class="p">)</span>
		<span class="n">sym_mfree_dma</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">cp</span><span class="p">),</span> <span class="s">&quot;CCB&quot;</span><span class="p">);</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *  Look up a CCB from a DSA value.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">sym_ccb</span> <span class="o">*</span><span class="n">sym_ccb_from_dsa</span><span class="p">(</span><span class="k">struct</span> <span class="n">sym_hcb</span> <span class="o">*</span><span class="n">np</span><span class="p">,</span> <span class="n">u32</span> <span class="n">dsa</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">hcode</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sym_ccb</span> <span class="o">*</span><span class="n">cp</span><span class="p">;</span>

	<span class="n">hcode</span> <span class="o">=</span> <span class="n">CCB_HASH_CODE</span><span class="p">(</span><span class="n">dsa</span><span class="p">);</span>
	<span class="n">cp</span> <span class="o">=</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">ccbh</span><span class="p">[</span><span class="n">hcode</span><span class="p">];</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">cp</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">ccb_ba</span> <span class="o">==</span> <span class="n">dsa</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">cp</span> <span class="o">=</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">link_ccbh</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">cp</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *  Target control block initialisation.</span>
<span class="cm"> *  Nothing important to do at the moment.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">sym_init_tcb</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sym_hcb</span> <span class="o">*</span><span class="n">np</span><span class="p">,</span> <span class="n">u_char</span> <span class="n">tn</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#if 0</span><span class="c">	/*  Hmmm... this checking looks paranoid. */</span>
<span class="c">	/*</span>
<span class="c">	 *  Check some alignments required by the chip.</span>
<span class="c">	 */	</span>
<span class="c">	assert (((offsetof(struct sym_reg, nc_sxfer) ^</span>
<span class="c">		offsetof(struct sym_tcb, head.sval)) &amp;3) == 0);</span>
<span class="c">	assert (((offsetof(struct sym_reg, nc_scntl3) ^</span>
<span class="c">		offsetof(struct sym_tcb, head.wval)) &amp;3) == 0);</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *  Lun control block allocation and initialization.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">sym_lcb</span> <span class="o">*</span><span class="n">sym_alloc_lcb</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sym_hcb</span> <span class="o">*</span><span class="n">np</span><span class="p">,</span> <span class="n">u_char</span> <span class="n">tn</span><span class="p">,</span> <span class="n">u_char</span> <span class="n">ln</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sym_tcb</span> <span class="o">*</span><span class="n">tp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">target</span><span class="p">[</span><span class="n">tn</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">sym_lcb</span> <span class="o">*</span><span class="n">lp</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 *  Initialize the target control block if not yet.</span>
<span class="cm">	 */</span>
	<span class="n">sym_init_tcb</span> <span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">tn</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 *  Allocate the LCB bus address array.</span>
<span class="cm">	 *  Compute the bus address of this table.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ln</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">luntbl</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

		<span class="n">tp</span><span class="o">-&gt;</span><span class="n">luntbl</span> <span class="o">=</span> <span class="n">sym_calloc_dma</span><span class="p">(</span><span class="mi">256</span><span class="p">,</span> <span class="s">&quot;LUNTBL&quot;</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">luntbl</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">64</span> <span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
			<span class="n">tp</span><span class="o">-&gt;</span><span class="n">luntbl</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">cpu_to_scr</span><span class="p">(</span><span class="n">vtobus</span><span class="p">(</span><span class="o">&amp;</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">badlun_sa</span><span class="p">));</span>
		<span class="n">tp</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">.</span><span class="n">luntbl_sa</span> <span class="o">=</span> <span class="n">cpu_to_scr</span><span class="p">(</span><span class="n">vtobus</span><span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">luntbl</span><span class="p">));</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 *  Allocate the table of pointers for LUN(s) &gt; 0, if needed.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ln</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">lunmp</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">tp</span><span class="o">-&gt;</span><span class="n">lunmp</span> <span class="o">=</span> <span class="n">kcalloc</span><span class="p">(</span><span class="n">SYM_CONF_MAX_LUN</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sym_lcb</span> <span class="o">*</span><span class="p">),</span>
				<span class="n">GFP_ATOMIC</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">lunmp</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 *  Allocate the lcb.</span>
<span class="cm">	 *  Make it available to the chip.</span>
<span class="cm">	 */</span>
	<span class="n">lp</span> <span class="o">=</span> <span class="n">sym_calloc_dma</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sym_lcb</span><span class="p">),</span> <span class="s">&quot;LCB&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">lp</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ln</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">tp</span><span class="o">-&gt;</span><span class="n">lunmp</span><span class="p">[</span><span class="n">ln</span><span class="p">]</span> <span class="o">=</span> <span class="n">lp</span><span class="p">;</span>
		<span class="n">tp</span><span class="o">-&gt;</span><span class="n">luntbl</span><span class="p">[</span><span class="n">ln</span><span class="p">]</span> <span class="o">=</span> <span class="n">cpu_to_scr</span><span class="p">(</span><span class="n">vtobus</span><span class="p">(</span><span class="n">lp</span><span class="p">));</span>
	<span class="p">}</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="n">tp</span><span class="o">-&gt;</span><span class="n">lun0p</span> <span class="o">=</span> <span class="n">lp</span><span class="p">;</span>
		<span class="n">tp</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">.</span><span class="n">lun0_sa</span> <span class="o">=</span> <span class="n">cpu_to_scr</span><span class="p">(</span><span class="n">vtobus</span><span class="p">(</span><span class="n">lp</span><span class="p">));</span>
	<span class="p">}</span>
	<span class="n">tp</span><span class="o">-&gt;</span><span class="n">nlcb</span><span class="o">++</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 *  Let the itl task point to error handling.</span>
<span class="cm">	 */</span>
	<span class="n">lp</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">.</span><span class="n">itl_task_sa</span> <span class="o">=</span> <span class="n">cpu_to_scr</span><span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">bad_itl_ba</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 *  Set the reselect pattern to our default. :)</span>
<span class="cm">	 */</span>
	<span class="n">lp</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">.</span><span class="n">resel_sa</span> <span class="o">=</span> <span class="n">cpu_to_scr</span><span class="p">(</span><span class="n">SCRIPTB_BA</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">resel_bad_lun</span><span class="p">));</span>

	<span class="cm">/*</span>
<span class="cm">	 *  Set user capabilities.</span>
<span class="cm">	 */</span>
	<span class="n">lp</span><span class="o">-&gt;</span><span class="n">user_flags</span> <span class="o">=</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">usrflags</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">SYM_DISC_ENABLED</span> <span class="o">|</span> <span class="n">SYM_TAGS_ENABLED</span><span class="p">);</span>

<span class="cp">#ifdef SYM_OPT_HANDLE_DEVICE_QUEUEING</span>
	<span class="cm">/*</span>
<span class="cm">	 *  Initialize device queueing.</span>
<span class="cm">	 */</span>
	<span class="n">sym_que_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">waiting_ccbq</span><span class="p">);</span>
	<span class="n">sym_que_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">started_ccbq</span><span class="p">);</span>
	<span class="n">lp</span><span class="o">-&gt;</span><span class="n">started_max</span>   <span class="o">=</span> <span class="n">SYM_CONF_MAX_TASK</span><span class="p">;</span>
	<span class="n">lp</span><span class="o">-&gt;</span><span class="n">started_limit</span> <span class="o">=</span> <span class="n">SYM_CONF_MAX_TASK</span><span class="p">;</span>
<span class="cp">#endif</span>

<span class="nl">fail:</span>
	<span class="k">return</span> <span class="n">lp</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *  Allocate LCB resources for tagged command queuing.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">sym_alloc_lcb_tags</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sym_hcb</span> <span class="o">*</span><span class="n">np</span><span class="p">,</span> <span class="n">u_char</span> <span class="n">tn</span><span class="p">,</span> <span class="n">u_char</span> <span class="n">ln</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sym_tcb</span> <span class="o">*</span><span class="n">tp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">target</span><span class="p">[</span><span class="n">tn</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">sym_lcb</span> <span class="o">*</span><span class="n">lp</span> <span class="o">=</span> <span class="n">sym_lp</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">ln</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 *  Allocate the task table and and the tag allocation </span>
<span class="cm">	 *  circular buffer. We want both or none.</span>
<span class="cm">	 */</span>
	<span class="n">lp</span><span class="o">-&gt;</span><span class="n">itlq_tbl</span> <span class="o">=</span> <span class="n">sym_calloc_dma</span><span class="p">(</span><span class="n">SYM_CONF_MAX_TASK</span><span class="o">*</span><span class="mi">4</span><span class="p">,</span> <span class="s">&quot;ITLQ_TBL&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">itlq_tbl</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
	<span class="n">lp</span><span class="o">-&gt;</span><span class="n">cb_tags</span> <span class="o">=</span> <span class="n">kcalloc</span><span class="p">(</span><span class="n">SYM_CONF_MAX_TASK</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">cb_tags</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">sym_mfree_dma</span><span class="p">(</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">itlq_tbl</span><span class="p">,</span> <span class="n">SYM_CONF_MAX_TASK</span><span class="o">*</span><span class="mi">4</span><span class="p">,</span> <span class="s">&quot;ITLQ_TBL&quot;</span><span class="p">);</span>
		<span class="n">lp</span><span class="o">-&gt;</span><span class="n">itlq_tbl</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 *  Initialize the task table with invalid entries.</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">SYM_CONF_MAX_TASK</span> <span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">lp</span><span class="o">-&gt;</span><span class="n">itlq_tbl</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">cpu_to_scr</span><span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">notask_ba</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 *  Fill up the tag buffer with tag numbers.</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">SYM_CONF_MAX_TASK</span> <span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">lp</span><span class="o">-&gt;</span><span class="n">cb_tags</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 *  Make the task table available to SCRIPTS, </span>
<span class="cm">	 *  And accept tagged commands now.</span>
<span class="cm">	 */</span>
	<span class="n">lp</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">.</span><span class="n">itlq_tbl_sa</span> <span class="o">=</span> <span class="n">cpu_to_scr</span><span class="p">(</span><span class="n">vtobus</span><span class="p">(</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">itlq_tbl</span><span class="p">));</span>

	<span class="k">return</span><span class="p">;</span>
<span class="nl">fail:</span>
	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *  Lun control block deallocation. Returns the number of valid remaining LCBs</span>
<span class="cm"> *  for the target.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">sym_free_lcb</span><span class="p">(</span><span class="k">struct</span> <span class="n">sym_hcb</span> <span class="o">*</span><span class="n">np</span><span class="p">,</span> <span class="n">u_char</span> <span class="n">tn</span><span class="p">,</span> <span class="n">u_char</span> <span class="n">ln</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sym_tcb</span> <span class="o">*</span><span class="n">tp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">target</span><span class="p">[</span><span class="n">tn</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">sym_lcb</span> <span class="o">*</span><span class="n">lp</span> <span class="o">=</span> <span class="n">sym_lp</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">ln</span><span class="p">);</span>

	<span class="n">tp</span><span class="o">-&gt;</span><span class="n">nlcb</span><span class="o">--</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ln</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">nlcb</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">kfree</span><span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">lunmp</span><span class="p">);</span>
			<span class="n">sym_mfree_dma</span><span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">luntbl</span><span class="p">,</span> <span class="mi">256</span><span class="p">,</span> <span class="s">&quot;LUNTBL&quot;</span><span class="p">);</span>
			<span class="n">tp</span><span class="o">-&gt;</span><span class="n">lunmp</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="n">tp</span><span class="o">-&gt;</span><span class="n">luntbl</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="n">tp</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">.</span><span class="n">luntbl_sa</span> <span class="o">=</span> <span class="n">cpu_to_scr</span><span class="p">(</span><span class="n">vtobus</span><span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">badluntbl</span><span class="p">));</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">tp</span><span class="o">-&gt;</span><span class="n">luntbl</span><span class="p">[</span><span class="n">ln</span><span class="p">]</span> <span class="o">=</span> <span class="n">cpu_to_scr</span><span class="p">(</span><span class="n">vtobus</span><span class="p">(</span><span class="o">&amp;</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">badlun_sa</span><span class="p">));</span>
			<span class="n">tp</span><span class="o">-&gt;</span><span class="n">lunmp</span><span class="p">[</span><span class="n">ln</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">tp</span><span class="o">-&gt;</span><span class="n">lun0p</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">tp</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">.</span><span class="n">lun0_sa</span> <span class="o">=</span> <span class="n">cpu_to_scr</span><span class="p">(</span><span class="n">vtobus</span><span class="p">(</span><span class="o">&amp;</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">badlun_sa</span><span class="p">));</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">itlq_tbl</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">sym_mfree_dma</span><span class="p">(</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">itlq_tbl</span><span class="p">,</span> <span class="n">SYM_CONF_MAX_TASK</span><span class="o">*</span><span class="mi">4</span><span class="p">,</span> <span class="s">&quot;ITLQ_TBL&quot;</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">cb_tags</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">sym_mfree_dma</span><span class="p">(</span><span class="n">lp</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">lp</span><span class="p">),</span> <span class="s">&quot;LCB&quot;</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">nlcb</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *  Queue a SCSI IO to the controller.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">sym_queue_scsiio</span><span class="p">(</span><span class="k">struct</span> <span class="n">sym_hcb</span> <span class="o">*</span><span class="n">np</span><span class="p">,</span> <span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sym_ccb</span> <span class="o">*</span><span class="n">cp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="n">sdev</span> <span class="o">=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">device</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sym_tcb</span> <span class="o">*</span><span class="n">tp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sym_lcb</span> <span class="o">*</span><span class="n">lp</span><span class="p">;</span>
	<span class="n">u_char</span>	<span class="o">*</span><span class="n">msgptr</span><span class="p">;</span>
	<span class="n">u_int</span>   <span class="n">msglen</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">can_disconnect</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 *  Keep track of the IO in our CCB.</span>
<span class="cm">	 */</span>
	<span class="n">cp</span><span class="o">-&gt;</span><span class="n">cmd</span> <span class="o">=</span> <span class="n">cmd</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 *  Retrieve the target descriptor.</span>
<span class="cm">	 */</span>
	<span class="n">tp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">target</span><span class="p">[</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">target</span><span class="p">];</span>

	<span class="cm">/*</span>
<span class="cm">	 *  Retrieve the lun descriptor.</span>
<span class="cm">	 */</span>
	<span class="n">lp</span> <span class="o">=</span> <span class="n">sym_lp</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">sdev</span><span class="o">-&gt;</span><span class="n">lun</span><span class="p">);</span>

	<span class="n">can_disconnect</span> <span class="o">=</span> <span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">tag</span> <span class="o">!=</span> <span class="n">NO_TAG</span><span class="p">)</span> <span class="o">||</span>
		<span class="p">(</span><span class="n">lp</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">curr_flags</span> <span class="o">&amp;</span> <span class="n">SYM_DISC_ENABLED</span><span class="p">));</span>

	<span class="n">msgptr</span> <span class="o">=</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">scsi_smsg</span><span class="p">;</span>
	<span class="n">msglen</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">msgptr</span><span class="p">[</span><span class="n">msglen</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">IDENTIFY</span><span class="p">(</span><span class="n">can_disconnect</span><span class="p">,</span> <span class="n">sdev</span><span class="o">-&gt;</span><span class="n">lun</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 *  Build the tag message if present.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">tag</span> <span class="o">!=</span> <span class="n">NO_TAG</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">u_char</span> <span class="n">order</span> <span class="o">=</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">order</span><span class="p">;</span>

		<span class="k">switch</span><span class="p">(</span><span class="n">order</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">M_ORDERED_TAG</span>:
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">M_HEAD_TAG</span>:
			<span class="k">break</span><span class="p">;</span>
		<span class="nl">default:</span>
			<span class="n">order</span> <span class="o">=</span> <span class="n">M_SIMPLE_TAG</span><span class="p">;</span>
		<span class="p">}</span>
<span class="cp">#ifdef SYM_OPT_LIMIT_COMMAND_REORDERING</span>
		<span class="cm">/*</span>
<span class="cm">		 *  Avoid too much reordering of SCSI commands.</span>
<span class="cm">		 *  The algorithm tries to prevent completion of any </span>
<span class="cm">		 *  tagged command from being delayed against more </span>
<span class="cm">		 *  than 3 times the max number of queued commands.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">lp</span> <span class="o">&amp;&amp;</span> <span class="n">lp</span><span class="o">-&gt;</span><span class="n">tags_since</span> <span class="o">&gt;</span> <span class="mi">3</span><span class="o">*</span><span class="n">SYM_CONF_MAX_TAG</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">lp</span><span class="o">-&gt;</span><span class="n">tags_si</span> <span class="o">=</span> <span class="o">!</span><span class="p">(</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">tags_si</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">tags_sum</span><span class="p">[</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">tags_si</span><span class="p">])</span> <span class="p">{</span>
				<span class="n">order</span> <span class="o">=</span> <span class="n">M_ORDERED_TAG</span><span class="p">;</span>
				<span class="k">if</span> <span class="p">((</span><span class="n">DEBUG_FLAGS</span> <span class="o">&amp;</span> <span class="n">DEBUG_TAGS</span><span class="p">)</span><span class="o">||</span><span class="n">sym_verbose</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">sym_print_addr</span><span class="p">(</span><span class="n">cmd</span><span class="p">,</span>
						<span class="s">&quot;ordered tag forced.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
				<span class="p">}</span>
			<span class="p">}</span>
			<span class="n">lp</span><span class="o">-&gt;</span><span class="n">tags_since</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
<span class="cp">#endif</span>
		<span class="n">msgptr</span><span class="p">[</span><span class="n">msglen</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">order</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 *  For less than 128 tags, actual tags are numbered </span>
<span class="cm">		 *  1,3,5,..2*MAXTAGS+1,since we may have to deal </span>
<span class="cm">		 *  with devices that have problems with #TAG 0 or too </span>
<span class="cm">		 *  great #TAG numbers. For more tags (up to 256), </span>
<span class="cm">		 *  we use directly our tag number.</span>
<span class="cm">		 */</span>
<span class="cp">#if SYM_CONF_MAX_TASK &gt; (512/4)</span>
		<span class="n">msgptr</span><span class="p">[</span><span class="n">msglen</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">tag</span><span class="p">;</span>
<span class="cp">#else</span>
		<span class="n">msgptr</span><span class="p">[</span><span class="n">msglen</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">tag</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 *  Build a negotiation message if needed.</span>
<span class="cm">	 *  (nego_status is filled by sym_prepare_nego())</span>
<span class="cm">	 *</span>
<span class="cm">	 *  Always negotiate on INQUIRY and REQUEST SENSE.</span>
<span class="cm">	 *</span>
<span class="cm">	 */</span>
	<span class="n">cp</span><span class="o">-&gt;</span><span class="n">nego_status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">tgoal</span><span class="p">.</span><span class="n">check_nego</span> <span class="o">||</span>
	     <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">INQUIRY</span> <span class="o">||</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">REQUEST_SENSE</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="o">!</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">nego_cp</span> <span class="o">&amp;&amp;</span> <span class="n">lp</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">msglen</span> <span class="o">+=</span> <span class="n">sym_prepare_nego</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">cp</span><span class="p">,</span> <span class="n">msgptr</span> <span class="o">+</span> <span class="n">msglen</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 *  Startqueue</span>
<span class="cm">	 */</span>
	<span class="n">cp</span><span class="o">-&gt;</span><span class="n">phys</span><span class="p">.</span><span class="n">head</span><span class="p">.</span><span class="n">go</span><span class="p">.</span><span class="n">start</span>   <span class="o">=</span> <span class="n">cpu_to_scr</span><span class="p">(</span><span class="n">SCRIPTA_BA</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">select</span><span class="p">));</span>
	<span class="n">cp</span><span class="o">-&gt;</span><span class="n">phys</span><span class="p">.</span><span class="n">head</span><span class="p">.</span><span class="n">go</span><span class="p">.</span><span class="n">restart</span> <span class="o">=</span> <span class="n">cpu_to_scr</span><span class="p">(</span><span class="n">SCRIPTA_BA</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">resel_dsa</span><span class="p">));</span>

	<span class="cm">/*</span>
<span class="cm">	 *  select</span>
<span class="cm">	 */</span>
	<span class="n">cp</span><span class="o">-&gt;</span><span class="n">phys</span><span class="p">.</span><span class="n">select</span><span class="p">.</span><span class="n">sel_id</span>		<span class="o">=</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">target</span><span class="p">;</span>
	<span class="n">cp</span><span class="o">-&gt;</span><span class="n">phys</span><span class="p">.</span><span class="n">select</span><span class="p">.</span><span class="n">sel_scntl3</span>	<span class="o">=</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">.</span><span class="n">wval</span><span class="p">;</span>
	<span class="n">cp</span><span class="o">-&gt;</span><span class="n">phys</span><span class="p">.</span><span class="n">select</span><span class="p">.</span><span class="n">sel_sxfer</span>	<span class="o">=</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">.</span><span class="n">sval</span><span class="p">;</span>
	<span class="n">cp</span><span class="o">-&gt;</span><span class="n">phys</span><span class="p">.</span><span class="n">select</span><span class="p">.</span><span class="n">sel_scntl4</span>	<span class="o">=</span> <span class="n">tp</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">.</span><span class="n">uval</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 *  message</span>
<span class="cm">	 */</span>
	<span class="n">cp</span><span class="o">-&gt;</span><span class="n">phys</span><span class="p">.</span><span class="n">smsg</span><span class="p">.</span><span class="n">addr</span>	<span class="o">=</span> <span class="n">CCB_BA</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">scsi_smsg</span><span class="p">);</span>
	<span class="n">cp</span><span class="o">-&gt;</span><span class="n">phys</span><span class="p">.</span><span class="n">smsg</span><span class="p">.</span><span class="n">size</span>	<span class="o">=</span> <span class="n">cpu_to_scr</span><span class="p">(</span><span class="n">msglen</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 *  status</span>
<span class="cm">	 */</span>
	<span class="n">cp</span><span class="o">-&gt;</span><span class="n">host_xflags</span>		<span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">cp</span><span class="o">-&gt;</span><span class="n">host_status</span>		<span class="o">=</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">nego_status</span> <span class="o">?</span> <span class="n">HS_NEGOTIATE</span> <span class="o">:</span> <span class="n">HS_BUSY</span><span class="p">;</span>
	<span class="n">cp</span><span class="o">-&gt;</span><span class="n">ssss_status</span>		<span class="o">=</span> <span class="n">S_ILLEGAL</span><span class="p">;</span>
	<span class="n">cp</span><span class="o">-&gt;</span><span class="n">xerr_status</span>		<span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">cp</span><span class="o">-&gt;</span><span class="n">host_flags</span>		<span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">cp</span><span class="o">-&gt;</span><span class="n">extra_bytes</span>		<span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 *  extreme data pointer.</span>
<span class="cm">	 *  shall be positive, so -1 is lower than lowest.:)</span>
<span class="cm">	 */</span>
	<span class="n">cp</span><span class="o">-&gt;</span><span class="n">ext_sg</span>  <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">cp</span><span class="o">-&gt;</span><span class="n">ext_ofs</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 *  Build the CDB and DATA descriptor block </span>
<span class="cm">	 *  and start the IO.</span>
<span class="cm">	 */</span>
	<span class="k">return</span> <span class="n">sym_setup_data_and_start</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">cmd</span><span class="p">,</span> <span class="n">cp</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *  Reset a SCSI target (all LUNs of this target).</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">sym_reset_scsi_target</span><span class="p">(</span><span class="k">struct</span> <span class="n">sym_hcb</span> <span class="o">*</span><span class="n">np</span><span class="p">,</span> <span class="kt">int</span> <span class="n">target</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sym_tcb</span> <span class="o">*</span><span class="n">tp</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">target</span> <span class="o">==</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">myaddr</span> <span class="o">||</span> <span class="p">(</span><span class="n">u_int</span><span class="p">)</span><span class="n">target</span> <span class="o">&gt;=</span> <span class="n">SYM_CONF_MAX_TARGET</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="n">tp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">target</span><span class="p">[</span><span class="n">target</span><span class="p">];</span>
	<span class="n">tp</span><span class="o">-&gt;</span><span class="n">to_reset</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">np</span><span class="o">-&gt;</span><span class="n">istat_sem</span> <span class="o">=</span> <span class="n">SEM</span><span class="p">;</span>
	<span class="n">OUTB</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">nc_istat</span><span class="p">,</span> <span class="n">SIGP</span><span class="o">|</span><span class="n">SEM</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *  Abort a SCSI IO.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">sym_abort_ccb</span><span class="p">(</span><span class="k">struct</span> <span class="n">sym_hcb</span> <span class="o">*</span><span class="n">np</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sym_ccb</span> <span class="o">*</span><span class="n">cp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">timed_out</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 *  Check that the IO is active.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cp</span> <span class="o">||</span> <span class="o">!</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">host_status</span> <span class="o">||</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">host_status</span> <span class="o">==</span> <span class="n">HS_WAIT</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 *  If a previous abort didn&#39;t succeed in time,</span>
<span class="cm">	 *  perform a BUS reset.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">to_abort</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">sym_reset_scsi_bus</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 *  Mark the CCB for abort and allow time for.</span>
<span class="cm">	 */</span>
	<span class="n">cp</span><span class="o">-&gt;</span><span class="n">to_abort</span> <span class="o">=</span> <span class="n">timed_out</span> <span class="o">?</span> <span class="mi">2</span> <span class="o">:</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 *  Tell the SCRIPTS processor to stop and synchronize with us.</span>
<span class="cm">	 */</span>
	<span class="n">np</span><span class="o">-&gt;</span><span class="n">istat_sem</span> <span class="o">=</span> <span class="n">SEM</span><span class="p">;</span>
	<span class="n">OUTB</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">nc_istat</span><span class="p">,</span> <span class="n">SIGP</span><span class="o">|</span><span class="n">SEM</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">sym_abort_scsiio</span><span class="p">(</span><span class="k">struct</span> <span class="n">sym_hcb</span> <span class="o">*</span><span class="n">np</span><span class="p">,</span> <span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">,</span> <span class="kt">int</span> <span class="n">timed_out</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sym_ccb</span> <span class="o">*</span><span class="n">cp</span><span class="p">;</span>
	<span class="n">SYM_QUEHEAD</span> <span class="o">*</span><span class="n">qp</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 *  Look up our CCB control block.</span>
<span class="cm">	 */</span>
	<span class="n">cp</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">FOR_EACH_QUEUED_ELEMENT</span><span class="p">(</span><span class="o">&amp;</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">busy_ccbq</span><span class="p">,</span> <span class="n">qp</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">sym_ccb</span> <span class="o">*</span><span class="n">cp2</span> <span class="o">=</span> <span class="n">sym_que_entry</span><span class="p">(</span><span class="n">qp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sym_ccb</span><span class="p">,</span> <span class="n">link_ccbq</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cp2</span><span class="o">-&gt;</span><span class="n">cmd</span> <span class="o">==</span> <span class="n">cmd</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">cp</span> <span class="o">=</span> <span class="n">cp2</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">sym_abort_ccb</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">cp</span><span class="p">,</span> <span class="n">timed_out</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *  Complete execution of a SCSI command with extended </span>
<span class="cm"> *  error, SCSI status error, or having been auto-sensed.</span>
<span class="cm"> *</span>
<span class="cm"> *  The SCRIPTS processor is not running there, so we </span>
<span class="cm"> *  can safely access IO registers and remove JOBs from  </span>
<span class="cm"> *  the START queue.</span>
<span class="cm"> *  SCRATCHA is assumed to have been loaded with STARTPOS </span>
<span class="cm"> *  before the SCRIPTS called the C code.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">sym_complete_error</span><span class="p">(</span><span class="k">struct</span> <span class="n">sym_hcb</span> <span class="o">*</span><span class="n">np</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sym_ccb</span> <span class="o">*</span><span class="n">cp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="n">sdev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sym_tcb</span> <span class="o">*</span><span class="n">tp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sym_lcb</span> <span class="o">*</span><span class="n">lp</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">resid</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 *  Paranoid check. :)</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cp</span> <span class="o">||</span> <span class="o">!</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">cmd</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">cmd</span> <span class="o">=</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">cmd</span><span class="p">;</span>
	<span class="n">sdev</span> <span class="o">=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">device</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">DEBUG_FLAGS</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">DEBUG_TINY</span><span class="o">|</span><span class="n">DEBUG_RESULT</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dev_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">sdev_gendev</span><span class="p">,</span> <span class="s">&quot;CCB=%p STAT=%x/%x/%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">cp</span><span class="p">,</span>
			<span class="n">cp</span><span class="o">-&gt;</span><span class="n">host_status</span><span class="p">,</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">ssss_status</span><span class="p">,</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">host_flags</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 *  Get target and lun pointers.</span>
<span class="cm">	 */</span>
	<span class="n">tp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">target</span><span class="p">[</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">target</span><span class="p">];</span>
	<span class="n">lp</span> <span class="o">=</span> <span class="n">sym_lp</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">sdev</span><span class="o">-&gt;</span><span class="n">lun</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 *  Check for extended errors.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">xerr_status</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sym_verbose</span><span class="p">)</span>
			<span class="n">sym_print_xerr</span><span class="p">(</span><span class="n">cmd</span><span class="p">,</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">xerr_status</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">host_status</span> <span class="o">==</span> <span class="n">HS_COMPLETE</span><span class="p">)</span>
			<span class="n">cp</span><span class="o">-&gt;</span><span class="n">host_status</span> <span class="o">=</span> <span class="n">HS_COMP_ERR</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 *  Calculate the residual.</span>
<span class="cm">	 */</span>
	<span class="n">resid</span> <span class="o">=</span> <span class="n">sym_compute_residual</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">cp</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">SYM_SETUP_RESIDUAL_SUPPORT</span><span class="p">)</span> <span class="p">{</span><span class="cm">/* If user does not want residuals */</span>
		<span class="n">resid</span>  <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>		 <span class="cm">/* throw them away. :)		    */</span>
		<span class="n">cp</span><span class="o">-&gt;</span><span class="n">sv_resid</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
<span class="cp">#ifdef DEBUG_2_0_X</span>
<span class="k">if</span> <span class="p">(</span><span class="n">resid</span><span class="p">)</span>
	<span class="n">printf</span><span class="p">(</span><span class="s">&quot;XXXX RESID= %d - 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">resid</span><span class="p">,</span> <span class="n">resid</span><span class="p">);</span>
<span class="cp">#endif</span>

	<span class="cm">/*</span>
<span class="cm">	 *  Dequeue all queued CCBs for that device </span>
<span class="cm">	 *  not yet started by SCRIPTS.</span>
<span class="cm">	 */</span>
	<span class="n">i</span> <span class="o">=</span> <span class="p">(</span><span class="n">INL</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">nc_scratcha</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">squeue_ba</span><span class="p">)</span> <span class="o">/</span> <span class="mi">4</span><span class="p">;</span>
	<span class="n">i</span> <span class="o">=</span> <span class="n">sym_dequeue_from_squeue</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">target</span><span class="p">,</span> <span class="n">sdev</span><span class="o">-&gt;</span><span class="n">lun</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 *  Restart the SCRIPTS processor.</span>
<span class="cm">	 */</span>
	<span class="n">OUTL_DSP</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">SCRIPTA_BA</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">start</span><span class="p">));</span>

<span class="cp">#ifdef SYM_OPT_HANDLE_DEVICE_QUEUEING</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">host_status</span> <span class="o">==</span> <span class="n">HS_COMPLETE</span> <span class="o">&amp;&amp;</span>
	    <span class="n">cp</span><span class="o">-&gt;</span><span class="n">ssss_status</span> <span class="o">==</span> <span class="n">S_QUEUE_FULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">lp</span> <span class="o">||</span> <span class="n">lp</span><span class="o">-&gt;</span><span class="n">started_tags</span> <span class="o">-</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">weirdness</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 *  Decrease queue depth as needed.</span>
<span class="cm">		 */</span>
		<span class="n">lp</span><span class="o">-&gt;</span><span class="n">started_max</span> <span class="o">=</span> <span class="n">lp</span><span class="o">-&gt;</span><span class="n">started_tags</span> <span class="o">-</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">lp</span><span class="o">-&gt;</span><span class="n">num_sgood</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">sym_verbose</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">sym_print_addr</span><span class="p">(</span><span class="n">cmd</span><span class="p">,</span> <span class="s">&quot; queue depth is now %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">lp</span><span class="o">-&gt;</span><span class="n">started_max</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 *  Repair the CCB.</span>
<span class="cm">		 */</span>
		<span class="n">cp</span><span class="o">-&gt;</span><span class="n">host_status</span> <span class="o">=</span> <span class="n">HS_BUSY</span><span class="p">;</span>
		<span class="n">cp</span><span class="o">-&gt;</span><span class="n">ssss_status</span> <span class="o">=</span> <span class="n">S_ILLEGAL</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 *  Let&#39;s requeue it to device.</span>
<span class="cm">		 */</span>
		<span class="n">sym_set_cam_status</span><span class="p">(</span><span class="n">cmd</span><span class="p">,</span> <span class="n">DID_SOFT_ERROR</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">finish</span><span class="p">;</span>
	<span class="p">}</span>
<span class="nl">weirdness:</span>
<span class="cp">#endif</span>
	<span class="cm">/*</span>
<span class="cm">	 *  Build result in CAM ccb.</span>
<span class="cm">	 */</span>
	<span class="n">sym_set_cam_result_error</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">cp</span><span class="p">,</span> <span class="n">resid</span><span class="p">);</span>

<span class="cp">#ifdef SYM_OPT_HANDLE_DEVICE_QUEUEING</span>
<span class="nl">finish:</span>
<span class="cp">#endif</span>
	<span class="cm">/*</span>
<span class="cm">	 *  Add this one to the COMP queue.</span>
<span class="cm">	 */</span>
	<span class="n">sym_remque</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">link_ccbq</span><span class="p">);</span>
	<span class="n">sym_insque_head</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">link_ccbq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">comp_ccbq</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 *  Complete all those commands with either error </span>
<span class="cm">	 *  or requeue condition.</span>
<span class="cm">	 */</span>
	<span class="n">sym_flush_comp_queue</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

<span class="cp">#ifdef SYM_OPT_HANDLE_DEVICE_QUEUEING</span>
	<span class="cm">/*</span>
<span class="cm">	 *  Donnot start more than 1 command after an error.</span>
<span class="cm">	 */</span>
	<span class="n">sym_start_next_ccbs</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">lp</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *  Complete execution of a successful SCSI command.</span>
<span class="cm"> *</span>
<span class="cm"> *  Only successful commands go to the DONE queue, </span>
<span class="cm"> *  since we need to have the SCRIPTS processor </span>
<span class="cm"> *  stopped on any error condition.</span>
<span class="cm"> *  The SCRIPTS processor is running while we are </span>
<span class="cm"> *  completing successful commands.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">sym_complete_ok</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sym_hcb</span> <span class="o">*</span><span class="n">np</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sym_ccb</span> <span class="o">*</span><span class="n">cp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sym_tcb</span> <span class="o">*</span><span class="n">tp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sym_lcb</span> <span class="o">*</span><span class="n">lp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">resid</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 *  Paranoid check. :)</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cp</span> <span class="o">||</span> <span class="o">!</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">cmd</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">assert</span> <span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">host_status</span> <span class="o">==</span> <span class="n">HS_COMPLETE</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 *  Get user command.</span>
<span class="cm">	 */</span>
	<span class="n">cmd</span> <span class="o">=</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">cmd</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 *  Get target and lun pointers.</span>
<span class="cm">	 */</span>
	<span class="n">tp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">target</span><span class="p">[</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">target</span><span class="p">];</span>
	<span class="n">lp</span> <span class="o">=</span> <span class="n">sym_lp</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">lun</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 *  If all data have been transferred, given than no</span>
<span class="cm">	 *  extended error did occur, there is no residual.</span>
<span class="cm">	 */</span>
	<span class="n">resid</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cp</span><span class="o">-&gt;</span><span class="n">phys</span><span class="p">.</span><span class="n">head</span><span class="p">.</span><span class="n">lastp</span> <span class="o">!=</span> <span class="n">cp</span><span class="o">-&gt;</span><span class="n">goalp</span><span class="p">)</span>
		<span class="n">resid</span> <span class="o">=</span> <span class="n">sym_compute_residual</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">cp</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 *  Wrong transfer residuals may be worse than just always </span>
<span class="cm">	 *  returning zero. User can disable this feature in </span>
<span class="cm">	 *  sym53c8xx.h. Residual support is enabled by default.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">SYM_SETUP_RESIDUAL_SUPPORT</span><span class="p">)</span>
		<span class="n">resid</span>  <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="cp">#ifdef DEBUG_2_0_X</span>
<span class="k">if</span> <span class="p">(</span><span class="n">resid</span><span class="p">)</span>
	<span class="n">printf</span><span class="p">(</span><span class="s">&quot;XXXX RESID= %d - 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">resid</span><span class="p">,</span> <span class="n">resid</span><span class="p">);</span>
<span class="cp">#endif</span>

	<span class="cm">/*</span>
<span class="cm">	 *  Build result in CAM ccb.</span>
<span class="cm">	 */</span>
	<span class="n">sym_set_cam_result_ok</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">cmd</span><span class="p">,</span> <span class="n">resid</span><span class="p">);</span>

<span class="cp">#ifdef SYM_OPT_HANDLE_DEVICE_QUEUEING</span>
	<span class="cm">/*</span>
<span class="cm">	 *  If max number of started ccbs had been reduced,</span>
<span class="cm">	 *  increase it if 200 good status received.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">lp</span> <span class="o">&amp;&amp;</span> <span class="n">lp</span><span class="o">-&gt;</span><span class="n">started_max</span> <span class="o">&lt;</span> <span class="n">lp</span><span class="o">-&gt;</span><span class="n">started_limit</span><span class="p">)</span> <span class="p">{</span>
		<span class="o">++</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">num_sgood</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">num_sgood</span> <span class="o">&gt;=</span> <span class="mi">200</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">lp</span><span class="o">-&gt;</span><span class="n">num_sgood</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="o">++</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">started_max</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">sym_verbose</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">sym_print_addr</span><span class="p">(</span><span class="n">cmd</span><span class="p">,</span> <span class="s">&quot; queue depth is now %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				       <span class="n">lp</span><span class="o">-&gt;</span><span class="n">started_max</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="cp">#endif</span>

	<span class="cm">/*</span>
<span class="cm">	 *  Free our CCB.</span>
<span class="cm">	 */</span>
	<span class="n">sym_free_ccb</span> <span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">cp</span><span class="p">);</span>

<span class="cp">#ifdef SYM_OPT_HANDLE_DEVICE_QUEUEING</span>
	<span class="cm">/*</span>
<span class="cm">	 *  Requeue a couple of awaiting scsi commands.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sym_que_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">waiting_ccbq</span><span class="p">))</span>
		<span class="n">sym_start_next_ccbs</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">lp</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="cm">/*</span>
<span class="cm">	 *  Complete the command.</span>
<span class="cm">	 */</span>
	<span class="n">sym_xpt_done</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">cmd</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *  Soft-attach the controller.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">sym_hcb_attach</span><span class="p">(</span><span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sym_fw</span> <span class="o">*</span><span class="n">fw</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sym_nvram</span> <span class="o">*</span><span class="n">nvram</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sym_hcb</span> <span class="o">*</span><span class="n">np</span> <span class="o">=</span> <span class="n">sym_get_hcb</span><span class="p">(</span><span class="n">shost</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 *  Get some info about the firmware.</span>
<span class="cm">	 */</span>
	<span class="n">np</span><span class="o">-&gt;</span><span class="n">scripta_sz</span>	 <span class="o">=</span> <span class="n">fw</span><span class="o">-&gt;</span><span class="n">a_size</span><span class="p">;</span>
	<span class="n">np</span><span class="o">-&gt;</span><span class="n">scriptb_sz</span>	 <span class="o">=</span> <span class="n">fw</span><span class="o">-&gt;</span><span class="n">b_size</span><span class="p">;</span>
	<span class="n">np</span><span class="o">-&gt;</span><span class="n">scriptz_sz</span>	 <span class="o">=</span> <span class="n">fw</span><span class="o">-&gt;</span><span class="n">z_size</span><span class="p">;</span>
	<span class="n">np</span><span class="o">-&gt;</span><span class="n">fw_setup</span>	 <span class="o">=</span> <span class="n">fw</span><span class="o">-&gt;</span><span class="n">setup</span><span class="p">;</span>
	<span class="n">np</span><span class="o">-&gt;</span><span class="n">fw_patch</span>	 <span class="o">=</span> <span class="n">fw</span><span class="o">-&gt;</span><span class="n">patch</span><span class="p">;</span>
	<span class="n">np</span><span class="o">-&gt;</span><span class="n">fw_name</span>	 <span class="o">=</span> <span class="n">fw</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 *  Save setting of some IO registers, so we will </span>
<span class="cm">	 *  be able to probe specific implementations.</span>
<span class="cm">	 */</span>
	<span class="n">sym_save_initial_setting</span> <span class="p">(</span><span class="n">np</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 *  Reset the chip now, since it has been reported </span>
<span class="cm">	 *  that SCSI clock calibration may not work properly </span>
<span class="cm">	 *  if the chip is currently active.</span>
<span class="cm">	 */</span>
	<span class="n">sym_chip_reset</span><span class="p">(</span><span class="n">np</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 *  Prepare controller and devices settings, according </span>
<span class="cm">	 *  to chip features, user set-up and driver set-up.</span>
<span class="cm">	 */</span>
	<span class="n">sym_prepare_setting</span><span class="p">(</span><span class="n">shost</span><span class="p">,</span> <span class="n">np</span><span class="p">,</span> <span class="n">nvram</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 *  Check the PCI clock frequency.</span>
<span class="cm">	 *  Must be performed after prepare_setting since it destroys </span>
<span class="cm">	 *  STEST1 that is used to probe for the clock doubler.</span>
<span class="cm">	 */</span>
	<span class="n">i</span> <span class="o">=</span> <span class="n">sym_getpciclock</span><span class="p">(</span><span class="n">np</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&gt;</span> <span class="mi">37000</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">features</span> <span class="o">&amp;</span> <span class="n">FE_66MHZ</span><span class="p">))</span>
		<span class="n">printf</span><span class="p">(</span><span class="s">&quot;%s: PCI BUS clock seems too high: %u KHz.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">sym_name</span><span class="p">(</span><span class="n">np</span><span class="p">),</span> <span class="n">i</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 *  Allocate the start queue.</span>
<span class="cm">	 */</span>
	<span class="n">np</span><span class="o">-&gt;</span><span class="n">squeue</span> <span class="o">=</span> <span class="n">sym_calloc_dma</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">u32</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">MAX_QUEUE</span><span class="o">*</span><span class="mi">2</span><span class="p">),</span><span class="s">&quot;SQUEUE&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">squeue</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">attach_failed</span><span class="p">;</span>
	<span class="n">np</span><span class="o">-&gt;</span><span class="n">squeue_ba</span> <span class="o">=</span> <span class="n">vtobus</span><span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">squeue</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 *  Allocate the done queue.</span>
<span class="cm">	 */</span>
	<span class="n">np</span><span class="o">-&gt;</span><span class="n">dqueue</span> <span class="o">=</span> <span class="n">sym_calloc_dma</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">u32</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">MAX_QUEUE</span><span class="o">*</span><span class="mi">2</span><span class="p">),</span><span class="s">&quot;DQUEUE&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">dqueue</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">attach_failed</span><span class="p">;</span>
	<span class="n">np</span><span class="o">-&gt;</span><span class="n">dqueue_ba</span> <span class="o">=</span> <span class="n">vtobus</span><span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">dqueue</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 *  Allocate the target bus address array.</span>
<span class="cm">	 */</span>
	<span class="n">np</span><span class="o">-&gt;</span><span class="n">targtbl</span> <span class="o">=</span> <span class="n">sym_calloc_dma</span><span class="p">(</span><span class="mi">256</span><span class="p">,</span> <span class="s">&quot;TARGTBL&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">targtbl</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">attach_failed</span><span class="p">;</span>
	<span class="n">np</span><span class="o">-&gt;</span><span class="n">targtbl_ba</span> <span class="o">=</span> <span class="n">vtobus</span><span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">targtbl</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 *  Allocate SCRIPTS areas.</span>
<span class="cm">	 */</span>
	<span class="n">np</span><span class="o">-&gt;</span><span class="n">scripta0</span> <span class="o">=</span> <span class="n">sym_calloc_dma</span><span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">scripta_sz</span><span class="p">,</span> <span class="s">&quot;SCRIPTA0&quot;</span><span class="p">);</span>
	<span class="n">np</span><span class="o">-&gt;</span><span class="n">scriptb0</span> <span class="o">=</span> <span class="n">sym_calloc_dma</span><span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">scriptb_sz</span><span class="p">,</span> <span class="s">&quot;SCRIPTB0&quot;</span><span class="p">);</span>
	<span class="n">np</span><span class="o">-&gt;</span><span class="n">scriptz0</span> <span class="o">=</span> <span class="n">sym_calloc_dma</span><span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">scriptz_sz</span><span class="p">,</span> <span class="s">&quot;SCRIPTZ0&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">scripta0</span> <span class="o">||</span> <span class="o">!</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">scriptb0</span> <span class="o">||</span> <span class="o">!</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">scriptz0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">attach_failed</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 *  Allocate the array of lists of CCBs hashed by DSA.</span>
<span class="cm">	 */</span>
	<span class="n">np</span><span class="o">-&gt;</span><span class="n">ccbh</span> <span class="o">=</span> <span class="n">kcalloc</span><span class="p">(</span><span class="n">CCB_HASH_SIZE</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sym_ccb</span> <span class="o">**</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">ccbh</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">attach_failed</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 *  Initialyze the CCB free and busy queues.</span>
<span class="cm">	 */</span>
	<span class="n">sym_que_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">free_ccbq</span><span class="p">);</span>
	<span class="n">sym_que_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">busy_ccbq</span><span class="p">);</span>
	<span class="n">sym_que_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">comp_ccbq</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 *  Initialization for optional handling </span>
<span class="cm">	 *  of device queueing.</span>
<span class="cm">	 */</span>
<span class="cp">#ifdef SYM_OPT_HANDLE_DEVICE_QUEUEING</span>
	<span class="n">sym_que_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">dummy_ccbq</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="cm">/*</span>
<span class="cm">	 *  Allocate some CCB. We need at least ONE.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sym_alloc_ccb</span><span class="p">(</span><span class="n">np</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">attach_failed</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 *  Calculate BUS addresses where we are going </span>
<span class="cm">	 *  to load the SCRIPTS.</span>
<span class="cm">	 */</span>
	<span class="n">np</span><span class="o">-&gt;</span><span class="n">scripta_ba</span>	<span class="o">=</span> <span class="n">vtobus</span><span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">scripta0</span><span class="p">);</span>
	<span class="n">np</span><span class="o">-&gt;</span><span class="n">scriptb_ba</span>	<span class="o">=</span> <span class="n">vtobus</span><span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">scriptb0</span><span class="p">);</span>
	<span class="n">np</span><span class="o">-&gt;</span><span class="n">scriptz_ba</span>	<span class="o">=</span> <span class="n">vtobus</span><span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">scriptz0</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">ram_ba</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">np</span><span class="o">-&gt;</span><span class="n">scripta_ba</span> <span class="o">=</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">ram_ba</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">features</span> <span class="o">&amp;</span> <span class="n">FE_RAM8K</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">np</span><span class="o">-&gt;</span><span class="n">scriptb_ba</span> <span class="o">=</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">scripta_ba</span> <span class="o">+</span> <span class="mi">4096</span><span class="p">;</span>
<span class="cp">#if 0</span><span class="c">	/* May get useful for 64 BIT PCI addressing */</span>
<span class="c">			np-&gt;scr_ram_seg = cpu_to_scr(np-&gt;scripta_ba &gt;&gt; 32);</span>
<span class="cp">#endif</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 *  Copy scripts to controller instance.</span>
<span class="cm">	 */</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">scripta0</span><span class="p">,</span> <span class="n">fw</span><span class="o">-&gt;</span><span class="n">a_base</span><span class="p">,</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">scripta_sz</span><span class="p">);</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">scriptb0</span><span class="p">,</span> <span class="n">fw</span><span class="o">-&gt;</span><span class="n">b_base</span><span class="p">,</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">scriptb_sz</span><span class="p">);</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">scriptz0</span><span class="p">,</span> <span class="n">fw</span><span class="o">-&gt;</span><span class="n">z_base</span><span class="p">,</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">scriptz_sz</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 *  Setup variable parts in scripts and compute</span>
<span class="cm">	 *  scripts bus addresses used from the C code.</span>
<span class="cm">	 */</span>
	<span class="n">np</span><span class="o">-&gt;</span><span class="n">fw_setup</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">fw</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 *  Bind SCRIPTS with physical addresses usable by the </span>
<span class="cm">	 *  SCRIPTS processor (as seen from the BUS = BUS addresses).</span>
<span class="cm">	 */</span>
	<span class="n">sym_fw_bind_script</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="p">(</span><span class="n">u32</span> <span class="o">*</span><span class="p">)</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">scripta0</span><span class="p">,</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">scripta_sz</span><span class="p">);</span>
	<span class="n">sym_fw_bind_script</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="p">(</span><span class="n">u32</span> <span class="o">*</span><span class="p">)</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">scriptb0</span><span class="p">,</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">scriptb_sz</span><span class="p">);</span>
	<span class="n">sym_fw_bind_script</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="p">(</span><span class="n">u32</span> <span class="o">*</span><span class="p">)</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">scriptz0</span><span class="p">,</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">scriptz_sz</span><span class="p">);</span>

<span class="cp">#ifdef SYM_CONF_IARB_SUPPORT</span>
	<span class="cm">/*</span>
<span class="cm">	 *    If user wants IARB to be set when we win arbitration </span>
<span class="cm">	 *    and have other jobs, compute the max number of consecutive </span>
<span class="cm">	 *    settings of IARB hints before we leave devices a chance to </span>
<span class="cm">	 *    arbitrate for reselection.</span>
<span class="cm">	 */</span>
<span class="cp">#ifdef	SYM_SETUP_IARB_MAX</span>
	<span class="n">np</span><span class="o">-&gt;</span><span class="n">iarb_max</span> <span class="o">=</span> <span class="n">SYM_SETUP_IARB_MAX</span><span class="p">;</span>
<span class="cp">#else</span>
	<span class="n">np</span><span class="o">-&gt;</span><span class="n">iarb_max</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="cp">#endif</span>

	<span class="cm">/*</span>
<span class="cm">	 *  Prepare the idle and invalid task actions.</span>
<span class="cm">	 */</span>
	<span class="n">np</span><span class="o">-&gt;</span><span class="n">idletask</span><span class="p">.</span><span class="n">start</span>	<span class="o">=</span> <span class="n">cpu_to_scr</span><span class="p">(</span><span class="n">SCRIPTA_BA</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">idle</span><span class="p">));</span>
	<span class="n">np</span><span class="o">-&gt;</span><span class="n">idletask</span><span class="p">.</span><span class="n">restart</span>	<span class="o">=</span> <span class="n">cpu_to_scr</span><span class="p">(</span><span class="n">SCRIPTB_BA</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">bad_i_t_l</span><span class="p">));</span>
	<span class="n">np</span><span class="o">-&gt;</span><span class="n">idletask_ba</span>		<span class="o">=</span> <span class="n">vtobus</span><span class="p">(</span><span class="o">&amp;</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">idletask</span><span class="p">);</span>

	<span class="n">np</span><span class="o">-&gt;</span><span class="n">notask</span><span class="p">.</span><span class="n">start</span>	<span class="o">=</span> <span class="n">cpu_to_scr</span><span class="p">(</span><span class="n">SCRIPTA_BA</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">idle</span><span class="p">));</span>
	<span class="n">np</span><span class="o">-&gt;</span><span class="n">notask</span><span class="p">.</span><span class="n">restart</span>	<span class="o">=</span> <span class="n">cpu_to_scr</span><span class="p">(</span><span class="n">SCRIPTB_BA</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">bad_i_t_l</span><span class="p">));</span>
	<span class="n">np</span><span class="o">-&gt;</span><span class="n">notask_ba</span>		<span class="o">=</span> <span class="n">vtobus</span><span class="p">(</span><span class="o">&amp;</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">notask</span><span class="p">);</span>

	<span class="n">np</span><span class="o">-&gt;</span><span class="n">bad_itl</span><span class="p">.</span><span class="n">start</span>	<span class="o">=</span> <span class="n">cpu_to_scr</span><span class="p">(</span><span class="n">SCRIPTA_BA</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">idle</span><span class="p">));</span>
	<span class="n">np</span><span class="o">-&gt;</span><span class="n">bad_itl</span><span class="p">.</span><span class="n">restart</span>	<span class="o">=</span> <span class="n">cpu_to_scr</span><span class="p">(</span><span class="n">SCRIPTB_BA</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">bad_i_t_l</span><span class="p">));</span>
	<span class="n">np</span><span class="o">-&gt;</span><span class="n">bad_itl_ba</span>		<span class="o">=</span> <span class="n">vtobus</span><span class="p">(</span><span class="o">&amp;</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">bad_itl</span><span class="p">);</span>

	<span class="n">np</span><span class="o">-&gt;</span><span class="n">bad_itlq</span><span class="p">.</span><span class="n">start</span>	<span class="o">=</span> <span class="n">cpu_to_scr</span><span class="p">(</span><span class="n">SCRIPTA_BA</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">idle</span><span class="p">));</span>
	<span class="n">np</span><span class="o">-&gt;</span><span class="n">bad_itlq</span><span class="p">.</span><span class="n">restart</span>	<span class="o">=</span> <span class="n">cpu_to_scr</span><span class="p">(</span><span class="n">SCRIPTB_BA</span><span class="p">(</span><span class="n">np</span><span class="p">,</span><span class="n">bad_i_t_l_q</span><span class="p">));</span>
	<span class="n">np</span><span class="o">-&gt;</span><span class="n">bad_itlq_ba</span>		<span class="o">=</span> <span class="n">vtobus</span><span class="p">(</span><span class="o">&amp;</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">bad_itlq</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 *  Allocate and prepare the lun JUMP table that is used </span>
<span class="cm">	 *  for a target prior the probing of devices (bad lun table).</span>
<span class="cm">	 *  A private table will be allocated for the target on the </span>
<span class="cm">	 *  first INQUIRY response received.</span>
<span class="cm">	 */</span>
	<span class="n">np</span><span class="o">-&gt;</span><span class="n">badluntbl</span> <span class="o">=</span> <span class="n">sym_calloc_dma</span><span class="p">(</span><span class="mi">256</span><span class="p">,</span> <span class="s">&quot;BADLUNTBL&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">badluntbl</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">attach_failed</span><span class="p">;</span>

	<span class="n">np</span><span class="o">-&gt;</span><span class="n">badlun_sa</span> <span class="o">=</span> <span class="n">cpu_to_scr</span><span class="p">(</span><span class="n">SCRIPTB_BA</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">resel_bad_lun</span><span class="p">));</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">64</span> <span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>	<span class="cm">/* 64 luns/target, no less */</span>
		<span class="n">np</span><span class="o">-&gt;</span><span class="n">badluntbl</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">cpu_to_scr</span><span class="p">(</span><span class="n">vtobus</span><span class="p">(</span><span class="o">&amp;</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">badlun_sa</span><span class="p">));</span>

	<span class="cm">/*</span>
<span class="cm">	 *  Prepare the bus address array that contains the bus </span>
<span class="cm">	 *  address of each target control block.</span>
<span class="cm">	 *  For now, assume all logical units are wrong. :)</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">SYM_CONF_MAX_TARGET</span> <span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">np</span><span class="o">-&gt;</span><span class="n">targtbl</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">cpu_to_scr</span><span class="p">(</span><span class="n">vtobus</span><span class="p">(</span><span class="o">&amp;</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">target</span><span class="p">[</span><span class="n">i</span><span class="p">]));</span>
		<span class="n">np</span><span class="o">-&gt;</span><span class="n">target</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">head</span><span class="p">.</span><span class="n">luntbl_sa</span> <span class="o">=</span>
				<span class="n">cpu_to_scr</span><span class="p">(</span><span class="n">vtobus</span><span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">badluntbl</span><span class="p">));</span>
		<span class="n">np</span><span class="o">-&gt;</span><span class="n">target</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">head</span><span class="p">.</span><span class="n">lun0_sa</span> <span class="o">=</span>
				<span class="n">cpu_to_scr</span><span class="p">(</span><span class="n">vtobus</span><span class="p">(</span><span class="o">&amp;</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">badlun_sa</span><span class="p">));</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 *  Now check the cache handling of the pci chipset.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sym_snooptest</span> <span class="p">(</span><span class="n">np</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">printf</span><span class="p">(</span><span class="s">&quot;%s: CACHE INCORRECTLY CONFIGURED.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">sym_name</span><span class="p">(</span><span class="n">np</span><span class="p">));</span>
		<span class="k">goto</span> <span class="n">attach_failed</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 *  Sigh! we are done.</span>
<span class="cm">	 */</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">attach_failed:</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">ENXIO</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *  Free everything that has been allocated for this device.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">sym_hcb_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">sym_hcb</span> <span class="o">*</span><span class="n">np</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">SYM_QUEHEAD</span> <span class="o">*</span><span class="n">qp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sym_ccb</span> <span class="o">*</span><span class="n">cp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sym_tcb</span> <span class="o">*</span><span class="n">tp</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">target</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">scriptz0</span><span class="p">)</span>
		<span class="n">sym_mfree_dma</span><span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">scriptz0</span><span class="p">,</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">scriptz_sz</span><span class="p">,</span> <span class="s">&quot;SCRIPTZ0&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">scriptb0</span><span class="p">)</span>
		<span class="n">sym_mfree_dma</span><span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">scriptb0</span><span class="p">,</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">scriptb_sz</span><span class="p">,</span> <span class="s">&quot;SCRIPTB0&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">scripta0</span><span class="p">)</span>
		<span class="n">sym_mfree_dma</span><span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">scripta0</span><span class="p">,</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">scripta_sz</span><span class="p">,</span> <span class="s">&quot;SCRIPTA0&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">squeue</span><span class="p">)</span>
		<span class="n">sym_mfree_dma</span><span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">squeue</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">u32</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">MAX_QUEUE</span><span class="o">*</span><span class="mi">2</span><span class="p">),</span> <span class="s">&quot;SQUEUE&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">dqueue</span><span class="p">)</span>
		<span class="n">sym_mfree_dma</span><span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">dqueue</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">u32</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">MAX_QUEUE</span><span class="o">*</span><span class="mi">2</span><span class="p">),</span> <span class="s">&quot;DQUEUE&quot;</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">actccbs</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">while</span> <span class="p">((</span><span class="n">qp</span> <span class="o">=</span> <span class="n">sym_remque_head</span><span class="p">(</span><span class="o">&amp;</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">free_ccbq</span><span class="p">))</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">cp</span> <span class="o">=</span> <span class="n">sym_que_entry</span><span class="p">(</span><span class="n">qp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sym_ccb</span><span class="p">,</span> <span class="n">link_ccbq</span><span class="p">);</span>
			<span class="n">sym_mfree_dma</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">cp</span><span class="p">),</span> <span class="s">&quot;CCB&quot;</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">ccbh</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">badluntbl</span><span class="p">)</span>
		<span class="n">sym_mfree_dma</span><span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">badluntbl</span><span class="p">,</span> <span class="mi">256</span><span class="p">,</span><span class="s">&quot;BADLUNTBL&quot;</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">target</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">target</span> <span class="o">&lt;</span> <span class="n">SYM_CONF_MAX_TARGET</span> <span class="p">;</span> <span class="n">target</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">tp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">target</span><span class="p">[</span><span class="n">target</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">luntbl</span><span class="p">)</span>
			<span class="n">sym_mfree_dma</span><span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">luntbl</span><span class="p">,</span> <span class="mi">256</span><span class="p">,</span> <span class="s">&quot;LUNTBL&quot;</span><span class="p">);</span>
<span class="cp">#if SYM_CONF_MAX_LUN &gt; 1</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">tp</span><span class="o">-&gt;</span><span class="n">lunmp</span><span class="p">);</span>
<span class="cp">#endif </span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">targtbl</span><span class="p">)</span>
		<span class="n">sym_mfree_dma</span><span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">targtbl</span><span class="p">,</span> <span class="mi">256</span><span class="p">,</span> <span class="s">&quot;TARGTBL&quot;</span><span class="p">);</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
