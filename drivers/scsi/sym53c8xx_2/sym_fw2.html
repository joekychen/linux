<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › scsi › sym53c8xx_2 › sym_fw2.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>sym_fw2.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Device driver for the SYMBIOS/LSILOGIC 53C8XX and 53C1010 family </span>
<span class="cm"> * of PCI-SCSI IO processors.</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 1999-2001  Gerard Roudier &lt;groudier@free.fr&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * This driver is derived from the Linux sym53c8xx driver.</span>
<span class="cm"> * Copyright (C) 1998-2000  Gerard Roudier</span>
<span class="cm"> *</span>
<span class="cm"> * The sym53c8xx driver is derived from the ncr53c8xx driver that had been </span>
<span class="cm"> * a port of the FreeBSD ncr driver to Linux-1.2.13.</span>
<span class="cm"> *</span>
<span class="cm"> * The original ncr driver has been written for 386bsd and FreeBSD by</span>
<span class="cm"> *         Wolfgang Stanglmeier        &lt;wolf@cologne.de&gt;</span>
<span class="cm"> *         Stefan Esser                &lt;se@mi.Uni-Koeln.de&gt;</span>
<span class="cm"> * Copyright (C) 1994  Wolfgang Stanglmeier</span>
<span class="cm"> *</span>
<span class="cm"> * Other major contributions:</span>
<span class="cm"> *</span>
<span class="cm"> * NVRAM detection and reading.</span>
<span class="cm"> * Copyright (C) 1997 Richard Waltham &lt;dormouse@farsrobt.demon.co.uk&gt;</span>
<span class="cm"> *</span>
<span class="cm"> *-----------------------------------------------------------------------------</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or modify</span>
<span class="cm"> * it under the terms of the GNU General Public License as published by</span>
<span class="cm"> * the Free Software Foundation; either version 2 of the License, or</span>
<span class="cm"> * (at your option) any later version.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is distributed in the hope that it will be useful,</span>
<span class="cm"> * but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="cm"> * GNU General Public License for more details.</span>
<span class="cm"> *</span>
<span class="cm"> * You should have received a copy of the GNU General Public License</span>
<span class="cm"> * along with this program; if not, write to the Free Software</span>
<span class="cm"> * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> *  Scripts for SYMBIOS-Processor</span>
<span class="cm"> *</span>
<span class="cm"> *  We have to know the offsets of all labels before we reach </span>
<span class="cm"> *  them (for forward jumps). Therefore we declare a struct </span>
<span class="cm"> *  here. If you make changes inside the script,</span>
<span class="cm"> *</span>
<span class="cm"> *  DONT FORGET TO CHANGE THE LENGTHS HERE!</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> *  Script fragments which are loaded into the on-chip RAM </span>
<span class="cm"> *  of 825A, 875, 876, 895, 895A, 896 and 1010 chips.</span>
<span class="cm"> *  Must not exceed 4K bytes.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">SYM_FWA_SCR</span> <span class="p">{</span>
	<span class="n">u32</span> <span class="n">start</span>		<span class="p">[</span> <span class="mi">14</span><span class="p">];</span>
	<span class="n">u32</span> <span class="n">getjob_begin</span>	<span class="p">[</span>  <span class="mi">4</span><span class="p">];</span>
	<span class="n">u32</span> <span class="n">getjob_end</span>		<span class="p">[</span>  <span class="mi">4</span><span class="p">];</span>
<span class="cp">#ifdef SYM_CONF_TARGET_ROLE_SUPPORT</span>
	<span class="n">u32</span> <span class="n">select</span>		<span class="p">[</span>  <span class="mi">6</span><span class="p">];</span>
<span class="cp">#else</span>
	<span class="n">u32</span> <span class="n">select</span>		<span class="p">[</span>  <span class="mi">4</span><span class="p">];</span>
<span class="cp">#endif</span>
<span class="cp">#if	SYM_CONF_DMA_ADDRESSING_MODE == 2</span>
	<span class="n">u32</span> <span class="n">is_dmap_dirty</span>	<span class="p">[</span>  <span class="mi">4</span><span class="p">];</span>
<span class="cp">#endif</span>
	<span class="n">u32</span> <span class="n">wf_sel_done</span>		<span class="p">[</span>  <span class="mi">2</span><span class="p">];</span>
	<span class="n">u32</span> <span class="n">sel_done</span>		<span class="p">[</span>  <span class="mi">2</span><span class="p">];</span>
	<span class="n">u32</span> <span class="n">send_ident</span>		<span class="p">[</span>  <span class="mi">2</span><span class="p">];</span>
<span class="cp">#ifdef SYM_CONF_IARB_SUPPORT</span>
	<span class="n">u32</span> <span class="n">select2</span>		<span class="p">[</span>  <span class="mi">8</span><span class="p">];</span>
<span class="cp">#else</span>
	<span class="n">u32</span> <span class="n">select2</span>		<span class="p">[</span>  <span class="mi">2</span><span class="p">];</span>
<span class="cp">#endif</span>
	<span class="n">u32</span> <span class="n">command</span>		<span class="p">[</span>  <span class="mi">2</span><span class="p">];</span>
	<span class="n">u32</span> <span class="n">dispatch</span>		<span class="p">[</span> <span class="mi">28</span><span class="p">];</span>
	<span class="n">u32</span> <span class="n">sel_no_cmd</span>		<span class="p">[</span> <span class="mi">10</span><span class="p">];</span>
	<span class="n">u32</span> <span class="n">init</span>		<span class="p">[</span>  <span class="mi">6</span><span class="p">];</span>
	<span class="n">u32</span> <span class="n">clrack</span>		<span class="p">[</span>  <span class="mi">4</span><span class="p">];</span>
	<span class="n">u32</span> <span class="n">datai_done</span>		<span class="p">[</span> <span class="mi">10</span><span class="p">];</span>
	<span class="n">u32</span> <span class="n">datai_done_wsr</span>	<span class="p">[</span> <span class="mi">20</span><span class="p">];</span>
	<span class="n">u32</span> <span class="n">datao_done</span>		<span class="p">[</span> <span class="mi">10</span><span class="p">];</span>
	<span class="n">u32</span> <span class="n">datao_done_wss</span>	<span class="p">[</span>  <span class="mi">6</span><span class="p">];</span>
	<span class="n">u32</span> <span class="n">datai_phase</span>		<span class="p">[</span>  <span class="mi">4</span><span class="p">];</span>
	<span class="n">u32</span> <span class="n">datao_phase</span>		<span class="p">[</span>  <span class="mi">6</span><span class="p">];</span>
	<span class="n">u32</span> <span class="n">msg_in</span>		<span class="p">[</span>  <span class="mi">2</span><span class="p">];</span>
	<span class="n">u32</span> <span class="n">msg_in2</span>		<span class="p">[</span> <span class="mi">10</span><span class="p">];</span>
<span class="cp">#ifdef SYM_CONF_IARB_SUPPORT</span>
	<span class="n">u32</span> <span class="n">status</span>		<span class="p">[</span> <span class="mi">14</span><span class="p">];</span>
<span class="cp">#else</span>
	<span class="n">u32</span> <span class="n">status</span>		<span class="p">[</span> <span class="mi">10</span><span class="p">];</span>
<span class="cp">#endif</span>
	<span class="n">u32</span> <span class="n">complete</span>		<span class="p">[</span>  <span class="mi">6</span><span class="p">];</span>
	<span class="n">u32</span> <span class="n">complete2</span>		<span class="p">[</span> <span class="mi">12</span><span class="p">];</span>
	<span class="n">u32</span> <span class="n">done</span>		<span class="p">[</span> <span class="mi">14</span><span class="p">];</span>
	<span class="n">u32</span> <span class="n">done_end</span>		<span class="p">[</span>  <span class="mi">2</span><span class="p">];</span>
	<span class="n">u32</span> <span class="n">complete_error</span>	<span class="p">[</span>  <span class="mi">4</span><span class="p">];</span>
	<span class="n">u32</span> <span class="n">save_dp</span>		<span class="p">[</span> <span class="mi">12</span><span class="p">];</span>
	<span class="n">u32</span> <span class="n">restore_dp</span>		<span class="p">[</span>  <span class="mi">8</span><span class="p">];</span>
	<span class="n">u32</span> <span class="n">disconnect</span>		<span class="p">[</span> <span class="mi">12</span><span class="p">];</span>
<span class="cp">#ifdef SYM_CONF_IARB_SUPPORT</span>
	<span class="n">u32</span> <span class="n">idle</span>		<span class="p">[</span>  <span class="mi">4</span><span class="p">];</span>
<span class="cp">#else</span>
	<span class="n">u32</span> <span class="n">idle</span>		<span class="p">[</span>  <span class="mi">2</span><span class="p">];</span>
<span class="cp">#endif</span>
<span class="cp">#ifdef SYM_CONF_IARB_SUPPORT</span>
	<span class="n">u32</span> <span class="n">ungetjob</span>		<span class="p">[</span>  <span class="mi">6</span><span class="p">];</span>
<span class="cp">#else</span>
	<span class="n">u32</span> <span class="n">ungetjob</span>		<span class="p">[</span>  <span class="mi">4</span><span class="p">];</span>
<span class="cp">#endif</span>
<span class="cp">#ifdef SYM_CONF_TARGET_ROLE_SUPPORT</span>
	<span class="n">u32</span> <span class="n">reselect</span>		<span class="p">[</span>  <span class="mi">4</span><span class="p">];</span>
<span class="cp">#else</span>
	<span class="n">u32</span> <span class="n">reselect</span>		<span class="p">[</span>  <span class="mi">2</span><span class="p">];</span>
<span class="cp">#endif</span>
	<span class="n">u32</span> <span class="n">reselected</span>		<span class="p">[</span> <span class="mi">22</span><span class="p">];</span>
	<span class="n">u32</span> <span class="n">resel_scntl4</span>	<span class="p">[</span> <span class="mi">20</span><span class="p">];</span>
	<span class="n">u32</span> <span class="n">resel_lun0</span>		<span class="p">[</span>  <span class="mi">6</span><span class="p">];</span>
<span class="cp">#if   SYM_CONF_MAX_TASK*4 &gt; 512</span>
	<span class="n">u32</span> <span class="n">resel_tag</span>		<span class="p">[</span> <span class="mi">26</span><span class="p">];</span>
<span class="cp">#elif SYM_CONF_MAX_TASK*4 &gt; 256</span>
	<span class="n">u32</span> <span class="n">resel_tag</span>		<span class="p">[</span> <span class="mi">20</span><span class="p">];</span>
<span class="cp">#else</span>
	<span class="n">u32</span> <span class="n">resel_tag</span>		<span class="p">[</span> <span class="mi">16</span><span class="p">];</span>
<span class="cp">#endif</span>
	<span class="n">u32</span> <span class="n">resel_dsa</span>		<span class="p">[</span>  <span class="mi">2</span><span class="p">];</span>
	<span class="n">u32</span> <span class="n">resel_dsa1</span>		<span class="p">[</span>  <span class="mi">4</span><span class="p">];</span>
	<span class="n">u32</span> <span class="n">resel_no_tag</span>	<span class="p">[</span>  <span class="mi">6</span><span class="p">];</span>
	<span class="n">u32</span> <span class="n">data_in</span>		<span class="p">[</span><span class="n">SYM_CONF_MAX_SG</span> <span class="o">*</span> <span class="mi">2</span><span class="p">];</span>
	<span class="n">u32</span> <span class="n">data_in2</span>		<span class="p">[</span>  <span class="mi">4</span><span class="p">];</span>
	<span class="n">u32</span> <span class="n">data_out</span>		<span class="p">[</span><span class="n">SYM_CONF_MAX_SG</span> <span class="o">*</span> <span class="mi">2</span><span class="p">];</span>
	<span class="n">u32</span> <span class="n">data_out2</span>		<span class="p">[</span>  <span class="mi">4</span><span class="p">];</span>
	<span class="n">u32</span> <span class="n">pm0_data</span>		<span class="p">[</span> <span class="mi">12</span><span class="p">];</span>
	<span class="n">u32</span> <span class="n">pm0_data_out</span>	<span class="p">[</span>  <span class="mi">6</span><span class="p">];</span>
	<span class="n">u32</span> <span class="n">pm0_data_end</span>	<span class="p">[</span>  <span class="mi">6</span><span class="p">];</span>
	<span class="n">u32</span> <span class="n">pm1_data</span>		<span class="p">[</span> <span class="mi">12</span><span class="p">];</span>
	<span class="n">u32</span> <span class="n">pm1_data_out</span>	<span class="p">[</span>  <span class="mi">6</span><span class="p">];</span>
	<span class="n">u32</span> <span class="n">pm1_data_end</span>	<span class="p">[</span>  <span class="mi">6</span><span class="p">];</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> *  Script fragments which stay in main memory for all chips </span>
<span class="cm"> *  except for chips that support 8K on-chip RAM.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">SYM_FWB_SCR</span> <span class="p">{</span>
	<span class="n">u32</span> <span class="n">start64</span>		<span class="p">[</span>  <span class="mi">2</span><span class="p">];</span>
	<span class="n">u32</span> <span class="n">no_data</span>		<span class="p">[</span>  <span class="mi">2</span><span class="p">];</span>
<span class="cp">#ifdef SYM_CONF_TARGET_ROLE_SUPPORT</span>
	<span class="n">u32</span> <span class="n">sel_for_abort</span>	<span class="p">[</span> <span class="mi">18</span><span class="p">];</span>
<span class="cp">#else</span>
	<span class="n">u32</span> <span class="n">sel_for_abort</span>	<span class="p">[</span> <span class="mi">16</span><span class="p">];</span>
<span class="cp">#endif</span>
	<span class="n">u32</span> <span class="n">sel_for_abort_1</span>	<span class="p">[</span>  <span class="mi">2</span><span class="p">];</span>
	<span class="n">u32</span> <span class="n">msg_in_etc</span>		<span class="p">[</span> <span class="mi">12</span><span class="p">];</span>
	<span class="n">u32</span> <span class="n">msg_received</span>	<span class="p">[</span>  <span class="mi">4</span><span class="p">];</span>
	<span class="n">u32</span> <span class="n">msg_weird_seen</span>	<span class="p">[</span>  <span class="mi">4</span><span class="p">];</span>
	<span class="n">u32</span> <span class="n">msg_extended</span>	<span class="p">[</span> <span class="mi">20</span><span class="p">];</span>
	<span class="n">u32</span> <span class="n">msg_bad</span>		<span class="p">[</span>  <span class="mi">6</span><span class="p">];</span>
	<span class="n">u32</span> <span class="n">msg_weird</span>		<span class="p">[</span>  <span class="mi">4</span><span class="p">];</span>
	<span class="n">u32</span> <span class="n">msg_weird1</span>		<span class="p">[</span>  <span class="mi">8</span><span class="p">];</span>

	<span class="n">u32</span> <span class="n">wdtr_resp</span>		<span class="p">[</span>  <span class="mi">6</span><span class="p">];</span>
	<span class="n">u32</span> <span class="n">send_wdtr</span>		<span class="p">[</span>  <span class="mi">4</span><span class="p">];</span>
	<span class="n">u32</span> <span class="n">sdtr_resp</span>		<span class="p">[</span>  <span class="mi">6</span><span class="p">];</span>
	<span class="n">u32</span> <span class="n">send_sdtr</span>		<span class="p">[</span>  <span class="mi">4</span><span class="p">];</span>
	<span class="n">u32</span> <span class="n">ppr_resp</span>		<span class="p">[</span>  <span class="mi">6</span><span class="p">];</span>
	<span class="n">u32</span> <span class="n">send_ppr</span>		<span class="p">[</span>  <span class="mi">4</span><span class="p">];</span>
	<span class="n">u32</span> <span class="n">nego_bad_phase</span>	<span class="p">[</span>  <span class="mi">4</span><span class="p">];</span>
	<span class="n">u32</span> <span class="n">msg_out</span>		<span class="p">[</span>  <span class="mi">4</span><span class="p">];</span>
	<span class="n">u32</span> <span class="n">msg_out_done</span>	<span class="p">[</span>  <span class="mi">4</span><span class="p">];</span>
	<span class="n">u32</span> <span class="n">data_ovrun</span>		<span class="p">[</span>  <span class="mi">2</span><span class="p">];</span>
	<span class="n">u32</span> <span class="n">data_ovrun1</span>		<span class="p">[</span> <span class="mi">22</span><span class="p">];</span>
	<span class="n">u32</span> <span class="n">data_ovrun2</span>		<span class="p">[</span>  <span class="mi">8</span><span class="p">];</span>
	<span class="n">u32</span> <span class="n">abort_resel</span>		<span class="p">[</span> <span class="mi">16</span><span class="p">];</span>
	<span class="n">u32</span> <span class="n">resend_ident</span>	<span class="p">[</span>  <span class="mi">4</span><span class="p">];</span>
	<span class="n">u32</span> <span class="n">ident_break</span>		<span class="p">[</span>  <span class="mi">4</span><span class="p">];</span>
	<span class="n">u32</span> <span class="n">ident_break_atn</span>	<span class="p">[</span>  <span class="mi">4</span><span class="p">];</span>
	<span class="n">u32</span> <span class="n">sdata_in</span>		<span class="p">[</span>  <span class="mi">6</span><span class="p">];</span>
	<span class="n">u32</span> <span class="n">resel_bad_lun</span>	<span class="p">[</span>  <span class="mi">4</span><span class="p">];</span>
	<span class="n">u32</span> <span class="n">bad_i_t_l</span>		<span class="p">[</span>  <span class="mi">4</span><span class="p">];</span>
	<span class="n">u32</span> <span class="n">bad_i_t_l_q</span>		<span class="p">[</span>  <span class="mi">4</span><span class="p">];</span>
	<span class="n">u32</span> <span class="n">bad_status</span>		<span class="p">[</span>  <span class="mi">6</span><span class="p">];</span>
	<span class="n">u32</span> <span class="n">pm_handle</span>		<span class="p">[</span> <span class="mi">20</span><span class="p">];</span>
	<span class="n">u32</span> <span class="n">pm_handle1</span>		<span class="p">[</span>  <span class="mi">4</span><span class="p">];</span>
	<span class="n">u32</span> <span class="n">pm_save</span>		<span class="p">[</span>  <span class="mi">4</span><span class="p">];</span>
	<span class="n">u32</span> <span class="n">pm0_save</span>		<span class="p">[</span> <span class="mi">12</span><span class="p">];</span>
	<span class="n">u32</span> <span class="n">pm_save_end</span>		<span class="p">[</span>  <span class="mi">4</span><span class="p">];</span>
	<span class="n">u32</span> <span class="n">pm1_save</span>		<span class="p">[</span> <span class="mi">14</span><span class="p">];</span>

	<span class="cm">/* WSR handling */</span>
	<span class="n">u32</span> <span class="n">pm_wsr_handle</span>	<span class="p">[</span> <span class="mi">38</span><span class="p">];</span>
	<span class="n">u32</span> <span class="n">wsr_ma_helper</span>	<span class="p">[</span>  <span class="mi">4</span><span class="p">];</span>

	<span class="cm">/* Data area */</span>
	<span class="n">u32</span> <span class="n">zero</span>		<span class="p">[</span>  <span class="mi">1</span><span class="p">];</span>
	<span class="n">u32</span> <span class="n">scratch</span>		<span class="p">[</span>  <span class="mi">1</span><span class="p">];</span>
	<span class="n">u32</span> <span class="n">pm0_data_addr</span>	<span class="p">[</span>  <span class="mi">1</span><span class="p">];</span>
	<span class="n">u32</span> <span class="n">pm1_data_addr</span>	<span class="p">[</span>  <span class="mi">1</span><span class="p">];</span>
	<span class="n">u32</span> <span class="n">done_pos</span>		<span class="p">[</span>  <span class="mi">1</span><span class="p">];</span>
	<span class="n">u32</span> <span class="n">startpos</span>		<span class="p">[</span>  <span class="mi">1</span><span class="p">];</span>
	<span class="n">u32</span> <span class="n">targtbl</span>		<span class="p">[</span>  <span class="mi">1</span><span class="p">];</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> *  Script fragments used at initialisations.</span>
<span class="cm"> *  Only runs out of main memory.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">SYM_FWZ_SCR</span> <span class="p">{</span>
	<span class="n">u32</span> <span class="n">snooptest</span>		<span class="p">[</span>  <span class="mi">6</span><span class="p">];</span>
	<span class="n">u32</span> <span class="n">snoopend</span>		<span class="p">[</span>  <span class="mi">2</span><span class="p">];</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">SYM_FWA_SCR</span> <span class="n">SYM_FWA_SCR</span> <span class="o">=</span> <span class="p">{</span>
<span class="cm">/*--------------------------&lt; START &gt;----------------------------*/</span> <span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 *  Switch the LED on.</span>
<span class="cm">	 *  Will be patched with a NO_OP if LED</span>
<span class="cm">	 *  not needed or not desired.</span>
<span class="cm">	 */</span>
	<span class="n">SCR_REG_REG</span> <span class="p">(</span><span class="n">gpreg</span><span class="p">,</span> <span class="n">SCR_AND</span><span class="p">,</span> <span class="mh">0xfe</span><span class="p">),</span>
		<span class="mi">0</span><span class="p">,</span>
	<span class="cm">/*</span>
<span class="cm">	 *      Clear SIGP.</span>
<span class="cm">	 */</span>
	<span class="n">SCR_FROM_REG</span> <span class="p">(</span><span class="n">ctest2</span><span class="p">),</span>
		<span class="mi">0</span><span class="p">,</span>
	<span class="cm">/*</span>
<span class="cm">	 *  Stop here if the C code wants to perform </span>
<span class="cm">	 *  some error recovery procedure manually.</span>
<span class="cm">	 *  (Indicate this by setting SEM in ISTAT)</span>
<span class="cm">	 */</span>
	<span class="n">SCR_FROM_REG</span> <span class="p">(</span><span class="n">istat</span><span class="p">),</span>
		<span class="mi">0</span><span class="p">,</span>
	<span class="cm">/*</span>
<span class="cm">	 *  Report to the C code the next position in </span>
<span class="cm">	 *  the start queue the SCRIPTS will schedule.</span>
<span class="cm">	 *  The C code must not change SCRATCHA.</span>
<span class="cm">	 */</span>
	<span class="n">SCR_LOAD_ABS</span> <span class="p">(</span><span class="n">scratcha</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span>
		<span class="n">PADDR_B</span> <span class="p">(</span><span class="n">startpos</span><span class="p">),</span>
	<span class="n">SCR_INT</span> <span class="o">^</span> <span class="n">IFTRUE</span> <span class="p">(</span><span class="n">MASK</span> <span class="p">(</span><span class="n">SEM</span><span class="p">,</span> <span class="n">SEM</span><span class="p">)),</span>
		<span class="n">SIR_SCRIPT_STOPPED</span><span class="p">,</span>
	<span class="cm">/*</span>
<span class="cm">	 *  Start the next job.</span>
<span class="cm">	 *</span>
<span class="cm">	 *  @DSA     = start point for this job.</span>
<span class="cm">	 *  SCRATCHA = address of this job in the start queue.</span>
<span class="cm">	 *</span>
<span class="cm">	 *  We will restore startpos with SCRATCHA if we fails the </span>
<span class="cm">	 *  arbitration or if it is the idle job.</span>
<span class="cm">	 *</span>
<span class="cm">	 *  The below GETJOB_BEGIN to GETJOB_END section of SCRIPTS </span>
<span class="cm">	 *  is a critical path. If it is partially executed, it then </span>
<span class="cm">	 *  may happen that the job address is not yet in the DSA </span>
<span class="cm">	 *  and the next queue position points to the next JOB.</span>
<span class="cm">	 */</span>
	<span class="n">SCR_LOAD_ABS</span> <span class="p">(</span><span class="n">dsa</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span>
		<span class="n">PADDR_B</span> <span class="p">(</span><span class="n">startpos</span><span class="p">),</span>
	<span class="n">SCR_LOAD_REL</span> <span class="p">(</span><span class="n">temp</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span>
		<span class="mi">4</span><span class="p">,</span>
<span class="p">}</span><span class="cm">/*-------------------------&lt; GETJOB_BEGIN &gt;---------------------*/</span><span class="p">,{</span>
	<span class="n">SCR_STORE_ABS</span> <span class="p">(</span><span class="n">temp</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span>
		<span class="n">PADDR_B</span> <span class="p">(</span><span class="n">startpos</span><span class="p">),</span>
	<span class="n">SCR_LOAD_REL</span> <span class="p">(</span><span class="n">dsa</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span>
		<span class="mi">0</span><span class="p">,</span>
<span class="p">}</span><span class="cm">/*-------------------------&lt; GETJOB_END &gt;-----------------------*/</span><span class="p">,{</span>
	<span class="n">SCR_LOAD_REL</span> <span class="p">(</span><span class="n">temp</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span>
		<span class="mi">0</span><span class="p">,</span>
	<span class="n">SCR_RETURN</span><span class="p">,</span>
		<span class="mi">0</span><span class="p">,</span>
<span class="p">}</span><span class="cm">/*-------------------------&lt; SELECT &gt;---------------------------*/</span><span class="p">,{</span>
	<span class="cm">/*</span>
<span class="cm">	 *  DSA	contains the address of a scheduled</span>
<span class="cm">	 *  	data structure.</span>
<span class="cm">	 *</span>
<span class="cm">	 *  SCRATCHA contains the address of the start queue  </span>
<span class="cm">	 *  	entry which points to the next job.</span>
<span class="cm">	 *</span>
<span class="cm">	 *  Set Initiator mode.</span>
<span class="cm">	 *</span>
<span class="cm">	 *  (Target mode is left as an exercise for the reader)</span>
<span class="cm">	 */</span>
<span class="cp">#ifdef SYM_CONF_TARGET_ROLE_SUPPORT</span>
	<span class="n">SCR_CLR</span> <span class="p">(</span><span class="n">SCR_TRG</span><span class="p">),</span>
		<span class="mi">0</span><span class="p">,</span>
<span class="cp">#endif</span>
	<span class="cm">/*</span>
<span class="cm">	 *      And try to select this target.</span>
<span class="cm">	 */</span>
	<span class="n">SCR_SEL_TBL_ATN</span> <span class="o">^</span> <span class="n">offsetof</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sym_dsb</span><span class="p">,</span> <span class="n">select</span><span class="p">),</span>
		<span class="n">PADDR_A</span> <span class="p">(</span><span class="n">ungetjob</span><span class="p">),</span>
	<span class="cm">/*</span>
<span class="cm">	 *  Now there are 4 possibilities:</span>
<span class="cm">	 *</span>
<span class="cm">	 *  (1) The chip loses arbitration.</span>
<span class="cm">	 *  This is ok, because it will try again,</span>
<span class="cm">	 *  when the bus becomes idle.</span>
<span class="cm">	 *  (But beware of the timeout function!)</span>
<span class="cm">	 *</span>
<span class="cm">	 *  (2) The chip is reselected.</span>
<span class="cm">	 *  Then the script processor takes the jump</span>
<span class="cm">	 *  to the RESELECT label.</span>
<span class="cm">	 *</span>
<span class="cm">	 *  (3) The chip wins arbitration.</span>
<span class="cm">	 *  Then it will execute SCRIPTS instruction until </span>
<span class="cm">	 *  the next instruction that checks SCSI phase.</span>
<span class="cm">	 *  Then will stop and wait for selection to be </span>
<span class="cm">	 *  complete or selection time-out to occur.</span>
<span class="cm">	 *</span>
<span class="cm">	 *  After having won arbitration, the SCRIPTS  </span>
<span class="cm">	 *  processor is able to execute instructions while </span>
<span class="cm">	 *  the SCSI core is performing SCSI selection.</span>
<span class="cm">	 */</span>
	<span class="cm">/*</span>
<span class="cm">	 *      Initialize the status registers</span>
<span class="cm">	 */</span>
	<span class="n">SCR_LOAD_REL</span> <span class="p">(</span><span class="n">scr0</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span>
		<span class="n">offsetof</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sym_ccb</span><span class="p">,</span> <span class="n">phys</span><span class="p">.</span><span class="n">head</span><span class="p">.</span><span class="n">status</span><span class="p">),</span>
	<span class="cm">/*</span>
<span class="cm">	 *  We may need help from CPU if the DMA segment </span>
<span class="cm">	 *  registers aren&#39;t up-to-date for this IO.</span>
<span class="cm">	 *  Patched with NOOP for chips that donnot </span>
<span class="cm">	 *  support DAC addressing.</span>
<span class="cm">	 */</span>
<span class="cp">#if	SYM_CONF_DMA_ADDRESSING_MODE == 2</span>
<span class="p">}</span><span class="cm">/*-------------------------&lt; IS_DMAP_DIRTY &gt;--------------------*/</span><span class="p">,{</span>
	<span class="n">SCR_FROM_REG</span> <span class="p">(</span><span class="n">HX_REG</span><span class="p">),</span>
		<span class="mi">0</span><span class="p">,</span>
	<span class="n">SCR_INT</span> <span class="o">^</span> <span class="n">IFTRUE</span> <span class="p">(</span><span class="n">MASK</span> <span class="p">(</span><span class="n">HX_DMAP_DIRTY</span><span class="p">,</span> <span class="n">HX_DMAP_DIRTY</span><span class="p">)),</span>
		<span class="n">SIR_DMAP_DIRTY</span><span class="p">,</span>
<span class="cp">#endif</span>
<span class="p">}</span><span class="cm">/*-------------------------&lt; WF_SEL_DONE &gt;----------------------*/</span><span class="p">,{</span>
	<span class="n">SCR_INT</span> <span class="o">^</span> <span class="n">IFFALSE</span> <span class="p">(</span><span class="n">WHEN</span> <span class="p">(</span><span class="n">SCR_MSG_OUT</span><span class="p">)),</span>
		<span class="n">SIR_SEL_ATN_NO_MSG_OUT</span><span class="p">,</span>
<span class="p">}</span><span class="cm">/*-------------------------&lt; SEL_DONE &gt;-------------------------*/</span><span class="p">,{</span>
	<span class="cm">/*</span>
<span class="cm">	 *  C1010-33 errata work-around.</span>
<span class="cm">	 *  Due to a race, the SCSI core may not have </span>
<span class="cm">	 *  loaded SCNTL3 on SEL_TBL instruction.</span>
<span class="cm">	 *  We reload it once phase is stable.</span>
<span class="cm">	 *  Patched with a NOOP for other chips.</span>
<span class="cm">	 */</span>
	<span class="n">SCR_LOAD_REL</span> <span class="p">(</span><span class="n">scntl3</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
		<span class="n">offsetof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sym_dsb</span><span class="p">,</span> <span class="n">select</span><span class="p">.</span><span class="n">sel_scntl3</span><span class="p">),</span>
<span class="p">}</span><span class="cm">/*-------------------------&lt; SEND_IDENT &gt;-----------------------*/</span><span class="p">,{</span>
	<span class="cm">/*</span>
<span class="cm">	 *  Selection complete.</span>
<span class="cm">	 *  Send the IDENTIFY and possibly the TAG message </span>
<span class="cm">	 *  and negotiation message if present.</span>
<span class="cm">	 */</span>
	<span class="n">SCR_MOVE_TBL</span> <span class="o">^</span> <span class="n">SCR_MSG_OUT</span><span class="p">,</span>
		<span class="n">offsetof</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sym_dsb</span><span class="p">,</span> <span class="n">smsg</span><span class="p">),</span>
<span class="p">}</span><span class="cm">/*-------------------------&lt; SELECT2 &gt;--------------------------*/</span><span class="p">,{</span>
<span class="cp">#ifdef SYM_CONF_IARB_SUPPORT</span>
	<span class="cm">/*</span>
<span class="cm">	 *  Set IMMEDIATE ARBITRATION if we have been given </span>
<span class="cm">	 *  a hint to do so. (Some job to do after this one).</span>
<span class="cm">	 */</span>
	<span class="n">SCR_FROM_REG</span> <span class="p">(</span><span class="n">HF_REG</span><span class="p">),</span>
		<span class="mi">0</span><span class="p">,</span>
	<span class="n">SCR_JUMPR</span> <span class="o">^</span> <span class="n">IFFALSE</span> <span class="p">(</span><span class="n">MASK</span> <span class="p">(</span><span class="n">HF_HINT_IARB</span><span class="p">,</span> <span class="n">HF_HINT_IARB</span><span class="p">)),</span>
		<span class="mi">8</span><span class="p">,</span>
	<span class="n">SCR_REG_REG</span> <span class="p">(</span><span class="n">scntl1</span><span class="p">,</span> <span class="n">SCR_OR</span><span class="p">,</span> <span class="n">IARB</span><span class="p">),</span>
		<span class="mi">0</span><span class="p">,</span>
<span class="cp">#endif</span>
	<span class="cm">/*</span>
<span class="cm">	 *  Anticipate the COMMAND phase.</span>
<span class="cm">	 *  This is the PHASE we expect at this point.</span>
<span class="cm">	 */</span>
	<span class="n">SCR_JUMP</span> <span class="o">^</span> <span class="n">IFFALSE</span> <span class="p">(</span><span class="n">WHEN</span> <span class="p">(</span><span class="n">SCR_COMMAND</span><span class="p">)),</span>
		<span class="n">PADDR_A</span> <span class="p">(</span><span class="n">sel_no_cmd</span><span class="p">),</span>
<span class="p">}</span><span class="cm">/*-------------------------&lt; COMMAND &gt;--------------------------*/</span><span class="p">,{</span>
	<span class="cm">/*</span>
<span class="cm">	 *  ... and send the command</span>
<span class="cm">	 */</span>
	<span class="n">SCR_MOVE_TBL</span> <span class="o">^</span> <span class="n">SCR_COMMAND</span><span class="p">,</span>
		<span class="n">offsetof</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sym_dsb</span><span class="p">,</span> <span class="n">cmd</span><span class="p">),</span>
<span class="p">}</span><span class="cm">/*-------------------------&lt; DISPATCH &gt;-------------------------*/</span><span class="p">,{</span>
	<span class="cm">/*</span>
<span class="cm">	 *  MSG_IN is the only phase that shall be </span>
<span class="cm">	 *  entered at least once for each (re)selection.</span>
<span class="cm">	 *  So we test it first.</span>
<span class="cm">	 */</span>
	<span class="n">SCR_JUMP</span> <span class="o">^</span> <span class="n">IFTRUE</span> <span class="p">(</span><span class="n">WHEN</span> <span class="p">(</span><span class="n">SCR_MSG_IN</span><span class="p">)),</span>
		<span class="n">PADDR_A</span> <span class="p">(</span><span class="n">msg_in</span><span class="p">),</span>
	<span class="n">SCR_JUMP</span> <span class="o">^</span> <span class="n">IFTRUE</span> <span class="p">(</span><span class="n">IF</span> <span class="p">(</span><span class="n">SCR_DATA_OUT</span><span class="p">)),</span>
		<span class="n">PADDR_A</span> <span class="p">(</span><span class="n">datao_phase</span><span class="p">),</span>
	<span class="n">SCR_JUMP</span> <span class="o">^</span> <span class="n">IFTRUE</span> <span class="p">(</span><span class="n">IF</span> <span class="p">(</span><span class="n">SCR_DATA_IN</span><span class="p">)),</span>
		<span class="n">PADDR_A</span> <span class="p">(</span><span class="n">datai_phase</span><span class="p">),</span>
	<span class="n">SCR_JUMP</span> <span class="o">^</span> <span class="n">IFTRUE</span> <span class="p">(</span><span class="n">IF</span> <span class="p">(</span><span class="n">SCR_STATUS</span><span class="p">)),</span>
		<span class="n">PADDR_A</span> <span class="p">(</span><span class="n">status</span><span class="p">),</span>
	<span class="n">SCR_JUMP</span> <span class="o">^</span> <span class="n">IFTRUE</span> <span class="p">(</span><span class="n">IF</span> <span class="p">(</span><span class="n">SCR_COMMAND</span><span class="p">)),</span>
		<span class="n">PADDR_A</span> <span class="p">(</span><span class="n">command</span><span class="p">),</span>
	<span class="n">SCR_JUMP</span> <span class="o">^</span> <span class="n">IFTRUE</span> <span class="p">(</span><span class="n">IF</span> <span class="p">(</span><span class="n">SCR_MSG_OUT</span><span class="p">)),</span>
		<span class="n">PADDR_B</span> <span class="p">(</span><span class="n">msg_out</span><span class="p">),</span>
	<span class="cm">/*</span>
<span class="cm">	 *  Discard as many illegal phases as </span>
<span class="cm">	 *  required and tell the C code about.</span>
<span class="cm">	 */</span>
	<span class="n">SCR_JUMPR</span> <span class="o">^</span> <span class="n">IFFALSE</span> <span class="p">(</span><span class="n">WHEN</span> <span class="p">(</span><span class="n">SCR_ILG_OUT</span><span class="p">)),</span>
		<span class="mi">16</span><span class="p">,</span>
	<span class="n">SCR_MOVE_ABS</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">^</span> <span class="n">SCR_ILG_OUT</span><span class="p">,</span>
		<span class="n">HADDR_1</span> <span class="p">(</span><span class="n">scratch</span><span class="p">),</span>
	<span class="n">SCR_JUMPR</span> <span class="o">^</span> <span class="n">IFTRUE</span> <span class="p">(</span><span class="n">WHEN</span> <span class="p">(</span><span class="n">SCR_ILG_OUT</span><span class="p">)),</span>
		<span class="o">-</span><span class="mi">16</span><span class="p">,</span>
	<span class="n">SCR_JUMPR</span> <span class="o">^</span> <span class="n">IFFALSE</span> <span class="p">(</span><span class="n">WHEN</span> <span class="p">(</span><span class="n">SCR_ILG_IN</span><span class="p">)),</span>
		<span class="mi">16</span><span class="p">,</span>
	<span class="n">SCR_MOVE_ABS</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">^</span> <span class="n">SCR_ILG_IN</span><span class="p">,</span>
		<span class="n">HADDR_1</span> <span class="p">(</span><span class="n">scratch</span><span class="p">),</span>
	<span class="n">SCR_JUMPR</span> <span class="o">^</span> <span class="n">IFTRUE</span> <span class="p">(</span><span class="n">WHEN</span> <span class="p">(</span><span class="n">SCR_ILG_IN</span><span class="p">)),</span>
		<span class="o">-</span><span class="mi">16</span><span class="p">,</span>
	<span class="n">SCR_INT</span><span class="p">,</span>
		<span class="n">SIR_BAD_PHASE</span><span class="p">,</span>
	<span class="n">SCR_JUMP</span><span class="p">,</span>
		<span class="n">PADDR_A</span> <span class="p">(</span><span class="n">dispatch</span><span class="p">),</span>
<span class="p">}</span><span class="cm">/*-------------------------&lt; SEL_NO_CMD &gt;-----------------------*/</span><span class="p">,{</span>
	<span class="cm">/*</span>
<span class="cm">	 *  The target does not switch to command </span>
<span class="cm">	 *  phase after IDENTIFY has been sent.</span>
<span class="cm">	 *</span>
<span class="cm">	 *  If it stays in MSG OUT phase send it </span>
<span class="cm">	 *  the IDENTIFY again.</span>
<span class="cm">	 */</span>
	<span class="n">SCR_JUMP</span> <span class="o">^</span> <span class="n">IFTRUE</span> <span class="p">(</span><span class="n">WHEN</span> <span class="p">(</span><span class="n">SCR_MSG_OUT</span><span class="p">)),</span>
		<span class="n">PADDR_B</span> <span class="p">(</span><span class="n">resend_ident</span><span class="p">),</span>
	<span class="cm">/*</span>
<span class="cm">	 *  If target does not switch to MSG IN phase </span>
<span class="cm">	 *  and we sent a negotiation, assert the </span>
<span class="cm">	 *  failure immediately.</span>
<span class="cm">	 */</span>
	<span class="n">SCR_JUMP</span> <span class="o">^</span> <span class="n">IFTRUE</span> <span class="p">(</span><span class="n">WHEN</span> <span class="p">(</span><span class="n">SCR_MSG_IN</span><span class="p">)),</span>
		<span class="n">PADDR_A</span> <span class="p">(</span><span class="n">dispatch</span><span class="p">),</span>
	<span class="n">SCR_FROM_REG</span> <span class="p">(</span><span class="n">HS_REG</span><span class="p">),</span>
		<span class="mi">0</span><span class="p">,</span>
	<span class="n">SCR_INT</span> <span class="o">^</span> <span class="n">IFTRUE</span> <span class="p">(</span><span class="n">DATA</span> <span class="p">(</span><span class="n">HS_NEGOTIATE</span><span class="p">)),</span>
		<span class="n">SIR_NEGO_FAILED</span><span class="p">,</span>
	<span class="cm">/*</span>
<span class="cm">	 *  Jump to dispatcher.</span>
<span class="cm">	 */</span>
	<span class="n">SCR_JUMP</span><span class="p">,</span>
		<span class="n">PADDR_A</span> <span class="p">(</span><span class="n">dispatch</span><span class="p">),</span>
<span class="p">}</span><span class="cm">/*-------------------------&lt; INIT &gt;-----------------------------*/</span><span class="p">,{</span>
	<span class="cm">/*</span>
<span class="cm">	 *  Wait for the SCSI RESET signal to be </span>
<span class="cm">	 *  inactive before restarting operations, </span>
<span class="cm">	 *  since the chip may hang on SEL_ATN </span>
<span class="cm">	 *  if SCSI RESET is active.</span>
<span class="cm">	 */</span>
	<span class="n">SCR_FROM_REG</span> <span class="p">(</span><span class="n">sstat0</span><span class="p">),</span>
		<span class="mi">0</span><span class="p">,</span>
	<span class="n">SCR_JUMPR</span> <span class="o">^</span> <span class="n">IFTRUE</span> <span class="p">(</span><span class="n">MASK</span> <span class="p">(</span><span class="n">IRST</span><span class="p">,</span> <span class="n">IRST</span><span class="p">)),</span>
		<span class="o">-</span><span class="mi">16</span><span class="p">,</span>
	<span class="n">SCR_JUMP</span><span class="p">,</span>
		<span class="n">PADDR_A</span> <span class="p">(</span><span class="n">start</span><span class="p">),</span>
<span class="p">}</span><span class="cm">/*-------------------------&lt; CLRACK &gt;---------------------------*/</span><span class="p">,{</span>
	<span class="cm">/*</span>
<span class="cm">	 *  Terminate possible pending message phase.</span>
<span class="cm">	 */</span>
	<span class="n">SCR_CLR</span> <span class="p">(</span><span class="n">SCR_ACK</span><span class="p">),</span>
		<span class="mi">0</span><span class="p">,</span>
	<span class="n">SCR_JUMP</span><span class="p">,</span>
		<span class="n">PADDR_A</span> <span class="p">(</span><span class="n">dispatch</span><span class="p">),</span>
<span class="p">}</span><span class="cm">/*-------------------------&lt; DATAI_DONE &gt;-----------------------*/</span><span class="p">,{</span>
	<span class="cm">/*</span>
<span class="cm">	 *  Save current pointer to LASTP.</span>
<span class="cm">	 */</span>
	<span class="n">SCR_STORE_REL</span> <span class="p">(</span><span class="n">temp</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span>
		<span class="n">offsetof</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sym_ccb</span><span class="p">,</span> <span class="n">phys</span><span class="p">.</span><span class="n">head</span><span class="p">.</span><span class="n">lastp</span><span class="p">),</span>
	<span class="cm">/*</span>
<span class="cm">	 *  If the SWIDE is not full, jump to dispatcher.</span>
<span class="cm">	 *  We anticipate a STATUS phase.</span>
<span class="cm">	 */</span>
	<span class="n">SCR_FROM_REG</span> <span class="p">(</span><span class="n">scntl2</span><span class="p">),</span>
		<span class="mi">0</span><span class="p">,</span>
	<span class="n">SCR_JUMP</span> <span class="o">^</span> <span class="n">IFTRUE</span> <span class="p">(</span><span class="n">MASK</span> <span class="p">(</span><span class="n">WSR</span><span class="p">,</span> <span class="n">WSR</span><span class="p">)),</span>
		<span class="n">PADDR_A</span> <span class="p">(</span><span class="n">datai_done_wsr</span><span class="p">),</span>
	<span class="n">SCR_JUMP</span> <span class="o">^</span> <span class="n">IFTRUE</span> <span class="p">(</span><span class="n">WHEN</span> <span class="p">(</span><span class="n">SCR_STATUS</span><span class="p">)),</span>
		<span class="n">PADDR_A</span> <span class="p">(</span><span class="n">status</span><span class="p">),</span>
	<span class="n">SCR_JUMP</span><span class="p">,</span>
		<span class="n">PADDR_A</span> <span class="p">(</span><span class="n">dispatch</span><span class="p">),</span>
<span class="p">}</span><span class="cm">/*-------------------------&lt; DATAI_DONE_WSR &gt;-------------------*/</span><span class="p">,{</span>
	<span class="cm">/*</span>
<span class="cm">	 *  The SWIDE is full.</span>
<span class="cm">	 *  Clear this condition.</span>
<span class="cm">	 */</span>
	<span class="n">SCR_REG_REG</span> <span class="p">(</span><span class="n">scntl2</span><span class="p">,</span> <span class="n">SCR_OR</span><span class="p">,</span> <span class="n">WSR</span><span class="p">),</span>
		<span class="mi">0</span><span class="p">,</span>
	<span class="cm">/*</span>
<span class="cm">	 *  We are expecting an IGNORE RESIDUE message </span>
<span class="cm">	 *  from the device, otherwise we are in data </span>
<span class="cm">	 *  overrun condition. Check against MSG_IN phase.</span>
<span class="cm">	 */</span>
	<span class="n">SCR_INT</span> <span class="o">^</span> <span class="n">IFFALSE</span> <span class="p">(</span><span class="n">WHEN</span> <span class="p">(</span><span class="n">SCR_MSG_IN</span><span class="p">)),</span>
		<span class="n">SIR_SWIDE_OVERRUN</span><span class="p">,</span>
	<span class="n">SCR_JUMP</span> <span class="o">^</span> <span class="n">IFFALSE</span> <span class="p">(</span><span class="n">WHEN</span> <span class="p">(</span><span class="n">SCR_MSG_IN</span><span class="p">)),</span>
		<span class="n">PADDR_A</span> <span class="p">(</span><span class="n">dispatch</span><span class="p">),</span>
	<span class="cm">/*</span>
<span class="cm">	 *  We are in MSG_IN phase,</span>
<span class="cm">	 *  Read the first byte of the message.</span>
<span class="cm">	 *  If it is not an IGNORE RESIDUE message,</span>
<span class="cm">	 *  signal overrun and jump to message </span>
<span class="cm">	 *  processing.</span>
<span class="cm">	 */</span>
	<span class="n">SCR_MOVE_ABS</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">^</span> <span class="n">SCR_MSG_IN</span><span class="p">,</span>
		<span class="n">HADDR_1</span> <span class="p">(</span><span class="n">msgin</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span>
	<span class="n">SCR_INT</span> <span class="o">^</span> <span class="n">IFFALSE</span> <span class="p">(</span><span class="n">DATA</span> <span class="p">(</span><span class="n">M_IGN_RESIDUE</span><span class="p">)),</span>
		<span class="n">SIR_SWIDE_OVERRUN</span><span class="p">,</span>
	<span class="n">SCR_JUMP</span> <span class="o">^</span> <span class="n">IFFALSE</span> <span class="p">(</span><span class="n">DATA</span> <span class="p">(</span><span class="n">M_IGN_RESIDUE</span><span class="p">)),</span>
		<span class="n">PADDR_A</span> <span class="p">(</span><span class="n">msg_in2</span><span class="p">),</span>
	<span class="cm">/*</span>
<span class="cm">	 *  We got the message we expected.</span>
<span class="cm">	 *  Read the 2nd byte, and jump to dispatcher.</span>
<span class="cm">	 */</span>
	<span class="n">SCR_CLR</span> <span class="p">(</span><span class="n">SCR_ACK</span><span class="p">),</span>
		<span class="mi">0</span><span class="p">,</span>
	<span class="n">SCR_MOVE_ABS</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">^</span> <span class="n">SCR_MSG_IN</span><span class="p">,</span>
		<span class="n">HADDR_1</span> <span class="p">(</span><span class="n">msgin</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span>
	<span class="n">SCR_CLR</span> <span class="p">(</span><span class="n">SCR_ACK</span><span class="p">),</span>
		<span class="mi">0</span><span class="p">,</span>
	<span class="n">SCR_JUMP</span><span class="p">,</span>
		<span class="n">PADDR_A</span> <span class="p">(</span><span class="n">dispatch</span><span class="p">),</span>
<span class="p">}</span><span class="cm">/*-------------------------&lt; DATAO_DONE &gt;-----------------------*/</span><span class="p">,{</span>
	<span class="cm">/*</span>
<span class="cm">	 *  Save current pointer to LASTP.</span>
<span class="cm">	 */</span>
	<span class="n">SCR_STORE_REL</span> <span class="p">(</span><span class="n">temp</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span>
		<span class="n">offsetof</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sym_ccb</span><span class="p">,</span> <span class="n">phys</span><span class="p">.</span><span class="n">head</span><span class="p">.</span><span class="n">lastp</span><span class="p">),</span>
	<span class="cm">/*</span>
<span class="cm">	 *  If the SODL is not full jump to dispatcher.</span>
<span class="cm">	 *  We anticipate a STATUS phase.</span>
<span class="cm">	 */</span>
	<span class="n">SCR_FROM_REG</span> <span class="p">(</span><span class="n">scntl2</span><span class="p">),</span>
		<span class="mi">0</span><span class="p">,</span>
	<span class="n">SCR_JUMP</span> <span class="o">^</span> <span class="n">IFTRUE</span> <span class="p">(</span><span class="n">MASK</span> <span class="p">(</span><span class="n">WSS</span><span class="p">,</span> <span class="n">WSS</span><span class="p">)),</span>
		<span class="n">PADDR_A</span> <span class="p">(</span><span class="n">datao_done_wss</span><span class="p">),</span>
	<span class="n">SCR_JUMP</span> <span class="o">^</span> <span class="n">IFTRUE</span> <span class="p">(</span><span class="n">WHEN</span> <span class="p">(</span><span class="n">SCR_STATUS</span><span class="p">)),</span>
		<span class="n">PADDR_A</span> <span class="p">(</span><span class="n">status</span><span class="p">),</span>
	<span class="n">SCR_JUMP</span><span class="p">,</span>
		<span class="n">PADDR_A</span> <span class="p">(</span><span class="n">dispatch</span><span class="p">),</span>
<span class="p">}</span><span class="cm">/*-------------------------&lt; DATAO_DONE_WSS &gt;-------------------*/</span><span class="p">,{</span>
	<span class="cm">/*</span>
<span class="cm">	 *  The SODL is full, clear this condition.</span>
<span class="cm">	 */</span>
	<span class="n">SCR_REG_REG</span> <span class="p">(</span><span class="n">scntl2</span><span class="p">,</span> <span class="n">SCR_OR</span><span class="p">,</span> <span class="n">WSS</span><span class="p">),</span>
		<span class="mi">0</span><span class="p">,</span>
	<span class="cm">/*</span>
<span class="cm">	 *  And signal a DATA UNDERRUN condition </span>
<span class="cm">	 *  to the C code.</span>
<span class="cm">	 */</span>
	<span class="n">SCR_INT</span><span class="p">,</span>
		<span class="n">SIR_SODL_UNDERRUN</span><span class="p">,</span>
	<span class="n">SCR_JUMP</span><span class="p">,</span>
		<span class="n">PADDR_A</span> <span class="p">(</span><span class="n">dispatch</span><span class="p">),</span>
<span class="p">}</span><span class="cm">/*-------------------------&lt; DATAI_PHASE &gt;----------------------*/</span><span class="p">,{</span>
	<span class="cm">/*</span>
<span class="cm">	 *  Jump to current pointer.</span>
<span class="cm">	 */</span>
	<span class="n">SCR_LOAD_REL</span> <span class="p">(</span><span class="n">temp</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span>
		<span class="n">offsetof</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sym_ccb</span><span class="p">,</span> <span class="n">phys</span><span class="p">.</span><span class="n">head</span><span class="p">.</span><span class="n">lastp</span><span class="p">),</span>
	<span class="n">SCR_RETURN</span><span class="p">,</span>
		<span class="mi">0</span><span class="p">,</span>
<span class="p">}</span><span class="cm">/*-------------------------&lt; DATAO_PHASE &gt;----------------------*/</span><span class="p">,{</span>
	<span class="cm">/*</span>
<span class="cm">	 *  C1010-66 errata work-around.</span>
<span class="cm">	 *  Extra clocks of data hold must be inserted </span>
<span class="cm">	 *  in DATA OUT phase on 33 MHz PCI BUS.</span>
<span class="cm">	 *  Patched with a NOOP for other chips.</span>
<span class="cm">	 */</span>
	<span class="n">SCR_REG_REG</span> <span class="p">(</span><span class="n">scntl4</span><span class="p">,</span> <span class="n">SCR_OR</span><span class="p">,</span> <span class="p">(</span><span class="n">XCLKH_DT</span><span class="o">|</span><span class="n">XCLKH_ST</span><span class="p">)),</span>
		<span class="mi">0</span><span class="p">,</span>
	<span class="cm">/*</span>
<span class="cm">	 *  Jump to current pointer.</span>
<span class="cm">	 */</span>
	<span class="n">SCR_LOAD_REL</span> <span class="p">(</span><span class="n">temp</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span>
		<span class="n">offsetof</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sym_ccb</span><span class="p">,</span> <span class="n">phys</span><span class="p">.</span><span class="n">head</span><span class="p">.</span><span class="n">lastp</span><span class="p">),</span>
	<span class="n">SCR_RETURN</span><span class="p">,</span>
		<span class="mi">0</span><span class="p">,</span>
<span class="p">}</span><span class="cm">/*-------------------------&lt; MSG_IN &gt;---------------------------*/</span><span class="p">,{</span>
	<span class="cm">/*</span>
<span class="cm">	 *  Get the first byte of the message.</span>
<span class="cm">	 *</span>
<span class="cm">	 *  The script processor doesn&#39;t negate the</span>
<span class="cm">	 *  ACK signal after this transfer.</span>
<span class="cm">	 */</span>
	<span class="n">SCR_MOVE_ABS</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">^</span> <span class="n">SCR_MSG_IN</span><span class="p">,</span>
		<span class="n">HADDR_1</span> <span class="p">(</span><span class="n">msgin</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span>
<span class="p">}</span><span class="cm">/*-------------------------&lt; MSG_IN2 &gt;--------------------------*/</span><span class="p">,{</span>
	<span class="cm">/*</span>
<span class="cm">	 *  Check first against 1 byte messages </span>
<span class="cm">	 *  that we handle from SCRIPTS.</span>
<span class="cm">	 */</span>
	<span class="n">SCR_JUMP</span> <span class="o">^</span> <span class="n">IFTRUE</span> <span class="p">(</span><span class="n">DATA</span> <span class="p">(</span><span class="n">M_COMPLETE</span><span class="p">)),</span>
		<span class="n">PADDR_A</span> <span class="p">(</span><span class="n">complete</span><span class="p">),</span>
	<span class="n">SCR_JUMP</span> <span class="o">^</span> <span class="n">IFTRUE</span> <span class="p">(</span><span class="n">DATA</span> <span class="p">(</span><span class="n">M_DISCONNECT</span><span class="p">)),</span>
		<span class="n">PADDR_A</span> <span class="p">(</span><span class="n">disconnect</span><span class="p">),</span>
	<span class="n">SCR_JUMP</span> <span class="o">^</span> <span class="n">IFTRUE</span> <span class="p">(</span><span class="n">DATA</span> <span class="p">(</span><span class="n">M_SAVE_DP</span><span class="p">)),</span>
		<span class="n">PADDR_A</span> <span class="p">(</span><span class="n">save_dp</span><span class="p">),</span>
	<span class="n">SCR_JUMP</span> <span class="o">^</span> <span class="n">IFTRUE</span> <span class="p">(</span><span class="n">DATA</span> <span class="p">(</span><span class="n">M_RESTORE_DP</span><span class="p">)),</span>
		<span class="n">PADDR_A</span> <span class="p">(</span><span class="n">restore_dp</span><span class="p">),</span>
	<span class="cm">/*</span>
<span class="cm">	 *  We handle all other messages from the </span>
<span class="cm">	 *  C code, so no need to waste on-chip RAM </span>
<span class="cm">	 *  for those ones.</span>
<span class="cm">	 */</span>
	<span class="n">SCR_JUMP</span><span class="p">,</span>
		<span class="n">PADDR_B</span> <span class="p">(</span><span class="n">msg_in_etc</span><span class="p">),</span>
<span class="p">}</span><span class="cm">/*-------------------------&lt; STATUS &gt;---------------------------*/</span><span class="p">,{</span>
	<span class="cm">/*</span>
<span class="cm">	 *  get the status</span>
<span class="cm">	 */</span>
	<span class="n">SCR_MOVE_ABS</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">^</span> <span class="n">SCR_STATUS</span><span class="p">,</span>
		<span class="n">HADDR_1</span> <span class="p">(</span><span class="n">scratch</span><span class="p">),</span>
<span class="cp">#ifdef SYM_CONF_IARB_SUPPORT</span>
	<span class="cm">/*</span>
<span class="cm">	 *  If STATUS is not GOOD, clear IMMEDIATE ARBITRATION, </span>
<span class="cm">	 *  since we may have to tamper the start queue from </span>
<span class="cm">	 *  the C code.</span>
<span class="cm">	 */</span>
	<span class="n">SCR_JUMPR</span> <span class="o">^</span> <span class="n">IFTRUE</span> <span class="p">(</span><span class="n">DATA</span> <span class="p">(</span><span class="n">S_GOOD</span><span class="p">)),</span>
		<span class="mi">8</span><span class="p">,</span>
	<span class="n">SCR_REG_REG</span> <span class="p">(</span><span class="n">scntl1</span><span class="p">,</span> <span class="n">SCR_AND</span><span class="p">,</span> <span class="o">~</span><span class="n">IARB</span><span class="p">),</span>
		<span class="mi">0</span><span class="p">,</span>
<span class="cp">#endif</span>
	<span class="cm">/*</span>
<span class="cm">	 *  save status to scsi_status.</span>
<span class="cm">	 *  mark as complete.</span>
<span class="cm">	 */</span>
	<span class="n">SCR_TO_REG</span> <span class="p">(</span><span class="n">SS_REG</span><span class="p">),</span>
		<span class="mi">0</span><span class="p">,</span>
	<span class="n">SCR_LOAD_REG</span> <span class="p">(</span><span class="n">HS_REG</span><span class="p">,</span> <span class="n">HS_COMPLETE</span><span class="p">),</span>
		<span class="mi">0</span><span class="p">,</span>
	<span class="cm">/*</span>
<span class="cm">	 *  Anticipate the MESSAGE PHASE for </span>
<span class="cm">	 *  the TASK COMPLETE message.</span>
<span class="cm">	 */</span>
	<span class="n">SCR_JUMP</span> <span class="o">^</span> <span class="n">IFTRUE</span> <span class="p">(</span><span class="n">WHEN</span> <span class="p">(</span><span class="n">SCR_MSG_IN</span><span class="p">)),</span>
		<span class="n">PADDR_A</span> <span class="p">(</span><span class="n">msg_in</span><span class="p">),</span>
	<span class="n">SCR_JUMP</span><span class="p">,</span>
		<span class="n">PADDR_A</span> <span class="p">(</span><span class="n">dispatch</span><span class="p">),</span>
<span class="p">}</span><span class="cm">/*-------------------------&lt; COMPLETE &gt;-------------------------*/</span><span class="p">,{</span>
	<span class="cm">/*</span>
<span class="cm">	 *  Complete message.</span>
<span class="cm">	 *</span>
<span class="cm">	 *  When we terminate the cycle by clearing ACK,</span>
<span class="cm">	 *  the target may disconnect immediately.</span>
<span class="cm">	 *</span>
<span class="cm">	 *  We don&#39;t want to be told of an &quot;unexpected disconnect&quot;,</span>
<span class="cm">	 *  so we disable this feature.</span>
<span class="cm">	 */</span>
	<span class="n">SCR_REG_REG</span> <span class="p">(</span><span class="n">scntl2</span><span class="p">,</span> <span class="n">SCR_AND</span><span class="p">,</span> <span class="mh">0x7f</span><span class="p">),</span>
		<span class="mi">0</span><span class="p">,</span>
	<span class="cm">/*</span>
<span class="cm">	 *  Terminate cycle ...</span>
<span class="cm">	 */</span>
	<span class="n">SCR_CLR</span> <span class="p">(</span><span class="n">SCR_ACK</span><span class="o">|</span><span class="n">SCR_ATN</span><span class="p">),</span>
		<span class="mi">0</span><span class="p">,</span>
	<span class="cm">/*</span>
<span class="cm">	 *  ... and wait for the disconnect.</span>
<span class="cm">	 */</span>
	<span class="n">SCR_WAIT_DISC</span><span class="p">,</span>
		<span class="mi">0</span><span class="p">,</span>
<span class="p">}</span><span class="cm">/*-------------------------&lt; COMPLETE2 &gt;------------------------*/</span><span class="p">,{</span>
	<span class="cm">/*</span>
<span class="cm">	 *  Save host status.</span>
<span class="cm">	 */</span>
	<span class="n">SCR_STORE_REL</span> <span class="p">(</span><span class="n">scr0</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span>
		<span class="n">offsetof</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sym_ccb</span><span class="p">,</span> <span class="n">phys</span><span class="p">.</span><span class="n">head</span><span class="p">.</span><span class="n">status</span><span class="p">),</span>
	<span class="cm">/*</span>
<span class="cm">	 *  Some bridges may reorder DMA writes to memory.</span>
<span class="cm">	 *  We donnot want the CPU to deal with completions  </span>
<span class="cm">	 *  without all the posted write having been flushed </span>
<span class="cm">	 *  to memory. This DUMMY READ should flush posted </span>
<span class="cm">	 *  buffers prior to the CPU having to deal with </span>
<span class="cm">	 *  completions.</span>
<span class="cm">	 */</span>
	<span class="n">SCR_LOAD_REL</span> <span class="p">(</span><span class="n">scr0</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span>	<span class="cm">/* DUMMY READ */</span>
		<span class="n">offsetof</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sym_ccb</span><span class="p">,</span> <span class="n">phys</span><span class="p">.</span><span class="n">head</span><span class="p">.</span><span class="n">status</span><span class="p">),</span>

	<span class="cm">/*</span>
<span class="cm">	 *  If command resulted in not GOOD status,</span>
<span class="cm">	 *  call the C code if needed.</span>
<span class="cm">	 */</span>
	<span class="n">SCR_FROM_REG</span> <span class="p">(</span><span class="n">SS_REG</span><span class="p">),</span>
		<span class="mi">0</span><span class="p">,</span>
	<span class="n">SCR_CALL</span> <span class="o">^</span> <span class="n">IFFALSE</span> <span class="p">(</span><span class="n">DATA</span> <span class="p">(</span><span class="n">S_GOOD</span><span class="p">)),</span>
		<span class="n">PADDR_B</span> <span class="p">(</span><span class="n">bad_status</span><span class="p">),</span>
	<span class="cm">/*</span>
<span class="cm">	 *  If we performed an auto-sense, call </span>
<span class="cm">	 *  the C code to synchronyze task aborts </span>
<span class="cm">	 *  with UNIT ATTENTION conditions.</span>
<span class="cm">	 */</span>
	<span class="n">SCR_FROM_REG</span> <span class="p">(</span><span class="n">HF_REG</span><span class="p">),</span>
		<span class="mi">0</span><span class="p">,</span>
	<span class="n">SCR_JUMP</span> <span class="o">^</span> <span class="n">IFFALSE</span> <span class="p">(</span><span class="n">MASK</span> <span class="p">(</span><span class="mi">0</span> <span class="p">,(</span><span class="n">HF_SENSE</span><span class="o">|</span><span class="n">HF_EXT_ERR</span><span class="p">))),</span>
		<span class="n">PADDR_A</span> <span class="p">(</span><span class="n">complete_error</span><span class="p">),</span>
<span class="p">}</span><span class="cm">/*-------------------------&lt; DONE &gt;-----------------------------*/</span><span class="p">,{</span>
	<span class="cm">/*</span>
<span class="cm">	 *  Copy the DSA to the DONE QUEUE and </span>
<span class="cm">	 *  signal completion to the host.</span>
<span class="cm">	 *  If we are interrupted between DONE </span>
<span class="cm">	 *  and DONE_END, we must reset, otherwise </span>
<span class="cm">	 *  the completed CCB may be lost.</span>
<span class="cm">	 */</span>
	<span class="n">SCR_STORE_ABS</span> <span class="p">(</span><span class="n">dsa</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span>
		<span class="n">PADDR_B</span> <span class="p">(</span><span class="n">scratch</span><span class="p">),</span>
	<span class="n">SCR_LOAD_ABS</span> <span class="p">(</span><span class="n">dsa</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span>
		<span class="n">PADDR_B</span> <span class="p">(</span><span class="n">done_pos</span><span class="p">),</span>
	<span class="n">SCR_LOAD_ABS</span> <span class="p">(</span><span class="n">scratcha</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span>
		<span class="n">PADDR_B</span> <span class="p">(</span><span class="n">scratch</span><span class="p">),</span>
	<span class="n">SCR_STORE_REL</span> <span class="p">(</span><span class="n">scratcha</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span>
		<span class="mi">0</span><span class="p">,</span>
	<span class="cm">/*</span>
<span class="cm">	 *  The instruction below reads the DONE QUEUE next </span>
<span class="cm">	 *  free position from memory.</span>
<span class="cm">	 *  In addition it ensures that all PCI posted writes  </span>
<span class="cm">	 *  are flushed and so the DSA value of the done </span>
<span class="cm">	 *  CCB is visible by the CPU before INTFLY is raised.</span>
<span class="cm">	 */</span>
	<span class="n">SCR_LOAD_REL</span> <span class="p">(</span><span class="n">scratcha</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span>
		<span class="mi">4</span><span class="p">,</span>
	<span class="n">SCR_INT_FLY</span><span class="p">,</span>
		<span class="mi">0</span><span class="p">,</span>
	<span class="n">SCR_STORE_ABS</span> <span class="p">(</span><span class="n">scratcha</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span>
		<span class="n">PADDR_B</span> <span class="p">(</span><span class="n">done_pos</span><span class="p">),</span>
<span class="p">}</span><span class="cm">/*-------------------------&lt; DONE_END &gt;-------------------------*/</span><span class="p">,{</span>
	<span class="n">SCR_JUMP</span><span class="p">,</span>
		<span class="n">PADDR_A</span> <span class="p">(</span><span class="n">start</span><span class="p">),</span>
<span class="p">}</span><span class="cm">/*-------------------------&lt; COMPLETE_ERROR &gt;-------------------*/</span><span class="p">,{</span>
	<span class="n">SCR_LOAD_ABS</span> <span class="p">(</span><span class="n">scratcha</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span>
		<span class="n">PADDR_B</span> <span class="p">(</span><span class="n">startpos</span><span class="p">),</span>
	<span class="n">SCR_INT</span><span class="p">,</span>
		<span class="n">SIR_COMPLETE_ERROR</span><span class="p">,</span>
<span class="p">}</span><span class="cm">/*-------------------------&lt; SAVE_DP &gt;--------------------------*/</span><span class="p">,{</span>
	<span class="cm">/*</span>
<span class="cm">	 *  Clear ACK immediately.</span>
<span class="cm">	 *  No need to delay it.</span>
<span class="cm">	 */</span>
	<span class="n">SCR_CLR</span> <span class="p">(</span><span class="n">SCR_ACK</span><span class="p">),</span>
		<span class="mi">0</span><span class="p">,</span>
	<span class="cm">/*</span>
<span class="cm">	 *  Keep track we received a SAVE DP, so </span>
<span class="cm">	 *  we will switch to the other PM context </span>
<span class="cm">	 *  on the next PM since the DP may point </span>
<span class="cm">	 *  to the current PM context.</span>
<span class="cm">	 */</span>
	<span class="n">SCR_REG_REG</span> <span class="p">(</span><span class="n">HF_REG</span><span class="p">,</span> <span class="n">SCR_OR</span><span class="p">,</span> <span class="n">HF_DP_SAVED</span><span class="p">),</span>
		<span class="mi">0</span><span class="p">,</span>
	<span class="cm">/*</span>
<span class="cm">	 *  SAVE_DP message:</span>
<span class="cm">	 *  Copy LASTP to SAVEP.</span>
<span class="cm">	 */</span>
	<span class="n">SCR_LOAD_REL</span> <span class="p">(</span><span class="n">scratcha</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span>
		<span class="n">offsetof</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sym_ccb</span><span class="p">,</span> <span class="n">phys</span><span class="p">.</span><span class="n">head</span><span class="p">.</span><span class="n">lastp</span><span class="p">),</span>
	<span class="n">SCR_STORE_REL</span> <span class="p">(</span><span class="n">scratcha</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span>
		<span class="n">offsetof</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sym_ccb</span><span class="p">,</span> <span class="n">phys</span><span class="p">.</span><span class="n">head</span><span class="p">.</span><span class="n">savep</span><span class="p">),</span>
	<span class="cm">/*</span>
<span class="cm">	 *  Anticipate the MESSAGE PHASE for </span>
<span class="cm">	 *  the DISCONNECT message.</span>
<span class="cm">	 */</span>
	<span class="n">SCR_JUMP</span> <span class="o">^</span> <span class="n">IFTRUE</span> <span class="p">(</span><span class="n">WHEN</span> <span class="p">(</span><span class="n">SCR_MSG_IN</span><span class="p">)),</span>
		<span class="n">PADDR_A</span> <span class="p">(</span><span class="n">msg_in</span><span class="p">),</span>
	<span class="n">SCR_JUMP</span><span class="p">,</span>
		<span class="n">PADDR_A</span> <span class="p">(</span><span class="n">dispatch</span><span class="p">),</span>
<span class="p">}</span><span class="cm">/*-------------------------&lt; RESTORE_DP &gt;-----------------------*/</span><span class="p">,{</span>
	<span class="cm">/*</span>
<span class="cm">	 *  Clear ACK immediately.</span>
<span class="cm">	 *  No need to delay it.</span>
<span class="cm">	 */</span>
	<span class="n">SCR_CLR</span> <span class="p">(</span><span class="n">SCR_ACK</span><span class="p">),</span>
		<span class="mi">0</span><span class="p">,</span>
	<span class="cm">/*</span>
<span class="cm">	 *  Copy SAVEP to LASTP.</span>
<span class="cm">	 */</span>
	<span class="n">SCR_LOAD_REL</span>  <span class="p">(</span><span class="n">scratcha</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span>
		<span class="n">offsetof</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sym_ccb</span><span class="p">,</span> <span class="n">phys</span><span class="p">.</span><span class="n">head</span><span class="p">.</span><span class="n">savep</span><span class="p">),</span>
	<span class="n">SCR_STORE_REL</span> <span class="p">(</span><span class="n">scratcha</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span>
		<span class="n">offsetof</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sym_ccb</span><span class="p">,</span> <span class="n">phys</span><span class="p">.</span><span class="n">head</span><span class="p">.</span><span class="n">lastp</span><span class="p">),</span>
	<span class="n">SCR_JUMP</span><span class="p">,</span>
		<span class="n">PADDR_A</span> <span class="p">(</span><span class="n">dispatch</span><span class="p">),</span>
<span class="p">}</span><span class="cm">/*-------------------------&lt; DISCONNECT &gt;-----------------------*/</span><span class="p">,{</span>
	<span class="cm">/*</span>
<span class="cm">	 *  DISCONNECTing  ...</span>
<span class="cm">	 *</span>
<span class="cm">	 *  disable the &quot;unexpected disconnect&quot; feature,</span>
<span class="cm">	 *  and remove the ACK signal.</span>
<span class="cm">	 */</span>
	<span class="n">SCR_REG_REG</span> <span class="p">(</span><span class="n">scntl2</span><span class="p">,</span> <span class="n">SCR_AND</span><span class="p">,</span> <span class="mh">0x7f</span><span class="p">),</span>
		<span class="mi">0</span><span class="p">,</span>
	<span class="n">SCR_CLR</span> <span class="p">(</span><span class="n">SCR_ACK</span><span class="o">|</span><span class="n">SCR_ATN</span><span class="p">),</span>
		<span class="mi">0</span><span class="p">,</span>
	<span class="cm">/*</span>
<span class="cm">	 *  Wait for the disconnect.</span>
<span class="cm">	 */</span>
	<span class="n">SCR_WAIT_DISC</span><span class="p">,</span>
		<span class="mi">0</span><span class="p">,</span>
	<span class="cm">/*</span>
<span class="cm">	 *  Status is: DISCONNECTED.</span>
<span class="cm">	 */</span>
	<span class="n">SCR_LOAD_REG</span> <span class="p">(</span><span class="n">HS_REG</span><span class="p">,</span> <span class="n">HS_DISCONNECT</span><span class="p">),</span>
		<span class="mi">0</span><span class="p">,</span>
	<span class="cm">/*</span>
<span class="cm">	 *  Save host status.</span>
<span class="cm">	 */</span>
	<span class="n">SCR_STORE_REL</span> <span class="p">(</span><span class="n">scr0</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span>
		<span class="n">offsetof</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sym_ccb</span><span class="p">,</span> <span class="n">phys</span><span class="p">.</span><span class="n">head</span><span class="p">.</span><span class="n">status</span><span class="p">),</span>
	<span class="n">SCR_JUMP</span><span class="p">,</span>
		<span class="n">PADDR_A</span> <span class="p">(</span><span class="n">start</span><span class="p">),</span>
<span class="p">}</span><span class="cm">/*-------------------------&lt; IDLE &gt;-----------------------------*/</span><span class="p">,{</span>
	<span class="cm">/*</span>
<span class="cm">	 *  Nothing to do?</span>
<span class="cm">	 *  Switch the LED off and wait for reselect.</span>
<span class="cm">	 *  Will be patched with a NO_OP if LED</span>
<span class="cm">	 *  not needed or not desired.</span>
<span class="cm">	 */</span>
	<span class="n">SCR_REG_REG</span> <span class="p">(</span><span class="n">gpreg</span><span class="p">,</span> <span class="n">SCR_OR</span><span class="p">,</span> <span class="mh">0x01</span><span class="p">),</span>
		<span class="mi">0</span><span class="p">,</span>
<span class="cp">#ifdef SYM_CONF_IARB_SUPPORT</span>
	<span class="n">SCR_JUMPR</span><span class="p">,</span>
		<span class="mi">8</span><span class="p">,</span>
<span class="cp">#endif</span>
<span class="p">}</span><span class="cm">/*-------------------------&lt; UNGETJOB &gt;-------------------------*/</span><span class="p">,{</span>
<span class="cp">#ifdef SYM_CONF_IARB_SUPPORT</span>
	<span class="cm">/*</span>
<span class="cm">	 *  Set IMMEDIATE ARBITRATION, for the next time.</span>
<span class="cm">	 *  This will give us better chance to win arbitration </span>
<span class="cm">	 *  for the job we just wanted to do.</span>
<span class="cm">	 */</span>
	<span class="n">SCR_REG_REG</span> <span class="p">(</span><span class="n">scntl1</span><span class="p">,</span> <span class="n">SCR_OR</span><span class="p">,</span> <span class="n">IARB</span><span class="p">),</span>
		<span class="mi">0</span><span class="p">,</span>
<span class="cp">#endif</span>
	<span class="cm">/*</span>
<span class="cm">	 *  We are not able to restart the SCRIPTS if we are </span>
<span class="cm">	 *  interrupted and these instruction haven&#39;t been </span>
<span class="cm">	 *  all executed. BTW, this is very unlikely to </span>
<span class="cm">	 *  happen, but we check that from the C code.</span>
<span class="cm">	 */</span>
	<span class="n">SCR_LOAD_REG</span> <span class="p">(</span><span class="n">dsa</span><span class="p">,</span> <span class="mh">0xff</span><span class="p">),</span>
		<span class="mi">0</span><span class="p">,</span>
	<span class="n">SCR_STORE_ABS</span> <span class="p">(</span><span class="n">scratcha</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span>
		<span class="n">PADDR_B</span> <span class="p">(</span><span class="n">startpos</span><span class="p">),</span>
<span class="p">}</span><span class="cm">/*-------------------------&lt; RESELECT &gt;-------------------------*/</span><span class="p">,{</span>
<span class="cp">#ifdef SYM_CONF_TARGET_ROLE_SUPPORT</span>
	<span class="cm">/*</span>
<span class="cm">	 *  Make sure we are in initiator mode.</span>
<span class="cm">	 */</span>
	<span class="n">SCR_CLR</span> <span class="p">(</span><span class="n">SCR_TRG</span><span class="p">),</span>
		<span class="mi">0</span><span class="p">,</span>
<span class="cp">#endif</span>
	<span class="cm">/*</span>
<span class="cm">	 *  Sleep waiting for a reselection.</span>
<span class="cm">	 */</span>
	<span class="n">SCR_WAIT_RESEL</span><span class="p">,</span>
		<span class="n">PADDR_A</span><span class="p">(</span><span class="n">start</span><span class="p">),</span>
<span class="p">}</span><span class="cm">/*-------------------------&lt; RESELECTED &gt;-----------------------*/</span><span class="p">,{</span>
	<span class="cm">/*</span>
<span class="cm">	 *  Switch the LED on.</span>
<span class="cm">	 *  Will be patched with a NO_OP if LED</span>
<span class="cm">	 *  not needed or not desired.</span>
<span class="cm">	 */</span>
	<span class="n">SCR_REG_REG</span> <span class="p">(</span><span class="n">gpreg</span><span class="p">,</span> <span class="n">SCR_AND</span><span class="p">,</span> <span class="mh">0xfe</span><span class="p">),</span>
		<span class="mi">0</span><span class="p">,</span>
	<span class="cm">/*</span>
<span class="cm">	 *  load the target id into the sdid</span>
<span class="cm">	 */</span>
	<span class="n">SCR_REG_SFBR</span> <span class="p">(</span><span class="n">ssid</span><span class="p">,</span> <span class="n">SCR_AND</span><span class="p">,</span> <span class="mh">0x8F</span><span class="p">),</span>
		<span class="mi">0</span><span class="p">,</span>
	<span class="n">SCR_TO_REG</span> <span class="p">(</span><span class="n">sdid</span><span class="p">),</span>
		<span class="mi">0</span><span class="p">,</span>
	<span class="cm">/*</span>
<span class="cm">	 *  Load the target control block address</span>
<span class="cm">	 */</span>
	<span class="n">SCR_LOAD_ABS</span> <span class="p">(</span><span class="n">dsa</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span>
		<span class="n">PADDR_B</span> <span class="p">(</span><span class="n">targtbl</span><span class="p">),</span>
	<span class="n">SCR_SFBR_REG</span> <span class="p">(</span><span class="n">dsa</span><span class="p">,</span> <span class="n">SCR_SHL</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
		<span class="mi">0</span><span class="p">,</span>
	<span class="n">SCR_REG_REG</span> <span class="p">(</span><span class="n">dsa</span><span class="p">,</span> <span class="n">SCR_SHL</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
		<span class="mi">0</span><span class="p">,</span>
	<span class="n">SCR_REG_REG</span> <span class="p">(</span><span class="n">dsa</span><span class="p">,</span> <span class="n">SCR_AND</span><span class="p">,</span> <span class="mh">0x3c</span><span class="p">),</span>
		<span class="mi">0</span><span class="p">,</span>
	<span class="n">SCR_LOAD_REL</span> <span class="p">(</span><span class="n">dsa</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span>
		<span class="mi">0</span><span class="p">,</span>
	<span class="cm">/*</span>
<span class="cm">	 *  We expect MESSAGE IN phase.</span>
<span class="cm">	 *  If not, get help from the C code.</span>
<span class="cm">	 */</span>
	<span class="n">SCR_INT</span> <span class="o">^</span> <span class="n">IFFALSE</span> <span class="p">(</span><span class="n">WHEN</span> <span class="p">(</span><span class="n">SCR_MSG_IN</span><span class="p">)),</span>
		<span class="n">SIR_RESEL_NO_MSG_IN</span><span class="p">,</span>
	<span class="cm">/*</span>
<span class="cm">	 *  Load the legacy synchronous transfer registers.</span>
<span class="cm">	 */</span>
	<span class="n">SCR_LOAD_REL</span> <span class="p">(</span><span class="n">scntl3</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
		<span class="n">offsetof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sym_tcb</span><span class="p">,</span> <span class="n">head</span><span class="p">.</span><span class="n">wval</span><span class="p">),</span>
	<span class="n">SCR_LOAD_REL</span> <span class="p">(</span><span class="n">sxfer</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
		<span class="n">offsetof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sym_tcb</span><span class="p">,</span> <span class="n">head</span><span class="p">.</span><span class="n">sval</span><span class="p">),</span>
<span class="p">}</span><span class="cm">/*-------------------------&lt; RESEL_SCNTL4 &gt;---------------------*/</span><span class="p">,{</span>
	<span class="cm">/*</span>
<span class="cm">	 *  The C1010 uses a new synchronous timing scheme.</span>
<span class="cm">	 *  Will be patched with a NO_OP if not a C1010.</span>
<span class="cm">	 */</span>
	<span class="n">SCR_LOAD_REL</span> <span class="p">(</span><span class="n">scntl4</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
		<span class="n">offsetof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sym_tcb</span><span class="p">,</span> <span class="n">head</span><span class="p">.</span><span class="n">uval</span><span class="p">),</span>
	<span class="cm">/*</span>
<span class="cm">	 *  Get the IDENTIFY message.</span>
<span class="cm">	 */</span>
	<span class="n">SCR_MOVE_ABS</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">^</span> <span class="n">SCR_MSG_IN</span><span class="p">,</span>
		<span class="n">HADDR_1</span> <span class="p">(</span><span class="n">msgin</span><span class="p">),</span>
	<span class="cm">/*</span>
<span class="cm">	 *  If IDENTIFY LUN #0, use a faster path </span>
<span class="cm">	 *  to find the LCB structure.</span>
<span class="cm">	 */</span>
	<span class="n">SCR_JUMP</span> <span class="o">^</span> <span class="n">IFTRUE</span> <span class="p">(</span><span class="n">MASK</span> <span class="p">(</span><span class="mh">0x80</span><span class="p">,</span> <span class="mh">0xbf</span><span class="p">)),</span>
		<span class="n">PADDR_A</span> <span class="p">(</span><span class="n">resel_lun0</span><span class="p">),</span>
	<span class="cm">/*</span>
<span class="cm">	 *  If message isn&#39;t an IDENTIFY, </span>
<span class="cm">	 *  tell the C code about.</span>
<span class="cm">	 */</span>
	<span class="n">SCR_INT</span> <span class="o">^</span> <span class="n">IFFALSE</span> <span class="p">(</span><span class="n">MASK</span> <span class="p">(</span><span class="mh">0x80</span><span class="p">,</span> <span class="mh">0x80</span><span class="p">)),</span>
		<span class="n">SIR_RESEL_NO_IDENTIFY</span><span class="p">,</span>
	<span class="cm">/*</span>
<span class="cm">	 *  It is an IDENTIFY message,</span>
<span class="cm">	 *  Load the LUN control block address.</span>
<span class="cm">	 */</span>
	<span class="n">SCR_LOAD_REL</span> <span class="p">(</span><span class="n">dsa</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span>
		<span class="n">offsetof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sym_tcb</span><span class="p">,</span> <span class="n">head</span><span class="p">.</span><span class="n">luntbl_sa</span><span class="p">),</span>
	<span class="n">SCR_SFBR_REG</span> <span class="p">(</span><span class="n">dsa</span><span class="p">,</span> <span class="n">SCR_SHL</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
		<span class="mi">0</span><span class="p">,</span>
	<span class="n">SCR_REG_REG</span> <span class="p">(</span><span class="n">dsa</span><span class="p">,</span> <span class="n">SCR_SHL</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
		<span class="mi">0</span><span class="p">,</span>
	<span class="n">SCR_REG_REG</span> <span class="p">(</span><span class="n">dsa</span><span class="p">,</span> <span class="n">SCR_AND</span><span class="p">,</span> <span class="mh">0xfc</span><span class="p">),</span>
		<span class="mi">0</span><span class="p">,</span>
	<span class="n">SCR_LOAD_REL</span> <span class="p">(</span><span class="n">dsa</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span>
		<span class="mi">0</span><span class="p">,</span>
	<span class="n">SCR_JUMPR</span><span class="p">,</span>
		<span class="mi">8</span><span class="p">,</span>
<span class="p">}</span><span class="cm">/*-------------------------&lt; RESEL_LUN0 &gt;-----------------------*/</span><span class="p">,{</span>
	<span class="cm">/*</span>
<span class="cm">	 *  LUN 0 special case (but usual one :))</span>
<span class="cm">	 */</span>
	<span class="n">SCR_LOAD_REL</span> <span class="p">(</span><span class="n">dsa</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span>
		<span class="n">offsetof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sym_tcb</span><span class="p">,</span> <span class="n">head</span><span class="p">.</span><span class="n">lun0_sa</span><span class="p">),</span>
	<span class="cm">/*</span>
<span class="cm">	 *  Jump indirectly to the reselect action for this LUN.</span>
<span class="cm">	 */</span>
	<span class="n">SCR_LOAD_REL</span> <span class="p">(</span><span class="n">temp</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span>
		<span class="n">offsetof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sym_lcb</span><span class="p">,</span> <span class="n">head</span><span class="p">.</span><span class="n">resel_sa</span><span class="p">),</span>
	<span class="n">SCR_RETURN</span><span class="p">,</span>
		<span class="mi">0</span><span class="p">,</span>
	<span class="cm">/* In normal situations, we jump to RESEL_TAG or RESEL_NO_TAG */</span>
<span class="p">}</span><span class="cm">/*-------------------------&lt; RESEL_TAG &gt;------------------------*/</span><span class="p">,{</span>
	<span class="cm">/*</span>
<span class="cm">	 *  ACK the IDENTIFY previously received.</span>
<span class="cm">	 */</span>
	<span class="n">SCR_CLR</span> <span class="p">(</span><span class="n">SCR_ACK</span><span class="p">),</span>
		<span class="mi">0</span><span class="p">,</span>
	<span class="cm">/*</span>
<span class="cm">	 *  It shall be a tagged command.</span>
<span class="cm">	 *  Read SIMPLE+TAG.</span>
<span class="cm">	 *  The C code will deal with errors.</span>
<span class="cm">	 *  Aggressive optimization, isn&#39;t it? :)</span>
<span class="cm">	 */</span>
	<span class="n">SCR_MOVE_ABS</span> <span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">^</span> <span class="n">SCR_MSG_IN</span><span class="p">,</span>
		<span class="n">HADDR_1</span> <span class="p">(</span><span class="n">msgin</span><span class="p">),</span>
	<span class="cm">/*</span>
<span class="cm">	 *  Load the pointer to the tagged task </span>
<span class="cm">	 *  table for this LUN.</span>
<span class="cm">	 */</span>
	<span class="n">SCR_LOAD_REL</span> <span class="p">(</span><span class="n">dsa</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span>
		<span class="n">offsetof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sym_lcb</span><span class="p">,</span> <span class="n">head</span><span class="p">.</span><span class="n">itlq_tbl_sa</span><span class="p">),</span>
	<span class="cm">/*</span>
<span class="cm">	 *  The SIDL still contains the TAG value.</span>
<span class="cm">	 *  Aggressive optimization, isn&#39;t it? :):)</span>
<span class="cm">	 */</span>
	<span class="n">SCR_REG_SFBR</span> <span class="p">(</span><span class="n">sidl</span><span class="p">,</span> <span class="n">SCR_SHL</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
		<span class="mi">0</span><span class="p">,</span>
<span class="cp">#if SYM_CONF_MAX_TASK*4 &gt; 512</span>
	<span class="n">SCR_JUMPR</span> <span class="o">^</span> <span class="n">IFFALSE</span> <span class="p">(</span><span class="n">CARRYSET</span><span class="p">),</span>
		<span class="mi">8</span><span class="p">,</span>
	<span class="n">SCR_REG_REG</span> <span class="p">(</span><span class="n">dsa1</span><span class="p">,</span> <span class="n">SCR_OR</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span>
		<span class="mi">0</span><span class="p">,</span>
	<span class="n">SCR_REG_REG</span> <span class="p">(</span><span class="n">sfbr</span><span class="p">,</span> <span class="n">SCR_SHL</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
		<span class="mi">0</span><span class="p">,</span>
	<span class="n">SCR_JUMPR</span> <span class="o">^</span> <span class="n">IFFALSE</span> <span class="p">(</span><span class="n">CARRYSET</span><span class="p">),</span>
		<span class="mi">8</span><span class="p">,</span>
	<span class="n">SCR_REG_REG</span> <span class="p">(</span><span class="n">dsa1</span><span class="p">,</span> <span class="n">SCR_OR</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
		<span class="mi">0</span><span class="p">,</span>
<span class="cp">#elif SYM_CONF_MAX_TASK*4 &gt; 256</span>
	<span class="n">SCR_JUMPR</span> <span class="o">^</span> <span class="n">IFFALSE</span> <span class="p">(</span><span class="n">CARRYSET</span><span class="p">),</span>
		<span class="mi">8</span><span class="p">,</span>
	<span class="n">SCR_REG_REG</span> <span class="p">(</span><span class="n">dsa1</span><span class="p">,</span> <span class="n">SCR_OR</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
		<span class="mi">0</span><span class="p">,</span>
<span class="cp">#endif</span>
	<span class="cm">/*</span>
<span class="cm">	 *  Retrieve the DSA of this task.</span>
<span class="cm">	 *  JUMP indirectly to the restart point of the CCB.</span>
<span class="cm">	 */</span>
	<span class="n">SCR_SFBR_REG</span> <span class="p">(</span><span class="n">dsa</span><span class="p">,</span> <span class="n">SCR_AND</span><span class="p">,</span> <span class="mh">0xfc</span><span class="p">),</span>
		<span class="mi">0</span><span class="p">,</span>
	<span class="n">SCR_LOAD_REL</span> <span class="p">(</span><span class="n">dsa</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span>
		<span class="mi">0</span><span class="p">,</span>
	<span class="n">SCR_LOAD_REL</span> <span class="p">(</span><span class="n">temp</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span>
		<span class="n">offsetof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sym_ccb</span><span class="p">,</span> <span class="n">phys</span><span class="p">.</span><span class="n">head</span><span class="p">.</span><span class="n">go</span><span class="p">.</span><span class="n">restart</span><span class="p">),</span>
	<span class="n">SCR_RETURN</span><span class="p">,</span>
		<span class="mi">0</span><span class="p">,</span>
	<span class="cm">/* In normal situations we branch to RESEL_DSA */</span>
<span class="p">}</span><span class="cm">/*-------------------------&lt; RESEL_DSA &gt;------------------------*/</span><span class="p">,{</span>
	<span class="cm">/*</span>
<span class="cm">	 *  ACK the IDENTIFY or TAG previously received.</span>
<span class="cm">	 */</span>
	<span class="n">SCR_CLR</span> <span class="p">(</span><span class="n">SCR_ACK</span><span class="p">),</span>
		<span class="mi">0</span><span class="p">,</span>
<span class="p">}</span><span class="cm">/*-------------------------&lt; RESEL_DSA1 &gt;-----------------------*/</span><span class="p">,{</span>
	<span class="cm">/*</span>
<span class="cm">	 *      Initialize the status registers</span>
<span class="cm">	 */</span>
	<span class="n">SCR_LOAD_REL</span> <span class="p">(</span><span class="n">scr0</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span>
		<span class="n">offsetof</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sym_ccb</span><span class="p">,</span> <span class="n">phys</span><span class="p">.</span><span class="n">head</span><span class="p">.</span><span class="n">status</span><span class="p">),</span>
	<span class="cm">/*</span>
<span class="cm">	 *  Jump to dispatcher.</span>
<span class="cm">	 */</span>
	<span class="n">SCR_JUMP</span><span class="p">,</span>
		<span class="n">PADDR_A</span> <span class="p">(</span><span class="n">dispatch</span><span class="p">),</span>
<span class="p">}</span><span class="cm">/*-------------------------&lt; RESEL_NO_TAG &gt;---------------------*/</span><span class="p">,{</span>
	<span class="cm">/*</span>
<span class="cm">	 *  Load the DSA with the unique ITL task.</span>
<span class="cm">	 */</span>
	<span class="n">SCR_LOAD_REL</span> <span class="p">(</span><span class="n">dsa</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span>
		<span class="n">offsetof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sym_lcb</span><span class="p">,</span> <span class="n">head</span><span class="p">.</span><span class="n">itl_task_sa</span><span class="p">),</span>
	<span class="cm">/*</span>
<span class="cm">	 *  JUMP indirectly to the restart point of the CCB.</span>
<span class="cm">	 */</span>
	<span class="n">SCR_LOAD_REL</span> <span class="p">(</span><span class="n">temp</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span>
		<span class="n">offsetof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sym_ccb</span><span class="p">,</span> <span class="n">phys</span><span class="p">.</span><span class="n">head</span><span class="p">.</span><span class="n">go</span><span class="p">.</span><span class="n">restart</span><span class="p">),</span>
	<span class="n">SCR_RETURN</span><span class="p">,</span>
		<span class="mi">0</span><span class="p">,</span>
	<span class="cm">/* In normal situations we branch to RESEL_DSA */</span>
<span class="p">}</span><span class="cm">/*-------------------------&lt; DATA_IN &gt;--------------------------*/</span><span class="p">,{</span>
<span class="cm">/*</span>
<span class="cm"> *  Because the size depends on the</span>
<span class="cm"> *  #define SYM_CONF_MAX_SG parameter,</span>
<span class="cm"> *  it is filled in at runtime.</span>
<span class="cm"> *</span>
<span class="cm"> *  ##===========&lt; i=0; i&lt;SYM_CONF_MAX_SG &gt;=========</span>
<span class="cm"> *  ||	SCR_CHMOV_TBL ^ SCR_DATA_IN,</span>
<span class="cm"> *  ||		offsetof (struct sym_dsb, data[ i]),</span>
<span class="cm"> *  ##==========================================</span>
<span class="cm"> */</span>
<span class="mi">0</span>
<span class="p">}</span><span class="cm">/*-------------------------&lt; DATA_IN2 &gt;-------------------------*/</span><span class="p">,{</span>
	<span class="n">SCR_CALL</span><span class="p">,</span>
		<span class="n">PADDR_A</span> <span class="p">(</span><span class="n">datai_done</span><span class="p">),</span>
	<span class="n">SCR_JUMP</span><span class="p">,</span>
		<span class="n">PADDR_B</span> <span class="p">(</span><span class="n">data_ovrun</span><span class="p">),</span>
<span class="p">}</span><span class="cm">/*-------------------------&lt; DATA_OUT &gt;-------------------------*/</span><span class="p">,{</span>
<span class="cm">/*</span>
<span class="cm"> *  Because the size depends on the</span>
<span class="cm"> *  #define SYM_CONF_MAX_SG parameter,</span>
<span class="cm"> *  it is filled in at runtime.</span>
<span class="cm"> *</span>
<span class="cm"> *  ##===========&lt; i=0; i&lt;SYM_CONF_MAX_SG &gt;=========</span>
<span class="cm"> *  ||	SCR_CHMOV_TBL ^ SCR_DATA_OUT,</span>
<span class="cm"> *  ||		offsetof (struct sym_dsb, data[ i]),</span>
<span class="cm"> *  ##==========================================</span>
<span class="cm"> */</span>
<span class="mi">0</span>
<span class="p">}</span><span class="cm">/*-------------------------&lt; DATA_OUT2 &gt;------------------------*/</span><span class="p">,{</span>
	<span class="n">SCR_CALL</span><span class="p">,</span>
		<span class="n">PADDR_A</span> <span class="p">(</span><span class="n">datao_done</span><span class="p">),</span>
	<span class="n">SCR_JUMP</span><span class="p">,</span>
		<span class="n">PADDR_B</span> <span class="p">(</span><span class="n">data_ovrun</span><span class="p">),</span>
<span class="p">}</span><span class="cm">/*-------------------------&lt; PM0_DATA &gt;-------------------------*/</span><span class="p">,{</span>
	<span class="cm">/*</span>
<span class="cm">	 *  Read our host flags to SFBR, so we will be able </span>
<span class="cm">	 *  to check against the data direction we expect.</span>
<span class="cm">	 */</span>
	<span class="n">SCR_FROM_REG</span> <span class="p">(</span><span class="n">HF_REG</span><span class="p">),</span>
		<span class="mi">0</span><span class="p">,</span>
	<span class="cm">/*</span>
<span class="cm">	 *  Check against actual DATA PHASE.</span>
<span class="cm">	 */</span>
	<span class="n">SCR_JUMP</span> <span class="o">^</span> <span class="n">IFFALSE</span> <span class="p">(</span><span class="n">WHEN</span> <span class="p">(</span><span class="n">SCR_DATA_IN</span><span class="p">)),</span>
		<span class="n">PADDR_A</span> <span class="p">(</span><span class="n">pm0_data_out</span><span class="p">),</span>
	<span class="cm">/*</span>
<span class="cm">	 *  Actual phase is DATA IN.</span>
<span class="cm">	 *  Check against expected direction.</span>
<span class="cm">	 */</span>
	<span class="n">SCR_JUMP</span> <span class="o">^</span> <span class="n">IFFALSE</span> <span class="p">(</span><span class="n">MASK</span> <span class="p">(</span><span class="n">HF_DATA_IN</span><span class="p">,</span> <span class="n">HF_DATA_IN</span><span class="p">)),</span>
		<span class="n">PADDR_B</span> <span class="p">(</span><span class="n">data_ovrun</span><span class="p">),</span>
	<span class="cm">/*</span>
<span class="cm">	 *  Keep track we are moving data from the </span>
<span class="cm">	 *  PM0 DATA mini-script.</span>
<span class="cm">	 */</span>
	<span class="n">SCR_REG_REG</span> <span class="p">(</span><span class="n">HF_REG</span><span class="p">,</span> <span class="n">SCR_OR</span><span class="p">,</span> <span class="n">HF_IN_PM0</span><span class="p">),</span>
		<span class="mi">0</span><span class="p">,</span>
	<span class="cm">/*</span>
<span class="cm">	 *  Move the data to memory.</span>
<span class="cm">	 */</span>
	<span class="n">SCR_CHMOV_TBL</span> <span class="o">^</span> <span class="n">SCR_DATA_IN</span><span class="p">,</span>
		<span class="n">offsetof</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sym_ccb</span><span class="p">,</span> <span class="n">phys</span><span class="p">.</span><span class="n">pm0</span><span class="p">.</span><span class="n">sg</span><span class="p">),</span>
	<span class="n">SCR_JUMP</span><span class="p">,</span>
		<span class="n">PADDR_A</span> <span class="p">(</span><span class="n">pm0_data_end</span><span class="p">),</span>
<span class="p">}</span><span class="cm">/*-------------------------&lt; PM0_DATA_OUT &gt;---------------------*/</span><span class="p">,{</span>
	<span class="cm">/*</span>
<span class="cm">	 *  Actual phase is DATA OUT.</span>
<span class="cm">	 *  Check against expected direction.</span>
<span class="cm">	 */</span>
	<span class="n">SCR_JUMP</span> <span class="o">^</span> <span class="n">IFTRUE</span> <span class="p">(</span><span class="n">MASK</span> <span class="p">(</span><span class="n">HF_DATA_IN</span><span class="p">,</span> <span class="n">HF_DATA_IN</span><span class="p">)),</span>
		<span class="n">PADDR_B</span> <span class="p">(</span><span class="n">data_ovrun</span><span class="p">),</span>
	<span class="cm">/*</span>
<span class="cm">	 *  Keep track we are moving data from the </span>
<span class="cm">	 *  PM0 DATA mini-script.</span>
<span class="cm">	 */</span>
	<span class="n">SCR_REG_REG</span> <span class="p">(</span><span class="n">HF_REG</span><span class="p">,</span> <span class="n">SCR_OR</span><span class="p">,</span> <span class="n">HF_IN_PM0</span><span class="p">),</span>
		<span class="mi">0</span><span class="p">,</span>
	<span class="cm">/*</span>
<span class="cm">	 *  Move the data from memory.</span>
<span class="cm">	 */</span>
	<span class="n">SCR_CHMOV_TBL</span> <span class="o">^</span> <span class="n">SCR_DATA_OUT</span><span class="p">,</span>
		<span class="n">offsetof</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sym_ccb</span><span class="p">,</span> <span class="n">phys</span><span class="p">.</span><span class="n">pm0</span><span class="p">.</span><span class="n">sg</span><span class="p">),</span>
<span class="p">}</span><span class="cm">/*-------------------------&lt; PM0_DATA_END &gt;---------------------*/</span><span class="p">,{</span>
	<span class="cm">/*</span>
<span class="cm">	 *  Clear the flag that told we were moving  </span>
<span class="cm">	 *  data from the PM0 DATA mini-script.</span>
<span class="cm">	 */</span>
	<span class="n">SCR_REG_REG</span> <span class="p">(</span><span class="n">HF_REG</span><span class="p">,</span> <span class="n">SCR_AND</span><span class="p">,</span> <span class="p">(</span><span class="o">~</span><span class="n">HF_IN_PM0</span><span class="p">)),</span>
		<span class="mi">0</span><span class="p">,</span>
	<span class="cm">/*</span>
<span class="cm">	 *  Return to the previous DATA script which </span>
<span class="cm">	 *  is guaranteed by design (if no bug) to be </span>
<span class="cm">	 *  the main DATA script for this transfer.</span>
<span class="cm">	 */</span>
	<span class="n">SCR_LOAD_REL</span> <span class="p">(</span><span class="n">temp</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span>
		<span class="n">offsetof</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sym_ccb</span><span class="p">,</span> <span class="n">phys</span><span class="p">.</span><span class="n">pm0</span><span class="p">.</span><span class="n">ret</span><span class="p">),</span>
	<span class="n">SCR_RETURN</span><span class="p">,</span>
		<span class="mi">0</span><span class="p">,</span>
<span class="p">}</span><span class="cm">/*-------------------------&lt; PM1_DATA &gt;-------------------------*/</span><span class="p">,{</span>
	<span class="cm">/*</span>
<span class="cm">	 *  Read our host flags to SFBR, so we will be able </span>
<span class="cm">	 *  to check against the data direction we expect.</span>
<span class="cm">	 */</span>
	<span class="n">SCR_FROM_REG</span> <span class="p">(</span><span class="n">HF_REG</span><span class="p">),</span>
		<span class="mi">0</span><span class="p">,</span>
	<span class="cm">/*</span>
<span class="cm">	 *  Check against actual DATA PHASE.</span>
<span class="cm">	 */</span>
	<span class="n">SCR_JUMP</span> <span class="o">^</span> <span class="n">IFFALSE</span> <span class="p">(</span><span class="n">WHEN</span> <span class="p">(</span><span class="n">SCR_DATA_IN</span><span class="p">)),</span>
		<span class="n">PADDR_A</span> <span class="p">(</span><span class="n">pm1_data_out</span><span class="p">),</span>
	<span class="cm">/*</span>
<span class="cm">	 *  Actual phase is DATA IN.</span>
<span class="cm">	 *  Check against expected direction.</span>
<span class="cm">	 */</span>
	<span class="n">SCR_JUMP</span> <span class="o">^</span> <span class="n">IFFALSE</span> <span class="p">(</span><span class="n">MASK</span> <span class="p">(</span><span class="n">HF_DATA_IN</span><span class="p">,</span> <span class="n">HF_DATA_IN</span><span class="p">)),</span>
		<span class="n">PADDR_B</span> <span class="p">(</span><span class="n">data_ovrun</span><span class="p">),</span>
	<span class="cm">/*</span>
<span class="cm">	 *  Keep track we are moving data from the </span>
<span class="cm">	 *  PM1 DATA mini-script.</span>
<span class="cm">	 */</span>
	<span class="n">SCR_REG_REG</span> <span class="p">(</span><span class="n">HF_REG</span><span class="p">,</span> <span class="n">SCR_OR</span><span class="p">,</span> <span class="n">HF_IN_PM1</span><span class="p">),</span>
		<span class="mi">0</span><span class="p">,</span>
	<span class="cm">/*</span>
<span class="cm">	 *  Move the data to memory.</span>
<span class="cm">	 */</span>
	<span class="n">SCR_CHMOV_TBL</span> <span class="o">^</span> <span class="n">SCR_DATA_IN</span><span class="p">,</span>
		<span class="n">offsetof</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sym_ccb</span><span class="p">,</span> <span class="n">phys</span><span class="p">.</span><span class="n">pm1</span><span class="p">.</span><span class="n">sg</span><span class="p">),</span>
	<span class="n">SCR_JUMP</span><span class="p">,</span>
		<span class="n">PADDR_A</span> <span class="p">(</span><span class="n">pm1_data_end</span><span class="p">),</span>
<span class="p">}</span><span class="cm">/*-------------------------&lt; PM1_DATA_OUT &gt;---------------------*/</span><span class="p">,{</span>
	<span class="cm">/*</span>
<span class="cm">	 *  Actual phase is DATA OUT.</span>
<span class="cm">	 *  Check against expected direction.</span>
<span class="cm">	 */</span>
	<span class="n">SCR_JUMP</span> <span class="o">^</span> <span class="n">IFTRUE</span> <span class="p">(</span><span class="n">MASK</span> <span class="p">(</span><span class="n">HF_DATA_IN</span><span class="p">,</span> <span class="n">HF_DATA_IN</span><span class="p">)),</span>
		<span class="n">PADDR_B</span> <span class="p">(</span><span class="n">data_ovrun</span><span class="p">),</span>
	<span class="cm">/*</span>
<span class="cm">	 *  Keep track we are moving data from the </span>
<span class="cm">	 *  PM1 DATA mini-script.</span>
<span class="cm">	 */</span>
	<span class="n">SCR_REG_REG</span> <span class="p">(</span><span class="n">HF_REG</span><span class="p">,</span> <span class="n">SCR_OR</span><span class="p">,</span> <span class="n">HF_IN_PM1</span><span class="p">),</span>
		<span class="mi">0</span><span class="p">,</span>
	<span class="cm">/*</span>
<span class="cm">	 *  Move the data from memory.</span>
<span class="cm">	 */</span>
	<span class="n">SCR_CHMOV_TBL</span> <span class="o">^</span> <span class="n">SCR_DATA_OUT</span><span class="p">,</span>
		<span class="n">offsetof</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sym_ccb</span><span class="p">,</span> <span class="n">phys</span><span class="p">.</span><span class="n">pm1</span><span class="p">.</span><span class="n">sg</span><span class="p">),</span>
<span class="p">}</span><span class="cm">/*-------------------------&lt; PM1_DATA_END &gt;---------------------*/</span><span class="p">,{</span>
	<span class="cm">/*</span>
<span class="cm">	 *  Clear the flag that told we were moving  </span>
<span class="cm">	 *  data from the PM1 DATA mini-script.</span>
<span class="cm">	 */</span>
	<span class="n">SCR_REG_REG</span> <span class="p">(</span><span class="n">HF_REG</span><span class="p">,</span> <span class="n">SCR_AND</span><span class="p">,</span> <span class="p">(</span><span class="o">~</span><span class="n">HF_IN_PM1</span><span class="p">)),</span>
		<span class="mi">0</span><span class="p">,</span>
	<span class="cm">/*</span>
<span class="cm">	 *  Return to the previous DATA script which </span>
<span class="cm">	 *  is guaranteed by design (if no bug) to be </span>
<span class="cm">	 *  the main DATA script for this transfer.</span>
<span class="cm">	 */</span>
	<span class="n">SCR_LOAD_REL</span> <span class="p">(</span><span class="n">temp</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span>
		<span class="n">offsetof</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sym_ccb</span><span class="p">,</span> <span class="n">phys</span><span class="p">.</span><span class="n">pm1</span><span class="p">.</span><span class="n">ret</span><span class="p">),</span>
	<span class="n">SCR_RETURN</span><span class="p">,</span>
		<span class="mi">0</span><span class="p">,</span>
<span class="p">}</span><span class="cm">/*-------------------------&lt;&gt;-----------------------------------*/</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">SYM_FWB_SCR</span> <span class="n">SYM_FWB_SCR</span> <span class="o">=</span> <span class="p">{</span>
<span class="cm">/*--------------------------&lt; START64 &gt;--------------------------*/</span> <span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 *  SCRIPT entry point for the 895A, 896 and 1010.</span>
<span class="cm">	 *  For now, there is no specific stuff for those </span>
<span class="cm">	 *  chips at this point, but this may come.</span>
<span class="cm">	 */</span>
	<span class="n">SCR_JUMP</span><span class="p">,</span>
		<span class="n">PADDR_A</span> <span class="p">(</span><span class="n">init</span><span class="p">),</span>
<span class="p">}</span><span class="cm">/*-------------------------&lt; NO_DATA &gt;--------------------------*/</span><span class="p">,{</span>
	<span class="n">SCR_JUMP</span><span class="p">,</span>
		<span class="n">PADDR_B</span> <span class="p">(</span><span class="n">data_ovrun</span><span class="p">),</span>
<span class="p">}</span><span class="cm">/*-------------------------&lt; SEL_FOR_ABORT &gt;--------------------*/</span><span class="p">,{</span>
	<span class="cm">/*</span>
<span class="cm">	 *  We are jumped here by the C code, if we have </span>
<span class="cm">	 *  some target to reset or some disconnected </span>
<span class="cm">	 *  job to abort. Since error recovery is a serious </span>
<span class="cm">	 *  busyness, we will really reset the SCSI BUS, if </span>
<span class="cm">	 *  case of a SCSI interrupt occurring in this path.</span>
<span class="cm">	 */</span>
<span class="cp">#ifdef SYM_CONF_TARGET_ROLE_SUPPORT</span>
	<span class="cm">/*</span>
<span class="cm">	 *  Set initiator mode.</span>
<span class="cm">	 */</span>
	<span class="n">SCR_CLR</span> <span class="p">(</span><span class="n">SCR_TRG</span><span class="p">),</span>
		<span class="mi">0</span><span class="p">,</span>
<span class="cp">#endif</span>
	<span class="cm">/*</span>
<span class="cm">	 *      And try to select this target.</span>
<span class="cm">	 */</span>
	<span class="n">SCR_SEL_TBL_ATN</span> <span class="o">^</span> <span class="n">offsetof</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sym_hcb</span><span class="p">,</span> <span class="n">abrt_sel</span><span class="p">),</span>
		<span class="n">PADDR_A</span> <span class="p">(</span><span class="n">reselect</span><span class="p">),</span>
	<span class="cm">/*</span>
<span class="cm">	 *  Wait for the selection to complete or </span>
<span class="cm">	 *  the selection to time out.</span>
<span class="cm">	 */</span>
	<span class="n">SCR_JUMPR</span> <span class="o">^</span> <span class="n">IFFALSE</span> <span class="p">(</span><span class="n">WHEN</span> <span class="p">(</span><span class="n">SCR_MSG_OUT</span><span class="p">)),</span>
		<span class="o">-</span><span class="mi">8</span><span class="p">,</span>
	<span class="cm">/*</span>
<span class="cm">	 *  Call the C code.</span>
<span class="cm">	 */</span>
	<span class="n">SCR_INT</span><span class="p">,</span>
		<span class="n">SIR_TARGET_SELECTED</span><span class="p">,</span>
	<span class="cm">/*</span>
<span class="cm">	 *  The C code should let us continue here. </span>
<span class="cm">	 *  Send the &#39;kiss of death&#39; message.</span>
<span class="cm">	 *  We expect an immediate disconnect once </span>
<span class="cm">	 *  the target has eaten the message.</span>
<span class="cm">	 */</span>
	<span class="n">SCR_REG_REG</span> <span class="p">(</span><span class="n">scntl2</span><span class="p">,</span> <span class="n">SCR_AND</span><span class="p">,</span> <span class="mh">0x7f</span><span class="p">),</span>
		<span class="mi">0</span><span class="p">,</span>
	<span class="n">SCR_MOVE_TBL</span> <span class="o">^</span> <span class="n">SCR_MSG_OUT</span><span class="p">,</span>
		<span class="n">offsetof</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sym_hcb</span><span class="p">,</span> <span class="n">abrt_tbl</span><span class="p">),</span>
	<span class="n">SCR_CLR</span> <span class="p">(</span><span class="n">SCR_ACK</span><span class="o">|</span><span class="n">SCR_ATN</span><span class="p">),</span>
		<span class="mi">0</span><span class="p">,</span>
	<span class="n">SCR_WAIT_DISC</span><span class="p">,</span>
		<span class="mi">0</span><span class="p">,</span>
	<span class="cm">/*</span>
<span class="cm">	 *  Tell the C code that we are done.</span>
<span class="cm">	 */</span>
	<span class="n">SCR_INT</span><span class="p">,</span>
		<span class="n">SIR_ABORT_SENT</span><span class="p">,</span>
<span class="p">}</span><span class="cm">/*-------------------------&lt; SEL_FOR_ABORT_1 &gt;------------------*/</span><span class="p">,{</span>
	<span class="cm">/*</span>
<span class="cm">	 *  Jump at scheduler.</span>
<span class="cm">	 */</span>
	<span class="n">SCR_JUMP</span><span class="p">,</span>
		<span class="n">PADDR_A</span> <span class="p">(</span><span class="n">start</span><span class="p">),</span>
<span class="p">}</span><span class="cm">/*-------------------------&lt; MSG_IN_ETC &gt;-----------------------*/</span><span class="p">,{</span>
	<span class="cm">/*</span>
<span class="cm">	 *  If it is an EXTENDED (variable size message)</span>
<span class="cm">	 *  Handle it.</span>
<span class="cm">	 */</span>
	<span class="n">SCR_JUMP</span> <span class="o">^</span> <span class="n">IFTRUE</span> <span class="p">(</span><span class="n">DATA</span> <span class="p">(</span><span class="n">M_EXTENDED</span><span class="p">)),</span>
		<span class="n">PADDR_B</span> <span class="p">(</span><span class="n">msg_extended</span><span class="p">),</span>
	<span class="cm">/*</span>
<span class="cm">	 *  Let the C code handle any other </span>
<span class="cm">	 *  1 byte message.</span>
<span class="cm">	 */</span>
	<span class="n">SCR_JUMP</span> <span class="o">^</span> <span class="n">IFTRUE</span> <span class="p">(</span><span class="n">MASK</span> <span class="p">(</span><span class="mh">0x00</span><span class="p">,</span> <span class="mh">0xf0</span><span class="p">)),</span>
		<span class="n">PADDR_B</span> <span class="p">(</span><span class="n">msg_received</span><span class="p">),</span>
	<span class="n">SCR_JUMP</span> <span class="o">^</span> <span class="n">IFTRUE</span> <span class="p">(</span><span class="n">MASK</span> <span class="p">(</span><span class="mh">0x10</span><span class="p">,</span> <span class="mh">0xf0</span><span class="p">)),</span>
		<span class="n">PADDR_B</span> <span class="p">(</span><span class="n">msg_received</span><span class="p">),</span>
	<span class="cm">/*</span>
<span class="cm">	 *  We donnot handle 2 bytes messages from SCRIPTS.</span>
<span class="cm">	 *  So, let the C code deal with these ones too.</span>
<span class="cm">	 */</span>
	<span class="n">SCR_JUMP</span> <span class="o">^</span> <span class="n">IFFALSE</span> <span class="p">(</span><span class="n">MASK</span> <span class="p">(</span><span class="mh">0x20</span><span class="p">,</span> <span class="mh">0xf0</span><span class="p">)),</span>
		<span class="n">PADDR_B</span> <span class="p">(</span><span class="n">msg_weird_seen</span><span class="p">),</span>
	<span class="n">SCR_CLR</span> <span class="p">(</span><span class="n">SCR_ACK</span><span class="p">),</span>
		<span class="mi">0</span><span class="p">,</span>
	<span class="n">SCR_MOVE_ABS</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">^</span> <span class="n">SCR_MSG_IN</span><span class="p">,</span>
		<span class="n">HADDR_1</span> <span class="p">(</span><span class="n">msgin</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span>
<span class="p">}</span><span class="cm">/*-------------------------&lt; MSG_RECEIVED &gt;---------------------*/</span><span class="p">,{</span>
	<span class="n">SCR_LOAD_REL</span> <span class="p">(</span><span class="n">scratcha</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span>	<span class="cm">/* DUMMY READ */</span>
		<span class="mi">0</span><span class="p">,</span>
	<span class="n">SCR_INT</span><span class="p">,</span>
		<span class="n">SIR_MSG_RECEIVED</span><span class="p">,</span>
<span class="p">}</span><span class="cm">/*-------------------------&lt; MSG_WEIRD_SEEN &gt;-------------------*/</span><span class="p">,{</span>
	<span class="n">SCR_LOAD_REL</span> <span class="p">(</span><span class="n">scratcha</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span>	<span class="cm">/* DUMMY READ */</span>
		<span class="mi">0</span><span class="p">,</span>
	<span class="n">SCR_INT</span><span class="p">,</span>
		<span class="n">SIR_MSG_WEIRD</span><span class="p">,</span>
<span class="p">}</span><span class="cm">/*-------------------------&lt; MSG_EXTENDED &gt;---------------------*/</span><span class="p">,{</span>
	<span class="cm">/*</span>
<span class="cm">	 *  Clear ACK and get the next byte </span>
<span class="cm">	 *  assumed to be the message length.</span>
<span class="cm">	 */</span>
	<span class="n">SCR_CLR</span> <span class="p">(</span><span class="n">SCR_ACK</span><span class="p">),</span>
		<span class="mi">0</span><span class="p">,</span>
	<span class="n">SCR_MOVE_ABS</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">^</span> <span class="n">SCR_MSG_IN</span><span class="p">,</span>
		<span class="n">HADDR_1</span> <span class="p">(</span><span class="n">msgin</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span>
	<span class="cm">/*</span>
<span class="cm">	 *  Try to catch some unlikely situations as 0 length </span>
<span class="cm">	 *  or too large the length.</span>
<span class="cm">	 */</span>
	<span class="n">SCR_JUMP</span> <span class="o">^</span> <span class="n">IFTRUE</span> <span class="p">(</span><span class="n">DATA</span> <span class="p">(</span><span class="mi">0</span><span class="p">)),</span>
		<span class="n">PADDR_B</span> <span class="p">(</span><span class="n">msg_weird_seen</span><span class="p">),</span>
	<span class="n">SCR_TO_REG</span> <span class="p">(</span><span class="n">scratcha</span><span class="p">),</span>
		<span class="mi">0</span><span class="p">,</span>
	<span class="n">SCR_REG_REG</span> <span class="p">(</span><span class="n">sfbr</span><span class="p">,</span> <span class="n">SCR_ADD</span><span class="p">,</span> <span class="p">(</span><span class="mi">256</span><span class="o">-</span><span class="mi">8</span><span class="p">)),</span>
		<span class="mi">0</span><span class="p">,</span>
	<span class="n">SCR_JUMP</span> <span class="o">^</span> <span class="n">IFTRUE</span> <span class="p">(</span><span class="n">CARRYSET</span><span class="p">),</span>
		<span class="n">PADDR_B</span> <span class="p">(</span><span class="n">msg_weird_seen</span><span class="p">),</span>
	<span class="cm">/*</span>
<span class="cm">	 *  We donnot handle extended messages from SCRIPTS.</span>
<span class="cm">	 *  Read the amount of data corresponding to the </span>
<span class="cm">	 *  message length and call the C code.</span>
<span class="cm">	 */</span>
	<span class="n">SCR_STORE_REL</span> <span class="p">(</span><span class="n">scratcha</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
		<span class="n">offsetof</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sym_dsb</span><span class="p">,</span> <span class="n">smsg_ext</span><span class="p">.</span><span class="n">size</span><span class="p">),</span>
	<span class="n">SCR_CLR</span> <span class="p">(</span><span class="n">SCR_ACK</span><span class="p">),</span>
		<span class="mi">0</span><span class="p">,</span>
	<span class="n">SCR_MOVE_TBL</span> <span class="o">^</span> <span class="n">SCR_MSG_IN</span><span class="p">,</span>
		<span class="n">offsetof</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sym_dsb</span><span class="p">,</span> <span class="n">smsg_ext</span><span class="p">),</span>
	<span class="n">SCR_JUMP</span><span class="p">,</span>
		<span class="n">PADDR_B</span> <span class="p">(</span><span class="n">msg_received</span><span class="p">),</span>
<span class="p">}</span><span class="cm">/*-------------------------&lt; MSG_BAD &gt;--------------------------*/</span><span class="p">,{</span>
	<span class="cm">/*</span>
<span class="cm">	 *  unimplemented message - reject it.</span>
<span class="cm">	 */</span>
	<span class="n">SCR_INT</span><span class="p">,</span>
		<span class="n">SIR_REJECT_TO_SEND</span><span class="p">,</span>
	<span class="n">SCR_SET</span> <span class="p">(</span><span class="n">SCR_ATN</span><span class="p">),</span>
		<span class="mi">0</span><span class="p">,</span>
	<span class="n">SCR_JUMP</span><span class="p">,</span>
		<span class="n">PADDR_A</span> <span class="p">(</span><span class="n">clrack</span><span class="p">),</span>
<span class="p">}</span><span class="cm">/*-------------------------&lt; MSG_WEIRD &gt;------------------------*/</span><span class="p">,{</span>
	<span class="cm">/*</span>
<span class="cm">	 *  weird message received</span>
<span class="cm">	 *  ignore all MSG IN phases and reject it.</span>
<span class="cm">	 */</span>
	<span class="n">SCR_INT</span><span class="p">,</span>
		<span class="n">SIR_REJECT_TO_SEND</span><span class="p">,</span>
	<span class="n">SCR_SET</span> <span class="p">(</span><span class="n">SCR_ATN</span><span class="p">),</span>
		<span class="mi">0</span><span class="p">,</span>
<span class="p">}</span><span class="cm">/*-------------------------&lt; MSG_WEIRD1 &gt;-----------------------*/</span><span class="p">,{</span>
	<span class="n">SCR_CLR</span> <span class="p">(</span><span class="n">SCR_ACK</span><span class="p">),</span>
		<span class="mi">0</span><span class="p">,</span>
	<span class="n">SCR_JUMP</span> <span class="o">^</span> <span class="n">IFFALSE</span> <span class="p">(</span><span class="n">WHEN</span> <span class="p">(</span><span class="n">SCR_MSG_IN</span><span class="p">)),</span>
		<span class="n">PADDR_A</span> <span class="p">(</span><span class="n">dispatch</span><span class="p">),</span>
	<span class="n">SCR_MOVE_ABS</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">^</span> <span class="n">SCR_MSG_IN</span><span class="p">,</span>
		<span class="n">HADDR_1</span> <span class="p">(</span><span class="n">scratch</span><span class="p">),</span>
	<span class="n">SCR_JUMP</span><span class="p">,</span>
		<span class="n">PADDR_B</span> <span class="p">(</span><span class="n">msg_weird1</span><span class="p">),</span>
<span class="p">}</span><span class="cm">/*-------------------------&lt; WDTR_RESP &gt;------------------------*/</span><span class="p">,{</span>
	<span class="cm">/*</span>
<span class="cm">	 *  let the target fetch our answer.</span>
<span class="cm">	 */</span>
	<span class="n">SCR_SET</span> <span class="p">(</span><span class="n">SCR_ATN</span><span class="p">),</span>
		<span class="mi">0</span><span class="p">,</span>
	<span class="n">SCR_CLR</span> <span class="p">(</span><span class="n">SCR_ACK</span><span class="p">),</span>
		<span class="mi">0</span><span class="p">,</span>
	<span class="n">SCR_JUMP</span> <span class="o">^</span> <span class="n">IFFALSE</span> <span class="p">(</span><span class="n">WHEN</span> <span class="p">(</span><span class="n">SCR_MSG_OUT</span><span class="p">)),</span>
		<span class="n">PADDR_B</span> <span class="p">(</span><span class="n">nego_bad_phase</span><span class="p">),</span>
<span class="p">}</span><span class="cm">/*-------------------------&lt; SEND_WDTR &gt;------------------------*/</span><span class="p">,{</span>
	<span class="cm">/*</span>
<span class="cm">	 *  Send the M_X_WIDE_REQ</span>
<span class="cm">	 */</span>
	<span class="n">SCR_MOVE_ABS</span> <span class="p">(</span><span class="mi">4</span><span class="p">)</span> <span class="o">^</span> <span class="n">SCR_MSG_OUT</span><span class="p">,</span>
		<span class="n">HADDR_1</span> <span class="p">(</span><span class="n">msgout</span><span class="p">),</span>
	<span class="n">SCR_JUMP</span><span class="p">,</span>
		<span class="n">PADDR_B</span> <span class="p">(</span><span class="n">msg_out_done</span><span class="p">),</span>
<span class="p">}</span><span class="cm">/*-------------------------&lt; SDTR_RESP &gt;------------------------*/</span><span class="p">,{</span>
	<span class="cm">/*</span>
<span class="cm">	 *  let the target fetch our answer.</span>
<span class="cm">	 */</span>
	<span class="n">SCR_SET</span> <span class="p">(</span><span class="n">SCR_ATN</span><span class="p">),</span>
		<span class="mi">0</span><span class="p">,</span>
	<span class="n">SCR_CLR</span> <span class="p">(</span><span class="n">SCR_ACK</span><span class="p">),</span>
		<span class="mi">0</span><span class="p">,</span>
	<span class="n">SCR_JUMP</span> <span class="o">^</span> <span class="n">IFFALSE</span> <span class="p">(</span><span class="n">WHEN</span> <span class="p">(</span><span class="n">SCR_MSG_OUT</span><span class="p">)),</span>
		<span class="n">PADDR_B</span> <span class="p">(</span><span class="n">nego_bad_phase</span><span class="p">),</span>
<span class="p">}</span><span class="cm">/*-------------------------&lt; SEND_SDTR &gt;------------------------*/</span><span class="p">,{</span>
	<span class="cm">/*</span>
<span class="cm">	 *  Send the M_X_SYNC_REQ</span>
<span class="cm">	 */</span>
	<span class="n">SCR_MOVE_ABS</span> <span class="p">(</span><span class="mi">5</span><span class="p">)</span> <span class="o">^</span> <span class="n">SCR_MSG_OUT</span><span class="p">,</span>
		<span class="n">HADDR_1</span> <span class="p">(</span><span class="n">msgout</span><span class="p">),</span>
	<span class="n">SCR_JUMP</span><span class="p">,</span>
		<span class="n">PADDR_B</span> <span class="p">(</span><span class="n">msg_out_done</span><span class="p">),</span>
<span class="p">}</span><span class="cm">/*-------------------------&lt; PPR_RESP &gt;-------------------------*/</span><span class="p">,{</span>
	<span class="cm">/*</span>
<span class="cm">	 *  let the target fetch our answer.</span>
<span class="cm">	 */</span>
	<span class="n">SCR_SET</span> <span class="p">(</span><span class="n">SCR_ATN</span><span class="p">),</span>
		<span class="mi">0</span><span class="p">,</span>
	<span class="n">SCR_CLR</span> <span class="p">(</span><span class="n">SCR_ACK</span><span class="p">),</span>
		<span class="mi">0</span><span class="p">,</span>
	<span class="n">SCR_JUMP</span> <span class="o">^</span> <span class="n">IFFALSE</span> <span class="p">(</span><span class="n">WHEN</span> <span class="p">(</span><span class="n">SCR_MSG_OUT</span><span class="p">)),</span>
		<span class="n">PADDR_B</span> <span class="p">(</span><span class="n">nego_bad_phase</span><span class="p">),</span>
<span class="p">}</span><span class="cm">/*-------------------------&lt; SEND_PPR &gt;-------------------------*/</span><span class="p">,{</span>
	<span class="cm">/*</span>
<span class="cm">	 *  Send the M_X_PPR_REQ</span>
<span class="cm">	 */</span>
	<span class="n">SCR_MOVE_ABS</span> <span class="p">(</span><span class="mi">8</span><span class="p">)</span> <span class="o">^</span> <span class="n">SCR_MSG_OUT</span><span class="p">,</span>
		<span class="n">HADDR_1</span> <span class="p">(</span><span class="n">msgout</span><span class="p">),</span>
	<span class="n">SCR_JUMP</span><span class="p">,</span>
		<span class="n">PADDR_B</span> <span class="p">(</span><span class="n">msg_out_done</span><span class="p">),</span>
<span class="p">}</span><span class="cm">/*-------------------------&lt; NEGO_BAD_PHASE &gt;-------------------*/</span><span class="p">,{</span>
	<span class="n">SCR_INT</span><span class="p">,</span>
		<span class="n">SIR_NEGO_PROTO</span><span class="p">,</span>
	<span class="n">SCR_JUMP</span><span class="p">,</span>
		<span class="n">PADDR_A</span> <span class="p">(</span><span class="n">dispatch</span><span class="p">),</span>
<span class="p">}</span><span class="cm">/*-------------------------&lt; MSG_OUT &gt;--------------------------*/</span><span class="p">,{</span>
	<span class="cm">/*</span>
<span class="cm">	 *  The target requests a message.</span>
<span class="cm">	 *  We donnot send messages that may </span>
<span class="cm">	 *  require the device to go to bus free.</span>
<span class="cm">	 */</span>
	<span class="n">SCR_MOVE_ABS</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">^</span> <span class="n">SCR_MSG_OUT</span><span class="p">,</span>
		<span class="n">HADDR_1</span> <span class="p">(</span><span class="n">msgout</span><span class="p">),</span>
	<span class="cm">/*</span>
<span class="cm">	 *  ... wait for the next phase</span>
<span class="cm">	 *  if it&#39;s a message out, send it again, ...</span>
<span class="cm">	 */</span>
	<span class="n">SCR_JUMP</span> <span class="o">^</span> <span class="n">IFTRUE</span> <span class="p">(</span><span class="n">WHEN</span> <span class="p">(</span><span class="n">SCR_MSG_OUT</span><span class="p">)),</span>
		<span class="n">PADDR_B</span> <span class="p">(</span><span class="n">msg_out</span><span class="p">),</span>
<span class="p">}</span><span class="cm">/*-------------------------&lt; MSG_OUT_DONE &gt;---------------------*/</span><span class="p">,{</span>
	<span class="cm">/*</span>
<span class="cm">	 *  Let the C code be aware of the </span>
<span class="cm">	 *  sent message and clear the message.</span>
<span class="cm">	 */</span>
	<span class="n">SCR_INT</span><span class="p">,</span>
		<span class="n">SIR_MSG_OUT_DONE</span><span class="p">,</span>
	<span class="cm">/*</span>
<span class="cm">	 *  ... and process the next phase</span>
<span class="cm">	 */</span>
	<span class="n">SCR_JUMP</span><span class="p">,</span>
		<span class="n">PADDR_A</span> <span class="p">(</span><span class="n">dispatch</span><span class="p">),</span>
<span class="p">}</span><span class="cm">/*-------------------------&lt; DATA_OVRUN &gt;-----------------------*/</span><span class="p">,{</span>
	<span class="cm">/*</span>
<span class="cm">	 *  Use scratcha to count the extra bytes.</span>
<span class="cm">	 */</span>
	<span class="n">SCR_LOAD_ABS</span> <span class="p">(</span><span class="n">scratcha</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span>
		<span class="n">PADDR_B</span> <span class="p">(</span><span class="n">zero</span><span class="p">),</span>
<span class="p">}</span><span class="cm">/*-------------------------&lt; DATA_OVRUN1 &gt;----------------------*/</span><span class="p">,{</span>
	<span class="cm">/*</span>
<span class="cm">	 *  The target may want to transfer too much data.</span>
<span class="cm">	 *</span>
<span class="cm">	 *  If phase is DATA OUT write 1 byte and count it.</span>
<span class="cm">	 */</span>
	<span class="n">SCR_JUMPR</span> <span class="o">^</span> <span class="n">IFFALSE</span> <span class="p">(</span><span class="n">WHEN</span> <span class="p">(</span><span class="n">SCR_DATA_OUT</span><span class="p">)),</span>
		<span class="mi">16</span><span class="p">,</span>
	<span class="n">SCR_CHMOV_ABS</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">^</span> <span class="n">SCR_DATA_OUT</span><span class="p">,</span>
		<span class="n">HADDR_1</span> <span class="p">(</span><span class="n">scratch</span><span class="p">),</span>
	<span class="n">SCR_JUMP</span><span class="p">,</span>
		<span class="n">PADDR_B</span> <span class="p">(</span><span class="n">data_ovrun2</span><span class="p">),</span>
	<span class="cm">/*</span>
<span class="cm">	 *  If WSR is set, clear this condition, and </span>
<span class="cm">	 *  count this byte.</span>
<span class="cm">	 */</span>
	<span class="n">SCR_FROM_REG</span> <span class="p">(</span><span class="n">scntl2</span><span class="p">),</span>
		<span class="mi">0</span><span class="p">,</span>
	<span class="n">SCR_JUMPR</span> <span class="o">^</span> <span class="n">IFFALSE</span> <span class="p">(</span><span class="n">MASK</span> <span class="p">(</span><span class="n">WSR</span><span class="p">,</span> <span class="n">WSR</span><span class="p">)),</span>
		<span class="mi">16</span><span class="p">,</span>
	<span class="n">SCR_REG_REG</span> <span class="p">(</span><span class="n">scntl2</span><span class="p">,</span> <span class="n">SCR_OR</span><span class="p">,</span> <span class="n">WSR</span><span class="p">),</span>
		<span class="mi">0</span><span class="p">,</span>
	<span class="n">SCR_JUMP</span><span class="p">,</span>
		<span class="n">PADDR_B</span> <span class="p">(</span><span class="n">data_ovrun2</span><span class="p">),</span>
	<span class="cm">/*</span>
<span class="cm">	 *  Finally check against DATA IN phase.</span>
<span class="cm">	 *  Signal data overrun to the C code </span>
<span class="cm">	 *  and jump to dispatcher if not so.</span>
<span class="cm">	 *  Read 1 byte otherwise and count it.</span>
<span class="cm">	 */</span>
	<span class="n">SCR_JUMPR</span> <span class="o">^</span> <span class="n">IFTRUE</span> <span class="p">(</span><span class="n">WHEN</span> <span class="p">(</span><span class="n">SCR_DATA_IN</span><span class="p">)),</span>
		<span class="mi">16</span><span class="p">,</span>
	<span class="n">SCR_INT</span><span class="p">,</span>
		<span class="n">SIR_DATA_OVERRUN</span><span class="p">,</span>
	<span class="n">SCR_JUMP</span><span class="p">,</span>
		<span class="n">PADDR_A</span> <span class="p">(</span><span class="n">dispatch</span><span class="p">),</span>
	<span class="n">SCR_CHMOV_ABS</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">^</span> <span class="n">SCR_DATA_IN</span><span class="p">,</span>
		<span class="n">HADDR_1</span> <span class="p">(</span><span class="n">scratch</span><span class="p">),</span>
<span class="p">}</span><span class="cm">/*-------------------------&lt; DATA_OVRUN2 &gt;----------------------*/</span><span class="p">,{</span>
	<span class="cm">/*</span>
<span class="cm">	 *  Count this byte.</span>
<span class="cm">	 *  This will allow to return a negative </span>
<span class="cm">	 *  residual to user.</span>
<span class="cm">	 */</span>
	<span class="n">SCR_REG_REG</span> <span class="p">(</span><span class="n">scratcha</span><span class="p">,</span>  <span class="n">SCR_ADD</span><span class="p">,</span>  <span class="mh">0x01</span><span class="p">),</span>
		<span class="mi">0</span><span class="p">,</span>
	<span class="n">SCR_REG_REG</span> <span class="p">(</span><span class="n">scratcha1</span><span class="p">,</span> <span class="n">SCR_ADDC</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
		<span class="mi">0</span><span class="p">,</span>
	<span class="n">SCR_REG_REG</span> <span class="p">(</span><span class="n">scratcha2</span><span class="p">,</span> <span class="n">SCR_ADDC</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
		<span class="mi">0</span><span class="p">,</span>
	<span class="cm">/*</span>
<span class="cm">	 *  .. and repeat as required.</span>
<span class="cm">	 */</span>
	<span class="n">SCR_JUMP</span><span class="p">,</span>
		<span class="n">PADDR_B</span> <span class="p">(</span><span class="n">data_ovrun1</span><span class="p">),</span>
<span class="p">}</span><span class="cm">/*-------------------------&lt; ABORT_RESEL &gt;----------------------*/</span><span class="p">,{</span>
	<span class="n">SCR_SET</span> <span class="p">(</span><span class="n">SCR_ATN</span><span class="p">),</span>
		<span class="mi">0</span><span class="p">,</span>
	<span class="n">SCR_CLR</span> <span class="p">(</span><span class="n">SCR_ACK</span><span class="p">),</span>
		<span class="mi">0</span><span class="p">,</span>
	<span class="cm">/*</span>
<span class="cm">	 *  send the abort/abortag/reset message</span>
<span class="cm">	 *  we expect an immediate disconnect</span>
<span class="cm">	 */</span>
	<span class="n">SCR_REG_REG</span> <span class="p">(</span><span class="n">scntl2</span><span class="p">,</span> <span class="n">SCR_AND</span><span class="p">,</span> <span class="mh">0x7f</span><span class="p">),</span>
		<span class="mi">0</span><span class="p">,</span>
	<span class="n">SCR_MOVE_ABS</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">^</span> <span class="n">SCR_MSG_OUT</span><span class="p">,</span>
		<span class="n">HADDR_1</span> <span class="p">(</span><span class="n">msgout</span><span class="p">),</span>
	<span class="n">SCR_CLR</span> <span class="p">(</span><span class="n">SCR_ACK</span><span class="o">|</span><span class="n">SCR_ATN</span><span class="p">),</span>
		<span class="mi">0</span><span class="p">,</span>
	<span class="n">SCR_WAIT_DISC</span><span class="p">,</span>
		<span class="mi">0</span><span class="p">,</span>
	<span class="n">SCR_INT</span><span class="p">,</span>
		<span class="n">SIR_RESEL_ABORTED</span><span class="p">,</span>
	<span class="n">SCR_JUMP</span><span class="p">,</span>
		<span class="n">PADDR_A</span> <span class="p">(</span><span class="n">start</span><span class="p">),</span>
<span class="p">}</span><span class="cm">/*-------------------------&lt; RESEND_IDENT &gt;---------------------*/</span><span class="p">,{</span>
	<span class="cm">/*</span>
<span class="cm">	 *  The target stays in MSG OUT phase after having acked </span>
<span class="cm">	 *  Identify [+ Tag [+ Extended message ]]. Targets shall</span>
<span class="cm">	 *  behave this way on parity error.</span>
<span class="cm">	 *  We must send it again all the messages.</span>
<span class="cm">	 */</span>
	<span class="n">SCR_SET</span> <span class="p">(</span><span class="n">SCR_ATN</span><span class="p">),</span> <span class="cm">/* Shall be asserted 2 deskew delays before the  */</span>
		<span class="mi">0</span><span class="p">,</span>         <span class="cm">/* 1rst ACK = 90 ns. Hope the chip isn&#39;t too fast */</span>
	<span class="n">SCR_JUMP</span><span class="p">,</span>
		<span class="n">PADDR_A</span> <span class="p">(</span><span class="n">send_ident</span><span class="p">),</span>
<span class="p">}</span><span class="cm">/*-------------------------&lt; IDENT_BREAK &gt;----------------------*/</span><span class="p">,{</span>
	<span class="n">SCR_CLR</span> <span class="p">(</span><span class="n">SCR_ATN</span><span class="p">),</span>
		<span class="mi">0</span><span class="p">,</span>
	<span class="n">SCR_JUMP</span><span class="p">,</span>
		<span class="n">PADDR_A</span> <span class="p">(</span><span class="n">select2</span><span class="p">),</span>
<span class="p">}</span><span class="cm">/*-------------------------&lt; IDENT_BREAK_ATN &gt;------------------*/</span><span class="p">,{</span>
	<span class="n">SCR_SET</span> <span class="p">(</span><span class="n">SCR_ATN</span><span class="p">),</span>
		<span class="mi">0</span><span class="p">,</span>
	<span class="n">SCR_JUMP</span><span class="p">,</span>
		<span class="n">PADDR_A</span> <span class="p">(</span><span class="n">select2</span><span class="p">),</span>
<span class="p">}</span><span class="cm">/*-------------------------&lt; SDATA_IN &gt;-------------------------*/</span><span class="p">,{</span>
	<span class="n">SCR_CHMOV_TBL</span> <span class="o">^</span> <span class="n">SCR_DATA_IN</span><span class="p">,</span>
		<span class="n">offsetof</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sym_dsb</span><span class="p">,</span> <span class="n">sense</span><span class="p">),</span>
	<span class="n">SCR_CALL</span><span class="p">,</span>
		<span class="n">PADDR_A</span> <span class="p">(</span><span class="n">datai_done</span><span class="p">),</span>
	<span class="n">SCR_JUMP</span><span class="p">,</span>
		<span class="n">PADDR_B</span> <span class="p">(</span><span class="n">data_ovrun</span><span class="p">),</span>
<span class="p">}</span><span class="cm">/*-------------------------&lt; RESEL_BAD_LUN &gt;--------------------*/</span><span class="p">,{</span>
	<span class="cm">/*</span>
<span class="cm">	 *  Message is an IDENTIFY, but lun is unknown.</span>
<span class="cm">	 *  Signal problem to C code for logging the event.</span>
<span class="cm">	 *  Send a M_ABORT to clear all pending tasks.</span>
<span class="cm">	 */</span>
	<span class="n">SCR_INT</span><span class="p">,</span>
		<span class="n">SIR_RESEL_BAD_LUN</span><span class="p">,</span>
	<span class="n">SCR_JUMP</span><span class="p">,</span>
		<span class="n">PADDR_B</span> <span class="p">(</span><span class="n">abort_resel</span><span class="p">),</span>
<span class="p">}</span><span class="cm">/*-------------------------&lt; BAD_I_T_L &gt;------------------------*/</span><span class="p">,{</span>
	<span class="cm">/*</span>
<span class="cm">	 *  We donnot have a task for that I_T_L.</span>
<span class="cm">	 *  Signal problem to C code for logging the event.</span>
<span class="cm">	 *  Send a M_ABORT message.</span>
<span class="cm">	 */</span>
	<span class="n">SCR_INT</span><span class="p">,</span>
		<span class="n">SIR_RESEL_BAD_I_T_L</span><span class="p">,</span>
	<span class="n">SCR_JUMP</span><span class="p">,</span>
		<span class="n">PADDR_B</span> <span class="p">(</span><span class="n">abort_resel</span><span class="p">),</span>
<span class="p">}</span><span class="cm">/*-------------------------&lt; BAD_I_T_L_Q &gt;----------------------*/</span><span class="p">,{</span>
	<span class="cm">/*</span>
<span class="cm">	 *  We donnot have a task that matches the tag.</span>
<span class="cm">	 *  Signal problem to C code for logging the event.</span>
<span class="cm">	 *  Send a M_ABORTTAG message.</span>
<span class="cm">	 */</span>
	<span class="n">SCR_INT</span><span class="p">,</span>
		<span class="n">SIR_RESEL_BAD_I_T_L_Q</span><span class="p">,</span>
	<span class="n">SCR_JUMP</span><span class="p">,</span>
		<span class="n">PADDR_B</span> <span class="p">(</span><span class="n">abort_resel</span><span class="p">),</span>
<span class="p">}</span><span class="cm">/*-------------------------&lt; BAD_STATUS &gt;-----------------------*/</span><span class="p">,{</span>
	<span class="cm">/*</span>
<span class="cm">	 *  Anything different from INTERMEDIATE </span>
<span class="cm">	 *  CONDITION MET should be a bad SCSI status, </span>
<span class="cm">	 *  given that GOOD status has already been tested.</span>
<span class="cm">	 *  Call the C code.</span>
<span class="cm">	 */</span>
	<span class="n">SCR_LOAD_ABS</span> <span class="p">(</span><span class="n">scratcha</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span>
		<span class="n">PADDR_B</span> <span class="p">(</span><span class="n">startpos</span><span class="p">),</span>
	<span class="n">SCR_INT</span> <span class="o">^</span> <span class="n">IFFALSE</span> <span class="p">(</span><span class="n">DATA</span> <span class="p">(</span><span class="n">S_COND_MET</span><span class="p">)),</span>
		<span class="n">SIR_BAD_SCSI_STATUS</span><span class="p">,</span>
	<span class="n">SCR_RETURN</span><span class="p">,</span>
		<span class="mi">0</span><span class="p">,</span>
<span class="p">}</span><span class="cm">/*-------------------------&lt; PM_HANDLE &gt;------------------------*/</span><span class="p">,{</span>
	<span class="cm">/*</span>
<span class="cm">	 *  Phase mismatch handling.</span>
<span class="cm">	 *</span>
<span class="cm">	 *  Since we have to deal with 2 SCSI data pointers  </span>
<span class="cm">	 *  (current and saved), we need at least 2 contexts.</span>
<span class="cm">	 *  Each context (pm0 and pm1) has a saved area, a </span>
<span class="cm">	 *  SAVE mini-script and a DATA phase mini-script.</span>
<span class="cm">	 */</span>
	<span class="cm">/*</span>
<span class="cm">	 *  Get the PM handling flags.</span>
<span class="cm">	 */</span>
	<span class="n">SCR_FROM_REG</span> <span class="p">(</span><span class="n">HF_REG</span><span class="p">),</span>
		<span class="mi">0</span><span class="p">,</span>
	<span class="cm">/*</span>
<span class="cm">	 *  If no flags (1rst PM for example), avoid </span>
<span class="cm">	 *  all the below heavy flags testing.</span>
<span class="cm">	 *  This makes the normal case a bit faster.</span>
<span class="cm">	 */</span>
	<span class="n">SCR_JUMP</span> <span class="o">^</span> <span class="n">IFTRUE</span> <span class="p">(</span><span class="n">MASK</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="p">(</span><span class="n">HF_IN_PM0</span> <span class="o">|</span> <span class="n">HF_IN_PM1</span> <span class="o">|</span> <span class="n">HF_DP_SAVED</span><span class="p">))),</span>
		<span class="n">PADDR_B</span> <span class="p">(</span><span class="n">pm_handle1</span><span class="p">),</span>
	<span class="cm">/*</span>
<span class="cm">	 *  If we received a SAVE DP, switch to the </span>
<span class="cm">	 *  other PM context since the savep may point </span>
<span class="cm">	 *  to the current PM context.</span>
<span class="cm">	 */</span>
	<span class="n">SCR_JUMPR</span> <span class="o">^</span> <span class="n">IFFALSE</span> <span class="p">(</span><span class="n">MASK</span> <span class="p">(</span><span class="n">HF_DP_SAVED</span><span class="p">,</span> <span class="n">HF_DP_SAVED</span><span class="p">)),</span>
		<span class="mi">8</span><span class="p">,</span>
	<span class="n">SCR_REG_REG</span> <span class="p">(</span><span class="n">sfbr</span><span class="p">,</span> <span class="n">SCR_XOR</span><span class="p">,</span> <span class="n">HF_ACT_PM</span><span class="p">),</span>
		<span class="mi">0</span><span class="p">,</span>
	<span class="cm">/*</span>
<span class="cm">	 *  If we have been interrupt in a PM DATA mini-script,</span>
<span class="cm">	 *  we take the return address from the corresponding </span>
<span class="cm">	 *  saved area.</span>
<span class="cm">	 *  This ensure the return address always points to the </span>
<span class="cm">	 *  main DATA script for this transfer.</span>
<span class="cm">	 */</span>
	<span class="n">SCR_JUMP</span> <span class="o">^</span> <span class="n">IFTRUE</span> <span class="p">(</span><span class="n">MASK</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="p">(</span><span class="n">HF_IN_PM0</span> <span class="o">|</span> <span class="n">HF_IN_PM1</span><span class="p">))),</span>
		<span class="n">PADDR_B</span> <span class="p">(</span><span class="n">pm_handle1</span><span class="p">),</span>
	<span class="n">SCR_JUMPR</span> <span class="o">^</span> <span class="n">IFFALSE</span> <span class="p">(</span><span class="n">MASK</span> <span class="p">(</span><span class="n">HF_IN_PM0</span><span class="p">,</span> <span class="n">HF_IN_PM0</span><span class="p">)),</span>
		<span class="mi">16</span><span class="p">,</span>
	<span class="n">SCR_LOAD_REL</span> <span class="p">(</span><span class="n">ia</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span>
		<span class="n">offsetof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sym_ccb</span><span class="p">,</span> <span class="n">phys</span><span class="p">.</span><span class="n">pm0</span><span class="p">.</span><span class="n">ret</span><span class="p">),</span>
	<span class="n">SCR_JUMP</span><span class="p">,</span>
		<span class="n">PADDR_B</span> <span class="p">(</span><span class="n">pm_save</span><span class="p">),</span>
	<span class="n">SCR_LOAD_REL</span> <span class="p">(</span><span class="n">ia</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span>
		<span class="n">offsetof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sym_ccb</span><span class="p">,</span> <span class="n">phys</span><span class="p">.</span><span class="n">pm1</span><span class="p">.</span><span class="n">ret</span><span class="p">),</span>
	<span class="n">SCR_JUMP</span><span class="p">,</span>
		<span class="n">PADDR_B</span> <span class="p">(</span><span class="n">pm_save</span><span class="p">),</span>
<span class="p">}</span><span class="cm">/*-------------------------&lt; PM_HANDLE1 &gt;-----------------------*/</span><span class="p">,{</span>
	<span class="cm">/*</span>
<span class="cm">	 *  Normal case.</span>
<span class="cm">	 *  Update the return address so that it </span>
<span class="cm">	 *  will point after the interrupted MOVE.</span>
<span class="cm">	 */</span>
	<span class="n">SCR_REG_REG</span> <span class="p">(</span><span class="n">ia</span><span class="p">,</span> <span class="n">SCR_ADD</span><span class="p">,</span> <span class="mi">8</span><span class="p">),</span>
		<span class="mi">0</span><span class="p">,</span>
	<span class="n">SCR_REG_REG</span> <span class="p">(</span><span class="n">ia1</span><span class="p">,</span> <span class="n">SCR_ADDC</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
		<span class="mi">0</span><span class="p">,</span>
<span class="p">}</span><span class="cm">/*-------------------------&lt; PM_SAVE &gt;--------------------------*/</span><span class="p">,{</span>
	<span class="cm">/*</span>
<span class="cm">	 *  Clear all the flags that told us if we were </span>
<span class="cm">	 *  interrupted in a PM DATA mini-script and/or </span>
<span class="cm">	 *  we received a SAVE DP.</span>
<span class="cm">	 */</span>
	<span class="n">SCR_SFBR_REG</span> <span class="p">(</span><span class="n">HF_REG</span><span class="p">,</span> <span class="n">SCR_AND</span><span class="p">,</span> <span class="p">(</span><span class="o">~</span><span class="p">(</span><span class="n">HF_IN_PM0</span><span class="o">|</span><span class="n">HF_IN_PM1</span><span class="o">|</span><span class="n">HF_DP_SAVED</span><span class="p">))),</span>
		<span class="mi">0</span><span class="p">,</span>
	<span class="cm">/*</span>
<span class="cm">	 *  Choose the current PM context.</span>
<span class="cm">	 */</span>
	<span class="n">SCR_JUMP</span> <span class="o">^</span> <span class="n">IFTRUE</span> <span class="p">(</span><span class="n">MASK</span> <span class="p">(</span><span class="n">HF_ACT_PM</span><span class="p">,</span> <span class="n">HF_ACT_PM</span><span class="p">)),</span>
		<span class="n">PADDR_B</span> <span class="p">(</span><span class="n">pm1_save</span><span class="p">),</span>
<span class="p">}</span><span class="cm">/*-------------------------&lt; PM0_SAVE &gt;-------------------------*/</span><span class="p">,{</span>
	<span class="n">SCR_STORE_REL</span> <span class="p">(</span><span class="n">ia</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span>
		<span class="n">offsetof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sym_ccb</span><span class="p">,</span> <span class="n">phys</span><span class="p">.</span><span class="n">pm0</span><span class="p">.</span><span class="n">ret</span><span class="p">),</span>
	<span class="cm">/*</span>
<span class="cm">	 *  If WSR bit is set, either UA and RBC may </span>
<span class="cm">	 *  have to be changed whether the device wants </span>
<span class="cm">	 *  to ignore this residue or not.</span>
<span class="cm">	 */</span>
	<span class="n">SCR_FROM_REG</span> <span class="p">(</span><span class="n">scntl2</span><span class="p">),</span>
		<span class="mi">0</span><span class="p">,</span>
	<span class="n">SCR_CALL</span> <span class="o">^</span> <span class="n">IFTRUE</span> <span class="p">(</span><span class="n">MASK</span> <span class="p">(</span><span class="n">WSR</span><span class="p">,</span> <span class="n">WSR</span><span class="p">)),</span>
		<span class="n">PADDR_B</span> <span class="p">(</span><span class="n">pm_wsr_handle</span><span class="p">),</span>
	<span class="cm">/*</span>
<span class="cm">	 *  Save the remaining byte count, the updated </span>
<span class="cm">	 *  address and the return address.</span>
<span class="cm">	 */</span>
	<span class="n">SCR_STORE_REL</span> <span class="p">(</span><span class="n">rbc</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span>
		<span class="n">offsetof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sym_ccb</span><span class="p">,</span> <span class="n">phys</span><span class="p">.</span><span class="n">pm0</span><span class="p">.</span><span class="n">sg</span><span class="p">.</span><span class="n">size</span><span class="p">),</span>
	<span class="n">SCR_STORE_REL</span> <span class="p">(</span><span class="n">ua</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span>
		<span class="n">offsetof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sym_ccb</span><span class="p">,</span> <span class="n">phys</span><span class="p">.</span><span class="n">pm0</span><span class="p">.</span><span class="n">sg</span><span class="p">.</span><span class="n">addr</span><span class="p">),</span>
	<span class="cm">/*</span>
<span class="cm">	 *  Set the current pointer at the PM0 DATA mini-script.</span>
<span class="cm">	 */</span>
	<span class="n">SCR_LOAD_ABS</span> <span class="p">(</span><span class="n">ia</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span>
		<span class="n">PADDR_B</span> <span class="p">(</span><span class="n">pm0_data_addr</span><span class="p">),</span>
<span class="p">}</span><span class="cm">/*-------------------------&lt; PM_SAVE_END &gt;----------------------*/</span><span class="p">,{</span>
	<span class="n">SCR_STORE_REL</span> <span class="p">(</span><span class="n">ia</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span>
		<span class="n">offsetof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sym_ccb</span><span class="p">,</span> <span class="n">phys</span><span class="p">.</span><span class="n">head</span><span class="p">.</span><span class="n">lastp</span><span class="p">),</span>
	<span class="n">SCR_JUMP</span><span class="p">,</span>
		<span class="n">PADDR_A</span> <span class="p">(</span><span class="n">dispatch</span><span class="p">),</span>
<span class="p">}</span><span class="cm">/*-------------------------&lt; PM1_SAVE &gt;-------------------------*/</span><span class="p">,{</span>
	<span class="n">SCR_STORE_REL</span> <span class="p">(</span><span class="n">ia</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span>
		<span class="n">offsetof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sym_ccb</span><span class="p">,</span> <span class="n">phys</span><span class="p">.</span><span class="n">pm1</span><span class="p">.</span><span class="n">ret</span><span class="p">),</span>
	<span class="cm">/*</span>
<span class="cm">	 *  If WSR bit is set, either UA and RBC may </span>
<span class="cm">	 *  have to be changed whether the device wants </span>
<span class="cm">	 *  to ignore this residue or not.</span>
<span class="cm">	 */</span>
	<span class="n">SCR_FROM_REG</span> <span class="p">(</span><span class="n">scntl2</span><span class="p">),</span>
		<span class="mi">0</span><span class="p">,</span>
	<span class="n">SCR_CALL</span> <span class="o">^</span> <span class="n">IFTRUE</span> <span class="p">(</span><span class="n">MASK</span> <span class="p">(</span><span class="n">WSR</span><span class="p">,</span> <span class="n">WSR</span><span class="p">)),</span>
		<span class="n">PADDR_B</span> <span class="p">(</span><span class="n">pm_wsr_handle</span><span class="p">),</span>
	<span class="cm">/*</span>
<span class="cm">	 *  Save the remaining byte count, the updated </span>
<span class="cm">	 *  address and the return address.</span>
<span class="cm">	 */</span>
	<span class="n">SCR_STORE_REL</span> <span class="p">(</span><span class="n">rbc</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span>
		<span class="n">offsetof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sym_ccb</span><span class="p">,</span> <span class="n">phys</span><span class="p">.</span><span class="n">pm1</span><span class="p">.</span><span class="n">sg</span><span class="p">.</span><span class="n">size</span><span class="p">),</span>
	<span class="n">SCR_STORE_REL</span> <span class="p">(</span><span class="n">ua</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span>
		<span class="n">offsetof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sym_ccb</span><span class="p">,</span> <span class="n">phys</span><span class="p">.</span><span class="n">pm1</span><span class="p">.</span><span class="n">sg</span><span class="p">.</span><span class="n">addr</span><span class="p">),</span>
	<span class="cm">/*</span>
<span class="cm">	 *  Set the current pointer at the PM1 DATA mini-script.</span>
<span class="cm">	 */</span>
	<span class="n">SCR_LOAD_ABS</span> <span class="p">(</span><span class="n">ia</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span>
		<span class="n">PADDR_B</span> <span class="p">(</span><span class="n">pm1_data_addr</span><span class="p">),</span>
	<span class="n">SCR_JUMP</span><span class="p">,</span>
		<span class="n">PADDR_B</span> <span class="p">(</span><span class="n">pm_save_end</span><span class="p">),</span>
<span class="p">}</span><span class="cm">/*-------------------------&lt; PM_WSR_HANDLE &gt;--------------------*/</span><span class="p">,{</span>
	<span class="cm">/*</span>
<span class="cm">	 *  Phase mismatch handling from SCRIPT with WSR set.</span>
<span class="cm">	 *  Such a condition can occur if the chip wants to </span>
<span class="cm">	 *  execute a CHMOV(size &gt; 1) when the WSR bit is </span>
<span class="cm">	 *  set and the target changes PHASE.</span>
<span class="cm">	 *</span>
<span class="cm">	 *  We must move the residual byte to memory.</span>
<span class="cm">	 *</span>
<span class="cm">	 *  UA contains bit 0..31 of the address to </span>
<span class="cm">	 *  move the residual byte.</span>
<span class="cm">	 *  Move it to the table indirect.</span>
<span class="cm">	 */</span>
	<span class="n">SCR_STORE_REL</span> <span class="p">(</span><span class="n">ua</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span>
		<span class="n">offsetof</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sym_ccb</span><span class="p">,</span> <span class="n">phys</span><span class="p">.</span><span class="n">wresid</span><span class="p">.</span><span class="n">addr</span><span class="p">),</span>
	<span class="cm">/*</span>
<span class="cm">	 *  Increment UA (move address to next position).</span>
<span class="cm">	 */</span>
	<span class="n">SCR_REG_REG</span> <span class="p">(</span><span class="n">ua</span><span class="p">,</span> <span class="n">SCR_ADD</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
		<span class="mi">0</span><span class="p">,</span>
	<span class="n">SCR_REG_REG</span> <span class="p">(</span><span class="n">ua1</span><span class="p">,</span> <span class="n">SCR_ADDC</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
		<span class="mi">0</span><span class="p">,</span>
	<span class="n">SCR_REG_REG</span> <span class="p">(</span><span class="n">ua2</span><span class="p">,</span> <span class="n">SCR_ADDC</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
		<span class="mi">0</span><span class="p">,</span>
	<span class="n">SCR_REG_REG</span> <span class="p">(</span><span class="n">ua3</span><span class="p">,</span> <span class="n">SCR_ADDC</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
		<span class="mi">0</span><span class="p">,</span>
	<span class="cm">/*</span>
<span class="cm">	 *  Compute SCRATCHA as:</span>
<span class="cm">	 *  - size to transfer = 1 byte.</span>
<span class="cm">	 *  - bit 24..31 = high address bit [32...39].</span>
<span class="cm">	 */</span>
	<span class="n">SCR_LOAD_ABS</span> <span class="p">(</span><span class="n">scratcha</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span>
		<span class="n">PADDR_B</span> <span class="p">(</span><span class="n">zero</span><span class="p">),</span>
	<span class="n">SCR_REG_REG</span> <span class="p">(</span><span class="n">scratcha</span><span class="p">,</span> <span class="n">SCR_OR</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
		<span class="mi">0</span><span class="p">,</span>
	<span class="n">SCR_FROM_REG</span> <span class="p">(</span><span class="n">rbc3</span><span class="p">),</span>
		<span class="mi">0</span><span class="p">,</span>
	<span class="n">SCR_TO_REG</span> <span class="p">(</span><span class="n">scratcha3</span><span class="p">),</span>
		<span class="mi">0</span><span class="p">,</span>
	<span class="cm">/*</span>
<span class="cm">	 *  Move this value to the table indirect.</span>
<span class="cm">	 */</span>
	<span class="n">SCR_STORE_REL</span> <span class="p">(</span><span class="n">scratcha</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span>
		<span class="n">offsetof</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sym_ccb</span><span class="p">,</span> <span class="n">phys</span><span class="p">.</span><span class="n">wresid</span><span class="p">.</span><span class="n">size</span><span class="p">),</span>
	<span class="cm">/*</span>
<span class="cm">	 *  Wait for a valid phase.</span>
<span class="cm">	 *  While testing with bogus QUANTUM drives, the C1010 </span>
<span class="cm">	 *  sometimes raised a spurious phase mismatch with </span>
<span class="cm">	 *  WSR and the CHMOV(1) triggered another PM.</span>
<span class="cm">	 *  Waiting explicitly for the PHASE seemed to avoid</span>
<span class="cm">	 *  the nested phase mismatch. Btw, this didn&#39;t happen </span>
<span class="cm">	 *  using my IBM drives.</span>
<span class="cm">	 */</span>
	<span class="n">SCR_JUMPR</span> <span class="o">^</span> <span class="n">IFFALSE</span> <span class="p">(</span><span class="n">WHEN</span> <span class="p">(</span><span class="n">SCR_DATA_IN</span><span class="p">)),</span>
		<span class="mi">0</span><span class="p">,</span>
	<span class="cm">/*</span>
<span class="cm">	 *  Perform the move of the residual byte.</span>
<span class="cm">	 */</span>
	<span class="n">SCR_CHMOV_TBL</span> <span class="o">^</span> <span class="n">SCR_DATA_IN</span><span class="p">,</span>
		<span class="n">offsetof</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sym_ccb</span><span class="p">,</span> <span class="n">phys</span><span class="p">.</span><span class="n">wresid</span><span class="p">),</span>
	<span class="cm">/*</span>
<span class="cm">	 *  We can now handle the phase mismatch with UA fixed.</span>
<span class="cm">	 *  RBC[0..23]=0 is a special case that does not require </span>
<span class="cm">	 *  a PM context. The C code also checks against this.</span>
<span class="cm">	 */</span>
	<span class="n">SCR_FROM_REG</span> <span class="p">(</span><span class="n">rbc</span><span class="p">),</span>
		<span class="mi">0</span><span class="p">,</span>
	<span class="n">SCR_RETURN</span> <span class="o">^</span> <span class="n">IFFALSE</span> <span class="p">(</span><span class="n">DATA</span> <span class="p">(</span><span class="mi">0</span><span class="p">)),</span>
		<span class="mi">0</span><span class="p">,</span>
	<span class="n">SCR_FROM_REG</span> <span class="p">(</span><span class="n">rbc1</span><span class="p">),</span>
		<span class="mi">0</span><span class="p">,</span>
	<span class="n">SCR_RETURN</span> <span class="o">^</span> <span class="n">IFFALSE</span> <span class="p">(</span><span class="n">DATA</span> <span class="p">(</span><span class="mi">0</span><span class="p">)),</span>
		<span class="mi">0</span><span class="p">,</span>
	<span class="n">SCR_FROM_REG</span> <span class="p">(</span><span class="n">rbc2</span><span class="p">),</span>
		<span class="mi">0</span><span class="p">,</span>
	<span class="n">SCR_RETURN</span> <span class="o">^</span> <span class="n">IFFALSE</span> <span class="p">(</span><span class="n">DATA</span> <span class="p">(</span><span class="mi">0</span><span class="p">)),</span>
		<span class="mi">0</span><span class="p">,</span>
	<span class="cm">/*</span>
<span class="cm">	 *  RBC[0..23]=0.</span>
<span class="cm">	 *  Not only we donnot need a PM context, but this would </span>
<span class="cm">	 *  lead to a bogus CHMOV(0). This condition means that </span>
<span class="cm">	 *  the residual was the last byte to move from this CHMOV.</span>
<span class="cm">	 *  So, we just have to move the current data script pointer </span>
<span class="cm">	 *  (i.e. TEMP) to the SCRIPTS address following the </span>
<span class="cm">	 *  interrupted CHMOV and jump to dispatcher.</span>
<span class="cm">	 *  IA contains the data pointer to save.</span>
<span class="cm">	 */</span>
	<span class="n">SCR_JUMP</span><span class="p">,</span>
		<span class="n">PADDR_B</span> <span class="p">(</span><span class="n">pm_save_end</span><span class="p">),</span>
<span class="p">}</span><span class="cm">/*-------------------------&lt; WSR_MA_HELPER &gt;--------------------*/</span><span class="p">,{</span>
	<span class="cm">/*</span>
<span class="cm">	 *  Helper for the C code when WSR bit is set.</span>
<span class="cm">	 *  Perform the move of the residual byte.</span>
<span class="cm">	 */</span>
	<span class="n">SCR_CHMOV_TBL</span> <span class="o">^</span> <span class="n">SCR_DATA_IN</span><span class="p">,</span>
		<span class="n">offsetof</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sym_ccb</span><span class="p">,</span> <span class="n">phys</span><span class="p">.</span><span class="n">wresid</span><span class="p">),</span>
	<span class="n">SCR_JUMP</span><span class="p">,</span>
		<span class="n">PADDR_A</span> <span class="p">(</span><span class="n">dispatch</span><span class="p">),</span>

<span class="p">}</span><span class="cm">/*-------------------------&lt; ZERO &gt;-----------------------------*/</span><span class="p">,{</span>
	<span class="n">SCR_DATA_ZERO</span><span class="p">,</span>
<span class="p">}</span><span class="cm">/*-------------------------&lt; SCRATCH &gt;--------------------------*/</span><span class="p">,{</span>
	<span class="n">SCR_DATA_ZERO</span><span class="p">,</span>
<span class="p">}</span><span class="cm">/*-------------------------&lt; PM0_DATA_ADDR &gt;--------------------*/</span><span class="p">,{</span>
	<span class="n">SCR_DATA_ZERO</span><span class="p">,</span>
<span class="p">}</span><span class="cm">/*-------------------------&lt; PM1_DATA_ADDR &gt;--------------------*/</span><span class="p">,{</span>
	<span class="n">SCR_DATA_ZERO</span><span class="p">,</span>
<span class="p">}</span><span class="cm">/*-------------------------&lt; DONE_POS &gt;-------------------------*/</span><span class="p">,{</span>
	<span class="n">SCR_DATA_ZERO</span><span class="p">,</span>
<span class="p">}</span><span class="cm">/*-------------------------&lt; STARTPOS &gt;-------------------------*/</span><span class="p">,{</span>
	<span class="n">SCR_DATA_ZERO</span><span class="p">,</span>
<span class="p">}</span><span class="cm">/*-------------------------&lt; TARGTBL &gt;--------------------------*/</span><span class="p">,{</span>
	<span class="n">SCR_DATA_ZERO</span><span class="p">,</span>
<span class="p">}</span><span class="cm">/*-------------------------&lt;&gt;-----------------------------------*/</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">SYM_FWZ_SCR</span> <span class="n">SYM_FWZ_SCR</span> <span class="o">=</span> <span class="p">{</span>
 <span class="cm">/*-------------------------&lt; SNOOPTEST &gt;------------------------*/</span><span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 *  Read the variable from memory.</span>
<span class="cm">	 */</span>
	<span class="n">SCR_LOAD_REL</span> <span class="p">(</span><span class="n">scratcha</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span>
		<span class="n">offsetof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sym_hcb</span><span class="p">,</span> <span class="n">scratch</span><span class="p">),</span>
	<span class="cm">/*</span>
<span class="cm">	 *  Write the variable to memory.</span>
<span class="cm">	 */</span>
	<span class="n">SCR_STORE_REL</span> <span class="p">(</span><span class="n">temp</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span>
		<span class="n">offsetof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sym_hcb</span><span class="p">,</span> <span class="n">scratch</span><span class="p">),</span>
	<span class="cm">/*</span>
<span class="cm">	 *  Read back the variable from memory.</span>
<span class="cm">	 */</span>
	<span class="n">SCR_LOAD_REL</span> <span class="p">(</span><span class="n">temp</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span>
		<span class="n">offsetof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sym_hcb</span><span class="p">,</span> <span class="n">scratch</span><span class="p">),</span>
<span class="p">}</span><span class="cm">/*-------------------------&lt; SNOOPEND &gt;-------------------------*/</span><span class="p">,{</span>
	<span class="cm">/*</span>
<span class="cm">	 *  And stop.</span>
<span class="cm">	 */</span>
	<span class="n">SCR_INT</span><span class="p">,</span>
		<span class="mi">99</span><span class="p">,</span>
<span class="p">}</span><span class="cm">/*-------------------------&lt;&gt;-----------------------------------*/</span>
<span class="p">};</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
