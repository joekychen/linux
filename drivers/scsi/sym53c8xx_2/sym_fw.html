<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › scsi › sym53c8xx_2 › sym_fw.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>sym_fw.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Device driver for the SYMBIOS/LSILOGIC 53C8XX and 53C1010 family </span>
<span class="cm"> * of PCI-SCSI IO processors.</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 1999-2001  Gerard Roudier &lt;groudier@free.fr&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * This driver is derived from the Linux sym53c8xx driver.</span>
<span class="cm"> * Copyright (C) 1998-2000  Gerard Roudier</span>
<span class="cm"> *</span>
<span class="cm"> * The sym53c8xx driver is derived from the ncr53c8xx driver that had been </span>
<span class="cm"> * a port of the FreeBSD ncr driver to Linux-1.2.13.</span>
<span class="cm"> *</span>
<span class="cm"> * The original ncr driver has been written for 386bsd and FreeBSD by</span>
<span class="cm"> *         Wolfgang Stanglmeier        &lt;wolf@cologne.de&gt;</span>
<span class="cm"> *         Stefan Esser                &lt;se@mi.Uni-Koeln.de&gt;</span>
<span class="cm"> * Copyright (C) 1994  Wolfgang Stanglmeier</span>
<span class="cm"> *</span>
<span class="cm"> * Other major contributions:</span>
<span class="cm"> *</span>
<span class="cm"> * NVRAM detection and reading.</span>
<span class="cm"> * Copyright (C) 1997 Richard Waltham &lt;dormouse@farsrobt.demon.co.uk&gt;</span>
<span class="cm"> *</span>
<span class="cm"> *-----------------------------------------------------------------------------</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or modify</span>
<span class="cm"> * it under the terms of the GNU General Public License as published by</span>
<span class="cm"> * the Free Software Foundation; either version 2 of the License, or</span>
<span class="cm"> * (at your option) any later version.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is distributed in the hope that it will be useful,</span>
<span class="cm"> * but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="cm"> * GNU General Public License for more details.</span>
<span class="cm"> *</span>
<span class="cm"> * You should have received a copy of the GNU General Public License</span>
<span class="cm"> * along with this program; if not, write to the Free Software</span>
<span class="cm"> * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA</span>
<span class="cm"> */</span>

<span class="cp">#include &quot;sym_glue.h&quot;</span>

<span class="cm">/*</span>
<span class="cm"> *  Macros used for all firmwares.</span>
<span class="cm"> */</span>
<span class="cp">#define	SYM_GEN_A(s, label)	((short) offsetof(s, label)),</span>
<span class="cp">#define	SYM_GEN_B(s, label)	((short) offsetof(s, label)),</span>
<span class="cp">#define	SYM_GEN_Z(s, label)	((short) offsetof(s, label)),</span>
<span class="cp">#define	PADDR_A(label)		SYM_GEN_PADDR_A(struct SYM_FWA_SCR, label)</span>
<span class="cp">#define	PADDR_B(label)		SYM_GEN_PADDR_B(struct SYM_FWB_SCR, label)</span>


<span class="cp">#if	SYM_CONF_GENERIC_SUPPORT</span>
<span class="cm">/*</span>
<span class="cm"> *  Allocate firmware #1 script area.</span>
<span class="cm"> */</span>
<span class="cp">#define	SYM_FWA_SCR		sym_fw1a_scr</span>
<span class="cp">#define	SYM_FWB_SCR		sym_fw1b_scr</span>
<span class="cp">#define	SYM_FWZ_SCR		sym_fw1z_scr</span>
<span class="cp">#include &quot;sym_fw1.h&quot;</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">sym_fwa_ofs</span> <span class="n">sym_fw1a_ofs</span> <span class="o">=</span> <span class="p">{</span>
	<span class="n">SYM_GEN_FW_A</span><span class="p">(</span><span class="k">struct</span> <span class="n">SYM_FWA_SCR</span><span class="p">)</span>
<span class="p">};</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">sym_fwb_ofs</span> <span class="n">sym_fw1b_ofs</span> <span class="o">=</span> <span class="p">{</span>
	<span class="n">SYM_GEN_FW_B</span><span class="p">(</span><span class="k">struct</span> <span class="n">SYM_FWB_SCR</span><span class="p">)</span>
<span class="p">};</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">sym_fwz_ofs</span> <span class="n">sym_fw1z_ofs</span> <span class="o">=</span> <span class="p">{</span>
	<span class="n">SYM_GEN_FW_Z</span><span class="p">(</span><span class="k">struct</span> <span class="n">SYM_FWZ_SCR</span><span class="p">)</span>
<span class="p">};</span>
<span class="cp">#undef	SYM_FWA_SCR</span>
<span class="cp">#undef	SYM_FWB_SCR</span>
<span class="cp">#undef	SYM_FWZ_SCR</span>
<span class="cp">#endif	</span><span class="cm">/* SYM_CONF_GENERIC_SUPPORT */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> *  Allocate firmware #2 script area.</span>
<span class="cm"> */</span>
<span class="cp">#define	SYM_FWA_SCR		sym_fw2a_scr</span>
<span class="cp">#define	SYM_FWB_SCR		sym_fw2b_scr</span>
<span class="cp">#define	SYM_FWZ_SCR		sym_fw2z_scr</span>
<span class="cp">#include &quot;sym_fw2.h&quot;</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">sym_fwa_ofs</span> <span class="n">sym_fw2a_ofs</span> <span class="o">=</span> <span class="p">{</span>
	<span class="n">SYM_GEN_FW_A</span><span class="p">(</span><span class="k">struct</span> <span class="n">SYM_FWA_SCR</span><span class="p">)</span>
<span class="p">};</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">sym_fwb_ofs</span> <span class="n">sym_fw2b_ofs</span> <span class="o">=</span> <span class="p">{</span>
	<span class="n">SYM_GEN_FW_B</span><span class="p">(</span><span class="k">struct</span> <span class="n">SYM_FWB_SCR</span><span class="p">)</span>
	<span class="n">SYM_GEN_B</span><span class="p">(</span><span class="k">struct</span> <span class="n">SYM_FWB_SCR</span><span class="p">,</span> <span class="n">start64</span><span class="p">)</span>
	<span class="n">SYM_GEN_B</span><span class="p">(</span><span class="k">struct</span> <span class="n">SYM_FWB_SCR</span><span class="p">,</span> <span class="n">pm_handle</span><span class="p">)</span>
<span class="p">};</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">sym_fwz_ofs</span> <span class="n">sym_fw2z_ofs</span> <span class="o">=</span> <span class="p">{</span>
	<span class="n">SYM_GEN_FW_Z</span><span class="p">(</span><span class="k">struct</span> <span class="n">SYM_FWZ_SCR</span><span class="p">)</span>
<span class="p">};</span>
<span class="cp">#undef	SYM_FWA_SCR</span>
<span class="cp">#undef	SYM_FWB_SCR</span>
<span class="cp">#undef	SYM_FWZ_SCR</span>

<span class="cp">#undef	SYM_GEN_A</span>
<span class="cp">#undef	SYM_GEN_B</span>
<span class="cp">#undef	SYM_GEN_Z</span>
<span class="cp">#undef	PADDR_A</span>
<span class="cp">#undef	PADDR_B</span>

<span class="cp">#if	SYM_CONF_GENERIC_SUPPORT</span>
<span class="cm">/*</span>
<span class="cm"> *  Patch routine for firmware #1.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">sym_fw1_patch</span><span class="p">(</span><span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sym_hcb</span> <span class="o">*</span><span class="n">np</span> <span class="o">=</span> <span class="n">sym_get_hcb</span><span class="p">(</span><span class="n">shost</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">sym_fw1a_scr</span> <span class="o">*</span><span class="n">scripta0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sym_fw1b_scr</span> <span class="o">*</span><span class="n">scriptb0</span><span class="p">;</span>

	<span class="n">scripta0</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sym_fw1a_scr</span> <span class="o">*</span><span class="p">)</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">scripta0</span><span class="p">;</span>
	<span class="n">scriptb0</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sym_fw1b_scr</span> <span class="o">*</span><span class="p">)</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">scriptb0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 *  Remove LED support if not needed.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">features</span> <span class="o">&amp;</span> <span class="n">FE_LED0</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">scripta0</span><span class="o">-&gt;</span><span class="n">idle</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>	<span class="o">=</span> <span class="n">cpu_to_scr</span><span class="p">(</span><span class="n">SCR_NO_OP</span><span class="p">);</span>
		<span class="n">scripta0</span><span class="o">-&gt;</span><span class="n">reselected</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>	<span class="o">=</span> <span class="n">cpu_to_scr</span><span class="p">(</span><span class="n">SCR_NO_OP</span><span class="p">);</span>
		<span class="n">scripta0</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>	<span class="o">=</span> <span class="n">cpu_to_scr</span><span class="p">(</span><span class="n">SCR_NO_OP</span><span class="p">);</span>
	<span class="p">}</span>

<span class="cp">#ifdef SYM_CONF_IARB_SUPPORT</span>
	<span class="cm">/*</span>
<span class="cm">	 *    If user does not want to use IMMEDIATE ARBITRATION</span>
<span class="cm">	 *    when we are reselected while attempting to arbitrate,</span>
<span class="cm">	 *    patch the SCRIPTS accordingly with a SCRIPT NO_OP.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">SYM_CONF_SET_IARB_ON_ARB_LOST</span><span class="p">)</span>
		<span class="n">scripta0</span><span class="o">-&gt;</span><span class="n">ungetjob</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">cpu_to_scr</span><span class="p">(</span><span class="n">SCR_NO_OP</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="cm">/*</span>
<span class="cm">	 *  Patch some data in SCRIPTS.</span>
<span class="cm">	 *  - start and done queue initial bus address.</span>
<span class="cm">	 *  - target bus address table bus address.</span>
<span class="cm">	 */</span>
	<span class="n">scriptb0</span><span class="o">-&gt;</span><span class="n">startpos</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>	<span class="o">=</span> <span class="n">cpu_to_scr</span><span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">squeue_ba</span><span class="p">);</span>
	<span class="n">scriptb0</span><span class="o">-&gt;</span><span class="n">done_pos</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>	<span class="o">=</span> <span class="n">cpu_to_scr</span><span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">dqueue_ba</span><span class="p">);</span>
	<span class="n">scriptb0</span><span class="o">-&gt;</span><span class="n">targtbl</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>	<span class="o">=</span> <span class="n">cpu_to_scr</span><span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">targtbl_ba</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#endif	</span><span class="cm">/* SYM_CONF_GENERIC_SUPPORT */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> *  Patch routine for firmware #2.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">sym_fw2_patch</span><span class="p">(</span><span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sym_data</span> <span class="o">*</span><span class="n">sym_data</span> <span class="o">=</span> <span class="n">shost_priv</span><span class="p">(</span><span class="n">shost</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span> <span class="o">=</span> <span class="n">sym_data</span><span class="o">-&gt;</span><span class="n">pdev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sym_hcb</span> <span class="o">*</span><span class="n">np</span> <span class="o">=</span> <span class="n">sym_data</span><span class="o">-&gt;</span><span class="n">ncb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sym_fw2a_scr</span> <span class="o">*</span><span class="n">scripta0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sym_fw2b_scr</span> <span class="o">*</span><span class="n">scriptb0</span><span class="p">;</span>

	<span class="n">scripta0</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sym_fw2a_scr</span> <span class="o">*</span><span class="p">)</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">scripta0</span><span class="p">;</span>
	<span class="n">scriptb0</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sym_fw2b_scr</span> <span class="o">*</span><span class="p">)</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">scriptb0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 *  Remove LED support if not needed.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">features</span> <span class="o">&amp;</span> <span class="n">FE_LED0</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">scripta0</span><span class="o">-&gt;</span><span class="n">idle</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>	<span class="o">=</span> <span class="n">cpu_to_scr</span><span class="p">(</span><span class="n">SCR_NO_OP</span><span class="p">);</span>
		<span class="n">scripta0</span><span class="o">-&gt;</span><span class="n">reselected</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>	<span class="o">=</span> <span class="n">cpu_to_scr</span><span class="p">(</span><span class="n">SCR_NO_OP</span><span class="p">);</span>
		<span class="n">scripta0</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>	<span class="o">=</span> <span class="n">cpu_to_scr</span><span class="p">(</span><span class="n">SCR_NO_OP</span><span class="p">);</span>
	<span class="p">}</span>

<span class="cp">#if   SYM_CONF_DMA_ADDRESSING_MODE == 2</span>
	<span class="cm">/*</span>
<span class="cm">	 *  Remove useless 64 bit DMA specific SCRIPTS, </span>
<span class="cm">	 *  when this feature is not available.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">use_dac</span><span class="p">(</span><span class="n">np</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">scripta0</span><span class="o">-&gt;</span><span class="n">is_dmap_dirty</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">cpu_to_scr</span><span class="p">(</span><span class="n">SCR_NO_OP</span><span class="p">);</span>
		<span class="n">scripta0</span><span class="o">-&gt;</span><span class="n">is_dmap_dirty</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">scripta0</span><span class="o">-&gt;</span><span class="n">is_dmap_dirty</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">cpu_to_scr</span><span class="p">(</span><span class="n">SCR_NO_OP</span><span class="p">);</span>
		<span class="n">scripta0</span><span class="o">-&gt;</span><span class="n">is_dmap_dirty</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef SYM_CONF_IARB_SUPPORT</span>
	<span class="cm">/*</span>
<span class="cm">	 *    If user does not want to use IMMEDIATE ARBITRATION</span>
<span class="cm">	 *    when we are reselected while attempting to arbitrate,</span>
<span class="cm">	 *    patch the SCRIPTS accordingly with a SCRIPT NO_OP.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">SYM_CONF_SET_IARB_ON_ARB_LOST</span><span class="p">)</span>
		<span class="n">scripta0</span><span class="o">-&gt;</span><span class="n">ungetjob</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">cpu_to_scr</span><span class="p">(</span><span class="n">SCR_NO_OP</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="cm">/*</span>
<span class="cm">	 *  Patch some variable in SCRIPTS.</span>
<span class="cm">	 *  - start and done queue initial bus address.</span>
<span class="cm">	 *  - target bus address table bus address.</span>
<span class="cm">	 */</span>
	<span class="n">scriptb0</span><span class="o">-&gt;</span><span class="n">startpos</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>	<span class="o">=</span> <span class="n">cpu_to_scr</span><span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">squeue_ba</span><span class="p">);</span>
	<span class="n">scriptb0</span><span class="o">-&gt;</span><span class="n">done_pos</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>	<span class="o">=</span> <span class="n">cpu_to_scr</span><span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">dqueue_ba</span><span class="p">);</span>
	<span class="n">scriptb0</span><span class="o">-&gt;</span><span class="n">targtbl</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>	<span class="o">=</span> <span class="n">cpu_to_scr</span><span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">targtbl_ba</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 *  Remove the load of SCNTL4 on reselection if not a C10.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">features</span> <span class="o">&amp;</span> <span class="n">FE_C10</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">scripta0</span><span class="o">-&gt;</span><span class="n">resel_scntl4</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">cpu_to_scr</span><span class="p">(</span><span class="n">SCR_NO_OP</span><span class="p">);</span>
		<span class="n">scripta0</span><span class="o">-&gt;</span><span class="n">resel_scntl4</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">cpu_to_scr</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 *  Remove a couple of work-arounds specific to C1010 if </span>
<span class="cm">	 *  they are not desirable. See `sym_fw2.h&#39; for more details.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">device</span> <span class="o">==</span> <span class="n">PCI_DEVICE_ID_LSI_53C1010_66</span> <span class="o">&amp;&amp;</span>
	      <span class="n">pdev</span><span class="o">-&gt;</span><span class="n">revision</span> <span class="o">&lt;</span> <span class="mh">0x1</span> <span class="o">&amp;&amp;</span>
	      <span class="n">np</span><span class="o">-&gt;</span><span class="n">pciclk_khz</span> <span class="o">&lt;</span> <span class="mi">60000</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">scripta0</span><span class="o">-&gt;</span><span class="n">datao_phase</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">cpu_to_scr</span><span class="p">(</span><span class="n">SCR_NO_OP</span><span class="p">);</span>
		<span class="n">scripta0</span><span class="o">-&gt;</span><span class="n">datao_phase</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">cpu_to_scr</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">device</span> <span class="o">==</span> <span class="n">PCI_DEVICE_ID_LSI_53C1010_33</span> <span class="cm">/* &amp;&amp;</span>
<span class="cm">	      pdev-&gt;revision &lt; 0xff */</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">scripta0</span><span class="o">-&gt;</span><span class="n">sel_done</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">cpu_to_scr</span><span class="p">(</span><span class="n">SCR_NO_OP</span><span class="p">);</span>
		<span class="n">scripta0</span><span class="o">-&gt;</span><span class="n">sel_done</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">cpu_to_scr</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 *  Patch some other variables in SCRIPTS.</span>
<span class="cm">	 *  These ones are loaded by the SCRIPTS processor.</span>
<span class="cm">	 */</span>
	<span class="n">scriptb0</span><span class="o">-&gt;</span><span class="n">pm0_data_addr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span>
		<span class="n">cpu_to_scr</span><span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">scripta_ba</span> <span class="o">+</span> 
			   <span class="n">offsetof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sym_fw2a_scr</span><span class="p">,</span> <span class="n">pm0_data</span><span class="p">));</span>
	<span class="n">scriptb0</span><span class="o">-&gt;</span><span class="n">pm1_data_addr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span>
		<span class="n">cpu_to_scr</span><span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">scripta_ba</span> <span class="o">+</span> 
			   <span class="n">offsetof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sym_fw2a_scr</span><span class="p">,</span> <span class="n">pm1_data</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *  Fill the data area in scripts.</span>
<span class="cm"> *  To be done for all firmwares.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">sym_fw_fill_data</span> <span class="p">(</span><span class="n">u32</span> <span class="o">*</span><span class="n">in</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">out</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span>	<span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">SYM_CONF_MAX_SG</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">in</span><span class="o">++</span>  <span class="o">=</span> <span class="n">SCR_CHMOV_TBL</span> <span class="o">^</span> <span class="n">SCR_DATA_IN</span><span class="p">;</span>
		<span class="o">*</span><span class="n">in</span><span class="o">++</span>  <span class="o">=</span> <span class="n">offsetof</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sym_dsb</span><span class="p">,</span> <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
		<span class="o">*</span><span class="n">out</span><span class="o">++</span> <span class="o">=</span> <span class="n">SCR_CHMOV_TBL</span> <span class="o">^</span> <span class="n">SCR_DATA_OUT</span><span class="p">;</span>
		<span class="o">*</span><span class="n">out</span><span class="o">++</span> <span class="o">=</span> <span class="n">offsetof</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sym_dsb</span><span class="p">,</span> <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *  Setup useful script bus addresses.</span>
<span class="cm"> *  To be done for all firmwares.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> 
<span class="nf">sym_fw_setup_bus_addresses</span><span class="p">(</span><span class="k">struct</span> <span class="n">sym_hcb</span> <span class="o">*</span><span class="n">np</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sym_fw</span> <span class="o">*</span><span class="n">fw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="o">*</span><span class="n">pa</span><span class="p">;</span>
	<span class="n">u_short</span> <span class="o">*</span><span class="n">po</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 *  Build the bus address table for script A </span>
<span class="cm">	 *  from the script A offset table.</span>
<span class="cm">	 */</span>
	<span class="n">po</span> <span class="o">=</span> <span class="p">(</span><span class="n">u_short</span> <span class="o">*</span><span class="p">)</span> <span class="n">fw</span><span class="o">-&gt;</span><span class="n">a_ofs</span><span class="p">;</span>
	<span class="n">pa</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">fwa_bas</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">fwa_bas</span><span class="p">)</span><span class="o">/</span><span class="k">sizeof</span><span class="p">(</span><span class="n">u32</span><span class="p">)</span> <span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">pa</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">scripta_ba</span> <span class="o">+</span> <span class="n">po</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

	<span class="cm">/*</span>
<span class="cm">	 *  Same for script B.</span>
<span class="cm">	 */</span>
	<span class="n">po</span> <span class="o">=</span> <span class="p">(</span><span class="n">u_short</span> <span class="o">*</span><span class="p">)</span> <span class="n">fw</span><span class="o">-&gt;</span><span class="n">b_ofs</span><span class="p">;</span>
	<span class="n">pa</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">fwb_bas</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">fwb_bas</span><span class="p">)</span><span class="o">/</span><span class="k">sizeof</span><span class="p">(</span><span class="n">u32</span><span class="p">)</span> <span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">pa</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">scriptb_ba</span> <span class="o">+</span> <span class="n">po</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

	<span class="cm">/*</span>
<span class="cm">	 *  Same for script Z.</span>
<span class="cm">	 */</span>
	<span class="n">po</span> <span class="o">=</span> <span class="p">(</span><span class="n">u_short</span> <span class="o">*</span><span class="p">)</span> <span class="n">fw</span><span class="o">-&gt;</span><span class="n">z_ofs</span><span class="p">;</span>
	<span class="n">pa</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">fwz_bas</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">fwz_bas</span><span class="p">)</span><span class="o">/</span><span class="k">sizeof</span><span class="p">(</span><span class="n">u32</span><span class="p">)</span> <span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">pa</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">scriptz_ba</span> <span class="o">+</span> <span class="n">po</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
<span class="p">}</span>

<span class="cp">#if	SYM_CONF_GENERIC_SUPPORT</span>
<span class="cm">/*</span>
<span class="cm"> *  Setup routine for firmware #1.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> 
<span class="nf">sym_fw1_setup</span><span class="p">(</span><span class="k">struct</span> <span class="n">sym_hcb</span> <span class="o">*</span><span class="n">np</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sym_fw</span> <span class="o">*</span><span class="n">fw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sym_fw1a_scr</span> <span class="o">*</span><span class="n">scripta0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sym_fw1b_scr</span> <span class="o">*</span><span class="n">scriptb0</span><span class="p">;</span>

	<span class="n">scripta0</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sym_fw1a_scr</span> <span class="o">*</span><span class="p">)</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">scripta0</span><span class="p">;</span>
	<span class="n">scriptb0</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sym_fw1b_scr</span> <span class="o">*</span><span class="p">)</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">scriptb0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 *  Fill variable parts in scripts.</span>
<span class="cm">	 */</span>
	<span class="n">sym_fw_fill_data</span><span class="p">(</span><span class="n">scripta0</span><span class="o">-&gt;</span><span class="n">data_in</span><span class="p">,</span> <span class="n">scripta0</span><span class="o">-&gt;</span><span class="n">data_out</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 *  Setup bus addresses used from the C code..</span>
<span class="cm">	 */</span>
	<span class="n">sym_fw_setup_bus_addresses</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">fw</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#endif	</span><span class="cm">/* SYM_CONF_GENERIC_SUPPORT */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> *  Setup routine for firmware #2.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> 
<span class="nf">sym_fw2_setup</span><span class="p">(</span><span class="k">struct</span> <span class="n">sym_hcb</span> <span class="o">*</span><span class="n">np</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sym_fw</span> <span class="o">*</span><span class="n">fw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sym_fw2a_scr</span> <span class="o">*</span><span class="n">scripta0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sym_fw2b_scr</span> <span class="o">*</span><span class="n">scriptb0</span><span class="p">;</span>

	<span class="n">scripta0</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sym_fw2a_scr</span> <span class="o">*</span><span class="p">)</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">scripta0</span><span class="p">;</span>
	<span class="n">scriptb0</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sym_fw2b_scr</span> <span class="o">*</span><span class="p">)</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">scriptb0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 *  Fill variable parts in scripts.</span>
<span class="cm">	 */</span>
	<span class="n">sym_fw_fill_data</span><span class="p">(</span><span class="n">scripta0</span><span class="o">-&gt;</span><span class="n">data_in</span><span class="p">,</span> <span class="n">scripta0</span><span class="o">-&gt;</span><span class="n">data_out</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 *  Setup bus addresses used from the C code..</span>
<span class="cm">	 */</span>
	<span class="n">sym_fw_setup_bus_addresses</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">fw</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *  Allocate firmware descriptors.</span>
<span class="cm"> */</span>
<span class="cp">#if	SYM_CONF_GENERIC_SUPPORT</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">sym_fw</span> <span class="n">sym_fw1</span> <span class="o">=</span> <span class="n">SYM_FW_ENTRY</span><span class="p">(</span><span class="n">sym_fw1</span><span class="p">,</span> <span class="s">&quot;NCR-generic&quot;</span><span class="p">);</span>
<span class="cp">#endif	</span><span class="cm">/* SYM_CONF_GENERIC_SUPPORT */</span><span class="cp"></span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">sym_fw</span> <span class="n">sym_fw2</span> <span class="o">=</span> <span class="n">SYM_FW_ENTRY</span><span class="p">(</span><span class="n">sym_fw2</span><span class="p">,</span> <span class="s">&quot;LOAD/STORE-based&quot;</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> *  Find the most appropriate firmware for a chip.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">sym_fw</span> <span class="o">*</span> 
<span class="nf">sym_find_firmware</span><span class="p">(</span><span class="k">struct</span> <span class="n">sym_chip</span> <span class="o">*</span><span class="n">chip</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">features</span> <span class="o">&amp;</span> <span class="n">FE_LDSTR</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">&amp;</span><span class="n">sym_fw2</span><span class="p">;</span>
<span class="cp">#if	SYM_CONF_GENERIC_SUPPORT</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">features</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">FE_PFEN</span><span class="o">|</span><span class="n">FE_NOPM</span><span class="o">|</span><span class="n">FE_DAC</span><span class="p">)))</span>
		<span class="k">return</span> <span class="o">&amp;</span><span class="n">sym_fw1</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="k">else</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *  Bind a script to physical addresses.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">sym_fw_bind_script</span><span class="p">(</span><span class="k">struct</span> <span class="n">sym_hcb</span> <span class="o">*</span><span class="n">np</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">start</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">opcode</span><span class="p">,</span> <span class="n">new</span><span class="p">,</span> <span class="n">old</span><span class="p">,</span> <span class="n">tmp1</span><span class="p">,</span> <span class="n">tmp2</span><span class="p">;</span>
	<span class="n">u32</span> <span class="o">*</span><span class="n">end</span><span class="p">,</span> <span class="o">*</span><span class="n">cur</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">relocs</span><span class="p">;</span>

	<span class="n">cur</span> <span class="o">=</span> <span class="n">start</span><span class="p">;</span>
	<span class="n">end</span> <span class="o">=</span> <span class="n">start</span> <span class="o">+</span> <span class="n">len</span><span class="o">/</span><span class="mi">4</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">cur</span> <span class="o">&lt;</span> <span class="n">end</span><span class="p">)</span> <span class="p">{</span>

		<span class="n">opcode</span> <span class="o">=</span> <span class="o">*</span><span class="n">cur</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 *  If we forget to change the length</span>
<span class="cm">		 *  in scripts, a field will be</span>
<span class="cm">		 *  padded with 0. This is an illegal</span>
<span class="cm">		 *  command.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">opcode</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printf</span> <span class="p">(</span><span class="s">&quot;%s: ERROR0 IN SCRIPT at %d.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">sym_name</span><span class="p">(</span><span class="n">np</span><span class="p">),</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="p">(</span><span class="n">cur</span><span class="o">-</span><span class="n">start</span><span class="p">));</span>
			<span class="o">++</span><span class="n">cur</span><span class="p">;</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">};</span>

		<span class="cm">/*</span>
<span class="cm">		 *  We use the bogus value 0xf00ff00f ;-)</span>
<span class="cm">		 *  to reserve data area in SCRIPTS.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">opcode</span> <span class="o">==</span> <span class="n">SCR_DATA_ZERO</span><span class="p">)</span> <span class="p">{</span>
			<span class="o">*</span><span class="n">cur</span><span class="o">++</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">DEBUG_FLAGS</span> <span class="o">&amp;</span> <span class="n">DEBUG_SCRIPT</span><span class="p">)</span>
			<span class="n">printf</span> <span class="p">(</span><span class="s">&quot;%d:  &lt;%x&gt;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="p">(</span><span class="n">cur</span><span class="o">-</span><span class="n">start</span><span class="p">),</span>
				<span class="p">(</span><span class="kt">unsigned</span><span class="p">)</span><span class="n">opcode</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 *  We don&#39;t have to decode ALL commands</span>
<span class="cm">		 */</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">opcode</span> <span class="o">&gt;&gt;</span> <span class="mi">28</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="mh">0xf</span>:
			<span class="cm">/*</span>
<span class="cm">			 *  LOAD / STORE DSA relative, don&#39;t relocate.</span>
<span class="cm">			 */</span>
			<span class="n">relocs</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="mh">0xe</span>:
			<span class="cm">/*</span>
<span class="cm">			 *  LOAD / STORE absolute.</span>
<span class="cm">			 */</span>
			<span class="n">relocs</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="mh">0xc</span>:
			<span class="cm">/*</span>
<span class="cm">			 *  COPY has TWO arguments.</span>
<span class="cm">			 */</span>
			<span class="n">relocs</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
			<span class="n">tmp1</span> <span class="o">=</span> <span class="n">cur</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
			<span class="n">tmp2</span> <span class="o">=</span> <span class="n">cur</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">tmp1</span> <span class="o">^</span> <span class="n">tmp2</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mi">3</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">printf</span> <span class="p">(</span><span class="s">&quot;%s: ERROR1 IN SCRIPT at %d.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">sym_name</span><span class="p">(</span><span class="n">np</span><span class="p">),</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="p">(</span><span class="n">cur</span><span class="o">-</span><span class="n">start</span><span class="p">));</span>
			<span class="p">}</span>
			<span class="cm">/*</span>
<span class="cm">			 *  If PREFETCH feature not enabled, remove </span>
<span class="cm">			 *  the NO FLUSH bit if present.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">opcode</span> <span class="o">&amp;</span> <span class="n">SCR_NO_FLUSH</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			    <span class="o">!</span><span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">features</span> <span class="o">&amp;</span> <span class="n">FE_PFEN</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">opcode</span> <span class="o">=</span> <span class="p">(</span><span class="n">opcode</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">SCR_NO_FLUSH</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="mh">0x0</span>:
			<span class="cm">/*</span>
<span class="cm">			 *  MOVE/CHMOV (absolute address)</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">features</span> <span class="o">&amp;</span> <span class="n">FE_WIDE</span><span class="p">))</span>
				<span class="n">opcode</span> <span class="o">=</span> <span class="p">(</span><span class="n">opcode</span> <span class="o">|</span> <span class="n">OPC_MOVE</span><span class="p">);</span>
			<span class="n">relocs</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="mh">0x1</span>:
			<span class="cm">/*</span>
<span class="cm">			 *  MOVE/CHMOV (table indirect)</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">features</span> <span class="o">&amp;</span> <span class="n">FE_WIDE</span><span class="p">))</span>
				<span class="n">opcode</span> <span class="o">=</span> <span class="p">(</span><span class="n">opcode</span> <span class="o">|</span> <span class="n">OPC_MOVE</span><span class="p">);</span>
			<span class="n">relocs</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
<span class="cp">#ifdef SYM_CONF_TARGET_ROLE_SUPPORT</span>
		<span class="k">case</span> <span class="mh">0x2</span>:
			<span class="cm">/*</span>
<span class="cm">			 *  MOVE/CHMOV in target role (absolute address)</span>
<span class="cm">			 */</span>
			<span class="n">opcode</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="mh">0x20000000</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">features</span> <span class="o">&amp;</span> <span class="n">FE_WIDE</span><span class="p">))</span>
				<span class="n">opcode</span> <span class="o">=</span> <span class="p">(</span><span class="n">opcode</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">OPC_TCHMOVE</span><span class="p">);</span>
			<span class="n">relocs</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="mh">0x3</span>:
			<span class="cm">/*</span>
<span class="cm">			 *  MOVE/CHMOV in target role (table indirect)</span>
<span class="cm">			 */</span>
			<span class="n">opcode</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="mh">0x20000000</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">features</span> <span class="o">&amp;</span> <span class="n">FE_WIDE</span><span class="p">))</span>
				<span class="n">opcode</span> <span class="o">=</span> <span class="p">(</span><span class="n">opcode</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">OPC_TCHMOVE</span><span class="p">);</span>
			<span class="n">relocs</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
<span class="cp">#endif</span>
		<span class="k">case</span> <span class="mh">0x8</span>:
			<span class="cm">/*</span>
<span class="cm">			 *  JUMP / CALL</span>
<span class="cm">			 *  don&#39;t relocate if relative :-)</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">opcode</span> <span class="o">&amp;</span> <span class="mh">0x00800000</span><span class="p">)</span>
				<span class="n">relocs</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">opcode</span> <span class="o">&amp;</span> <span class="mh">0xf8400000</span><span class="p">)</span> <span class="o">==</span> <span class="mh">0x80400000</span><span class="p">)</span><span class="cm">/*JUMP64*/</span>
				<span class="n">relocs</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
			<span class="k">else</span>
				<span class="n">relocs</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="mh">0x4</span>:
		<span class="k">case</span> <span class="mh">0x5</span>:
		<span class="k">case</span> <span class="mh">0x6</span>:
		<span class="k">case</span> <span class="mh">0x7</span>:
			<span class="n">relocs</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="nl">default:</span>
			<span class="n">relocs</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">};</span>

		<span class="cm">/*</span>
<span class="cm">		 *  Scriptify:) the opcode.</span>
<span class="cm">		 */</span>
		<span class="o">*</span><span class="n">cur</span><span class="o">++</span> <span class="o">=</span> <span class="n">cpu_to_scr</span><span class="p">(</span><span class="n">opcode</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 *  If no relocation, assume 1 argument </span>
<span class="cm">		 *  and just scriptize:) it.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">relocs</span><span class="p">)</span> <span class="p">{</span>
			<span class="o">*</span><span class="n">cur</span> <span class="o">=</span> <span class="n">cpu_to_scr</span><span class="p">(</span><span class="o">*</span><span class="n">cur</span><span class="p">);</span>
			<span class="o">++</span><span class="n">cur</span><span class="p">;</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 *  Otherwise performs all needed relocations.</span>
<span class="cm">		 */</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">relocs</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">old</span> <span class="o">=</span> <span class="o">*</span><span class="n">cur</span><span class="p">;</span>

			<span class="k">switch</span> <span class="p">(</span><span class="n">old</span> <span class="o">&amp;</span> <span class="n">RELOC_MASK</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">case</span> <span class="n">RELOC_REGISTER</span>:
				<span class="n">new</span> <span class="o">=</span> <span class="p">(</span><span class="n">old</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">RELOC_MASK</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">mmio_ba</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="k">case</span> <span class="n">RELOC_LABEL_A</span>:
				<span class="n">new</span> <span class="o">=</span> <span class="p">(</span><span class="n">old</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">RELOC_MASK</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">scripta_ba</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="k">case</span> <span class="n">RELOC_LABEL_B</span>:
				<span class="n">new</span> <span class="o">=</span> <span class="p">(</span><span class="n">old</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">RELOC_MASK</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">scriptb_ba</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="k">case</span> <span class="n">RELOC_SOFTC</span>:
				<span class="n">new</span> <span class="o">=</span> <span class="p">(</span><span class="n">old</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">RELOC_MASK</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">hcb_ba</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="k">case</span> <span class="mi">0</span>:
				<span class="cm">/*</span>
<span class="cm">				 *  Don&#39;t relocate a 0 address.</span>
<span class="cm">				 *  They are mostly used for patched or </span>
<span class="cm">				 *  script self-modified areas.</span>
<span class="cm">				 */</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">old</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">new</span> <span class="o">=</span> <span class="n">old</span><span class="p">;</span>
					<span class="k">break</span><span class="p">;</span>
				<span class="p">}</span>
				<span class="cm">/* fall through */</span>
			<span class="nl">default:</span>
				<span class="n">new</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
				<span class="n">panic</span><span class="p">(</span><span class="s">&quot;sym_fw_bind_script: &quot;</span>
				      <span class="s">&quot;weird relocation %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">old</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="o">*</span><span class="n">cur</span><span class="o">++</span> <span class="o">=</span> <span class="n">cpu_to_scr</span><span class="p">(</span><span class="n">new</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">};</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
