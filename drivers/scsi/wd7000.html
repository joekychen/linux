<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › scsi › wd7000.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>wd7000.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/* $Id: $</span>
<span class="cm"> *  linux/drivers/scsi/wd7000.c</span>
<span class="cm"> *</span>
<span class="cm"> *  Copyright (C) 1992  Thomas Wuensche</span>
<span class="cm"> *	closely related to the aha1542 driver from Tommy Thorn</span>
<span class="cm"> *	( as close as different hardware allows on a lowlevel-driver :-) )</span>
<span class="cm"> *</span>
<span class="cm"> *  Revised (and renamed) by John Boyd &lt;boyd@cis.ohio-state.edu&gt; to</span>
<span class="cm"> *  accommodate Eric Youngdale&#39;s modifications to scsi.c.  Nov 1992.</span>
<span class="cm"> *</span>
<span class="cm"> *  Additional changes to support scatter/gather.  Dec. 1992.  tw/jb</span>
<span class="cm"> *</span>
<span class="cm"> *  No longer tries to reset SCSI bus at boot (it wasn&#39;t working anyway).</span>
<span class="cm"> *  Rewritten to support multiple host adapters.</span>
<span class="cm"> *  Miscellaneous cleanup.</span>
<span class="cm"> *  So far, still doesn&#39;t do reset or abort correctly, since I have no idea</span>
<span class="cm"> *  how to do them with this board (8^(.                      Jan 1994 jb</span>
<span class="cm"> *</span>
<span class="cm"> * This driver now supports both of the two standard configurations (per</span>
<span class="cm"> * the 3.36 Owner&#39;s Manual, my latest reference) by the same method as</span>
<span class="cm"> * before; namely, by looking for a BIOS signature.  Thus, the location of</span>
<span class="cm"> * the BIOS signature determines the board configuration.  Until I have</span>
<span class="cm"> * time to do something more flexible, users should stick to one of the</span>
<span class="cm"> * following:</span>
<span class="cm"> *</span>
<span class="cm"> * Standard configuration for single-adapter systems:</span>
<span class="cm"> *    - BIOS at CE00h</span>
<span class="cm"> *    - I/O base address 350h</span>
<span class="cm"> *    - IRQ level 15</span>
<span class="cm"> *    - DMA channel 6</span>
<span class="cm"> * Standard configuration for a second adapter in a system:</span>
<span class="cm"> *    - BIOS at C800h</span>
<span class="cm"> *    - I/O base address 330h</span>
<span class="cm"> *    - IRQ level 11</span>
<span class="cm"> *    - DMA channel 5</span>
<span class="cm"> *</span>
<span class="cm"> * Anyone who can recompile the kernel is welcome to add others as need</span>
<span class="cm"> * arises, but unpredictable results may occur if there are conflicts.</span>
<span class="cm"> * In any event, if there are multiple adapters in a system, they MUST</span>
<span class="cm"> * use different I/O bases, IRQ levels, and DMA channels, since they will be</span>
<span class="cm"> * indistinguishable (and in direct conflict) otherwise.</span>
<span class="cm"> *</span>
<span class="cm"> *   As a point of information, the NO_OP command toggles the CMD_RDY bit</span>
<span class="cm"> * of the status port, and this fact could be used as a test for the I/O</span>
<span class="cm"> * base address (or more generally, board detection).  There is an interrupt</span>
<span class="cm"> * status port, so IRQ probing could also be done.  I suppose the full</span>
<span class="cm"> * DMA diagnostic could be used to detect the DMA channel being used.  I</span>
<span class="cm"> * haven&#39;t done any of this, though, because I think there&#39;s too much of</span>
<span class="cm"> * a chance that such explorations could be destructive, if some other</span>
<span class="cm"> * board&#39;s resources are used inadvertently.  So, call me a wimp, but I</span>
<span class="cm"> * don&#39;t want to try it.  The only kind of exploration I trust is memory</span>
<span class="cm"> * exploration, since it&#39;s more certain that reading memory won&#39;t be</span>
<span class="cm"> * destructive.</span>
<span class="cm"> *</span>
<span class="cm"> * More to my liking would be a LILO boot command line specification, such</span>
<span class="cm"> * as is used by the aha152x driver (and possibly others).  I&#39;ll look into</span>
<span class="cm"> * it, as I have time...</span>
<span class="cm"> *</span>
<span class="cm"> *   I get mail occasionally from people who either are using or are</span>
<span class="cm"> * considering using a WD7000 with Linux.  There is a variety of</span>
<span class="cm"> * nomenclature describing WD7000&#39;s.  To the best of my knowledge, the</span>
<span class="cm"> * following is a brief summary (from an old WD doc - I don&#39;t work for</span>
<span class="cm"> * them or anything like that):</span>
<span class="cm"> *</span>
<span class="cm"> * WD7000-FASST2: This is a WD7000 board with the real-mode SST ROM BIOS</span>
<span class="cm"> *        installed.  Last I heard, the BIOS was actually done by Columbia</span>
<span class="cm"> *        Data Products.  The BIOS is only used by this driver (and thus</span>
<span class="cm"> *        by Linux) to identify the board; none of it can be executed under</span>
<span class="cm"> *        Linux.</span>
<span class="cm"> *</span>
<span class="cm"> * WD7000-ASC: This is the original adapter board, with or without BIOS.</span>
<span class="cm"> *        The board uses a WD33C93 or WD33C93A SBIC, which in turn is</span>
<span class="cm"> *        controlled by an onboard Z80 processor.  The board interface</span>
<span class="cm"> *        visible to the host CPU is defined effectively by the Z80&#39;s</span>
<span class="cm"> *        firmware, and it is this firmware&#39;s revision level that is</span>
<span class="cm"> *        determined and reported by this driver.  (The version of the</span>
<span class="cm"> *        on-board BIOS is of no interest whatsoever.)  The host CPU has</span>
<span class="cm"> *        no access to the SBIC; hence the fact that it is a WD33C93 is</span>
<span class="cm"> *        also of no interest to this driver.</span>
<span class="cm"> *</span>
<span class="cm"> * WD7000-AX:</span>
<span class="cm"> * WD7000-MX:</span>
<span class="cm"> * WD7000-EX: These are newer versions of the WD7000-ASC.  The -ASC is</span>
<span class="cm"> *        largely built from discrete components; these boards use more</span>
<span class="cm"> *        integration.  The -AX is an ISA bus board (like the -ASC),</span>
<span class="cm"> *        the -MX is an MCA (i.e., PS/2) bus board), and the -EX is an</span>
<span class="cm"> *        EISA bus board.</span>
<span class="cm"> *</span>
<span class="cm"> *  At the time of my documentation, the -?X boards were &quot;future&quot; products,</span>
<span class="cm"> *  and were not yet available.  However, I vaguely recall that Thomas</span>
<span class="cm"> *  Wuensche had an -AX, so I believe at least it is supported by this</span>
<span class="cm"> *  driver.  I have no personal knowledge of either -MX or -EX boards.</span>
<span class="cm"> *</span>
<span class="cm"> *  P.S. Just recently, I&#39;ve discovered (directly from WD and Future</span>
<span class="cm"> *  Domain) that all but the WD7000-EX have been out of production for</span>
<span class="cm"> *  two years now.  FD has production rights to the 7000-EX, and are</span>
<span class="cm"> *  producing it under a new name, and with a new BIOS.  If anyone has</span>
<span class="cm"> *  one of the FD boards, it would be nice to come up with a signature</span>
<span class="cm"> *  for it.</span>
<span class="cm"> *                                                           J.B. Jan 1994.</span>
<span class="cm"> *</span>
<span class="cm"> *</span>
<span class="cm"> *  Revisions by Miroslav Zagorac &lt;zaga@fly.cc.fer.hr&gt;</span>
<span class="cm"> *</span>
<span class="cm"> *  08/24/1996.</span>
<span class="cm"> *</span>
<span class="cm"> *  Enhancement for wd7000_detect function has been made, so you don&#39;t have</span>
<span class="cm"> *  to enter BIOS ROM address in initialisation data (see struct Config).</span>
<span class="cm"> *  We cannot detect IRQ, DMA and I/O base address for now, so we have to</span>
<span class="cm"> *  enter them as arguments while wd_7000 is detected. If someone has IRQ,</span>
<span class="cm"> *  DMA or I/O base address set to some other value, he can enter them in</span>
<span class="cm"> *  configuration without any problem. Also I wrote a function wd7000_setup,</span>
<span class="cm"> *  so now you can enter WD-7000 definition as kernel arguments,</span>
<span class="cm"> *  as in lilo.conf:</span>
<span class="cm"> *</span>
<span class="cm"> *     append=&quot;wd7000=IRQ,DMA,IO&quot;</span>
<span class="cm"> *</span>
<span class="cm"> *  PS: If card BIOS ROM is disabled, function wd7000_detect now will recognize</span>
<span class="cm"> *      adapter, unlike the old one. Anyway, BIOS ROM from WD7000 adapter is</span>
<span class="cm"> *      useless for Linux. B^)</span>
<span class="cm"> *</span>
<span class="cm"> *</span>
<span class="cm"> *  09/06/1996.</span>
<span class="cm"> *</span>
<span class="cm"> *  Autodetecting of I/O base address from wd7000_detect function is removed,</span>
<span class="cm"> *  some little bugs removed, etc...</span>
<span class="cm"> *</span>
<span class="cm"> *  Thanks to Roger Scott for driver debugging.</span>
<span class="cm"> *</span>
<span class="cm"> *  06/07/1997</span>
<span class="cm"> *</span>
<span class="cm"> *  Added support for /proc file system (/proc/scsi/wd7000/[0...] files).</span>
<span class="cm"> *  Now, driver can handle hard disks with capacity &gt;1GB.</span>
<span class="cm"> *</span>
<span class="cm"> *  01/15/1998</span>
<span class="cm"> *</span>
<span class="cm"> *  Added support for BUS_ON and BUS_OFF parameters in config line.</span>
<span class="cm"> *  Miscellaneous cleanup.</span>
<span class="cm"> *</span>
<span class="cm"> *  03/01/1998</span>
<span class="cm"> *</span>
<span class="cm"> *  WD7000 driver now work on kernels &gt;= 2.1.x</span>
<span class="cm"> *</span>
<span class="cm"> *</span>
<span class="cm"> * 12/31/2001 - Arnaldo Carvalho de Melo &lt;acme@conectiva.com.br&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * use host-&gt;host_lock, not io_request_lock, cleanups</span>
<span class="cm"> *</span>
<span class="cm"> * 2002/10/04 - Alan Cox &lt;alan@lxorguk.ukuu.org.uk&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * Use dev_id for interrupts, kill __func__ pasting</span>
<span class="cm"> * Add a lock for the scb pool, clean up all other cli/sti usage stuff</span>
<span class="cm"> * Use the adapter lock for the other places we had the cli&#39;s</span>
<span class="cm"> *</span>
<span class="cm"> * 2002/10/06 - Alan Cox &lt;alan@lxorguk.ukuu.org.uk&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * Switch to new style error handling</span>
<span class="cm"> * Clean up delay to udelay, and yielding sleeps</span>
<span class="cm"> * Make host reset actually reset the card</span>
<span class="cm"> * Make everything static</span>
<span class="cm"> *</span>
<span class="cm"> * 2003/02/12 - Christoph Hellwig &lt;hch@infradead.org&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * Cleaned up host template definition</span>
<span class="cm"> * Removed now obsolete wd7000.h</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/delay.h&gt;</span>
<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/interrupt.h&gt;</span>
<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/types.h&gt;</span>
<span class="cp">#include &lt;linux/string.h&gt;</span>
<span class="cp">#include &lt;linux/spinlock.h&gt;</span>
<span class="cp">#include &lt;linux/ioport.h&gt;</span>
<span class="cp">#include &lt;linux/proc_fs.h&gt;</span>
<span class="cp">#include &lt;linux/blkdev.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/stat.h&gt;</span>
<span class="cp">#include &lt;linux/io.h&gt;</span>

<span class="cp">#include &lt;asm/dma.h&gt;</span>

<span class="cp">#include &lt;scsi/scsi.h&gt;</span>
<span class="cp">#include &lt;scsi/scsi_cmnd.h&gt;</span>
<span class="cp">#include &lt;scsi/scsi_device.h&gt;</span>
<span class="cp">#include &lt;scsi/scsi_host.h&gt;</span>
<span class="cp">#include &lt;scsi/scsicam.h&gt;</span>


<span class="cp">#undef  WD7000_DEBUG		</span><span class="cm">/* general debug                */</span><span class="cp"></span>
<span class="cp">#ifdef WD7000_DEBUG</span>
<span class="cp">#define dprintk printk</span>
<span class="cp">#else</span>
<span class="cp">#define dprintk(format,args...)</span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> *  Mailbox structure sizes.</span>
<span class="cm"> *  I prefer to keep the number of ICMBs much larger than the number of</span>
<span class="cm"> *  OGMBs.  OGMBs are used very quickly by the driver to start one or</span>
<span class="cm"> *  more commands, while ICMBs are used by the host adapter per command.</span>
<span class="cm"> */</span>
<span class="cp">#define OGMB_CNT	16</span>
<span class="cp">#define ICMB_CNT	32</span>

<span class="cm">/*</span>
<span class="cm"> *  Scb&#39;s are shared by all active adapters.  So, if they all become busy,</span>
<span class="cm"> *  callers may be made to wait in alloc_scbs for them to free.  That can</span>
<span class="cm"> *  be avoided by setting MAX_SCBS to NUM_CONFIG * WD7000_Q.  If you&#39;d</span>
<span class="cm"> *  rather conserve memory, use a smaller number (&gt; 0, of course) - things</span>
<span class="cm"> *  will should still work OK.</span>
<span class="cm"> */</span>
<span class="cp">#define MAX_SCBS        32</span>

<span class="cm">/*</span>
<span class="cm"> *  In this version, sg_tablesize now defaults to WD7000_SG, and will</span>
<span class="cm"> *  be set to SG_NONE for older boards.  This is the reverse of the</span>
<span class="cm"> *  previous default, and was changed so that the driver-level</span>
<span class="cm"> *  scsi_host_template would reflect the driver&#39;s support for scatter/</span>
<span class="cm"> *  gather.</span>
<span class="cm"> *</span>
<span class="cm"> *  Also, it has been reported that boards at Revision 6 support scatter/</span>
<span class="cm"> *  gather, so the new definition of an &quot;older&quot; board has been changed</span>
<span class="cm"> *  accordingly.</span>
<span class="cm"> */</span>
<span class="cp">#define WD7000_Q	16</span>
<span class="cp">#define WD7000_SG	16</span>


<span class="cm">/*</span>
<span class="cm"> *  WD7000-specific mailbox structure</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">volatile</span> <span class="k">struct</span> <span class="n">mailbox</span> <span class="p">{</span>
	<span class="n">unchar</span> <span class="n">status</span><span class="p">;</span>
	<span class="n">unchar</span> <span class="n">scbptr</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>	<span class="cm">/* SCSI-style - MSB first (big endian) */</span>
<span class="p">}</span> <span class="n">Mailbox</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> *  This structure should contain all per-adapter global data.  I.e., any</span>
<span class="cm"> *  new global per-adapter data should put in here.</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">adapter</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">sh</span><span class="p">;</span>	<span class="cm">/* Pointer to Scsi_Host structure    */</span>
	<span class="kt">int</span> <span class="n">iobase</span><span class="p">;</span>		<span class="cm">/* This adapter&#39;s I/O base address   */</span>
	<span class="kt">int</span> <span class="n">irq</span><span class="p">;</span>		<span class="cm">/* This adapter&#39;s IRQ level          */</span>
	<span class="kt">int</span> <span class="n">dma</span><span class="p">;</span>		<span class="cm">/* This adapter&#39;s DMA channel        */</span>
	<span class="kt">int</span> <span class="n">int_counter</span><span class="p">;</span>	<span class="cm">/* This adapter&#39;s interrupt counter  */</span>
	<span class="kt">int</span> <span class="n">bus_on</span><span class="p">;</span>		<span class="cm">/* This adapter&#39;s BUS_ON time        */</span>
	<span class="kt">int</span> <span class="n">bus_off</span><span class="p">;</span>		<span class="cm">/* This adapter&#39;s BUS_OFF time       */</span>
	<span class="k">struct</span> <span class="p">{</span>		<span class="cm">/* This adapter&#39;s mailboxes          */</span>
		<span class="n">Mailbox</span> <span class="n">ogmb</span><span class="p">[</span><span class="n">OGMB_CNT</span><span class="p">];</span>	<span class="cm">/* Outgoing mailboxes                */</span>
		<span class="n">Mailbox</span> <span class="n">icmb</span><span class="p">[</span><span class="n">ICMB_CNT</span><span class="p">];</span>	<span class="cm">/* Incoming mailboxes                */</span>
	<span class="p">}</span> <span class="n">mb</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">next_ogmb</span><span class="p">;</span>		<span class="cm">/* to reduce contention at mailboxes */</span>
	<span class="n">unchar</span> <span class="n">control</span><span class="p">;</span>		<span class="cm">/* shadows CONTROL port value        */</span>
	<span class="n">unchar</span> <span class="n">rev1</span><span class="p">,</span> <span class="n">rev2</span><span class="p">;</span>	<span class="cm">/* filled in by wd7000_revision      */</span>
<span class="p">}</span> <span class="n">Adapter</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * (linear) base address for ROM BIOS</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">const</span> <span class="kt">long</span> <span class="n">wd7000_biosaddr</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="mh">0xc0000</span><span class="p">,</span> <span class="mh">0xc2000</span><span class="p">,</span> <span class="mh">0xc4000</span><span class="p">,</span> <span class="mh">0xc6000</span><span class="p">,</span> <span class="mh">0xc8000</span><span class="p">,</span> <span class="mh">0xca000</span><span class="p">,</span> <span class="mh">0xcc000</span><span class="p">,</span> <span class="mh">0xce000</span><span class="p">,</span>
	<span class="mh">0xd0000</span><span class="p">,</span> <span class="mh">0xd2000</span><span class="p">,</span> <span class="mh">0xd4000</span><span class="p">,</span> <span class="mh">0xd6000</span><span class="p">,</span> <span class="mh">0xd8000</span><span class="p">,</span> <span class="mh">0xda000</span><span class="p">,</span> <span class="mh">0xdc000</span><span class="p">,</span> <span class="mh">0xde000</span>
<span class="p">};</span>
<span class="cp">#define NUM_ADDRS ARRAY_SIZE(wd7000_biosaddr)</span>

<span class="k">static</span> <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">wd7000_iobase</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="mh">0x0300</span><span class="p">,</span> <span class="mh">0x0308</span><span class="p">,</span> <span class="mh">0x0310</span><span class="p">,</span> <span class="mh">0x0318</span><span class="p">,</span> <span class="mh">0x0320</span><span class="p">,</span> <span class="mh">0x0328</span><span class="p">,</span> <span class="mh">0x0330</span><span class="p">,</span> <span class="mh">0x0338</span><span class="p">,</span>
	<span class="mh">0x0340</span><span class="p">,</span> <span class="mh">0x0348</span><span class="p">,</span> <span class="mh">0x0350</span><span class="p">,</span> <span class="mh">0x0358</span><span class="p">,</span> <span class="mh">0x0360</span><span class="p">,</span> <span class="mh">0x0368</span><span class="p">,</span> <span class="mh">0x0370</span><span class="p">,</span> <span class="mh">0x0378</span><span class="p">,</span>
	<span class="mh">0x0380</span><span class="p">,</span> <span class="mh">0x0388</span><span class="p">,</span> <span class="mh">0x0390</span><span class="p">,</span> <span class="mh">0x0398</span><span class="p">,</span> <span class="mh">0x03a0</span><span class="p">,</span> <span class="mh">0x03a8</span><span class="p">,</span> <span class="mh">0x03b0</span><span class="p">,</span> <span class="mh">0x03b8</span><span class="p">,</span>
	<span class="mh">0x03c0</span><span class="p">,</span> <span class="mh">0x03c8</span><span class="p">,</span> <span class="mh">0x03d0</span><span class="p">,</span> <span class="mh">0x03d8</span><span class="p">,</span> <span class="mh">0x03e0</span><span class="p">,</span> <span class="mh">0x03e8</span><span class="p">,</span> <span class="mh">0x03f0</span><span class="p">,</span> <span class="mh">0x03f8</span>
<span class="p">};</span>
<span class="cp">#define NUM_IOPORTS ARRAY_SIZE(wd7000_iobase)</span>

<span class="k">static</span> <span class="k">const</span> <span class="kt">short</span> <span class="n">wd7000_irq</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">14</span><span class="p">,</span> <span class="mi">15</span> <span class="p">};</span>
<span class="cp">#define NUM_IRQS ARRAY_SIZE(wd7000_irq)</span>

<span class="k">static</span> <span class="k">const</span> <span class="kt">short</span> <span class="n">wd7000_dma</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span> <span class="p">};</span>
<span class="cp">#define NUM_DMAS ARRAY_SIZE(wd7000_dma)</span>

<span class="cm">/*</span>
<span class="cm"> * The following is set up by wd7000_detect, and used thereafter for</span>
<span class="cm"> * proc and other global ookups</span>
<span class="cm"> */</span>

<span class="cp">#define UNITS	8</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">wd7000_host</span><span class="p">[</span><span class="n">UNITS</span><span class="p">];</span>

<span class="cp">#define BUS_ON    64		</span><span class="cm">/* x 125ns = 8000ns (BIOS default) */</span><span class="cp"></span>
<span class="cp">#define BUS_OFF   15		</span><span class="cm">/* x 125ns = 1875ns (BIOS default) */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> *  Standard Adapter Configurations - used by wd7000_detect</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="kt">short</span> <span class="n">irq</span><span class="p">;</span>		<span class="cm">/* IRQ level                                  */</span>
	<span class="kt">short</span> <span class="n">dma</span><span class="p">;</span>		<span class="cm">/* DMA channel                                */</span>
	<span class="kt">unsigned</span> <span class="n">iobase</span><span class="p">;</span>	<span class="cm">/* I/O base address                           */</span>
	<span class="kt">short</span> <span class="n">bus_on</span><span class="p">;</span>		<span class="cm">/* Time that WD7000 spends on the AT-bus when */</span>
	<span class="cm">/* transferring data. BIOS default is 8000ns. */</span>
	<span class="kt">short</span> <span class="n">bus_off</span><span class="p">;</span>		<span class="cm">/* Time that WD7000 spends OFF THE BUS after  */</span>
	<span class="cm">/* while it is transferring data.             */</span>
	<span class="cm">/* BIOS default is 1875ns                     */</span>
<span class="p">}</span> <span class="n">Config</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * Add here your configuration...</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">Config</span> <span class="n">configs</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">{</span><span class="mi">15</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mh">0x350</span><span class="p">,</span> <span class="n">BUS_ON</span><span class="p">,</span> <span class="n">BUS_OFF</span><span class="p">},</span>	<span class="cm">/* defaults for single adapter */</span>
	<span class="p">{</span><span class="mi">11</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mh">0x320</span><span class="p">,</span> <span class="n">BUS_ON</span><span class="p">,</span> <span class="n">BUS_OFF</span><span class="p">},</span>	<span class="cm">/* defaults for second adapter */</span>
	<span class="p">{</span><span class="mi">7</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mh">0x350</span><span class="p">,</span> <span class="n">BUS_ON</span><span class="p">,</span> <span class="n">BUS_OFF</span><span class="p">},</span>	<span class="cm">/* My configuration (Zaga)     */</span>
	<span class="p">{</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mh">0x0</span><span class="p">,</span> <span class="n">BUS_ON</span><span class="p">,</span> <span class="n">BUS_OFF</span><span class="p">}</span>	<span class="cm">/* Empty slot                  */</span>
<span class="p">};</span>
<span class="cp">#define NUM_CONFIGS ARRAY_SIZE(configs)</span>

<span class="cm">/*</span>
<span class="cm"> *  The following list defines strings to look for in the BIOS that identify</span>
<span class="cm"> *  it as the WD7000-FASST2 SST BIOS.  I suspect that something should be</span>
<span class="cm"> *  added for the Future Domain version.</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">signature</span> <span class="p">{</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">sig</span><span class="p">;</span>	<span class="cm">/* String to look for            */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ofs</span><span class="p">;</span>	<span class="cm">/* offset from BIOS base address */</span>
	<span class="kt">unsigned</span> <span class="n">len</span><span class="p">;</span>		<span class="cm">/* length of string              */</span>
<span class="p">}</span> <span class="n">Signature</span><span class="p">;</span>

<span class="k">static</span> <span class="k">const</span> <span class="n">Signature</span> <span class="n">signatures</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">{</span><span class="s">&quot;SSTBIOS&quot;</span><span class="p">,</span> <span class="mh">0x0000d</span><span class="p">,</span> <span class="mi">7</span><span class="p">}</span>	<span class="cm">/* &quot;SSTBIOS&quot; @ offset 0x0000d */</span>
<span class="p">};</span>
<span class="cp">#define NUM_SIGNATURES ARRAY_SIZE(signatures)</span>


<span class="cm">/*</span>
<span class="cm"> *  I/O Port Offsets and Bit Definitions</span>
<span class="cm"> *  4 addresses are used.  Those not defined here are reserved.</span>
<span class="cm"> */</span>
<span class="cp">#define ASC_STAT        0	</span><span class="cm">/* Status,  Read          */</span><span class="cp"></span>
<span class="cp">#define ASC_COMMAND     0	</span><span class="cm">/* Command, Write         */</span><span class="cp"></span>
<span class="cp">#define ASC_INTR_STAT   1	</span><span class="cm">/* Interrupt Status, Read */</span><span class="cp"></span>
<span class="cp">#define ASC_INTR_ACK    1	</span><span class="cm">/* Acknowledge, Write     */</span><span class="cp"></span>
<span class="cp">#define ASC_CONTROL     2	</span><span class="cm">/* Control, Write         */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * ASC Status Port</span>
<span class="cm"> */</span>
<span class="cp">#define INT_IM		0x80	</span><span class="cm">/* Interrupt Image Flag           */</span><span class="cp"></span>
<span class="cp">#define CMD_RDY		0x40	</span><span class="cm">/* Command Port Ready             */</span><span class="cp"></span>
<span class="cp">#define CMD_REJ		0x20	</span><span class="cm">/* Command Port Byte Rejected     */</span><span class="cp"></span>
<span class="cp">#define ASC_INIT        0x10	</span><span class="cm">/* ASC Initialized Flag           */</span><span class="cp"></span>
<span class="cp">#define ASC_STATMASK    0xf0	</span><span class="cm">/* The lower 4 Bytes are reserved */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * COMMAND opcodes</span>
<span class="cm"> *</span>
<span class="cm"> *  Unfortunately, I have no idea how to properly use some of these commands,</span>
<span class="cm"> *  as the OEM manual does not make it clear.  I have not been able to use</span>
<span class="cm"> *  enable/disable unsolicited interrupts or the reset commands with any</span>
<span class="cm"> *  discernible effect whatsoever.  I think they may be related to certain</span>
<span class="cm"> *  ICB commands, but again, the OEM manual doesn&#39;t make that clear.</span>
<span class="cm"> */</span>
<span class="cp">#define NO_OP             0	</span><span class="cm">/* NO-OP toggles CMD_RDY bit in ASC_STAT  */</span><span class="cp"></span>
<span class="cp">#define INITIALIZATION    1	</span><span class="cm">/* initialization (10 bytes)              */</span><span class="cp"></span>
<span class="cp">#define DISABLE_UNS_INTR  2	</span><span class="cm">/* disable unsolicited interrupts         */</span><span class="cp"></span>
<span class="cp">#define ENABLE_UNS_INTR   3	</span><span class="cm">/* enable unsolicited interrupts          */</span><span class="cp"></span>
<span class="cp">#define INTR_ON_FREE_OGMB 4	</span><span class="cm">/* interrupt on free OGMB                 */</span><span class="cp"></span>
<span class="cp">#define SOFT_RESET        5	</span><span class="cm">/* SCSI bus soft reset                    */</span><span class="cp"></span>
<span class="cp">#define HARD_RESET_ACK    6	</span><span class="cm">/* SCSI bus hard reset acknowledge        */</span><span class="cp"></span>
<span class="cp">#define START_OGMB        0x80	</span><span class="cm">/* start command in OGMB (n)              */</span><span class="cp"></span>
<span class="cp">#define SCAN_OGMBS        0xc0	</span><span class="cm">/* start multiple commands, signature (n) */</span><span class="cp"></span>
				<span class="cm">/*    where (n) = lower 6 bits            */</span>
<span class="cm">/*</span>
<span class="cm"> * For INITIALIZATION:</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">initCmd</span> <span class="p">{</span>
	<span class="n">unchar</span> <span class="n">op</span><span class="p">;</span>		<span class="cm">/* command opcode (= 1)                    */</span>
	<span class="n">unchar</span> <span class="n">ID</span><span class="p">;</span>		<span class="cm">/* Adapter&#39;s SCSI ID                       */</span>
	<span class="n">unchar</span> <span class="n">bus_on</span><span class="p">;</span>		<span class="cm">/* Bus on time, x 125ns (see below)        */</span>
	<span class="n">unchar</span> <span class="n">bus_off</span><span class="p">;</span>		<span class="cm">/* Bus off time, &quot;&quot;         &quot;&quot;             */</span>
	<span class="n">unchar</span> <span class="n">rsvd</span><span class="p">;</span>		<span class="cm">/* Reserved                                */</span>
	<span class="n">unchar</span> <span class="n">mailboxes</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>	<span class="cm">/* Address of Mailboxes, MSB first         */</span>
	<span class="n">unchar</span> <span class="n">ogmbs</span><span class="p">;</span>		<span class="cm">/* Number of outgoing MBs, max 64, 0,1 = 1 */</span>
	<span class="n">unchar</span> <span class="n">icmbs</span><span class="p">;</span>		<span class="cm">/* Number of incoming MBs,   &quot;&quot;       &quot;&quot;   */</span>
<span class="p">}</span> <span class="n">InitCmd</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * Interrupt Status Port - also returns diagnostic codes at ASC reset</span>
<span class="cm"> *</span>
<span class="cm"> * if msb is zero, the lower bits are diagnostic status</span>
<span class="cm"> * Diagnostics:</span>
<span class="cm"> * 01   No diagnostic error occurred</span>
<span class="cm"> * 02   RAM failure</span>
<span class="cm"> * 03   FIFO R/W failed</span>
<span class="cm"> * 04   SBIC register read/write failed</span>
<span class="cm"> * 05   Initialization D-FF failed</span>
<span class="cm"> * 06   Host IRQ D-FF failed</span>
<span class="cm"> * 07   ROM checksum error</span>
<span class="cm"> * Interrupt status (bitwise):</span>
<span class="cm"> * 10NNNNNN   outgoing mailbox NNNNNN is free</span>
<span class="cm"> * 11NNNNNN   incoming mailbox NNNNNN needs service</span>
<span class="cm"> */</span>
<span class="cp">#define MB_INTR    0xC0		</span><span class="cm">/* Mailbox Service possible/required */</span><span class="cp"></span>
<span class="cp">#define IMB_INTR   0x40		</span><span class="cm">/* 1 Incoming / 0 Outgoing           */</span><span class="cp"></span>
<span class="cp">#define MB_MASK    0x3f		</span><span class="cm">/* mask for mailbox number           */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * CONTROL port bits</span>
<span class="cm"> */</span>
<span class="cp">#define INT_EN     0x08		</span><span class="cm">/* Interrupt Enable */</span><span class="cp"></span>
<span class="cp">#define DMA_EN     0x04		</span><span class="cm">/* DMA Enable       */</span><span class="cp"></span>
<span class="cp">#define SCSI_RES   0x02		</span><span class="cm">/* SCSI Reset       */</span><span class="cp"></span>
<span class="cp">#define ASC_RES    0x01		</span><span class="cm">/* ASC Reset        */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * Driver data structures:</span>
<span class="cm"> *   - mb and scbs are required for interfacing with the host adapter.</span>
<span class="cm"> *     An SCB has extra fields not visible to the adapter; mb&#39;s</span>
<span class="cm"> *     _cannot_ do this, since the adapter assumes they are contiguous in</span>
<span class="cm"> *     memory, 4 bytes each, with ICMBs following OGMBs, and uses this fact</span>
<span class="cm"> *     to access them.</span>
<span class="cm"> *   - An icb is for host-only (non-SCSI) commands.  ICBs are 16 bytes each;</span>
<span class="cm"> *     the additional bytes are used only by the driver.</span>
<span class="cm"> *   - For now, a pool of SCBs are kept in global storage by this driver,</span>
<span class="cm"> *     and are allocated and freed as needed.</span>
<span class="cm"> *</span>
<span class="cm"> *  The 7000-FASST2 marks OGMBs empty as soon as it has _started_ a command,</span>
<span class="cm"> *  not when it has finished.  Since the SCB must be around for completion,</span>
<span class="cm"> *  problems arise when SCBs correspond to OGMBs, which may be reallocated</span>
<span class="cm"> *  earlier (or delayed unnecessarily until a command completes).</span>
<span class="cm"> *  Mailboxes are used as transient data structures, simply for</span>
<span class="cm"> *  carrying SCB addresses to/from the 7000-FASST2.</span>
<span class="cm"> *</span>
<span class="cm"> *  Note also since SCBs are not &quot;permanently&quot; associated with mailboxes,</span>
<span class="cm"> *  there is no need to keep a global list of scsi_cmnd pointers indexed</span>
<span class="cm"> *  by OGMB.   Again, SCBs reference their scsi_cmnds directly, so mailbox</span>
<span class="cm"> *  indices need not be involved.</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> *  WD7000-specific scatter/gather element structure</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">sgb</span> <span class="p">{</span>
	<span class="n">unchar</span> <span class="n">len</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
	<span class="n">unchar</span> <span class="n">ptr</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>		<span class="cm">/* Also SCSI-style - MSB first */</span>
<span class="p">}</span> <span class="n">Sgb</span><span class="p">;</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">scb</span> <span class="p">{</span>		<span class="cm">/* Command Control Block 5.4.1               */</span>
	<span class="n">unchar</span> <span class="n">op</span><span class="p">;</span>		<span class="cm">/* Command Control Block Operation Code      */</span>
	<span class="n">unchar</span> <span class="n">idlun</span><span class="p">;</span>		<span class="cm">/* op=0,2:Target Id, op=1:Initiator Id       */</span>
	<span class="cm">/* Outbound data transfer, length is checked */</span>
	<span class="cm">/* Inbound data transfer, length is checked  */</span>
	<span class="cm">/* Logical Unit Number                       */</span>
	<span class="n">unchar</span> <span class="n">cdb</span><span class="p">[</span><span class="mi">12</span><span class="p">];</span>		<span class="cm">/* SCSI Command Block                        */</span>
	<span class="k">volatile</span> <span class="n">unchar</span> <span class="n">status</span><span class="p">;</span>	<span class="cm">/* SCSI Return Status                        */</span>
	<span class="k">volatile</span> <span class="n">unchar</span> <span class="n">vue</span><span class="p">;</span>	<span class="cm">/* Vendor Unique Error Code                  */</span>
	<span class="n">unchar</span> <span class="n">maxlen</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>	<span class="cm">/* Maximum Data Transfer Length              */</span>
	<span class="n">unchar</span> <span class="n">dataptr</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>	<span class="cm">/* SCSI Data Block Pointer                   */</span>
	<span class="n">unchar</span> <span class="n">linkptr</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>	<span class="cm">/* Next Command Link Pointer                 */</span>
	<span class="n">unchar</span> <span class="n">direc</span><span class="p">;</span>		<span class="cm">/* Transfer Direction                        */</span>
	<span class="n">unchar</span> <span class="n">reserved2</span><span class="p">[</span><span class="mi">6</span><span class="p">];</span>	<span class="cm">/* SCSI Command Descriptor Block             */</span>
	<span class="cm">/* end of hardware SCB                       */</span>
	<span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="n">SCpnt</span><span class="p">;</span><span class="cm">/* scsi_cmnd using this SCB                  */</span>
	<span class="n">Sgb</span> <span class="n">sgb</span><span class="p">[</span><span class="n">WD7000_SG</span><span class="p">];</span>	<span class="cm">/* Scatter/gather list for this SCB          */</span>
	<span class="n">Adapter</span> <span class="o">*</span><span class="n">host</span><span class="p">;</span>		<span class="cm">/* host adapter                              */</span>
	<span class="k">struct</span> <span class="n">scb</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>	<span class="cm">/* for lists of scbs                         */</span>
<span class="p">}</span> <span class="n">Scb</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> *  This driver is written to allow host-only commands to be executed.</span>
<span class="cm"> *  These use a 16-byte block called an ICB.  The format is extended by the</span>
<span class="cm"> *  driver to 18 bytes, to support the status returned in the ICMB and</span>
<span class="cm"> *  an execution phase code.</span>
<span class="cm"> *</span>
<span class="cm"> *  There are other formats besides these; these are the ones I&#39;ve tried</span>
<span class="cm"> *  to use.  Formats for some of the defined ICB opcodes are not defined</span>
<span class="cm"> *  (notably, get/set unsolicited interrupt status) in my copy of the OEM</span>
<span class="cm"> *  manual, and others are ambiguous/hard to follow.</span>
<span class="cm"> */</span>
<span class="cp">#define ICB_OP_MASK           0x80	</span><span class="cm">/* distinguishes scbs from icbs        */</span><span class="cp"></span>
<span class="cp">#define ICB_OP_OPEN_RBUF      0x80	</span><span class="cm">/* open receive buffer                 */</span><span class="cp"></span>
<span class="cp">#define ICB_OP_RECV_CMD       0x81	</span><span class="cm">/* receive command from initiator      */</span><span class="cp"></span>
<span class="cp">#define ICB_OP_RECV_DATA      0x82	</span><span class="cm">/* receive data from initiator         */</span><span class="cp"></span>
<span class="cp">#define ICB_OP_RECV_SDATA     0x83	</span><span class="cm">/* receive data with status from init. */</span><span class="cp"></span>
<span class="cp">#define ICB_OP_SEND_DATA      0x84	</span><span class="cm">/* send data with status to initiator  */</span><span class="cp"></span>
<span class="cp">#define ICB_OP_SEND_STAT      0x86	</span><span class="cm">/* send command status to initiator    */</span><span class="cp"></span>
					<span class="cm">/* 0x87 is reserved                    */</span>
<span class="cp">#define ICB_OP_READ_INIT      0x88	</span><span class="cm">/* read initialization bytes           */</span><span class="cp"></span>
<span class="cp">#define ICB_OP_READ_ID        0x89	</span><span class="cm">/* read adapter&#39;s SCSI ID              */</span><span class="cp"></span>
<span class="cp">#define ICB_OP_SET_UMASK      0x8A	</span><span class="cm">/* set unsolicited interrupt mask      */</span><span class="cp"></span>
<span class="cp">#define ICB_OP_GET_UMASK      0x8B	</span><span class="cm">/* read unsolicited interrupt mask     */</span><span class="cp"></span>
<span class="cp">#define ICB_OP_GET_REVISION   0x8C	</span><span class="cm">/* read firmware revision level        */</span><span class="cp"></span>
<span class="cp">#define ICB_OP_DIAGNOSTICS    0x8D	</span><span class="cm">/* execute diagnostics                 */</span><span class="cp"></span>
<span class="cp">#define ICB_OP_SET_EPARMS     0x8E	</span><span class="cm">/* set execution parameters            */</span><span class="cp"></span>
<span class="cp">#define ICB_OP_GET_EPARMS     0x8F	</span><span class="cm">/* read execution parameters           */</span><span class="cp"></span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">icbRecvCmd</span> <span class="p">{</span>
	<span class="n">unchar</span> <span class="n">op</span><span class="p">;</span>
	<span class="n">unchar</span> <span class="n">IDlun</span><span class="p">;</span>		<span class="cm">/* Initiator SCSI ID/lun     */</span>
	<span class="n">unchar</span> <span class="n">len</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>		<span class="cm">/* command buffer length     */</span>
	<span class="n">unchar</span> <span class="n">ptr</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>		<span class="cm">/* command buffer address    */</span>
	<span class="n">unchar</span> <span class="n">rsvd</span><span class="p">[</span><span class="mi">7</span><span class="p">];</span>		<span class="cm">/* reserved                  */</span>
	<span class="k">volatile</span> <span class="n">unchar</span> <span class="n">vue</span><span class="p">;</span>	<span class="cm">/* vendor-unique error code  */</span>
	<span class="k">volatile</span> <span class="n">unchar</span> <span class="n">status</span><span class="p">;</span>	<span class="cm">/* returned (icmb) status    */</span>
	<span class="k">volatile</span> <span class="n">unchar</span> <span class="n">phase</span><span class="p">;</span>	<span class="cm">/* used by interrupt handler */</span>
<span class="p">}</span> <span class="n">IcbRecvCmd</span><span class="p">;</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">icbSendStat</span> <span class="p">{</span>
	<span class="n">unchar</span> <span class="n">op</span><span class="p">;</span>
	<span class="n">unchar</span> <span class="n">IDlun</span><span class="p">;</span>		<span class="cm">/* Target SCSI ID/lun                  */</span>
	<span class="n">unchar</span> <span class="n">stat</span><span class="p">;</span>		<span class="cm">/* (outgoing) completion status byte 1 */</span>
	<span class="n">unchar</span> <span class="n">rsvd</span><span class="p">[</span><span class="mi">12</span><span class="p">];</span>	<span class="cm">/* reserved                            */</span>
	<span class="k">volatile</span> <span class="n">unchar</span> <span class="n">vue</span><span class="p">;</span>	<span class="cm">/* vendor-unique error code            */</span>
	<span class="k">volatile</span> <span class="n">unchar</span> <span class="n">status</span><span class="p">;</span>	<span class="cm">/* returned (icmb) status              */</span>
	<span class="k">volatile</span> <span class="n">unchar</span> <span class="n">phase</span><span class="p">;</span>	<span class="cm">/* used by interrupt handler           */</span>
<span class="p">}</span> <span class="n">IcbSendStat</span><span class="p">;</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">icbRevLvl</span> <span class="p">{</span>
	<span class="n">unchar</span> <span class="n">op</span><span class="p">;</span>
	<span class="k">volatile</span> <span class="n">unchar</span> <span class="n">primary</span><span class="p">;</span>	<span class="cm">/* primary revision level (returned)   */</span>
	<span class="k">volatile</span> <span class="n">unchar</span> <span class="n">secondary</span><span class="p">;</span>	<span class="cm">/* secondary revision level (returned) */</span>
	<span class="n">unchar</span> <span class="n">rsvd</span><span class="p">[</span><span class="mi">12</span><span class="p">];</span>	<span class="cm">/* reserved                            */</span>
	<span class="k">volatile</span> <span class="n">unchar</span> <span class="n">vue</span><span class="p">;</span>	<span class="cm">/* vendor-unique error code            */</span>
	<span class="k">volatile</span> <span class="n">unchar</span> <span class="n">status</span><span class="p">;</span>	<span class="cm">/* returned (icmb) status              */</span>
	<span class="k">volatile</span> <span class="n">unchar</span> <span class="n">phase</span><span class="p">;</span>	<span class="cm">/* used by interrupt handler           */</span>
<span class="p">}</span> <span class="n">IcbRevLvl</span><span class="p">;</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">icbUnsMask</span> <span class="p">{</span>	<span class="cm">/* I&#39;m totally guessing here */</span>
	<span class="n">unchar</span> <span class="n">op</span><span class="p">;</span>
	<span class="k">volatile</span> <span class="n">unchar</span> <span class="n">mask</span><span class="p">[</span><span class="mi">14</span><span class="p">];</span>	<span class="cm">/* mask bits                 */</span>
<span class="cp">#if 0</span><span class="c"></span>
<span class="c">	unchar rsvd[12];	/* reserved                  */</span>
<span class="cp">#endif</span>
	<span class="k">volatile</span> <span class="n">unchar</span> <span class="n">vue</span><span class="p">;</span>	<span class="cm">/* vendor-unique error code  */</span>
	<span class="k">volatile</span> <span class="n">unchar</span> <span class="n">status</span><span class="p">;</span>	<span class="cm">/* returned (icmb) status    */</span>
	<span class="k">volatile</span> <span class="n">unchar</span> <span class="n">phase</span><span class="p">;</span>	<span class="cm">/* used by interrupt handler */</span>
<span class="p">}</span> <span class="n">IcbUnsMask</span><span class="p">;</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">icbDiag</span> <span class="p">{</span>
	<span class="n">unchar</span> <span class="n">op</span><span class="p">;</span>
	<span class="n">unchar</span> <span class="n">type</span><span class="p">;</span>		<span class="cm">/* diagnostics type code (0-3) */</span>
	<span class="n">unchar</span> <span class="n">len</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>		<span class="cm">/* buffer length               */</span>
	<span class="n">unchar</span> <span class="n">ptr</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>		<span class="cm">/* buffer address              */</span>
	<span class="n">unchar</span> <span class="n">rsvd</span><span class="p">[</span><span class="mi">7</span><span class="p">];</span>		<span class="cm">/* reserved                    */</span>
	<span class="k">volatile</span> <span class="n">unchar</span> <span class="n">vue</span><span class="p">;</span>	<span class="cm">/* vendor-unique error code    */</span>
	<span class="k">volatile</span> <span class="n">unchar</span> <span class="n">status</span><span class="p">;</span>	<span class="cm">/* returned (icmb) status      */</span>
	<span class="k">volatile</span> <span class="n">unchar</span> <span class="n">phase</span><span class="p">;</span>	<span class="cm">/* used by interrupt handler   */</span>
<span class="p">}</span> <span class="n">IcbDiag</span><span class="p">;</span>

<span class="cp">#define ICB_DIAG_POWERUP   0	</span><span class="cm">/* Power-up diags only       */</span><span class="cp"></span>
<span class="cp">#define ICB_DIAG_WALKING   1	</span><span class="cm">/* walking 1&#39;s pattern       */</span><span class="cp"></span>
<span class="cp">#define ICB_DIAG_DMA       2	</span><span class="cm">/* DMA - system memory diags */</span><span class="cp"></span>
<span class="cp">#define ICB_DIAG_FULL      3	</span><span class="cm">/* do both 1 &amp; 2             */</span><span class="cp"></span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">icbParms</span> <span class="p">{</span>
	<span class="n">unchar</span> <span class="n">op</span><span class="p">;</span>
	<span class="n">unchar</span> <span class="n">rsvd1</span><span class="p">;</span>		<span class="cm">/* reserved                  */</span>
	<span class="n">unchar</span> <span class="n">len</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>		<span class="cm">/* parms buffer length       */</span>
	<span class="n">unchar</span> <span class="n">ptr</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>		<span class="cm">/* parms buffer address      */</span>
	<span class="n">unchar</span> <span class="n">idx</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>		<span class="cm">/* index (MSB-LSB)           */</span>
	<span class="n">unchar</span> <span class="n">rsvd2</span><span class="p">[</span><span class="mi">5</span><span class="p">];</span>	<span class="cm">/* reserved                  */</span>
	<span class="k">volatile</span> <span class="n">unchar</span> <span class="n">vue</span><span class="p">;</span>	<span class="cm">/* vendor-unique error code  */</span>
	<span class="k">volatile</span> <span class="n">unchar</span> <span class="n">status</span><span class="p">;</span>	<span class="cm">/* returned (icmb) status    */</span>
	<span class="k">volatile</span> <span class="n">unchar</span> <span class="n">phase</span><span class="p">;</span>	<span class="cm">/* used by interrupt handler */</span>
<span class="p">}</span> <span class="n">IcbParms</span><span class="p">;</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">icbAny</span> <span class="p">{</span>
	<span class="n">unchar</span> <span class="n">op</span><span class="p">;</span>
	<span class="n">unchar</span> <span class="n">data</span><span class="p">[</span><span class="mi">14</span><span class="p">];</span>	<span class="cm">/* format-specific data      */</span>
	<span class="k">volatile</span> <span class="n">unchar</span> <span class="n">vue</span><span class="p">;</span>	<span class="cm">/* vendor-unique error code  */</span>
	<span class="k">volatile</span> <span class="n">unchar</span> <span class="n">status</span><span class="p">;</span>	<span class="cm">/* returned (icmb) status    */</span>
	<span class="k">volatile</span> <span class="n">unchar</span> <span class="n">phase</span><span class="p">;</span>	<span class="cm">/* used by interrupt handler */</span>
<span class="p">}</span> <span class="n">IcbAny</span><span class="p">;</span>

<span class="k">typedef</span> <span class="k">union</span> <span class="n">icb</span> <span class="p">{</span>
	<span class="n">unchar</span> <span class="n">op</span><span class="p">;</span>		<span class="cm">/* ICB opcode                     */</span>
	<span class="n">IcbRecvCmd</span> <span class="n">recv_cmd</span><span class="p">;</span>	<span class="cm">/* format for receive command     */</span>
	<span class="n">IcbSendStat</span> <span class="n">send_stat</span><span class="p">;</span>	<span class="cm">/* format for send status         */</span>
	<span class="n">IcbRevLvl</span> <span class="n">rev_lvl</span><span class="p">;</span>	<span class="cm">/* format for get revision level  */</span>
	<span class="n">IcbDiag</span> <span class="n">diag</span><span class="p">;</span>		<span class="cm">/* format for execute diagnostics */</span>
	<span class="n">IcbParms</span> <span class="n">eparms</span><span class="p">;</span>	<span class="cm">/* format for get/set exec parms  */</span>
	<span class="n">IcbAny</span> <span class="n">icb</span><span class="p">;</span>		<span class="cm">/* generic format                 */</span>
	<span class="n">unchar</span> <span class="n">data</span><span class="p">[</span><span class="mi">18</span><span class="p">];</span>
<span class="p">}</span> <span class="n">Icb</span><span class="p">;</span>

<span class="cp">#ifdef MODULE</span>
<span class="k">static</span> <span class="kt">char</span> <span class="o">*</span><span class="n">wd7000</span><span class="p">;</span>
<span class="n">module_param</span><span class="p">(</span><span class="n">wd7000</span><span class="p">,</span> <span class="n">charp</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> *  Driver SCB structure pool.</span>
<span class="cm"> *</span>
<span class="cm"> *  The SCBs declared here are shared by all host adapters; hence, this</span>
<span class="cm"> *  structure is not part of the Adapter structure.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">Scb</span> <span class="n">scbs</span><span class="p">[</span><span class="n">MAX_SCBS</span><span class="p">];</span>
<span class="k">static</span> <span class="n">Scb</span> <span class="o">*</span><span class="n">scbfree</span><span class="p">;</span>		<span class="cm">/* free list         */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">freescbs</span> <span class="o">=</span> <span class="n">MAX_SCBS</span><span class="p">;</span>	<span class="cm">/* free list counter */</span>
<span class="k">static</span> <span class="n">spinlock_t</span> <span class="n">scbpool_lock</span><span class="p">;</span>	<span class="cm">/* guards the scb free list and count */</span>

<span class="cm">/*</span>
<span class="cm"> *  END of data/declarations - code follows.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">__init</span> <span class="nf">setup_error</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">mesg</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">ints</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ints</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">3</span><span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;wd7000_setup: </span><span class="se">\&quot;</span><span class="s">wd7000=%d,%d,0x%x</span><span class="se">\&quot;</span><span class="s"> -&gt; %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ints</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">ints</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">ints</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">mesg</span><span class="p">);</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">ints</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">4</span><span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;wd7000_setup: </span><span class="se">\&quot;</span><span class="s">wd7000=%d,%d,0x%x,%d</span><span class="se">\&quot;</span><span class="s"> -&gt; %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ints</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">ints</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">ints</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">ints</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span> <span class="n">mesg</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;wd7000_setup: </span><span class="se">\&quot;</span><span class="s">wd7000=%d,%d,0x%x,%d,%d</span><span class="se">\&quot;</span><span class="s"> -&gt; %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ints</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">ints</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">ints</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">ints</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span> <span class="n">ints</span><span class="p">[</span><span class="mi">5</span><span class="p">],</span> <span class="n">mesg</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * Note: You can now set these options from the kernel&#39;s &quot;command line&quot;.</span>
<span class="cm"> * The syntax is:</span>
<span class="cm"> *</span>
<span class="cm"> *     wd7000=&lt;IRQ&gt;,&lt;DMA&gt;,&lt;IO&gt;[,&lt;BUS_ON&gt;[,&lt;BUS_OFF&gt;]]</span>
<span class="cm"> *</span>
<span class="cm"> * , where BUS_ON and BUS_OFF are in nanoseconds. BIOS default values</span>
<span class="cm"> * are 8000ns for BUS_ON and 1875ns for BUS_OFF.</span>
<span class="cm"> * eg:</span>
<span class="cm"> *     wd7000=7,6,0x350</span>
<span class="cm"> *</span>
<span class="cm"> * will configure the driver for a WD-7000 controller</span>
<span class="cm"> * using IRQ 15 with a DMA channel 6, at IO base address 0x350.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">wd7000_setup</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">static</span> <span class="kt">short</span> <span class="n">wd7000_card_num</span><span class="p">;</span>	<span class="cm">/* .bss will zero this */</span>
	<span class="kt">short</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ints</span><span class="p">[</span><span class="mi">6</span><span class="p">];</span>

	<span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="n">get_options</span><span class="p">(</span><span class="n">str</span><span class="p">,</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">ints</span><span class="p">),</span> <span class="n">ints</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">wd7000_card_num</span> <span class="o">&gt;=</span> <span class="n">NUM_CONFIGS</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;%s: Too many </span><span class="se">\&quot;</span><span class="s">wd7000=</span><span class="se">\&quot;</span><span class="s"> configurations in &quot;</span> <span class="s">&quot;command line!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">ints</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">ints</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">5</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;%s: Error in command line!  &quot;</span> <span class="s">&quot;Usage: wd7000=&lt;IRQ&gt;,&lt;DMA&gt;,IO&gt;[,&lt;BUS_ON&gt;&quot;</span> <span class="s">&quot;[,&lt;BUS_OFF&gt;]]</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">NUM_IRQS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ints</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">wd7000_irq</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
				<span class="k">break</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">NUM_IRQS</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">setup_error</span><span class="p">(</span><span class="s">&quot;invalid IRQ.&quot;</span><span class="p">,</span> <span class="n">ints</span><span class="p">);</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="n">configs</span><span class="p">[</span><span class="n">wd7000_card_num</span><span class="p">].</span><span class="n">irq</span> <span class="o">=</span> <span class="n">ints</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">NUM_DMAS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ints</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="n">wd7000_dma</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
				<span class="k">break</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">NUM_DMAS</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">setup_error</span><span class="p">(</span><span class="s">&quot;invalid DMA channel.&quot;</span><span class="p">,</span> <span class="n">ints</span><span class="p">);</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="n">configs</span><span class="p">[</span><span class="n">wd7000_card_num</span><span class="p">].</span><span class="n">dma</span> <span class="o">=</span> <span class="n">ints</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">NUM_IOPORTS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ints</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">==</span> <span class="n">wd7000_iobase</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
				<span class="k">break</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">NUM_IOPORTS</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">setup_error</span><span class="p">(</span><span class="s">&quot;invalid I/O base address.&quot;</span><span class="p">,</span> <span class="n">ints</span><span class="p">);</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="n">configs</span><span class="p">[</span><span class="n">wd7000_card_num</span><span class="p">].</span><span class="n">iobase</span> <span class="o">=</span> <span class="n">ints</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">ints</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">3</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">ints</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">500</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">ints</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">31875</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">setup_error</span><span class="p">(</span><span class="s">&quot;BUS_ON value is out of range (500&quot;</span> <span class="s">&quot; to 31875 nanoseconds)!&quot;</span><span class="p">,</span> <span class="n">ints</span><span class="p">);</span>
				<span class="n">configs</span><span class="p">[</span><span class="n">wd7000_card_num</span><span class="p">].</span><span class="n">bus_on</span> <span class="o">=</span> <span class="n">BUS_ON</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span>
				<span class="n">configs</span><span class="p">[</span><span class="n">wd7000_card_num</span><span class="p">].</span><span class="n">bus_on</span> <span class="o">=</span> <span class="n">ints</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">/</span> <span class="mi">125</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="n">configs</span><span class="p">[</span><span class="n">wd7000_card_num</span><span class="p">].</span><span class="n">bus_on</span> <span class="o">=</span> <span class="n">BUS_ON</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">ints</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">4</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">ints</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">500</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">ints</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">31875</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">setup_error</span><span class="p">(</span><span class="s">&quot;BUS_OFF value is out of range (500&quot;</span> <span class="s">&quot; to 31875 nanoseconds)!&quot;</span><span class="p">,</span> <span class="n">ints</span><span class="p">);</span>
				<span class="n">configs</span><span class="p">[</span><span class="n">wd7000_card_num</span><span class="p">].</span><span class="n">bus_off</span> <span class="o">=</span> <span class="n">BUS_OFF</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span>
				<span class="n">configs</span><span class="p">[</span><span class="n">wd7000_card_num</span><span class="p">].</span><span class="n">bus_off</span> <span class="o">=</span> <span class="n">ints</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">/</span> <span class="mi">125</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="n">configs</span><span class="p">[</span><span class="n">wd7000_card_num</span><span class="p">].</span><span class="n">bus_off</span> <span class="o">=</span> <span class="n">BUS_OFF</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">wd7000_card_num</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">wd7000_card_num</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
				<span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>

				<span class="k">for</span> <span class="p">(;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">wd7000_card_num</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
					<span class="k">if</span> <span class="p">(</span><span class="n">configs</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">irq</span> <span class="o">==</span> <span class="n">configs</span><span class="p">[</span><span class="n">j</span><span class="p">].</span><span class="n">irq</span><span class="p">)</span> <span class="p">{</span>
						<span class="n">setup_error</span><span class="p">(</span><span class="s">&quot;duplicated IRQ!&quot;</span><span class="p">,</span> <span class="n">ints</span><span class="p">);</span>
						<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
					<span class="p">}</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">configs</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">dma</span> <span class="o">==</span> <span class="n">configs</span><span class="p">[</span><span class="n">j</span><span class="p">].</span><span class="n">dma</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">setup_error</span><span class="p">(</span><span class="s">&quot;duplicated DMA &quot;</span> <span class="s">&quot;channel!&quot;</span><span class="p">,</span> <span class="n">ints</span><span class="p">);</span>
					<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
				<span class="p">}</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">configs</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">iobase</span> <span class="o">==</span> <span class="n">configs</span><span class="p">[</span><span class="n">j</span><span class="p">].</span><span class="n">iobase</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">setup_error</span><span class="p">(</span><span class="s">&quot;duplicated I/O &quot;</span> <span class="s">&quot;base address!&quot;</span><span class="p">,</span> <span class="n">ints</span><span class="p">);</span>
					<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
				<span class="p">}</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="n">dprintk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;wd7000_setup: IRQ=%d, DMA=%d, I/O=0x%x, &quot;</span>
			<span class="s">&quot;BUS_ON=%dns, BUS_OFF=%dns</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">configs</span><span class="p">[</span><span class="n">wd7000_card_num</span><span class="p">].</span><span class="n">irq</span><span class="p">,</span> <span class="n">configs</span><span class="p">[</span><span class="n">wd7000_card_num</span><span class="p">].</span><span class="n">dma</span><span class="p">,</span> <span class="n">configs</span><span class="p">[</span><span class="n">wd7000_card_num</span><span class="p">].</span><span class="n">iobase</span><span class="p">,</span> <span class="n">configs</span><span class="p">[</span><span class="n">wd7000_card_num</span><span class="p">].</span><span class="n">bus_on</span> <span class="o">*</span> <span class="mi">125</span><span class="p">,</span> <span class="n">configs</span><span class="p">[</span><span class="n">wd7000_card_num</span><span class="p">].</span><span class="n">bus_off</span> <span class="o">*</span> <span class="mi">125</span><span class="p">);</span>

		<span class="n">wd7000_card_num</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">__setup</span><span class="p">(</span><span class="s">&quot;wd7000=&quot;</span><span class="p">,</span> <span class="n">wd7000_setup</span><span class="p">);</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">any2scsi</span><span class="p">(</span><span class="n">unchar</span> <span class="o">*</span> <span class="n">scsi</span><span class="p">,</span> <span class="kt">int</span> <span class="n">any</span><span class="p">)</span>
<span class="p">{</span>
	<span class="o">*</span><span class="n">scsi</span><span class="o">++</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span><span class="p">)</span><span class="n">any</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">;</span>
	<span class="o">*</span><span class="n">scsi</span><span class="o">++</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span><span class="p">)</span><span class="n">any</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">;</span>
	<span class="o">*</span><span class="n">scsi</span><span class="o">++</span> <span class="o">=</span> <span class="n">any</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">scsi2int</span><span class="p">(</span><span class="n">unchar</span> <span class="o">*</span> <span class="n">scsi</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">scsi</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">scsi</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">|</span> <span class="n">scsi</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">wd7000_enable_intr</span><span class="p">(</span><span class="n">Adapter</span> <span class="o">*</span> <span class="n">host</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">host</span><span class="o">-&gt;</span><span class="n">control</span> <span class="o">|=</span> <span class="n">INT_EN</span><span class="p">;</span>
	<span class="n">outb</span><span class="p">(</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">control</span><span class="p">,</span> <span class="n">host</span><span class="o">-&gt;</span><span class="n">iobase</span> <span class="o">+</span> <span class="n">ASC_CONTROL</span><span class="p">);</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">wd7000_enable_dma</span><span class="p">(</span><span class="n">Adapter</span> <span class="o">*</span> <span class="n">host</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="n">host</span><span class="o">-&gt;</span><span class="n">control</span> <span class="o">|=</span> <span class="n">DMA_EN</span><span class="p">;</span>
	<span class="n">outb</span><span class="p">(</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">control</span><span class="p">,</span> <span class="n">host</span><span class="o">-&gt;</span><span class="n">iobase</span> <span class="o">+</span> <span class="n">ASC_CONTROL</span><span class="p">);</span>

	<span class="n">flags</span> <span class="o">=</span> <span class="n">claim_dma_lock</span><span class="p">();</span>
	<span class="n">set_dma_mode</span><span class="p">(</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">dma</span><span class="p">,</span> <span class="n">DMA_MODE_CASCADE</span><span class="p">);</span>
	<span class="n">enable_dma</span><span class="p">(</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">dma</span><span class="p">);</span>
	<span class="n">release_dma_lock</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>

<span class="p">}</span>


<span class="cp">#define WAITnexttimeout 200	</span><span class="cm">/* 2 seconds */</span><span class="cp"></span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">short</span> <span class="nf">WAIT</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">port</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">mask</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">allof</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">noneof</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="n">WAITbits</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">WAITtimeout</span> <span class="o">=</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="n">WAITnexttimeout</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">time_before_eq</span><span class="p">(</span><span class="n">jiffies</span><span class="p">,</span> <span class="n">WAITtimeout</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">WAITbits</span> <span class="o">=</span> <span class="n">inb</span><span class="p">(</span><span class="n">port</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">mask</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(((</span><span class="n">WAITbits</span> <span class="o">&amp;</span> <span class="n">allof</span><span class="p">)</span> <span class="o">==</span> <span class="n">allof</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">((</span><span class="n">WAITbits</span> <span class="o">&amp;</span> <span class="n">noneof</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span>
			<span class="k">return</span> <span class="p">(</span><span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">command_out</span><span class="p">(</span><span class="n">Adapter</span> <span class="o">*</span> <span class="n">host</span><span class="p">,</span> <span class="n">unchar</span> <span class="o">*</span> <span class="n">cmd</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">WAIT</span><span class="p">(</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">iobase</span> <span class="o">+</span> <span class="n">ASC_STAT</span><span class="p">,</span> <span class="n">ASC_STATMASK</span><span class="p">,</span> <span class="n">CMD_RDY</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">len</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">do</span> <span class="p">{</span>
				<span class="n">outb</span><span class="p">(</span><span class="o">*</span><span class="n">cmd</span><span class="p">,</span> <span class="n">host</span><span class="o">-&gt;</span><span class="n">iobase</span> <span class="o">+</span> <span class="n">ASC_COMMAND</span><span class="p">);</span>
				<span class="n">WAIT</span><span class="p">(</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">iobase</span> <span class="o">+</span> <span class="n">ASC_STAT</span><span class="p">,</span> <span class="n">ASC_STATMASK</span><span class="p">,</span> <span class="n">CMD_RDY</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
			<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">inb</span><span class="p">(</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">iobase</span> <span class="o">+</span> <span class="n">ASC_STAT</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">CMD_REJ</span><span class="p">);</span>

			<span class="n">cmd</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">return</span> <span class="p">(</span><span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;wd7000 command_out: WAIT failed(%d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">len</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>

	<span class="k">return</span> <span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> *  This version of alloc_scbs is in preparation for supporting multiple</span>
<span class="cm"> *  commands per lun and command chaining, by queueing pending commands.</span>
<span class="cm"> *  We will need to allocate Scbs in blocks since they will wait to be</span>
<span class="cm"> *  executed so there is the possibility of deadlock otherwise.</span>
<span class="cm"> *  Also, to keep larger requests from being starved by smaller requests,</span>
<span class="cm"> *  we limit access to this routine with an internal busy flag, so that</span>
<span class="cm"> *  the satisfiability of a request is not dependent on the size of the</span>
<span class="cm"> *  request.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">Scb</span> <span class="o">*</span><span class="nf">alloc_scbs</span><span class="p">(</span><span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">host</span><span class="p">,</span> <span class="kt">int</span> <span class="n">needed</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">Scb</span> <span class="o">*</span><span class="n">scb</span><span class="p">,</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">timeout</span> <span class="o">=</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="n">WAITnexttimeout</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">now</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">needed</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="p">(</span><span class="nb">NULL</span><span class="p">);</span>	<span class="cm">/* sanity check */</span>

	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>

      <span class="nl">retry:</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">freescbs</span> <span class="o">&lt;</span> <span class="n">needed</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">timeout</span> <span class="o">=</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="n">WAITnexttimeout</span><span class="p">;</span>
		<span class="k">do</span> <span class="p">{</span>
			<span class="cm">/* FIXME: can we actually just yield here ?? */</span>
			<span class="k">for</span> <span class="p">(</span><span class="n">now</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span> <span class="n">now</span> <span class="o">==</span> <span class="n">jiffies</span><span class="p">;)</span>
				<span class="n">cpu_relax</span><span class="p">();</span>	<span class="cm">/* wait a jiffy */</span>
		<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">freescbs</span> <span class="o">&lt;</span> <span class="n">needed</span> <span class="o">&amp;&amp;</span> <span class="n">time_before_eq</span><span class="p">(</span><span class="n">jiffies</span><span class="p">,</span> <span class="n">timeout</span><span class="p">));</span>
		<span class="cm">/*</span>
<span class="cm">		 *  If we get here with enough free Scbs, we can take them.</span>
<span class="cm">		 *  Otherwise, we timed out and didn&#39;t get enough.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">freescbs</span> <span class="o">&lt;</span> <span class="n">needed</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;wd7000: can&#39;t get enough free SCBs.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">return</span> <span class="p">(</span><span class="nb">NULL</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* Take the lock, then check we didn&#39;t get beaten, if so try again */</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">scbpool_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">freescbs</span> <span class="o">&lt;</span> <span class="n">needed</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">scbpool_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">retry</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">scb</span> <span class="o">=</span> <span class="n">scbfree</span><span class="p">;</span>
	<span class="n">freescbs</span> <span class="o">-=</span> <span class="n">needed</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">needed</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">p</span> <span class="o">=</span> <span class="n">scbfree</span><span class="p">;</span>
		<span class="n">scbfree</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">p</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">scbpool_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">scb</span><span class="p">);</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">free_scb</span><span class="p">(</span><span class="n">Scb</span> <span class="o">*</span> <span class="n">scb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">scbpool_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">memset</span><span class="p">(</span><span class="n">scb</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">Scb</span><span class="p">));</span>
	<span class="n">scb</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">scbfree</span><span class="p">;</span>
	<span class="n">scbfree</span> <span class="o">=</span> <span class="n">scb</span><span class="p">;</span>
	<span class="n">freescbs</span><span class="o">++</span><span class="p">;</span>

	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">scbpool_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">init_scbs</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">scbpool_lock</span><span class="p">);</span>

	<span class="cm">/* This is only ever called before the SCB pool is active */</span>

	<span class="n">scbfree</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">scbs</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">scbs</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">scbs</span><span class="p">));</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">MAX_SCBS</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">scbs</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">next</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">scbs</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]);</span>
		<span class="n">scbs</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">SCpnt</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">scbs</span><span class="p">[</span><span class="n">MAX_SCBS</span> <span class="o">-</span> <span class="mi">1</span><span class="p">].</span><span class="n">next</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">scbs</span><span class="p">[</span><span class="n">MAX_SCBS</span> <span class="o">-</span> <span class="mi">1</span><span class="p">].</span><span class="n">SCpnt</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">int</span> <span class="n">mail_out</span><span class="p">(</span><span class="n">Adapter</span> <span class="o">*</span> <span class="n">host</span><span class="p">,</span> <span class="n">Scb</span> <span class="o">*</span> <span class="n">scbptr</span><span class="p">)</span>
<span class="cm">/*</span>
<span class="cm"> *  Note: this can also be used for ICBs; just cast to the parm type.</span>
<span class="cm"> */</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">ogmb</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="n">unchar</span> <span class="n">start_ogmb</span><span class="p">;</span>
	<span class="n">Mailbox</span> <span class="o">*</span><span class="n">ogmbs</span> <span class="o">=</span> <span class="n">host</span><span class="o">-&gt;</span><span class="n">mb</span><span class="p">.</span><span class="n">ogmb</span><span class="p">;</span>
	<span class="kt">int</span> <span class="o">*</span><span class="n">next_ogmb</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">next_ogmb</span><span class="p">);</span>

	<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot;wd7000_mail_out: 0x%06lx&quot;</span><span class="p">,</span> <span class="p">(</span><span class="kt">long</span><span class="p">)</span> <span class="n">scbptr</span><span class="p">);</span>

	<span class="cm">/* We first look for a free outgoing mailbox */</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">sh</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">ogmb</span> <span class="o">=</span> <span class="o">*</span><span class="n">next_ogmb</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">OGMB_CNT</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ogmbs</span><span class="p">[</span><span class="n">ogmb</span><span class="p">].</span><span class="n">status</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot; using OGMB 0x%x&quot;</span><span class="p">,</span> <span class="n">ogmb</span><span class="p">);</span>
			<span class="n">ogmbs</span><span class="p">[</span><span class="n">ogmb</span><span class="p">].</span><span class="n">status</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">any2scsi</span><span class="p">((</span><span class="n">unchar</span> <span class="o">*</span><span class="p">)</span> <span class="n">ogmbs</span><span class="p">[</span><span class="n">ogmb</span><span class="p">].</span><span class="n">scbptr</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="n">scbptr</span><span class="p">);</span>

			<span class="o">*</span><span class="n">next_ogmb</span> <span class="o">=</span> <span class="p">(</span><span class="n">ogmb</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">OGMB_CNT</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="n">ogmb</span> <span class="o">=</span> <span class="p">(</span><span class="n">ogmb</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">OGMB_CNT</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">sh</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot;, scb is 0x%06lx&quot;</span><span class="p">,</span> <span class="p">(</span><span class="kt">long</span><span class="p">)</span> <span class="n">scbptr</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&gt;=</span> <span class="n">OGMB_CNT</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 *  Alternatively, we might issue the &quot;interrupt on free OGMB&quot;,</span>
<span class="cm">		 *  and sleep, but it must be ensured that it isn&#39;t the init</span>
<span class="cm">		 *  task running.  Instead, this version assumes that the caller</span>
<span class="cm">		 *  will be persistent, and try again.  Since it&#39;s the adapter</span>
<span class="cm">		 *  that marks OGMB&#39;s free, waiting even with interrupts off</span>
<span class="cm">		 *  should work, since they are freed very quickly in most cases.</span>
<span class="cm">		 */</span>
		<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot;, no free OGMBs.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="p">(</span><span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">wd7000_enable_intr</span><span class="p">(</span><span class="n">host</span><span class="p">);</span>

	<span class="n">start_ogmb</span> <span class="o">=</span> <span class="n">START_OGMB</span> <span class="o">|</span> <span class="n">ogmb</span><span class="p">;</span>
	<span class="n">command_out</span><span class="p">(</span><span class="n">host</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">start_ogmb</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

	<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot;, awaiting interrupt.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="k">return</span> <span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">int</span> <span class="n">make_code</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">hosterr</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">scsierr</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef WD7000_DEBUG</span>
	<span class="kt">int</span> <span class="n">in_error</span> <span class="o">=</span> <span class="n">hosterr</span><span class="p">;</span>
<span class="cp">#endif</span>

	<span class="k">switch</span> <span class="p">((</span><span class="n">hosterr</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="mi">0</span>:		<span class="cm">/* Reserved */</span>
		<span class="n">hosterr</span> <span class="o">=</span> <span class="n">DID_ERROR</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">1</span>:		<span class="cm">/* Command Complete, no errors */</span>
		<span class="n">hosterr</span> <span class="o">=</span> <span class="n">DID_OK</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">2</span>:		<span class="cm">/* Command complete, error logged in scb status (scsierr) */</span>
		<span class="n">hosterr</span> <span class="o">=</span> <span class="n">DID_OK</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">4</span>:		<span class="cm">/* Command failed to complete - timeout */</span>
		<span class="n">hosterr</span> <span class="o">=</span> <span class="n">DID_TIME_OUT</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">5</span>:		<span class="cm">/* Command terminated; Bus reset by external device */</span>
		<span class="n">hosterr</span> <span class="o">=</span> <span class="n">DID_RESET</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">6</span>:		<span class="cm">/* Unexpected Command Received w/ host as target */</span>
		<span class="n">hosterr</span> <span class="o">=</span> <span class="n">DID_BAD_TARGET</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">80</span>:		<span class="cm">/* Unexpected Reselection */</span>
	<span class="k">case</span> <span class="mi">81</span>:		<span class="cm">/* Unexpected Selection */</span>
		<span class="n">hosterr</span> <span class="o">=</span> <span class="n">DID_BAD_INTR</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">82</span>:		<span class="cm">/* Abort Command Message  */</span>
		<span class="n">hosterr</span> <span class="o">=</span> <span class="n">DID_ABORT</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">83</span>:		<span class="cm">/* SCSI Bus Software Reset */</span>
	<span class="k">case</span> <span class="mi">84</span>:		<span class="cm">/* SCSI Bus Hardware Reset */</span>
		<span class="n">hosterr</span> <span class="o">=</span> <span class="n">DID_RESET</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>		<span class="cm">/* Reserved */</span>
		<span class="n">hosterr</span> <span class="o">=</span> <span class="n">DID_ERROR</span><span class="p">;</span>
	<span class="p">}</span>
<span class="cp">#ifdef WD7000_DEBUG</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">scsierr</span> <span class="o">||</span> <span class="n">hosterr</span><span class="p">)</span>
		<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">SCSI command error: SCSI 0x%02x host 0x%04x return %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">scsierr</span><span class="p">,</span> <span class="n">in_error</span><span class="p">,</span> <span class="n">hosterr</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">scsierr</span> <span class="o">|</span> <span class="p">(</span><span class="n">hosterr</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">));</span>
<span class="p">}</span>

<span class="cp">#define wd7000_intr_ack(host)   outb (0, host-&gt;iobase + ASC_INTR_ACK)</span>


<span class="k">static</span> <span class="n">irqreturn_t</span> <span class="n">wd7000_intr</span><span class="p">(</span><span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">dev_id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">Adapter</span> <span class="o">*</span><span class="n">host</span> <span class="o">=</span> <span class="p">(</span><span class="n">Adapter</span> <span class="o">*</span><span class="p">)</span> <span class="n">dev_id</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">flag</span><span class="p">,</span> <span class="n">icmb</span><span class="p">,</span> <span class="n">errstatus</span><span class="p">,</span> <span class="n">icmb_status</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">host_error</span><span class="p">,</span> <span class="n">scsi_error</span><span class="p">;</span>
	<span class="n">Scb</span> <span class="o">*</span><span class="n">scb</span><span class="p">;</span>	<span class="cm">/* for SCSI commands */</span>
	<span class="n">IcbAny</span> <span class="o">*</span><span class="n">icb</span><span class="p">;</span>	<span class="cm">/* for host commands */</span>
	<span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="n">SCpnt</span><span class="p">;</span>
	<span class="n">Mailbox</span> <span class="o">*</span><span class="n">icmbs</span> <span class="o">=</span> <span class="n">host</span><span class="o">-&gt;</span><span class="n">mb</span><span class="p">.</span><span class="n">icmb</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">sh</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">host</span><span class="o">-&gt;</span><span class="n">int_counter</span><span class="o">++</span><span class="p">;</span>

	<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot;wd7000_intr: irq = %d, host = 0x%06lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">irq</span><span class="p">,</span> <span class="p">(</span><span class="kt">long</span><span class="p">)</span> <span class="n">host</span><span class="p">);</span>

	<span class="n">flag</span> <span class="o">=</span> <span class="n">inb</span><span class="p">(</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">iobase</span> <span class="o">+</span> <span class="n">ASC_INTR_STAT</span><span class="p">);</span>

	<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot;wd7000_intr: intr stat = 0x%02x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">flag</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">inb</span><span class="p">(</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">iobase</span> <span class="o">+</span> <span class="n">ASC_STAT</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">INT_IM</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* NB: these are _very_ possible if IRQ 15 is being used, since</span>
<span class="cm">		 * it&#39;s the &quot;garbage collector&quot; on the 2nd 8259 PIC.  Specifically,</span>
<span class="cm">		 * any interrupt signal into the 8259 which can&#39;t be identified</span>
<span class="cm">		 * comes out as 7 from the 8259, which is 15 to the host.  Thus, it</span>
<span class="cm">		 * is a good thing the WD7000 has an interrupt status port, so we</span>
<span class="cm">		 * can sort these out.  Otherwise, electrical noise and other such</span>
<span class="cm">		 * problems would be indistinguishable from valid interrupts...</span>
<span class="cm">		 */</span>
		<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot;wd7000_intr: phantom interrupt...</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">ack</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">flag</span> <span class="o">&amp;</span> <span class="n">MB_INTR</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">ack</span><span class="p">;</span>

	<span class="cm">/* The interrupt is for a mailbox */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">flag</span> <span class="o">&amp;</span> <span class="n">IMB_INTR</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot;wd7000_intr: free outgoing mailbox</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * If sleep_on() and the &quot;interrupt on free OGMB&quot; command are</span>
<span class="cm">		 * used in mail_out(), wake_up() should correspondingly be called</span>
<span class="cm">		 * here.  For now, we don&#39;t need to do anything special.</span>
<span class="cm">		 */</span>
		<span class="k">goto</span> <span class="n">ack</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* The interrupt is for an incoming mailbox */</span>
	<span class="n">icmb</span> <span class="o">=</span> <span class="n">flag</span> <span class="o">&amp;</span> <span class="n">MB_MASK</span><span class="p">;</span>
	<span class="n">icmb_status</span> <span class="o">=</span> <span class="n">icmbs</span><span class="p">[</span><span class="n">icmb</span><span class="p">].</span><span class="n">status</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">icmb_status</span> <span class="o">&amp;</span> <span class="mh">0x80</span><span class="p">)</span> <span class="p">{</span>	<span class="cm">/* unsolicited - result in ICMB */</span>
		<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot;wd7000_intr: unsolicited interrupt 0x%02x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">icmb_status</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">ack</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Aaaargh! (Zaga) */</span>
	<span class="n">scb</span> <span class="o">=</span> <span class="n">isa_bus_to_virt</span><span class="p">(</span><span class="n">scsi2int</span><span class="p">((</span><span class="n">unchar</span> <span class="o">*</span><span class="p">)</span> <span class="n">icmbs</span><span class="p">[</span><span class="n">icmb</span><span class="p">].</span><span class="n">scbptr</span><span class="p">));</span>
	<span class="n">icmbs</span><span class="p">[</span><span class="n">icmb</span><span class="p">].</span><span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">scb</span><span class="o">-&gt;</span><span class="n">op</span> <span class="o">&amp;</span> <span class="n">ICB_OP_MASK</span><span class="p">)</span> <span class="p">{</span>	<span class="cm">/* an SCB is done */</span>
		<span class="n">icb</span> <span class="o">=</span> <span class="p">(</span><span class="n">IcbAny</span> <span class="o">*</span><span class="p">)</span> <span class="n">scb</span><span class="p">;</span>
		<span class="n">icb</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">=</span> <span class="n">icmb_status</span><span class="p">;</span>
		<span class="n">icb</span><span class="o">-&gt;</span><span class="n">phase</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">ack</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">SCpnt</span> <span class="o">=</span> <span class="n">scb</span><span class="o">-&gt;</span><span class="n">SCpnt</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">--</span><span class="p">(</span><span class="n">SCpnt</span><span class="o">-&gt;</span><span class="n">SCp</span><span class="p">.</span><span class="n">phase</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>	<span class="cm">/* all scbs are done */</span>
		<span class="n">host_error</span> <span class="o">=</span> <span class="n">scb</span><span class="o">-&gt;</span><span class="n">vue</span> <span class="o">|</span> <span class="p">(</span><span class="n">icmb_status</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">);</span>
		<span class="n">scsi_error</span> <span class="o">=</span> <span class="n">scb</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">;</span>
		<span class="n">errstatus</span> <span class="o">=</span> <span class="n">make_code</span><span class="p">(</span><span class="n">host_error</span><span class="p">,</span> <span class="n">scsi_error</span><span class="p">);</span>
		<span class="n">SCpnt</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">=</span> <span class="n">errstatus</span><span class="p">;</span>

		<span class="n">free_scb</span><span class="p">(</span><span class="n">scb</span><span class="p">);</span>

		<span class="n">SCpnt</span><span class="o">-&gt;</span><span class="n">scsi_done</span><span class="p">(</span><span class="n">SCpnt</span><span class="p">);</span>
	<span class="p">}</span>

 <span class="nl">ack:</span>
	<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot;wd7000_intr: return from interrupt handler</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">wd7000_intr_ack</span><span class="p">(</span><span class="n">host</span><span class="p">);</span>

	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">sh</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">IRQ_HANDLED</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">wd7000_queuecommand_lck</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="n">SCpnt</span><span class="p">,</span>
		<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">done</span><span class="p">)(</span><span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="p">))</span>
<span class="p">{</span>
	<span class="n">Scb</span> <span class="o">*</span><span class="n">scb</span><span class="p">;</span>
	<span class="n">Sgb</span> <span class="o">*</span><span class="n">sgb</span><span class="p">;</span>
	<span class="n">unchar</span> <span class="o">*</span><span class="n">cdb</span> <span class="o">=</span> <span class="p">(</span><span class="n">unchar</span> <span class="o">*</span><span class="p">)</span> <span class="n">SCpnt</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">;</span>
	<span class="n">unchar</span> <span class="n">idlun</span><span class="p">;</span>
	<span class="kt">short</span> <span class="n">cdblen</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">nseg</span><span class="p">;</span>
	<span class="n">Adapter</span> <span class="o">*</span><span class="n">host</span> <span class="o">=</span> <span class="p">(</span><span class="n">Adapter</span> <span class="o">*</span><span class="p">)</span> <span class="n">SCpnt</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">hostdata</span><span class="p">;</span>

	<span class="n">cdblen</span> <span class="o">=</span> <span class="n">SCpnt</span><span class="o">-&gt;</span><span class="n">cmd_len</span><span class="p">;</span>
	<span class="n">idlun</span> <span class="o">=</span> <span class="p">((</span><span class="n">SCpnt</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">id</span> <span class="o">&lt;&lt;</span> <span class="mi">5</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xe0</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">SCpnt</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">lun</span> <span class="o">&amp;</span> <span class="mi">7</span><span class="p">);</span>
	<span class="n">SCpnt</span><span class="o">-&gt;</span><span class="n">scsi_done</span> <span class="o">=</span> <span class="n">done</span><span class="p">;</span>
	<span class="n">SCpnt</span><span class="o">-&gt;</span><span class="n">SCp</span><span class="p">.</span><span class="n">phase</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">scb</span> <span class="o">=</span> <span class="n">alloc_scbs</span><span class="p">(</span><span class="n">SCpnt</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">scb</span><span class="o">-&gt;</span><span class="n">idlun</span> <span class="o">=</span> <span class="n">idlun</span><span class="p">;</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">scb</span><span class="o">-&gt;</span><span class="n">cdb</span><span class="p">,</span> <span class="n">cdb</span><span class="p">,</span> <span class="n">cdblen</span><span class="p">);</span>
	<span class="n">scb</span><span class="o">-&gt;</span><span class="n">direc</span> <span class="o">=</span> <span class="mh">0x40</span><span class="p">;</span>	<span class="cm">/* Disable direction check */</span>

	<span class="n">scb</span><span class="o">-&gt;</span><span class="n">SCpnt</span> <span class="o">=</span> <span class="n">SCpnt</span><span class="p">;</span>	<span class="cm">/* so we can find stuff later */</span>
	<span class="n">SCpnt</span><span class="o">-&gt;</span><span class="n">host_scribble</span> <span class="o">=</span> <span class="p">(</span><span class="n">unchar</span> <span class="o">*</span><span class="p">)</span> <span class="n">scb</span><span class="p">;</span>
	<span class="n">scb</span><span class="o">-&gt;</span><span class="n">host</span> <span class="o">=</span> <span class="n">host</span><span class="p">;</span>

	<span class="n">nseg</span> <span class="o">=</span> <span class="n">scsi_sg_count</span><span class="p">(</span><span class="n">SCpnt</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nseg</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">scatterlist</span> <span class="o">*</span><span class="n">sg</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="n">i</span><span class="p">;</span>

		<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot;Using scatter/gather with %d elements.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">nseg</span><span class="p">);</span>

		<span class="n">sgb</span> <span class="o">=</span> <span class="n">scb</span><span class="o">-&gt;</span><span class="n">sgb</span><span class="p">;</span>
		<span class="n">scb</span><span class="o">-&gt;</span><span class="n">op</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">any2scsi</span><span class="p">(</span><span class="n">scb</span><span class="o">-&gt;</span><span class="n">dataptr</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="n">sgb</span><span class="p">);</span>
		<span class="n">any2scsi</span><span class="p">(</span><span class="n">scb</span><span class="o">-&gt;</span><span class="n">maxlen</span><span class="p">,</span> <span class="n">nseg</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">Sgb</span><span class="p">));</span>

		<span class="n">scsi_for_each_sg</span><span class="p">(</span><span class="n">SCpnt</span><span class="p">,</span> <span class="n">sg</span><span class="p">,</span> <span class="n">nseg</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">any2scsi</span><span class="p">(</span><span class="n">sgb</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">ptr</span><span class="p">,</span> <span class="n">isa_page_to_bus</span><span class="p">(</span><span class="n">sg_page</span><span class="p">(</span><span class="n">sg</span><span class="p">))</span> <span class="o">+</span> <span class="n">sg</span><span class="o">-&gt;</span><span class="n">offset</span><span class="p">);</span>
			<span class="n">any2scsi</span><span class="p">(</span><span class="n">sgb</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">len</span><span class="p">,</span> <span class="n">sg</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">scb</span><span class="o">-&gt;</span><span class="n">op</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">nseg</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">scatterlist</span> <span class="o">*</span><span class="n">sg</span> <span class="o">=</span> <span class="n">scsi_sglist</span><span class="p">(</span><span class="n">SCpnt</span><span class="p">);</span>
			<span class="n">any2scsi</span><span class="p">(</span><span class="n">scb</span><span class="o">-&gt;</span><span class="n">dataptr</span><span class="p">,</span> <span class="n">isa_page_to_bus</span><span class="p">(</span><span class="n">sg_page</span><span class="p">(</span><span class="n">sg</span><span class="p">))</span> <span class="o">+</span> <span class="n">sg</span><span class="o">-&gt;</span><span class="n">offset</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">any2scsi</span><span class="p">(</span><span class="n">scb</span><span class="o">-&gt;</span><span class="n">maxlen</span><span class="p">,</span> <span class="n">scsi_bufflen</span><span class="p">(</span><span class="n">SCpnt</span><span class="p">));</span>
	<span class="p">}</span>

	<span class="cm">/* FIXME: drop lock and yield here ? */</span>

	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">mail_out</span><span class="p">(</span><span class="n">host</span><span class="p">,</span> <span class="n">scb</span><span class="p">))</span>
		<span class="n">cpu_relax</span><span class="p">();</span>	<span class="cm">/* keep trying */</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">DEF_SCSI_QCMD</span><span class="p">(</span><span class="n">wd7000_queuecommand</span><span class="p">)</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">wd7000_diagnostics</span><span class="p">(</span><span class="n">Adapter</span> <span class="o">*</span> <span class="n">host</span><span class="p">,</span> <span class="kt">int</span> <span class="n">code</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">static</span> <span class="n">IcbDiag</span> <span class="n">icb</span> <span class="o">=</span> <span class="p">{</span> <span class="n">ICB_OP_DIAGNOSTICS</span> <span class="p">};</span>
	<span class="k">static</span> <span class="n">unchar</span> <span class="n">buf</span><span class="p">[</span><span class="mi">256</span><span class="p">];</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">timeout</span><span class="p">;</span>

	<span class="n">icb</span><span class="p">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">code</span><span class="p">;</span>
	<span class="n">any2scsi</span><span class="p">(</span><span class="n">icb</span><span class="p">.</span><span class="n">len</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">buf</span><span class="p">));</span>
	<span class="n">any2scsi</span><span class="p">(</span><span class="n">icb</span><span class="p">.</span><span class="n">ptr</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">buf</span><span class="p">);</span>
	<span class="n">icb</span><span class="p">.</span><span class="n">phase</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * This routine is only called at init, so there should be OGMBs</span>
<span class="cm">	 * available.  I&#39;m assuming so here.  If this is going to</span>
<span class="cm">	 * fail, I can just let the timeout catch the failure.</span>
<span class="cm">	 */</span>
	<span class="n">mail_out</span><span class="p">(</span><span class="n">host</span><span class="p">,</span> <span class="p">(</span><span class="k">struct</span> <span class="n">scb</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">icb</span><span class="p">);</span>
	<span class="n">timeout</span> <span class="o">=</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="n">WAITnexttimeout</span><span class="p">;</span>	<span class="cm">/* wait up to 2 seconds */</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">icb</span><span class="p">.</span><span class="n">phase</span> <span class="o">&amp;&amp;</span> <span class="n">time_before</span><span class="p">(</span><span class="n">jiffies</span><span class="p">,</span> <span class="n">timeout</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">cpu_relax</span><span class="p">();</span>	<span class="cm">/* wait for completion */</span>
		<span class="n">barrier</span><span class="p">();</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">icb</span><span class="p">.</span><span class="n">phase</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;wd7000_diagnostics: timed out.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="p">(</span><span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">make_code</span><span class="p">(</span><span class="n">icb</span><span class="p">.</span><span class="n">vue</span> <span class="o">|</span> <span class="p">(</span><span class="n">icb</span><span class="p">.</span><span class="n">status</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">),</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;wd7000_diagnostics: failed (0x%02x,0x%02x)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">icb</span><span class="p">.</span><span class="n">vue</span><span class="p">,</span> <span class="n">icb</span><span class="p">.</span><span class="n">status</span><span class="p">);</span>
		<span class="k">return</span> <span class="p">(</span><span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">int</span> <span class="n">wd7000_adapter_reset</span><span class="p">(</span><span class="n">Adapter</span> <span class="o">*</span> <span class="n">host</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">InitCmd</span> <span class="n">init_cmd</span> <span class="o">=</span> <span class="p">{</span>
		<span class="n">INITIALIZATION</span><span class="p">,</span>
		<span class="mi">7</span><span class="p">,</span>
		<span class="n">host</span><span class="o">-&gt;</span><span class="n">bus_on</span><span class="p">,</span>
		<span class="n">host</span><span class="o">-&gt;</span><span class="n">bus_off</span><span class="p">,</span>
		<span class="mi">0</span><span class="p">,</span>
		<span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">},</span>
		<span class="n">OGMB_CNT</span><span class="p">,</span>
		<span class="n">ICMB_CNT</span>
	<span class="p">};</span>
	<span class="kt">int</span> <span class="n">diag</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 *  Reset the adapter - only.  The SCSI bus was initialized at power-up,</span>
<span class="cm">	 *  and we need to do this just so we control the mailboxes, etc.</span>
<span class="cm">	 */</span>
	<span class="n">outb</span><span class="p">(</span><span class="n">ASC_RES</span><span class="p">,</span> <span class="n">host</span><span class="o">-&gt;</span><span class="n">iobase</span> <span class="o">+</span> <span class="n">ASC_CONTROL</span><span class="p">);</span>
	<span class="n">udelay</span><span class="p">(</span><span class="mi">40</span><span class="p">);</span>		<span class="cm">/* reset pulse: this is 40us, only need 25us */</span>
	<span class="n">outb</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">host</span><span class="o">-&gt;</span><span class="n">iobase</span> <span class="o">+</span> <span class="n">ASC_CONTROL</span><span class="p">);</span>
	<span class="n">host</span><span class="o">-&gt;</span><span class="n">control</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>	<span class="cm">/* this must always shadow ASC_CONTROL */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">WAIT</span><span class="p">(</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">iobase</span> <span class="o">+</span> <span class="n">ASC_STAT</span><span class="p">,</span> <span class="n">ASC_STATMASK</span><span class="p">,</span> <span class="n">CMD_RDY</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;wd7000_init: WAIT timed out.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>	<span class="cm">/* -1 = not ok */</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">diag</span> <span class="o">=</span> <span class="n">inb</span><span class="p">(</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">iobase</span> <span class="o">+</span> <span class="n">ASC_INTR_STAT</span><span class="p">))</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;wd7000_init: &quot;</span><span class="p">);</span>

		<span class="k">switch</span> <span class="p">(</span><span class="n">diag</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="mi">2</span>:
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;RAM failure.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="mi">3</span>:
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;FIFO R/W failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="mi">4</span>:
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;SBIC register R/W failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="mi">5</span>:
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;Initialization D-FF failed.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="mi">6</span>:
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;Host IRQ D-FF failed.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="mi">7</span>:
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;ROM checksum error.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="nl">default:</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;diagnostic code 0x%02Xh received.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">diag</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* Clear mailboxes */</span>
	<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">mb</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">mb</span><span class="p">));</span>

	<span class="cm">/* Execute init command */</span>
	<span class="n">any2scsi</span><span class="p">((</span><span class="n">unchar</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">init_cmd</span><span class="p">.</span><span class="n">mailboxes</span><span class="p">),</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">mb</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">command_out</span><span class="p">(</span><span class="n">host</span><span class="p">,</span> <span class="p">(</span><span class="n">unchar</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">init_cmd</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">init_cmd</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;wd7000_adapter_reset: adapter initialization failed.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">WAIT</span><span class="p">(</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">iobase</span> <span class="o">+</span> <span class="n">ASC_STAT</span><span class="p">,</span> <span class="n">ASC_STATMASK</span><span class="p">,</span> <span class="n">ASC_INIT</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;wd7000_adapter_reset: WAIT timed out.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">wd7000_init</span><span class="p">(</span><span class="n">Adapter</span> <span class="o">*</span> <span class="n">host</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">wd7000_adapter_reset</span><span class="p">(</span><span class="n">host</span><span class="p">)</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>


	<span class="k">if</span> <span class="p">(</span><span class="n">request_irq</span><span class="p">(</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">,</span> <span class="n">wd7000_intr</span><span class="p">,</span> <span class="n">IRQF_DISABLED</span><span class="p">,</span> <span class="s">&quot;wd7000&quot;</span><span class="p">,</span> <span class="n">host</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;wd7000_init: can&#39;t get IRQ %d.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">host</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">);</span>
		<span class="k">return</span> <span class="p">(</span><span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">request_dma</span><span class="p">(</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">dma</span><span class="p">,</span> <span class="s">&quot;wd7000&quot;</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;wd7000_init: can&#39;t get DMA channel %d.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">host</span><span class="o">-&gt;</span><span class="n">dma</span><span class="p">);</span>
		<span class="n">free_irq</span><span class="p">(</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">,</span> <span class="n">host</span><span class="p">);</span>
		<span class="k">return</span> <span class="p">(</span><span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">wd7000_enable_dma</span><span class="p">(</span><span class="n">host</span><span class="p">);</span>
	<span class="n">wd7000_enable_intr</span><span class="p">(</span><span class="n">host</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">wd7000_diagnostics</span><span class="p">(</span><span class="n">host</span><span class="p">,</span> <span class="n">ICB_DIAG_FULL</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">free_dma</span><span class="p">(</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">dma</span><span class="p">);</span>
		<span class="n">free_irq</span><span class="p">(</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="k">return</span> <span class="p">(</span><span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">void</span> <span class="n">wd7000_revision</span><span class="p">(</span><span class="n">Adapter</span> <span class="o">*</span> <span class="n">host</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">static</span> <span class="n">IcbRevLvl</span> <span class="n">icb</span> <span class="o">=</span> <span class="p">{</span> <span class="n">ICB_OP_GET_REVISION</span> <span class="p">};</span>

	<span class="n">icb</span><span class="p">.</span><span class="n">phase</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * Like diagnostics, this is only done at init time, in fact, from</span>
<span class="cm">	 * wd7000_detect, so there should be OGMBs available.  If it fails,</span>
<span class="cm">	 * the only damage will be that the revision will show up as 0.0,</span>
<span class="cm">	 * which in turn means that scatter/gather will be disabled.</span>
<span class="cm">	 */</span>
	<span class="n">mail_out</span><span class="p">(</span><span class="n">host</span><span class="p">,</span> <span class="p">(</span><span class="k">struct</span> <span class="n">scb</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">icb</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">icb</span><span class="p">.</span><span class="n">phase</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cpu_relax</span><span class="p">();</span>	<span class="cm">/* wait for completion */</span>
		<span class="n">barrier</span><span class="p">();</span>
	<span class="p">}</span>
	<span class="n">host</span><span class="o">-&gt;</span><span class="n">rev1</span> <span class="o">=</span> <span class="n">icb</span><span class="p">.</span><span class="n">primary</span><span class="p">;</span>
	<span class="n">host</span><span class="o">-&gt;</span><span class="n">rev2</span> <span class="o">=</span> <span class="n">icb</span><span class="p">.</span><span class="n">secondary</span><span class="p">;</span>
<span class="p">}</span>


<span class="cp">#undef SPRINTF</span>
<span class="cp">#define SPRINTF(args...) { if (pos &lt; (buffer + length)) pos += sprintf (pos, ## args); }</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">wd7000_set_info</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span> <span class="kt">int</span> <span class="n">length</span><span class="p">,</span> <span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">host</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot;Buffer = &lt;%.*s&gt;, length = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">length</span><span class="p">,</span> <span class="n">buffer</span><span class="p">,</span> <span class="n">length</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Currently this is a no-op</span>
<span class="cm">	 */</span>
	<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot;Sorry, this function is currently out of order...</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">length</span><span class="p">);</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">int</span> <span class="n">wd7000_proc_info</span><span class="p">(</span><span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">host</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">start</span><span class="p">,</span> <span class="kt">off_t</span> <span class="n">offset</span><span class="p">,</span> <span class="kt">int</span> <span class="n">length</span><span class="p">,</span>  <span class="kt">int</span> <span class="n">inout</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">Adapter</span> <span class="o">*</span><span class="n">adapter</span> <span class="o">=</span> <span class="p">(</span><span class="n">Adapter</span> <span class="o">*</span><span class="p">)</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">hostdata</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">pos</span> <span class="o">=</span> <span class="n">buffer</span><span class="p">;</span>
<span class="cp">#ifdef WD7000_DEBUG</span>
	<span class="n">Mailbox</span> <span class="o">*</span><span class="n">ogmbs</span><span class="p">,</span> <span class="o">*</span><span class="n">icmbs</span><span class="p">;</span>
	<span class="kt">short</span> <span class="n">count</span><span class="p">;</span>
<span class="cp">#endif</span>

	<span class="cm">/*</span>
<span class="cm">	 * Has data been written to the file ?</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">inout</span><span class="p">)</span>
		<span class="k">return</span> <span class="p">(</span><span class="n">wd7000_set_info</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="n">length</span><span class="p">,</span> <span class="n">host</span><span class="p">));</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">SPRINTF</span><span class="p">(</span><span class="s">&quot;Host scsi%d: Western Digital WD-7000 (rev %d.%d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">host</span><span class="o">-&gt;</span><span class="n">host_no</span><span class="p">,</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rev1</span><span class="p">,</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">rev2</span><span class="p">);</span>
	<span class="n">SPRINTF</span><span class="p">(</span><span class="s">&quot;  IO base:      0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">iobase</span><span class="p">);</span>
	<span class="n">SPRINTF</span><span class="p">(</span><span class="s">&quot;  IRQ:          %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">);</span>
	<span class="n">SPRINTF</span><span class="p">(</span><span class="s">&quot;  DMA channel:  %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">dma</span><span class="p">);</span>
	<span class="n">SPRINTF</span><span class="p">(</span><span class="s">&quot;  Interrupts:   %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">int_counter</span><span class="p">);</span>
	<span class="n">SPRINTF</span><span class="p">(</span><span class="s">&quot;  BUS_ON time:  %d nanoseconds</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">bus_on</span> <span class="o">*</span> <span class="mi">125</span><span class="p">);</span>
	<span class="n">SPRINTF</span><span class="p">(</span><span class="s">&quot;  BUS_OFF time: %d nanoseconds</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">bus_off</span> <span class="o">*</span> <span class="mi">125</span><span class="p">);</span>

<span class="cp">#ifdef WD7000_DEBUG</span>
	<span class="n">ogmbs</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">mb</span><span class="p">.</span><span class="n">ogmb</span><span class="p">;</span>
	<span class="n">icmbs</span> <span class="o">=</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">mb</span><span class="p">.</span><span class="n">icmb</span><span class="p">;</span>

	<span class="n">SPRINTF</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">Control port value: 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">control</span><span class="p">);</span>
	<span class="n">SPRINTF</span><span class="p">(</span><span class="s">&quot;Incoming mailbox:</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">SPRINTF</span><span class="p">(</span><span class="s">&quot;  size: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ICMB_CNT</span><span class="p">);</span>
	<span class="n">SPRINTF</span><span class="p">(</span><span class="s">&quot;  queued messages: &quot;</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ICMB_CNT</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">icmbs</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">status</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">count</span><span class="o">++</span><span class="p">;</span>
			<span class="n">SPRINTF</span><span class="p">(</span><span class="s">&quot;0x%x &quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
		<span class="p">}</span>

	<span class="n">SPRINTF</span><span class="p">(</span><span class="n">count</span> <span class="o">?</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span> <span class="o">:</span> <span class="s">&quot;none</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="n">SPRINTF</span><span class="p">(</span><span class="s">&quot;Outgoing mailbox:</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">SPRINTF</span><span class="p">(</span><span class="s">&quot;  size: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">OGMB_CNT</span><span class="p">);</span>
	<span class="n">SPRINTF</span><span class="p">(</span><span class="s">&quot;  next message: 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">adapter</span><span class="o">-&gt;</span><span class="n">next_ogmb</span><span class="p">);</span>
	<span class="n">SPRINTF</span><span class="p">(</span><span class="s">&quot;  queued messages: &quot;</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">OGMB_CNT</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ogmbs</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">status</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">count</span><span class="o">++</span><span class="p">;</span>
			<span class="n">SPRINTF</span><span class="p">(</span><span class="s">&quot;0x%x &quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
		<span class="p">}</span>

	<span class="n">SPRINTF</span><span class="p">(</span><span class="n">count</span> <span class="o">?</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span> <span class="o">:</span> <span class="s">&quot;none</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="cp">#endif</span>

	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Calculate start of next buffer, and return value.</span>
<span class="cm">	 */</span>
	<span class="o">*</span><span class="n">start</span> <span class="o">=</span> <span class="n">buffer</span> <span class="o">+</span> <span class="n">offset</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">pos</span> <span class="o">-</span> <span class="n">buffer</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">offset</span><span class="p">)</span>
		<span class="k">return</span> <span class="p">(</span><span class="mi">0</span><span class="p">);</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">pos</span> <span class="o">-</span> <span class="n">buffer</span> <span class="o">-</span> <span class="n">offset</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">length</span><span class="p">)</span>
		<span class="k">return</span> <span class="p">(</span><span class="n">pos</span> <span class="o">-</span> <span class="n">buffer</span> <span class="o">-</span> <span class="n">offset</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="k">return</span> <span class="p">(</span><span class="n">length</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> *  Returns the number of adapters this driver is supporting.</span>
<span class="cm"> *</span>
<span class="cm"> *  The source for hosts.c says to wait to call scsi_register until 100%</span>
<span class="cm"> *  sure about an adapter.  We need to do it a little sooner here; we</span>
<span class="cm"> *  need the storage set up by scsi_register before wd7000_init, and</span>
<span class="cm"> *  changing the location of an Adapter structure is more trouble than</span>
<span class="cm"> *  calling scsi_unregister.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="n">__init</span> <span class="kt">int</span> <span class="n">wd7000_detect</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_host_template</span> <span class="o">*</span><span class="n">tpnt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">short</span> <span class="n">present</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">biosaddr_ptr</span><span class="p">,</span> <span class="n">sig_ptr</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">pass</span><span class="p">;</span>
	<span class="kt">short</span> <span class="n">biosptr</span><span class="p">[</span><span class="n">NUM_CONFIGS</span><span class="p">];</span>
	<span class="kt">unsigned</span> <span class="n">iobase</span><span class="p">;</span>
	<span class="n">Adapter</span> <span class="o">*</span><span class="n">host</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">sh</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">unit</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot;wd7000_detect: started</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

<span class="cp">#ifdef MODULE</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">wd7000</span><span class="p">)</span>
		<span class="n">wd7000_setup</span><span class="p">(</span><span class="n">wd7000</span><span class="p">);</span>
<span class="cp">#endif</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">UNITS</span><span class="p">;</span> <span class="n">wd7000_host</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">NUM_CONFIGS</span><span class="p">;</span> <span class="n">biosptr</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>

	<span class="n">tpnt</span><span class="o">-&gt;</span><span class="n">proc_name</span> <span class="o">=</span> <span class="s">&quot;wd7000&quot;</span><span class="p">;</span>
	<span class="n">tpnt</span><span class="o">-&gt;</span><span class="n">proc_info</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">wd7000_proc_info</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Set up SCB free list, which is shared by all adapters</span>
<span class="cm">	 */</span>
	<span class="n">init_scbs</span><span class="p">();</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">pass</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">pass</span> <span class="o">&lt;</span> <span class="n">NUM_CONFIGS</span><span class="p">;</span> <span class="n">pass</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * First, search for BIOS SIGNATURE...</span>
<span class="cm">		 */</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">biosaddr_ptr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">biosaddr_ptr</span> <span class="o">&lt;</span> <span class="n">NUM_ADDRS</span><span class="p">;</span> <span class="n">biosaddr_ptr</span><span class="o">++</span><span class="p">)</span>
			<span class="k">for</span> <span class="p">(</span><span class="n">sig_ptr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">sig_ptr</span> <span class="o">&lt;</span> <span class="n">NUM_SIGNATURES</span><span class="p">;</span> <span class="n">sig_ptr</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">pass</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
					<span class="k">if</span> <span class="p">(</span><span class="n">biosptr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">biosaddr_ptr</span><span class="p">)</span>
						<span class="k">break</span><span class="p">;</span>

				<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">pass</span><span class="p">)</span> <span class="p">{</span>
					<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">biosaddr</span> <span class="o">=</span> <span class="n">ioremap</span><span class="p">(</span><span class="n">wd7000_biosaddr</span><span class="p">[</span><span class="n">biosaddr_ptr</span><span class="p">]</span> <span class="o">+</span> <span class="n">signatures</span><span class="p">[</span><span class="n">sig_ptr</span><span class="p">].</span><span class="n">ofs</span><span class="p">,</span>
								 <span class="n">signatures</span><span class="p">[</span><span class="n">sig_ptr</span><span class="p">].</span><span class="n">len</span><span class="p">);</span>
					<span class="kt">short</span> <span class="n">bios_match</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

					<span class="k">if</span> <span class="p">(</span><span class="n">biosaddr</span><span class="p">)</span>
						<span class="n">bios_match</span> <span class="o">=</span> <span class="n">check_signature</span><span class="p">(</span><span class="n">biosaddr</span><span class="p">,</span> <span class="n">signatures</span><span class="p">[</span><span class="n">sig_ptr</span><span class="p">].</span><span class="n">sig</span><span class="p">,</span> <span class="n">signatures</span><span class="p">[</span><span class="n">sig_ptr</span><span class="p">].</span><span class="n">len</span><span class="p">);</span>

					<span class="n">iounmap</span><span class="p">(</span><span class="n">biosaddr</span><span class="p">);</span>

					<span class="k">if</span> <span class="p">(</span><span class="n">bios_match</span><span class="p">)</span>
						<span class="k">goto</span> <span class="n">bios_matched</span><span class="p">;</span>
				<span class="p">}</span>
			<span class="p">}</span>

	      <span class="nl">bios_matched:</span>
		<span class="cm">/*</span>
<span class="cm">		 * BIOS SIGNATURE has been found.</span>
<span class="cm">		 */</span>
<span class="cp">#ifdef WD7000_DEBUG</span>
		<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot;wd7000_detect: pass %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">pass</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">biosaddr_ptr</span> <span class="o">==</span> <span class="n">NUM_ADDRS</span><span class="p">)</span>
			<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot;WD-7000 SST BIOS not detected...</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot;WD-7000 SST BIOS detected at 0x%lx: checking...</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">wd7000_biosaddr</span><span class="p">[</span><span class="n">biosaddr_ptr</span><span class="p">]);</span>
<span class="cp">#endif</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">configs</span><span class="p">[</span><span class="n">pass</span><span class="p">].</span><span class="n">irq</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">unit</span> <span class="o">==</span> <span class="n">UNITS</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">iobase</span> <span class="o">=</span> <span class="n">configs</span><span class="p">[</span><span class="n">pass</span><span class="p">].</span><span class="n">iobase</span><span class="p">;</span>

		<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot;wd7000_detect: check IO 0x%x region...</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">iobase</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">request_region</span><span class="p">(</span><span class="n">iobase</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="s">&quot;wd7000&quot;</span><span class="p">))</span> <span class="p">{</span>

			<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot;wd7000_detect: ASC reset (IO 0x%x) ...&quot;</span><span class="p">,</span> <span class="n">iobase</span><span class="p">);</span>
			<span class="cm">/*</span>
<span class="cm">			 * ASC reset...</span>
<span class="cm">			 */</span>
			<span class="n">outb</span><span class="p">(</span><span class="n">ASC_RES</span><span class="p">,</span> <span class="n">iobase</span> <span class="o">+</span> <span class="n">ASC_CONTROL</span><span class="p">);</span>
			<span class="n">msleep</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
			<span class="n">outb</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">iobase</span> <span class="o">+</span> <span class="n">ASC_CONTROL</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">WAIT</span><span class="p">(</span><span class="n">iobase</span> <span class="o">+</span> <span class="n">ASC_STAT</span><span class="p">,</span> <span class="n">ASC_STATMASK</span><span class="p">,</span> <span class="n">CMD_RDY</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot;failed!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
				<span class="k">goto</span> <span class="n">err_release</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span>
				<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot;ok!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">inb</span><span class="p">(</span><span class="n">iobase</span> <span class="o">+</span> <span class="n">ASC_INTR_STAT</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/*</span>
<span class="cm">				 *  We register here, to get a pointer to the extra space,</span>
<span class="cm">				 *  which we&#39;ll use as the Adapter structure (host) for</span>
<span class="cm">				 *  this adapter.  It is located just after the registered</span>
<span class="cm">				 *  Scsi_Host structure (sh), and is located by the empty</span>
<span class="cm">				 *  array hostdata.</span>
<span class="cm">				 */</span>
				<span class="n">sh</span> <span class="o">=</span> <span class="n">scsi_register</span><span class="p">(</span><span class="n">tpnt</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">Adapter</span><span class="p">));</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">sh</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
					<span class="k">goto</span> <span class="n">err_release</span><span class="p">;</span>

				<span class="n">host</span> <span class="o">=</span> <span class="p">(</span><span class="n">Adapter</span> <span class="o">*</span><span class="p">)</span> <span class="n">sh</span><span class="o">-&gt;</span><span class="n">hostdata</span><span class="p">;</span>

				<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot;wd7000_detect: adapter allocated at 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="n">host</span><span class="p">);</span>
				<span class="n">memset</span><span class="p">(</span><span class="n">host</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">Adapter</span><span class="p">));</span>

				<span class="n">host</span><span class="o">-&gt;</span><span class="n">irq</span> <span class="o">=</span> <span class="n">configs</span><span class="p">[</span><span class="n">pass</span><span class="p">].</span><span class="n">irq</span><span class="p">;</span>
				<span class="n">host</span><span class="o">-&gt;</span><span class="n">dma</span> <span class="o">=</span> <span class="n">configs</span><span class="p">[</span><span class="n">pass</span><span class="p">].</span><span class="n">dma</span><span class="p">;</span>
				<span class="n">host</span><span class="o">-&gt;</span><span class="n">iobase</span> <span class="o">=</span> <span class="n">iobase</span><span class="p">;</span>
				<span class="n">host</span><span class="o">-&gt;</span><span class="n">int_counter</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
				<span class="n">host</span><span class="o">-&gt;</span><span class="n">bus_on</span> <span class="o">=</span> <span class="n">configs</span><span class="p">[</span><span class="n">pass</span><span class="p">].</span><span class="n">bus_on</span><span class="p">;</span>
				<span class="n">host</span><span class="o">-&gt;</span><span class="n">bus_off</span> <span class="o">=</span> <span class="n">configs</span><span class="p">[</span><span class="n">pass</span><span class="p">].</span><span class="n">bus_off</span><span class="p">;</span>
				<span class="n">host</span><span class="o">-&gt;</span><span class="n">sh</span> <span class="o">=</span> <span class="n">wd7000_host</span><span class="p">[</span><span class="n">unit</span><span class="p">]</span> <span class="o">=</span> <span class="n">sh</span><span class="p">;</span>
				<span class="n">unit</span><span class="o">++</span><span class="p">;</span>

				<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot;wd7000_detect: Trying init WD-7000 card at IO &quot;</span> <span class="s">&quot;0x%x, IRQ %d, DMA %d...</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">host</span><span class="o">-&gt;</span><span class="n">iobase</span><span class="p">,</span> <span class="n">host</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">,</span> <span class="n">host</span><span class="o">-&gt;</span><span class="n">dma</span><span class="p">);</span>

				<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">wd7000_init</span><span class="p">(</span><span class="n">host</span><span class="p">))</span>	<span class="cm">/* Initialization failed */</span>
					<span class="k">goto</span> <span class="n">err_unregister</span><span class="p">;</span>

				<span class="cm">/*</span>
<span class="cm">				 *  OK from here - we&#39;ll use this adapter/configuration.</span>
<span class="cm">				 */</span>
				<span class="n">wd7000_revision</span><span class="p">(</span><span class="n">host</span><span class="p">);</span>	<span class="cm">/* important for scatter/gather */</span>

				<span class="cm">/*</span>
<span class="cm">				 *  For boards before rev 6.0, scatter/gather isn&#39;t supported.</span>
<span class="cm">				 */</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">rev1</span> <span class="o">&lt;</span> <span class="mi">6</span><span class="p">)</span>
					<span class="n">sh</span><span class="o">-&gt;</span><span class="n">sg_tablesize</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

				<span class="n">present</span><span class="o">++</span><span class="p">;</span>	<span class="cm">/* count it */</span>

				<span class="k">if</span> <span class="p">(</span><span class="n">biosaddr_ptr</span> <span class="o">!=</span> <span class="n">NUM_ADDRS</span><span class="p">)</span>
					<span class="n">biosptr</span><span class="p">[</span><span class="n">pass</span><span class="p">]</span> <span class="o">=</span> <span class="n">biosaddr_ptr</span><span class="p">;</span>

				<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;Western Digital WD-7000 (rev %d.%d) &quot;</span><span class="p">,</span> <span class="n">host</span><span class="o">-&gt;</span><span class="n">rev1</span><span class="p">,</span> <span class="n">host</span><span class="o">-&gt;</span><span class="n">rev2</span><span class="p">);</span>
				<span class="n">printk</span><span class="p">(</span><span class="s">&quot;using IO 0x%x, IRQ %d, DMA %d.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">host</span><span class="o">-&gt;</span><span class="n">iobase</span><span class="p">,</span> <span class="n">host</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">,</span> <span class="n">host</span><span class="o">-&gt;</span><span class="n">dma</span><span class="p">);</span>
				<span class="n">printk</span><span class="p">(</span><span class="s">&quot;  BUS_ON time: %dns, BUS_OFF time: %dns</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">host</span><span class="o">-&gt;</span><span class="n">bus_on</span> <span class="o">*</span> <span class="mi">125</span><span class="p">,</span> <span class="n">host</span><span class="o">-&gt;</span><span class="n">bus_off</span> <span class="o">*</span> <span class="mi">125</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot;wd7000_detect: IO 0x%x region already allocated!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">iobase</span><span class="p">);</span>

		<span class="k">continue</span><span class="p">;</span>

	      <span class="nl">err_unregister:</span>
		<span class="n">scsi_unregister</span><span class="p">(</span><span class="n">sh</span><span class="p">);</span>
	      <span class="nl">err_release:</span>
		<span class="n">release_region</span><span class="p">(</span><span class="n">iobase</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>

	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">present</span><span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;Failed initialization of WD-7000 SCSI card!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="k">return</span> <span class="p">(</span><span class="n">present</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">wd7000_release</span><span class="p">(</span><span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">)</span>
		<span class="n">free_irq</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">io_port</span> <span class="o">&amp;&amp;</span> <span class="n">shost</span><span class="o">-&gt;</span><span class="n">n_io_port</span><span class="p">)</span>
		<span class="n">release_region</span><span class="p">(</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">io_port</span><span class="p">,</span> <span class="n">shost</span><span class="o">-&gt;</span><span class="n">n_io_port</span><span class="p">);</span>
	<span class="n">scsi_unregister</span><span class="p">(</span><span class="n">shost</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#if 0</span><span class="c"></span>
<span class="c">/*</span>
<span class="c"> *  I have absolutely NO idea how to do an abort with the WD7000...</span>
<span class="c"> */</span>
<span class="c">static int wd7000_abort(Scsi_Cmnd * SCpnt)</span>
<span class="c">{</span>
<span class="c">	Adapter *host = (Adapter *) SCpnt-&gt;device-&gt;host-&gt;hostdata;</span>

<span class="c">	if (inb(host-&gt;iobase + ASC_STAT) &amp; INT_IM) {</span>
<span class="c">		printk(&quot;wd7000_abort: lost interrupt\n&quot;);</span>
<span class="c">		wd7000_intr_handle(host-&gt;irq, NULL, NULL);</span>
<span class="c">		return FAILED;</span>
<span class="c">	}</span>
<span class="c">	return FAILED;</span>
<span class="c">}</span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> *  Last resort. Reinitialize the board.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">wd7000_host_reset</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="n">SCpnt</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">Adapter</span> <span class="o">*</span><span class="n">host</span> <span class="o">=</span> <span class="p">(</span><span class="n">Adapter</span> <span class="o">*</span><span class="p">)</span> <span class="n">SCpnt</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">hostdata</span><span class="p">;</span>

	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="n">SCpnt</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">wd7000_adapter_reset</span><span class="p">(</span><span class="n">host</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="n">SCpnt</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">FAILED</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">wd7000_enable_intr</span><span class="p">(</span><span class="n">host</span><span class="p">);</span>

	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="n">SCpnt</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">host_lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">SUCCESS</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *  This was borrowed directly from aha1542.c. (Zaga)</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">wd7000_biosparam</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="n">sdev</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">block_device</span> <span class="o">*</span><span class="n">bdev</span><span class="p">,</span> <span class="n">sector_t</span> <span class="n">capacity</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">ip</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="n">b</span><span class="p">[</span><span class="n">BDEVNAME_SIZE</span><span class="p">];</span>

	<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot;wd7000_biosparam: dev=%s, size=%d, &quot;</span><span class="p">,</span>
		<span class="n">bdevname</span><span class="p">(</span><span class="n">bdev</span><span class="p">,</span> <span class="n">b</span><span class="p">),</span> <span class="n">capacity</span><span class="p">);</span>
	<span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">b</span><span class="p">;</span>	<span class="cm">/* unused var warning? */</span>

	<span class="cm">/*</span>
<span class="cm">	 * try default translation</span>
<span class="cm">	 */</span>
	<span class="n">ip</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">64</span><span class="p">;</span>
	<span class="n">ip</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">32</span><span class="p">;</span>
	<span class="n">ip</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">capacity</span> <span class="o">&gt;&gt;</span> <span class="mi">11</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * for disks &gt;1GB do some guessing</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ip</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">1024</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">info</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>

		<span class="cm">/*</span>
<span class="cm">		 * try to figure out the geometry from the partition table</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">scsicam_bios_param</span><span class="p">(</span><span class="n">bdev</span><span class="p">,</span> <span class="n">capacity</span><span class="p">,</span> <span class="n">info</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">||</span> <span class="o">!</span><span class="p">(((</span><span class="n">info</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">64</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">info</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">32</span><span class="p">))</span> <span class="o">||</span> <span class="p">((</span><span class="n">info</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">255</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">info</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">63</span><span class="p">))))</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot;wd7000_biosparam: unable to verify geometry for disk with &gt;1GB.</span><span class="se">\n</span><span class="s">&quot;</span> <span class="s">&quot;                  using extended translation.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

			<span class="n">ip</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">255</span><span class="p">;</span>
			<span class="n">ip</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">63</span><span class="p">;</span>
			<span class="n">ip</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">capacity</span> <span class="o">/</span> <span class="p">(</span><span class="mi">255</span> <span class="o">*</span> <span class="mi">63</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">ip</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">info</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
			<span class="n">ip</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">info</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
			<span class="n">ip</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">info</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">info</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">255</span><span class="p">)</span>
				<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;%s: current partition table is &quot;</span> <span class="s">&quot;using extended translation.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot;bios geometry: head=%d, sec=%d, cyl=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ip</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">ip</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">ip</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span>
	<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot;WARNING: check, if the bios geometry is correct.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="k">return</span> <span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">MODULE_AUTHOR</span><span class="p">(</span><span class="s">&quot;Thomas Wuensche, John Boyd, Miroslav Zagorac&quot;</span><span class="p">);</span>
<span class="n">MODULE_DESCRIPTION</span><span class="p">(</span><span class="s">&quot;Driver for the WD7000 series ISA controllers&quot;</span><span class="p">);</span>
<span class="n">MODULE_LICENSE</span><span class="p">(</span><span class="s">&quot;GPL&quot;</span><span class="p">);</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">scsi_host_template</span> <span class="n">driver_template</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">proc_name</span>		<span class="o">=</span> <span class="s">&quot;wd7000&quot;</span><span class="p">,</span>
	<span class="p">.</span><span class="n">proc_info</span>		<span class="o">=</span> <span class="n">wd7000_proc_info</span><span class="p">,</span>
	<span class="p">.</span><span class="n">name</span>			<span class="o">=</span> <span class="s">&quot;Western Digital WD-7000&quot;</span><span class="p">,</span>
	<span class="p">.</span><span class="n">detect</span>			<span class="o">=</span> <span class="n">wd7000_detect</span><span class="p">,</span>
	<span class="p">.</span><span class="n">release</span>		<span class="o">=</span> <span class="n">wd7000_release</span><span class="p">,</span>
	<span class="p">.</span><span class="n">queuecommand</span>		<span class="o">=</span> <span class="n">wd7000_queuecommand</span><span class="p">,</span>
	<span class="p">.</span><span class="n">eh_host_reset_handler</span>	<span class="o">=</span> <span class="n">wd7000_host_reset</span><span class="p">,</span>
	<span class="p">.</span><span class="n">bios_param</span>		<span class="o">=</span> <span class="n">wd7000_biosparam</span><span class="p">,</span>
	<span class="p">.</span><span class="n">can_queue</span>		<span class="o">=</span> <span class="n">WD7000_Q</span><span class="p">,</span>
	<span class="p">.</span><span class="n">this_id</span>		<span class="o">=</span> <span class="mi">7</span><span class="p">,</span>
	<span class="p">.</span><span class="n">sg_tablesize</span>		<span class="o">=</span> <span class="n">WD7000_SG</span><span class="p">,</span>
	<span class="p">.</span><span class="n">cmd_per_lun</span>		<span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
	<span class="p">.</span><span class="n">unchecked_isa_dma</span>	<span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
	<span class="p">.</span><span class="n">use_clustering</span>		<span class="o">=</span> <span class="n">ENABLE_CLUSTERING</span><span class="p">,</span>
<span class="p">};</span>

<span class="cp">#include &quot;scsi_module.c&quot;</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
