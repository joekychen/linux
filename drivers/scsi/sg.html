<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › scsi › sg.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>sg.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> *  History:</span>
<span class="cm"> *  Started: Aug 9 by Lawrence Foard (entropy@world.std.com),</span>
<span class="cm"> *           to allow user process control of SCSI devices.</span>
<span class="cm"> *  Development Sponsored by Killy Corp. NY NY</span>
<span class="cm"> *</span>
<span class="cm"> * Original driver (sg.c):</span>
<span class="cm"> *        Copyright (C) 1992 Lawrence Foard</span>
<span class="cm"> * Version 2 and 3 extensions to driver:</span>
<span class="cm"> *        Copyright (C) 1998 - 2005 Douglas Gilbert</span>
<span class="cm"> *</span>
<span class="cm"> *  Modified  19-JAN-1998  Richard Gooch &lt;rgooch@atnf.csiro.au&gt;  Devfs support</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or modify</span>
<span class="cm"> * it under the terms of the GNU General Public License as published by</span>
<span class="cm"> * the Free Software Foundation; either version 2, or (at your option)</span>
<span class="cm"> * any later version.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">sg_version_num</span> <span class="o">=</span> <span class="mi">30534</span><span class="p">;</span>	<span class="cm">/* 2 digits for each component */</span>
<span class="cp">#define SG_VERSION_STR &quot;3.5.34&quot;</span>

<span class="cm">/*</span>
<span class="cm"> *  D. P. Gilbert (dgilbert@interlog.com, dougg@triode.net.au), notes:</span>
<span class="cm"> *      - scsi logging is available via SCSI_LOG_TIMEOUT macros. First</span>
<span class="cm"> *        the kernel/module needs to be built with CONFIG_SCSI_LOGGING</span>
<span class="cm"> *        (otherwise the macros compile to empty statements).</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="cp">#include &lt;linux/module.h&gt;</span>

<span class="cp">#include &lt;linux/fs.h&gt;</span>
<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/sched.h&gt;</span>
<span class="cp">#include &lt;linux/string.h&gt;</span>
<span class="cp">#include &lt;linux/mm.h&gt;</span>
<span class="cp">#include &lt;linux/errno.h&gt;</span>
<span class="cp">#include &lt;linux/mtio.h&gt;</span>
<span class="cp">#include &lt;linux/ioctl.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/fcntl.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/poll.h&gt;</span>
<span class="cp">#include &lt;linux/moduleparam.h&gt;</span>
<span class="cp">#include &lt;linux/cdev.h&gt;</span>
<span class="cp">#include &lt;linux/idr.h&gt;</span>
<span class="cp">#include &lt;linux/seq_file.h&gt;</span>
<span class="cp">#include &lt;linux/blkdev.h&gt;</span>
<span class="cp">#include &lt;linux/delay.h&gt;</span>
<span class="cp">#include &lt;linux/blktrace_api.h&gt;</span>
<span class="cp">#include &lt;linux/mutex.h&gt;</span>
<span class="cp">#include &lt;linux/ratelimit.h&gt;</span>

<span class="cp">#include &quot;scsi.h&quot;</span>
<span class="cp">#include &lt;scsi/scsi_dbg.h&gt;</span>
<span class="cp">#include &lt;scsi/scsi_host.h&gt;</span>
<span class="cp">#include &lt;scsi/scsi_driver.h&gt;</span>
<span class="cp">#include &lt;scsi/scsi_ioctl.h&gt;</span>
<span class="cp">#include &lt;scsi/sg.h&gt;</span>

<span class="cp">#include &quot;scsi_logging.h&quot;</span>

<span class="cp">#ifdef CONFIG_SCSI_PROC_FS</span>
<span class="cp">#include &lt;linux/proc_fs.h&gt;</span>
<span class="k">static</span> <span class="kt">char</span> <span class="o">*</span><span class="n">sg_version_date</span> <span class="o">=</span> <span class="s">&quot;20061027&quot;</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">sg_proc_init</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">sg_proc_cleanup</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="cp">#endif</span>

<span class="cp">#define SG_ALLOW_DIO_DEF 0</span>

<span class="cp">#define SG_MAX_DEVS 32768</span>

<span class="cm">/*</span>
<span class="cm"> * Suppose you want to calculate the formula muldiv(x,m,d)=int(x * m / d)</span>
<span class="cm"> * Then when using 32 bit integers x * m may overflow during the calculation.</span>
<span class="cm"> * Replacing muldiv(x) by muldiv(x)=((x % d) * m) / d + int(x / d) * m</span>
<span class="cm"> * calculates the same, but prevents the overflow when both m and d</span>
<span class="cm"> * are &quot;small&quot; numbers (like HZ and USER_HZ).</span>
<span class="cm"> * Of course an overflow is inavoidable if the result of muldiv doesn&#39;t fit</span>
<span class="cm"> * in 32 bits.</span>
<span class="cm"> */</span>
<span class="cp">#define MULDIV(X,MUL,DIV) ((((X % DIV) * MUL) / DIV) + ((X / DIV) * MUL))</span>

<span class="cp">#define SG_DEFAULT_TIMEOUT MULDIV(SG_DEFAULT_TIMEOUT_USER, HZ, USER_HZ)</span>

<span class="kt">int</span> <span class="n">sg_big_buff</span> <span class="o">=</span> <span class="n">SG_DEF_RESERVED_SIZE</span><span class="p">;</span>
<span class="cm">/* N.B. This variable is readable and writeable via</span>
<span class="cm">   /proc/scsi/sg/def_reserved_size . Each time sg_open() is called a buffer</span>
<span class="cm">   of this size (or less if there is not enough memory) will be reserved</span>
<span class="cm">   for use by this file descriptor. [Deprecated usage: this variable is also</span>
<span class="cm">   readable via /proc/sys/kernel/sg-big-buff if the sg driver is built into</span>
<span class="cm">   the kernel (i.e. it is not a module).] */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">def_reserved_size</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>	<span class="cm">/* picks up init parameter */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">sg_allow_dio</span> <span class="o">=</span> <span class="n">SG_ALLOW_DIO_DEF</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">scatter_elem_sz</span> <span class="o">=</span> <span class="n">SG_SCATTER_SZ</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">scatter_elem_sz_prev</span> <span class="o">=</span> <span class="n">SG_SCATTER_SZ</span><span class="p">;</span>

<span class="cp">#define SG_SECTOR_SZ 512</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">sg_add</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">class_interface</span> <span class="o">*</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">sg_remove</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">class_interface</span> <span class="o">*</span><span class="p">);</span>

<span class="k">static</span> <span class="n">DEFINE_SPINLOCK</span><span class="p">(</span><span class="n">sg_open_exclusive_lock</span><span class="p">);</span>

<span class="k">static</span> <span class="n">DEFINE_IDR</span><span class="p">(</span><span class="n">sg_index_idr</span><span class="p">);</span>
<span class="k">static</span> <span class="n">DEFINE_RWLOCK</span><span class="p">(</span><span class="n">sg_index_lock</span><span class="p">);</span>	<span class="cm">/* Also used to lock</span>
<span class="cm">							   file descriptor list for device */</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">class_interface</span> <span class="n">sg_interface</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">add_dev</span>	<span class="o">=</span> <span class="n">sg_add</span><span class="p">,</span>
	<span class="p">.</span><span class="n">remove_dev</span>	<span class="o">=</span> <span class="n">sg_remove</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">sg_scatter_hold</span> <span class="p">{</span> <span class="cm">/* holding area for scsi scatter gather info */</span>
	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">k_use_sg</span><span class="p">;</span> <span class="cm">/* Count of kernel scatter-gather pieces */</span>
	<span class="kt">unsigned</span> <span class="n">sglist_len</span><span class="p">;</span> <span class="cm">/* size of malloc&#39;d scatter-gather list ++ */</span>
	<span class="kt">unsigned</span> <span class="n">bufflen</span><span class="p">;</span>	<span class="cm">/* Size of (aggregate) data buffer */</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">**</span><span class="n">pages</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">page_order</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">dio_in_use</span><span class="p">;</span>	<span class="cm">/* 0-&gt;indirect IO (or mmap), 1-&gt;dio */</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">cmd_opcode</span><span class="p">;</span> <span class="cm">/* first byte of command */</span>
<span class="p">}</span> <span class="n">Sg_scatter_hold</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">sg_device</span><span class="p">;</span>		<span class="cm">/* forward declarations */</span>
<span class="k">struct</span> <span class="n">sg_fd</span><span class="p">;</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">sg_request</span> <span class="p">{</span>	<span class="cm">/* SG_MAX_QUEUE requests outstanding per file */</span>
	<span class="k">struct</span> <span class="n">sg_request</span> <span class="o">*</span><span class="n">nextrp</span><span class="p">;</span>	<span class="cm">/* NULL -&gt; tail request (slist) */</span>
	<span class="k">struct</span> <span class="n">sg_fd</span> <span class="o">*</span><span class="n">parentfp</span><span class="p">;</span>	<span class="cm">/* NULL -&gt; not in use */</span>
	<span class="n">Sg_scatter_hold</span> <span class="n">data</span><span class="p">;</span>	<span class="cm">/* hold buffer, perhaps scatter list */</span>
	<span class="n">sg_io_hdr_t</span> <span class="n">header</span><span class="p">;</span>	<span class="cm">/* scsi command+info, see &lt;scsi/sg.h&gt; */</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">sense_b</span><span class="p">[</span><span class="n">SCSI_SENSE_BUFFERSIZE</span><span class="p">];</span>
	<span class="kt">char</span> <span class="n">res_used</span><span class="p">;</span>		<span class="cm">/* 1 -&gt; using reserve buffer, 0 -&gt; not ... */</span>
	<span class="kt">char</span> <span class="n">orphan</span><span class="p">;</span>		<span class="cm">/* 1 -&gt; drop on sight, 0 -&gt; normal */</span>
	<span class="kt">char</span> <span class="n">sg_io_owned</span><span class="p">;</span>	<span class="cm">/* 1 -&gt; packet belongs to SG_IO */</span>
	<span class="cm">/* done protected by rq_list_lock */</span>
	<span class="kt">char</span> <span class="n">done</span><span class="p">;</span>		<span class="cm">/* 0-&gt;before bh, 1-&gt;before read, 2-&gt;read */</span>
	<span class="k">struct</span> <span class="n">request</span> <span class="o">*</span><span class="n">rq</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">bio</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">execute_work</span> <span class="n">ew</span><span class="p">;</span>
<span class="p">}</span> <span class="n">Sg_request</span><span class="p">;</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">sg_fd</span> <span class="p">{</span>		<span class="cm">/* holds the state of a file descriptor */</span>
	<span class="cm">/* sfd_siblings is protected by sg_index_lock */</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">sfd_siblings</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sg_device</span> <span class="o">*</span><span class="n">parentdp</span><span class="p">;</span>	<span class="cm">/* owning device */</span>
	<span class="n">wait_queue_head_t</span> <span class="n">read_wait</span><span class="p">;</span>	<span class="cm">/* queue read until command done */</span>
	<span class="n">rwlock_t</span> <span class="n">rq_list_lock</span><span class="p">;</span>	<span class="cm">/* protect access to list in req_arr */</span>
	<span class="kt">int</span> <span class="n">timeout</span><span class="p">;</span>		<span class="cm">/* defaults to SG_DEFAULT_TIMEOUT      */</span>
	<span class="kt">int</span> <span class="n">timeout_user</span><span class="p">;</span>	<span class="cm">/* defaults to SG_DEFAULT_TIMEOUT_USER */</span>
	<span class="n">Sg_scatter_hold</span> <span class="n">reserve</span><span class="p">;</span>	<span class="cm">/* buffer held for this file descriptor */</span>
	<span class="kt">unsigned</span> <span class="n">save_scat_len</span><span class="p">;</span>	<span class="cm">/* original length of trunc. scat. element */</span>
	<span class="n">Sg_request</span> <span class="o">*</span><span class="n">headrp</span><span class="p">;</span>	<span class="cm">/* head of request slist, NULL-&gt;empty */</span>
	<span class="k">struct</span> <span class="n">fasync_struct</span> <span class="o">*</span><span class="n">async_qp</span><span class="p">;</span>	<span class="cm">/* used by asynchronous notification */</span>
	<span class="n">Sg_request</span> <span class="n">req_arr</span><span class="p">[</span><span class="n">SG_MAX_QUEUE</span><span class="p">];</span>	<span class="cm">/* used as singly-linked list */</span>
	<span class="kt">char</span> <span class="n">low_dma</span><span class="p">;</span>		<span class="cm">/* as in parent but possibly overridden to 1 */</span>
	<span class="kt">char</span> <span class="n">force_packid</span><span class="p">;</span>	<span class="cm">/* 1 -&gt; pack_id input to read(), 0 -&gt; ignored */</span>
	<span class="kt">char</span> <span class="n">cmd_q</span><span class="p">;</span>		<span class="cm">/* 1 -&gt; allow command queuing, 0 -&gt; don&#39;t */</span>
	<span class="kt">char</span> <span class="n">next_cmd_len</span><span class="p">;</span>	<span class="cm">/* 0 -&gt; automatic (def), &gt;0 -&gt; use on next write() */</span>
	<span class="kt">char</span> <span class="n">keep_orphan</span><span class="p">;</span>	<span class="cm">/* 0 -&gt; drop orphan (def), 1 -&gt; keep for read() */</span>
	<span class="kt">char</span> <span class="n">mmap_called</span><span class="p">;</span>	<span class="cm">/* 0 -&gt; mmap() never called on this fd */</span>
	<span class="k">struct</span> <span class="n">kref</span> <span class="n">f_ref</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">execute_work</span> <span class="n">ew</span><span class="p">;</span>
<span class="p">}</span> <span class="n">Sg_fd</span><span class="p">;</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">sg_device</span> <span class="p">{</span> <span class="cm">/* holds the state of each scsi generic device */</span>
	<span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="n">device</span><span class="p">;</span>
	<span class="n">wait_queue_head_t</span> <span class="n">o_excl_wait</span><span class="p">;</span>	<span class="cm">/* queue open() when O_EXCL in use */</span>
	<span class="kt">int</span> <span class="n">sg_tablesize</span><span class="p">;</span>	<span class="cm">/* adapter&#39;s max scatter-gather table size */</span>
	<span class="n">u32</span> <span class="n">index</span><span class="p">;</span>		<span class="cm">/* device index number */</span>
	<span class="cm">/* sfds is protected by sg_index_lock */</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">sfds</span><span class="p">;</span>
	<span class="k">volatile</span> <span class="kt">char</span> <span class="n">detached</span><span class="p">;</span>	<span class="cm">/* 0-&gt;attached, 1-&gt;detached pending removal */</span>
	<span class="cm">/* exclude protected by sg_open_exclusive_lock */</span>
	<span class="kt">char</span> <span class="n">exclude</span><span class="p">;</span>		<span class="cm">/* opened for exclusive access */</span>
	<span class="kt">char</span> <span class="n">sgdebug</span><span class="p">;</span>		<span class="cm">/* 0-&gt;off, 1-&gt;sense, 9-&gt;dump dev, 10-&gt; all devs */</span>
	<span class="k">struct</span> <span class="n">gendisk</span> <span class="o">*</span><span class="n">disk</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cdev</span> <span class="o">*</span> <span class="n">cdev</span><span class="p">;</span>	<span class="cm">/* char_dev [sysfs: /sys/cdev/major/sg&lt;n&gt;] */</span>
	<span class="k">struct</span> <span class="n">kref</span> <span class="n">d_ref</span><span class="p">;</span>
<span class="p">}</span> <span class="n">Sg_device</span><span class="p">;</span>

<span class="cm">/* tasklet or soft irq callback */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">sg_rq_end_io</span><span class="p">(</span><span class="k">struct</span> <span class="n">request</span> <span class="o">*</span><span class="n">rq</span><span class="p">,</span> <span class="kt">int</span> <span class="n">uptodate</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">sg_start_req</span><span class="p">(</span><span class="n">Sg_request</span> <span class="o">*</span><span class="n">srp</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">cmd</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">sg_finish_rem_req</span><span class="p">(</span><span class="n">Sg_request</span> <span class="o">*</span> <span class="n">srp</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">sg_build_indirect</span><span class="p">(</span><span class="n">Sg_scatter_hold</span> <span class="o">*</span> <span class="n">schp</span><span class="p">,</span> <span class="n">Sg_fd</span> <span class="o">*</span> <span class="n">sfp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">buff_size</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">ssize_t</span> <span class="n">sg_new_read</span><span class="p">(</span><span class="n">Sg_fd</span> <span class="o">*</span> <span class="n">sfp</span><span class="p">,</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">count</span><span class="p">,</span>
			   <span class="n">Sg_request</span> <span class="o">*</span> <span class="n">srp</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">ssize_t</span> <span class="n">sg_new_write</span><span class="p">(</span><span class="n">Sg_fd</span> <span class="o">*</span><span class="n">sfp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span>
			<span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">count</span><span class="p">,</span> <span class="kt">int</span> <span class="n">blocking</span><span class="p">,</span>
			<span class="kt">int</span> <span class="n">read_only</span><span class="p">,</span> <span class="kt">int</span> <span class="n">sg_io_owned</span><span class="p">,</span> <span class="n">Sg_request</span> <span class="o">**</span><span class="n">o_srp</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">sg_common_write</span><span class="p">(</span><span class="n">Sg_fd</span> <span class="o">*</span> <span class="n">sfp</span><span class="p">,</span> <span class="n">Sg_request</span> <span class="o">*</span> <span class="n">srp</span><span class="p">,</span>
			   <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">cmnd</span><span class="p">,</span> <span class="kt">int</span> <span class="n">timeout</span><span class="p">,</span> <span class="kt">int</span> <span class="n">blocking</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">sg_read_oxfer</span><span class="p">(</span><span class="n">Sg_request</span> <span class="o">*</span> <span class="n">srp</span><span class="p">,</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">outp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">num_read_xfer</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">sg_remove_scat</span><span class="p">(</span><span class="n">Sg_scatter_hold</span> <span class="o">*</span> <span class="n">schp</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">sg_build_reserve</span><span class="p">(</span><span class="n">Sg_fd</span> <span class="o">*</span> <span class="n">sfp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">req_size</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">sg_link_reserve</span><span class="p">(</span><span class="n">Sg_fd</span> <span class="o">*</span> <span class="n">sfp</span><span class="p">,</span> <span class="n">Sg_request</span> <span class="o">*</span> <span class="n">srp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">size</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">sg_unlink_reserve</span><span class="p">(</span><span class="n">Sg_fd</span> <span class="o">*</span> <span class="n">sfp</span><span class="p">,</span> <span class="n">Sg_request</span> <span class="o">*</span> <span class="n">srp</span><span class="p">);</span>
<span class="k">static</span> <span class="n">Sg_fd</span> <span class="o">*</span><span class="n">sg_add_sfp</span><span class="p">(</span><span class="n">Sg_device</span> <span class="o">*</span> <span class="n">sdp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">dev</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">sg_remove_sfp</span><span class="p">(</span><span class="k">struct</span> <span class="n">kref</span> <span class="o">*</span><span class="p">);</span>
<span class="k">static</span> <span class="n">Sg_request</span> <span class="o">*</span><span class="n">sg_get_rq_mark</span><span class="p">(</span><span class="n">Sg_fd</span> <span class="o">*</span> <span class="n">sfp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">pack_id</span><span class="p">);</span>
<span class="k">static</span> <span class="n">Sg_request</span> <span class="o">*</span><span class="n">sg_add_request</span><span class="p">(</span><span class="n">Sg_fd</span> <span class="o">*</span> <span class="n">sfp</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">sg_remove_request</span><span class="p">(</span><span class="n">Sg_fd</span> <span class="o">*</span> <span class="n">sfp</span><span class="p">,</span> <span class="n">Sg_request</span> <span class="o">*</span> <span class="n">srp</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">sg_res_in_use</span><span class="p">(</span><span class="n">Sg_fd</span> <span class="o">*</span> <span class="n">sfp</span><span class="p">);</span>
<span class="k">static</span> <span class="n">Sg_device</span> <span class="o">*</span><span class="n">sg_get_dev</span><span class="p">(</span><span class="kt">int</span> <span class="n">dev</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">sg_put_dev</span><span class="p">(</span><span class="n">Sg_device</span> <span class="o">*</span><span class="n">sdp</span><span class="p">);</span>

<span class="cp">#define SZ_SG_HEADER sizeof(struct sg_header)</span>
<span class="cp">#define SZ_SG_IO_HDR sizeof(sg_io_hdr_t)</span>
<span class="cp">#define SZ_SG_IOVEC sizeof(sg_iovec_t)</span>
<span class="cp">#define SZ_SG_REQ_INFO sizeof(sg_req_info_t)</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">sg_allow_access</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">cmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sg_fd</span> <span class="o">*</span><span class="n">sfp</span> <span class="o">=</span> <span class="n">filp</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sfp</span><span class="o">-&gt;</span><span class="n">parentdp</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="n">TYPE_SCANNER</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">blk_verify_command</span><span class="p">(</span><span class="n">cmd</span><span class="p">,</span> <span class="n">filp</span><span class="o">-&gt;</span><span class="n">f_mode</span> <span class="o">&amp;</span> <span class="n">FMODE_WRITE</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">get_exclude</span><span class="p">(</span><span class="n">Sg_device</span> <span class="o">*</span><span class="n">sdp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sg_open_exclusive_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">sdp</span><span class="o">-&gt;</span><span class="n">exclude</span><span class="p">;</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sg_open_exclusive_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">set_exclude</span><span class="p">(</span><span class="n">Sg_device</span> <span class="o">*</span><span class="n">sdp</span><span class="p">,</span> <span class="kt">char</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sg_open_exclusive_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">sdp</span><span class="o">-&gt;</span><span class="n">exclude</span> <span class="o">=</span> <span class="n">val</span><span class="p">;</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sg_open_exclusive_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">val</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">sfds_list_empty</span><span class="p">(</span><span class="n">Sg_device</span> <span class="o">*</span><span class="n">sdp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">read_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sg_index_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sdp</span><span class="o">-&gt;</span><span class="n">sfds</span><span class="p">);</span>
	<span class="n">read_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sg_index_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">sg_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">dev</span> <span class="o">=</span> <span class="n">iminor</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">flags</span> <span class="o">=</span> <span class="n">filp</span><span class="o">-&gt;</span><span class="n">f_flags</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">;</span>
	<span class="n">Sg_device</span> <span class="o">*</span><span class="n">sdp</span><span class="p">;</span>
	<span class="n">Sg_fd</span> <span class="o">*</span><span class="n">sfp</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">res</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">retval</span><span class="p">;</span>

	<span class="n">nonseekable_open</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">filp</span><span class="p">);</span>
	<span class="n">SCSI_LOG_TIMEOUT</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">printk</span><span class="p">(</span><span class="s">&quot;sg_open: dev=%d, flags=0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="n">flags</span><span class="p">));</span>
	<span class="n">sdp</span> <span class="o">=</span> <span class="n">sg_get_dev</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">sdp</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">sdp</span><span class="p">);</span>
		<span class="n">sdp</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">sg_put</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* This driver&#39;s module count bumped by fops_get in &lt;linux/fs.h&gt; */</span>
	<span class="cm">/* Prevent the device driver from vanishing while we sleep */</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="n">scsi_device_get</span><span class="p">(</span><span class="n">sdp</span><span class="o">-&gt;</span><span class="n">device</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">sg_put</span><span class="p">;</span>

	<span class="n">retval</span> <span class="o">=</span> <span class="n">scsi_autopm_get_device</span><span class="p">(</span><span class="n">sdp</span><span class="o">-&gt;</span><span class="n">device</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">sdp_put</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">((</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">O_NONBLOCK</span><span class="p">)</span> <span class="o">||</span>
	      <span class="n">scsi_block_when_processing_errors</span><span class="p">(</span><span class="n">sdp</span><span class="o">-&gt;</span><span class="n">device</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENXIO</span><span class="p">;</span>
		<span class="cm">/* we are in error recovery for this device */</span>
		<span class="k">goto</span> <span class="n">error_out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">O_EXCL</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">O_RDONLY</span> <span class="o">==</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">O_ACCMODE</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span> <span class="cm">/* Can&#39;t lock it with read only access */</span>
			<span class="k">goto</span> <span class="n">error_out</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sfds_list_empty</span><span class="p">(</span><span class="n">sdp</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">O_NONBLOCK</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">error_out</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">res</span> <span class="o">=</span> <span class="n">wait_event_interruptible</span><span class="p">(</span><span class="n">sdp</span><span class="o">-&gt;</span><span class="n">o_excl_wait</span><span class="p">,</span>
					   <span class="p">((</span><span class="o">!</span><span class="n">sfds_list_empty</span><span class="p">(</span><span class="n">sdp</span><span class="p">)</span> <span class="o">||</span> <span class="n">get_exclude</span><span class="p">(</span><span class="n">sdp</span><span class="p">))</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="n">set_exclude</span><span class="p">(</span><span class="n">sdp</span><span class="p">,</span> <span class="mi">1</span><span class="p">)));</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">res</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">retval</span> <span class="o">=</span> <span class="n">res</span><span class="p">;</span>	<span class="cm">/* -ERESTARTSYS because signal hit process */</span>
			<span class="k">goto</span> <span class="n">error_out</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">get_exclude</span><span class="p">(</span><span class="n">sdp</span><span class="p">))</span> <span class="p">{</span>	<span class="cm">/* some other fd has an exclusive lock on dev */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">O_NONBLOCK</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">error_out</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">res</span> <span class="o">=</span> <span class="n">wait_event_interruptible</span><span class="p">(</span><span class="n">sdp</span><span class="o">-&gt;</span><span class="n">o_excl_wait</span><span class="p">,</span> <span class="o">!</span><span class="n">get_exclude</span><span class="p">(</span><span class="n">sdp</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">res</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">retval</span> <span class="o">=</span> <span class="n">res</span><span class="p">;</span>	<span class="cm">/* -ERESTARTSYS because signal hit process */</span>
			<span class="k">goto</span> <span class="n">error_out</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sdp</span><span class="o">-&gt;</span><span class="n">detached</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">error_out</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sfds_list_empty</span><span class="p">(</span><span class="n">sdp</span><span class="p">))</span> <span class="p">{</span>	<span class="cm">/* no existing opens on this device */</span>
		<span class="n">sdp</span><span class="o">-&gt;</span><span class="n">sgdebug</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">q</span> <span class="o">=</span> <span class="n">sdp</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">request_queue</span><span class="p">;</span>
		<span class="n">sdp</span><span class="o">-&gt;</span><span class="n">sg_tablesize</span> <span class="o">=</span> <span class="n">queue_max_segments</span><span class="p">(</span><span class="n">q</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">sfp</span> <span class="o">=</span> <span class="n">sg_add_sfp</span><span class="p">(</span><span class="n">sdp</span><span class="p">,</span> <span class="n">dev</span><span class="p">)))</span>
		<span class="n">filp</span><span class="o">-&gt;</span><span class="n">private_data</span> <span class="o">=</span> <span class="n">sfp</span><span class="p">;</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">O_EXCL</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">set_exclude</span><span class="p">(</span><span class="n">sdp</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>	<span class="cm">/* undo if error */</span>
			<span class="n">wake_up_interruptible</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sdp</span><span class="o">-&gt;</span><span class="n">o_excl_wait</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">error_out</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">error_out:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">scsi_autopm_put_device</span><span class="p">(</span><span class="n">sdp</span><span class="o">-&gt;</span><span class="n">device</span><span class="p">);</span>
<span class="nl">sdp_put:</span>
		<span class="n">scsi_device_put</span><span class="p">(</span><span class="n">sdp</span><span class="o">-&gt;</span><span class="n">device</span><span class="p">);</span>
	<span class="p">}</span>
<span class="nl">sg_put:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sdp</span><span class="p">)</span>
		<span class="n">sg_put_dev</span><span class="p">(</span><span class="n">sdp</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Following function was formerly called &#39;sg_close&#39; */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">sg_release</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">Sg_device</span> <span class="o">*</span><span class="n">sdp</span><span class="p">;</span>
	<span class="n">Sg_fd</span> <span class="o">*</span><span class="n">sfp</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="o">!</span><span class="p">(</span><span class="n">sfp</span> <span class="o">=</span> <span class="p">(</span><span class="n">Sg_fd</span> <span class="o">*</span><span class="p">)</span> <span class="n">filp</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">))</span> <span class="o">||</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">sdp</span> <span class="o">=</span> <span class="n">sfp</span><span class="o">-&gt;</span><span class="n">parentdp</span><span class="p">)))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENXIO</span><span class="p">;</span>
	<span class="n">SCSI_LOG_TIMEOUT</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">printk</span><span class="p">(</span><span class="s">&quot;sg_release: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">sdp</span><span class="o">-&gt;</span><span class="n">disk</span><span class="o">-&gt;</span><span class="n">disk_name</span><span class="p">));</span>

	<span class="n">set_exclude</span><span class="p">(</span><span class="n">sdp</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">wake_up_interruptible</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sdp</span><span class="o">-&gt;</span><span class="n">o_excl_wait</span><span class="p">);</span>

	<span class="n">scsi_autopm_put_device</span><span class="p">(</span><span class="n">sdp</span><span class="o">-&gt;</span><span class="n">device</span><span class="p">);</span>
	<span class="n">kref_put</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sfp</span><span class="o">-&gt;</span><span class="n">f_ref</span><span class="p">,</span> <span class="n">sg_remove_sfp</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span>
<span class="nf">sg_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">count</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span> <span class="n">ppos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">Sg_device</span> <span class="o">*</span><span class="n">sdp</span><span class="p">;</span>
	<span class="n">Sg_fd</span> <span class="o">*</span><span class="n">sfp</span><span class="p">;</span>
	<span class="n">Sg_request</span> <span class="o">*</span><span class="n">srp</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">req_pack_id</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">sg_io_hdr_t</span> <span class="o">*</span><span class="n">hp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sg_header</span> <span class="o">*</span><span class="n">old_hdr</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">retval</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="o">!</span><span class="p">(</span><span class="n">sfp</span> <span class="o">=</span> <span class="p">(</span><span class="n">Sg_fd</span> <span class="o">*</span><span class="p">)</span> <span class="n">filp</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">))</span> <span class="o">||</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">sdp</span> <span class="o">=</span> <span class="n">sfp</span><span class="o">-&gt;</span><span class="n">parentdp</span><span class="p">)))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENXIO</span><span class="p">;</span>
	<span class="n">SCSI_LOG_TIMEOUT</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">printk</span><span class="p">(</span><span class="s">&quot;sg_read: %s, count=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				   <span class="n">sdp</span><span class="o">-&gt;</span><span class="n">disk</span><span class="o">-&gt;</span><span class="n">disk_name</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="n">count</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">access_ok</span><span class="p">(</span><span class="n">VERIFY_WRITE</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">count</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sfp</span><span class="o">-&gt;</span><span class="n">force_packid</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">count</span> <span class="o">&gt;=</span> <span class="n">SZ_SG_HEADER</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">old_hdr</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="n">SZ_SG_HEADER</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">old_hdr</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">__copy_from_user</span><span class="p">(</span><span class="n">old_hdr</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">SZ_SG_HEADER</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">free_old_hdr</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">old_hdr</span><span class="o">-&gt;</span><span class="n">reply_len</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">&gt;=</span> <span class="n">SZ_SG_IO_HDR</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">sg_io_hdr_t</span> <span class="o">*</span><span class="n">new_hdr</span><span class="p">;</span>
				<span class="n">new_hdr</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="n">SZ_SG_IO_HDR</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">new_hdr</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
					<span class="k">goto</span> <span class="n">free_old_hdr</span><span class="p">;</span>
				<span class="p">}</span>
				<span class="n">retval</span> <span class="o">=</span><span class="n">__copy_from_user</span>
				    <span class="p">(</span><span class="n">new_hdr</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">SZ_SG_IO_HDR</span><span class="p">);</span>
				<span class="n">req_pack_id</span> <span class="o">=</span> <span class="n">new_hdr</span><span class="o">-&gt;</span><span class="n">pack_id</span><span class="p">;</span>
				<span class="n">kfree</span><span class="p">(</span><span class="n">new_hdr</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">retval</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
					<span class="k">goto</span> <span class="n">free_old_hdr</span><span class="p">;</span>
				<span class="p">}</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="n">req_pack_id</span> <span class="o">=</span> <span class="n">old_hdr</span><span class="o">-&gt;</span><span class="n">pack_id</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">srp</span> <span class="o">=</span> <span class="n">sg_get_rq_mark</span><span class="p">(</span><span class="n">sfp</span><span class="p">,</span> <span class="n">req_pack_id</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">srp</span><span class="p">)</span> <span class="p">{</span>		<span class="cm">/* now wait on packet to arrive */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sdp</span><span class="o">-&gt;</span><span class="n">detached</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">free_old_hdr</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">filp</span><span class="o">-&gt;</span><span class="n">f_flags</span> <span class="o">&amp;</span> <span class="n">O_NONBLOCK</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">free_old_hdr</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="n">wait_event_interruptible</span><span class="p">(</span><span class="n">sfp</span><span class="o">-&gt;</span><span class="n">read_wait</span><span class="p">,</span>
			<span class="p">(</span><span class="n">sdp</span><span class="o">-&gt;</span><span class="n">detached</span> <span class="o">||</span>
			<span class="p">(</span><span class="n">srp</span> <span class="o">=</span> <span class="n">sg_get_rq_mark</span><span class="p">(</span><span class="n">sfp</span><span class="p">,</span> <span class="n">req_pack_id</span><span class="p">))));</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sdp</span><span class="o">-&gt;</span><span class="n">detached</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">free_old_hdr</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">retval</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* -ERESTARTSYS as signal hit process */</span>
			<span class="k">goto</span> <span class="n">free_old_hdr</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">srp</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">interface_id</span> <span class="o">!=</span> <span class="sc">&#39;\0&#39;</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="n">sg_new_read</span><span class="p">(</span><span class="n">sfp</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">count</span><span class="p">,</span> <span class="n">srp</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">free_old_hdr</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">hp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">srp</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">old_hdr</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">old_hdr</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="n">SZ_SG_HEADER</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span> <span class="n">old_hdr</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">free_old_hdr</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">old_hdr</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">SZ_SG_HEADER</span><span class="p">);</span>
	<span class="n">old_hdr</span><span class="o">-&gt;</span><span class="n">reply_len</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="n">hp</span><span class="o">-&gt;</span><span class="n">timeout</span><span class="p">;</span>
	<span class="n">old_hdr</span><span class="o">-&gt;</span><span class="n">pack_len</span> <span class="o">=</span> <span class="n">old_hdr</span><span class="o">-&gt;</span><span class="n">reply_len</span><span class="p">;</span> <span class="cm">/* old, strange behaviour */</span>
	<span class="n">old_hdr</span><span class="o">-&gt;</span><span class="n">pack_id</span> <span class="o">=</span> <span class="n">hp</span><span class="o">-&gt;</span><span class="n">pack_id</span><span class="p">;</span>
	<span class="n">old_hdr</span><span class="o">-&gt;</span><span class="n">twelve_byte</span> <span class="o">=</span>
	    <span class="p">((</span><span class="n">srp</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">.</span><span class="n">cmd_opcode</span> <span class="o">&gt;=</span> <span class="mh">0xc0</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="mi">12</span> <span class="o">==</span> <span class="n">hp</span><span class="o">-&gt;</span><span class="n">cmd_len</span><span class="p">))</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">old_hdr</span><span class="o">-&gt;</span><span class="n">target_status</span> <span class="o">=</span> <span class="n">hp</span><span class="o">-&gt;</span><span class="n">masked_status</span><span class="p">;</span>
	<span class="n">old_hdr</span><span class="o">-&gt;</span><span class="n">host_status</span> <span class="o">=</span> <span class="n">hp</span><span class="o">-&gt;</span><span class="n">host_status</span><span class="p">;</span>
	<span class="n">old_hdr</span><span class="o">-&gt;</span><span class="n">driver_status</span> <span class="o">=</span> <span class="n">hp</span><span class="o">-&gt;</span><span class="n">driver_status</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">CHECK_CONDITION</span> <span class="o">&amp;</span> <span class="n">hp</span><span class="o">-&gt;</span><span class="n">masked_status</span><span class="p">)</span> <span class="o">||</span>
	    <span class="p">(</span><span class="n">DRIVER_SENSE</span> <span class="o">&amp;</span> <span class="n">hp</span><span class="o">-&gt;</span><span class="n">driver_status</span><span class="p">))</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">old_hdr</span><span class="o">-&gt;</span><span class="n">sense_buffer</span><span class="p">,</span> <span class="n">srp</span><span class="o">-&gt;</span><span class="n">sense_b</span><span class="p">,</span>
		       <span class="k">sizeof</span> <span class="p">(</span><span class="n">old_hdr</span><span class="o">-&gt;</span><span class="n">sense_buffer</span><span class="p">));</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">hp</span><span class="o">-&gt;</span><span class="n">host_status</span><span class="p">)</span> <span class="p">{</span>
	<span class="cm">/* This setup of &#39;result&#39; is for backward compatibility and is best</span>
<span class="cm">	   ignored by the user who should use target, host + driver status */</span>
	<span class="k">case</span> <span class="n">DID_OK</span>:
	<span class="k">case</span> <span class="n">DID_PASSTHROUGH</span>:
	<span class="k">case</span> <span class="n">DID_SOFT_ERROR</span>:
		<span class="n">old_hdr</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">DID_NO_CONNECT</span>:
	<span class="k">case</span> <span class="n">DID_BUS_BUSY</span>:
	<span class="k">case</span> <span class="n">DID_TIME_OUT</span>:
		<span class="n">old_hdr</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">=</span> <span class="n">EBUSY</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">DID_BAD_TARGET</span>:
	<span class="k">case</span> <span class="n">DID_ABORT</span>:
	<span class="k">case</span> <span class="n">DID_PARITY</span>:
	<span class="k">case</span> <span class="n">DID_RESET</span>:
	<span class="k">case</span> <span class="n">DID_BAD_INTR</span>:
		<span class="n">old_hdr</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">=</span> <span class="n">EIO</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">DID_ERROR</span>:
		<span class="n">old_hdr</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">=</span> <span class="p">(</span><span class="n">srp</span><span class="o">-&gt;</span><span class="n">sense_b</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> 
				  <span class="n">hp</span><span class="o">-&gt;</span><span class="n">masked_status</span> <span class="o">==</span> <span class="n">GOOD</span><span class="p">)</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="n">EIO</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">old_hdr</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">=</span> <span class="n">EIO</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Now copy the result back to the user buffer.  */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">&gt;=</span> <span class="n">SZ_SG_HEADER</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">__copy_to_user</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">old_hdr</span><span class="p">,</span> <span class="n">SZ_SG_HEADER</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">free_old_hdr</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">buf</span> <span class="o">+=</span> <span class="n">SZ_SG_HEADER</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">&gt;</span> <span class="n">old_hdr</span><span class="o">-&gt;</span><span class="n">reply_len</span><span class="p">)</span>
			<span class="n">count</span> <span class="o">=</span> <span class="n">old_hdr</span><span class="o">-&gt;</span><span class="n">reply_len</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">&gt;</span> <span class="n">SZ_SG_HEADER</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">sg_read_oxfer</span><span class="p">(</span><span class="n">srp</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">count</span> <span class="o">-</span> <span class="n">SZ_SG_HEADER</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
				<span class="k">goto</span> <span class="n">free_old_hdr</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">count</span> <span class="o">=</span> <span class="p">(</span><span class="n">old_hdr</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="n">sg_finish_rem_req</span><span class="p">(</span><span class="n">srp</span><span class="p">);</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="n">count</span><span class="p">;</span>
<span class="nl">free_old_hdr:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">old_hdr</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span>
<span class="nf">sg_new_read</span><span class="p">(</span><span class="n">Sg_fd</span> <span class="o">*</span> <span class="n">sfp</span><span class="p">,</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">count</span><span class="p">,</span> <span class="n">Sg_request</span> <span class="o">*</span> <span class="n">srp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">sg_io_hdr_t</span> <span class="o">*</span><span class="n">hp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">srp</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">len</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">&lt;</span> <span class="n">SZ_SG_IO_HDR</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">err_out</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">hp</span><span class="o">-&gt;</span><span class="n">sb_len_wr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">hp</span><span class="o">-&gt;</span><span class="n">mx_sb_len</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">hp</span><span class="o">-&gt;</span><span class="n">sbp</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">CHECK_CONDITION</span> <span class="o">&amp;</span> <span class="n">hp</span><span class="o">-&gt;</span><span class="n">masked_status</span><span class="p">)</span> <span class="o">||</span>
		    <span class="p">(</span><span class="n">DRIVER_SENSE</span> <span class="o">&amp;</span> <span class="n">hp</span><span class="o">-&gt;</span><span class="n">driver_status</span><span class="p">))</span> <span class="p">{</span>
			<span class="kt">int</span> <span class="n">sb_len</span> <span class="o">=</span> <span class="n">SCSI_SENSE_BUFFERSIZE</span><span class="p">;</span>
			<span class="n">sb_len</span> <span class="o">=</span> <span class="p">(</span><span class="n">hp</span><span class="o">-&gt;</span><span class="n">mx_sb_len</span> <span class="o">&gt;</span> <span class="n">sb_len</span><span class="p">)</span> <span class="o">?</span> <span class="n">sb_len</span> <span class="o">:</span> <span class="n">hp</span><span class="o">-&gt;</span><span class="n">mx_sb_len</span><span class="p">;</span>
			<span class="n">len</span> <span class="o">=</span> <span class="mi">8</span> <span class="o">+</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="n">srp</span><span class="o">-&gt;</span><span class="n">sense_b</span><span class="p">[</span><span class="mi">7</span><span class="p">];</span>	<span class="cm">/* Additional sense length field */</span>
			<span class="n">len</span> <span class="o">=</span> <span class="p">(</span><span class="n">len</span> <span class="o">&gt;</span> <span class="n">sb_len</span><span class="p">)</span> <span class="o">?</span> <span class="n">sb_len</span> <span class="o">:</span> <span class="n">len</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">copy_to_user</span><span class="p">(</span><span class="n">hp</span><span class="o">-&gt;</span><span class="n">sbp</span><span class="p">,</span> <span class="n">srp</span><span class="o">-&gt;</span><span class="n">sense_b</span><span class="p">,</span> <span class="n">len</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
				<span class="k">goto</span> <span class="n">err_out</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">hp</span><span class="o">-&gt;</span><span class="n">sb_len_wr</span> <span class="o">=</span> <span class="n">len</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hp</span><span class="o">-&gt;</span><span class="n">masked_status</span> <span class="o">||</span> <span class="n">hp</span><span class="o">-&gt;</span><span class="n">host_status</span> <span class="o">||</span> <span class="n">hp</span><span class="o">-&gt;</span><span class="n">driver_status</span><span class="p">)</span>
		<span class="n">hp</span><span class="o">-&gt;</span><span class="n">info</span> <span class="o">|=</span> <span class="n">SG_INFO_CHECK</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">copy_to_user</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">hp</span><span class="p">,</span> <span class="n">SZ_SG_IO_HDR</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">err_out</span><span class="p">;</span>
	<span class="p">}</span>
<span class="nl">err_out:</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">sg_finish_rem_req</span><span class="p">(</span><span class="n">srp</span><span class="p">);</span>
	<span class="k">return</span> <span class="p">(</span><span class="mi">0</span> <span class="o">==</span> <span class="n">err</span><span class="p">)</span> <span class="o">?</span> <span class="n">count</span> <span class="o">:</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span>
<span class="nf">sg_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">count</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span> <span class="n">ppos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">mxsize</span><span class="p">,</span> <span class="n">cmd_size</span><span class="p">,</span> <span class="n">k</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">input_size</span><span class="p">,</span> <span class="n">blocking</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">opcode</span><span class="p">;</span>
	<span class="n">Sg_device</span> <span class="o">*</span><span class="n">sdp</span><span class="p">;</span>
	<span class="n">Sg_fd</span> <span class="o">*</span><span class="n">sfp</span><span class="p">;</span>
	<span class="n">Sg_request</span> <span class="o">*</span><span class="n">srp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sg_header</span> <span class="n">old_hdr</span><span class="p">;</span>
	<span class="n">sg_io_hdr_t</span> <span class="o">*</span><span class="n">hp</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">cmnd</span><span class="p">[</span><span class="n">MAX_COMMAND_SIZE</span><span class="p">];</span>

	<span class="k">if</span> <span class="p">((</span><span class="o">!</span><span class="p">(</span><span class="n">sfp</span> <span class="o">=</span> <span class="p">(</span><span class="n">Sg_fd</span> <span class="o">*</span><span class="p">)</span> <span class="n">filp</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">))</span> <span class="o">||</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">sdp</span> <span class="o">=</span> <span class="n">sfp</span><span class="o">-&gt;</span><span class="n">parentdp</span><span class="p">)))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENXIO</span><span class="p">;</span>
	<span class="n">SCSI_LOG_TIMEOUT</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">printk</span><span class="p">(</span><span class="s">&quot;sg_write: %s, count=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				   <span class="n">sdp</span><span class="o">-&gt;</span><span class="n">disk</span><span class="o">-&gt;</span><span class="n">disk_name</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="n">count</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sdp</span><span class="o">-&gt;</span><span class="n">detached</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">((</span><span class="n">filp</span><span class="o">-&gt;</span><span class="n">f_flags</span> <span class="o">&amp;</span> <span class="n">O_NONBLOCK</span><span class="p">)</span> <span class="o">||</span>
	      <span class="n">scsi_block_when_processing_errors</span><span class="p">(</span><span class="n">sdp</span><span class="o">-&gt;</span><span class="n">device</span><span class="p">)))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENXIO</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">access_ok</span><span class="p">(</span><span class="n">VERIFY_READ</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">count</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>	<span class="cm">/* protects following copy_from_user()s + get_user()s */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">&lt;</span> <span class="n">SZ_SG_HEADER</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">__copy_from_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">old_hdr</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">SZ_SG_HEADER</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="n">blocking</span> <span class="o">=</span> <span class="o">!</span><span class="p">(</span><span class="n">filp</span><span class="o">-&gt;</span><span class="n">f_flags</span> <span class="o">&amp;</span> <span class="n">O_NONBLOCK</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">old_hdr</span><span class="p">.</span><span class="n">reply_len</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">sg_new_write</span><span class="p">(</span><span class="n">sfp</span><span class="p">,</span> <span class="n">filp</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">count</span><span class="p">,</span>
				    <span class="n">blocking</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">SZ_SG_HEADER</span> <span class="o">+</span> <span class="mi">6</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>	<span class="cm">/* The minimum scsi command length is 6 bytes. */</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">srp</span> <span class="o">=</span> <span class="n">sg_add_request</span><span class="p">(</span><span class="n">sfp</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">SCSI_LOG_TIMEOUT</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">printk</span><span class="p">(</span><span class="s">&quot;sg_write: queue full</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">));</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EDOM</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">buf</span> <span class="o">+=</span> <span class="n">SZ_SG_HEADER</span><span class="p">;</span>
	<span class="n">__get_user</span><span class="p">(</span><span class="n">opcode</span><span class="p">,</span> <span class="n">buf</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sfp</span><span class="o">-&gt;</span><span class="n">next_cmd_len</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sfp</span><span class="o">-&gt;</span><span class="n">next_cmd_len</span> <span class="o">&gt;</span> <span class="n">MAX_COMMAND_SIZE</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">SCSI_LOG_TIMEOUT</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">printk</span><span class="p">(</span><span class="s">&quot;sg_write: command length too long</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">));</span>
			<span class="n">sfp</span><span class="o">-&gt;</span><span class="n">next_cmd_len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">sg_remove_request</span><span class="p">(</span><span class="n">sfp</span><span class="p">,</span> <span class="n">srp</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">cmd_size</span> <span class="o">=</span> <span class="n">sfp</span><span class="o">-&gt;</span><span class="n">next_cmd_len</span><span class="p">;</span>
		<span class="n">sfp</span><span class="o">-&gt;</span><span class="n">next_cmd_len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>	<span class="cm">/* reset so only this write() effected */</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">cmd_size</span> <span class="o">=</span> <span class="n">COMMAND_SIZE</span><span class="p">(</span><span class="n">opcode</span><span class="p">);</span>	<span class="cm">/* based on SCSI command group */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">opcode</span> <span class="o">&gt;=</span> <span class="mh">0xc0</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">old_hdr</span><span class="p">.</span><span class="n">twelve_byte</span><span class="p">)</span>
			<span class="n">cmd_size</span> <span class="o">=</span> <span class="mi">12</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">SCSI_LOG_TIMEOUT</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="n">printk</span><span class="p">(</span>
		<span class="s">&quot;sg_write:   scsi opcode=0x%02x, cmd_size=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="n">opcode</span><span class="p">,</span> <span class="n">cmd_size</span><span class="p">));</span>
<span class="cm">/* Determine buffer size.  */</span>
	<span class="n">input_size</span> <span class="o">=</span> <span class="n">count</span> <span class="o">-</span> <span class="n">cmd_size</span><span class="p">;</span>
	<span class="n">mxsize</span> <span class="o">=</span> <span class="p">(</span><span class="n">input_size</span> <span class="o">&gt;</span> <span class="n">old_hdr</span><span class="p">.</span><span class="n">reply_len</span><span class="p">)</span> <span class="o">?</span> <span class="n">input_size</span> <span class="o">:</span> <span class="n">old_hdr</span><span class="p">.</span><span class="n">reply_len</span><span class="p">;</span>
	<span class="n">mxsize</span> <span class="o">-=</span> <span class="n">SZ_SG_HEADER</span><span class="p">;</span>
	<span class="n">input_size</span> <span class="o">-=</span> <span class="n">SZ_SG_HEADER</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">input_size</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">sg_remove_request</span><span class="p">(</span><span class="n">sfp</span><span class="p">,</span> <span class="n">srp</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>	<span class="cm">/* User did not pass enough bytes for this command. */</span>
	<span class="p">}</span>
	<span class="n">hp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">srp</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">;</span>
	<span class="n">hp</span><span class="o">-&gt;</span><span class="n">interface_id</span> <span class="o">=</span> <span class="sc">&#39;\0&#39;</span><span class="p">;</span>	<span class="cm">/* indicator of old interface tunnelled */</span>
	<span class="n">hp</span><span class="o">-&gt;</span><span class="n">cmd_len</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="p">)</span> <span class="n">cmd_size</span><span class="p">;</span>
	<span class="n">hp</span><span class="o">-&gt;</span><span class="n">iovec_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">hp</span><span class="o">-&gt;</span><span class="n">mx_sb_len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">input_size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">hp</span><span class="o">-&gt;</span><span class="n">dxfer_direction</span> <span class="o">=</span> <span class="p">(</span><span class="n">old_hdr</span><span class="p">.</span><span class="n">reply_len</span> <span class="o">&gt;</span> <span class="n">SZ_SG_HEADER</span><span class="p">)</span> <span class="o">?</span>
		    <span class="n">SG_DXFER_TO_FROM_DEV</span> <span class="o">:</span> <span class="n">SG_DXFER_TO_DEV</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">hp</span><span class="o">-&gt;</span><span class="n">dxfer_direction</span> <span class="o">=</span> <span class="p">(</span><span class="n">mxsize</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">?</span> <span class="n">SG_DXFER_FROM_DEV</span> <span class="o">:</span> <span class="n">SG_DXFER_NONE</span><span class="p">;</span>
	<span class="n">hp</span><span class="o">-&gt;</span><span class="n">dxfer_len</span> <span class="o">=</span> <span class="n">mxsize</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hp</span><span class="o">-&gt;</span><span class="n">dxfer_direction</span> <span class="o">==</span> <span class="n">SG_DXFER_TO_DEV</span><span class="p">)</span>
		<span class="n">hp</span><span class="o">-&gt;</span><span class="n">dxferp</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span><span class="n">buf</span> <span class="o">+</span> <span class="n">cmd_size</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">hp</span><span class="o">-&gt;</span><span class="n">dxferp</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">hp</span><span class="o">-&gt;</span><span class="n">sbp</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">hp</span><span class="o">-&gt;</span><span class="n">timeout</span> <span class="o">=</span> <span class="n">old_hdr</span><span class="p">.</span><span class="n">reply_len</span><span class="p">;</span>	<span class="cm">/* structure abuse ... */</span>
	<span class="n">hp</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">=</span> <span class="n">input_size</span><span class="p">;</span>	<span class="cm">/* structure abuse ... */</span>
	<span class="n">hp</span><span class="o">-&gt;</span><span class="n">pack_id</span> <span class="o">=</span> <span class="n">old_hdr</span><span class="p">.</span><span class="n">pack_id</span><span class="p">;</span>
	<span class="n">hp</span><span class="o">-&gt;</span><span class="n">usr_ptr</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">__copy_from_user</span><span class="p">(</span><span class="n">cmnd</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">cmd_size</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * SG_DXFER_TO_FROM_DEV is functionally equivalent to SG_DXFER_FROM_DEV,</span>
<span class="cm">	 * but is is possible that the app intended SG_DXFER_TO_DEV, because there</span>
<span class="cm">	 * is a non-zero input_size, so emit a warning.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hp</span><span class="o">-&gt;</span><span class="n">dxfer_direction</span> <span class="o">==</span> <span class="n">SG_DXFER_TO_FROM_DEV</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">static</span> <span class="kt">char</span> <span class="n">cmd</span><span class="p">[</span><span class="n">TASK_COMM_LEN</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">comm</span><span class="p">,</span> <span class="n">cmd</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">printk_ratelimited</span><span class="p">(</span><span class="n">KERN_WARNING</span>
					   <span class="s">&quot;sg_write: data in/out %d/%d bytes &quot;</span>
					   <span class="s">&quot;for SCSI command 0x%x-- guessing &quot;</span>
					   <span class="s">&quot;data in;</span><span class="se">\n</span><span class="s">   program %s not setting &quot;</span>
					   <span class="s">&quot;count and/or reply_len properly</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					   <span class="n">old_hdr</span><span class="p">.</span><span class="n">reply_len</span> <span class="o">-</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">SZ_SG_HEADER</span><span class="p">,</span>
					   <span class="n">input_size</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)</span> <span class="n">cmnd</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
					   <span class="n">current</span><span class="o">-&gt;</span><span class="n">comm</span><span class="p">);</span>
			<span class="n">strcpy</span><span class="p">(</span><span class="n">cmd</span><span class="p">,</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">comm</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">k</span> <span class="o">=</span> <span class="n">sg_common_write</span><span class="p">(</span><span class="n">sfp</span><span class="p">,</span> <span class="n">srp</span><span class="p">,</span> <span class="n">cmnd</span><span class="p">,</span> <span class="n">sfp</span><span class="o">-&gt;</span><span class="n">timeout</span><span class="p">,</span> <span class="n">blocking</span><span class="p">);</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">k</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">?</span> <span class="n">k</span> <span class="o">:</span> <span class="n">count</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span>
<span class="nf">sg_new_write</span><span class="p">(</span><span class="n">Sg_fd</span> <span class="o">*</span><span class="n">sfp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span>
		 <span class="kt">size_t</span> <span class="n">count</span><span class="p">,</span> <span class="kt">int</span> <span class="n">blocking</span><span class="p">,</span> <span class="kt">int</span> <span class="n">read_only</span><span class="p">,</span> <span class="kt">int</span> <span class="n">sg_io_owned</span><span class="p">,</span>
		 <span class="n">Sg_request</span> <span class="o">**</span><span class="n">o_srp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">k</span><span class="p">;</span>
	<span class="n">Sg_request</span> <span class="o">*</span><span class="n">srp</span><span class="p">;</span>
	<span class="n">sg_io_hdr_t</span> <span class="o">*</span><span class="n">hp</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">cmnd</span><span class="p">[</span><span class="n">MAX_COMMAND_SIZE</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">timeout</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ul_timeout</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">&lt;</span> <span class="n">SZ_SG_IO_HDR</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">access_ok</span><span class="p">(</span><span class="n">VERIFY_READ</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">count</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span> <span class="cm">/* protects following copy_from_user()s + get_user()s */</span>

	<span class="n">sfp</span><span class="o">-&gt;</span><span class="n">cmd_q</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>	<span class="cm">/* when sg_io_hdr seen, set command queuing on */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">srp</span> <span class="o">=</span> <span class="n">sg_add_request</span><span class="p">(</span><span class="n">sfp</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">SCSI_LOG_TIMEOUT</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">printk</span><span class="p">(</span><span class="s">&quot;sg_new_write: queue full</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">));</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EDOM</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">srp</span><span class="o">-&gt;</span><span class="n">sg_io_owned</span> <span class="o">=</span> <span class="n">sg_io_owned</span><span class="p">;</span>
	<span class="n">hp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">srp</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">__copy_from_user</span><span class="p">(</span><span class="n">hp</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">SZ_SG_IO_HDR</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">sg_remove_request</span><span class="p">(</span><span class="n">sfp</span><span class="p">,</span> <span class="n">srp</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hp</span><span class="o">-&gt;</span><span class="n">interface_id</span> <span class="o">!=</span> <span class="sc">&#39;S&#39;</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">sg_remove_request</span><span class="p">(</span><span class="n">sfp</span><span class="p">,</span> <span class="n">srp</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOSYS</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hp</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">SG_FLAG_MMAP_IO</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">hp</span><span class="o">-&gt;</span><span class="n">dxfer_len</span> <span class="o">&gt;</span> <span class="n">sfp</span><span class="o">-&gt;</span><span class="n">reserve</span><span class="p">.</span><span class="n">bufflen</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">sg_remove_request</span><span class="p">(</span><span class="n">sfp</span><span class="p">,</span> <span class="n">srp</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>	<span class="cm">/* MMAP_IO size must fit in reserve buffer */</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">hp</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">SG_FLAG_DIRECT_IO</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">sg_remove_request</span><span class="p">(</span><span class="n">sfp</span><span class="p">,</span> <span class="n">srp</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>	<span class="cm">/* either MMAP_IO or DIRECT_IO (not both) */</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sg_res_in_use</span><span class="p">(</span><span class="n">sfp</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">sg_remove_request</span><span class="p">(</span><span class="n">sfp</span><span class="p">,</span> <span class="n">srp</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>	<span class="cm">/* reserve buffer already being used */</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">ul_timeout</span> <span class="o">=</span> <span class="n">msecs_to_jiffies</span><span class="p">(</span><span class="n">srp</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">timeout</span><span class="p">);</span>
	<span class="n">timeout</span> <span class="o">=</span> <span class="p">(</span><span class="n">ul_timeout</span> <span class="o">&lt;</span> <span class="n">INT_MAX</span><span class="p">)</span> <span class="o">?</span> <span class="n">ul_timeout</span> <span class="o">:</span> <span class="n">INT_MAX</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">((</span><span class="o">!</span><span class="n">hp</span><span class="o">-&gt;</span><span class="n">cmdp</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">hp</span><span class="o">-&gt;</span><span class="n">cmd_len</span> <span class="o">&lt;</span> <span class="mi">6</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">hp</span><span class="o">-&gt;</span><span class="n">cmd_len</span> <span class="o">&gt;</span> <span class="k">sizeof</span> <span class="p">(</span><span class="n">cmnd</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">sg_remove_request</span><span class="p">(</span><span class="n">sfp</span><span class="p">,</span> <span class="n">srp</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EMSGSIZE</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">access_ok</span><span class="p">(</span><span class="n">VERIFY_READ</span><span class="p">,</span> <span class="n">hp</span><span class="o">-&gt;</span><span class="n">cmdp</span><span class="p">,</span> <span class="n">hp</span><span class="o">-&gt;</span><span class="n">cmd_len</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">sg_remove_request</span><span class="p">(</span><span class="n">sfp</span><span class="p">,</span> <span class="n">srp</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>	<span class="cm">/* protects following copy_from_user()s + get_user()s */</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">__copy_from_user</span><span class="p">(</span><span class="n">cmnd</span><span class="p">,</span> <span class="n">hp</span><span class="o">-&gt;</span><span class="n">cmdp</span><span class="p">,</span> <span class="n">hp</span><span class="o">-&gt;</span><span class="n">cmd_len</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">sg_remove_request</span><span class="p">(</span><span class="n">sfp</span><span class="p">,</span> <span class="n">srp</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">read_only</span> <span class="o">&amp;&amp;</span> <span class="n">sg_allow_access</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">cmnd</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">sg_remove_request</span><span class="p">(</span><span class="n">sfp</span><span class="p">,</span> <span class="n">srp</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">k</span> <span class="o">=</span> <span class="n">sg_common_write</span><span class="p">(</span><span class="n">sfp</span><span class="p">,</span> <span class="n">srp</span><span class="p">,</span> <span class="n">cmnd</span><span class="p">,</span> <span class="n">timeout</span><span class="p">,</span> <span class="n">blocking</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">k</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">k</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">o_srp</span><span class="p">)</span>
		<span class="o">*</span><span class="n">o_srp</span> <span class="o">=</span> <span class="n">srp</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">count</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">sg_common_write</span><span class="p">(</span><span class="n">Sg_fd</span> <span class="o">*</span> <span class="n">sfp</span><span class="p">,</span> <span class="n">Sg_request</span> <span class="o">*</span> <span class="n">srp</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">cmnd</span><span class="p">,</span> <span class="kt">int</span> <span class="n">timeout</span><span class="p">,</span> <span class="kt">int</span> <span class="n">blocking</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">k</span><span class="p">,</span> <span class="n">data_dir</span><span class="p">;</span>
	<span class="n">Sg_device</span> <span class="o">*</span><span class="n">sdp</span> <span class="o">=</span> <span class="n">sfp</span><span class="o">-&gt;</span><span class="n">parentdp</span><span class="p">;</span>
	<span class="n">sg_io_hdr_t</span> <span class="o">*</span><span class="n">hp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">srp</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">;</span>

	<span class="n">srp</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">.</span><span class="n">cmd_opcode</span> <span class="o">=</span> <span class="n">cmnd</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>	<span class="cm">/* hold opcode of command */</span>
	<span class="n">hp</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">hp</span><span class="o">-&gt;</span><span class="n">masked_status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">hp</span><span class="o">-&gt;</span><span class="n">msg_status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">hp</span><span class="o">-&gt;</span><span class="n">info</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">hp</span><span class="o">-&gt;</span><span class="n">host_status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">hp</span><span class="o">-&gt;</span><span class="n">driver_status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">hp</span><span class="o">-&gt;</span><span class="n">resid</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">SCSI_LOG_TIMEOUT</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="n">printk</span><span class="p">(</span><span class="s">&quot;sg_common_write:  scsi opcode=0x%02x, cmd_size=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			  <span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="n">cmnd</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="n">hp</span><span class="o">-&gt;</span><span class="n">cmd_len</span><span class="p">));</span>

	<span class="n">k</span> <span class="o">=</span> <span class="n">sg_start_req</span><span class="p">(</span><span class="n">srp</span><span class="p">,</span> <span class="n">cmnd</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">SCSI_LOG_TIMEOUT</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">printk</span><span class="p">(</span><span class="s">&quot;sg_common_write: start_req err=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">k</span><span class="p">));</span>
		<span class="n">sg_finish_rem_req</span><span class="p">(</span><span class="n">srp</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">k</span><span class="p">;</span>	<span class="cm">/* probably out of space --&gt; ENOMEM */</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sdp</span><span class="o">-&gt;</span><span class="n">detached</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">srp</span><span class="o">-&gt;</span><span class="n">bio</span><span class="p">)</span>
			<span class="n">blk_end_request_all</span><span class="p">(</span><span class="n">srp</span><span class="o">-&gt;</span><span class="n">rq</span><span class="p">,</span> <span class="o">-</span><span class="n">EIO</span><span class="p">);</span>
		<span class="n">sg_finish_rem_req</span><span class="p">(</span><span class="n">srp</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">hp</span><span class="o">-&gt;</span><span class="n">dxfer_direction</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">SG_DXFER_TO_FROM_DEV</span>:
	<span class="k">case</span> <span class="n">SG_DXFER_FROM_DEV</span>:
		<span class="n">data_dir</span> <span class="o">=</span> <span class="n">DMA_FROM_DEVICE</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SG_DXFER_TO_DEV</span>:
		<span class="n">data_dir</span> <span class="o">=</span> <span class="n">DMA_TO_DEVICE</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SG_DXFER_UNKNOWN</span>:
		<span class="n">data_dir</span> <span class="o">=</span> <span class="n">DMA_BIDIRECTIONAL</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">data_dir</span> <span class="o">=</span> <span class="n">DMA_NONE</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">hp</span><span class="o">-&gt;</span><span class="n">duration</span> <span class="o">=</span> <span class="n">jiffies_to_msecs</span><span class="p">(</span><span class="n">jiffies</span><span class="p">);</span>

	<span class="n">srp</span><span class="o">-&gt;</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">timeout</span> <span class="o">=</span> <span class="n">timeout</span><span class="p">;</span>
	<span class="n">kref_get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sfp</span><span class="o">-&gt;</span><span class="n">f_ref</span><span class="p">);</span> <span class="cm">/* sg_rq_end_io() does kref_put(). */</span>
	<span class="n">blk_execute_rq_nowait</span><span class="p">(</span><span class="n">sdp</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">request_queue</span><span class="p">,</span> <span class="n">sdp</span><span class="o">-&gt;</span><span class="n">disk</span><span class="p">,</span>
			      <span class="n">srp</span><span class="o">-&gt;</span><span class="n">rq</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">sg_rq_end_io</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">srp_done</span><span class="p">(</span><span class="n">Sg_fd</span> <span class="o">*</span><span class="n">sfp</span><span class="p">,</span> <span class="n">Sg_request</span> <span class="o">*</span><span class="n">srp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">read_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sfp</span><span class="o">-&gt;</span><span class="n">rq_list_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">srp</span><span class="o">-&gt;</span><span class="n">done</span><span class="p">;</span>
	<span class="n">read_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sfp</span><span class="o">-&gt;</span><span class="n">rq_list_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">long</span>
<span class="nf">sg_ioctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cmd_in</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span><span class="n">arg</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">__user</span> <span class="o">*</span><span class="n">ip</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">result</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">read_only</span><span class="p">;</span>
	<span class="n">Sg_device</span> <span class="o">*</span><span class="n">sdp</span><span class="p">;</span>
	<span class="n">Sg_fd</span> <span class="o">*</span><span class="n">sfp</span><span class="p">;</span>
	<span class="n">Sg_request</span> <span class="o">*</span><span class="n">srp</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">iflags</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="o">!</span><span class="p">(</span><span class="n">sfp</span> <span class="o">=</span> <span class="p">(</span><span class="n">Sg_fd</span> <span class="o">*</span><span class="p">)</span> <span class="n">filp</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">))</span> <span class="o">||</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">sdp</span> <span class="o">=</span> <span class="n">sfp</span><span class="o">-&gt;</span><span class="n">parentdp</span><span class="p">)))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENXIO</span><span class="p">;</span>

	<span class="n">SCSI_LOG_TIMEOUT</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">printk</span><span class="p">(</span><span class="s">&quot;sg_ioctl: %s, cmd=0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				   <span class="n">sdp</span><span class="o">-&gt;</span><span class="n">disk</span><span class="o">-&gt;</span><span class="n">disk_name</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="n">cmd_in</span><span class="p">));</span>
	<span class="n">read_only</span> <span class="o">=</span> <span class="p">(</span><span class="n">O_RDWR</span> <span class="o">!=</span> <span class="p">(</span><span class="n">filp</span><span class="o">-&gt;</span><span class="n">f_flags</span> <span class="o">&amp;</span> <span class="n">O_ACCMODE</span><span class="p">));</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">cmd_in</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">SG_IO</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">sdp</span><span class="o">-&gt;</span><span class="n">detached</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">scsi_block_when_processing_errors</span><span class="p">(</span><span class="n">sdp</span><span class="o">-&gt;</span><span class="n">device</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENXIO</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">access_ok</span><span class="p">(</span><span class="n">VERIFY_WRITE</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">SZ_SG_IO_HDR</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
		<span class="n">result</span> <span class="o">=</span> <span class="n">sg_new_write</span><span class="p">(</span><span class="n">sfp</span><span class="p">,</span> <span class="n">filp</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">SZ_SG_IO_HDR</span><span class="p">,</span>
				 <span class="mi">1</span><span class="p">,</span> <span class="n">read_only</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">srp</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">result</span><span class="p">;</span>
		<span class="n">result</span> <span class="o">=</span> <span class="n">wait_event_interruptible</span><span class="p">(</span><span class="n">sfp</span><span class="o">-&gt;</span><span class="n">read_wait</span><span class="p">,</span>
			<span class="p">(</span><span class="n">srp_done</span><span class="p">(</span><span class="n">sfp</span><span class="p">,</span> <span class="n">srp</span><span class="p">)</span> <span class="o">||</span> <span class="n">sdp</span><span class="o">-&gt;</span><span class="n">detached</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sdp</span><span class="o">-&gt;</span><span class="n">detached</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
		<span class="n">write_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sfp</span><span class="o">-&gt;</span><span class="n">rq_list_lock</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">srp</span><span class="o">-&gt;</span><span class="n">done</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">srp</span><span class="o">-&gt;</span><span class="n">done</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
			<span class="n">write_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sfp</span><span class="o">-&gt;</span><span class="n">rq_list_lock</span><span class="p">);</span>
			<span class="n">result</span> <span class="o">=</span> <span class="n">sg_new_read</span><span class="p">(</span><span class="n">sfp</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">SZ_SG_IO_HDR</span><span class="p">,</span> <span class="n">srp</span><span class="p">);</span>
			<span class="k">return</span> <span class="p">(</span><span class="n">result</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">?</span> <span class="n">result</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">srp</span><span class="o">-&gt;</span><span class="n">orphan</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">write_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sfp</span><span class="o">-&gt;</span><span class="n">rq_list_lock</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">result</span><span class="p">;</span>	<span class="cm">/* -ERESTARTSYS because signal hit process */</span>
	<span class="k">case</span> <span class="n">SG_SET_TIMEOUT</span>:
		<span class="n">result</span> <span class="o">=</span> <span class="n">get_user</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">ip</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">result</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">result</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">val</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">val</span> <span class="o">&gt;=</span> <span class="n">MULDIV</span> <span class="p">(</span><span class="n">INT_MAX</span><span class="p">,</span> <span class="n">USER_HZ</span><span class="p">,</span> <span class="n">HZ</span><span class="p">))</span>
		    <span class="n">val</span> <span class="o">=</span> <span class="n">MULDIV</span> <span class="p">(</span><span class="n">INT_MAX</span><span class="p">,</span> <span class="n">USER_HZ</span><span class="p">,</span> <span class="n">HZ</span><span class="p">);</span>
		<span class="n">sfp</span><span class="o">-&gt;</span><span class="n">timeout_user</span> <span class="o">=</span> <span class="n">val</span><span class="p">;</span>
		<span class="n">sfp</span><span class="o">-&gt;</span><span class="n">timeout</span> <span class="o">=</span> <span class="n">MULDIV</span> <span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">HZ</span><span class="p">,</span> <span class="n">USER_HZ</span><span class="p">);</span>

		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SG_GET_TIMEOUT</span>:	<span class="cm">/* N.B. User receives timeout as return value */</span>
				<span class="cm">/* strange ..., for backward compatibility */</span>
		<span class="k">return</span> <span class="n">sfp</span><span class="o">-&gt;</span><span class="n">timeout_user</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SG_SET_FORCE_LOW_DMA</span>:
		<span class="n">result</span> <span class="o">=</span> <span class="n">get_user</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">ip</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">result</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">result</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">val</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">sfp</span><span class="o">-&gt;</span><span class="n">low_dma</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">((</span><span class="mi">0</span> <span class="o">==</span> <span class="n">sfp</span><span class="o">-&gt;</span><span class="n">low_dma</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="mi">0</span> <span class="o">==</span> <span class="n">sg_res_in_use</span><span class="p">(</span><span class="n">sfp</span><span class="p">)))</span> <span class="p">{</span>
				<span class="n">val</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="n">sfp</span><span class="o">-&gt;</span><span class="n">reserve</span><span class="p">.</span><span class="n">bufflen</span><span class="p">;</span>
				<span class="n">sg_remove_scat</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sfp</span><span class="o">-&gt;</span><span class="n">reserve</span><span class="p">);</span>
				<span class="n">sg_build_reserve</span><span class="p">(</span><span class="n">sfp</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">sdp</span><span class="o">-&gt;</span><span class="n">detached</span><span class="p">)</span>
				<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
			<span class="n">sfp</span><span class="o">-&gt;</span><span class="n">low_dma</span> <span class="o">=</span> <span class="n">sdp</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">unchecked_isa_dma</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SG_GET_LOW_DMA</span>:
		<span class="k">return</span> <span class="n">put_user</span><span class="p">((</span><span class="kt">int</span><span class="p">)</span> <span class="n">sfp</span><span class="o">-&gt;</span><span class="n">low_dma</span><span class="p">,</span> <span class="n">ip</span><span class="p">);</span>
	<span class="k">case</span> <span class="n">SG_GET_SCSI_ID</span>:
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">access_ok</span><span class="p">(</span><span class="n">VERIFY_WRITE</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="k">sizeof</span> <span class="p">(</span><span class="n">sg_scsi_id_t</span><span class="p">)))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
		<span class="k">else</span> <span class="p">{</span>
			<span class="n">sg_scsi_id_t</span> <span class="n">__user</span> <span class="o">*</span><span class="n">sg_idp</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">sdp</span><span class="o">-&gt;</span><span class="n">detached</span><span class="p">)</span>
				<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
			<span class="n">__put_user</span><span class="p">((</span><span class="kt">int</span><span class="p">)</span> <span class="n">sdp</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">host_no</span><span class="p">,</span>
				   <span class="o">&amp;</span><span class="n">sg_idp</span><span class="o">-&gt;</span><span class="n">host_no</span><span class="p">);</span>
			<span class="n">__put_user</span><span class="p">((</span><span class="kt">int</span><span class="p">)</span> <span class="n">sdp</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">channel</span><span class="p">,</span>
				   <span class="o">&amp;</span><span class="n">sg_idp</span><span class="o">-&gt;</span><span class="n">channel</span><span class="p">);</span>
			<span class="n">__put_user</span><span class="p">((</span><span class="kt">int</span><span class="p">)</span> <span class="n">sdp</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sg_idp</span><span class="o">-&gt;</span><span class="n">scsi_id</span><span class="p">);</span>
			<span class="n">__put_user</span><span class="p">((</span><span class="kt">int</span><span class="p">)</span> <span class="n">sdp</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">lun</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sg_idp</span><span class="o">-&gt;</span><span class="n">lun</span><span class="p">);</span>
			<span class="n">__put_user</span><span class="p">((</span><span class="kt">int</span><span class="p">)</span> <span class="n">sdp</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sg_idp</span><span class="o">-&gt;</span><span class="n">scsi_type</span><span class="p">);</span>
			<span class="n">__put_user</span><span class="p">((</span><span class="kt">short</span><span class="p">)</span> <span class="n">sdp</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">cmd_per_lun</span><span class="p">,</span>
				   <span class="o">&amp;</span><span class="n">sg_idp</span><span class="o">-&gt;</span><span class="n">h_cmd_per_lun</span><span class="p">);</span>
			<span class="n">__put_user</span><span class="p">((</span><span class="kt">short</span><span class="p">)</span> <span class="n">sdp</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">queue_depth</span><span class="p">,</span>
				   <span class="o">&amp;</span><span class="n">sg_idp</span><span class="o">-&gt;</span><span class="n">d_queue_depth</span><span class="p">);</span>
			<span class="n">__put_user</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sg_idp</span><span class="o">-&gt;</span><span class="n">unused</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
			<span class="n">__put_user</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sg_idp</span><span class="o">-&gt;</span><span class="n">unused</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="k">case</span> <span class="n">SG_SET_FORCE_PACK_ID</span>:
		<span class="n">result</span> <span class="o">=</span> <span class="n">get_user</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">ip</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">result</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">result</span><span class="p">;</span>
		<span class="n">sfp</span><span class="o">-&gt;</span><span class="n">force_packid</span> <span class="o">=</span> <span class="n">val</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SG_GET_PACK_ID</span>:
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">access_ok</span><span class="p">(</span><span class="n">VERIFY_WRITE</span><span class="p">,</span> <span class="n">ip</span><span class="p">,</span> <span class="k">sizeof</span> <span class="p">(</span><span class="kt">int</span><span class="p">)))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
		<span class="n">read_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sfp</span><span class="o">-&gt;</span><span class="n">rq_list_lock</span><span class="p">,</span> <span class="n">iflags</span><span class="p">);</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">srp</span> <span class="o">=</span> <span class="n">sfp</span><span class="o">-&gt;</span><span class="n">headrp</span><span class="p">;</span> <span class="n">srp</span><span class="p">;</span> <span class="n">srp</span> <span class="o">=</span> <span class="n">srp</span><span class="o">-&gt;</span><span class="n">nextrp</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">((</span><span class="mi">1</span> <span class="o">==</span> <span class="n">srp</span><span class="o">-&gt;</span><span class="n">done</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="o">!</span><span class="n">srp</span><span class="o">-&gt;</span><span class="n">sg_io_owned</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">read_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sfp</span><span class="o">-&gt;</span><span class="n">rq_list_lock</span><span class="p">,</span>
						       <span class="n">iflags</span><span class="p">);</span>
				<span class="n">__put_user</span><span class="p">(</span><span class="n">srp</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">pack_id</span><span class="p">,</span> <span class="n">ip</span><span class="p">);</span>
				<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="n">read_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sfp</span><span class="o">-&gt;</span><span class="n">rq_list_lock</span><span class="p">,</span> <span class="n">iflags</span><span class="p">);</span>
		<span class="n">__put_user</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">ip</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SG_GET_NUM_WAITING</span>:
		<span class="n">read_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sfp</span><span class="o">-&gt;</span><span class="n">rq_list_lock</span><span class="p">,</span> <span class="n">iflags</span><span class="p">);</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">val</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">srp</span> <span class="o">=</span> <span class="n">sfp</span><span class="o">-&gt;</span><span class="n">headrp</span><span class="p">;</span> <span class="n">srp</span><span class="p">;</span> <span class="n">srp</span> <span class="o">=</span> <span class="n">srp</span><span class="o">-&gt;</span><span class="n">nextrp</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">((</span><span class="mi">1</span> <span class="o">==</span> <span class="n">srp</span><span class="o">-&gt;</span><span class="n">done</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="o">!</span><span class="n">srp</span><span class="o">-&gt;</span><span class="n">sg_io_owned</span><span class="p">))</span>
				<span class="o">++</span><span class="n">val</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">read_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sfp</span><span class="o">-&gt;</span><span class="n">rq_list_lock</span><span class="p">,</span> <span class="n">iflags</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">put_user</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">ip</span><span class="p">);</span>
	<span class="k">case</span> <span class="n">SG_GET_SG_TABLESIZE</span>:
		<span class="k">return</span> <span class="n">put_user</span><span class="p">(</span><span class="n">sdp</span><span class="o">-&gt;</span><span class="n">sg_tablesize</span><span class="p">,</span> <span class="n">ip</span><span class="p">);</span>
	<span class="k">case</span> <span class="n">SG_SET_RESERVED_SIZE</span>:
		<span class="n">result</span> <span class="o">=</span> <span class="n">get_user</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">ip</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">result</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">result</span><span class="p">;</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">val</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
                        <span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="n">val</span> <span class="o">=</span> <span class="n">min_t</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span>
			    <span class="n">queue_max_sectors</span><span class="p">(</span><span class="n">sdp</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">request_queue</span><span class="p">)</span> <span class="o">*</span> <span class="mi">512</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">val</span> <span class="o">!=</span> <span class="n">sfp</span><span class="o">-&gt;</span><span class="n">reserve</span><span class="p">.</span><span class="n">bufflen</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">sg_res_in_use</span><span class="p">(</span><span class="n">sfp</span><span class="p">)</span> <span class="o">||</span> <span class="n">sfp</span><span class="o">-&gt;</span><span class="n">mmap_called</span><span class="p">)</span>
				<span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
			<span class="n">sg_remove_scat</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sfp</span><span class="o">-&gt;</span><span class="n">reserve</span><span class="p">);</span>
			<span class="n">sg_build_reserve</span><span class="p">(</span><span class="n">sfp</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SG_GET_RESERVED_SIZE</span>:
		<span class="n">val</span> <span class="o">=</span> <span class="n">min_t</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="n">sfp</span><span class="o">-&gt;</span><span class="n">reserve</span><span class="p">.</span><span class="n">bufflen</span><span class="p">,</span>
			    <span class="n">queue_max_sectors</span><span class="p">(</span><span class="n">sdp</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">request_queue</span><span class="p">)</span> <span class="o">*</span> <span class="mi">512</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">put_user</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">ip</span><span class="p">);</span>
	<span class="k">case</span> <span class="n">SG_SET_COMMAND_Q</span>:
		<span class="n">result</span> <span class="o">=</span> <span class="n">get_user</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">ip</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">result</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">result</span><span class="p">;</span>
		<span class="n">sfp</span><span class="o">-&gt;</span><span class="n">cmd_q</span> <span class="o">=</span> <span class="n">val</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SG_GET_COMMAND_Q</span>:
		<span class="k">return</span> <span class="n">put_user</span><span class="p">((</span><span class="kt">int</span><span class="p">)</span> <span class="n">sfp</span><span class="o">-&gt;</span><span class="n">cmd_q</span><span class="p">,</span> <span class="n">ip</span><span class="p">);</span>
	<span class="k">case</span> <span class="n">SG_SET_KEEP_ORPHAN</span>:
		<span class="n">result</span> <span class="o">=</span> <span class="n">get_user</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">ip</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">result</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">result</span><span class="p">;</span>
		<span class="n">sfp</span><span class="o">-&gt;</span><span class="n">keep_orphan</span> <span class="o">=</span> <span class="n">val</span><span class="p">;</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SG_GET_KEEP_ORPHAN</span>:
		<span class="k">return</span> <span class="n">put_user</span><span class="p">((</span><span class="kt">int</span><span class="p">)</span> <span class="n">sfp</span><span class="o">-&gt;</span><span class="n">keep_orphan</span><span class="p">,</span> <span class="n">ip</span><span class="p">);</span>
	<span class="k">case</span> <span class="n">SG_NEXT_CMD_LEN</span>:
		<span class="n">result</span> <span class="o">=</span> <span class="n">get_user</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">ip</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">result</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">result</span><span class="p">;</span>
		<span class="n">sfp</span><span class="o">-&gt;</span><span class="n">next_cmd_len</span> <span class="o">=</span> <span class="p">(</span><span class="n">val</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">?</span> <span class="n">val</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SG_GET_VERSION_NUM</span>:
		<span class="k">return</span> <span class="n">put_user</span><span class="p">(</span><span class="n">sg_version_num</span><span class="p">,</span> <span class="n">ip</span><span class="p">);</span>
	<span class="k">case</span> <span class="n">SG_GET_ACCESS_COUNT</span>:
		<span class="cm">/* faked - we don&#39;t have a real access count anymore */</span>
		<span class="n">val</span> <span class="o">=</span> <span class="p">(</span><span class="n">sdp</span><span class="o">-&gt;</span><span class="n">device</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">put_user</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">ip</span><span class="p">);</span>
	<span class="k">case</span> <span class="n">SG_GET_REQUEST_TABLE</span>:
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">access_ok</span><span class="p">(</span><span class="n">VERIFY_WRITE</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">SZ_SG_REQ_INFO</span> <span class="o">*</span> <span class="n">SG_MAX_QUEUE</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
		<span class="k">else</span> <span class="p">{</span>
			<span class="n">sg_req_info_t</span> <span class="o">*</span><span class="n">rinfo</span><span class="p">;</span>
			<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ms</span><span class="p">;</span>

			<span class="n">rinfo</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="n">SZ_SG_REQ_INFO</span> <span class="o">*</span> <span class="n">SG_MAX_QUEUE</span><span class="p">,</span>
								<span class="n">GFP_KERNEL</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rinfo</span><span class="p">)</span>
				<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
			<span class="n">read_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sfp</span><span class="o">-&gt;</span><span class="n">rq_list_lock</span><span class="p">,</span> <span class="n">iflags</span><span class="p">);</span>
			<span class="k">for</span> <span class="p">(</span><span class="n">srp</span> <span class="o">=</span> <span class="n">sfp</span><span class="o">-&gt;</span><span class="n">headrp</span><span class="p">,</span> <span class="n">val</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">val</span> <span class="o">&lt;</span> <span class="n">SG_MAX_QUEUE</span><span class="p">;</span>
			     <span class="o">++</span><span class="n">val</span><span class="p">,</span> <span class="n">srp</span> <span class="o">=</span> <span class="n">srp</span> <span class="o">?</span> <span class="n">srp</span><span class="o">-&gt;</span><span class="n">nextrp</span> <span class="o">:</span> <span class="n">srp</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rinfo</span><span class="p">[</span><span class="n">val</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="n">SZ_SG_REQ_INFO</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">srp</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">rinfo</span><span class="p">[</span><span class="n">val</span><span class="p">].</span><span class="n">req_state</span> <span class="o">=</span> <span class="n">srp</span><span class="o">-&gt;</span><span class="n">done</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
					<span class="n">rinfo</span><span class="p">[</span><span class="n">val</span><span class="p">].</span><span class="n">problem</span> <span class="o">=</span>
					    <span class="n">srp</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">masked_status</span> <span class="o">&amp;</span> 
					    <span class="n">srp</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">host_status</span> <span class="o">&amp;</span> 
					    <span class="n">srp</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">driver_status</span><span class="p">;</span>
					<span class="k">if</span> <span class="p">(</span><span class="n">srp</span><span class="o">-&gt;</span><span class="n">done</span><span class="p">)</span>
						<span class="n">rinfo</span><span class="p">[</span><span class="n">val</span><span class="p">].</span><span class="n">duration</span> <span class="o">=</span>
							<span class="n">srp</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">duration</span><span class="p">;</span>
					<span class="k">else</span> <span class="p">{</span>
						<span class="n">ms</span> <span class="o">=</span> <span class="n">jiffies_to_msecs</span><span class="p">(</span><span class="n">jiffies</span><span class="p">);</span>
						<span class="n">rinfo</span><span class="p">[</span><span class="n">val</span><span class="p">].</span><span class="n">duration</span> <span class="o">=</span>
						    <span class="p">(</span><span class="n">ms</span> <span class="o">&gt;</span> <span class="n">srp</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">duration</span><span class="p">)</span> <span class="o">?</span>
						    <span class="p">(</span><span class="n">ms</span> <span class="o">-</span> <span class="n">srp</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">duration</span><span class="p">)</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
					<span class="p">}</span>
					<span class="n">rinfo</span><span class="p">[</span><span class="n">val</span><span class="p">].</span><span class="n">orphan</span> <span class="o">=</span> <span class="n">srp</span><span class="o">-&gt;</span><span class="n">orphan</span><span class="p">;</span>
					<span class="n">rinfo</span><span class="p">[</span><span class="n">val</span><span class="p">].</span><span class="n">sg_io_owned</span> <span class="o">=</span>
							<span class="n">srp</span><span class="o">-&gt;</span><span class="n">sg_io_owned</span><span class="p">;</span>
					<span class="n">rinfo</span><span class="p">[</span><span class="n">val</span><span class="p">].</span><span class="n">pack_id</span> <span class="o">=</span>
							<span class="n">srp</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">pack_id</span><span class="p">;</span>
					<span class="n">rinfo</span><span class="p">[</span><span class="n">val</span><span class="p">].</span><span class="n">usr_ptr</span> <span class="o">=</span>
							<span class="n">srp</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">usr_ptr</span><span class="p">;</span>
				<span class="p">}</span>
			<span class="p">}</span>
			<span class="n">read_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sfp</span><span class="o">-&gt;</span><span class="n">rq_list_lock</span><span class="p">,</span> <span class="n">iflags</span><span class="p">);</span>
			<span class="n">result</span> <span class="o">=</span> <span class="n">__copy_to_user</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">rinfo</span><span class="p">,</span> 
						<span class="n">SZ_SG_REQ_INFO</span> <span class="o">*</span> <span class="n">SG_MAX_QUEUE</span><span class="p">);</span>
			<span class="n">result</span> <span class="o">=</span> <span class="n">result</span> <span class="o">?</span> <span class="o">-</span><span class="n">EFAULT</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">kfree</span><span class="p">(</span><span class="n">rinfo</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">result</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="k">case</span> <span class="n">SG_EMULATED_HOST</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">sdp</span><span class="o">-&gt;</span><span class="n">detached</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
		<span class="k">return</span> <span class="n">put_user</span><span class="p">(</span><span class="n">sdp</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">hostt</span><span class="o">-&gt;</span><span class="n">emulated</span><span class="p">,</span> <span class="n">ip</span><span class="p">);</span>
	<span class="k">case</span> <span class="n">SG_SCSI_RESET</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">sdp</span><span class="o">-&gt;</span><span class="n">detached</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">filp</span><span class="o">-&gt;</span><span class="n">f_flags</span> <span class="o">&amp;</span> <span class="n">O_NONBLOCK</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">scsi_host_in_recovery</span><span class="p">(</span><span class="n">sdp</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">))</span>
				<span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">scsi_block_when_processing_errors</span><span class="p">(</span><span class="n">sdp</span><span class="o">-&gt;</span><span class="n">device</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
		<span class="n">result</span> <span class="o">=</span> <span class="n">get_user</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">ip</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">result</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">result</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">SG_SCSI_RESET_NOTHING</span> <span class="o">==</span> <span class="n">val</span><span class="p">)</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">val</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">SG_SCSI_RESET_DEVICE</span>:
			<span class="n">val</span> <span class="o">=</span> <span class="n">SCSI_TRY_RESET_DEVICE</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">SG_SCSI_RESET_TARGET</span>:
			<span class="n">val</span> <span class="o">=</span> <span class="n">SCSI_TRY_RESET_TARGET</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">SG_SCSI_RESET_BUS</span>:
			<span class="n">val</span> <span class="o">=</span> <span class="n">SCSI_TRY_RESET_BUS</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">SG_SCSI_RESET_HOST</span>:
			<span class="n">val</span> <span class="o">=</span> <span class="n">SCSI_TRY_RESET_HOST</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="nl">default:</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">capable</span><span class="p">(</span><span class="n">CAP_SYS_ADMIN</span><span class="p">)</span> <span class="o">||</span> <span class="o">!</span><span class="n">capable</span><span class="p">(</span><span class="n">CAP_SYS_RAWIO</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EACCES</span><span class="p">;</span>
		<span class="k">return</span> <span class="p">(</span><span class="n">scsi_reset_provider</span><span class="p">(</span><span class="n">sdp</span><span class="o">-&gt;</span><span class="n">device</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span> <span class="o">==</span>
			<span class="n">SUCCESS</span><span class="p">)</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SCSI_IOCTL_SEND_COMMAND</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">sdp</span><span class="o">-&gt;</span><span class="n">detached</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">read_only</span><span class="p">)</span> <span class="p">{</span>
			<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">opcode</span> <span class="o">=</span> <span class="n">WRITE_6</span><span class="p">;</span>
			<span class="n">Scsi_Ioctl_Command</span> <span class="n">__user</span> <span class="o">*</span><span class="n">siocp</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">opcode</span><span class="p">,</span> <span class="n">siocp</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
				<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">sg_allow_access</span><span class="p">(</span><span class="n">filp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">opcode</span><span class="p">))</span>
				<span class="k">return</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">return</span> <span class="n">sg_scsi_ioctl</span><span class="p">(</span><span class="n">sdp</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">request_queue</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">filp</span><span class="o">-&gt;</span><span class="n">f_mode</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
	<span class="k">case</span> <span class="n">SG_SET_DEBUG</span>:
		<span class="n">result</span> <span class="o">=</span> <span class="n">get_user</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">ip</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">result</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">result</span><span class="p">;</span>
		<span class="n">sdp</span><span class="o">-&gt;</span><span class="n">sgdebug</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span><span class="p">)</span> <span class="n">val</span><span class="p">;</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SCSI_IOCTL_GET_IDLUN</span>:
	<span class="k">case</span> <span class="n">SCSI_IOCTL_GET_BUS_NUMBER</span>:
	<span class="k">case</span> <span class="n">SCSI_IOCTL_PROBE_HOST</span>:
	<span class="k">case</span> <span class="n">SG_GET_TRANSFORM</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">sdp</span><span class="o">-&gt;</span><span class="n">detached</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
		<span class="k">return</span> <span class="n">scsi_ioctl</span><span class="p">(</span><span class="n">sdp</span><span class="o">-&gt;</span><span class="n">device</span><span class="p">,</span> <span class="n">cmd_in</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
	<span class="k">case</span> <span class="n">BLKSECTGET</span>:
		<span class="k">return</span> <span class="n">put_user</span><span class="p">(</span><span class="n">queue_max_sectors</span><span class="p">(</span><span class="n">sdp</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">request_queue</span><span class="p">)</span> <span class="o">*</span> <span class="mi">512</span><span class="p">,</span>
				<span class="n">ip</span><span class="p">);</span>
	<span class="k">case</span> <span class="n">BLKTRACESETUP</span>:
		<span class="k">return</span> <span class="n">blk_trace_setup</span><span class="p">(</span><span class="n">sdp</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">request_queue</span><span class="p">,</span>
				       <span class="n">sdp</span><span class="o">-&gt;</span><span class="n">disk</span><span class="o">-&gt;</span><span class="n">disk_name</span><span class="p">,</span>
				       <span class="n">MKDEV</span><span class="p">(</span><span class="n">SCSI_GENERIC_MAJOR</span><span class="p">,</span> <span class="n">sdp</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">),</span>
				       <span class="nb">NULL</span><span class="p">,</span>
				       <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">arg</span><span class="p">);</span>
	<span class="k">case</span> <span class="n">BLKTRACESTART</span>:
		<span class="k">return</span> <span class="n">blk_trace_startstop</span><span class="p">(</span><span class="n">sdp</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">request_queue</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">case</span> <span class="n">BLKTRACESTOP</span>:
		<span class="k">return</span> <span class="n">blk_trace_startstop</span><span class="p">(</span><span class="n">sdp</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">request_queue</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">case</span> <span class="n">BLKTRACETEARDOWN</span>:
		<span class="k">return</span> <span class="n">blk_trace_remove</span><span class="p">(</span><span class="n">sdp</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">request_queue</span><span class="p">);</span>
	<span class="nl">default:</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">read_only</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>	<span class="cm">/* don&#39;t know so take safe approach */</span>
		<span class="k">return</span> <span class="n">scsi_ioctl</span><span class="p">(</span><span class="n">sdp</span><span class="o">-&gt;</span><span class="n">device</span><span class="p">,</span> <span class="n">cmd_in</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_COMPAT</span>
<span class="k">static</span> <span class="kt">long</span> <span class="nf">sg_compat_ioctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cmd_in</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">Sg_device</span> <span class="o">*</span><span class="n">sdp</span><span class="p">;</span>
	<span class="n">Sg_fd</span> <span class="o">*</span><span class="n">sfp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="n">sdev</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="o">!</span><span class="p">(</span><span class="n">sfp</span> <span class="o">=</span> <span class="p">(</span><span class="n">Sg_fd</span> <span class="o">*</span><span class="p">)</span> <span class="n">filp</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">))</span> <span class="o">||</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">sdp</span> <span class="o">=</span> <span class="n">sfp</span><span class="o">-&gt;</span><span class="n">parentdp</span><span class="p">)))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENXIO</span><span class="p">;</span>

	<span class="n">sdev</span> <span class="o">=</span> <span class="n">sdp</span><span class="o">-&gt;</span><span class="n">device</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">hostt</span><span class="o">-&gt;</span><span class="n">compat_ioctl</span><span class="p">)</span> <span class="p">{</span> 
		<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

		<span class="n">ret</span> <span class="o">=</span> <span class="n">sdev</span><span class="o">-&gt;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">hostt</span><span class="o">-&gt;</span><span class="n">compat_ioctl</span><span class="p">(</span><span class="n">sdev</span><span class="p">,</span> <span class="n">cmd_in</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span><span class="n">arg</span><span class="p">);</span>

		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="p">}</span>
	
	<span class="k">return</span> <span class="o">-</span><span class="n">ENOIOCTLCMD</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span>
<span class="nf">sg_poll</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span> <span class="n">poll_table</span> <span class="o">*</span> <span class="n">wait</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">res</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">Sg_device</span> <span class="o">*</span><span class="n">sdp</span><span class="p">;</span>
	<span class="n">Sg_fd</span> <span class="o">*</span><span class="n">sfp</span><span class="p">;</span>
	<span class="n">Sg_request</span> <span class="o">*</span><span class="n">srp</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">iflags</span><span class="p">;</span>

	<span class="n">sfp</span> <span class="o">=</span> <span class="n">filp</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sfp</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">POLLERR</span><span class="p">;</span>
	<span class="n">sdp</span> <span class="o">=</span> <span class="n">sfp</span><span class="o">-&gt;</span><span class="n">parentdp</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sdp</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">POLLERR</span><span class="p">;</span>
	<span class="n">poll_wait</span><span class="p">(</span><span class="n">filp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sfp</span><span class="o">-&gt;</span><span class="n">read_wait</span><span class="p">,</span> <span class="n">wait</span><span class="p">);</span>
	<span class="n">read_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sfp</span><span class="o">-&gt;</span><span class="n">rq_list_lock</span><span class="p">,</span> <span class="n">iflags</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">srp</span> <span class="o">=</span> <span class="n">sfp</span><span class="o">-&gt;</span><span class="n">headrp</span><span class="p">;</span> <span class="n">srp</span><span class="p">;</span> <span class="n">srp</span> <span class="o">=</span> <span class="n">srp</span><span class="o">-&gt;</span><span class="n">nextrp</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* if any read waiting, flag it */</span>
		<span class="k">if</span> <span class="p">((</span><span class="mi">0</span> <span class="o">==</span> <span class="n">res</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">==</span> <span class="n">srp</span><span class="o">-&gt;</span><span class="n">done</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="o">!</span><span class="n">srp</span><span class="o">-&gt;</span><span class="n">sg_io_owned</span><span class="p">))</span>
			<span class="n">res</span> <span class="o">=</span> <span class="n">POLLIN</span> <span class="o">|</span> <span class="n">POLLRDNORM</span><span class="p">;</span>
		<span class="o">++</span><span class="n">count</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">read_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sfp</span><span class="o">-&gt;</span><span class="n">rq_list_lock</span><span class="p">,</span> <span class="n">iflags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sdp</span><span class="o">-&gt;</span><span class="n">detached</span><span class="p">)</span>
		<span class="n">res</span> <span class="o">|=</span> <span class="n">POLLHUP</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sfp</span><span class="o">-&gt;</span><span class="n">cmd_q</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="mi">0</span> <span class="o">==</span> <span class="n">count</span><span class="p">)</span>
			<span class="n">res</span> <span class="o">|=</span> <span class="n">POLLOUT</span> <span class="o">|</span> <span class="n">POLLWRNORM</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">&lt;</span> <span class="n">SG_MAX_QUEUE</span><span class="p">)</span>
		<span class="n">res</span> <span class="o">|=</span> <span class="n">POLLOUT</span> <span class="o">|</span> <span class="n">POLLWRNORM</span><span class="p">;</span>
	<span class="n">SCSI_LOG_TIMEOUT</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">printk</span><span class="p">(</span><span class="s">&quot;sg_poll: %s, res=0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				   <span class="n">sdp</span><span class="o">-&gt;</span><span class="n">disk</span><span class="o">-&gt;</span><span class="n">disk_name</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="n">res</span><span class="p">));</span>
	<span class="k">return</span> <span class="n">res</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">sg_fasync</span><span class="p">(</span><span class="kt">int</span> <span class="n">fd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">mode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">Sg_device</span> <span class="o">*</span><span class="n">sdp</span><span class="p">;</span>
	<span class="n">Sg_fd</span> <span class="o">*</span><span class="n">sfp</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="o">!</span><span class="p">(</span><span class="n">sfp</span> <span class="o">=</span> <span class="p">(</span><span class="n">Sg_fd</span> <span class="o">*</span><span class="p">)</span> <span class="n">filp</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">))</span> <span class="o">||</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">sdp</span> <span class="o">=</span> <span class="n">sfp</span><span class="o">-&gt;</span><span class="n">parentdp</span><span class="p">)))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENXIO</span><span class="p">;</span>
	<span class="n">SCSI_LOG_TIMEOUT</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">printk</span><span class="p">(</span><span class="s">&quot;sg_fasync: %s, mode=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				   <span class="n">sdp</span><span class="o">-&gt;</span><span class="n">disk</span><span class="o">-&gt;</span><span class="n">disk_name</span><span class="p">,</span> <span class="n">mode</span><span class="p">));</span>

	<span class="k">return</span> <span class="n">fasync_helper</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">filp</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sfp</span><span class="o">-&gt;</span><span class="n">async_qp</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">sg_vma_fault</span><span class="p">(</span><span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">,</span> <span class="k">struct</span> <span class="n">vm_fault</span> <span class="o">*</span><span class="n">vmf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">Sg_fd</span> <span class="o">*</span><span class="n">sfp</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">offset</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">sa</span><span class="p">;</span>
	<span class="n">Sg_scatter_hold</span> <span class="o">*</span><span class="n">rsv_schp</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">k</span><span class="p">,</span> <span class="n">length</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="nb">NULL</span> <span class="o">==</span> <span class="n">vma</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">sfp</span> <span class="o">=</span> <span class="p">(</span><span class="n">Sg_fd</span> <span class="o">*</span><span class="p">)</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_private_data</span><span class="p">)))</span>
		<span class="k">return</span> <span class="n">VM_FAULT_SIGBUS</span><span class="p">;</span>
	<span class="n">rsv_schp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">sfp</span><span class="o">-&gt;</span><span class="n">reserve</span><span class="p">;</span>
	<span class="n">offset</span> <span class="o">=</span> <span class="n">vmf</span><span class="o">-&gt;</span><span class="n">pgoff</span> <span class="o">&lt;&lt;</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">offset</span> <span class="o">&gt;=</span> <span class="n">rsv_schp</span><span class="o">-&gt;</span><span class="n">bufflen</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">VM_FAULT_SIGBUS</span><span class="p">;</span>
	<span class="n">SCSI_LOG_TIMEOUT</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">printk</span><span class="p">(</span><span class="s">&quot;sg_vma_fault: offset=%lu, scatg=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				   <span class="n">offset</span><span class="p">,</span> <span class="n">rsv_schp</span><span class="o">-&gt;</span><span class="n">k_use_sg</span><span class="p">));</span>
	<span class="n">sa</span> <span class="o">=</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_start</span><span class="p">;</span>
	<span class="n">length</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">PAGE_SHIFT</span> <span class="o">+</span> <span class="n">rsv_schp</span><span class="o">-&gt;</span><span class="n">page_order</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">k</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="n">rsv_schp</span><span class="o">-&gt;</span><span class="n">k_use_sg</span> <span class="o">&amp;&amp;</span> <span class="n">sa</span> <span class="o">&lt;</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_end</span><span class="p">;</span> <span class="n">k</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">len</span> <span class="o">=</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_end</span> <span class="o">-</span> <span class="n">sa</span><span class="p">;</span>
		<span class="n">len</span> <span class="o">=</span> <span class="p">(</span><span class="n">len</span> <span class="o">&lt;</span> <span class="n">length</span><span class="p">)</span> <span class="o">?</span> <span class="n">len</span> <span class="o">:</span> <span class="n">length</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">offset</span> <span class="o">&lt;</span> <span class="n">len</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span> <span class="o">=</span> <span class="n">nth_page</span><span class="p">(</span><span class="n">rsv_schp</span><span class="o">-&gt;</span><span class="n">pages</span><span class="p">[</span><span class="n">k</span><span class="p">],</span>
						     <span class="n">offset</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">);</span>
			<span class="n">get_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>	<span class="cm">/* increment page count */</span>
			<span class="n">vmf</span><span class="o">-&gt;</span><span class="n">page</span> <span class="o">=</span> <span class="n">page</span><span class="p">;</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span> <span class="cm">/* success */</span>
		<span class="p">}</span>
		<span class="n">sa</span> <span class="o">+=</span> <span class="n">len</span><span class="p">;</span>
		<span class="n">offset</span> <span class="o">-=</span> <span class="n">len</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">VM_FAULT_SIGBUS</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">vm_operations_struct</span> <span class="n">sg_mmap_vm_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">fault</span> <span class="o">=</span> <span class="n">sg_vma_fault</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">sg_mmap</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">Sg_fd</span> <span class="o">*</span><span class="n">sfp</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">req_sz</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">sa</span><span class="p">;</span>
	<span class="n">Sg_scatter_hold</span> <span class="o">*</span><span class="n">rsv_schp</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">k</span><span class="p">,</span> <span class="n">length</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="o">!</span><span class="n">filp</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="o">!</span><span class="n">vma</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">sfp</span> <span class="o">=</span> <span class="p">(</span><span class="n">Sg_fd</span> <span class="o">*</span><span class="p">)</span> <span class="n">filp</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">)))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENXIO</span><span class="p">;</span>
	<span class="n">req_sz</span> <span class="o">=</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_end</span> <span class="o">-</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_start</span><span class="p">;</span>
	<span class="n">SCSI_LOG_TIMEOUT</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">printk</span><span class="p">(</span><span class="s">&quot;sg_mmap starting, vm_start=%p, len=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				   <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_start</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="n">req_sz</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_pgoff</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>	<span class="cm">/* want no offset */</span>
	<span class="n">rsv_schp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">sfp</span><span class="o">-&gt;</span><span class="n">reserve</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">req_sz</span> <span class="o">&gt;</span> <span class="n">rsv_schp</span><span class="o">-&gt;</span><span class="n">bufflen</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>	<span class="cm">/* cannot map more than reserved buffer */</span>

	<span class="n">sa</span> <span class="o">=</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_start</span><span class="p">;</span>
	<span class="n">length</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">PAGE_SHIFT</span> <span class="o">+</span> <span class="n">rsv_schp</span><span class="o">-&gt;</span><span class="n">page_order</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">k</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="n">rsv_schp</span><span class="o">-&gt;</span><span class="n">k_use_sg</span> <span class="o">&amp;&amp;</span> <span class="n">sa</span> <span class="o">&lt;</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_end</span><span class="p">;</span> <span class="n">k</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">len</span> <span class="o">=</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_end</span> <span class="o">-</span> <span class="n">sa</span><span class="p">;</span>
		<span class="n">len</span> <span class="o">=</span> <span class="p">(</span><span class="n">len</span> <span class="o">&lt;</span> <span class="n">length</span><span class="p">)</span> <span class="o">?</span> <span class="n">len</span> <span class="o">:</span> <span class="n">length</span><span class="p">;</span>
		<span class="n">sa</span> <span class="o">+=</span> <span class="n">len</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">sfp</span><span class="o">-&gt;</span><span class="n">mmap_called</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_flags</span> <span class="o">|=</span> <span class="n">VM_RESERVED</span><span class="p">;</span>
	<span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_private_data</span> <span class="o">=</span> <span class="n">sfp</span><span class="p">;</span>
	<span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_ops</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">sg_mmap_vm_ops</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">sg_rq_end_io_usercontext</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sg_request</span> <span class="o">*</span><span class="n">srp</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">work</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sg_request</span><span class="p">,</span> <span class="n">ew</span><span class="p">.</span><span class="n">work</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">sg_fd</span> <span class="o">*</span><span class="n">sfp</span> <span class="o">=</span> <span class="n">srp</span><span class="o">-&gt;</span><span class="n">parentfp</span><span class="p">;</span>

	<span class="n">sg_finish_rem_req</span><span class="p">(</span><span class="n">srp</span><span class="p">);</span>
	<span class="n">kref_put</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sfp</span><span class="o">-&gt;</span><span class="n">f_ref</span><span class="p">,</span> <span class="n">sg_remove_sfp</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * This function is a &quot;bottom half&quot; handler that is called by the mid</span>
<span class="cm"> * level when a command is completed (or has failed).</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">sg_rq_end_io</span><span class="p">(</span><span class="k">struct</span> <span class="n">request</span> <span class="o">*</span><span class="n">rq</span><span class="p">,</span> <span class="kt">int</span> <span class="n">uptodate</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sg_request</span> <span class="o">*</span><span class="n">srp</span> <span class="o">=</span> <span class="n">rq</span><span class="o">-&gt;</span><span class="n">end_io_data</span><span class="p">;</span>
	<span class="n">Sg_device</span> <span class="o">*</span><span class="n">sdp</span><span class="p">;</span>
	<span class="n">Sg_fd</span> <span class="o">*</span><span class="n">sfp</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">iflags</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ms</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">sense</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">result</span><span class="p">,</span> <span class="n">resid</span><span class="p">,</span> <span class="n">done</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">WARN_ON</span><span class="p">(</span><span class="n">srp</span><span class="o">-&gt;</span><span class="n">done</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">sfp</span> <span class="o">=</span> <span class="n">srp</span><span class="o">-&gt;</span><span class="n">parentfp</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">WARN_ON</span><span class="p">(</span><span class="n">sfp</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">sdp</span> <span class="o">=</span> <span class="n">sfp</span><span class="o">-&gt;</span><span class="n">parentdp</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">sdp</span><span class="o">-&gt;</span><span class="n">detached</span><span class="p">))</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;sg_rq_end_io: device detached</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="n">sense</span> <span class="o">=</span> <span class="n">rq</span><span class="o">-&gt;</span><span class="n">sense</span><span class="p">;</span>
	<span class="n">result</span> <span class="o">=</span> <span class="n">rq</span><span class="o">-&gt;</span><span class="n">errors</span><span class="p">;</span>
	<span class="n">resid</span> <span class="o">=</span> <span class="n">rq</span><span class="o">-&gt;</span><span class="n">resid_len</span><span class="p">;</span>

	<span class="n">SCSI_LOG_TIMEOUT</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="n">printk</span><span class="p">(</span><span class="s">&quot;sg_cmd_done: %s, pack_id=%d, res=0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">sdp</span><span class="o">-&gt;</span><span class="n">disk</span><span class="o">-&gt;</span><span class="n">disk_name</span><span class="p">,</span> <span class="n">srp</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">pack_id</span><span class="p">,</span> <span class="n">result</span><span class="p">));</span>
	<span class="n">srp</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">resid</span> <span class="o">=</span> <span class="n">resid</span><span class="p">;</span>
	<span class="n">ms</span> <span class="o">=</span> <span class="n">jiffies_to_msecs</span><span class="p">(</span><span class="n">jiffies</span><span class="p">);</span>
	<span class="n">srp</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">duration</span> <span class="o">=</span> <span class="p">(</span><span class="n">ms</span> <span class="o">&gt;</span> <span class="n">srp</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">duration</span><span class="p">)</span> <span class="o">?</span>
				<span class="p">(</span><span class="n">ms</span> <span class="o">-</span> <span class="n">srp</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">duration</span><span class="p">)</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="mi">0</span> <span class="o">!=</span> <span class="n">result</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">scsi_sense_hdr</span> <span class="n">sshdr</span><span class="p">;</span>

		<span class="n">srp</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">status</span> <span class="o">=</span> <span class="mh">0xff</span> <span class="o">&amp;</span> <span class="n">result</span><span class="p">;</span>
		<span class="n">srp</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">masked_status</span> <span class="o">=</span> <span class="n">status_byte</span><span class="p">(</span><span class="n">result</span><span class="p">);</span>
		<span class="n">srp</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">msg_status</span> <span class="o">=</span> <span class="n">msg_byte</span><span class="p">(</span><span class="n">result</span><span class="p">);</span>
		<span class="n">srp</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">host_status</span> <span class="o">=</span> <span class="n">host_byte</span><span class="p">(</span><span class="n">result</span><span class="p">);</span>
		<span class="n">srp</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">driver_status</span> <span class="o">=</span> <span class="n">driver_byte</span><span class="p">(</span><span class="n">result</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">sdp</span><span class="o">-&gt;</span><span class="n">sgdebug</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="p">((</span><span class="n">CHECK_CONDITION</span> <span class="o">==</span> <span class="n">srp</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">masked_status</span><span class="p">)</span> <span class="o">||</span>
		     <span class="p">(</span><span class="n">COMMAND_TERMINATED</span> <span class="o">==</span> <span class="n">srp</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">masked_status</span><span class="p">)))</span>
			<span class="n">__scsi_print_sense</span><span class="p">(</span><span class="s">&quot;sg_cmd_done&quot;</span><span class="p">,</span> <span class="n">sense</span><span class="p">,</span>
					   <span class="n">SCSI_SENSE_BUFFERSIZE</span><span class="p">);</span>

		<span class="cm">/* Following if statement is a patch supplied by Eric Youngdale */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">driver_byte</span><span class="p">(</span><span class="n">result</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span>
		    <span class="o">&amp;&amp;</span> <span class="n">scsi_normalize_sense</span><span class="p">(</span><span class="n">sense</span><span class="p">,</span> <span class="n">SCSI_SENSE_BUFFERSIZE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sshdr</span><span class="p">)</span>
		    <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">scsi_sense_is_deferred</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sshdr</span><span class="p">)</span>
		    <span class="o">&amp;&amp;</span> <span class="n">sshdr</span><span class="p">.</span><span class="n">sense_key</span> <span class="o">==</span> <span class="n">UNIT_ATTENTION</span>
		    <span class="o">&amp;&amp;</span> <span class="n">sdp</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">removable</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Detected possible disc change. Set the bit - this */</span>
			<span class="cm">/* may be used if there are filesystems using this device */</span>
			<span class="n">sdp</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">changed</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="cm">/* Rely on write phase to clean out srp status values, so no &quot;else&quot; */</span>

	<span class="n">write_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sfp</span><span class="o">-&gt;</span><span class="n">rq_list_lock</span><span class="p">,</span> <span class="n">iflags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">srp</span><span class="o">-&gt;</span><span class="n">orphan</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sfp</span><span class="o">-&gt;</span><span class="n">keep_orphan</span><span class="p">)</span>
			<span class="n">srp</span><span class="o">-&gt;</span><span class="n">sg_io_owned</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">done</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">srp</span><span class="o">-&gt;</span><span class="n">done</span> <span class="o">=</span> <span class="n">done</span><span class="p">;</span>
	<span class="n">write_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sfp</span><span class="o">-&gt;</span><span class="n">rq_list_lock</span><span class="p">,</span> <span class="n">iflags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">done</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* Now wake up any sg_read() that is waiting for this</span>
<span class="cm">		 * packet.</span>
<span class="cm">		 */</span>
		<span class="n">wake_up_interruptible</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sfp</span><span class="o">-&gt;</span><span class="n">read_wait</span><span class="p">);</span>
		<span class="n">kill_fasync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sfp</span><span class="o">-&gt;</span><span class="n">async_qp</span><span class="p">,</span> <span class="n">SIGPOLL</span><span class="p">,</span> <span class="n">POLL_IN</span><span class="p">);</span>
		<span class="n">kref_put</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sfp</span><span class="o">-&gt;</span><span class="n">f_ref</span><span class="p">,</span> <span class="n">sg_remove_sfp</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">INIT_WORK</span><span class="p">(</span><span class="o">&amp;</span><span class="n">srp</span><span class="o">-&gt;</span><span class="n">ew</span><span class="p">.</span><span class="n">work</span><span class="p">,</span> <span class="n">sg_rq_end_io_usercontext</span><span class="p">);</span>
		<span class="n">schedule_work</span><span class="p">(</span><span class="o">&amp;</span><span class="n">srp</span><span class="o">-&gt;</span><span class="n">ew</span><span class="p">.</span><span class="n">work</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">sg_fops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">owner</span> <span class="o">=</span> <span class="n">THIS_MODULE</span><span class="p">,</span>
	<span class="p">.</span><span class="n">read</span> <span class="o">=</span> <span class="n">sg_read</span><span class="p">,</span>
	<span class="p">.</span><span class="n">write</span> <span class="o">=</span> <span class="n">sg_write</span><span class="p">,</span>
	<span class="p">.</span><span class="n">poll</span> <span class="o">=</span> <span class="n">sg_poll</span><span class="p">,</span>
	<span class="p">.</span><span class="n">unlocked_ioctl</span> <span class="o">=</span> <span class="n">sg_ioctl</span><span class="p">,</span>
<span class="cp">#ifdef CONFIG_COMPAT</span>
	<span class="p">.</span><span class="n">compat_ioctl</span> <span class="o">=</span> <span class="n">sg_compat_ioctl</span><span class="p">,</span>
<span class="cp">#endif</span>
	<span class="p">.</span><span class="n">open</span> <span class="o">=</span> <span class="n">sg_open</span><span class="p">,</span>
	<span class="p">.</span><span class="n">mmap</span> <span class="o">=</span> <span class="n">sg_mmap</span><span class="p">,</span>
	<span class="p">.</span><span class="n">release</span> <span class="o">=</span> <span class="n">sg_release</span><span class="p">,</span>
	<span class="p">.</span><span class="n">fasync</span> <span class="o">=</span> <span class="n">sg_fasync</span><span class="p">,</span>
	<span class="p">.</span><span class="n">llseek</span> <span class="o">=</span> <span class="n">no_llseek</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">class</span> <span class="o">*</span><span class="n">sg_sysfs_class</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">sg_sysfs_valid</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="k">static</span> <span class="n">Sg_device</span> <span class="o">*</span><span class="nf">sg_alloc</span><span class="p">(</span><span class="k">struct</span> <span class="n">gendisk</span> <span class="o">*</span><span class="n">disk</span><span class="p">,</span> <span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="n">scsidp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">q</span> <span class="o">=</span> <span class="n">scsidp</span><span class="o">-&gt;</span><span class="n">request_queue</span><span class="p">;</span>
	<span class="n">Sg_device</span> <span class="o">*</span><span class="n">sdp</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">iflags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">k</span><span class="p">;</span>

	<span class="n">sdp</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">Sg_device</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sdp</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;kmalloc Sg_device failure</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">ENOMEM</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">idr_pre_get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sg_index_idr</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;idr expansion Sg_device failure</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">write_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sg_index_lock</span><span class="p">,</span> <span class="n">iflags</span><span class="p">);</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">idr_get_new</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sg_index_idr</span><span class="p">,</span> <span class="n">sdp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">k</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">write_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sg_index_lock</span><span class="p">,</span> <span class="n">iflags</span><span class="p">);</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;idr allocation Sg_device failure: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">error</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">k</span> <span class="o">&gt;=</span> <span class="n">SG_MAX_DEVS</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">overflow</span><span class="p">;</span>

	<span class="n">SCSI_LOG_TIMEOUT</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">printk</span><span class="p">(</span><span class="s">&quot;sg_alloc: dev=%d </span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">k</span><span class="p">));</span>
	<span class="n">sprintf</span><span class="p">(</span><span class="n">disk</span><span class="o">-&gt;</span><span class="n">disk_name</span><span class="p">,</span> <span class="s">&quot;sg%d&quot;</span><span class="p">,</span> <span class="n">k</span><span class="p">);</span>
	<span class="n">disk</span><span class="o">-&gt;</span><span class="n">first_minor</span> <span class="o">=</span> <span class="n">k</span><span class="p">;</span>
	<span class="n">sdp</span><span class="o">-&gt;</span><span class="n">disk</span> <span class="o">=</span> <span class="n">disk</span><span class="p">;</span>
	<span class="n">sdp</span><span class="o">-&gt;</span><span class="n">device</span> <span class="o">=</span> <span class="n">scsidp</span><span class="p">;</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sdp</span><span class="o">-&gt;</span><span class="n">sfds</span><span class="p">);</span>
	<span class="n">init_waitqueue_head</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sdp</span><span class="o">-&gt;</span><span class="n">o_excl_wait</span><span class="p">);</span>
	<span class="n">sdp</span><span class="o">-&gt;</span><span class="n">sg_tablesize</span> <span class="o">=</span> <span class="n">queue_max_segments</span><span class="p">(</span><span class="n">q</span><span class="p">);</span>
	<span class="n">sdp</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">=</span> <span class="n">k</span><span class="p">;</span>
	<span class="n">kref_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sdp</span><span class="o">-&gt;</span><span class="n">d_ref</span><span class="p">);</span>

	<span class="n">write_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sg_index_lock</span><span class="p">,</span> <span class="n">iflags</span><span class="p">);</span>

	<span class="n">error</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
 <span class="nl">out:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">sdp</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="n">error</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">sdp</span><span class="p">;</span>

 <span class="nl">overflow:</span>
	<span class="n">idr_remove</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sg_index_idr</span><span class="p">,</span> <span class="n">k</span><span class="p">);</span>
	<span class="n">write_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sg_index_lock</span><span class="p">,</span> <span class="n">iflags</span><span class="p">);</span>
	<span class="n">sdev_printk</span><span class="p">(</span><span class="n">KERN_WARNING</span><span class="p">,</span> <span class="n">scsidp</span><span class="p">,</span>
		    <span class="s">&quot;Unable to attach sg device type=%d, minor &quot;</span>
		    <span class="s">&quot;number exceeds %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">scsidp</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">,</span> <span class="n">SG_MAX_DEVS</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
	<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">sg_add</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">cl_dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">class_interface</span> <span class="o">*</span><span class="n">cl_intf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="n">scsidp</span> <span class="o">=</span> <span class="n">to_scsi_device</span><span class="p">(</span><span class="n">cl_dev</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">gendisk</span> <span class="o">*</span><span class="n">disk</span><span class="p">;</span>
	<span class="n">Sg_device</span> <span class="o">*</span><span class="n">sdp</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cdev</span> <span class="o">*</span> <span class="n">cdev</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">iflags</span><span class="p">;</span>

	<span class="n">disk</span> <span class="o">=</span> <span class="n">alloc_disk</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">disk</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;alloc_disk failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">disk</span><span class="o">-&gt;</span><span class="n">major</span> <span class="o">=</span> <span class="n">SCSI_GENERIC_MAJOR</span><span class="p">;</span>

	<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="n">cdev</span> <span class="o">=</span> <span class="n">cdev_alloc</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cdev</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;cdev_alloc failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">cdev</span><span class="o">-&gt;</span><span class="n">owner</span> <span class="o">=</span> <span class="n">THIS_MODULE</span><span class="p">;</span>
	<span class="n">cdev</span><span class="o">-&gt;</span><span class="n">ops</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">sg_fops</span><span class="p">;</span>

	<span class="n">sdp</span> <span class="o">=</span> <span class="n">sg_alloc</span><span class="p">(</span><span class="n">disk</span><span class="p">,</span> <span class="n">scsidp</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">sdp</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;sg_alloc failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">sdp</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">cdev_add</span><span class="p">(</span><span class="n">cdev</span><span class="p">,</span> <span class="n">MKDEV</span><span class="p">(</span><span class="n">SCSI_GENERIC_MAJOR</span><span class="p">,</span> <span class="n">sdp</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">),</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">cdev_add_err</span><span class="p">;</span>

	<span class="n">sdp</span><span class="o">-&gt;</span><span class="n">cdev</span> <span class="o">=</span> <span class="n">cdev</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sg_sysfs_valid</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">sg_class_member</span><span class="p">;</span>

		<span class="n">sg_class_member</span> <span class="o">=</span> <span class="n">device_create</span><span class="p">(</span><span class="n">sg_sysfs_class</span><span class="p">,</span> <span class="n">cl_dev</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">,</span>
						<span class="n">MKDEV</span><span class="p">(</span><span class="n">SCSI_GENERIC_MAJOR</span><span class="p">,</span>
						      <span class="n">sdp</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">),</span>
						<span class="n">sdp</span><span class="p">,</span> <span class="s">&quot;%s&quot;</span><span class="p">,</span> <span class="n">disk</span><span class="o">-&gt;</span><span class="n">disk_name</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">sg_class_member</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;sg_add: &quot;</span>
			       <span class="s">&quot;device_create failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">error</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">sg_class_member</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">cdev_add_err</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">sysfs_create_link</span><span class="p">(</span><span class="o">&amp;</span><span class="n">scsidp</span><span class="o">-&gt;</span><span class="n">sdev_gendev</span><span class="p">.</span><span class="n">kobj</span><span class="p">,</span>
					  <span class="o">&amp;</span><span class="n">sg_class_member</span><span class="o">-&gt;</span><span class="n">kobj</span><span class="p">,</span> <span class="s">&quot;generic&quot;</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;sg_add: unable to make symlink &quot;</span>
					<span class="s">&quot;&#39;generic&#39; back to sg%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">sdp</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;sg_add: sg_sys Invalid</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="n">sdev_printk</span><span class="p">(</span><span class="n">KERN_NOTICE</span><span class="p">,</span> <span class="n">scsidp</span><span class="p">,</span>
		    <span class="s">&quot;Attached scsi generic sg%d type %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">sdp</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">,</span>
		    <span class="n">scsidp</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">);</span>

	<span class="n">dev_set_drvdata</span><span class="p">(</span><span class="n">cl_dev</span><span class="p">,</span> <span class="n">sdp</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">cdev_add_err:</span>
	<span class="n">write_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sg_index_lock</span><span class="p">,</span> <span class="n">iflags</span><span class="p">);</span>
	<span class="n">idr_remove</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sg_index_idr</span><span class="p">,</span> <span class="n">sdp</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">);</span>
	<span class="n">write_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sg_index_lock</span><span class="p">,</span> <span class="n">iflags</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">sdp</span><span class="p">);</span>

<span class="nl">out:</span>
	<span class="n">put_disk</span><span class="p">(</span><span class="n">disk</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cdev</span><span class="p">)</span>
		<span class="n">cdev_del</span><span class="p">(</span><span class="n">cdev</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">sg_device_destroy</span><span class="p">(</span><span class="k">struct</span> <span class="n">kref</span> <span class="o">*</span><span class="n">kref</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sg_device</span> <span class="o">*</span><span class="n">sdp</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">kref</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sg_device</span><span class="p">,</span> <span class="n">d_ref</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="cm">/* CAUTION!  Note that the device can still be found via idr_find()</span>
<span class="cm">	 * even though the refcount is 0.  Therefore, do idr_remove() BEFORE</span>
<span class="cm">	 * any other cleanup.</span>
<span class="cm">	 */</span>

	<span class="n">write_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sg_index_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">idr_remove</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sg_index_idr</span><span class="p">,</span> <span class="n">sdp</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">);</span>
	<span class="n">write_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sg_index_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">SCSI_LOG_TIMEOUT</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;sg_device_destroy: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">sdp</span><span class="o">-&gt;</span><span class="n">disk</span><span class="o">-&gt;</span><span class="n">disk_name</span><span class="p">));</span>

	<span class="n">put_disk</span><span class="p">(</span><span class="n">sdp</span><span class="o">-&gt;</span><span class="n">disk</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">sdp</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">sg_remove</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">cl_dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">class_interface</span> <span class="o">*</span><span class="n">cl_intf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="n">scsidp</span> <span class="o">=</span> <span class="n">to_scsi_device</span><span class="p">(</span><span class="n">cl_dev</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">);</span>
	<span class="n">Sg_device</span> <span class="o">*</span><span class="n">sdp</span> <span class="o">=</span> <span class="n">dev_get_drvdata</span><span class="p">(</span><span class="n">cl_dev</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">iflags</span><span class="p">;</span>
	<span class="n">Sg_fd</span> <span class="o">*</span><span class="n">sfp</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sdp</span> <span class="o">||</span> <span class="n">sdp</span><span class="o">-&gt;</span><span class="n">detached</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">SCSI_LOG_TIMEOUT</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">printk</span><span class="p">(</span><span class="s">&quot;sg_remove: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">sdp</span><span class="o">-&gt;</span><span class="n">disk</span><span class="o">-&gt;</span><span class="n">disk_name</span><span class="p">));</span>

	<span class="cm">/* Need a write lock to set sdp-&gt;detached. */</span>
	<span class="n">write_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sg_index_lock</span><span class="p">,</span> <span class="n">iflags</span><span class="p">);</span>
	<span class="n">sdp</span><span class="o">-&gt;</span><span class="n">detached</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">sfp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sdp</span><span class="o">-&gt;</span><span class="n">sfds</span><span class="p">,</span> <span class="n">sfd_siblings</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">wake_up_interruptible</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sfp</span><span class="o">-&gt;</span><span class="n">read_wait</span><span class="p">);</span>
		<span class="n">kill_fasync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sfp</span><span class="o">-&gt;</span><span class="n">async_qp</span><span class="p">,</span> <span class="n">SIGPOLL</span><span class="p">,</span> <span class="n">POLL_HUP</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">write_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sg_index_lock</span><span class="p">,</span> <span class="n">iflags</span><span class="p">);</span>

	<span class="n">sysfs_remove_link</span><span class="p">(</span><span class="o">&amp;</span><span class="n">scsidp</span><span class="o">-&gt;</span><span class="n">sdev_gendev</span><span class="p">.</span><span class="n">kobj</span><span class="p">,</span> <span class="s">&quot;generic&quot;</span><span class="p">);</span>
	<span class="n">device_destroy</span><span class="p">(</span><span class="n">sg_sysfs_class</span><span class="p">,</span> <span class="n">MKDEV</span><span class="p">(</span><span class="n">SCSI_GENERIC_MAJOR</span><span class="p">,</span> <span class="n">sdp</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">));</span>
	<span class="n">cdev_del</span><span class="p">(</span><span class="n">sdp</span><span class="o">-&gt;</span><span class="n">cdev</span><span class="p">);</span>
	<span class="n">sdp</span><span class="o">-&gt;</span><span class="n">cdev</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">sg_put_dev</span><span class="p">(</span><span class="n">sdp</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">module_param_named</span><span class="p">(</span><span class="n">scatter_elem_sz</span><span class="p">,</span> <span class="n">scatter_elem_sz</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="n">S_IRUGO</span> <span class="o">|</span> <span class="n">S_IWUSR</span><span class="p">);</span>
<span class="n">module_param_named</span><span class="p">(</span><span class="n">def_reserved_size</span><span class="p">,</span> <span class="n">def_reserved_size</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span>
		   <span class="n">S_IRUGO</span> <span class="o">|</span> <span class="n">S_IWUSR</span><span class="p">);</span>
<span class="n">module_param_named</span><span class="p">(</span><span class="n">allow_dio</span><span class="p">,</span> <span class="n">sg_allow_dio</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="n">S_IRUGO</span> <span class="o">|</span> <span class="n">S_IWUSR</span><span class="p">);</span>

<span class="n">MODULE_AUTHOR</span><span class="p">(</span><span class="s">&quot;Douglas Gilbert&quot;</span><span class="p">);</span>
<span class="n">MODULE_DESCRIPTION</span><span class="p">(</span><span class="s">&quot;SCSI generic (sg) driver&quot;</span><span class="p">);</span>
<span class="n">MODULE_LICENSE</span><span class="p">(</span><span class="s">&quot;GPL&quot;</span><span class="p">);</span>
<span class="n">MODULE_VERSION</span><span class="p">(</span><span class="n">SG_VERSION_STR</span><span class="p">);</span>
<span class="n">MODULE_ALIAS_CHARDEV_MAJOR</span><span class="p">(</span><span class="n">SCSI_GENERIC_MAJOR</span><span class="p">);</span>

<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">scatter_elem_sz</span><span class="p">,</span> <span class="s">&quot;scatter gather element &quot;</span>
                <span class="s">&quot;size (default: max(SG_SCATTER_SZ, PAGE_SIZE))&quot;</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">def_reserved_size</span><span class="p">,</span> <span class="s">&quot;size of buffer reserved for each fd&quot;</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">allow_dio</span><span class="p">,</span> <span class="s">&quot;allow direct I/O (default: 0 (disallow))&quot;</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span>
<span class="nf">init_sg</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">scatter_elem_sz</span> <span class="o">&lt;</span> <span class="n">PAGE_SIZE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">scatter_elem_sz</span> <span class="o">=</span> <span class="n">PAGE_SIZE</span><span class="p">;</span>
		<span class="n">scatter_elem_sz_prev</span> <span class="o">=</span> <span class="n">scatter_elem_sz</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">def_reserved_size</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">sg_big_buff</span> <span class="o">=</span> <span class="n">def_reserved_size</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">def_reserved_size</span> <span class="o">=</span> <span class="n">sg_big_buff</span><span class="p">;</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">register_chrdev_region</span><span class="p">(</span><span class="n">MKDEV</span><span class="p">(</span><span class="n">SCSI_GENERIC_MAJOR</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> 
				    <span class="n">SG_MAX_DEVS</span><span class="p">,</span> <span class="s">&quot;sg&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
        <span class="n">sg_sysfs_class</span> <span class="o">=</span> <span class="n">class_create</span><span class="p">(</span><span class="n">THIS_MODULE</span><span class="p">,</span> <span class="s">&quot;scsi_generic&quot;</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span> <span class="n">IS_ERR</span><span class="p">(</span><span class="n">sg_sysfs_class</span><span class="p">)</span> <span class="p">)</span> <span class="p">{</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">sg_sysfs_class</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">err_out</span><span class="p">;</span>
        <span class="p">}</span>
	<span class="n">sg_sysfs_valid</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">scsi_register_interface</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sg_interface</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="mi">0</span> <span class="o">==</span> <span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
<span class="cp">#ifdef CONFIG_SCSI_PROC_FS</span>
		<span class="n">sg_proc_init</span><span class="p">();</span>
<span class="cp">#endif				</span><span class="cm">/* CONFIG_SCSI_PROC_FS */</span><span class="cp"></span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">class_destroy</span><span class="p">(</span><span class="n">sg_sysfs_class</span><span class="p">);</span>
<span class="nl">err_out:</span>
	<span class="n">unregister_chrdev_region</span><span class="p">(</span><span class="n">MKDEV</span><span class="p">(</span><span class="n">SCSI_GENERIC_MAJOR</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">SG_MAX_DEVS</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__exit</span>
<span class="nf">exit_sg</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef CONFIG_SCSI_PROC_FS</span>
	<span class="n">sg_proc_cleanup</span><span class="p">();</span>
<span class="cp">#endif				</span><span class="cm">/* CONFIG_SCSI_PROC_FS */</span><span class="cp"></span>
	<span class="n">scsi_unregister_interface</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sg_interface</span><span class="p">);</span>
	<span class="n">class_destroy</span><span class="p">(</span><span class="n">sg_sysfs_class</span><span class="p">);</span>
	<span class="n">sg_sysfs_valid</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">unregister_chrdev_region</span><span class="p">(</span><span class="n">MKDEV</span><span class="p">(</span><span class="n">SCSI_GENERIC_MAJOR</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
				 <span class="n">SG_MAX_DEVS</span><span class="p">);</span>
	<span class="n">idr_destroy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sg_index_idr</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">sg_start_req</span><span class="p">(</span><span class="n">Sg_request</span> <span class="o">*</span><span class="n">srp</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">cmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">res</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">request</span> <span class="o">*</span><span class="n">rq</span><span class="p">;</span>
	<span class="n">Sg_fd</span> <span class="o">*</span><span class="n">sfp</span> <span class="o">=</span> <span class="n">srp</span><span class="o">-&gt;</span><span class="n">parentfp</span><span class="p">;</span>
	<span class="n">sg_io_hdr_t</span> <span class="o">*</span><span class="n">hp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">srp</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">dxfer_len</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="n">hp</span><span class="o">-&gt;</span><span class="n">dxfer_len</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">dxfer_dir</span> <span class="o">=</span> <span class="n">hp</span><span class="o">-&gt;</span><span class="n">dxfer_direction</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">iov_count</span> <span class="o">=</span> <span class="n">hp</span><span class="o">-&gt;</span><span class="n">iovec_count</span><span class="p">;</span>
	<span class="n">Sg_scatter_hold</span> <span class="o">*</span><span class="n">req_schp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">srp</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
	<span class="n">Sg_scatter_hold</span> <span class="o">*</span><span class="n">rsv_schp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">sfp</span><span class="o">-&gt;</span><span class="n">reserve</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">q</span> <span class="o">=</span> <span class="n">sfp</span><span class="o">-&gt;</span><span class="n">parentdp</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">request_queue</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rq_map_data</span> <span class="o">*</span><span class="n">md</span><span class="p">,</span> <span class="n">map_data</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rw</span> <span class="o">=</span> <span class="n">hp</span><span class="o">-&gt;</span><span class="n">dxfer_direction</span> <span class="o">==</span> <span class="n">SG_DXFER_TO_DEV</span> <span class="o">?</span> <span class="n">WRITE</span> <span class="o">:</span> <span class="n">READ</span><span class="p">;</span>

	<span class="n">SCSI_LOG_TIMEOUT</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;sg_start_req: dxfer_len=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				   <span class="n">dxfer_len</span><span class="p">));</span>

	<span class="n">rq</span> <span class="o">=</span> <span class="n">blk_get_request</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">rw</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rq</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">memcpy</span><span class="p">(</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">cmd</span><span class="p">,</span> <span class="n">cmd</span><span class="p">,</span> <span class="n">hp</span><span class="o">-&gt;</span><span class="n">cmd_len</span><span class="p">);</span>

	<span class="n">rq</span><span class="o">-&gt;</span><span class="n">cmd_len</span> <span class="o">=</span> <span class="n">hp</span><span class="o">-&gt;</span><span class="n">cmd_len</span><span class="p">;</span>
	<span class="n">rq</span><span class="o">-&gt;</span><span class="n">cmd_type</span> <span class="o">=</span> <span class="n">REQ_TYPE_BLOCK_PC</span><span class="p">;</span>

	<span class="n">srp</span><span class="o">-&gt;</span><span class="n">rq</span> <span class="o">=</span> <span class="n">rq</span><span class="p">;</span>
	<span class="n">rq</span><span class="o">-&gt;</span><span class="n">end_io_data</span> <span class="o">=</span> <span class="n">srp</span><span class="p">;</span>
	<span class="n">rq</span><span class="o">-&gt;</span><span class="n">sense</span> <span class="o">=</span> <span class="n">srp</span><span class="o">-&gt;</span><span class="n">sense_b</span><span class="p">;</span>
	<span class="n">rq</span><span class="o">-&gt;</span><span class="n">retries</span> <span class="o">=</span> <span class="n">SG_DEFAULT_RETRIES</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">dxfer_len</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">dxfer_dir</span> <span class="o">==</span> <span class="n">SG_DXFER_NONE</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sg_allow_dio</span> <span class="o">&amp;&amp;</span> <span class="n">hp</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">SG_FLAG_DIRECT_IO</span> <span class="o">&amp;&amp;</span>
	    <span class="n">dxfer_dir</span> <span class="o">!=</span> <span class="n">SG_DXFER_UNKNOWN</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">iov_count</span> <span class="o">&amp;&amp;</span>
	    <span class="o">!</span><span class="n">sfp</span><span class="o">-&gt;</span><span class="n">parentdp</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">unchecked_isa_dma</span> <span class="o">&amp;&amp;</span>
	    <span class="n">blk_rq_aligned</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">hp</span><span class="o">-&gt;</span><span class="n">dxferp</span><span class="p">,</span> <span class="n">dxfer_len</span><span class="p">))</span>
		<span class="n">md</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">md</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">map_data</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">md</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sg_res_in_use</span><span class="p">(</span><span class="n">sfp</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">dxfer_len</span> <span class="o">&lt;=</span> <span class="n">rsv_schp</span><span class="o">-&gt;</span><span class="n">bufflen</span><span class="p">)</span>
			<span class="n">sg_link_reserve</span><span class="p">(</span><span class="n">sfp</span><span class="p">,</span> <span class="n">srp</span><span class="p">,</span> <span class="n">dxfer_len</span><span class="p">);</span>
		<span class="k">else</span> <span class="p">{</span>
			<span class="n">res</span> <span class="o">=</span> <span class="n">sg_build_indirect</span><span class="p">(</span><span class="n">req_schp</span><span class="p">,</span> <span class="n">sfp</span><span class="p">,</span> <span class="n">dxfer_len</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">res</span><span class="p">)</span>
				<span class="k">return</span> <span class="n">res</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">md</span><span class="o">-&gt;</span><span class="n">pages</span> <span class="o">=</span> <span class="n">req_schp</span><span class="o">-&gt;</span><span class="n">pages</span><span class="p">;</span>
		<span class="n">md</span><span class="o">-&gt;</span><span class="n">page_order</span> <span class="o">=</span> <span class="n">req_schp</span><span class="o">-&gt;</span><span class="n">page_order</span><span class="p">;</span>
		<span class="n">md</span><span class="o">-&gt;</span><span class="n">nr_entries</span> <span class="o">=</span> <span class="n">req_schp</span><span class="o">-&gt;</span><span class="n">k_use_sg</span><span class="p">;</span>
		<span class="n">md</span><span class="o">-&gt;</span><span class="n">offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">md</span><span class="o">-&gt;</span><span class="n">null_mapped</span> <span class="o">=</span> <span class="n">hp</span><span class="o">-&gt;</span><span class="n">dxferp</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dxfer_dir</span> <span class="o">==</span> <span class="n">SG_DXFER_TO_FROM_DEV</span><span class="p">)</span>
			<span class="n">md</span><span class="o">-&gt;</span><span class="n">from_user</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">md</span><span class="o">-&gt;</span><span class="n">from_user</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">iov_count</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">len</span><span class="p">,</span> <span class="n">size</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sg_iovec</span><span class="p">)</span> <span class="o">*</span> <span class="n">iov_count</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">iovec</span> <span class="o">*</span><span class="n">iov</span><span class="p">;</span>

		<span class="n">iov</span> <span class="o">=</span> <span class="n">memdup_user</span><span class="p">(</span><span class="n">hp</span><span class="o">-&gt;</span><span class="n">dxferp</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">iov</span><span class="p">))</span>
			<span class="k">return</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">iov</span><span class="p">);</span>

		<span class="n">len</span> <span class="o">=</span> <span class="n">iov_length</span><span class="p">(</span><span class="n">iov</span><span class="p">,</span> <span class="n">iov_count</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">hp</span><span class="o">-&gt;</span><span class="n">dxfer_len</span> <span class="o">&lt;</span> <span class="n">len</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">iov_count</span> <span class="o">=</span> <span class="n">iov_shorten</span><span class="p">(</span><span class="n">iov</span><span class="p">,</span> <span class="n">iov_count</span><span class="p">,</span> <span class="n">hp</span><span class="o">-&gt;</span><span class="n">dxfer_len</span><span class="p">);</span>
			<span class="n">len</span> <span class="o">=</span> <span class="n">hp</span><span class="o">-&gt;</span><span class="n">dxfer_len</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">res</span> <span class="o">=</span> <span class="n">blk_rq_map_user_iov</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">rq</span><span class="p">,</span> <span class="n">md</span><span class="p">,</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sg_iovec</span> <span class="o">*</span><span class="p">)</span><span class="n">iov</span><span class="p">,</span>
					  <span class="n">iov_count</span><span class="p">,</span>
					  <span class="n">len</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">iov</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">res</span> <span class="o">=</span> <span class="n">blk_rq_map_user</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">rq</span><span class="p">,</span> <span class="n">md</span><span class="p">,</span> <span class="n">hp</span><span class="o">-&gt;</span><span class="n">dxferp</span><span class="p">,</span>
				      <span class="n">hp</span><span class="o">-&gt;</span><span class="n">dxfer_len</span><span class="p">,</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">res</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">srp</span><span class="o">-&gt;</span><span class="n">bio</span> <span class="o">=</span> <span class="n">rq</span><span class="o">-&gt;</span><span class="n">bio</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">md</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">req_schp</span><span class="o">-&gt;</span><span class="n">dio_in_use</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">hp</span><span class="o">-&gt;</span><span class="n">info</span> <span class="o">|=</span> <span class="n">SG_INFO_DIRECT_IO</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">res</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">sg_finish_rem_req</span><span class="p">(</span><span class="n">Sg_request</span> <span class="o">*</span> <span class="n">srp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">Sg_fd</span> <span class="o">*</span><span class="n">sfp</span> <span class="o">=</span> <span class="n">srp</span><span class="o">-&gt;</span><span class="n">parentfp</span><span class="p">;</span>
	<span class="n">Sg_scatter_hold</span> <span class="o">*</span><span class="n">req_schp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">srp</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>

	<span class="n">SCSI_LOG_TIMEOUT</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="n">printk</span><span class="p">(</span><span class="s">&quot;sg_finish_rem_req: res_used=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="n">srp</span><span class="o">-&gt;</span><span class="n">res_used</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">srp</span><span class="o">-&gt;</span><span class="n">rq</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">srp</span><span class="o">-&gt;</span><span class="n">bio</span><span class="p">)</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">blk_rq_unmap_user</span><span class="p">(</span><span class="n">srp</span><span class="o">-&gt;</span><span class="n">bio</span><span class="p">);</span>

		<span class="n">blk_put_request</span><span class="p">(</span><span class="n">srp</span><span class="o">-&gt;</span><span class="n">rq</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">srp</span><span class="o">-&gt;</span><span class="n">res_used</span><span class="p">)</span>
		<span class="n">sg_unlink_reserve</span><span class="p">(</span><span class="n">sfp</span><span class="p">,</span> <span class="n">srp</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">sg_remove_scat</span><span class="p">(</span><span class="n">req_schp</span><span class="p">);</span>

	<span class="n">sg_remove_request</span><span class="p">(</span><span class="n">sfp</span><span class="p">,</span> <span class="n">srp</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">sg_build_sgat</span><span class="p">(</span><span class="n">Sg_scatter_hold</span> <span class="o">*</span> <span class="n">schp</span><span class="p">,</span> <span class="k">const</span> <span class="n">Sg_fd</span> <span class="o">*</span> <span class="n">sfp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">tablesize</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">sg_bufflen</span> <span class="o">=</span> <span class="n">tablesize</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="p">);</span>
	<span class="n">gfp_t</span> <span class="n">gfp_flags</span> <span class="o">=</span> <span class="n">GFP_ATOMIC</span> <span class="o">|</span> <span class="n">__GFP_NOWARN</span><span class="p">;</span>

	<span class="n">schp</span><span class="o">-&gt;</span><span class="n">pages</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="n">sg_bufflen</span><span class="p">,</span> <span class="n">gfp_flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">schp</span><span class="o">-&gt;</span><span class="n">pages</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="n">schp</span><span class="o">-&gt;</span><span class="n">sglist_len</span> <span class="o">=</span> <span class="n">sg_bufflen</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">tablesize</span><span class="p">;</span>	<span class="cm">/* number of scat_gath elements allocated */</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">sg_build_indirect</span><span class="p">(</span><span class="n">Sg_scatter_hold</span> <span class="o">*</span> <span class="n">schp</span><span class="p">,</span> <span class="n">Sg_fd</span> <span class="o">*</span> <span class="n">sfp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">buff_size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret_sz</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">rem_sz</span><span class="p">,</span> <span class="n">num</span><span class="p">,</span> <span class="n">mx_sc_elems</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">sg_tablesize</span> <span class="o">=</span> <span class="n">sfp</span><span class="o">-&gt;</span><span class="n">parentdp</span><span class="o">-&gt;</span><span class="n">sg_tablesize</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">blk_size</span> <span class="o">=</span> <span class="n">buff_size</span><span class="p">,</span> <span class="n">order</span><span class="p">;</span>
	<span class="n">gfp_t</span> <span class="n">gfp_mask</span> <span class="o">=</span> <span class="n">GFP_ATOMIC</span> <span class="o">|</span> <span class="n">__GFP_COMP</span> <span class="o">|</span> <span class="n">__GFP_NOWARN</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">blk_size</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="mi">0</span> <span class="o">==</span> <span class="n">blk_size</span><span class="p">)</span>
		<span class="o">++</span><span class="n">blk_size</span><span class="p">;</span>	<span class="cm">/* don&#39;t know why */</span>
	<span class="cm">/* round request up to next highest SG_SECTOR_SZ byte boundary */</span>
	<span class="n">blk_size</span> <span class="o">=</span> <span class="n">ALIGN</span><span class="p">(</span><span class="n">blk_size</span><span class="p">,</span> <span class="n">SG_SECTOR_SZ</span><span class="p">);</span>
	<span class="n">SCSI_LOG_TIMEOUT</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="n">printk</span><span class="p">(</span><span class="s">&quot;sg_build_indirect: buff_size=%d, blk_size=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				   <span class="n">buff_size</span><span class="p">,</span> <span class="n">blk_size</span><span class="p">));</span>

	<span class="cm">/* N.B. ret_sz carried into this block ... */</span>
	<span class="n">mx_sc_elems</span> <span class="o">=</span> <span class="n">sg_build_sgat</span><span class="p">(</span><span class="n">schp</span><span class="p">,</span> <span class="n">sfp</span><span class="p">,</span> <span class="n">sg_tablesize</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mx_sc_elems</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">mx_sc_elems</span><span class="p">;</span>	<span class="cm">/* most likely -ENOMEM */</span>

	<span class="n">num</span> <span class="o">=</span> <span class="n">scatter_elem_sz</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">num</span> <span class="o">!=</span> <span class="n">scatter_elem_sz_prev</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">num</span> <span class="o">&lt;</span> <span class="n">PAGE_SIZE</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">scatter_elem_sz</span> <span class="o">=</span> <span class="n">PAGE_SIZE</span><span class="p">;</span>
			<span class="n">scatter_elem_sz_prev</span> <span class="o">=</span> <span class="n">PAGE_SIZE</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="n">scatter_elem_sz_prev</span> <span class="o">=</span> <span class="n">num</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sfp</span><span class="o">-&gt;</span><span class="n">low_dma</span><span class="p">)</span>
		<span class="n">gfp_mask</span> <span class="o">|=</span> <span class="n">GFP_DMA</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">capable</span><span class="p">(</span><span class="n">CAP_SYS_ADMIN</span><span class="p">)</span> <span class="o">||</span> <span class="o">!</span><span class="n">capable</span><span class="p">(</span><span class="n">CAP_SYS_RAWIO</span><span class="p">))</span>
		<span class="n">gfp_mask</span> <span class="o">|=</span> <span class="n">__GFP_ZERO</span><span class="p">;</span>

	<span class="n">order</span> <span class="o">=</span> <span class="n">get_order</span><span class="p">(</span><span class="n">num</span><span class="p">);</span>
<span class="nl">retry:</span>
	<span class="n">ret_sz</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">PAGE_SHIFT</span> <span class="o">+</span> <span class="n">order</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">k</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">rem_sz</span> <span class="o">=</span> <span class="n">blk_size</span><span class="p">;</span> <span class="n">rem_sz</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="n">mx_sc_elems</span><span class="p">;</span>
	     <span class="n">k</span><span class="o">++</span><span class="p">,</span> <span class="n">rem_sz</span> <span class="o">-=</span> <span class="n">ret_sz</span><span class="p">)</span> <span class="p">{</span>

		<span class="n">num</span> <span class="o">=</span> <span class="p">(</span><span class="n">rem_sz</span> <span class="o">&gt;</span> <span class="n">scatter_elem_sz_prev</span><span class="p">)</span> <span class="o">?</span>
			<span class="n">scatter_elem_sz_prev</span> <span class="o">:</span> <span class="n">rem_sz</span><span class="p">;</span>

		<span class="n">schp</span><span class="o">-&gt;</span><span class="n">pages</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">alloc_pages</span><span class="p">(</span><span class="n">gfp_mask</span><span class="p">,</span> <span class="n">order</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">schp</span><span class="o">-&gt;</span><span class="n">pages</span><span class="p">[</span><span class="n">k</span><span class="p">])</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">num</span> <span class="o">==</span> <span class="n">scatter_elem_sz_prev</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">ret_sz</span> <span class="o">&gt;</span> <span class="n">scatter_elem_sz_prev</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">scatter_elem_sz</span> <span class="o">=</span> <span class="n">ret_sz</span><span class="p">;</span>
				<span class="n">scatter_elem_sz_prev</span> <span class="o">=</span> <span class="n">ret_sz</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="n">SCSI_LOG_TIMEOUT</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="n">printk</span><span class="p">(</span><span class="s">&quot;sg_build_indirect: k=%d, num=%d, &quot;</span>
				 <span class="s">&quot;ret_sz=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">num</span><span class="p">,</span> <span class="n">ret_sz</span><span class="p">));</span>
	<span class="p">}</span>		<span class="cm">/* end of for loop */</span>

	<span class="n">schp</span><span class="o">-&gt;</span><span class="n">page_order</span> <span class="o">=</span> <span class="n">order</span><span class="p">;</span>
	<span class="n">schp</span><span class="o">-&gt;</span><span class="n">k_use_sg</span> <span class="o">=</span> <span class="n">k</span><span class="p">;</span>
	<span class="n">SCSI_LOG_TIMEOUT</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="n">printk</span><span class="p">(</span><span class="s">&quot;sg_build_indirect: k_use_sg=%d, &quot;</span>
			 <span class="s">&quot;rem_sz=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">rem_sz</span><span class="p">));</span>

	<span class="n">schp</span><span class="o">-&gt;</span><span class="n">bufflen</span> <span class="o">=</span> <span class="n">blk_size</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rem_sz</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>	<span class="cm">/* must have failed */</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">out:</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">k</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">__free_pages</span><span class="p">(</span><span class="n">schp</span><span class="o">-&gt;</span><span class="n">pages</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">order</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">--</span><span class="n">order</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">retry</span><span class="p">;</span>

	<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">sg_remove_scat</span><span class="p">(</span><span class="n">Sg_scatter_hold</span> <span class="o">*</span> <span class="n">schp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">SCSI_LOG_TIMEOUT</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="n">printk</span><span class="p">(</span><span class="s">&quot;sg_remove_scat: k_use_sg=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">schp</span><span class="o">-&gt;</span><span class="n">k_use_sg</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">schp</span><span class="o">-&gt;</span><span class="n">pages</span> <span class="o">&amp;&amp;</span> <span class="n">schp</span><span class="o">-&gt;</span><span class="n">sglist_len</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">schp</span><span class="o">-&gt;</span><span class="n">dio_in_use</span><span class="p">)</span> <span class="p">{</span>
			<span class="kt">int</span> <span class="n">k</span><span class="p">;</span>

			<span class="k">for</span> <span class="p">(</span><span class="n">k</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="n">schp</span><span class="o">-&gt;</span><span class="n">k_use_sg</span> <span class="o">&amp;&amp;</span> <span class="n">schp</span><span class="o">-&gt;</span><span class="n">pages</span><span class="p">[</span><span class="n">k</span><span class="p">];</span> <span class="n">k</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">SCSI_LOG_TIMEOUT</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="n">printk</span><span class="p">(</span>
				    <span class="s">&quot;sg_remove_scat: k=%d, pg=0x%p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				    <span class="n">k</span><span class="p">,</span> <span class="n">schp</span><span class="o">-&gt;</span><span class="n">pages</span><span class="p">[</span><span class="n">k</span><span class="p">]));</span>
				<span class="n">__free_pages</span><span class="p">(</span><span class="n">schp</span><span class="o">-&gt;</span><span class="n">pages</span><span class="p">[</span><span class="n">k</span><span class="p">],</span> <span class="n">schp</span><span class="o">-&gt;</span><span class="n">page_order</span><span class="p">);</span>
			<span class="p">}</span>

			<span class="n">kfree</span><span class="p">(</span><span class="n">schp</span><span class="o">-&gt;</span><span class="n">pages</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">schp</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span> <span class="p">(</span><span class="o">*</span><span class="n">schp</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">sg_read_oxfer</span><span class="p">(</span><span class="n">Sg_request</span> <span class="o">*</span> <span class="n">srp</span><span class="p">,</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">outp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">num_read_xfer</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">Sg_scatter_hold</span> <span class="o">*</span><span class="n">schp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">srp</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">k</span><span class="p">,</span> <span class="n">num</span><span class="p">;</span>

	<span class="n">SCSI_LOG_TIMEOUT</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="n">printk</span><span class="p">(</span><span class="s">&quot;sg_read_oxfer: num_read_xfer=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				   <span class="n">num_read_xfer</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">((</span><span class="o">!</span><span class="n">outp</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">num_read_xfer</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">num</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">PAGE_SHIFT</span> <span class="o">+</span> <span class="n">schp</span><span class="o">-&gt;</span><span class="n">page_order</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">k</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="n">schp</span><span class="o">-&gt;</span><span class="n">k_use_sg</span> <span class="o">&amp;&amp;</span> <span class="n">schp</span><span class="o">-&gt;</span><span class="n">pages</span><span class="p">[</span><span class="n">k</span><span class="p">];</span> <span class="n">k</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">num</span> <span class="o">&gt;</span> <span class="n">num_read_xfer</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">__copy_to_user</span><span class="p">(</span><span class="n">outp</span><span class="p">,</span> <span class="n">page_address</span><span class="p">(</span><span class="n">schp</span><span class="o">-&gt;</span><span class="n">pages</span><span class="p">[</span><span class="n">k</span><span class="p">]),</span>
					   <span class="n">num_read_xfer</span><span class="p">))</span>
				<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">__copy_to_user</span><span class="p">(</span><span class="n">outp</span><span class="p">,</span> <span class="n">page_address</span><span class="p">(</span><span class="n">schp</span><span class="o">-&gt;</span><span class="n">pages</span><span class="p">[</span><span class="n">k</span><span class="p">]),</span>
					   <span class="n">num</span><span class="p">))</span>
				<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
			<span class="n">num_read_xfer</span> <span class="o">-=</span> <span class="n">num</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">num_read_xfer</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="n">outp</span> <span class="o">+=</span> <span class="n">num</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">sg_build_reserve</span><span class="p">(</span><span class="n">Sg_fd</span> <span class="o">*</span> <span class="n">sfp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">req_size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">Sg_scatter_hold</span> <span class="o">*</span><span class="n">schp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">sfp</span><span class="o">-&gt;</span><span class="n">reserve</span><span class="p">;</span>

	<span class="n">SCSI_LOG_TIMEOUT</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="n">printk</span><span class="p">(</span><span class="s">&quot;sg_build_reserve: req_size=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">req_size</span><span class="p">));</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">req_size</span> <span class="o">&lt;</span> <span class="n">PAGE_SIZE</span><span class="p">)</span>
			<span class="n">req_size</span> <span class="o">=</span> <span class="n">PAGE_SIZE</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="mi">0</span> <span class="o">==</span> <span class="n">sg_build_indirect</span><span class="p">(</span><span class="n">schp</span><span class="p">,</span> <span class="n">sfp</span><span class="p">,</span> <span class="n">req_size</span><span class="p">))</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">sg_remove_scat</span><span class="p">(</span><span class="n">schp</span><span class="p">);</span>
		<span class="n">req_size</span> <span class="o">&gt;&gt;=</span> <span class="mi">1</span><span class="p">;</span>	<span class="cm">/* divide by 2 */</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">req_size</span> <span class="o">&gt;</span> <span class="p">(</span><span class="n">PAGE_SIZE</span> <span class="o">/</span> <span class="mi">2</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">sg_link_reserve</span><span class="p">(</span><span class="n">Sg_fd</span> <span class="o">*</span> <span class="n">sfp</span><span class="p">,</span> <span class="n">Sg_request</span> <span class="o">*</span> <span class="n">srp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">Sg_scatter_hold</span> <span class="o">*</span><span class="n">req_schp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">srp</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
	<span class="n">Sg_scatter_hold</span> <span class="o">*</span><span class="n">rsv_schp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">sfp</span><span class="o">-&gt;</span><span class="n">reserve</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">k</span><span class="p">,</span> <span class="n">num</span><span class="p">,</span> <span class="n">rem</span><span class="p">;</span>

	<span class="n">srp</span><span class="o">-&gt;</span><span class="n">res_used</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">SCSI_LOG_TIMEOUT</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="n">printk</span><span class="p">(</span><span class="s">&quot;sg_link_reserve: size=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">size</span><span class="p">));</span>
	<span class="n">rem</span> <span class="o">=</span> <span class="n">size</span><span class="p">;</span>

	<span class="n">num</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">PAGE_SHIFT</span> <span class="o">+</span> <span class="n">rsv_schp</span><span class="o">-&gt;</span><span class="n">page_order</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">k</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="n">rsv_schp</span><span class="o">-&gt;</span><span class="n">k_use_sg</span><span class="p">;</span> <span class="n">k</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rem</span> <span class="o">&lt;=</span> <span class="n">num</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">req_schp</span><span class="o">-&gt;</span><span class="n">k_use_sg</span> <span class="o">=</span> <span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">req_schp</span><span class="o">-&gt;</span><span class="n">sglist_len</span> <span class="o">=</span> <span class="n">rsv_schp</span><span class="o">-&gt;</span><span class="n">sglist_len</span><span class="p">;</span>
			<span class="n">req_schp</span><span class="o">-&gt;</span><span class="n">pages</span> <span class="o">=</span> <span class="n">rsv_schp</span><span class="o">-&gt;</span><span class="n">pages</span><span class="p">;</span>

			<span class="n">req_schp</span><span class="o">-&gt;</span><span class="n">bufflen</span> <span class="o">=</span> <span class="n">size</span><span class="p">;</span>
			<span class="n">req_schp</span><span class="o">-&gt;</span><span class="n">page_order</span> <span class="o">=</span> <span class="n">rsv_schp</span><span class="o">-&gt;</span><span class="n">page_order</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="n">rem</span> <span class="o">-=</span> <span class="n">num</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">k</span> <span class="o">&gt;=</span> <span class="n">rsv_schp</span><span class="o">-&gt;</span><span class="n">k_use_sg</span><span class="p">)</span>
		<span class="n">SCSI_LOG_TIMEOUT</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">printk</span><span class="p">(</span><span class="s">&quot;sg_link_reserve: BAD size</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">sg_unlink_reserve</span><span class="p">(</span><span class="n">Sg_fd</span> <span class="o">*</span> <span class="n">sfp</span><span class="p">,</span> <span class="n">Sg_request</span> <span class="o">*</span> <span class="n">srp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">Sg_scatter_hold</span> <span class="o">*</span><span class="n">req_schp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">srp</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>

	<span class="n">SCSI_LOG_TIMEOUT</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="n">printk</span><span class="p">(</span><span class="s">&quot;sg_unlink_reserve: req-&gt;k_use_sg=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				   <span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="n">req_schp</span><span class="o">-&gt;</span><span class="n">k_use_sg</span><span class="p">));</span>
	<span class="n">req_schp</span><span class="o">-&gt;</span><span class="n">k_use_sg</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">req_schp</span><span class="o">-&gt;</span><span class="n">bufflen</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">req_schp</span><span class="o">-&gt;</span><span class="n">pages</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">req_schp</span><span class="o">-&gt;</span><span class="n">page_order</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">req_schp</span><span class="o">-&gt;</span><span class="n">sglist_len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">sfp</span><span class="o">-&gt;</span><span class="n">save_scat_len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">srp</span><span class="o">-&gt;</span><span class="n">res_used</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">Sg_request</span> <span class="o">*</span>
<span class="nf">sg_get_rq_mark</span><span class="p">(</span><span class="n">Sg_fd</span> <span class="o">*</span> <span class="n">sfp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">pack_id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">Sg_request</span> <span class="o">*</span><span class="n">resp</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">iflags</span><span class="p">;</span>

	<span class="n">write_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sfp</span><span class="o">-&gt;</span><span class="n">rq_list_lock</span><span class="p">,</span> <span class="n">iflags</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">resp</span> <span class="o">=</span> <span class="n">sfp</span><span class="o">-&gt;</span><span class="n">headrp</span><span class="p">;</span> <span class="n">resp</span><span class="p">;</span> <span class="n">resp</span> <span class="o">=</span> <span class="n">resp</span><span class="o">-&gt;</span><span class="n">nextrp</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* look for requests that are ready + not SG_IO owned */</span>
		<span class="k">if</span> <span class="p">((</span><span class="mi">1</span> <span class="o">==</span> <span class="n">resp</span><span class="o">-&gt;</span><span class="n">done</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="o">!</span><span class="n">resp</span><span class="o">-&gt;</span><span class="n">sg_io_owned</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="p">((</span><span class="o">-</span><span class="mi">1</span> <span class="o">==</span> <span class="n">pack_id</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">resp</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">pack_id</span> <span class="o">==</span> <span class="n">pack_id</span><span class="p">)))</span> <span class="p">{</span>
			<span class="n">resp</span><span class="o">-&gt;</span><span class="n">done</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>	<span class="cm">/* guard against other readers */</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">write_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sfp</span><span class="o">-&gt;</span><span class="n">rq_list_lock</span><span class="p">,</span> <span class="n">iflags</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">resp</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* always adds to end of list */</span>
<span class="k">static</span> <span class="n">Sg_request</span> <span class="o">*</span>
<span class="nf">sg_add_request</span><span class="p">(</span><span class="n">Sg_fd</span> <span class="o">*</span> <span class="n">sfp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">k</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">iflags</span><span class="p">;</span>
	<span class="n">Sg_request</span> <span class="o">*</span><span class="n">resp</span><span class="p">;</span>
	<span class="n">Sg_request</span> <span class="o">*</span><span class="n">rp</span> <span class="o">=</span> <span class="n">sfp</span><span class="o">-&gt;</span><span class="n">req_arr</span><span class="p">;</span>

	<span class="n">write_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sfp</span><span class="o">-&gt;</span><span class="n">rq_list_lock</span><span class="p">,</span> <span class="n">iflags</span><span class="p">);</span>
	<span class="n">resp</span> <span class="o">=</span> <span class="n">sfp</span><span class="o">-&gt;</span><span class="n">headrp</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">resp</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">memset</span><span class="p">(</span><span class="n">rp</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span> <span class="p">(</span><span class="n">Sg_request</span><span class="p">));</span>
		<span class="n">rp</span><span class="o">-&gt;</span><span class="n">parentfp</span> <span class="o">=</span> <span class="n">sfp</span><span class="p">;</span>
		<span class="n">resp</span> <span class="o">=</span> <span class="n">rp</span><span class="p">;</span>
		<span class="n">sfp</span><span class="o">-&gt;</span><span class="n">headrp</span> <span class="o">=</span> <span class="n">resp</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="mi">0</span> <span class="o">==</span> <span class="n">sfp</span><span class="o">-&gt;</span><span class="n">cmd_q</span><span class="p">)</span>
			<span class="n">resp</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>	<span class="cm">/* command queuing disallowed */</span>
		<span class="k">else</span> <span class="p">{</span>
			<span class="k">for</span> <span class="p">(</span><span class="n">k</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="n">SG_MAX_QUEUE</span><span class="p">;</span> <span class="o">++</span><span class="n">k</span><span class="p">,</span> <span class="o">++</span><span class="n">rp</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rp</span><span class="o">-&gt;</span><span class="n">parentfp</span><span class="p">)</span>
					<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">k</span> <span class="o">&lt;</span> <span class="n">SG_MAX_QUEUE</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">memset</span><span class="p">(</span><span class="n">rp</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span> <span class="p">(</span><span class="n">Sg_request</span><span class="p">));</span>
				<span class="n">rp</span><span class="o">-&gt;</span><span class="n">parentfp</span> <span class="o">=</span> <span class="n">sfp</span><span class="p">;</span>
				<span class="k">while</span> <span class="p">(</span><span class="n">resp</span><span class="o">-&gt;</span><span class="n">nextrp</span><span class="p">)</span>
					<span class="n">resp</span> <span class="o">=</span> <span class="n">resp</span><span class="o">-&gt;</span><span class="n">nextrp</span><span class="p">;</span>
				<span class="n">resp</span><span class="o">-&gt;</span><span class="n">nextrp</span> <span class="o">=</span> <span class="n">rp</span><span class="p">;</span>
				<span class="n">resp</span> <span class="o">=</span> <span class="n">rp</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span>
				<span class="n">resp</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">resp</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">resp</span><span class="o">-&gt;</span><span class="n">nextrp</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">resp</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">duration</span> <span class="o">=</span> <span class="n">jiffies_to_msecs</span><span class="p">(</span><span class="n">jiffies</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">write_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sfp</span><span class="o">-&gt;</span><span class="n">rq_list_lock</span><span class="p">,</span> <span class="n">iflags</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">resp</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Return of 1 for found; 0 for not found */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">sg_remove_request</span><span class="p">(</span><span class="n">Sg_fd</span> <span class="o">*</span> <span class="n">sfp</span><span class="p">,</span> <span class="n">Sg_request</span> <span class="o">*</span> <span class="n">srp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">Sg_request</span> <span class="o">*</span><span class="n">prev_rp</span><span class="p">;</span>
	<span class="n">Sg_request</span> <span class="o">*</span><span class="n">rp</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">iflags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">res</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="o">!</span><span class="n">sfp</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="o">!</span><span class="n">srp</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="o">!</span><span class="n">sfp</span><span class="o">-&gt;</span><span class="n">headrp</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">res</span><span class="p">;</span>
	<span class="n">write_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sfp</span><span class="o">-&gt;</span><span class="n">rq_list_lock</span><span class="p">,</span> <span class="n">iflags</span><span class="p">);</span>
	<span class="n">prev_rp</span> <span class="o">=</span> <span class="n">sfp</span><span class="o">-&gt;</span><span class="n">headrp</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">srp</span> <span class="o">==</span> <span class="n">prev_rp</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">sfp</span><span class="o">-&gt;</span><span class="n">headrp</span> <span class="o">=</span> <span class="n">prev_rp</span><span class="o">-&gt;</span><span class="n">nextrp</span><span class="p">;</span>
		<span class="n">prev_rp</span><span class="o">-&gt;</span><span class="n">parentfp</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">res</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">while</span> <span class="p">((</span><span class="n">rp</span> <span class="o">=</span> <span class="n">prev_rp</span><span class="o">-&gt;</span><span class="n">nextrp</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">srp</span> <span class="o">==</span> <span class="n">rp</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">prev_rp</span><span class="o">-&gt;</span><span class="n">nextrp</span> <span class="o">=</span> <span class="n">rp</span><span class="o">-&gt;</span><span class="n">nextrp</span><span class="p">;</span>
				<span class="n">rp</span><span class="o">-&gt;</span><span class="n">parentfp</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
				<span class="n">res</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">prev_rp</span> <span class="o">=</span> <span class="n">rp</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">write_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sfp</span><span class="o">-&gt;</span><span class="n">rq_list_lock</span><span class="p">,</span> <span class="n">iflags</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">res</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">Sg_fd</span> <span class="o">*</span>
<span class="nf">sg_add_sfp</span><span class="p">(</span><span class="n">Sg_device</span> <span class="o">*</span> <span class="n">sdp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">Sg_fd</span> <span class="o">*</span><span class="n">sfp</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">iflags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">bufflen</span><span class="p">;</span>

	<span class="n">sfp</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">sfp</span><span class="p">),</span> <span class="n">GFP_ATOMIC</span> <span class="o">|</span> <span class="n">__GFP_NOWARN</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sfp</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">init_waitqueue_head</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sfp</span><span class="o">-&gt;</span><span class="n">read_wait</span><span class="p">);</span>
	<span class="n">rwlock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sfp</span><span class="o">-&gt;</span><span class="n">rq_list_lock</span><span class="p">);</span>

	<span class="n">kref_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sfp</span><span class="o">-&gt;</span><span class="n">f_ref</span><span class="p">);</span>
	<span class="n">sfp</span><span class="o">-&gt;</span><span class="n">timeout</span> <span class="o">=</span> <span class="n">SG_DEFAULT_TIMEOUT</span><span class="p">;</span>
	<span class="n">sfp</span><span class="o">-&gt;</span><span class="n">timeout_user</span> <span class="o">=</span> <span class="n">SG_DEFAULT_TIMEOUT_USER</span><span class="p">;</span>
	<span class="n">sfp</span><span class="o">-&gt;</span><span class="n">force_packid</span> <span class="o">=</span> <span class="n">SG_DEF_FORCE_PACK_ID</span><span class="p">;</span>
	<span class="n">sfp</span><span class="o">-&gt;</span><span class="n">low_dma</span> <span class="o">=</span> <span class="p">(</span><span class="n">SG_DEF_FORCE_LOW_DMA</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">?</span>
	    <span class="n">sdp</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">unchecked_isa_dma</span> <span class="o">:</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">sfp</span><span class="o">-&gt;</span><span class="n">cmd_q</span> <span class="o">=</span> <span class="n">SG_DEF_COMMAND_Q</span><span class="p">;</span>
	<span class="n">sfp</span><span class="o">-&gt;</span><span class="n">keep_orphan</span> <span class="o">=</span> <span class="n">SG_DEF_KEEP_ORPHAN</span><span class="p">;</span>
	<span class="n">sfp</span><span class="o">-&gt;</span><span class="n">parentdp</span> <span class="o">=</span> <span class="n">sdp</span><span class="p">;</span>
	<span class="n">write_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sg_index_lock</span><span class="p">,</span> <span class="n">iflags</span><span class="p">);</span>
	<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sfp</span><span class="o">-&gt;</span><span class="n">sfd_siblings</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sdp</span><span class="o">-&gt;</span><span class="n">sfds</span><span class="p">);</span>
	<span class="n">write_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sg_index_lock</span><span class="p">,</span> <span class="n">iflags</span><span class="p">);</span>
	<span class="n">SCSI_LOG_TIMEOUT</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">printk</span><span class="p">(</span><span class="s">&quot;sg_add_sfp: sfp=0x%p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">sfp</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">sg_big_buff</span> <span class="o">!=</span> <span class="n">def_reserved_size</span><span class="p">))</span>
		<span class="n">sg_big_buff</span> <span class="o">=</span> <span class="n">def_reserved_size</span><span class="p">;</span>

	<span class="n">bufflen</span> <span class="o">=</span> <span class="n">min_t</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="n">sg_big_buff</span><span class="p">,</span>
			<span class="n">queue_max_sectors</span><span class="p">(</span><span class="n">sdp</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">request_queue</span><span class="p">)</span> <span class="o">*</span> <span class="mi">512</span><span class="p">);</span>
	<span class="n">sg_build_reserve</span><span class="p">(</span><span class="n">sfp</span><span class="p">,</span> <span class="n">bufflen</span><span class="p">);</span>
	<span class="n">SCSI_LOG_TIMEOUT</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">printk</span><span class="p">(</span><span class="s">&quot;sg_add_sfp:   bufflen=%d, k_use_sg=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			   <span class="n">sfp</span><span class="o">-&gt;</span><span class="n">reserve</span><span class="p">.</span><span class="n">bufflen</span><span class="p">,</span> <span class="n">sfp</span><span class="o">-&gt;</span><span class="n">reserve</span><span class="p">.</span><span class="n">k_use_sg</span><span class="p">));</span>

	<span class="n">kref_get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sdp</span><span class="o">-&gt;</span><span class="n">d_ref</span><span class="p">);</span>
	<span class="n">__module_get</span><span class="p">(</span><span class="n">THIS_MODULE</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">sfp</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">sg_remove_sfp_usercontext</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sg_fd</span> <span class="o">*</span><span class="n">sfp</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">work</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sg_fd</span><span class="p">,</span> <span class="n">ew</span><span class="p">.</span><span class="n">work</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">sg_device</span> <span class="o">*</span><span class="n">sdp</span> <span class="o">=</span> <span class="n">sfp</span><span class="o">-&gt;</span><span class="n">parentdp</span><span class="p">;</span>

	<span class="cm">/* Cleanup any responses which were never read(). */</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">sfp</span><span class="o">-&gt;</span><span class="n">headrp</span><span class="p">)</span>
		<span class="n">sg_finish_rem_req</span><span class="p">(</span><span class="n">sfp</span><span class="o">-&gt;</span><span class="n">headrp</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sfp</span><span class="o">-&gt;</span><span class="n">reserve</span><span class="p">.</span><span class="n">bufflen</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">SCSI_LOG_TIMEOUT</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span>
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot;sg_remove_sfp:    bufflen=%d, k_use_sg=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="n">sfp</span><span class="o">-&gt;</span><span class="n">reserve</span><span class="p">.</span><span class="n">bufflen</span><span class="p">,</span>
				<span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="n">sfp</span><span class="o">-&gt;</span><span class="n">reserve</span><span class="p">.</span><span class="n">k_use_sg</span><span class="p">));</span>
		<span class="n">sg_remove_scat</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sfp</span><span class="o">-&gt;</span><span class="n">reserve</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">SCSI_LOG_TIMEOUT</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;sg_remove_sfp: %s, sfp=0x%p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">sdp</span><span class="o">-&gt;</span><span class="n">disk</span><span class="o">-&gt;</span><span class="n">disk_name</span><span class="p">,</span>
			<span class="n">sfp</span><span class="p">));</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">sfp</span><span class="p">);</span>

	<span class="n">scsi_device_put</span><span class="p">(</span><span class="n">sdp</span><span class="o">-&gt;</span><span class="n">device</span><span class="p">);</span>
	<span class="n">sg_put_dev</span><span class="p">(</span><span class="n">sdp</span><span class="p">);</span>
	<span class="n">module_put</span><span class="p">(</span><span class="n">THIS_MODULE</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">sg_remove_sfp</span><span class="p">(</span><span class="k">struct</span> <span class="n">kref</span> <span class="o">*</span><span class="n">kref</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sg_fd</span> <span class="o">*</span><span class="n">sfp</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">kref</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sg_fd</span><span class="p">,</span> <span class="n">f_ref</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">sg_device</span> <span class="o">*</span><span class="n">sdp</span> <span class="o">=</span> <span class="n">sfp</span><span class="o">-&gt;</span><span class="n">parentdp</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">iflags</span><span class="p">;</span>

	<span class="n">write_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sg_index_lock</span><span class="p">,</span> <span class="n">iflags</span><span class="p">);</span>
	<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sfp</span><span class="o">-&gt;</span><span class="n">sfd_siblings</span><span class="p">);</span>
	<span class="n">write_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sg_index_lock</span><span class="p">,</span> <span class="n">iflags</span><span class="p">);</span>
	<span class="n">wake_up_interruptible</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sdp</span><span class="o">-&gt;</span><span class="n">o_excl_wait</span><span class="p">);</span>

	<span class="n">INIT_WORK</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sfp</span><span class="o">-&gt;</span><span class="n">ew</span><span class="p">.</span><span class="n">work</span><span class="p">,</span> <span class="n">sg_remove_sfp_usercontext</span><span class="p">);</span>
	<span class="n">schedule_work</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sfp</span><span class="o">-&gt;</span><span class="n">ew</span><span class="p">.</span><span class="n">work</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">sg_res_in_use</span><span class="p">(</span><span class="n">Sg_fd</span> <span class="o">*</span> <span class="n">sfp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="n">Sg_request</span> <span class="o">*</span><span class="n">srp</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">iflags</span><span class="p">;</span>

	<span class="n">read_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sfp</span><span class="o">-&gt;</span><span class="n">rq_list_lock</span><span class="p">,</span> <span class="n">iflags</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">srp</span> <span class="o">=</span> <span class="n">sfp</span><span class="o">-&gt;</span><span class="n">headrp</span><span class="p">;</span> <span class="n">srp</span><span class="p">;</span> <span class="n">srp</span> <span class="o">=</span> <span class="n">srp</span><span class="o">-&gt;</span><span class="n">nextrp</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">srp</span><span class="o">-&gt;</span><span class="n">res_used</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="n">read_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sfp</span><span class="o">-&gt;</span><span class="n">rq_list_lock</span><span class="p">,</span> <span class="n">iflags</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">srp</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_SCSI_PROC_FS</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">sg_idr_max_id</span><span class="p">(</span><span class="kt">int</span> <span class="n">id</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="o">*</span><span class="n">k</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">k</span> <span class="o">&lt;</span> <span class="n">id</span><span class="p">)</span>
		<span class="o">*</span><span class="n">k</span> <span class="o">=</span> <span class="n">id</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">sg_last_dev</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">iflags</span><span class="p">;</span>

	<span class="n">read_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sg_index_lock</span><span class="p">,</span> <span class="n">iflags</span><span class="p">);</span>
	<span class="n">idr_for_each</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sg_index_idr</span><span class="p">,</span> <span class="n">sg_idr_max_id</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">k</span><span class="p">);</span>
	<span class="n">read_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sg_index_lock</span><span class="p">,</span> <span class="n">iflags</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>		<span class="cm">/* origin 1 */</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="cm">/* must be called with sg_index_lock held */</span>
<span class="k">static</span> <span class="n">Sg_device</span> <span class="o">*</span><span class="nf">sg_lookup_dev</span><span class="p">(</span><span class="kt">int</span> <span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">idr_find</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sg_index_idr</span><span class="p">,</span> <span class="n">dev</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">Sg_device</span> <span class="o">*</span><span class="nf">sg_get_dev</span><span class="p">(</span><span class="kt">int</span> <span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sg_device</span> <span class="o">*</span><span class="n">sdp</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">read_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sg_index_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">sdp</span> <span class="o">=</span> <span class="n">sg_lookup_dev</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sdp</span><span class="p">)</span>
		<span class="n">sdp</span> <span class="o">=</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">ENXIO</span><span class="p">);</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">sdp</span><span class="o">-&gt;</span><span class="n">detached</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* If sdp-&gt;detached, then the refcount may already be 0, in</span>
<span class="cm">		 * which case it would be a bug to do kref_get().</span>
<span class="cm">		 */</span>
		<span class="n">sdp</span> <span class="o">=</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">ENODEV</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">kref_get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sdp</span><span class="o">-&gt;</span><span class="n">d_ref</span><span class="p">);</span>
	<span class="n">read_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sg_index_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">sdp</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">sg_put_dev</span><span class="p">(</span><span class="k">struct</span> <span class="n">sg_device</span> <span class="o">*</span><span class="n">sdp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">kref_put</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sdp</span><span class="o">-&gt;</span><span class="n">d_ref</span><span class="p">,</span> <span class="n">sg_device_destroy</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_SCSI_PROC_FS</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">proc_dir_entry</span> <span class="o">*</span><span class="n">sg_proc_sgp</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">char</span> <span class="n">sg_proc_sg_dirname</span><span class="p">[]</span> <span class="o">=</span> <span class="s">&quot;scsi/sg&quot;</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">sg_proc_seq_show_int</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">v</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">sg_proc_single_open_adio</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">ssize_t</span> <span class="n">sg_proc_write_adio</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span>
			          <span class="kt">size_t</span> <span class="n">count</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">off</span><span class="p">);</span>
<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">adio_fops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">owner</span> <span class="o">=</span> <span class="n">THIS_MODULE</span><span class="p">,</span>
	<span class="p">.</span><span class="n">open</span> <span class="o">=</span> <span class="n">sg_proc_single_open_adio</span><span class="p">,</span>
	<span class="p">.</span><span class="n">read</span> <span class="o">=</span> <span class="n">seq_read</span><span class="p">,</span>
	<span class="p">.</span><span class="n">llseek</span> <span class="o">=</span> <span class="n">seq_lseek</span><span class="p">,</span>
	<span class="p">.</span><span class="n">write</span> <span class="o">=</span> <span class="n">sg_proc_write_adio</span><span class="p">,</span>
	<span class="p">.</span><span class="n">release</span> <span class="o">=</span> <span class="n">single_release</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">sg_proc_single_open_dressz</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">ssize_t</span> <span class="n">sg_proc_write_dressz</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span> 
		<span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">count</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">off</span><span class="p">);</span>
<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">dressz_fops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">owner</span> <span class="o">=</span> <span class="n">THIS_MODULE</span><span class="p">,</span>
	<span class="p">.</span><span class="n">open</span> <span class="o">=</span> <span class="n">sg_proc_single_open_dressz</span><span class="p">,</span>
	<span class="p">.</span><span class="n">read</span> <span class="o">=</span> <span class="n">seq_read</span><span class="p">,</span>
	<span class="p">.</span><span class="n">llseek</span> <span class="o">=</span> <span class="n">seq_lseek</span><span class="p">,</span>
	<span class="p">.</span><span class="n">write</span> <span class="o">=</span> <span class="n">sg_proc_write_dressz</span><span class="p">,</span>
	<span class="p">.</span><span class="n">release</span> <span class="o">=</span> <span class="n">single_release</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">sg_proc_seq_show_version</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">v</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">sg_proc_single_open_version</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">);</span>
<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">version_fops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">owner</span> <span class="o">=</span> <span class="n">THIS_MODULE</span><span class="p">,</span>
	<span class="p">.</span><span class="n">open</span> <span class="o">=</span> <span class="n">sg_proc_single_open_version</span><span class="p">,</span>
	<span class="p">.</span><span class="n">read</span> <span class="o">=</span> <span class="n">seq_read</span><span class="p">,</span>
	<span class="p">.</span><span class="n">llseek</span> <span class="o">=</span> <span class="n">seq_lseek</span><span class="p">,</span>
	<span class="p">.</span><span class="n">release</span> <span class="o">=</span> <span class="n">single_release</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">sg_proc_seq_show_devhdr</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">v</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">sg_proc_single_open_devhdr</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">);</span>
<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">devhdr_fops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">owner</span> <span class="o">=</span> <span class="n">THIS_MODULE</span><span class="p">,</span>
	<span class="p">.</span><span class="n">open</span> <span class="o">=</span> <span class="n">sg_proc_single_open_devhdr</span><span class="p">,</span>
	<span class="p">.</span><span class="n">read</span> <span class="o">=</span> <span class="n">seq_read</span><span class="p">,</span>
	<span class="p">.</span><span class="n">llseek</span> <span class="o">=</span> <span class="n">seq_lseek</span><span class="p">,</span>
	<span class="p">.</span><span class="n">release</span> <span class="o">=</span> <span class="n">single_release</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">sg_proc_seq_show_dev</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">v</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">sg_proc_open_dev</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="o">*</span> <span class="n">dev_seq_start</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">pos</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="o">*</span> <span class="n">dev_seq_next</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">v</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">pos</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">dev_seq_stop</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">v</span><span class="p">);</span>
<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">dev_fops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">owner</span> <span class="o">=</span> <span class="n">THIS_MODULE</span><span class="p">,</span>
	<span class="p">.</span><span class="n">open</span> <span class="o">=</span> <span class="n">sg_proc_open_dev</span><span class="p">,</span>
	<span class="p">.</span><span class="n">read</span> <span class="o">=</span> <span class="n">seq_read</span><span class="p">,</span>
	<span class="p">.</span><span class="n">llseek</span> <span class="o">=</span> <span class="n">seq_lseek</span><span class="p">,</span>
	<span class="p">.</span><span class="n">release</span> <span class="o">=</span> <span class="n">seq_release</span><span class="p">,</span>
<span class="p">};</span>
<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">seq_operations</span> <span class="n">dev_seq_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">start</span> <span class="o">=</span> <span class="n">dev_seq_start</span><span class="p">,</span>
	<span class="p">.</span><span class="n">next</span>  <span class="o">=</span> <span class="n">dev_seq_next</span><span class="p">,</span>
	<span class="p">.</span><span class="n">stop</span>  <span class="o">=</span> <span class="n">dev_seq_stop</span><span class="p">,</span>
	<span class="p">.</span><span class="n">show</span>  <span class="o">=</span> <span class="n">sg_proc_seq_show_dev</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">sg_proc_seq_show_devstrs</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">v</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">sg_proc_open_devstrs</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">);</span>
<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">devstrs_fops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">owner</span> <span class="o">=</span> <span class="n">THIS_MODULE</span><span class="p">,</span>
	<span class="p">.</span><span class="n">open</span> <span class="o">=</span> <span class="n">sg_proc_open_devstrs</span><span class="p">,</span>
	<span class="p">.</span><span class="n">read</span> <span class="o">=</span> <span class="n">seq_read</span><span class="p">,</span>
	<span class="p">.</span><span class="n">llseek</span> <span class="o">=</span> <span class="n">seq_lseek</span><span class="p">,</span>
	<span class="p">.</span><span class="n">release</span> <span class="o">=</span> <span class="n">seq_release</span><span class="p">,</span>
<span class="p">};</span>
<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">seq_operations</span> <span class="n">devstrs_seq_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">start</span> <span class="o">=</span> <span class="n">dev_seq_start</span><span class="p">,</span>
	<span class="p">.</span><span class="n">next</span>  <span class="o">=</span> <span class="n">dev_seq_next</span><span class="p">,</span>
	<span class="p">.</span><span class="n">stop</span>  <span class="o">=</span> <span class="n">dev_seq_stop</span><span class="p">,</span>
	<span class="p">.</span><span class="n">show</span>  <span class="o">=</span> <span class="n">sg_proc_seq_show_devstrs</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">sg_proc_seq_show_debug</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">v</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">sg_proc_open_debug</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">);</span>
<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">debug_fops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">owner</span> <span class="o">=</span> <span class="n">THIS_MODULE</span><span class="p">,</span>
	<span class="p">.</span><span class="n">open</span> <span class="o">=</span> <span class="n">sg_proc_open_debug</span><span class="p">,</span>
	<span class="p">.</span><span class="n">read</span> <span class="o">=</span> <span class="n">seq_read</span><span class="p">,</span>
	<span class="p">.</span><span class="n">llseek</span> <span class="o">=</span> <span class="n">seq_lseek</span><span class="p">,</span>
	<span class="p">.</span><span class="n">release</span> <span class="o">=</span> <span class="n">seq_release</span><span class="p">,</span>
<span class="p">};</span>
<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">seq_operations</span> <span class="n">debug_seq_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">start</span> <span class="o">=</span> <span class="n">dev_seq_start</span><span class="p">,</span>
	<span class="p">.</span><span class="n">next</span>  <span class="o">=</span> <span class="n">dev_seq_next</span><span class="p">,</span>
	<span class="p">.</span><span class="n">stop</span>  <span class="o">=</span> <span class="n">dev_seq_stop</span><span class="p">,</span>
	<span class="p">.</span><span class="n">show</span>  <span class="o">=</span> <span class="n">sg_proc_seq_show_debug</span><span class="p">,</span>
<span class="p">};</span>


<span class="k">struct</span> <span class="n">sg_proc_leaf</span> <span class="p">{</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">name</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="o">*</span> <span class="n">fops</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">sg_proc_leaf</span> <span class="n">sg_proc_leaf_arr</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">{</span><span class="s">&quot;allow_dio&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">adio_fops</span><span class="p">},</span>
	<span class="p">{</span><span class="s">&quot;debug&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">debug_fops</span><span class="p">},</span>
	<span class="p">{</span><span class="s">&quot;def_reserved_size&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dressz_fops</span><span class="p">},</span>
	<span class="p">{</span><span class="s">&quot;device_hdr&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">devhdr_fops</span><span class="p">},</span>
	<span class="p">{</span><span class="s">&quot;devices&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dev_fops</span><span class="p">},</span>
	<span class="p">{</span><span class="s">&quot;device_strs&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">devstrs_fops</span><span class="p">},</span>
	<span class="p">{</span><span class="s">&quot;version&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">version_fops</span><span class="p">}</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">sg_proc_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">num_leaves</span> <span class="o">=</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">sg_proc_leaf_arr</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">k</span><span class="p">;</span>

	<span class="n">sg_proc_sgp</span> <span class="o">=</span> <span class="n">proc_mkdir</span><span class="p">(</span><span class="n">sg_proc_sg_dirname</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sg_proc_sgp</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">k</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="n">num_leaves</span><span class="p">;</span> <span class="o">++</span><span class="n">k</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">const</span> <span class="k">struct</span> <span class="n">sg_proc_leaf</span> <span class="o">*</span><span class="n">leaf</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">sg_proc_leaf_arr</span><span class="p">[</span><span class="n">k</span><span class="p">];</span>
		<span class="n">umode_t</span> <span class="n">mask</span> <span class="o">=</span> <span class="n">leaf</span><span class="o">-&gt;</span><span class="n">fops</span><span class="o">-&gt;</span><span class="n">write</span> <span class="o">?</span> <span class="n">S_IRUGO</span> <span class="o">|</span> <span class="n">S_IWUSR</span> <span class="o">:</span> <span class="n">S_IRUGO</span><span class="p">;</span>
		<span class="n">proc_create</span><span class="p">(</span><span class="n">leaf</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="n">sg_proc_sgp</span><span class="p">,</span> <span class="n">leaf</span><span class="o">-&gt;</span><span class="n">fops</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">sg_proc_cleanup</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">k</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">num_leaves</span> <span class="o">=</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">sg_proc_leaf_arr</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sg_proc_sgp</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">k</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="n">num_leaves</span><span class="p">;</span> <span class="o">++</span><span class="n">k</span><span class="p">)</span>
		<span class="n">remove_proc_entry</span><span class="p">(</span><span class="n">sg_proc_leaf_arr</span><span class="p">[</span><span class="n">k</span><span class="p">].</span><span class="n">name</span><span class="p">,</span> <span class="n">sg_proc_sgp</span><span class="p">);</span>
	<span class="n">remove_proc_entry</span><span class="p">(</span><span class="n">sg_proc_sg_dirname</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">int</span> <span class="nf">sg_proc_seq_show_int</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">v</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">seq_printf</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="o">*</span><span class="p">((</span><span class="kt">int</span> <span class="o">*</span><span class="p">)</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">private</span><span class="p">));</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">sg_proc_single_open_adio</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">single_open</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">sg_proc_seq_show_int</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sg_allow_dio</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span> 
<span class="nf">sg_proc_write_adio</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span>
		   <span class="kt">size_t</span> <span class="n">count</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">off</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">num</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">capable</span><span class="p">(</span><span class="n">CAP_SYS_ADMIN</span><span class="p">)</span> <span class="o">||</span> <span class="o">!</span><span class="n">capable</span><span class="p">(</span><span class="n">CAP_SYS_RAWIO</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EACCES</span><span class="p">;</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">kstrtoul_from_user</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="n">count</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">num</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
	<span class="n">sg_allow_dio</span> <span class="o">=</span> <span class="n">num</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">count</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">sg_proc_single_open_dressz</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">single_open</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">sg_proc_seq_show_int</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sg_big_buff</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span> 
<span class="nf">sg_proc_write_dressz</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span>
		     <span class="kt">size_t</span> <span class="n">count</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">off</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">k</span> <span class="o">=</span> <span class="n">ULONG_MAX</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">capable</span><span class="p">(</span><span class="n">CAP_SYS_ADMIN</span><span class="p">)</span> <span class="o">||</span> <span class="o">!</span><span class="n">capable</span><span class="p">(</span><span class="n">CAP_SYS_RAWIO</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EACCES</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">kstrtoul_from_user</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="n">count</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">k</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">k</span> <span class="o">&lt;=</span> <span class="mi">1048576</span><span class="p">)</span> <span class="p">{</span>	<span class="cm">/* limit &quot;big buff&quot; to 1 MB */</span>
		<span class="n">sg_big_buff</span> <span class="o">=</span> <span class="n">k</span><span class="p">;</span>
		<span class="k">return</span> <span class="n">count</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">ERANGE</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">sg_proc_seq_show_version</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">v</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">seq_printf</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">&quot;%d</span><span class="se">\t</span><span class="s">%s [%s]</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">sg_version_num</span><span class="p">,</span> <span class="n">SG_VERSION_STR</span><span class="p">,</span>
		   <span class="n">sg_version_date</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">sg_proc_single_open_version</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">single_open</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">sg_proc_seq_show_version</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">sg_proc_seq_show_devhdr</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">v</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">seq_printf</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">&quot;host</span><span class="se">\t</span><span class="s">chan</span><span class="se">\t</span><span class="s">id</span><span class="se">\t</span><span class="s">lun</span><span class="se">\t</span><span class="s">type</span><span class="se">\t</span><span class="s">opens</span><span class="se">\t</span><span class="s">qdepth</span><span class="se">\t</span><span class="s">busy</span><span class="se">\t</span><span class="s">&quot;</span>
		   <span class="s">&quot;online</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">sg_proc_single_open_devhdr</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">single_open</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">sg_proc_seq_show_devhdr</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">sg_proc_deviter</span> <span class="p">{</span>
	<span class="n">loff_t</span>	<span class="n">index</span><span class="p">;</span>
	<span class="kt">size_t</span>	<span class="n">max</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">void</span> <span class="o">*</span> <span class="nf">dev_seq_start</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">pos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sg_proc_deviter</span> <span class="o">*</span> <span class="n">it</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">it</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>

	<span class="n">s</span><span class="o">-&gt;</span><span class="n">private</span> <span class="o">=</span> <span class="n">it</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span> <span class="n">it</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">it</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">=</span> <span class="o">*</span><span class="n">pos</span><span class="p">;</span>
	<span class="n">it</span><span class="o">-&gt;</span><span class="n">max</span> <span class="o">=</span> <span class="n">sg_last_dev</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">it</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">&gt;=</span> <span class="n">it</span><span class="o">-&gt;</span><span class="n">max</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">it</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="o">*</span> <span class="nf">dev_seq_next</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">v</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">pos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sg_proc_deviter</span> <span class="o">*</span> <span class="n">it</span> <span class="o">=</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">private</span><span class="p">;</span>

	<span class="o">*</span><span class="n">pos</span> <span class="o">=</span> <span class="o">++</span><span class="n">it</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">;</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">it</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">&lt;</span> <span class="n">it</span><span class="o">-&gt;</span><span class="n">max</span><span class="p">)</span> <span class="o">?</span> <span class="n">it</span> <span class="o">:</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">dev_seq_stop</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">v</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">private</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">sg_proc_open_dev</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">)</span>
<span class="p">{</span>
        <span class="k">return</span> <span class="n">seq_open</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dev_seq_ops</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">sg_proc_seq_show_dev</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">v</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sg_proc_deviter</span> <span class="o">*</span> <span class="n">it</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sg_proc_deviter</span> <span class="o">*</span><span class="p">)</span> <span class="n">v</span><span class="p">;</span>
	<span class="n">Sg_device</span> <span class="o">*</span><span class="n">sdp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="n">scsidp</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">iflags</span><span class="p">;</span>

	<span class="n">read_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sg_index_lock</span><span class="p">,</span> <span class="n">iflags</span><span class="p">);</span>
	<span class="n">sdp</span> <span class="o">=</span> <span class="n">it</span> <span class="o">?</span> <span class="n">sg_lookup_dev</span><span class="p">(</span><span class="n">it</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">)</span> <span class="o">:</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sdp</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">scsidp</span> <span class="o">=</span> <span class="n">sdp</span><span class="o">-&gt;</span><span class="n">device</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="o">!</span><span class="n">sdp</span><span class="o">-&gt;</span><span class="n">detached</span><span class="p">))</span>
		<span class="n">seq_printf</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">&quot;%d</span><span class="se">\t</span><span class="s">%d</span><span class="se">\t</span><span class="s">%d</span><span class="se">\t</span><span class="s">%d</span><span class="se">\t</span><span class="s">%d</span><span class="se">\t</span><span class="s">%d</span><span class="se">\t</span><span class="s">%d</span><span class="se">\t</span><span class="s">%d</span><span class="se">\t</span><span class="s">%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			      <span class="n">scsidp</span><span class="o">-&gt;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">host_no</span><span class="p">,</span> <span class="n">scsidp</span><span class="o">-&gt;</span><span class="n">channel</span><span class="p">,</span>
			      <span class="n">scsidp</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">,</span> <span class="n">scsidp</span><span class="o">-&gt;</span><span class="n">lun</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="n">scsidp</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">,</span>
			      <span class="mi">1</span><span class="p">,</span>
			      <span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="n">scsidp</span><span class="o">-&gt;</span><span class="n">queue_depth</span><span class="p">,</span>
			      <span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="n">scsidp</span><span class="o">-&gt;</span><span class="n">device_busy</span><span class="p">,</span>
			      <span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="n">scsi_device_online</span><span class="p">(</span><span class="n">scsidp</span><span class="p">));</span>
	<span class="k">else</span>
		<span class="n">seq_printf</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">&quot;-1</span><span class="se">\t</span><span class="s">-1</span><span class="se">\t</span><span class="s">-1</span><span class="se">\t</span><span class="s">-1</span><span class="se">\t</span><span class="s">-1</span><span class="se">\t</span><span class="s">-1</span><span class="se">\t</span><span class="s">-1</span><span class="se">\t</span><span class="s">-1</span><span class="se">\t</span><span class="s">-1</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">read_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sg_index_lock</span><span class="p">,</span> <span class="n">iflags</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">sg_proc_open_devstrs</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">)</span>
<span class="p">{</span>
        <span class="k">return</span> <span class="n">seq_open</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">devstrs_seq_ops</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">sg_proc_seq_show_devstrs</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">v</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sg_proc_deviter</span> <span class="o">*</span> <span class="n">it</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sg_proc_deviter</span> <span class="o">*</span><span class="p">)</span> <span class="n">v</span><span class="p">;</span>
	<span class="n">Sg_device</span> <span class="o">*</span><span class="n">sdp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="n">scsidp</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">iflags</span><span class="p">;</span>

	<span class="n">read_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sg_index_lock</span><span class="p">,</span> <span class="n">iflags</span><span class="p">);</span>
	<span class="n">sdp</span> <span class="o">=</span> <span class="n">it</span> <span class="o">?</span> <span class="n">sg_lookup_dev</span><span class="p">(</span><span class="n">it</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">)</span> <span class="o">:</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sdp</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">scsidp</span> <span class="o">=</span> <span class="n">sdp</span><span class="o">-&gt;</span><span class="n">device</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="o">!</span><span class="n">sdp</span><span class="o">-&gt;</span><span class="n">detached</span><span class="p">))</span>
		<span class="n">seq_printf</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">&quot;%8.8s</span><span class="se">\t</span><span class="s">%16.16s</span><span class="se">\t</span><span class="s">%4.4s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			   <span class="n">scsidp</span><span class="o">-&gt;</span><span class="n">vendor</span><span class="p">,</span> <span class="n">scsidp</span><span class="o">-&gt;</span><span class="n">model</span><span class="p">,</span> <span class="n">scsidp</span><span class="o">-&gt;</span><span class="n">rev</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">seq_printf</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">&quot;&lt;no active device&gt;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">read_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sg_index_lock</span><span class="p">,</span> <span class="n">iflags</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* must be called while holding sg_index_lock */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">sg_proc_debug_helper</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="n">Sg_device</span> <span class="o">*</span> <span class="n">sdp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">k</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">new_interface</span><span class="p">,</span> <span class="n">blen</span><span class="p">,</span> <span class="n">usg</span><span class="p">;</span>
	<span class="n">Sg_request</span> <span class="o">*</span><span class="n">srp</span><span class="p">;</span>
	<span class="n">Sg_fd</span> <span class="o">*</span><span class="n">fp</span><span class="p">;</span>
	<span class="k">const</span> <span class="n">sg_io_hdr_t</span> <span class="o">*</span><span class="n">hp</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">cp</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ms</span><span class="p">;</span>

	<span class="n">k</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">fp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sdp</span><span class="o">-&gt;</span><span class="n">sfds</span><span class="p">,</span> <span class="n">sfd_siblings</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">k</span><span class="o">++</span><span class="p">;</span>
		<span class="n">read_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fp</span><span class="o">-&gt;</span><span class="n">rq_list_lock</span><span class="p">);</span> <span class="cm">/* irqs already disabled */</span>
		<span class="n">seq_printf</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">&quot;   FD(%d): timeout=%dms bufflen=%d &quot;</span>
			   <span class="s">&quot;(res)sgat=%d low_dma=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span>
			   <span class="n">jiffies_to_msecs</span><span class="p">(</span><span class="n">fp</span><span class="o">-&gt;</span><span class="n">timeout</span><span class="p">),</span>
			   <span class="n">fp</span><span class="o">-&gt;</span><span class="n">reserve</span><span class="p">.</span><span class="n">bufflen</span><span class="p">,</span>
			   <span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="n">fp</span><span class="o">-&gt;</span><span class="n">reserve</span><span class="p">.</span><span class="n">k_use_sg</span><span class="p">,</span>
			   <span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="n">fp</span><span class="o">-&gt;</span><span class="n">low_dma</span><span class="p">);</span>
		<span class="n">seq_printf</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">&quot;   cmd_q=%d f_packid=%d k_orphan=%d closed=0</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			   <span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="n">fp</span><span class="o">-&gt;</span><span class="n">cmd_q</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="n">fp</span><span class="o">-&gt;</span><span class="n">force_packid</span><span class="p">,</span>
			   <span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="n">fp</span><span class="o">-&gt;</span><span class="n">keep_orphan</span><span class="p">);</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">m</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">srp</span> <span class="o">=</span> <span class="n">fp</span><span class="o">-&gt;</span><span class="n">headrp</span><span class="p">;</span>
				<span class="n">srp</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">;</span>
				<span class="o">++</span><span class="n">m</span><span class="p">,</span> <span class="n">srp</span> <span class="o">=</span> <span class="n">srp</span><span class="o">-&gt;</span><span class="n">nextrp</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">hp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">srp</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">;</span>
			<span class="n">new_interface</span> <span class="o">=</span> <span class="p">(</span><span class="n">hp</span><span class="o">-&gt;</span><span class="n">interface_id</span> <span class="o">==</span> <span class="sc">&#39;\0&#39;</span><span class="p">)</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">srp</span><span class="o">-&gt;</span><span class="n">res_used</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">new_interface</span> <span class="o">&amp;&amp;</span> 
				    <span class="p">(</span><span class="n">SG_FLAG_MMAP_IO</span> <span class="o">&amp;</span> <span class="n">hp</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">))</span>
					<span class="n">cp</span> <span class="o">=</span> <span class="s">&quot;     mmap&gt;&gt; &quot;</span><span class="p">;</span>
				<span class="k">else</span>
					<span class="n">cp</span> <span class="o">=</span> <span class="s">&quot;     rb&gt;&gt; &quot;</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">SG_INFO_DIRECT_IO_MASK</span> <span class="o">&amp;</span> <span class="n">hp</span><span class="o">-&gt;</span><span class="n">info</span><span class="p">)</span>
					<span class="n">cp</span> <span class="o">=</span> <span class="s">&quot;     dio&gt;&gt; &quot;</span><span class="p">;</span>
				<span class="k">else</span>
					<span class="n">cp</span> <span class="o">=</span> <span class="s">&quot;     &quot;</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">seq_printf</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">cp</span><span class="p">);</span>
			<span class="n">blen</span> <span class="o">=</span> <span class="n">srp</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">.</span><span class="n">bufflen</span><span class="p">;</span>
			<span class="n">usg</span> <span class="o">=</span> <span class="n">srp</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">.</span><span class="n">k_use_sg</span><span class="p">;</span>
			<span class="n">seq_printf</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">srp</span><span class="o">-&gt;</span><span class="n">done</span> <span class="o">?</span> 
				   <span class="p">((</span><span class="mi">1</span> <span class="o">==</span> <span class="n">srp</span><span class="o">-&gt;</span><span class="n">done</span><span class="p">)</span> <span class="o">?</span>  <span class="s">&quot;rcv:&quot;</span> <span class="o">:</span> <span class="s">&quot;fin:&quot;</span><span class="p">)</span>
				   <span class="o">:</span> <span class="s">&quot;act:&quot;</span><span class="p">);</span>
			<span class="n">seq_printf</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">&quot; id=%d blen=%d&quot;</span><span class="p">,</span>
				   <span class="n">srp</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">pack_id</span><span class="p">,</span> <span class="n">blen</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">srp</span><span class="o">-&gt;</span><span class="n">done</span><span class="p">)</span>
				<span class="n">seq_printf</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">&quot; dur=%d&quot;</span><span class="p">,</span> <span class="n">hp</span><span class="o">-&gt;</span><span class="n">duration</span><span class="p">);</span>
			<span class="k">else</span> <span class="p">{</span>
				<span class="n">ms</span> <span class="o">=</span> <span class="n">jiffies_to_msecs</span><span class="p">(</span><span class="n">jiffies</span><span class="p">);</span>
				<span class="n">seq_printf</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">&quot; t_o/elap=%d/%d&quot;</span><span class="p">,</span>
					<span class="p">(</span><span class="n">new_interface</span> <span class="o">?</span> <span class="n">hp</span><span class="o">-&gt;</span><span class="n">timeout</span> <span class="o">:</span>
						  <span class="n">jiffies_to_msecs</span><span class="p">(</span><span class="n">fp</span><span class="o">-&gt;</span><span class="n">timeout</span><span class="p">)),</span>
					<span class="p">(</span><span class="n">ms</span> <span class="o">&gt;</span> <span class="n">hp</span><span class="o">-&gt;</span><span class="n">duration</span> <span class="o">?</span> <span class="n">ms</span> <span class="o">-</span> <span class="n">hp</span><span class="o">-&gt;</span><span class="n">duration</span> <span class="o">:</span> <span class="mi">0</span><span class="p">));</span>
			<span class="p">}</span>
			<span class="n">seq_printf</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">&quot;ms sgat=%d op=0x%02x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">usg</span><span class="p">,</span>
				   <span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="n">srp</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">.</span><span class="n">cmd_opcode</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="mi">0</span> <span class="o">==</span> <span class="n">m</span><span class="p">)</span>
			<span class="n">seq_printf</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">&quot;     No requests active</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">read_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fp</span><span class="o">-&gt;</span><span class="n">rq_list_lock</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">sg_proc_open_debug</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">)</span>
<span class="p">{</span>
        <span class="k">return</span> <span class="n">seq_open</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">debug_seq_ops</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">sg_proc_seq_show_debug</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">v</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sg_proc_deviter</span> <span class="o">*</span> <span class="n">it</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sg_proc_deviter</span> <span class="o">*</span><span class="p">)</span> <span class="n">v</span><span class="p">;</span>
	<span class="n">Sg_device</span> <span class="o">*</span><span class="n">sdp</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">iflags</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">it</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="mi">0</span> <span class="o">==</span> <span class="n">it</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">seq_printf</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">&quot;max_active_device=%d(origin 1)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			   <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">it</span><span class="o">-&gt;</span><span class="n">max</span><span class="p">);</span>
		<span class="n">seq_printf</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">&quot; def_reserved_size=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">sg_big_buff</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">read_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sg_index_lock</span><span class="p">,</span> <span class="n">iflags</span><span class="p">);</span>
	<span class="n">sdp</span> <span class="o">=</span> <span class="n">it</span> <span class="o">?</span> <span class="n">sg_lookup_dev</span><span class="p">(</span><span class="n">it</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">)</span> <span class="o">:</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sdp</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sdp</span><span class="o">-&gt;</span><span class="n">sfds</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="n">scsidp</span> <span class="o">=</span> <span class="n">sdp</span><span class="o">-&gt;</span><span class="n">device</span><span class="p">;</span>

		<span class="n">seq_printf</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">&quot; &gt;&gt;&gt; device=%s &quot;</span><span class="p">,</span> <span class="n">sdp</span><span class="o">-&gt;</span><span class="n">disk</span><span class="o">-&gt;</span><span class="n">disk_name</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sdp</span><span class="o">-&gt;</span><span class="n">detached</span><span class="p">)</span>
			<span class="n">seq_printf</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">&quot;detached pending close &quot;</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">seq_printf</span>
			    <span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">&quot;scsi%d chan=%d id=%d lun=%d   em=%d&quot;</span><span class="p">,</span>
			     <span class="n">scsidp</span><span class="o">-&gt;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">host_no</span><span class="p">,</span>
			     <span class="n">scsidp</span><span class="o">-&gt;</span><span class="n">channel</span><span class="p">,</span> <span class="n">scsidp</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">,</span>
			     <span class="n">scsidp</span><span class="o">-&gt;</span><span class="n">lun</span><span class="p">,</span>
			     <span class="n">scsidp</span><span class="o">-&gt;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">hostt</span><span class="o">-&gt;</span><span class="n">emulated</span><span class="p">);</span>
		<span class="n">seq_printf</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">&quot; sg_tablesize=%d excl=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			   <span class="n">sdp</span><span class="o">-&gt;</span><span class="n">sg_tablesize</span><span class="p">,</span> <span class="n">get_exclude</span><span class="p">(</span><span class="n">sdp</span><span class="p">));</span>
		<span class="n">sg_proc_debug_helper</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">sdp</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">read_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sg_index_lock</span><span class="p">,</span> <span class="n">iflags</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#endif				</span><span class="cm">/* CONFIG_SCSI_PROC_FS */</span><span class="cp"></span>

<span class="n">module_init</span><span class="p">(</span><span class="n">init_sg</span><span class="p">);</span>
<span class="n">module_exit</span><span class="p">(</span><span class="n">exit_sg</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
