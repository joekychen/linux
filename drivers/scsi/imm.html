<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › scsi › imm.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>imm.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*  Driver for the Iomega MatchMaker parallel port SCSI HBA embedded in </span>
<span class="cm"> * the Iomega ZIP Plus drive</span>
<span class="cm"> * </span>
<span class="cm"> * (c) 1998     David Campbell</span>
<span class="cm"> *</span>
<span class="cm"> * Please note that I live in Perth, Western Australia. GMT+0800</span>
<span class="cm"> */</span>

<span class="cp">#ifndef _IMM_H</span>
<span class="cp">#define _IMM_H</span>

<span class="cp">#define   IMM_VERSION   &quot;2.05 (for Linux 2.4.0)&quot;</span>

<span class="cm">/* </span>
<span class="cm"> * 10 Apr 1998 (Good Friday) - Received EN144302 by email from Iomega.</span>
<span class="cm"> * Scarry thing is the level of support from one of their managers.</span>
<span class="cm"> * The onus is now on us (the developers) to shut up and start coding.</span>
<span class="cm"> *                                              11Apr98 [ 0.10 ]</span>
<span class="cm"> *</span>
<span class="cm"> * --- SNIP ---</span>
<span class="cm"> *</span>
<span class="cm"> * It manages to find the drive which is a good start. Writing data during</span>
<span class="cm"> * data phase is known to be broken (due to requirements of two byte writes).</span>
<span class="cm"> * Removing &quot;Phase&quot; debug messages.</span>
<span class="cm"> *</span>
<span class="cm"> * PS: Took four hours of coding after I bought a drive.</span>
<span class="cm"> *      ANZAC Day (Aus &quot;War Veterans Holiday&quot;)  25Apr98 [ 0.14 ]</span>
<span class="cm"> *</span>
<span class="cm"> * Ten minutes later after a few fixes.... (LITERALLY!!!)</span>
<span class="cm"> * Have mounted disk, copied file, dismounted disk, remount disk, diff file</span>
<span class="cm"> *                    -----  It actually works!!! -----</span>
<span class="cm"> *                                              25Apr98 [ 0.15 ]</span>
<span class="cm"> *</span>
<span class="cm"> * Twenty minutes of mucking around, rearanged the IEEE negotiate mechanism.</span>
<span class="cm"> * Now have byte mode working (only EPP and ECP to go now... :=)</span>
<span class="cm"> *                                              26Apr98 [ 0.16 ]</span>
<span class="cm"> *</span>
<span class="cm"> * Thirty minutes of further coding results in EPP working on my machine.</span>
<span class="cm"> *                                              27Apr98 [ 0.17 ]</span>
<span class="cm"> *</span>
<span class="cm"> * Due to work commitments and inability to get a &quot;true&quot; ECP mode functioning</span>
<span class="cm"> * I have decided to code the parport support into imm.</span>
<span class="cm"> *                                              09Jun98 [ 0.18 ]</span>
<span class="cm"> *</span>
<span class="cm"> * Driver is now out of beta testing.</span>
<span class="cm"> * Support for parport has been added.</span>
<span class="cm"> * Now distributed with the ppa driver.</span>
<span class="cm"> *                                              12Jun98 [ 2.00 ]</span>
<span class="cm"> *</span>
<span class="cm"> * Err.. It appears that imm-2.00 was broken....</span>
<span class="cm"> *                                              18Jun98 [ 2.01 ]</span>
<span class="cm"> *</span>
<span class="cm"> * Patch applied to sync this against the Linux 2.1.x kernel code</span>
<span class="cm"> * Included qboot_zip.sh</span>
<span class="cm"> *                                              21Jun98 [ 2.02 ]</span>
<span class="cm"> *</span>
<span class="cm"> * Other clean ups include the follow changes:</span>
<span class="cm"> *    CONFIG_SCSI_PPA_HAVE_PEDANTIC =&gt; CONFIG_SCSI_IZIP_EPP16</span>
<span class="cm"> *    added CONFIG_SCSI_IZIP_SLOW_CTR option</span>
<span class="cm"> *                                                      [2.03]</span>
<span class="cm"> *  Fix kernel panic on scsi timeout.		20Aug00 [2.04]</span>
<span class="cm"> *</span>
<span class="cm"> *  Avoid io_request_lock problems.</span>
<span class="cm"> *  John Cavan &lt;johncavan@home.com&gt;		16Nov00 [2.05]</span>
<span class="cm"> */</span>
<span class="cm">/* ------ END OF USER CONFIGURABLE PARAMETERS ----- */</span>

<span class="cp">#include  &lt;linux/stddef.h&gt;</span>
<span class="cp">#include  &lt;linux/module.h&gt;</span>
<span class="cp">#include  &lt;linux/kernel.h&gt;</span>
<span class="cp">#include  &lt;linux/ioport.h&gt;</span>
<span class="cp">#include  &lt;linux/delay.h&gt;</span>
<span class="cp">#include  &lt;linux/proc_fs.h&gt;</span>
<span class="cp">#include  &lt;linux/stat.h&gt;</span>
<span class="cp">#include  &lt;linux/blkdev.h&gt;</span>
<span class="cp">#include  &lt;linux/sched.h&gt;</span>
<span class="cp">#include  &lt;linux/interrupt.h&gt;</span>

<span class="cp">#include  &lt;asm/io.h&gt;</span>
<span class="cp">#include  &lt;scsi/scsi_host.h&gt;</span>
<span class="cm">/* batteries not included :-) */</span>

<span class="cm">/*</span>
<span class="cm"> * modes in which the driver can operate </span>
<span class="cm"> */</span>
<span class="cp">#define   IMM_AUTODETECT        0	</span><span class="cm">/* Autodetect mode                */</span><span class="cp"></span>
<span class="cp">#define   IMM_NIBBLE            1	</span><span class="cm">/* work in standard 4 bit mode    */</span><span class="cp"></span>
<span class="cp">#define   IMM_PS2               2	</span><span class="cm">/* PS/2 byte mode         */</span><span class="cp"></span>
<span class="cp">#define   IMM_EPP_8             3	</span><span class="cm">/* EPP mode, 8 bit                */</span><span class="cp"></span>
<span class="cp">#define   IMM_EPP_16            4	</span><span class="cm">/* EPP mode, 16 bit               */</span><span class="cp"></span>
<span class="cp">#define   IMM_EPP_32            5	</span><span class="cm">/* EPP mode, 32 bit               */</span><span class="cp"></span>
<span class="cp">#define   IMM_UNKNOWN           6	</span><span class="cm">/* Just in case...                */</span><span class="cp"></span>

<span class="k">static</span> <span class="kt">char</span> <span class="o">*</span><span class="n">IMM_MODE_STRING</span><span class="p">[]</span> <span class="o">=</span>
<span class="p">{</span>
	<span class="p">[</span><span class="n">IMM_AUTODETECT</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;Autodetect&quot;</span><span class="p">,</span>
	<span class="p">[</span><span class="n">IMM_NIBBLE</span><span class="p">]</span>	 <span class="o">=</span> <span class="s">&quot;SPP&quot;</span><span class="p">,</span>
	<span class="p">[</span><span class="n">IMM_PS2</span><span class="p">]</span>	 <span class="o">=</span> <span class="s">&quot;PS/2&quot;</span><span class="p">,</span>
	<span class="p">[</span><span class="n">IMM_EPP_8</span><span class="p">]</span>	 <span class="o">=</span> <span class="s">&quot;EPP 8 bit&quot;</span><span class="p">,</span>
	<span class="p">[</span><span class="n">IMM_EPP_16</span><span class="p">]</span>	 <span class="o">=</span> <span class="s">&quot;EPP 16 bit&quot;</span><span class="p">,</span>
<span class="cp">#ifdef CONFIG_SCSI_IZIP_EPP16</span>
	<span class="p">[</span><span class="n">IMM_EPP_32</span><span class="p">]</span>	 <span class="o">=</span> <span class="s">&quot;EPP 16 bit&quot;</span><span class="p">,</span>
<span class="cp">#else</span>
	<span class="p">[</span><span class="n">IMM_EPP_32</span><span class="p">]</span>	 <span class="o">=</span> <span class="s">&quot;EPP 32 bit&quot;</span><span class="p">,</span>
<span class="cp">#endif</span>
	<span class="p">[</span><span class="n">IMM_UNKNOWN</span><span class="p">]</span>	 <span class="o">=</span> <span class="s">&quot;Unknown&quot;</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/* other options */</span>
<span class="cp">#define IMM_BURST_SIZE	512	</span><span class="cm">/* data burst size */</span><span class="cp"></span>
<span class="cp">#define IMM_SELECT_TMO  500	</span><span class="cm">/* 500 how long to wait for target ? */</span><span class="cp"></span>
<span class="cp">#define IMM_SPIN_TMO    5000	</span><span class="cm">/* 50000 imm_wait loop limiter */</span><span class="cp"></span>
<span class="cp">#define IMM_DEBUG	0	</span><span class="cm">/* debugging option */</span><span class="cp"></span>
<span class="cp">#define IN_EPP_MODE(x) (x == IMM_EPP_8 || x == IMM_EPP_16 || x == IMM_EPP_32)</span>

<span class="cm">/* args to imm_connect */</span>
<span class="cp">#define CONNECT_EPP_MAYBE 1</span>
<span class="cp">#define CONNECT_NORMAL  0</span>

<span class="cp">#define r_dtr(x)        (unsigned char)inb((x))</span>
<span class="cp">#define r_str(x)        (unsigned char)inb((x)+1)</span>
<span class="cp">#define r_ctr(x)        (unsigned char)inb((x)+2)</span>
<span class="cp">#define r_epp(x)        (unsigned char)inb((x)+4)</span>
<span class="cp">#define r_fifo(x)       (unsigned char)inb((x))   </span><span class="cm">/* x must be base_hi */</span><span class="cp"></span>
					<span class="cm">/* On PCI is: base+0x400 != base_hi */</span>
<span class="cp">#define r_ecr(x)        (unsigned char)inb((x)+2) </span><span class="cm">/* x must be base_hi */</span><span class="cp"></span>

<span class="cp">#define w_dtr(x,y)      outb(y, (x))</span>
<span class="cp">#define w_str(x,y)      outb(y, (x)+1)</span>
<span class="cp">#define w_epp(x,y)      outb(y, (x)+4)</span>
<span class="cp">#define w_fifo(x,y)     outb(y, (x))     </span><span class="cm">/* x must be base_hi */</span><span class="cp"></span>
<span class="cp">#define w_ecr(x,y)      outb(y, (x)+0x2) </span><span class="cm">/* x must be base_hi */</span><span class="cp"></span>

<span class="cp">#ifdef CONFIG_SCSI_IZIP_SLOW_CTR</span>
<span class="cp">#define w_ctr(x,y)      outb_p(y, (x)+2)</span>
<span class="cp">#else</span>
<span class="cp">#define w_ctr(x,y)      outb(y, (x)+2)</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">imm_engine</span><span class="p">(</span><span class="n">imm_struct</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="p">);</span>

<span class="cp">#endif				</span><span class="cm">/* _IMM_H */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
