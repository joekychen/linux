<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › of › base.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>base.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Procedures for creating, accessing and interpreting the device tree.</span>
<span class="cm"> *</span>
<span class="cm"> * Paul Mackerras	August 1996.</span>
<span class="cm"> * Copyright (C) 1996-2005 Paul Mackerras.</span>
<span class="cm"> *</span>
<span class="cm"> *  Adapted for 64bit PowerPC by Dave Engebretsen and Peter Bergner.</span>
<span class="cm"> *    {engebret|bergner}@us.ibm.com</span>
<span class="cm"> *</span>
<span class="cm"> *  Adapted for sparc and sparc64 by David S. Miller davem@davemloft.net</span>
<span class="cm"> *</span>
<span class="cm"> *  Reconsolidated from arch/x/kernel/prom.c by Stephen Rothwell and</span>
<span class="cm"> *  Grant Likely.</span>
<span class="cm"> *</span>
<span class="cm"> *      This program is free software; you can redistribute it and/or</span>
<span class="cm"> *      modify it under the terms of the GNU General Public License</span>
<span class="cm"> *      as published by the Free Software Foundation; either version</span>
<span class="cm"> *      2 of the License, or (at your option) any later version.</span>
<span class="cm"> */</span>
<span class="cp">#include &lt;linux/ctype.h&gt;</span>
<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/of.h&gt;</span>
<span class="cp">#include &lt;linux/spinlock.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/proc_fs.h&gt;</span>

<span class="cm">/**</span>
<span class="cm"> * struct alias_prop - Alias property in &#39;aliases&#39; node</span>
<span class="cm"> * @link:	List node to link the structure in aliases_lookup list</span>
<span class="cm"> * @alias:	Alias property name</span>
<span class="cm"> * @np:		Pointer to device_node that the alias stands for</span>
<span class="cm"> * @id:		Index value from end of alias name</span>
<span class="cm"> * @stem:	Alias string without the index</span>
<span class="cm"> *</span>
<span class="cm"> * The structure represents one alias property of &#39;aliases&#39; node as</span>
<span class="cm"> * an entry in aliases_lookup list.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">alias_prop</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">link</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">alias</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">np</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">id</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">stem</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="p">};</span>

<span class="k">static</span> <span class="n">LIST_HEAD</span><span class="p">(</span><span class="n">aliases_lookup</span><span class="p">);</span>

<span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">allnodes</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">of_chosen</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">of_aliases</span><span class="p">;</span>

<span class="k">static</span> <span class="n">DEFINE_MUTEX</span><span class="p">(</span><span class="n">of_aliases_mutex</span><span class="p">);</span>

<span class="cm">/* use when traversing tree through the allnext, child, sibling,</span>
<span class="cm"> * or parent members of struct device_node.</span>
<span class="cm"> */</span>
<span class="n">DEFINE_RWLOCK</span><span class="p">(</span><span class="n">devtree_lock</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">of_n_addr_cells</span><span class="p">(</span><span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">np</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="n">__be32</span> <span class="o">*</span><span class="n">ip</span><span class="p">;</span>

	<span class="k">do</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">)</span>
			<span class="n">np</span> <span class="o">=</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">;</span>
		<span class="n">ip</span> <span class="o">=</span> <span class="n">of_get_property</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="s">&quot;#address-cells&quot;</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ip</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">be32_to_cpup</span><span class="p">(</span><span class="n">ip</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">);</span>
	<span class="cm">/* No #address-cells property for the root node */</span>
	<span class="k">return</span> <span class="n">OF_ROOT_NODE_ADDR_CELLS_DEFAULT</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">of_n_addr_cells</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">of_n_size_cells</span><span class="p">(</span><span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">np</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="n">__be32</span> <span class="o">*</span><span class="n">ip</span><span class="p">;</span>

	<span class="k">do</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">)</span>
			<span class="n">np</span> <span class="o">=</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">;</span>
		<span class="n">ip</span> <span class="o">=</span> <span class="n">of_get_property</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="s">&quot;#size-cells&quot;</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ip</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">be32_to_cpup</span><span class="p">(</span><span class="n">ip</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">);</span>
	<span class="cm">/* No #size-cells property for the root node */</span>
	<span class="k">return</span> <span class="n">OF_ROOT_NODE_SIZE_CELLS_DEFAULT</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">of_n_size_cells</span><span class="p">);</span>

<span class="cp">#if defined(CONFIG_OF_DYNAMIC)</span>
<span class="cm">/**</span>
<span class="cm"> *	of_node_get - Increment refcount of a node</span>
<span class="cm"> *	@node:	Node to inc refcount, NULL is supported to</span>
<span class="cm"> *		simplify writing of callers</span>
<span class="cm"> *</span>
<span class="cm"> *	Returns node.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="nf">of_node_get</span><span class="p">(</span><span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">node</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">node</span><span class="p">)</span>
		<span class="n">kref_get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">kref</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">node</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">of_node_get</span><span class="p">);</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="nf">kref_to_device_node</span><span class="p">(</span><span class="k">struct</span> <span class="n">kref</span> <span class="o">*</span><span class="n">kref</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">container_of</span><span class="p">(</span><span class="n">kref</span><span class="p">,</span> <span class="k">struct</span> <span class="n">device_node</span><span class="p">,</span> <span class="n">kref</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	of_node_release - release a dynamically allocated node</span>
<span class="cm"> *	@kref:  kref element of the node to be released</span>
<span class="cm"> *</span>
<span class="cm"> *	In of_node_put() this function is passed to kref_put()</span>
<span class="cm"> *	as the destructor.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">of_node_release</span><span class="p">(</span><span class="k">struct</span> <span class="n">kref</span> <span class="o">*</span><span class="n">kref</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">node</span> <span class="o">=</span> <span class="n">kref_to_device_node</span><span class="p">(</span><span class="n">kref</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">property</span> <span class="o">*</span><span class="n">prop</span> <span class="o">=</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">properties</span><span class="p">;</span>

	<span class="cm">/* We should never be releasing nodes that haven&#39;t been detached. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">of_node_check_flag</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">OF_DETACHED</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;ERROR: Bad of_node_put() on %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">full_name</span><span class="p">);</span>
		<span class="n">dump_stack</span><span class="p">();</span>
		<span class="n">kref_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">kref</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">of_node_check_flag</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">OF_DYNAMIC</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">prop</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">property</span> <span class="o">*</span><span class="n">next</span> <span class="o">=</span> <span class="n">prop</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">prop</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">prop</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">prop</span><span class="p">);</span>
		<span class="n">prop</span> <span class="o">=</span> <span class="n">next</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">prop</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">prop</span> <span class="o">=</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">deadprops</span><span class="p">;</span>
			<span class="n">node</span><span class="o">-&gt;</span><span class="n">deadprops</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">full_name</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">node</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	of_node_put - Decrement refcount of a node</span>
<span class="cm"> *	@node:	Node to dec refcount, NULL is supported to</span>
<span class="cm"> *		simplify writing of callers</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">of_node_put</span><span class="p">(</span><span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">node</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">node</span><span class="p">)</span>
		<span class="n">kref_put</span><span class="p">(</span><span class="o">&amp;</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">kref</span><span class="p">,</span> <span class="n">of_node_release</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">of_node_put</span><span class="p">);</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_OF_DYNAMIC */</span><span class="cp"></span>

<span class="k">struct</span> <span class="n">property</span> <span class="o">*</span><span class="nf">of_find_property</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">np</span><span class="p">,</span>
				  <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span>
				  <span class="kt">int</span> <span class="o">*</span><span class="n">lenp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">property</span> <span class="o">*</span><span class="n">pp</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">np</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">read_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">devtree_lock</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">pp</span> <span class="o">=</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">properties</span><span class="p">;</span> <span class="n">pp</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">pp</span> <span class="o">=</span> <span class="n">pp</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">of_prop_cmp</span><span class="p">(</span><span class="n">pp</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">lenp</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
				<span class="o">*</span><span class="n">lenp</span> <span class="o">=</span> <span class="n">pp</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">read_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">devtree_lock</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">pp</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">of_find_property</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * of_find_all_nodes - Get next node in global list</span>
<span class="cm"> * @prev:	Previous node or NULL to start iteration</span>
<span class="cm"> *		of_node_put() will be called on it</span>
<span class="cm"> *</span>
<span class="cm"> * Returns a node pointer with refcount incremented, use</span>
<span class="cm"> * of_node_put() on it when done.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="nf">of_find_all_nodes</span><span class="p">(</span><span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">prev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">np</span><span class="p">;</span>

	<span class="n">read_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">devtree_lock</span><span class="p">);</span>
	<span class="n">np</span> <span class="o">=</span> <span class="n">prev</span> <span class="o">?</span> <span class="n">prev</span><span class="o">-&gt;</span><span class="n">allnext</span> <span class="o">:</span> <span class="n">allnodes</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(;</span> <span class="n">np</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">;</span> <span class="n">np</span> <span class="o">=</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">allnext</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">of_node_get</span><span class="p">(</span><span class="n">np</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="n">of_node_put</span><span class="p">(</span><span class="n">prev</span><span class="p">);</span>
	<span class="n">read_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">devtree_lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">np</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">of_find_all_nodes</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Find a property with a given name for a given node</span>
<span class="cm"> * and return the value.</span>
<span class="cm"> */</span>
<span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">of_get_property</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">np</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span>
			 <span class="kt">int</span> <span class="o">*</span><span class="n">lenp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">property</span> <span class="o">*</span><span class="n">pp</span> <span class="o">=</span> <span class="n">of_find_property</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">lenp</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">pp</span> <span class="o">?</span> <span class="n">pp</span><span class="o">-&gt;</span><span class="n">value</span> <span class="o">:</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">of_get_property</span><span class="p">);</span>

<span class="cm">/** Checks if the given &quot;compat&quot; string matches one of the strings in</span>
<span class="cm"> * the device&#39;s &quot;compatible&quot; property</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">of_device_is_compatible</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">device</span><span class="p">,</span>
		<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">compat</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">cp</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">cplen</span><span class="p">,</span> <span class="n">l</span><span class="p">;</span>

	<span class="n">cp</span> <span class="o">=</span> <span class="n">of_get_property</span><span class="p">(</span><span class="n">device</span><span class="p">,</span> <span class="s">&quot;compatible&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cplen</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cp</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">cplen</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">of_compat_cmp</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">compat</span><span class="p">,</span> <span class="n">strlen</span><span class="p">(</span><span class="n">compat</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">l</span> <span class="o">=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">cp</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">cp</span> <span class="o">+=</span> <span class="n">l</span><span class="p">;</span>
		<span class="n">cplen</span> <span class="o">-=</span> <span class="n">l</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">of_device_is_compatible</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * of_machine_is_compatible - Test root of device tree for a given compatible value</span>
<span class="cm"> * @compat: compatible string to look for in root node&#39;s compatible property.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns true if the root node has the given value in its</span>
<span class="cm"> * compatible property.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">of_machine_is_compatible</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">compat</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">root</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">root</span> <span class="o">=</span> <span class="n">of_find_node_by_path</span><span class="p">(</span><span class="s">&quot;/&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">root</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">of_device_is_compatible</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">compat</span><span class="p">);</span>
		<span class="n">of_node_put</span><span class="p">(</span><span class="n">root</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">of_machine_is_compatible</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> *  of_device_is_available - check if a device is available for use</span>
<span class="cm"> *</span>
<span class="cm"> *  @device: Node to check for availability</span>
<span class="cm"> *</span>
<span class="cm"> *  Returns 1 if the status property is absent or set to &quot;okay&quot; or &quot;ok&quot;,</span>
<span class="cm"> *  0 otherwise</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">of_device_is_available</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">device</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">status</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">statlen</span><span class="p">;</span>

	<span class="n">status</span> <span class="o">=</span> <span class="n">of_get_property</span><span class="p">(</span><span class="n">device</span><span class="p">,</span> <span class="s">&quot;status&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">statlen</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">statlen</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strcmp</span><span class="p">(</span><span class="n">status</span><span class="p">,</span> <span class="s">&quot;okay&quot;</span><span class="p">)</span> <span class="o">||</span> <span class="o">!</span><span class="n">strcmp</span><span class="p">(</span><span class="n">status</span><span class="p">,</span> <span class="s">&quot;ok&quot;</span><span class="p">))</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">of_device_is_available</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> *	of_get_parent - Get a node&#39;s parent if any</span>
<span class="cm"> *	@node:	Node to get parent</span>
<span class="cm"> *</span>
<span class="cm"> *	Returns a node pointer with refcount incremented, use</span>
<span class="cm"> *	of_node_put() on it when done.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="nf">of_get_parent</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">node</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">np</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">node</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">read_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">devtree_lock</span><span class="p">);</span>
	<span class="n">np</span> <span class="o">=</span> <span class="n">of_node_get</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">);</span>
	<span class="n">read_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">devtree_lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">np</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">of_get_parent</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> *	of_get_next_parent - Iterate to a node&#39;s parent</span>
<span class="cm"> *	@node:	Node to get parent of</span>
<span class="cm"> *</span>
<span class="cm"> * 	This is like of_get_parent() except that it drops the</span>
<span class="cm"> * 	refcount on the passed node, making it suitable for iterating</span>
<span class="cm"> * 	through a node&#39;s parents.</span>
<span class="cm"> *</span>
<span class="cm"> *	Returns a node pointer with refcount incremented, use</span>
<span class="cm"> *	of_node_put() on it when done.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="nf">of_get_next_parent</span><span class="p">(</span><span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">node</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">parent</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">node</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">read_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">devtree_lock</span><span class="p">);</span>
	<span class="n">parent</span> <span class="o">=</span> <span class="n">of_node_get</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">);</span>
	<span class="n">of_node_put</span><span class="p">(</span><span class="n">node</span><span class="p">);</span>
	<span class="n">read_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">devtree_lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">parent</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	of_get_next_child - Iterate a node childs</span>
<span class="cm"> *	@node:	parent node</span>
<span class="cm"> *	@prev:	previous child of the parent node, or NULL to get first</span>
<span class="cm"> *</span>
<span class="cm"> *	Returns a node pointer with refcount incremented, use</span>
<span class="cm"> *	of_node_put() on it when done.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="nf">of_get_next_child</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">node</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">prev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>

	<span class="n">read_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">devtree_lock</span><span class="p">);</span>
	<span class="n">next</span> <span class="o">=</span> <span class="n">prev</span> <span class="o">?</span> <span class="n">prev</span><span class="o">-&gt;</span><span class="n">sibling</span> <span class="o">:</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">child</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(;</span> <span class="n">next</span><span class="p">;</span> <span class="n">next</span> <span class="o">=</span> <span class="n">next</span><span class="o">-&gt;</span><span class="n">sibling</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">of_node_get</span><span class="p">(</span><span class="n">next</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="n">of_node_put</span><span class="p">(</span><span class="n">prev</span><span class="p">);</span>
	<span class="n">read_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">devtree_lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">next</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">of_get_next_child</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> *	of_find_node_by_path - Find a node matching a full OF path</span>
<span class="cm"> *	@path:	The full path to match</span>
<span class="cm"> *</span>
<span class="cm"> *	Returns a node pointer with refcount incremented, use</span>
<span class="cm"> *	of_node_put() on it when done.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="nf">of_find_node_by_path</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">path</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">np</span> <span class="o">=</span> <span class="n">allnodes</span><span class="p">;</span>

	<span class="n">read_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">devtree_lock</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(;</span> <span class="n">np</span><span class="p">;</span> <span class="n">np</span> <span class="o">=</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">allnext</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">full_name</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">of_node_cmp</span><span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">full_name</span><span class="p">,</span> <span class="n">path</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		    <span class="o">&amp;&amp;</span> <span class="n">of_node_get</span><span class="p">(</span><span class="n">np</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">read_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">devtree_lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">np</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">of_find_node_by_path</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> *	of_find_node_by_name - Find a node by its &quot;name&quot; property</span>
<span class="cm"> *	@from:	The node to start searching from or NULL, the node</span>
<span class="cm"> *		you pass will not be searched, only the next one</span>
<span class="cm"> *		will; typically, you pass what the previous call</span>
<span class="cm"> *		returned. of_node_put() will be called on it</span>
<span class="cm"> *	@name:	The name string to match against</span>
<span class="cm"> *</span>
<span class="cm"> *	Returns a node pointer with refcount incremented, use</span>
<span class="cm"> *	of_node_put() on it when done.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="nf">of_find_node_by_name</span><span class="p">(</span><span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">from</span><span class="p">,</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">np</span><span class="p">;</span>

	<span class="n">read_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">devtree_lock</span><span class="p">);</span>
	<span class="n">np</span> <span class="o">=</span> <span class="n">from</span> <span class="o">?</span> <span class="n">from</span><span class="o">-&gt;</span><span class="n">allnext</span> <span class="o">:</span> <span class="n">allnodes</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(;</span> <span class="n">np</span><span class="p">;</span> <span class="n">np</span> <span class="o">=</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">allnext</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">name</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">of_node_cmp</span><span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		    <span class="o">&amp;&amp;</span> <span class="n">of_node_get</span><span class="p">(</span><span class="n">np</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="n">of_node_put</span><span class="p">(</span><span class="n">from</span><span class="p">);</span>
	<span class="n">read_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">devtree_lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">np</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">of_find_node_by_name</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> *	of_find_node_by_type - Find a node by its &quot;device_type&quot; property</span>
<span class="cm"> *	@from:	The node to start searching from, or NULL to start searching</span>
<span class="cm"> *		the entire device tree. The node you pass will not be</span>
<span class="cm"> *		searched, only the next one will; typically, you pass</span>
<span class="cm"> *		what the previous call returned. of_node_put() will be</span>
<span class="cm"> *		called on from for you.</span>
<span class="cm"> *	@type:	The type string to match against</span>
<span class="cm"> *</span>
<span class="cm"> *	Returns a node pointer with refcount incremented, use</span>
<span class="cm"> *	of_node_put() on it when done.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="nf">of_find_node_by_type</span><span class="p">(</span><span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">from</span><span class="p">,</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">type</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">np</span><span class="p">;</span>

	<span class="n">read_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">devtree_lock</span><span class="p">);</span>
	<span class="n">np</span> <span class="o">=</span> <span class="n">from</span> <span class="o">?</span> <span class="n">from</span><span class="o">-&gt;</span><span class="n">allnext</span> <span class="o">:</span> <span class="n">allnodes</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(;</span> <span class="n">np</span><span class="p">;</span> <span class="n">np</span> <span class="o">=</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">allnext</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">of_node_cmp</span><span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">,</span> <span class="n">type</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		    <span class="o">&amp;&amp;</span> <span class="n">of_node_get</span><span class="p">(</span><span class="n">np</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="n">of_node_put</span><span class="p">(</span><span class="n">from</span><span class="p">);</span>
	<span class="n">read_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">devtree_lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">np</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">of_find_node_by_type</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> *	of_find_compatible_node - Find a node based on type and one of the</span>
<span class="cm"> *                                tokens in its &quot;compatible&quot; property</span>
<span class="cm"> *	@from:		The node to start searching from or NULL, the node</span>
<span class="cm"> *			you pass will not be searched, only the next one</span>
<span class="cm"> *			will; typically, you pass what the previous call</span>
<span class="cm"> *			returned. of_node_put() will be called on it</span>
<span class="cm"> *	@type:		The type string to match &quot;device_type&quot; or NULL to ignore</span>
<span class="cm"> *	@compatible:	The string to match to one of the tokens in the device</span>
<span class="cm"> *			&quot;compatible&quot; list.</span>
<span class="cm"> *</span>
<span class="cm"> *	Returns a node pointer with refcount incremented, use</span>
<span class="cm"> *	of_node_put() on it when done.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="nf">of_find_compatible_node</span><span class="p">(</span><span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">from</span><span class="p">,</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">type</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">compatible</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">np</span><span class="p">;</span>

	<span class="n">read_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">devtree_lock</span><span class="p">);</span>
	<span class="n">np</span> <span class="o">=</span> <span class="n">from</span> <span class="o">?</span> <span class="n">from</span><span class="o">-&gt;</span><span class="n">allnext</span> <span class="o">:</span> <span class="n">allnodes</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(;</span> <span class="n">np</span><span class="p">;</span> <span class="n">np</span> <span class="o">=</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">allnext</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">type</span>
		    <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">of_node_cmp</span><span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">,</span> <span class="n">type</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)))</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">of_device_is_compatible</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">compatible</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">of_node_get</span><span class="p">(</span><span class="n">np</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">of_node_put</span><span class="p">(</span><span class="n">from</span><span class="p">);</span>
	<span class="n">read_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">devtree_lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">np</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">of_find_compatible_node</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> *	of_find_node_with_property - Find a node which has a property with</span>
<span class="cm"> *                                   the given name.</span>
<span class="cm"> *	@from:		The node to start searching from or NULL, the node</span>
<span class="cm"> *			you pass will not be searched, only the next one</span>
<span class="cm"> *			will; typically, you pass what the previous call</span>
<span class="cm"> *			returned. of_node_put() will be called on it</span>
<span class="cm"> *	@prop_name:	The name of the property to look for.</span>
<span class="cm"> *</span>
<span class="cm"> *	Returns a node pointer with refcount incremented, use</span>
<span class="cm"> *	of_node_put() on it when done.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="nf">of_find_node_with_property</span><span class="p">(</span><span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">from</span><span class="p">,</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">prop_name</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">np</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">property</span> <span class="o">*</span><span class="n">pp</span><span class="p">;</span>

	<span class="n">read_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">devtree_lock</span><span class="p">);</span>
	<span class="n">np</span> <span class="o">=</span> <span class="n">from</span> <span class="o">?</span> <span class="n">from</span><span class="o">-&gt;</span><span class="n">allnext</span> <span class="o">:</span> <span class="n">allnodes</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(;</span> <span class="n">np</span><span class="p">;</span> <span class="n">np</span> <span class="o">=</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">allnext</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">pp</span> <span class="o">=</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">properties</span><span class="p">;</span> <span class="n">pp</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">pp</span> <span class="o">=</span> <span class="n">pp</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">of_prop_cmp</span><span class="p">(</span><span class="n">pp</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">prop_name</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">of_node_get</span><span class="p">(</span><span class="n">np</span><span class="p">);</span>
				<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="nl">out:</span>
	<span class="n">of_node_put</span><span class="p">(</span><span class="n">from</span><span class="p">);</span>
	<span class="n">read_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">devtree_lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">np</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">of_find_node_with_property</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * of_match_node - Tell if an device_node has a matching of_match structure</span>
<span class="cm"> *	@matches:	array of of device match structures to search in</span>
<span class="cm"> *	@node:		the of device structure to match against</span>
<span class="cm"> *</span>
<span class="cm"> *	Low level utility function used by device matching.</span>
<span class="cm"> */</span>
<span class="k">const</span> <span class="k">struct</span> <span class="n">of_device_id</span> <span class="o">*</span><span class="nf">of_match_node</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">of_device_id</span> <span class="o">*</span><span class="n">matches</span><span class="p">,</span>
					 <span class="k">const</span> <span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">node</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">matches</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">matches</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">||</span> <span class="n">matches</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">||</span> <span class="n">matches</span><span class="o">-&gt;</span><span class="n">compatible</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">match</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">matches</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
			<span class="n">match</span> <span class="o">&amp;=</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">name</span>
				<span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">strcmp</span><span class="p">(</span><span class="n">matches</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">matches</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
			<span class="n">match</span> <span class="o">&amp;=</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">type</span>
				<span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">strcmp</span><span class="p">(</span><span class="n">matches</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">,</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">matches</span><span class="o">-&gt;</span><span class="n">compatible</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
			<span class="n">match</span> <span class="o">&amp;=</span> <span class="n">of_device_is_compatible</span><span class="p">(</span><span class="n">node</span><span class="p">,</span>
						<span class="n">matches</span><span class="o">-&gt;</span><span class="n">compatible</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">match</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">matches</span><span class="p">;</span>
		<span class="n">matches</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">of_match_node</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> *	of_find_matching_node - Find a node based on an of_device_id match</span>
<span class="cm"> *				table.</span>
<span class="cm"> *	@from:		The node to start searching from or NULL, the node</span>
<span class="cm"> *			you pass will not be searched, only the next one</span>
<span class="cm"> *			will; typically, you pass what the previous call</span>
<span class="cm"> *			returned. of_node_put() will be called on it</span>
<span class="cm"> *	@matches:	array of of device match structures to search in</span>
<span class="cm"> *</span>
<span class="cm"> *	Returns a node pointer with refcount incremented, use</span>
<span class="cm"> *	of_node_put() on it when done.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="nf">of_find_matching_node</span><span class="p">(</span><span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">from</span><span class="p">,</span>
					  <span class="k">const</span> <span class="k">struct</span> <span class="n">of_device_id</span> <span class="o">*</span><span class="n">matches</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">np</span><span class="p">;</span>

	<span class="n">read_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">devtree_lock</span><span class="p">);</span>
	<span class="n">np</span> <span class="o">=</span> <span class="n">from</span> <span class="o">?</span> <span class="n">from</span><span class="o">-&gt;</span><span class="n">allnext</span> <span class="o">:</span> <span class="n">allnodes</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(;</span> <span class="n">np</span><span class="p">;</span> <span class="n">np</span> <span class="o">=</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">allnext</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">of_match_node</span><span class="p">(</span><span class="n">matches</span><span class="p">,</span> <span class="n">np</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">of_node_get</span><span class="p">(</span><span class="n">np</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">of_node_put</span><span class="p">(</span><span class="n">from</span><span class="p">);</span>
	<span class="n">read_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">devtree_lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">np</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">of_find_matching_node</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * of_modalias_node - Lookup appropriate modalias for a device node</span>
<span class="cm"> * @node:	pointer to a device tree node</span>
<span class="cm"> * @modalias:	Pointer to buffer that modalias value will be copied into</span>
<span class="cm"> * @len:	Length of modalias value</span>
<span class="cm"> *</span>
<span class="cm"> * Based on the value of the compatible property, this routine will attempt</span>
<span class="cm"> * to choose an appropriate modalias value for a particular device tree node.</span>
<span class="cm"> * It does this by stripping the manufacturer prefix (as delimited by a &#39;,&#39;)</span>
<span class="cm"> * from the first entry in the compatible list property.</span>
<span class="cm"> *</span>
<span class="cm"> * This routine returns 0 on success, &lt;0 on failure.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">of_modalias_node</span><span class="p">(</span><span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">node</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">modalias</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">compatible</span><span class="p">,</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">cplen</span><span class="p">;</span>

	<span class="n">compatible</span> <span class="o">=</span> <span class="n">of_get_property</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="s">&quot;compatible&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cplen</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">compatible</span> <span class="o">||</span> <span class="n">strlen</span><span class="p">(</span><span class="n">compatible</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">cplen</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
	<span class="n">p</span> <span class="o">=</span> <span class="n">strchr</span><span class="p">(</span><span class="n">compatible</span><span class="p">,</span> <span class="sc">&#39;,&#39;</span><span class="p">);</span>
	<span class="n">strlcpy</span><span class="p">(</span><span class="n">modalias</span><span class="p">,</span> <span class="n">p</span> <span class="o">?</span> <span class="n">p</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">:</span> <span class="n">compatible</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">of_modalias_node</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * of_find_node_by_phandle - Find a node given a phandle</span>
<span class="cm"> * @handle:	phandle of the node to find</span>
<span class="cm"> *</span>
<span class="cm"> * Returns a node pointer with refcount incremented, use</span>
<span class="cm"> * of_node_put() on it when done.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="nf">of_find_node_by_phandle</span><span class="p">(</span><span class="n">phandle</span> <span class="n">handle</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">np</span><span class="p">;</span>

	<span class="n">read_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">devtree_lock</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">np</span> <span class="o">=</span> <span class="n">allnodes</span><span class="p">;</span> <span class="n">np</span><span class="p">;</span> <span class="n">np</span> <span class="o">=</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">allnext</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">phandle</span> <span class="o">==</span> <span class="n">handle</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="n">of_node_get</span><span class="p">(</span><span class="n">np</span><span class="p">);</span>
	<span class="n">read_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">devtree_lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">np</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">of_find_node_by_phandle</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * of_property_read_u32_array - Find and read an array of 32 bit integers</span>
<span class="cm"> * from a property.</span>
<span class="cm"> *</span>
<span class="cm"> * @np:		device node from which the property value is to be read.</span>
<span class="cm"> * @propname:	name of the property to be searched.</span>
<span class="cm"> * @out_value:	pointer to return value, modified only if return value is 0.</span>
<span class="cm"> *</span>
<span class="cm"> * Search for a property in a device node and read 32-bit value(s) from</span>
<span class="cm"> * it. Returns 0 on success, -EINVAL if the property does not exist,</span>
<span class="cm"> * -ENODATA if property does not have a value, and -EOVERFLOW if the</span>
<span class="cm"> * property data isn&#39;t large enough.</span>
<span class="cm"> *</span>
<span class="cm"> * The out_value is modified only if a valid u32 value can be decoded.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">of_property_read_u32_array</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">np</span><span class="p">,</span>
			       <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">propname</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">out_values</span><span class="p">,</span>
			       <span class="kt">size_t</span> <span class="n">sz</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">property</span> <span class="o">*</span><span class="n">prop</span> <span class="o">=</span> <span class="n">of_find_property</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">propname</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">const</span> <span class="n">__be32</span> <span class="o">*</span><span class="n">val</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">prop</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">prop</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODATA</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">sz</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">out_values</span><span class="p">))</span> <span class="o">&gt;</span> <span class="n">prop</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EOVERFLOW</span><span class="p">;</span>

	<span class="n">val</span> <span class="o">=</span> <span class="n">prop</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">sz</span><span class="o">--</span><span class="p">)</span>
		<span class="o">*</span><span class="n">out_values</span><span class="o">++</span> <span class="o">=</span> <span class="n">be32_to_cpup</span><span class="p">(</span><span class="n">val</span><span class="o">++</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">of_property_read_u32_array</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * of_property_read_u64 - Find and read a 64 bit integer from a property</span>
<span class="cm"> * @np:		device node from which the property value is to be read.</span>
<span class="cm"> * @propname:	name of the property to be searched.</span>
<span class="cm"> * @out_value:	pointer to return value, modified only if return value is 0.</span>
<span class="cm"> *</span>
<span class="cm"> * Search for a property in a device node and read a 64-bit value from</span>
<span class="cm"> * it. Returns 0 on success, -EINVAL if the property does not exist,</span>
<span class="cm"> * -ENODATA if property does not have a value, and -EOVERFLOW if the</span>
<span class="cm"> * property data isn&#39;t large enough.</span>
<span class="cm"> *</span>
<span class="cm"> * The out_value is modified only if a valid u64 value can be decoded.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">of_property_read_u64</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">np</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">propname</span><span class="p">,</span>
			 <span class="n">u64</span> <span class="o">*</span><span class="n">out_value</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">property</span> <span class="o">*</span><span class="n">prop</span> <span class="o">=</span> <span class="n">of_find_property</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">propname</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">prop</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">prop</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODATA</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">out_value</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">prop</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EOVERFLOW</span><span class="p">;</span>
	<span class="o">*</span><span class="n">out_value</span> <span class="o">=</span> <span class="n">of_read_number</span><span class="p">(</span><span class="n">prop</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">of_property_read_u64</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * of_property_read_string - Find and read a string from a property</span>
<span class="cm"> * @np:		device node from which the property value is to be read.</span>
<span class="cm"> * @propname:	name of the property to be searched.</span>
<span class="cm"> * @out_string:	pointer to null terminated return string, modified only if</span>
<span class="cm"> *		return value is 0.</span>
<span class="cm"> *</span>
<span class="cm"> * Search for a property in a device tree node and retrieve a null</span>
<span class="cm"> * terminated string value (pointer to data, not a copy). Returns 0 on</span>
<span class="cm"> * success, -EINVAL if the property does not exist, -ENODATA if property</span>
<span class="cm"> * does not have a value, and -EILSEQ if the string is not null-terminated</span>
<span class="cm"> * within the length of the property data.</span>
<span class="cm"> *</span>
<span class="cm"> * The out_string pointer is modified only if a valid string can be decoded.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">of_property_read_string</span><span class="p">(</span><span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">np</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">propname</span><span class="p">,</span>
				<span class="k">const</span> <span class="kt">char</span> <span class="o">**</span><span class="n">out_string</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">property</span> <span class="o">*</span><span class="n">prop</span> <span class="o">=</span> <span class="n">of_find_property</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">propname</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">prop</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">prop</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODATA</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">strnlen</span><span class="p">(</span><span class="n">prop</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">,</span> <span class="n">prop</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">prop</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EILSEQ</span><span class="p">;</span>
	<span class="o">*</span><span class="n">out_string</span> <span class="o">=</span> <span class="n">prop</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">of_property_read_string</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * of_property_read_string_index - Find and read a string from a multiple</span>
<span class="cm"> * strings property.</span>
<span class="cm"> * @np:		device node from which the property value is to be read.</span>
<span class="cm"> * @propname:	name of the property to be searched.</span>
<span class="cm"> * @index:	index of the string in the list of strings</span>
<span class="cm"> * @out_string:	pointer to null terminated return string, modified only if</span>
<span class="cm"> *		return value is 0.</span>
<span class="cm"> *</span>
<span class="cm"> * Search for a property in a device tree node and retrieve a null</span>
<span class="cm"> * terminated string value (pointer to data, not a copy) in the list of strings</span>
<span class="cm"> * contained in that property.</span>
<span class="cm"> * Returns 0 on success, -EINVAL if the property does not exist, -ENODATA if</span>
<span class="cm"> * property does not have a value, and -EILSEQ if the string is not</span>
<span class="cm"> * null-terminated within the length of the property data.</span>
<span class="cm"> *</span>
<span class="cm"> * The out_string pointer is modified only if a valid string can be decoded.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">of_property_read_string_index</span><span class="p">(</span><span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">np</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">propname</span><span class="p">,</span>
				  <span class="kt">int</span> <span class="n">index</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">**</span><span class="n">output</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">property</span> <span class="o">*</span><span class="n">prop</span> <span class="o">=</span> <span class="n">of_find_property</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">propname</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">l</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">total</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">prop</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">prop</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODATA</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">strnlen</span><span class="p">(</span><span class="n">prop</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">,</span> <span class="n">prop</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">prop</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EILSEQ</span><span class="p">;</span>

	<span class="n">p</span> <span class="o">=</span> <span class="n">prop</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">total</span> <span class="o">&lt;</span> <span class="n">prop</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">;</span> <span class="n">total</span> <span class="o">+=</span> <span class="n">l</span><span class="p">,</span> <span class="n">p</span> <span class="o">+=</span> <span class="n">l</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">l</span> <span class="o">=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">i</span><span class="o">++</span> <span class="o">==</span> <span class="n">index</span><span class="p">)</span> <span class="p">{</span>
			<span class="o">*</span><span class="n">output</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">ENODATA</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">of_property_read_string_index</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * of_property_match_string() - Find string in a list and return index</span>
<span class="cm"> * @np: pointer to node containing string list property</span>
<span class="cm"> * @propname: string list property name</span>
<span class="cm"> * @string: pointer to string to search for in string list</span>
<span class="cm"> *</span>
<span class="cm"> * This function searches a string list property and returns the index</span>
<span class="cm"> * of a specific string value.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">of_property_match_string</span><span class="p">(</span><span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">np</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">propname</span><span class="p">,</span>
			     <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">string</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">property</span> <span class="o">*</span><span class="n">prop</span> <span class="o">=</span> <span class="n">of_find_property</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">propname</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="kt">size_t</span> <span class="n">l</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="o">*</span><span class="n">end</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">prop</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">prop</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODATA</span><span class="p">;</span>

	<span class="n">p</span> <span class="o">=</span> <span class="n">prop</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">;</span>
	<span class="n">end</span> <span class="o">=</span> <span class="n">p</span> <span class="o">+</span> <span class="n">prop</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">p</span> <span class="o">&lt;</span> <span class="n">end</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">,</span> <span class="n">p</span> <span class="o">+=</span> <span class="n">l</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">l</span> <span class="o">=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">p</span> <span class="o">+</span> <span class="n">l</span> <span class="o">&gt;</span> <span class="n">end</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EILSEQ</span><span class="p">;</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;comparing %s with %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">string</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">string</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">i</span><span class="p">;</span> <span class="cm">/* Found it; return index */</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">ENODATA</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">of_property_match_string</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * of_property_count_strings - Find and return the number of strings from a</span>
<span class="cm"> * multiple strings property.</span>
<span class="cm"> * @np:		device node from which the property value is to be read.</span>
<span class="cm"> * @propname:	name of the property to be searched.</span>
<span class="cm"> *</span>
<span class="cm"> * Search for a property in a device tree node and retrieve the number of null</span>
<span class="cm"> * terminated string contain in it. Returns the number of strings on</span>
<span class="cm"> * success, -EINVAL if the property does not exist, -ENODATA if property</span>
<span class="cm"> * does not have a value, and -EILSEQ if the string is not null-terminated</span>
<span class="cm"> * within the length of the property data.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">of_property_count_strings</span><span class="p">(</span><span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">np</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">propname</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">property</span> <span class="o">*</span><span class="n">prop</span> <span class="o">=</span> <span class="n">of_find_property</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">propname</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">l</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">total</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">prop</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">prop</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODATA</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">strnlen</span><span class="p">(</span><span class="n">prop</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">,</span> <span class="n">prop</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">prop</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EILSEQ</span><span class="p">;</span>

	<span class="n">p</span> <span class="o">=</span> <span class="n">prop</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">total</span> <span class="o">&lt;</span> <span class="n">prop</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">;</span> <span class="n">total</span> <span class="o">+=</span> <span class="n">l</span><span class="p">,</span> <span class="n">p</span> <span class="o">+=</span> <span class="n">l</span><span class="p">,</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">l</span> <span class="o">=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">i</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">of_property_count_strings</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * of_parse_phandle - Resolve a phandle property to a device_node pointer</span>
<span class="cm"> * @np: Pointer to device node holding phandle property</span>
<span class="cm"> * @phandle_name: Name of property holding a phandle value</span>
<span class="cm"> * @index: For properties holding a table of phandles, this is the index into</span>
<span class="cm"> *         the table</span>
<span class="cm"> *</span>
<span class="cm"> * Returns the device_node pointer with refcount incremented.  Use</span>
<span class="cm"> * of_node_put() on it when done.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span>
<span class="nf">of_parse_phandle</span><span class="p">(</span><span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">np</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">phandle_name</span><span class="p">,</span> <span class="kt">int</span> <span class="n">index</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="n">__be32</span> <span class="o">*</span><span class="n">phandle</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">size</span><span class="p">;</span>

	<span class="n">phandle</span> <span class="o">=</span> <span class="n">of_get_property</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">phandle_name</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">size</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">((</span><span class="o">!</span><span class="n">phandle</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">size</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">phandle</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)))</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">of_find_node_by_phandle</span><span class="p">(</span><span class="n">be32_to_cpup</span><span class="p">(</span><span class="n">phandle</span> <span class="o">+</span> <span class="n">index</span><span class="p">));</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">of_parse_phandle</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * of_parse_phandle_with_args() - Find a node pointed by phandle in a list</span>
<span class="cm"> * @np:		pointer to a device tree node containing a list</span>
<span class="cm"> * @list_name:	property name that contains a list</span>
<span class="cm"> * @cells_name:	property name that specifies phandles&#39; arguments count</span>
<span class="cm"> * @index:	index of a phandle to parse out</span>
<span class="cm"> * @out_args:	optional pointer to output arguments structure (will be filled)</span>
<span class="cm"> *</span>
<span class="cm"> * This function is useful to parse lists of phandles and their arguments.</span>
<span class="cm"> * Returns 0 on success and fills out_args, on error returns appropriate</span>
<span class="cm"> * errno value.</span>
<span class="cm"> *</span>
<span class="cm"> * Caller is responsible to call of_node_put() on the returned out_args-&gt;node</span>
<span class="cm"> * pointer.</span>
<span class="cm"> *</span>
<span class="cm"> * Example:</span>
<span class="cm"> *</span>
<span class="cm"> * phandle1: node1 {</span>
<span class="cm"> * 	#list-cells = &lt;2&gt;;</span>
<span class="cm"> * }</span>
<span class="cm"> *</span>
<span class="cm"> * phandle2: node2 {</span>
<span class="cm"> * 	#list-cells = &lt;1&gt;;</span>
<span class="cm"> * }</span>
<span class="cm"> *</span>
<span class="cm"> * node3 {</span>
<span class="cm"> * 	list = &lt;&amp;phandle1 1 2 &amp;phandle2 3&gt;;</span>
<span class="cm"> * }</span>
<span class="cm"> *</span>
<span class="cm"> * To get a device_node of the `node2&#39; node you may call this:</span>
<span class="cm"> * of_parse_phandle_with_args(node3, &quot;list&quot;, &quot;#list-cells&quot;, 1, &amp;args);</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">of_parse_phandle_with_args</span><span class="p">(</span><span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">np</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">list_name</span><span class="p">,</span>
				<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">cells_name</span><span class="p">,</span> <span class="kt">int</span> <span class="n">index</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">of_phandle_args</span> <span class="o">*</span><span class="n">out_args</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="n">__be32</span> <span class="o">*</span><span class="n">list</span><span class="p">,</span> <span class="o">*</span><span class="n">list_end</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">size</span><span class="p">,</span> <span class="n">cur_index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">node</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">phandle</span> <span class="n">phandle</span><span class="p">;</span>

	<span class="cm">/* Retrieve the phandle list property */</span>
	<span class="n">list</span> <span class="o">=</span> <span class="n">of_get_property</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">list_name</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">size</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">list</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="n">list_end</span> <span class="o">=</span> <span class="n">list</span> <span class="o">+</span> <span class="n">size</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">list</span><span class="p">);</span>

	<span class="cm">/* Loop over the phandles until all the requested entry is found */</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">list</span> <span class="o">&lt;</span> <span class="n">list_end</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * If phandle is 0, then it is an empty entry with no</span>
<span class="cm">		 * arguments.  Skip forward to the next entry.</span>
<span class="cm">		 */</span>
		<span class="n">phandle</span> <span class="o">=</span> <span class="n">be32_to_cpup</span><span class="p">(</span><span class="n">list</span><span class="o">++</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">phandle</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * Find the provider node and parse the #*-cells</span>
<span class="cm">			 * property to determine the argument length</span>
<span class="cm">			 */</span>
			<span class="n">node</span> <span class="o">=</span> <span class="n">of_find_node_by_phandle</span><span class="p">(</span><span class="n">phandle</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">node</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;%s: could not find phandle</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					 <span class="n">np</span><span class="o">-&gt;</span><span class="n">full_name</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">of_property_read_u32</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">cells_name</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">count</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;%s: could not get %s for %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					 <span class="n">np</span><span class="o">-&gt;</span><span class="n">full_name</span><span class="p">,</span> <span class="n">cells_name</span><span class="p">,</span>
					 <span class="n">node</span><span class="o">-&gt;</span><span class="n">full_name</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="cm">/*</span>
<span class="cm">			 * Make sure that the arguments actually fit in the</span>
<span class="cm">			 * remaining property data length</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">list</span> <span class="o">+</span> <span class="n">count</span> <span class="o">&gt;</span> <span class="n">list_end</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;%s: arguments longer than property</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					 <span class="n">np</span><span class="o">-&gt;</span><span class="n">full_name</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 * All of the error cases above bail out of the loop, so at</span>
<span class="cm">		 * this point, the parsing is successful. If the requested</span>
<span class="cm">		 * index matches, then fill the out_args structure and return,</span>
<span class="cm">		 * or return -ENOENT for an empty entry.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cur_index</span> <span class="o">==</span> <span class="n">index</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">phandle</span><span class="p">)</span>
				<span class="k">return</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">out_args</span><span class="p">)</span> <span class="p">{</span>
				<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">WARN_ON</span><span class="p">(</span><span class="n">count</span> <span class="o">&gt;</span> <span class="n">MAX_PHANDLE_ARGS</span><span class="p">))</span>
					<span class="n">count</span> <span class="o">=</span> <span class="n">MAX_PHANDLE_ARGS</span><span class="p">;</span>
				<span class="n">out_args</span><span class="o">-&gt;</span><span class="n">np</span> <span class="o">=</span> <span class="n">node</span><span class="p">;</span>
				<span class="n">out_args</span><span class="o">-&gt;</span><span class="n">args_count</span> <span class="o">=</span> <span class="n">count</span><span class="p">;</span>
				<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
					<span class="n">out_args</span><span class="o">-&gt;</span><span class="n">args</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">be32_to_cpup</span><span class="p">(</span><span class="n">list</span><span class="o">++</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">of_node_put</span><span class="p">(</span><span class="n">node</span><span class="p">);</span>
		<span class="n">node</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">list</span> <span class="o">+=</span> <span class="n">count</span><span class="p">;</span>
		<span class="n">cur_index</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Loop exited without finding a valid entry; return an error */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">node</span><span class="p">)</span>
		<span class="n">of_node_put</span><span class="p">(</span><span class="n">node</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">of_parse_phandle_with_args</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * prom_add_property - Add a property to a node</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">prom_add_property</span><span class="p">(</span><span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">np</span><span class="p">,</span> <span class="k">struct</span> <span class="n">property</span> <span class="o">*</span><span class="n">prop</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">property</span> <span class="o">**</span><span class="n">next</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">prop</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">write_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">devtree_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">next</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">properties</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">*</span><span class="n">next</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">prop</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="p">(</span><span class="o">*</span><span class="n">next</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* duplicate ! don&#39;t insert it */</span>
			<span class="n">write_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">devtree_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">next</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="o">*</span><span class="n">next</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="o">*</span><span class="n">next</span> <span class="o">=</span> <span class="n">prop</span><span class="p">;</span>
	<span class="n">write_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">devtree_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_PROC_DEVICETREE</span>
	<span class="cm">/* try to add to proc as well if it was initialized */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">pde</span><span class="p">)</span>
		<span class="n">proc_device_tree_add_prop</span><span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">pde</span><span class="p">,</span> <span class="n">prop</span><span class="p">);</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_PROC_DEVICETREE */</span><span class="cp"></span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * prom_remove_property - Remove a property from a node.</span>
<span class="cm"> *</span>
<span class="cm"> * Note that we don&#39;t actually remove it, since we have given out</span>
<span class="cm"> * who-knows-how-many pointers to the data using get-property.</span>
<span class="cm"> * Instead we just move the property to the &quot;dead properties&quot;</span>
<span class="cm"> * list, so it won&#39;t be found any more.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">prom_remove_property</span><span class="p">(</span><span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">np</span><span class="p">,</span> <span class="k">struct</span> <span class="n">property</span> <span class="o">*</span><span class="n">prop</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">property</span> <span class="o">**</span><span class="n">next</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">found</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">write_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">devtree_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">next</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">properties</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">*</span><span class="n">next</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">next</span> <span class="o">==</span> <span class="n">prop</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* found the node */</span>
			<span class="o">*</span><span class="n">next</span> <span class="o">=</span> <span class="n">prop</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
			<span class="n">prop</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">deadprops</span><span class="p">;</span>
			<span class="n">np</span><span class="o">-&gt;</span><span class="n">deadprops</span> <span class="o">=</span> <span class="n">prop</span><span class="p">;</span>
			<span class="n">found</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">next</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="o">*</span><span class="n">next</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">write_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">devtree_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">found</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_PROC_DEVICETREE</span>
	<span class="cm">/* try to remove the proc node as well */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">pde</span><span class="p">)</span>
		<span class="n">proc_device_tree_remove_prop</span><span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">pde</span><span class="p">,</span> <span class="n">prop</span><span class="p">);</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_PROC_DEVICETREE */</span><span class="cp"></span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * prom_update_property - Update a property in a node.</span>
<span class="cm"> *</span>
<span class="cm"> * Note that we don&#39;t actually remove it, since we have given out</span>
<span class="cm"> * who-knows-how-many pointers to the data using get-property.</span>
<span class="cm"> * Instead we just move the property to the &quot;dead properties&quot; list,</span>
<span class="cm"> * and add the new property to the property list</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">prom_update_property</span><span class="p">(</span><span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">np</span><span class="p">,</span>
			 <span class="k">struct</span> <span class="n">property</span> <span class="o">*</span><span class="n">newprop</span><span class="p">,</span>
			 <span class="k">struct</span> <span class="n">property</span> <span class="o">*</span><span class="n">oldprop</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">property</span> <span class="o">**</span><span class="n">next</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">found</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">write_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">devtree_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">next</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">properties</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">*</span><span class="n">next</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">next</span> <span class="o">==</span> <span class="n">oldprop</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* found the node */</span>
			<span class="n">newprop</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">oldprop</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
			<span class="o">*</span><span class="n">next</span> <span class="o">=</span> <span class="n">newprop</span><span class="p">;</span>
			<span class="n">oldprop</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">deadprops</span><span class="p">;</span>
			<span class="n">np</span><span class="o">-&gt;</span><span class="n">deadprops</span> <span class="o">=</span> <span class="n">oldprop</span><span class="p">;</span>
			<span class="n">found</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">next</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="o">*</span><span class="n">next</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">write_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">devtree_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">found</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_PROC_DEVICETREE</span>
	<span class="cm">/* try to add to proc as well if it was initialized */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">pde</span><span class="p">)</span>
		<span class="n">proc_device_tree_update_prop</span><span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">pde</span><span class="p">,</span> <span class="n">newprop</span><span class="p">,</span> <span class="n">oldprop</span><span class="p">);</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_PROC_DEVICETREE */</span><span class="cp"></span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#if defined(CONFIG_OF_DYNAMIC)</span>
<span class="cm">/*</span>
<span class="cm"> * Support for dynamic device trees.</span>
<span class="cm"> *</span>
<span class="cm"> * On some platforms, the device tree can be manipulated at runtime.</span>
<span class="cm"> * The routines in this section support adding, removing and changing</span>
<span class="cm"> * device tree nodes.</span>
<span class="cm"> */</span>

<span class="cm">/**</span>
<span class="cm"> * of_attach_node - Plug a device node into the tree and global list.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">of_attach_node</span><span class="p">(</span><span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">np</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">write_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">devtree_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">np</span><span class="o">-&gt;</span><span class="n">sibling</span> <span class="o">=</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">child</span><span class="p">;</span>
	<span class="n">np</span><span class="o">-&gt;</span><span class="n">allnext</span> <span class="o">=</span> <span class="n">allnodes</span><span class="p">;</span>
	<span class="n">np</span><span class="o">-&gt;</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">child</span> <span class="o">=</span> <span class="n">np</span><span class="p">;</span>
	<span class="n">allnodes</span> <span class="o">=</span> <span class="n">np</span><span class="p">;</span>
	<span class="n">write_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">devtree_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * of_detach_node - &quot;Unplug&quot; a node from the device tree.</span>
<span class="cm"> *</span>
<span class="cm"> * The caller must hold a reference to the node.  The memory associated with</span>
<span class="cm"> * the node is not freed until its refcount goes to zero.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">of_detach_node</span><span class="p">(</span><span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">np</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">parent</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">write_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">devtree_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">parent</span> <span class="o">=</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">parent</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">allnodes</span> <span class="o">==</span> <span class="n">np</span><span class="p">)</span>
		<span class="n">allnodes</span> <span class="o">=</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">allnext</span><span class="p">;</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">prev</span><span class="p">;</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">prev</span> <span class="o">=</span> <span class="n">allnodes</span><span class="p">;</span>
		     <span class="n">prev</span><span class="o">-&gt;</span><span class="n">allnext</span> <span class="o">!=</span> <span class="n">np</span><span class="p">;</span>
		     <span class="n">prev</span> <span class="o">=</span> <span class="n">prev</span><span class="o">-&gt;</span><span class="n">allnext</span><span class="p">)</span>
			<span class="p">;</span>
		<span class="n">prev</span><span class="o">-&gt;</span><span class="n">allnext</span> <span class="o">=</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">allnext</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">child</span> <span class="o">==</span> <span class="n">np</span><span class="p">)</span>
		<span class="n">parent</span><span class="o">-&gt;</span><span class="n">child</span> <span class="o">=</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">sibling</span><span class="p">;</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">prevsib</span><span class="p">;</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">prevsib</span> <span class="o">=</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">child</span><span class="p">;</span>
		     <span class="n">prevsib</span><span class="o">-&gt;</span><span class="n">sibling</span> <span class="o">!=</span> <span class="n">np</span><span class="p">;</span>
		     <span class="n">prevsib</span> <span class="o">=</span> <span class="n">prevsib</span><span class="o">-&gt;</span><span class="n">sibling</span><span class="p">)</span>
			<span class="p">;</span>
		<span class="n">prevsib</span><span class="o">-&gt;</span><span class="n">sibling</span> <span class="o">=</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">sibling</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">of_node_set_flag</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">OF_DETACHED</span><span class="p">);</span>

<span class="nl">out_unlock:</span>
	<span class="n">write_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">devtree_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* defined(CONFIG_OF_DYNAMIC) */</span><span class="cp"></span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">of_alias_add</span><span class="p">(</span><span class="k">struct</span> <span class="n">alias_prop</span> <span class="o">*</span><span class="n">ap</span><span class="p">,</span> <span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">np</span><span class="p">,</span>
			 <span class="kt">int</span> <span class="n">id</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">stem</span><span class="p">,</span> <span class="kt">int</span> <span class="n">stem_len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ap</span><span class="o">-&gt;</span><span class="n">np</span> <span class="o">=</span> <span class="n">np</span><span class="p">;</span>
	<span class="n">ap</span><span class="o">-&gt;</span><span class="n">id</span> <span class="o">=</span> <span class="n">id</span><span class="p">;</span>
	<span class="n">strncpy</span><span class="p">(</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">stem</span><span class="p">,</span> <span class="n">stem</span><span class="p">,</span> <span class="n">stem_len</span><span class="p">);</span>
	<span class="n">ap</span><span class="o">-&gt;</span><span class="n">stem</span><span class="p">[</span><span class="n">stem_len</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">link</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">aliases_lookup</span><span class="p">);</span>
	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;adding DT alias:%s: stem=%s id=%i node=%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		 <span class="n">ap</span><span class="o">-&gt;</span><span class="n">alias</span><span class="p">,</span> <span class="n">ap</span><span class="o">-&gt;</span><span class="n">stem</span><span class="p">,</span> <span class="n">ap</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">,</span> <span class="n">np</span> <span class="o">?</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">full_name</span> <span class="o">:</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * of_alias_scan - Scan all properties of &#39;aliases&#39; node</span>
<span class="cm"> *</span>
<span class="cm"> * The function scans all the properties of &#39;aliases&#39; node and populate</span>
<span class="cm"> * the the global lookup table with the properties.  It returns the</span>
<span class="cm"> * number of alias_prop found, or error code in error case.</span>
<span class="cm"> *</span>
<span class="cm"> * @dt_alloc:	An allocator that provides a virtual address to memory</span>
<span class="cm"> *		for the resulting tree</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">of_alias_scan</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span> <span class="p">(</span><span class="o">*</span><span class="n">dt_alloc</span><span class="p">)(</span><span class="n">u64</span> <span class="n">size</span><span class="p">,</span> <span class="n">u64</span> <span class="n">align</span><span class="p">))</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">property</span> <span class="o">*</span><span class="n">pp</span><span class="p">;</span>

	<span class="n">of_chosen</span> <span class="o">=</span> <span class="n">of_find_node_by_path</span><span class="p">(</span><span class="s">&quot;/chosen&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">of_chosen</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="n">of_chosen</span> <span class="o">=</span> <span class="n">of_find_node_by_path</span><span class="p">(</span><span class="s">&quot;/chosen@0&quot;</span><span class="p">);</span>
	<span class="n">of_aliases</span> <span class="o">=</span> <span class="n">of_find_node_by_path</span><span class="p">(</span><span class="s">&quot;/aliases&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">of_aliases</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">for_each_property_of_node</span><span class="p">(</span><span class="n">of_aliases</span><span class="p">,</span> <span class="n">pp</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">start</span> <span class="o">=</span> <span class="n">pp</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">;</span>
		<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">end</span> <span class="o">=</span> <span class="n">start</span> <span class="o">+</span> <span class="n">strlen</span><span class="p">(</span><span class="n">start</span><span class="p">);</span>
		<span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">np</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">alias_prop</span> <span class="o">*</span><span class="n">ap</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">id</span><span class="p">,</span> <span class="n">len</span><span class="p">;</span>

		<span class="cm">/* Skip those we do not want to proceed */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strcmp</span><span class="p">(</span><span class="n">pp</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="s">&quot;name&quot;</span><span class="p">)</span> <span class="o">||</span>
		    <span class="o">!</span><span class="n">strcmp</span><span class="p">(</span><span class="n">pp</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="s">&quot;phandle&quot;</span><span class="p">)</span> <span class="o">||</span>
		    <span class="o">!</span><span class="n">strcmp</span><span class="p">(</span><span class="n">pp</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="s">&quot;linux,phandle&quot;</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">np</span> <span class="o">=</span> <span class="n">of_find_node_by_path</span><span class="p">(</span><span class="n">pp</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">np</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="cm">/* walk the alias backwards to extract the id and work out</span>
<span class="cm">		 * the &#39;stem&#39; string */</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">isdigit</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">end</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span> <span class="o">&amp;&amp;</span> <span class="n">end</span> <span class="o">&gt;</span> <span class="n">start</span><span class="p">)</span>
			<span class="n">end</span><span class="o">--</span><span class="p">;</span>
		<span class="n">len</span> <span class="o">=</span> <span class="n">end</span> <span class="o">-</span> <span class="n">start</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">kstrtoint</span><span class="p">(</span><span class="n">end</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">id</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="cm">/* Allocate an alias_prop with enough space for the stem */</span>
		<span class="n">ap</span> <span class="o">=</span> <span class="n">dt_alloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">ap</span><span class="p">)</span> <span class="o">+</span> <span class="n">len</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ap</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="n">ap</span><span class="o">-&gt;</span><span class="n">alias</span> <span class="o">=</span> <span class="n">start</span><span class="p">;</span>
		<span class="n">of_alias_add</span><span class="p">(</span><span class="n">ap</span><span class="p">,</span> <span class="n">np</span><span class="p">,</span> <span class="n">id</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * of_alias_get_id - Get alias id for the given device_node</span>
<span class="cm"> * @np:		Pointer to the given device_node</span>
<span class="cm"> * @stem:	Alias stem of the given device_node</span>
<span class="cm"> *</span>
<span class="cm"> * The function travels the lookup table to get alias id for the given</span>
<span class="cm"> * device_node and alias stem.  It returns the alias id if find it.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">of_alias_get_id</span><span class="p">(</span><span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">np</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">stem</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">alias_prop</span> <span class="o">*</span><span class="n">app</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">id</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">of_aliases_mutex</span><span class="p">);</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">app</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">aliases_lookup</span><span class="p">,</span> <span class="n">link</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">app</span><span class="o">-&gt;</span><span class="n">stem</span><span class="p">,</span> <span class="n">stem</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">np</span> <span class="o">==</span> <span class="n">app</span><span class="o">-&gt;</span><span class="n">np</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">id</span> <span class="o">=</span> <span class="n">app</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">of_aliases_mutex</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">id</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">of_alias_get_id</span><span class="p">);</span>

<span class="k">const</span> <span class="n">__be32</span> <span class="o">*</span><span class="nf">of_prop_next_u32</span><span class="p">(</span><span class="k">struct</span> <span class="n">property</span> <span class="o">*</span><span class="n">prop</span><span class="p">,</span> <span class="k">const</span> <span class="n">__be32</span> <span class="o">*</span><span class="n">cur</span><span class="p">,</span>
			       <span class="n">u32</span> <span class="o">*</span><span class="n">pu</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">curv</span> <span class="o">=</span> <span class="n">cur</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">prop</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cur</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">curv</span> <span class="o">=</span> <span class="n">prop</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out_val</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">curv</span> <span class="o">+=</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">cur</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">curv</span> <span class="o">&gt;=</span> <span class="n">prop</span><span class="o">-&gt;</span><span class="n">value</span> <span class="o">+</span> <span class="n">prop</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

<span class="nl">out_val:</span>
	<span class="o">*</span><span class="n">pu</span> <span class="o">=</span> <span class="n">be32_to_cpup</span><span class="p">(</span><span class="n">curv</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">curv</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">of_prop_next_u32</span><span class="p">);</span>

<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="nf">of_prop_next_string</span><span class="p">(</span><span class="k">struct</span> <span class="n">property</span> <span class="o">*</span><span class="n">prop</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">cur</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">curv</span> <span class="o">=</span> <span class="n">cur</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">prop</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cur</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">prop</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">;</span>

	<span class="n">curv</span> <span class="o">+=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">cur</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">curv</span> <span class="o">&gt;=</span> <span class="n">prop</span><span class="o">-&gt;</span><span class="n">value</span> <span class="o">+</span> <span class="n">prop</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">curv</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">of_prop_next_string</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
