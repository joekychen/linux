<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › of › irq.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>irq.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> *  Derived from arch/i386/kernel/irq.c</span>
<span class="cm"> *    Copyright (C) 1992 Linus Torvalds</span>
<span class="cm"> *  Adapted from arch/i386 by Gary Thomas</span>
<span class="cm"> *    Copyright (C) 1995-1996 Gary Thomas (gdt@linuxppc.org)</span>
<span class="cm"> *  Updated and modified by Cort Dougan &lt;cort@fsmlabs.com&gt;</span>
<span class="cm"> *    Copyright (C) 1996-2001 Cort Dougan</span>
<span class="cm"> *  Adapted for Power Macintosh by Paul Mackerras</span>
<span class="cm"> *    Copyright (C) 1996 Paul Mackerras (paulus@cs.anu.edu.au)</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or</span>
<span class="cm"> * modify it under the terms of the GNU General Public License</span>
<span class="cm"> * as published by the Free Software Foundation; either version</span>
<span class="cm"> * 2 of the License, or (at your option) any later version.</span>
<span class="cm"> *</span>
<span class="cm"> * This file contains the code used to make IRQ descriptions in the</span>
<span class="cm"> * device tree to actual irq numbers on an interrupt controller</span>
<span class="cm"> * driver.</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/errno.h&gt;</span>
<span class="cp">#include &lt;linux/list.h&gt;</span>
<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/of.h&gt;</span>
<span class="cp">#include &lt;linux/of_irq.h&gt;</span>
<span class="cp">#include &lt;linux/string.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>

<span class="cm">/**</span>
<span class="cm"> * irq_of_parse_and_map - Parse and map an interrupt into linux virq space</span>
<span class="cm"> * @device: Device node of the device whose interrupt is to be mapped</span>
<span class="cm"> * @index: Index of the interrupt to map</span>
<span class="cm"> *</span>
<span class="cm"> * This function is a wrapper that chains of_irq_map_one() and</span>
<span class="cm"> * irq_create_of_mapping() to make things easier to callers</span>
<span class="cm"> */</span>
<span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">irq_of_parse_and_map</span><span class="p">(</span><span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">index</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">of_irq</span> <span class="n">oirq</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">of_irq_map_one</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">oirq</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">irq_create_of_mapping</span><span class="p">(</span><span class="n">oirq</span><span class="p">.</span><span class="n">controller</span><span class="p">,</span> <span class="n">oirq</span><span class="p">.</span><span class="n">specifier</span><span class="p">,</span>
				     <span class="n">oirq</span><span class="p">.</span><span class="n">size</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">irq_of_parse_and_map</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * of_irq_find_parent - Given a device node, find its interrupt parent node</span>
<span class="cm"> * @child: pointer to device node</span>
<span class="cm"> *</span>
<span class="cm"> * Returns a pointer to the interrupt parent node, or NULL if the interrupt</span>
<span class="cm"> * parent could not be determined.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="nf">of_irq_find_parent</span><span class="p">(</span><span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">child</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
	<span class="k">const</span> <span class="n">__be32</span> <span class="o">*</span><span class="n">parp</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">of_node_get</span><span class="p">(</span><span class="n">child</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">do</span> <span class="p">{</span>
		<span class="n">parp</span> <span class="o">=</span> <span class="n">of_get_property</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="s">&quot;interrupt-parent&quot;</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">parp</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
			<span class="n">p</span> <span class="o">=</span> <span class="n">of_get_parent</span><span class="p">(</span><span class="n">child</span><span class="p">);</span>
		<span class="k">else</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">of_irq_workarounds</span> <span class="o">&amp;</span> <span class="n">OF_IMAP_NO_PHANDLE</span><span class="p">)</span>
				<span class="n">p</span> <span class="o">=</span> <span class="n">of_node_get</span><span class="p">(</span><span class="n">of_irq_dflt_pic</span><span class="p">);</span>
			<span class="k">else</span>
				<span class="n">p</span> <span class="o">=</span> <span class="n">of_find_node_by_phandle</span><span class="p">(</span><span class="n">be32_to_cpup</span><span class="p">(</span><span class="n">parp</span><span class="p">));</span>
		<span class="p">}</span>
		<span class="n">of_node_put</span><span class="p">(</span><span class="n">child</span><span class="p">);</span>
		<span class="n">child</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">p</span> <span class="o">&amp;&amp;</span> <span class="n">of_get_property</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="s">&quot;#interrupt-cells&quot;</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">)</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">p</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * of_irq_map_raw - Low level interrupt tree parsing</span>
<span class="cm"> * @parent:	the device interrupt parent</span>
<span class="cm"> * @intspec:	interrupt specifier (&quot;interrupts&quot; property of the device)</span>
<span class="cm"> * @ointsize:   size of the passed in interrupt specifier</span>
<span class="cm"> * @addr:	address specifier (start of &quot;reg&quot; property of the device)</span>
<span class="cm"> * @out_irq:	structure of_irq filled by this function</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 0 on success and a negative number on error</span>
<span class="cm"> *</span>
<span class="cm"> * This function is a low-level interrupt tree walking function. It</span>
<span class="cm"> * can be used to do a partial walk with synthetized reg and interrupts</span>
<span class="cm"> * properties, for example when resolving PCI interrupts when no device</span>
<span class="cm"> * node exist for the parent.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">of_irq_map_raw</span><span class="p">(</span><span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">parent</span><span class="p">,</span> <span class="k">const</span> <span class="n">__be32</span> <span class="o">*</span><span class="n">intspec</span><span class="p">,</span>
		   <span class="n">u32</span> <span class="n">ointsize</span><span class="p">,</span> <span class="k">const</span> <span class="n">__be32</span> <span class="o">*</span><span class="n">addr</span><span class="p">,</span> <span class="k">struct</span> <span class="n">of_irq</span> <span class="o">*</span><span class="n">out_irq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">ipar</span><span class="p">,</span> <span class="o">*</span><span class="n">tnode</span><span class="p">,</span> <span class="o">*</span><span class="n">old</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">*</span><span class="n">newpar</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">const</span> <span class="n">__be32</span> <span class="o">*</span><span class="n">tmp</span><span class="p">,</span> <span class="o">*</span><span class="n">imap</span><span class="p">,</span> <span class="o">*</span><span class="n">imask</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">intsize</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">addrsize</span><span class="p">,</span> <span class="n">newintsize</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">newaddrsize</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">imaplen</span><span class="p">,</span> <span class="n">match</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;of_irq_map_raw: par=%s,intspec=[0x%08x 0x%08x...],ointsize=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		 <span class="n">parent</span><span class="o">-&gt;</span><span class="n">full_name</span><span class="p">,</span> <span class="n">be32_to_cpup</span><span class="p">(</span><span class="n">intspec</span><span class="p">),</span>
		 <span class="n">be32_to_cpup</span><span class="p">(</span><span class="n">intspec</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="n">ointsize</span><span class="p">);</span>

	<span class="n">ipar</span> <span class="o">=</span> <span class="n">of_node_get</span><span class="p">(</span><span class="n">parent</span><span class="p">);</span>

	<span class="cm">/* First get the #interrupt-cells property of the current cursor</span>
<span class="cm">	 * that tells us how to interpret the passed-in intspec. If there</span>
<span class="cm">	 * is none, we are nice and just walk up the tree</span>
<span class="cm">	 */</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="n">tmp</span> <span class="o">=</span> <span class="n">of_get_property</span><span class="p">(</span><span class="n">ipar</span><span class="p">,</span> <span class="s">&quot;#interrupt-cells&quot;</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tmp</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">intsize</span> <span class="o">=</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="o">*</span><span class="n">tmp</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">tnode</span> <span class="o">=</span> <span class="n">ipar</span><span class="p">;</span>
		<span class="n">ipar</span> <span class="o">=</span> <span class="n">of_irq_find_parent</span><span class="p">(</span><span class="n">ipar</span><span class="p">);</span>
		<span class="n">of_node_put</span><span class="p">(</span><span class="n">tnode</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">ipar</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ipar</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot; -&gt; no parent found !</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;of_irq_map_raw: ipar=%s, size=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ipar</span><span class="o">-&gt;</span><span class="n">full_name</span><span class="p">,</span> <span class="n">intsize</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ointsize</span> <span class="o">!=</span> <span class="n">intsize</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="cm">/* Look for this #address-cells. We have to implement the old linux</span>
<span class="cm">	 * trick of looking for the parent here as some device-trees rely on it</span>
<span class="cm">	 */</span>
	<span class="n">old</span> <span class="o">=</span> <span class="n">of_node_get</span><span class="p">(</span><span class="n">ipar</span><span class="p">);</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="n">tmp</span> <span class="o">=</span> <span class="n">of_get_property</span><span class="p">(</span><span class="n">old</span><span class="p">,</span> <span class="s">&quot;#address-cells&quot;</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="n">tnode</span> <span class="o">=</span> <span class="n">of_get_parent</span><span class="p">(</span><span class="n">old</span><span class="p">);</span>
		<span class="n">of_node_put</span><span class="p">(</span><span class="n">old</span><span class="p">);</span>
		<span class="n">old</span> <span class="o">=</span> <span class="n">tnode</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">old</span> <span class="o">&amp;&amp;</span> <span class="n">tmp</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">of_node_put</span><span class="p">(</span><span class="n">old</span><span class="p">);</span>
	<span class="n">old</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">addrsize</span> <span class="o">=</span> <span class="p">(</span><span class="n">tmp</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="o">?</span> <span class="mi">2</span> <span class="o">:</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="o">*</span><span class="n">tmp</span><span class="p">);</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot; -&gt; addrsize=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">addrsize</span><span class="p">);</span>

	<span class="cm">/* Now start the actual &quot;proper&quot; walk of the interrupt tree */</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">ipar</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Now check if cursor is an interrupt-controller and if it is</span>
<span class="cm">		 * then we are done</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">of_get_property</span><span class="p">(</span><span class="n">ipar</span><span class="p">,</span> <span class="s">&quot;interrupt-controller&quot;</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">)</span> <span class="o">!=</span>
				<span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot; -&gt; got it !</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">intsize</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
				<span class="n">out_irq</span><span class="o">-&gt;</span><span class="n">specifier</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span>
						<span class="n">of_read_number</span><span class="p">(</span><span class="n">intspec</span> <span class="o">+</span><span class="n">i</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
			<span class="n">out_irq</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">=</span> <span class="n">intsize</span><span class="p">;</span>
			<span class="n">out_irq</span><span class="o">-&gt;</span><span class="n">controller</span> <span class="o">=</span> <span class="n">ipar</span><span class="p">;</span>
			<span class="n">of_node_put</span><span class="p">(</span><span class="n">old</span><span class="p">);</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* Now look for an interrupt-map */</span>
		<span class="n">imap</span> <span class="o">=</span> <span class="n">of_get_property</span><span class="p">(</span><span class="n">ipar</span><span class="p">,</span> <span class="s">&quot;interrupt-map&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">imaplen</span><span class="p">);</span>
		<span class="cm">/* No interrupt map, check for an interrupt parent */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">imap</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot; -&gt; no map, getting parent</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">newpar</span> <span class="o">=</span> <span class="n">of_irq_find_parent</span><span class="p">(</span><span class="n">ipar</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">skiplevel</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">imaplen</span> <span class="o">/=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">u32</span><span class="p">);</span>

		<span class="cm">/* Look for a mask */</span>
		<span class="n">imask</span> <span class="o">=</span> <span class="n">of_get_property</span><span class="p">(</span><span class="n">ipar</span><span class="p">,</span> <span class="s">&quot;interrupt-map-mask&quot;</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

		<span class="cm">/* If we were passed no &quot;reg&quot; property and we attempt to parse</span>
<span class="cm">		 * an interrupt-map, then #address-cells must be 0.</span>
<span class="cm">		 * Fail if it&#39;s not.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">addr</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="o">&amp;&amp;</span> <span class="n">addrsize</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot; -&gt; no reg passed in when needed !</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* Parse interrupt-map */</span>
		<span class="n">match</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">imaplen</span> <span class="o">&gt;</span> <span class="p">(</span><span class="n">addrsize</span> <span class="o">+</span> <span class="n">intsize</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">match</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Compare specifiers */</span>
			<span class="n">match</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">addrsize</span> <span class="o">&amp;&amp;</span> <span class="n">match</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">u32</span> <span class="n">mask</span> <span class="o">=</span> <span class="n">imask</span> <span class="o">?</span> <span class="n">imask</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">:</span> <span class="mh">0xffffffffu</span><span class="p">;</span>
				<span class="n">match</span> <span class="o">=</span> <span class="p">((</span><span class="n">addr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">^</span> <span class="n">imap</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">&amp;</span> <span class="n">mask</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">for</span> <span class="p">(;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">addrsize</span> <span class="o">+</span> <span class="n">intsize</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">match</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">u32</span> <span class="n">mask</span> <span class="o">=</span> <span class="n">imask</span> <span class="o">?</span> <span class="n">imask</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">:</span> <span class="mh">0xffffffffu</span><span class="p">;</span>
				<span class="n">match</span> <span class="o">=</span>
				   <span class="p">((</span><span class="n">intspec</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="n">addrsize</span><span class="p">]</span> <span class="o">^</span> <span class="n">imap</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">&amp;</span> <span class="n">mask</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">imap</span> <span class="o">+=</span> <span class="n">addrsize</span> <span class="o">+</span> <span class="n">intsize</span><span class="p">;</span>
			<span class="n">imaplen</span> <span class="o">-=</span> <span class="n">addrsize</span> <span class="o">+</span> <span class="n">intsize</span><span class="p">;</span>

			<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot; -&gt; match=%d (imaplen=%d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">match</span><span class="p">,</span> <span class="n">imaplen</span><span class="p">);</span>

			<span class="cm">/* Get the interrupt parent */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">of_irq_workarounds</span> <span class="o">&amp;</span> <span class="n">OF_IMAP_NO_PHANDLE</span><span class="p">)</span>
				<span class="n">newpar</span> <span class="o">=</span> <span class="n">of_node_get</span><span class="p">(</span><span class="n">of_irq_dflt_pic</span><span class="p">);</span>
			<span class="k">else</span>
				<span class="n">newpar</span> <span class="o">=</span> <span class="n">of_find_node_by_phandle</span><span class="p">(</span><span class="n">be32_to_cpup</span><span class="p">(</span><span class="n">imap</span><span class="p">));</span>
			<span class="n">imap</span><span class="o">++</span><span class="p">;</span>
			<span class="o">--</span><span class="n">imaplen</span><span class="p">;</span>

			<span class="cm">/* Check if not found */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">newpar</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot; -&gt; imap parent not found !</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
				<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="cm">/* Get #interrupt-cells and #address-cells of new</span>
<span class="cm">			 * parent</span>
<span class="cm">			 */</span>
			<span class="n">tmp</span> <span class="o">=</span> <span class="n">of_get_property</span><span class="p">(</span><span class="n">newpar</span><span class="p">,</span> <span class="s">&quot;#interrupt-cells&quot;</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">tmp</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot; -&gt; parent lacks #interrupt-cells!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
				<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">newintsize</span> <span class="o">=</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="o">*</span><span class="n">tmp</span><span class="p">);</span>
			<span class="n">tmp</span> <span class="o">=</span> <span class="n">of_get_property</span><span class="p">(</span><span class="n">newpar</span><span class="p">,</span> <span class="s">&quot;#address-cells&quot;</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
			<span class="n">newaddrsize</span> <span class="o">=</span> <span class="p">(</span><span class="n">tmp</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="o">*</span><span class="n">tmp</span><span class="p">);</span>

			<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot; -&gt; newintsize=%d, newaddrsize=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			    <span class="n">newintsize</span><span class="p">,</span> <span class="n">newaddrsize</span><span class="p">);</span>

			<span class="cm">/* Check for malformed properties */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">imaplen</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">newaddrsize</span> <span class="o">+</span> <span class="n">newintsize</span><span class="p">))</span>
				<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>

			<span class="n">imap</span> <span class="o">+=</span> <span class="n">newaddrsize</span> <span class="o">+</span> <span class="n">newintsize</span><span class="p">;</span>
			<span class="n">imaplen</span> <span class="o">-=</span> <span class="n">newaddrsize</span> <span class="o">+</span> <span class="n">newintsize</span><span class="p">;</span>

			<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot; -&gt; imaplen=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">imaplen</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">match</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>

		<span class="n">of_node_put</span><span class="p">(</span><span class="n">old</span><span class="p">);</span>
		<span class="n">old</span> <span class="o">=</span> <span class="n">of_node_get</span><span class="p">(</span><span class="n">newpar</span><span class="p">);</span>
		<span class="n">addrsize</span> <span class="o">=</span> <span class="n">newaddrsize</span><span class="p">;</span>
		<span class="n">intsize</span> <span class="o">=</span> <span class="n">newintsize</span><span class="p">;</span>
		<span class="n">intspec</span> <span class="o">=</span> <span class="n">imap</span> <span class="o">-</span> <span class="n">intsize</span><span class="p">;</span>
		<span class="n">addr</span> <span class="o">=</span> <span class="n">intspec</span> <span class="o">-</span> <span class="n">addrsize</span><span class="p">;</span>

	<span class="nl">skiplevel:</span>
		<span class="cm">/* Iterate again with new parent */</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot; -&gt; new parent: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">newpar</span> <span class="o">?</span> <span class="n">newpar</span><span class="o">-&gt;</span><span class="n">full_name</span> <span class="o">:</span> <span class="s">&quot;&lt;&gt;&quot;</span><span class="p">);</span>
		<span class="n">of_node_put</span><span class="p">(</span><span class="n">ipar</span><span class="p">);</span>
		<span class="n">ipar</span> <span class="o">=</span> <span class="n">newpar</span><span class="p">;</span>
		<span class="n">newpar</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
 <span class="nl">fail:</span>
	<span class="n">of_node_put</span><span class="p">(</span><span class="n">ipar</span><span class="p">);</span>
	<span class="n">of_node_put</span><span class="p">(</span><span class="n">old</span><span class="p">);</span>
	<span class="n">of_node_put</span><span class="p">(</span><span class="n">newpar</span><span class="p">);</span>

	<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">of_irq_map_raw</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * of_irq_map_one - Resolve an interrupt for a device</span>
<span class="cm"> * @device: the device whose interrupt is to be resolved</span>
<span class="cm"> * @index: index of the interrupt to resolve</span>
<span class="cm"> * @out_irq: structure of_irq filled by this function</span>
<span class="cm"> *</span>
<span class="cm"> * This function resolves an interrupt, walking the tree, for a given</span>
<span class="cm"> * device-tree node. It&#39;s the high level pendant to of_irq_map_raw().</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">of_irq_map_one</span><span class="p">(</span><span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">device</span><span class="p">,</span> <span class="kt">int</span> <span class="n">index</span><span class="p">,</span> <span class="k">struct</span> <span class="n">of_irq</span> <span class="o">*</span><span class="n">out_irq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
	<span class="k">const</span> <span class="n">__be32</span> <span class="o">*</span><span class="n">intspec</span><span class="p">,</span> <span class="o">*</span><span class="n">tmp</span><span class="p">,</span> <span class="o">*</span><span class="n">addr</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">intsize</span><span class="p">,</span> <span class="n">intlen</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">res</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;of_irq_map_one: dev=%s, index=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">device</span><span class="o">-&gt;</span><span class="n">full_name</span><span class="p">,</span> <span class="n">index</span><span class="p">);</span>

	<span class="cm">/* OldWorld mac stuff is &quot;special&quot;, handle out of line */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">of_irq_workarounds</span> <span class="o">&amp;</span> <span class="n">OF_IMAP_OLDWORLD_MAC</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">of_irq_map_oldworld</span><span class="p">(</span><span class="n">device</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">out_irq</span><span class="p">);</span>

	<span class="cm">/* Get the interrupts property */</span>
	<span class="n">intspec</span> <span class="o">=</span> <span class="n">of_get_property</span><span class="p">(</span><span class="n">device</span><span class="p">,</span> <span class="s">&quot;interrupts&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">intlen</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">intspec</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="n">intlen</span> <span class="o">/=</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">intspec</span><span class="p">);</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot; intspec=%d intlen=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">be32_to_cpup</span><span class="p">(</span><span class="n">intspec</span><span class="p">),</span> <span class="n">intlen</span><span class="p">);</span>

	<span class="cm">/* Get the reg property (if any) */</span>
	<span class="n">addr</span> <span class="o">=</span> <span class="n">of_get_property</span><span class="p">(</span><span class="n">device</span><span class="p">,</span> <span class="s">&quot;reg&quot;</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

	<span class="cm">/* Look for the interrupt parent. */</span>
	<span class="n">p</span> <span class="o">=</span> <span class="n">of_irq_find_parent</span><span class="p">(</span><span class="n">device</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">p</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="cm">/* Get size of interrupt specifier */</span>
	<span class="n">tmp</span> <span class="o">=</span> <span class="n">of_get_property</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="s">&quot;#interrupt-cells&quot;</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tmp</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="n">intsize</span> <span class="o">=</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="o">*</span><span class="n">tmp</span><span class="p">);</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot; intsize=%d intlen=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">intsize</span><span class="p">,</span> <span class="n">intlen</span><span class="p">);</span>

	<span class="cm">/* Check index */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">intsize</span> <span class="o">&gt;</span> <span class="n">intlen</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="cm">/* Get new specifier and map it */</span>
	<span class="n">res</span> <span class="o">=</span> <span class="n">of_irq_map_raw</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">intspec</span> <span class="o">+</span> <span class="n">index</span> <span class="o">*</span> <span class="n">intsize</span><span class="p">,</span> <span class="n">intsize</span><span class="p">,</span>
			     <span class="n">addr</span><span class="p">,</span> <span class="n">out_irq</span><span class="p">);</span>
 <span class="nl">out:</span>
	<span class="n">of_node_put</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">res</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">of_irq_map_one</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * of_irq_to_resource - Decode a node&#39;s IRQ and return it as a resource</span>
<span class="cm"> * @dev: pointer to device tree node</span>
<span class="cm"> * @index: zero-based index of the irq</span>
<span class="cm"> * @r: pointer to resource structure to return result into.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">of_irq_to_resource</span><span class="p">(</span><span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">index</span><span class="p">,</span> <span class="k">struct</span> <span class="n">resource</span> <span class="o">*</span><span class="n">r</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">irq</span> <span class="o">=</span> <span class="n">irq_of_parse_and_map</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">index</span><span class="p">);</span>

	<span class="cm">/* Only dereference the resource if both the</span>
<span class="cm">	 * resource and the irq are valid. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">r</span> <span class="o">&amp;&amp;</span> <span class="n">irq</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * Get optional &quot;interrupts-names&quot; property to add a name</span>
<span class="cm">		 * to the resource.</span>
<span class="cm">		 */</span>
		<span class="n">of_property_read_string_index</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;interrupt-names&quot;</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span>
					      <span class="o">&amp;</span><span class="n">name</span><span class="p">);</span>

		<span class="n">r</span><span class="o">-&gt;</span><span class="n">start</span> <span class="o">=</span> <span class="n">r</span><span class="o">-&gt;</span><span class="n">end</span> <span class="o">=</span> <span class="n">irq</span><span class="p">;</span>
		<span class="n">r</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">=</span> <span class="n">IORESOURCE_IRQ</span><span class="p">;</span>
		<span class="n">r</span><span class="o">-&gt;</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span> <span class="o">?</span> <span class="n">name</span> <span class="o">:</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">full_name</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">irq</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">of_irq_to_resource</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * of_irq_count - Count the number of IRQs a node uses</span>
<span class="cm"> * @dev: pointer to device tree node</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">of_irq_count</span><span class="p">(</span><span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">nr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">of_irq_to_resource</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">nr</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">))</span>
		<span class="n">nr</span><span class="o">++</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">nr</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * of_irq_to_resource_table - Fill in resource table with node&#39;s IRQ info</span>
<span class="cm"> * @dev: pointer to device tree node</span>
<span class="cm"> * @res: array of resources to fill in</span>
<span class="cm"> * @nr_irqs: the number of IRQs (and upper bound for num of @res elements)</span>
<span class="cm"> *</span>
<span class="cm"> * Returns the size of the filled in table (up to @nr_irqs).</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">of_irq_to_resource_table</span><span class="p">(</span><span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">resource</span> <span class="o">*</span><span class="n">res</span><span class="p">,</span>
		<span class="kt">int</span> <span class="n">nr_irqs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nr_irqs</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">,</span> <span class="n">res</span><span class="o">++</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">of_irq_to_resource</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">res</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">i</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">intc_desc</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">list</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">device_node</span>	<span class="o">*</span><span class="n">dev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">device_node</span>	<span class="o">*</span><span class="n">interrupt_parent</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * of_irq_init - Scan and init matching interrupt controllers in DT</span>
<span class="cm"> * @matches: 0 terminated array of nodes to match and init function to call</span>
<span class="cm"> *</span>
<span class="cm"> * This function scans the device tree for matching interrupt controller nodes,</span>
<span class="cm"> * and calls their initialization functions in order with parents first.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">__init</span> <span class="nf">of_irq_init</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">of_device_id</span> <span class="o">*</span><span class="n">matches</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">device_node</span> <span class="o">*</span><span class="n">np</span><span class="p">,</span> <span class="o">*</span><span class="n">parent</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">intc_desc</span> <span class="o">*</span><span class="n">desc</span><span class="p">,</span> <span class="o">*</span><span class="n">temp_desc</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">intc_desc_list</span><span class="p">,</span> <span class="n">intc_parent_list</span><span class="p">;</span>

	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">intc_desc_list</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">intc_parent_list</span><span class="p">);</span>

	<span class="n">for_each_matching_node</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">matches</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">of_find_property</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="s">&quot;interrupt-controller&quot;</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * Here, we allocate and populate an intc_desc with the node</span>
<span class="cm">		 * pointer, interrupt-parent device_node etc.</span>
<span class="cm">		 */</span>
		<span class="n">desc</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">desc</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">WARN_ON</span><span class="p">(</span><span class="o">!</span><span class="n">desc</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">err</span><span class="p">;</span>

		<span class="n">desc</span><span class="o">-&gt;</span><span class="n">dev</span> <span class="o">=</span> <span class="n">np</span><span class="p">;</span>
		<span class="n">desc</span><span class="o">-&gt;</span><span class="n">interrupt_parent</span> <span class="o">=</span> <span class="n">of_irq_find_parent</span><span class="p">(</span><span class="n">np</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">interrupt_parent</span> <span class="o">==</span> <span class="n">np</span><span class="p">)</span>
			<span class="n">desc</span><span class="o">-&gt;</span><span class="n">interrupt_parent</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">intc_desc_list</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * The root irq controller is the one without an interrupt-parent.</span>
<span class="cm">	 * That one goes first, followed by the controllers that reference it,</span>
<span class="cm">	 * followed by the ones that reference the 2nd level controllers, etc.</span>
<span class="cm">	 */</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">intc_desc_list</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Process all controllers with the current &#39;parent&#39;.</span>
<span class="cm">		 * First pass will be looking for NULL as the parent.</span>
<span class="cm">		 * The assumption is that NULL parent means a root controller.</span>
<span class="cm">		 */</span>
		<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">desc</span><span class="p">,</span> <span class="n">temp_desc</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">intc_desc_list</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">const</span> <span class="k">struct</span> <span class="n">of_device_id</span> <span class="o">*</span><span class="n">match</span><span class="p">;</span>
			<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
			<span class="n">of_irq_init_cb_t</span> <span class="n">irq_init_cb</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">interrupt_parent</span> <span class="o">!=</span> <span class="n">parent</span><span class="p">)</span>
				<span class="k">continue</span><span class="p">;</span>

			<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
			<span class="n">match</span> <span class="o">=</span> <span class="n">of_match_node</span><span class="p">(</span><span class="n">matches</span><span class="p">,</span> <span class="n">desc</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">WARN</span><span class="p">(</span><span class="o">!</span><span class="n">match</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span>
			    <span class="s">&quot;of_irq_init: no init function for %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			    <span class="n">match</span><span class="o">-&gt;</span><span class="n">compatible</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">kfree</span><span class="p">(</span><span class="n">desc</span><span class="p">);</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;of_irq_init: init %s @ %p, parent %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				 <span class="n">match</span><span class="o">-&gt;</span><span class="n">compatible</span><span class="p">,</span>
				 <span class="n">desc</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">desc</span><span class="o">-&gt;</span><span class="n">interrupt_parent</span><span class="p">);</span>
			<span class="n">irq_init_cb</span> <span class="o">=</span> <span class="n">match</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">irq_init_cb</span><span class="p">(</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">desc</span><span class="o">-&gt;</span><span class="n">interrupt_parent</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">kfree</span><span class="p">(</span><span class="n">desc</span><span class="p">);</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="cm">/*</span>
<span class="cm">			 * This one is now set up; add it to the parent list so</span>
<span class="cm">			 * its children can get processed in a subsequent pass.</span>
<span class="cm">			 */</span>
			<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">intc_parent_list</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="cm">/* Get the next pending parent that might have children */</span>
		<span class="n">desc</span> <span class="o">=</span> <span class="n">list_first_entry</span><span class="p">(</span><span class="o">&amp;</span><span class="n">intc_parent_list</span><span class="p">,</span> <span class="n">typeof</span><span class="p">(</span><span class="o">*</span><span class="n">desc</span><span class="p">),</span> <span class="n">list</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">intc_parent_list</span><span class="p">)</span> <span class="o">||</span> <span class="o">!</span><span class="n">desc</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;of_irq_init: children remain, but no parents</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
		<span class="n">parent</span> <span class="o">=</span> <span class="n">desc</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">desc</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">desc</span><span class="p">,</span> <span class="n">temp_desc</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">intc_parent_list</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">desc</span><span class="p">);</span>
	<span class="p">}</span>
<span class="nl">err:</span>
	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">desc</span><span class="p">,</span> <span class="n">temp_desc</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">intc_desc_list</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">desc</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
