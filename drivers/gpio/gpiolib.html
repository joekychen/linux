<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › gpio › gpiolib.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>gpiolib.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/interrupt.h&gt;</span>
<span class="cp">#include &lt;linux/irq.h&gt;</span>
<span class="cp">#include &lt;linux/spinlock.h&gt;</span>
<span class="cp">#include &lt;linux/device.h&gt;</span>
<span class="cp">#include &lt;linux/err.h&gt;</span>
<span class="cp">#include &lt;linux/debugfs.h&gt;</span>
<span class="cp">#include &lt;linux/seq_file.h&gt;</span>
<span class="cp">#include &lt;linux/gpio.h&gt;</span>
<span class="cp">#include &lt;linux/of_gpio.h&gt;</span>
<span class="cp">#include &lt;linux/idr.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>

<span class="cp">#define CREATE_TRACE_POINTS</span>
<span class="cp">#include &lt;trace/events/gpio.h&gt;</span>

<span class="cm">/* Optional implementation infrastructure for GPIO interfaces.</span>
<span class="cm"> *</span>
<span class="cm"> * Platforms may want to use this if they tend to use very many GPIOs</span>
<span class="cm"> * that aren&#39;t part of a System-On-Chip core; or across I2C/SPI/etc.</span>
<span class="cm"> *</span>
<span class="cm"> * When kernel footprint or instruction count is an issue, simpler</span>
<span class="cm"> * implementations may be preferred.  The GPIO programming interface</span>
<span class="cm"> * allows for inlining speed-critical get/set operations for common</span>
<span class="cm"> * cases, so that access to SOC-integrated GPIOs can sometimes cost</span>
<span class="cm"> * only an instruction or two per bit.</span>
<span class="cm"> */</span>


<span class="cm">/* When debugging, extend minimal trust to callers and platform code.</span>
<span class="cm"> * Also emit diagnostic messages that may help initial bringup, when</span>
<span class="cm"> * board setup or driver bugs are most common.</span>
<span class="cm"> *</span>
<span class="cm"> * Otherwise, minimize overhead in what may be bitbanging codepaths.</span>
<span class="cm"> */</span>
<span class="cp">#ifdef	DEBUG</span>
<span class="cp">#define	extra_checks	1</span>
<span class="cp">#else</span>
<span class="cp">#define	extra_checks	0</span>
<span class="cp">#endif</span>

<span class="cm">/* gpio_lock prevents conflicts during gpio_desc[] table updates.</span>
<span class="cm"> * While any GPIO is requested, its gpio_chip is not removable;</span>
<span class="cm"> * each GPIO&#39;s &quot;requested&quot; flag serves as a lock and refcount.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">DEFINE_SPINLOCK</span><span class="p">(</span><span class="n">gpio_lock</span><span class="p">);</span>

<span class="k">struct</span> <span class="n">gpio_desc</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">gpio_chip</span>	<span class="o">*</span><span class="n">chip</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">flags</span><span class="p">;</span>
<span class="cm">/* flag symbols are bit numbers */</span>
<span class="cp">#define FLAG_REQUESTED	0</span>
<span class="cp">#define FLAG_IS_OUT	1</span>
<span class="cp">#define FLAG_RESERVED	2</span>
<span class="cp">#define FLAG_EXPORT	3	</span><span class="cm">/* protected by sysfs_lock */</span><span class="cp"></span>
<span class="cp">#define FLAG_SYSFS	4	</span><span class="cm">/* exported via /sys/class/gpio/control */</span><span class="cp"></span>
<span class="cp">#define FLAG_TRIG_FALL	5	</span><span class="cm">/* trigger on falling edge */</span><span class="cp"></span>
<span class="cp">#define FLAG_TRIG_RISE	6	</span><span class="cm">/* trigger on rising edge */</span><span class="cp"></span>
<span class="cp">#define FLAG_ACTIVE_LOW	7	</span><span class="cm">/* sysfs value has active low */</span><span class="cp"></span>
<span class="cp">#define FLAG_OPEN_DRAIN	8	</span><span class="cm">/* Gpio is open drain type */</span><span class="cp"></span>
<span class="cp">#define FLAG_OPEN_SOURCE 9	</span><span class="cm">/* Gpio is open source type */</span><span class="cp"></span>

<span class="cp">#define ID_SHIFT	16	</span><span class="cm">/* add new flags before this one */</span><span class="cp"></span>

<span class="cp">#define GPIO_FLAGS_MASK		((1 &lt;&lt; ID_SHIFT) - 1)</span>
<span class="cp">#define GPIO_TRIGGER_MASK	(BIT(FLAG_TRIG_FALL) | BIT(FLAG_TRIG_RISE))</span>

<span class="cp">#ifdef CONFIG_DEBUG_FS</span>
	<span class="k">const</span> <span class="kt">char</span>		<span class="o">*</span><span class="n">label</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="p">};</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">gpio_desc</span> <span class="n">gpio_desc</span><span class="p">[</span><span class="n">ARCH_NR_GPIOS</span><span class="p">];</span>

<span class="cp">#ifdef CONFIG_GPIO_SYSFS</span>
<span class="k">static</span> <span class="n">DEFINE_IDR</span><span class="p">(</span><span class="n">dirent_idr</span><span class="p">);</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">desc_set_label</span><span class="p">(</span><span class="k">struct</span> <span class="n">gpio_desc</span> <span class="o">*</span><span class="n">d</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">label</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef CONFIG_DEBUG_FS</span>
	<span class="n">d</span><span class="o">-&gt;</span><span class="n">label</span> <span class="o">=</span> <span class="n">label</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="cm">/* Warn when drivers omit gpio_request() calls -- legal but ill-advised</span>
<span class="cm"> * when setting direction, and otherwise illegal.  Until board setup code</span>
<span class="cm"> * and drivers use explicit requests everywhere (which won&#39;t happen when</span>
<span class="cm"> * those calls have no teeth) we can&#39;t avoid autorequesting.  This nag</span>
<span class="cm"> * message should motivate switching to explicit requests... so should</span>
<span class="cm"> * the weaker cleanup after faults, compared to gpio_request().</span>
<span class="cm"> *</span>
<span class="cm"> * NOTE: the autorequest mechanism is going away; at this point it&#39;s</span>
<span class="cm"> * only &quot;legal&quot; in the sense that (old) code using it won&#39;t break yet,</span>
<span class="cm"> * but instead only triggers a WARN() stack dump.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">gpio_ensure_requested</span><span class="p">(</span><span class="k">struct</span> <span class="n">gpio_desc</span> <span class="o">*</span><span class="n">desc</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">offset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">gpio_chip</span> <span class="o">*</span><span class="n">chip</span> <span class="o">=</span> <span class="n">desc</span><span class="o">-&gt;</span><span class="n">chip</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">int</span> <span class="n">gpio</span> <span class="o">=</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">base</span> <span class="o">+</span> <span class="n">offset</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">WARN</span><span class="p">(</span><span class="n">test_and_set_bit</span><span class="p">(</span><span class="n">FLAG_REQUESTED</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span>
			<span class="s">&quot;autorequest GPIO-%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">gpio</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">try_module_get</span><span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">owner</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;GPIO-%d: module can&#39;t be gotten </span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">gpio</span><span class="p">);</span>
			<span class="n">clear_bit</span><span class="p">(</span><span class="n">FLAG_REQUESTED</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
			<span class="cm">/* lose */</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">desc_set_label</span><span class="p">(</span><span class="n">desc</span><span class="p">,</span> <span class="s">&quot;[auto]&quot;</span><span class="p">);</span>
		<span class="cm">/* caller must chip-&gt;request() w/o spinlock */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">request</span><span class="p">)</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* caller holds gpio_lock *OR* gpio is marked as requested */</span>
<span class="k">struct</span> <span class="n">gpio_chip</span> <span class="o">*</span><span class="nf">gpio_to_chip</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">gpio</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">gpio_desc</span><span class="p">[</span><span class="n">gpio</span><span class="p">].</span><span class="n">chip</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* dynamic allocation of GPIOs, e.g. on a hotplugged device */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">gpiochip_find_base</span><span class="p">(</span><span class="kt">int</span> <span class="n">ngpio</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">spare</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">base</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOSPC</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">ARCH_NR_GPIOS</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">gpio_desc</span> <span class="o">*</span><span class="n">desc</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">gpio_desc</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="k">struct</span> <span class="n">gpio_chip</span> <span class="o">*</span><span class="n">chip</span> <span class="o">=</span> <span class="n">desc</span><span class="o">-&gt;</span><span class="n">chip</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">chip</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">test_bit</span><span class="p">(</span><span class="n">FLAG_RESERVED</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">spare</span><span class="o">++</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">spare</span> <span class="o">==</span> <span class="n">ngpio</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">base</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">spare</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">chip</span><span class="p">)</span>
				<span class="n">i</span> <span class="o">-=</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">ngpio</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">gpio_is_valid</span><span class="p">(</span><span class="n">base</span><span class="p">))</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;%s: found new base at %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">base</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">base</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * gpiochip_reserve() - reserve range of gpios to use with platform code only</span>
<span class="cm"> * @start: starting gpio number</span>
<span class="cm"> * @ngpio: number of gpios to reserve</span>
<span class="cm"> * Context: platform init, potentially before irqs or kmalloc will work</span>
<span class="cm"> *</span>
<span class="cm"> * Returns a negative errno if any gpio within the range is already reserved</span>
<span class="cm"> * or registered, else returns zero as a success code.  Use this function</span>
<span class="cm"> * to mark a range of gpios as unavailable for dynamic gpio number allocation,</span>
<span class="cm"> * for example because its driver support is not yet loaded.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">__init</span> <span class="nf">gpiochip_reserve</span><span class="p">(</span><span class="kt">int</span> <span class="n">start</span><span class="p">,</span> <span class="kt">int</span> <span class="n">ngpio</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">gpio_is_valid</span><span class="p">(</span><span class="n">start</span><span class="p">)</span> <span class="o">||</span> <span class="o">!</span><span class="n">gpio_is_valid</span><span class="p">(</span><span class="n">start</span> <span class="o">+</span> <span class="n">ngpio</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gpio_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">start</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">start</span> <span class="o">+</span> <span class="n">ngpio</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">gpio_desc</span> <span class="o">*</span><span class="n">desc</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">gpio_desc</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">chip</span> <span class="o">||</span> <span class="n">test_bit</span><span class="p">(</span><span class="n">FLAG_RESERVED</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">err</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">set_bit</span><span class="p">(</span><span class="n">FLAG_RESERVED</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;%s: reserved gpios from %d to %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		 <span class="n">__func__</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">start</span> <span class="o">+</span> <span class="n">ngpio</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
<span class="nl">err:</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gpio_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_GPIO_SYSFS</span>

<span class="cm">/* lock protects against unexport_gpio() being called while</span>
<span class="cm"> * sysfs files are active.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">DEFINE_MUTEX</span><span class="p">(</span><span class="n">sysfs_lock</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * /sys/class/gpio/gpioN... only for GPIOs that are exported</span>
<span class="cm"> *   /direction</span>
<span class="cm"> *      * MAY BE OMITTED if kernel won&#39;t allow direction changes</span>
<span class="cm"> *      * is read/write as &quot;in&quot; or &quot;out&quot;</span>
<span class="cm"> *      * may also be written as &quot;high&quot; or &quot;low&quot;, initializing</span>
<span class="cm"> *        output value as specified (&quot;out&quot; implies &quot;low&quot;)</span>
<span class="cm"> *   /value</span>
<span class="cm"> *      * always readable, subject to hardware behavior</span>
<span class="cm"> *      * may be writable, as zero/nonzero</span>
<span class="cm"> *   /edge</span>
<span class="cm"> *      * configures behavior of poll(2) on /value</span>
<span class="cm"> *      * available only if pin can generate IRQs on input</span>
<span class="cm"> *      * is read/write as &quot;none&quot;, &quot;falling&quot;, &quot;rising&quot;, or &quot;both&quot;</span>
<span class="cm"> *   /active_low</span>
<span class="cm"> *      * configures polarity of /value</span>
<span class="cm"> *      * is read/write as zero/nonzero</span>
<span class="cm"> *      * also affects existing and subsequent &quot;falling&quot; and &quot;rising&quot;</span>
<span class="cm"> *        /edge configuration</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">gpio_direction_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">gpio_desc</span>	<span class="o">*</span><span class="n">desc</span> <span class="o">=</span> <span class="n">dev_get_drvdata</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="kt">ssize_t</span>			<span class="n">status</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sysfs_lock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">test_bit</span><span class="p">(</span><span class="n">FLAG_EXPORT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">))</span>
		<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">test_bit</span><span class="p">(</span><span class="n">FLAG_IS_OUT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">)</span>
				<span class="o">?</span> <span class="s">&quot;out&quot;</span> <span class="o">:</span> <span class="s">&quot;in&quot;</span><span class="p">);</span>

	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sysfs_lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">gpio_direction_store</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">gpio_desc</span>	<span class="o">*</span><span class="n">desc</span> <span class="o">=</span> <span class="n">dev_get_drvdata</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="kt">unsigned</span>		<span class="n">gpio</span> <span class="o">=</span> <span class="n">desc</span> <span class="o">-</span> <span class="n">gpio_desc</span><span class="p">;</span>
	<span class="kt">ssize_t</span>			<span class="n">status</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sysfs_lock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">test_bit</span><span class="p">(</span><span class="n">FLAG_EXPORT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">))</span>
		<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">sysfs_streq</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;high&quot;</span><span class="p">))</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">gpio_direction_output</span><span class="p">(</span><span class="n">gpio</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">sysfs_streq</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;out&quot;</span><span class="p">)</span> <span class="o">||</span> <span class="n">sysfs_streq</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;low&quot;</span><span class="p">))</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">gpio_direction_output</span><span class="p">(</span><span class="n">gpio</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">sysfs_streq</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;in&quot;</span><span class="p">))</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">gpio_direction_input</span><span class="p">(</span><span class="n">gpio</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sysfs_lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">status</span> <span class="o">?</span> <span class="o">:</span> <span class="n">size</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="cm">/* const */</span> <span class="n">DEVICE_ATTR</span><span class="p">(</span><span class="n">direction</span><span class="p">,</span> <span class="mo">0644</span><span class="p">,</span>
		<span class="n">gpio_direction_show</span><span class="p">,</span> <span class="n">gpio_direction_store</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">gpio_value_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">gpio_desc</span>	<span class="o">*</span><span class="n">desc</span> <span class="o">=</span> <span class="n">dev_get_drvdata</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="kt">unsigned</span>		<span class="n">gpio</span> <span class="o">=</span> <span class="n">desc</span> <span class="o">-</span> <span class="n">gpio_desc</span><span class="p">;</span>
	<span class="kt">ssize_t</span>			<span class="n">status</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sysfs_lock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">test_bit</span><span class="p">(</span><span class="n">FLAG_EXPORT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">value</span><span class="p">;</span>

		<span class="n">value</span> <span class="o">=</span> <span class="o">!!</span><span class="n">gpio_get_value_cansleep</span><span class="p">(</span><span class="n">gpio</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">FLAG_ACTIVE_LOW</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">))</span>
			<span class="n">value</span> <span class="o">=</span> <span class="o">!</span><span class="n">value</span><span class="p">;</span>

		<span class="n">status</span> <span class="o">=</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">value</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sysfs_lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">gpio_value_store</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">gpio_desc</span>	<span class="o">*</span><span class="n">desc</span> <span class="o">=</span> <span class="n">dev_get_drvdata</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="kt">unsigned</span>		<span class="n">gpio</span> <span class="o">=</span> <span class="n">desc</span> <span class="o">-</span> <span class="n">gpio_desc</span><span class="p">;</span>
	<span class="kt">ssize_t</span>			<span class="n">status</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sysfs_lock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">test_bit</span><span class="p">(</span><span class="n">FLAG_EXPORT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">))</span>
		<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">test_bit</span><span class="p">(</span><span class="n">FLAG_IS_OUT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">))</span>
		<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="kt">long</span>		<span class="n">value</span><span class="p">;</span>

		<span class="n">status</span> <span class="o">=</span> <span class="n">strict_strtol</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">value</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">FLAG_ACTIVE_LOW</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">))</span>
				<span class="n">value</span> <span class="o">=</span> <span class="o">!</span><span class="n">value</span><span class="p">;</span>
			<span class="n">gpio_set_value_cansleep</span><span class="p">(</span><span class="n">gpio</span><span class="p">,</span> <span class="n">value</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">);</span>
			<span class="n">status</span> <span class="o">=</span> <span class="n">size</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sysfs_lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="n">DEVICE_ATTR</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="mo">0644</span><span class="p">,</span>
		<span class="n">gpio_value_show</span><span class="p">,</span> <span class="n">gpio_value_store</span><span class="p">);</span>

<span class="k">static</span> <span class="n">irqreturn_t</span> <span class="nf">gpio_sysfs_irq</span><span class="p">(</span><span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">priv</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sysfs_dirent</span>	<span class="o">*</span><span class="n">value_sd</span> <span class="o">=</span> <span class="n">priv</span><span class="p">;</span>

	<span class="n">sysfs_notify_dirent</span><span class="p">(</span><span class="n">value_sd</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">IRQ_HANDLED</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">gpio_setup_irq</span><span class="p">(</span><span class="k">struct</span> <span class="n">gpio_desc</span> <span class="o">*</span><span class="n">desc</span><span class="p">,</span> <span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">gpio_flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sysfs_dirent</span>	<span class="o">*</span><span class="n">value_sd</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">irq_flags</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">ret</span><span class="p">,</span> <span class="n">irq</span><span class="p">,</span> <span class="n">id</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">GPIO_TRIGGER_MASK</span><span class="p">)</span> <span class="o">==</span> <span class="n">gpio_flags</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">irq</span> <span class="o">=</span> <span class="n">gpio_to_irq</span><span class="p">(</span><span class="n">desc</span> <span class="o">-</span> <span class="n">gpio_desc</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">irq</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>

	<span class="n">id</span> <span class="o">=</span> <span class="n">desc</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&gt;&gt;</span> <span class="n">ID_SHIFT</span><span class="p">;</span>
	<span class="n">value_sd</span> <span class="o">=</span> <span class="n">idr_find</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dirent_idr</span><span class="p">,</span> <span class="n">id</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">value_sd</span><span class="p">)</span>
		<span class="n">free_irq</span><span class="p">(</span><span class="n">irq</span><span class="p">,</span> <span class="n">value_sd</span><span class="p">);</span>

	<span class="n">desc</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">GPIO_TRIGGER_MASK</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">gpio_flags</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">free_id</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">irq_flags</span> <span class="o">=</span> <span class="n">IRQF_SHARED</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">FLAG_TRIG_FALL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">gpio_flags</span><span class="p">))</span>
		<span class="n">irq_flags</span> <span class="o">|=</span> <span class="n">test_bit</span><span class="p">(</span><span class="n">FLAG_ACTIVE_LOW</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">)</span> <span class="o">?</span>
			<span class="n">IRQF_TRIGGER_RISING</span> <span class="o">:</span> <span class="n">IRQF_TRIGGER_FALLING</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">FLAG_TRIG_RISE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">gpio_flags</span><span class="p">))</span>
		<span class="n">irq_flags</span> <span class="o">|=</span> <span class="n">test_bit</span><span class="p">(</span><span class="n">FLAG_ACTIVE_LOW</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">)</span> <span class="o">?</span>
			<span class="n">IRQF_TRIGGER_FALLING</span> <span class="o">:</span> <span class="n">IRQF_TRIGGER_RISING</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">value_sd</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">value_sd</span> <span class="o">=</span> <span class="n">sysfs_get_dirent</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">kobj</span><span class="p">.</span><span class="n">sd</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="s">&quot;value&quot;</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">value_sd</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">err_out</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">do</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">idr_pre_get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dirent_idr</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">))</span>
				<span class="n">ret</span> <span class="o">=</span> <span class="n">idr_get_new_above</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dirent_idr</span><span class="p">,</span> <span class="n">value_sd</span><span class="p">,</span>
							<span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">id</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">free_sd</span><span class="p">;</span>

		<span class="n">desc</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;=</span> <span class="n">GPIO_FLAGS_MASK</span><span class="p">;</span>
		<span class="n">desc</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">id</span> <span class="o">&lt;&lt;</span> <span class="n">ID_SHIFT</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&gt;&gt;</span> <span class="n">ID_SHIFT</span> <span class="o">!=</span> <span class="n">id</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ERANGE</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">free_id</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">request_any_context_irq</span><span class="p">(</span><span class="n">irq</span><span class="p">,</span> <span class="n">gpio_sysfs_irq</span><span class="p">,</span> <span class="n">irq_flags</span><span class="p">,</span>
				<span class="s">&quot;gpiolib&quot;</span><span class="p">,</span> <span class="n">value_sd</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">free_id</span><span class="p">;</span>

	<span class="n">desc</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">gpio_flags</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">free_id:</span>
	<span class="n">idr_remove</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dirent_idr</span><span class="p">,</span> <span class="n">id</span><span class="p">);</span>
	<span class="n">desc</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;=</span> <span class="n">GPIO_FLAGS_MASK</span><span class="p">;</span>
<span class="nl">free_sd:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">value_sd</span><span class="p">)</span>
		<span class="n">sysfs_put</span><span class="p">(</span><span class="n">value_sd</span><span class="p">);</span>
<span class="nl">err_out:</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
<span class="p">}</span> <span class="n">trigger_types</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">{</span> <span class="s">&quot;none&quot;</span><span class="p">,</span>    <span class="mi">0</span> <span class="p">},</span>
	<span class="p">{</span> <span class="s">&quot;falling&quot;</span><span class="p">,</span> <span class="n">BIT</span><span class="p">(</span><span class="n">FLAG_TRIG_FALL</span><span class="p">)</span> <span class="p">},</span>
	<span class="p">{</span> <span class="s">&quot;rising&quot;</span><span class="p">,</span>  <span class="n">BIT</span><span class="p">(</span><span class="n">FLAG_TRIG_RISE</span><span class="p">)</span> <span class="p">},</span>
	<span class="p">{</span> <span class="s">&quot;both&quot;</span><span class="p">,</span>    <span class="n">BIT</span><span class="p">(</span><span class="n">FLAG_TRIG_FALL</span><span class="p">)</span> <span class="o">|</span> <span class="n">BIT</span><span class="p">(</span><span class="n">FLAG_TRIG_RISE</span><span class="p">)</span> <span class="p">},</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">gpio_edge_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">gpio_desc</span>	<span class="o">*</span><span class="n">desc</span> <span class="o">=</span> <span class="n">dev_get_drvdata</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="kt">ssize_t</span>			<span class="n">status</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sysfs_lock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">test_bit</span><span class="p">(</span><span class="n">FLAG_EXPORT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">))</span>
		<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

		<span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">trigger_types</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">GPIO_TRIGGER_MASK</span><span class="p">)</span>
					<span class="o">==</span> <span class="n">trigger_types</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">flags</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">status</span> <span class="o">=</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
						 <span class="n">trigger_types</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">name</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sysfs_lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">gpio_edge_store</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">gpio_desc</span>	<span class="o">*</span><span class="n">desc</span> <span class="o">=</span> <span class="n">dev_get_drvdata</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="kt">ssize_t</span>			<span class="n">status</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">trigger_types</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sysfs_streq</span><span class="p">(</span><span class="n">trigger_types</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">name</span><span class="p">,</span> <span class="n">buf</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">found</span><span class="p">;</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

<span class="nl">found:</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sysfs_lock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">test_bit</span><span class="p">(</span><span class="n">FLAG_EXPORT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">))</span>
		<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">gpio_setup_irq</span><span class="p">(</span><span class="n">desc</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="n">trigger_types</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">flags</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">status</span><span class="p">)</span>
			<span class="n">status</span> <span class="o">=</span> <span class="n">size</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sysfs_lock</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">DEVICE_ATTR</span><span class="p">(</span><span class="n">edge</span><span class="p">,</span> <span class="mo">0644</span><span class="p">,</span> <span class="n">gpio_edge_show</span><span class="p">,</span> <span class="n">gpio_edge_store</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">sysfs_set_active_low</span><span class="p">(</span><span class="k">struct</span> <span class="n">gpio_desc</span> <span class="o">*</span><span class="n">desc</span><span class="p">,</span> <span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
				<span class="kt">int</span> <span class="n">value</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span>			<span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!!</span><span class="n">test_bit</span><span class="p">(</span><span class="n">FLAG_ACTIVE_LOW</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">)</span> <span class="o">==</span> <span class="o">!!</span><span class="n">value</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">value</span><span class="p">)</span>
		<span class="n">set_bit</span><span class="p">(</span><span class="n">FLAG_ACTIVE_LOW</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">clear_bit</span><span class="p">(</span><span class="n">FLAG_ACTIVE_LOW</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>

	<span class="cm">/* reconfigure poll(2) support if enabled on one edge only */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="o">!!</span><span class="n">test_bit</span><span class="p">(</span><span class="n">FLAG_TRIG_RISE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">)</span> <span class="o">^</span>
				<span class="o">!!</span><span class="n">test_bit</span><span class="p">(</span><span class="n">FLAG_TRIG_FALL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">)))</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">trigger_flags</span> <span class="o">=</span> <span class="n">desc</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">GPIO_TRIGGER_MASK</span><span class="p">;</span>

		<span class="n">gpio_setup_irq</span><span class="p">(</span><span class="n">desc</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">gpio_setup_irq</span><span class="p">(</span><span class="n">desc</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="n">trigger_flags</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">gpio_active_low_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">gpio_desc</span>	<span class="o">*</span><span class="n">desc</span> <span class="o">=</span> <span class="n">dev_get_drvdata</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="kt">ssize_t</span>			<span class="n">status</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sysfs_lock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">test_bit</span><span class="p">(</span><span class="n">FLAG_EXPORT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">))</span>
		<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="o">!!</span><span class="n">test_bit</span><span class="p">(</span><span class="n">FLAG_ACTIVE_LOW</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">));</span>

	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sysfs_lock</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">gpio_active_low_store</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">gpio_desc</span>	<span class="o">*</span><span class="n">desc</span> <span class="o">=</span> <span class="n">dev_get_drvdata</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="kt">ssize_t</span>			<span class="n">status</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sysfs_lock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">test_bit</span><span class="p">(</span><span class="n">FLAG_EXPORT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="kt">long</span>		<span class="n">value</span><span class="p">;</span>

		<span class="n">status</span> <span class="o">=</span> <span class="n">strict_strtol</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">value</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">status</span> <span class="o">=</span> <span class="n">sysfs_set_active_low</span><span class="p">(</span><span class="n">desc</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="n">value</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sysfs_lock</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">status</span> <span class="o">?</span> <span class="o">:</span> <span class="n">size</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="n">DEVICE_ATTR</span><span class="p">(</span><span class="n">active_low</span><span class="p">,</span> <span class="mo">0644</span><span class="p">,</span>
		<span class="n">gpio_active_low_show</span><span class="p">,</span> <span class="n">gpio_active_low_store</span><span class="p">);</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">attribute</span> <span class="o">*</span><span class="n">gpio_attrs</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="o">&amp;</span><span class="n">dev_attr_value</span><span class="p">.</span><span class="n">attr</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">dev_attr_active_low</span><span class="p">.</span><span class="n">attr</span><span class="p">,</span>
	<span class="nb">NULL</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">attribute_group</span> <span class="n">gpio_attr_group</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">attrs</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">attribute</span> <span class="o">**</span><span class="p">)</span> <span class="n">gpio_attrs</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * /sys/class/gpio/gpiochipN/</span>
<span class="cm"> *   /base ... matching gpio_chip.base (N)</span>
<span class="cm"> *   /label ... matching gpio_chip.label</span>
<span class="cm"> *   /ngpio ... matching gpio_chip.ngpio</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">chip_base_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">gpio_chip</span>	<span class="o">*</span><span class="n">chip</span> <span class="o">=</span> <span class="n">dev_get_drvdata</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="n">DEVICE_ATTR</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="mo">0444</span><span class="p">,</span> <span class="n">chip_base_show</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">chip_label_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">gpio_chip</span>	<span class="o">*</span><span class="n">chip</span> <span class="o">=</span> <span class="n">dev_get_drvdata</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">label</span> <span class="o">?</span> <span class="o">:</span> <span class="s">&quot;&quot;</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="n">DEVICE_ATTR</span><span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="mo">0444</span><span class="p">,</span> <span class="n">chip_label_show</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">chip_ngpio_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">gpio_chip</span>	<span class="o">*</span><span class="n">chip</span> <span class="o">=</span> <span class="n">dev_get_drvdata</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;%u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">ngpio</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="n">DEVICE_ATTR</span><span class="p">(</span><span class="n">ngpio</span><span class="p">,</span> <span class="mo">0444</span><span class="p">,</span> <span class="n">chip_ngpio_show</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">attribute</span> <span class="o">*</span><span class="n">gpiochip_attrs</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="o">&amp;</span><span class="n">dev_attr_base</span><span class="p">.</span><span class="n">attr</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">dev_attr_label</span><span class="p">.</span><span class="n">attr</span><span class="p">,</span>
	<span class="o">&amp;</span><span class="n">dev_attr_ngpio</span><span class="p">.</span><span class="n">attr</span><span class="p">,</span>
	<span class="nb">NULL</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">attribute_group</span> <span class="n">gpiochip_attr_group</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">attrs</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">attribute</span> <span class="o">**</span><span class="p">)</span> <span class="n">gpiochip_attrs</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * /sys/class/gpio/export ... write-only</span>
<span class="cm"> *	integer N ... number of GPIO to export (full access)</span>
<span class="cm"> * /sys/class/gpio/unexport ... write-only</span>
<span class="cm"> *	integer N ... number of GPIO to unexport</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">export_store</span><span class="p">(</span><span class="k">struct</span> <span class="n">class</span> <span class="o">*</span><span class="n">class</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">class_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span>
				<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">long</span>	<span class="n">gpio</span><span class="p">;</span>
	<span class="kt">int</span>	<span class="n">status</span><span class="p">;</span>

	<span class="n">status</span> <span class="o">=</span> <span class="n">strict_strtol</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">gpio</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>

	<span class="cm">/* No extra locking here; FLAG_SYSFS just signifies that the</span>
<span class="cm">	 * request and export were done by on behalf of userspace, so</span>
<span class="cm">	 * they may be undone on its behalf too.</span>
<span class="cm">	 */</span>

	<span class="n">status</span> <span class="o">=</span> <span class="n">gpio_request</span><span class="p">(</span><span class="n">gpio</span><span class="p">,</span> <span class="s">&quot;sysfs&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>

	<span class="n">status</span> <span class="o">=</span> <span class="n">gpio_export</span><span class="p">(</span><span class="n">gpio</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">gpio_free</span><span class="p">(</span><span class="n">gpio</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">set_bit</span><span class="p">(</span><span class="n">FLAG_SYSFS</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">gpio_desc</span><span class="p">[</span><span class="n">gpio</span><span class="p">].</span><span class="n">flags</span><span class="p">);</span>

<span class="nl">done:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span><span class="p">)</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;%s: status %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">status</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">status</span> <span class="o">?</span> <span class="o">:</span> <span class="n">len</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">unexport_store</span><span class="p">(</span><span class="k">struct</span> <span class="n">class</span> <span class="o">*</span><span class="n">class</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">class_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span>
				<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">long</span>	<span class="n">gpio</span><span class="p">;</span>
	<span class="kt">int</span>	<span class="n">status</span><span class="p">;</span>

	<span class="n">status</span> <span class="o">=</span> <span class="n">strict_strtol</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">gpio</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>

	<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="cm">/* reject bogus commands (gpio_unexport ignores them) */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">gpio_is_valid</span><span class="p">(</span><span class="n">gpio</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>

	<span class="cm">/* No extra locking here; FLAG_SYSFS just signifies that the</span>
<span class="cm">	 * request and export were done by on behalf of userspace, so</span>
<span class="cm">	 * they may be undone on its behalf too.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">test_and_clear_bit</span><span class="p">(</span><span class="n">FLAG_SYSFS</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">gpio_desc</span><span class="p">[</span><span class="n">gpio</span><span class="p">].</span><span class="n">flags</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">gpio_free</span><span class="p">(</span><span class="n">gpio</span><span class="p">);</span>
	<span class="p">}</span>
<span class="nl">done:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span><span class="p">)</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;%s: status %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">status</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">status</span> <span class="o">?</span> <span class="o">:</span> <span class="n">len</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">class_attribute</span> <span class="n">gpio_class_attrs</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="n">__ATTR</span><span class="p">(</span><span class="n">export</span><span class="p">,</span> <span class="mo">0200</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">export_store</span><span class="p">),</span>
	<span class="n">__ATTR</span><span class="p">(</span><span class="n">unexport</span><span class="p">,</span> <span class="mo">0200</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">unexport_store</span><span class="p">),</span>
	<span class="n">__ATTR_NULL</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">class</span> <span class="n">gpio_class</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">name</span> <span class="o">=</span>		<span class="s">&quot;gpio&quot;</span><span class="p">,</span>
	<span class="p">.</span><span class="n">owner</span> <span class="o">=</span>	<span class="n">THIS_MODULE</span><span class="p">,</span>

	<span class="p">.</span><span class="n">class_attrs</span> <span class="o">=</span>	<span class="n">gpio_class_attrs</span><span class="p">,</span>
<span class="p">};</span>


<span class="cm">/**</span>
<span class="cm"> * gpio_export - export a GPIO through sysfs</span>
<span class="cm"> * @gpio: gpio to make available, already requested</span>
<span class="cm"> * @direction_may_change: true if userspace may change gpio direction</span>
<span class="cm"> * Context: arch_initcall or later</span>
<span class="cm"> *</span>
<span class="cm"> * When drivers want to make a GPIO accessible to userspace after they</span>
<span class="cm"> * have requested it -- perhaps while debugging, or as part of their</span>
<span class="cm"> * public interface -- they may use this routine.  If the GPIO can</span>
<span class="cm"> * change direction (some can&#39;t) and the caller allows it, userspace</span>
<span class="cm"> * will see &quot;direction&quot; sysfs attribute which may be used to change</span>
<span class="cm"> * the gpio&#39;s direction.  A &quot;value&quot; attribute will always be provided.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns zero on success, else an error.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">gpio_export</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">gpio</span><span class="p">,</span> <span class="n">bool</span> <span class="n">direction_may_change</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">flags</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">gpio_desc</span>	<span class="o">*</span><span class="n">desc</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">char</span>		<span class="o">*</span><span class="n">ioname</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="cm">/* can&#39;t export until sysfs is available ... */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">gpio_class</span><span class="p">.</span><span class="n">p</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;%s: called too early!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">gpio_is_valid</span><span class="p">(</span><span class="n">gpio</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sysfs_lock</span><span class="p">);</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gpio_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">desc</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">gpio_desc</span><span class="p">[</span><span class="n">gpio</span><span class="p">];</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">FLAG_REQUESTED</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">)</span>
			<span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">test_bit</span><span class="p">(</span><span class="n">FLAG_EXPORT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">direction_input</span>
				<span class="o">||</span> <span class="o">!</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">direction_output</span><span class="p">)</span>
			<span class="n">direction_may_change</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gpio_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">names</span> <span class="o">&amp;&amp;</span> <span class="n">desc</span><span class="o">-&gt;</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">names</span><span class="p">[</span><span class="n">gpio</span> <span class="o">-</span> <span class="n">desc</span><span class="o">-&gt;</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">])</span>
		<span class="n">ioname</span> <span class="o">=</span> <span class="n">desc</span><span class="o">-&gt;</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">names</span><span class="p">[</span><span class="n">gpio</span> <span class="o">-</span> <span class="n">desc</span><span class="o">-&gt;</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">];</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">device</span>	<span class="o">*</span><span class="n">dev</span><span class="p">;</span>

		<span class="n">dev</span> <span class="o">=</span> <span class="n">device_create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gpio_class</span><span class="p">,</span> <span class="n">desc</span><span class="o">-&gt;</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">MKDEV</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
				<span class="n">desc</span><span class="p">,</span> <span class="n">ioname</span> <span class="o">?</span> <span class="n">ioname</span> <span class="o">:</span> <span class="s">&quot;gpio%u&quot;</span><span class="p">,</span> <span class="n">gpio</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">dev</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">status</span> <span class="o">=</span> <span class="n">sysfs_create_group</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">kobj</span><span class="p">,</span>
						<span class="o">&amp;</span><span class="n">gpio_attr_group</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">status</span> <span class="o">&amp;&amp;</span> <span class="n">direction_may_change</span><span class="p">)</span>
				<span class="n">status</span> <span class="o">=</span> <span class="n">device_create_file</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span>
						<span class="o">&amp;</span><span class="n">dev_attr_direction</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">status</span> <span class="o">&amp;&amp;</span> <span class="n">gpio_to_irq</span><span class="p">(</span><span class="n">gpio</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">0</span>
					<span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">direction_may_change</span>
						<span class="o">||</span> <span class="o">!</span><span class="n">test_bit</span><span class="p">(</span><span class="n">FLAG_IS_OUT</span><span class="p">,</span>
							<span class="o">&amp;</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">)))</span>
				<span class="n">status</span> <span class="o">=</span> <span class="n">device_create_file</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span>
						<span class="o">&amp;</span><span class="n">dev_attr_edge</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
				<span class="n">device_unregister</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="n">status</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">set_bit</span><span class="p">(</span><span class="n">FLAG_EXPORT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sysfs_lock</span><span class="p">);</span>

<span class="nl">done:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span><span class="p">)</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;%s: gpio%d status %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">gpio</span><span class="p">,</span> <span class="n">status</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">gpio_export</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">match_export</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">dev_get_drvdata</span><span class="p">(</span><span class="n">dev</span><span class="p">)</span> <span class="o">==</span> <span class="n">data</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * gpio_export_link - create a sysfs link to an exported GPIO node</span>
<span class="cm"> * @dev: device under which to create symlink</span>
<span class="cm"> * @name: name of the symlink</span>
<span class="cm"> * @gpio: gpio to create symlink to, already exported</span>
<span class="cm"> *</span>
<span class="cm"> * Set up a symlink from /sys/.../dev/name to /sys/class/gpio/gpioN</span>
<span class="cm"> * node. Caller is responsible for unlinking.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns zero on success, else an error.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">gpio_export_link</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">gpio</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">gpio_desc</span>	<span class="o">*</span><span class="n">desc</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">gpio_is_valid</span><span class="p">(</span><span class="n">gpio</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sysfs_lock</span><span class="p">);</span>

	<span class="n">desc</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">gpio_desc</span><span class="p">[</span><span class="n">gpio</span><span class="p">];</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">FLAG_EXPORT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">tdev</span><span class="p">;</span>

		<span class="n">tdev</span> <span class="o">=</span> <span class="n">class_find_device</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gpio_class</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">desc</span><span class="p">,</span> <span class="n">match_export</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tdev</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">status</span> <span class="o">=</span> <span class="n">sysfs_create_link</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">kobj</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tdev</span><span class="o">-&gt;</span><span class="n">kobj</span><span class="p">,</span>
						<span class="n">name</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sysfs_lock</span><span class="p">);</span>

<span class="nl">done:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span><span class="p">)</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;%s: gpio%d status %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">gpio</span><span class="p">,</span> <span class="n">status</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">gpio_export_link</span><span class="p">);</span>


<span class="cm">/**</span>
<span class="cm"> * gpio_sysfs_set_active_low - set the polarity of gpio sysfs value</span>
<span class="cm"> * @gpio: gpio to change</span>
<span class="cm"> * @value: non-zero to use active low, i.e. inverted values</span>
<span class="cm"> *</span>
<span class="cm"> * Set the polarity of /sys/class/gpio/gpioN/value sysfs attribute.</span>
<span class="cm"> * The GPIO does not have to be exported yet.  If poll(2) support has</span>
<span class="cm"> * been enabled for either rising or falling edge, it will be</span>
<span class="cm"> * reconfigured to follow the new polarity.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns zero on success, else an error.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">gpio_sysfs_set_active_low</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">gpio</span><span class="p">,</span> <span class="kt">int</span> <span class="n">value</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">gpio_desc</span>	<span class="o">*</span><span class="n">desc</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">device</span>		<span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">gpio_is_valid</span><span class="p">(</span><span class="n">gpio</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sysfs_lock</span><span class="p">);</span>

	<span class="n">desc</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">gpio_desc</span><span class="p">[</span><span class="n">gpio</span><span class="p">];</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">FLAG_EXPORT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dev</span> <span class="o">=</span> <span class="n">class_find_device</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gpio_class</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">desc</span><span class="p">,</span> <span class="n">match_export</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dev</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">unlock</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">status</span> <span class="o">=</span> <span class="n">sysfs_set_active_low</span><span class="p">(</span><span class="n">desc</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="n">value</span><span class="p">);</span>

<span class="nl">unlock:</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sysfs_lock</span><span class="p">);</span>

<span class="nl">done:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span><span class="p">)</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;%s: gpio%d status %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">gpio</span><span class="p">,</span> <span class="n">status</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">gpio_sysfs_set_active_low</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * gpio_unexport - reverse effect of gpio_export()</span>
<span class="cm"> * @gpio: gpio to make unavailable</span>
<span class="cm"> *</span>
<span class="cm"> * This is implicit on gpio_free().</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">gpio_unexport</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">gpio</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">gpio_desc</span>	<span class="o">*</span><span class="n">desc</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">device</span>		<span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">gpio_is_valid</span><span class="p">(</span><span class="n">gpio</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sysfs_lock</span><span class="p">);</span>

	<span class="n">desc</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">gpio_desc</span><span class="p">[</span><span class="n">gpio</span><span class="p">];</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">FLAG_EXPORT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">))</span> <span class="p">{</span>

		<span class="n">dev</span> <span class="o">=</span> <span class="n">class_find_device</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gpio_class</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">desc</span><span class="p">,</span> <span class="n">match_export</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">gpio_setup_irq</span><span class="p">(</span><span class="n">desc</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
			<span class="n">clear_bit</span><span class="p">(</span><span class="n">FLAG_EXPORT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sysfs_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">device_unregister</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
		<span class="n">put_device</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="p">}</span>
<span class="nl">done:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span><span class="p">)</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;%s: gpio%d status %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">gpio</span><span class="p">,</span> <span class="n">status</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">gpio_unexport</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">gpiochip_export</span><span class="p">(</span><span class="k">struct</span> <span class="n">gpio_chip</span> <span class="o">*</span><span class="n">chip</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span>		<span class="n">status</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">device</span>	<span class="o">*</span><span class="n">dev</span><span class="p">;</span>

	<span class="cm">/* Many systems register gpio chips for SOC support very early,</span>
<span class="cm">	 * before driver model support is available.  In those cases we</span>
<span class="cm">	 * export this later, in gpiolib_sysfs_init() ... here we just</span>
<span class="cm">	 * verify that _some_ field of gpio_class got initialized.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">gpio_class</span><span class="p">.</span><span class="n">p</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* use chip-&gt;base for the ID; it&#39;s already known to be unique */</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sysfs_lock</span><span class="p">);</span>
	<span class="n">dev</span> <span class="o">=</span> <span class="n">device_create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gpio_class</span><span class="p">,</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">MKDEV</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">chip</span><span class="p">,</span>
				<span class="s">&quot;gpiochip%d&quot;</span><span class="p">,</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">dev</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">sysfs_create_group</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">kobj</span><span class="p">,</span>
				<span class="o">&amp;</span><span class="n">gpiochip_attr_group</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">chip</span><span class="o">-&gt;</span><span class="n">exported</span> <span class="o">=</span> <span class="p">(</span><span class="n">status</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sysfs_lock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">status</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">long</span>	<span class="n">flags</span><span class="p">;</span>
		<span class="kt">unsigned</span>	<span class="n">gpio</span><span class="p">;</span>

		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gpio_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="n">gpio</span> <span class="o">=</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">;</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">gpio_desc</span><span class="p">[</span><span class="n">gpio</span><span class="p">].</span><span class="n">chip</span> <span class="o">==</span> <span class="n">chip</span><span class="p">)</span>
			<span class="n">gpio_desc</span><span class="p">[</span><span class="n">gpio</span><span class="o">++</span><span class="p">].</span><span class="n">chip</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gpio_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;%s: chip %s status %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span>
				<span class="n">chip</span><span class="o">-&gt;</span><span class="n">label</span><span class="p">,</span> <span class="n">status</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">gpiochip_unexport</span><span class="p">(</span><span class="k">struct</span> <span class="n">gpio_chip</span> <span class="o">*</span><span class="n">chip</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span>			<span class="n">status</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">device</span>		<span class="o">*</span><span class="n">dev</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sysfs_lock</span><span class="p">);</span>
	<span class="n">dev</span> <span class="o">=</span> <span class="n">class_find_device</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gpio_class</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">chip</span><span class="p">,</span> <span class="n">match_export</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">put_device</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
		<span class="n">device_unregister</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
		<span class="n">chip</span><span class="o">-&gt;</span><span class="n">exported</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sysfs_lock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">status</span><span class="p">)</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;%s: chip %s status %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span>
				<span class="n">chip</span><span class="o">-&gt;</span><span class="n">label</span><span class="p">,</span> <span class="n">status</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">gpiolib_sysfs_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span>		<span class="n">status</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>	<span class="n">flags</span><span class="p">;</span>
	<span class="kt">unsigned</span>	<span class="n">gpio</span><span class="p">;</span>

	<span class="n">status</span> <span class="o">=</span> <span class="n">class_register</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gpio_class</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">status</span><span class="p">;</span>

	<span class="cm">/* Scan and register the gpio_chips which registered very</span>
<span class="cm">	 * early (e.g. before the class_register above was called).</span>
<span class="cm">	 *</span>
<span class="cm">	 * We run before arch_initcall() so chip-&gt;dev nodes can have</span>
<span class="cm">	 * registered, and so arch_initcall() can always gpio_export().</span>
<span class="cm">	 */</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gpio_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">gpio</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">gpio</span> <span class="o">&lt;</span> <span class="n">ARCH_NR_GPIOS</span><span class="p">;</span> <span class="n">gpio</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">gpio_chip</span>	<span class="o">*</span><span class="n">chip</span><span class="p">;</span>

		<span class="n">chip</span> <span class="o">=</span> <span class="n">gpio_desc</span><span class="p">[</span><span class="n">gpio</span><span class="p">].</span><span class="n">chip</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">chip</span> <span class="o">||</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">exported</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gpio_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">gpiochip_export</span><span class="p">(</span><span class="n">chip</span><span class="p">);</span>
		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gpio_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gpio_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>


	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">postcore_initcall</span><span class="p">(</span><span class="n">gpiolib_sysfs_init</span><span class="p">);</span>

<span class="cp">#else</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">gpiochip_export</span><span class="p">(</span><span class="k">struct</span> <span class="n">gpio_chip</span> <span class="o">*</span><span class="n">chip</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">gpiochip_unexport</span><span class="p">(</span><span class="k">struct</span> <span class="n">gpio_chip</span> <span class="o">*</span><span class="n">chip</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="cp">#endif </span><span class="cm">/* CONFIG_GPIO_SYSFS */</span><span class="cp"></span>

<span class="cm">/**</span>
<span class="cm"> * gpiochip_add() - register a gpio_chip</span>
<span class="cm"> * @chip: the chip to register, with chip-&gt;base initialized</span>
<span class="cm"> * Context: potentially before irqs or kmalloc will work</span>
<span class="cm"> *</span>
<span class="cm"> * Returns a negative errno if the chip can&#39;t be registered, such as</span>
<span class="cm"> * because the chip-&gt;base is invalid or already associated with a</span>
<span class="cm"> * different chip.  Otherwise it returns zero as a success code.</span>
<span class="cm"> *</span>
<span class="cm"> * When gpiochip_add() is called very early during boot, so that GPIOs</span>
<span class="cm"> * can be freely used, the chip-&gt;dev device must be registered before</span>
<span class="cm"> * the gpio framework&#39;s arch_initcall().  Otherwise sysfs initialization</span>
<span class="cm"> * for GPIOs will fail rudely.</span>
<span class="cm"> *</span>
<span class="cm"> * If chip-&gt;base is negative, this requests dynamic assignment of</span>
<span class="cm"> * a range of valid GPIOs.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">gpiochip_add</span><span class="p">(</span><span class="k">struct</span> <span class="n">gpio_chip</span> <span class="o">*</span><span class="n">chip</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>	<span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span>	<span class="n">id</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">base</span> <span class="o">=</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="o">!</span><span class="n">gpio_is_valid</span><span class="p">(</span><span class="n">base</span><span class="p">)</span> <span class="o">||</span> <span class="o">!</span><span class="n">gpio_is_valid</span><span class="p">(</span><span class="n">base</span> <span class="o">+</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">ngpio</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
			<span class="o">&amp;&amp;</span> <span class="n">base</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gpio_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">base</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">base</span> <span class="o">=</span> <span class="n">gpiochip_find_base</span><span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">ngpio</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">base</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">status</span> <span class="o">=</span> <span class="n">base</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">unlock</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">chip</span><span class="o">-&gt;</span><span class="n">base</span> <span class="o">=</span> <span class="n">base</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* these GPIO numbers must not be managed by another gpio_chip */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">id</span> <span class="o">=</span> <span class="n">base</span><span class="p">;</span> <span class="n">id</span> <span class="o">&lt;</span> <span class="n">base</span> <span class="o">+</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">ngpio</span><span class="p">;</span> <span class="n">id</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">gpio_desc</span><span class="p">[</span><span class="n">id</span><span class="p">].</span><span class="n">chip</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">id</span> <span class="o">=</span> <span class="n">base</span><span class="p">;</span> <span class="n">id</span> <span class="o">&lt;</span> <span class="n">base</span> <span class="o">+</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">ngpio</span><span class="p">;</span> <span class="n">id</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">gpio_desc</span><span class="p">[</span><span class="n">id</span><span class="p">].</span><span class="n">chip</span> <span class="o">=</span> <span class="n">chip</span><span class="p">;</span>

			<span class="cm">/* REVISIT:  most hardware initializes GPIOs as</span>
<span class="cm">			 * inputs (often with pullups enabled) so power</span>
<span class="cm">			 * usage is minimized.  Linux code should set the</span>
<span class="cm">			 * gpio direction first thing; but until it does,</span>
<span class="cm">			 * we may expose the wrong direction in sysfs.</span>
<span class="cm">			 */</span>
			<span class="n">gpio_desc</span><span class="p">[</span><span class="n">id</span><span class="p">].</span><span class="n">flags</span> <span class="o">=</span> <span class="o">!</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">direction_input</span>
				<span class="o">?</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">FLAG_IS_OUT</span><span class="p">)</span>
				<span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">of_gpiochip_add</span><span class="p">(</span><span class="n">chip</span><span class="p">);</span>

<span class="nl">unlock:</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gpio_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">status</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>

	<span class="n">status</span> <span class="o">=</span> <span class="n">gpiochip_export</span><span class="p">(</span><span class="n">chip</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;gpiochip_add: registered GPIOs %d to %d on device: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">chip</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">,</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">base</span> <span class="o">+</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">ngpio</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span>
		<span class="n">chip</span><span class="o">-&gt;</span><span class="n">label</span> <span class="o">?</span> <span class="o">:</span> <span class="s">&quot;generic&quot;</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">fail:</span>
	<span class="cm">/* failures here can mean systems won&#39;t boot... */</span>
	<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;gpiochip_add: gpios %d..%d (%s) failed to register</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">chip</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">,</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">base</span> <span class="o">+</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">ngpio</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span>
		<span class="n">chip</span><span class="o">-&gt;</span><span class="n">label</span> <span class="o">?</span> <span class="o">:</span> <span class="s">&quot;generic&quot;</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">gpiochip_add</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * gpiochip_remove() - unregister a gpio_chip</span>
<span class="cm"> * @chip: the chip to unregister</span>
<span class="cm"> *</span>
<span class="cm"> * A gpio_chip with any GPIOs still requested may not be removed.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">gpiochip_remove</span><span class="p">(</span><span class="k">struct</span> <span class="n">gpio_chip</span> <span class="o">*</span><span class="n">chip</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>	<span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span>	<span class="n">id</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gpio_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">of_gpiochip_remove</span><span class="p">(</span><span class="n">chip</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">id</span> <span class="o">=</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">;</span> <span class="n">id</span> <span class="o">&lt;</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">base</span> <span class="o">+</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">ngpio</span><span class="p">;</span> <span class="n">id</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">FLAG_REQUESTED</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">gpio_desc</span><span class="p">[</span><span class="n">id</span><span class="p">].</span><span class="n">flags</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">id</span> <span class="o">=</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">;</span> <span class="n">id</span> <span class="o">&lt;</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">base</span> <span class="o">+</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">ngpio</span><span class="p">;</span> <span class="n">id</span><span class="o">++</span><span class="p">)</span>
			<span class="n">gpio_desc</span><span class="p">[</span><span class="n">id</span><span class="p">].</span><span class="n">chip</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gpio_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">gpiochip_unexport</span><span class="p">(</span><span class="n">chip</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">gpiochip_remove</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * gpiochip_find() - iterator for locating a specific gpio_chip</span>
<span class="cm"> * @data: data to pass to match function</span>
<span class="cm"> * @callback: Callback function to check gpio_chip</span>
<span class="cm"> *</span>
<span class="cm"> * Similar to bus_find_device.  It returns a reference to a gpio_chip as</span>
<span class="cm"> * determined by a user supplied @match callback.  The callback should return</span>
<span class="cm"> * 0 if the device doesn&#39;t match and non-zero if it does.  If the callback is</span>
<span class="cm"> * non-zero, this function will return to the caller and not iterate over any</span>
<span class="cm"> * more gpio_chips.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">gpio_chip</span> <span class="o">*</span><span class="nf">gpiochip_find</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span>
				<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">match</span><span class="p">)(</span><span class="k">struct</span> <span class="n">gpio_chip</span> <span class="o">*</span><span class="n">chip</span><span class="p">,</span>
					     <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">))</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">gpio_chip</span> <span class="o">*</span><span class="n">chip</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gpio_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ARCH_NR_GPIOS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">gpio_desc</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">chip</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">match</span><span class="p">(</span><span class="n">gpio_desc</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">chip</span><span class="p">,</span> <span class="n">data</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">chip</span> <span class="o">=</span> <span class="n">gpio_desc</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">chip</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gpio_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">chip</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">gpiochip_find</span><span class="p">);</span>

<span class="cm">/* These &quot;optional&quot; allocation calls help prevent drivers from stomping</span>
<span class="cm"> * on each other, and help provide better diagnostics in debugfs.</span>
<span class="cm"> * They&#39;re called even less than the &quot;set direction&quot; calls.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">gpio_request</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">gpio</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">label</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">gpio_desc</span>	<span class="o">*</span><span class="n">desc</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">gpio_chip</span>	<span class="o">*</span><span class="n">chip</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">flags</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gpio_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">gpio_is_valid</span><span class="p">(</span><span class="n">gpio</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
	<span class="n">desc</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">gpio_desc</span><span class="p">[</span><span class="n">gpio</span><span class="p">];</span>
	<span class="n">chip</span> <span class="o">=</span> <span class="n">desc</span><span class="o">-&gt;</span><span class="n">chip</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">chip</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">try_module_get</span><span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">owner</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>

	<span class="cm">/* NOTE:  gpio_request() can be called in early boot,</span>
<span class="cm">	 * before IRQs are enabled, for non-sleeping (SOC) GPIOs.</span>
<span class="cm">	 */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">test_and_set_bit</span><span class="p">(</span><span class="n">FLAG_REQUESTED</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">desc_set_label</span><span class="p">(</span><span class="n">desc</span><span class="p">,</span> <span class="n">label</span> <span class="o">?</span> <span class="o">:</span> <span class="s">&quot;?&quot;</span><span class="p">);</span>
		<span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
		<span class="n">module_put</span><span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">owner</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">request</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* chip-&gt;request may sleep */</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gpio_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">request</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">gpio</span> <span class="o">-</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">);</span>
		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gpio_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">desc_set_label</span><span class="p">(</span><span class="n">desc</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
			<span class="n">module_put</span><span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">owner</span><span class="p">);</span>
			<span class="n">clear_bit</span><span class="p">(</span><span class="n">FLAG_REQUESTED</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

<span class="nl">done:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span><span class="p">)</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;gpio_request: gpio-%d (%s) status %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">gpio</span><span class="p">,</span> <span class="n">label</span> <span class="o">?</span> <span class="o">:</span> <span class="s">&quot;?&quot;</span><span class="p">,</span> <span class="n">status</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gpio_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">gpio_request</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">gpio_free</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">gpio</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">flags</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">gpio_desc</span>	<span class="o">*</span><span class="n">desc</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">gpio_chip</span>	<span class="o">*</span><span class="n">chip</span><span class="p">;</span>

	<span class="n">might_sleep</span><span class="p">();</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">gpio_is_valid</span><span class="p">(</span><span class="n">gpio</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">WARN_ON</span><span class="p">(</span><span class="n">extra_checks</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">gpio_unexport</span><span class="p">(</span><span class="n">gpio</span><span class="p">);</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gpio_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">desc</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">gpio_desc</span><span class="p">[</span><span class="n">gpio</span><span class="p">];</span>
	<span class="n">chip</span> <span class="o">=</span> <span class="n">desc</span><span class="o">-&gt;</span><span class="n">chip</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">chip</span> <span class="o">&amp;&amp;</span> <span class="n">test_bit</span><span class="p">(</span><span class="n">FLAG_REQUESTED</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">free</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gpio_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
			<span class="n">might_sleep_if</span><span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">can_sleep</span><span class="p">);</span>
			<span class="n">chip</span><span class="o">-&gt;</span><span class="n">free</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">gpio</span> <span class="o">-</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">);</span>
			<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gpio_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">desc_set_label</span><span class="p">(</span><span class="n">desc</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="n">module_put</span><span class="p">(</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">owner</span><span class="p">);</span>
		<span class="n">clear_bit</span><span class="p">(</span><span class="n">FLAG_ACTIVE_LOW</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
		<span class="n">clear_bit</span><span class="p">(</span><span class="n">FLAG_REQUESTED</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
		<span class="n">clear_bit</span><span class="p">(</span><span class="n">FLAG_OPEN_DRAIN</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
		<span class="n">clear_bit</span><span class="p">(</span><span class="n">FLAG_OPEN_SOURCE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">WARN_ON</span><span class="p">(</span><span class="n">extra_checks</span><span class="p">);</span>

	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gpio_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">gpio_free</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * gpio_request_one - request a single GPIO with initial configuration</span>
<span class="cm"> * @gpio:	the GPIO number</span>
<span class="cm"> * @flags:	GPIO configuration as specified by GPIOF_*</span>
<span class="cm"> * @label:	a literal description string of this GPIO</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">gpio_request_one</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">gpio</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">label</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">gpio_request</span><span class="p">(</span><span class="n">gpio</span><span class="p">,</span> <span class="n">label</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">GPIOF_OPEN_DRAIN</span><span class="p">)</span>
		<span class="n">set_bit</span><span class="p">(</span><span class="n">FLAG_OPEN_DRAIN</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">gpio_desc</span><span class="p">[</span><span class="n">gpio</span><span class="p">].</span><span class="n">flags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">GPIOF_OPEN_SOURCE</span><span class="p">)</span>
		<span class="n">set_bit</span><span class="p">(</span><span class="n">FLAG_OPEN_SOURCE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">gpio_desc</span><span class="p">[</span><span class="n">gpio</span><span class="p">].</span><span class="n">flags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">GPIOF_DIR_IN</span><span class="p">)</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">gpio_direction_input</span><span class="p">(</span><span class="n">gpio</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">gpio_direction_output</span><span class="p">(</span><span class="n">gpio</span><span class="p">,</span>
				<span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">GPIOF_INIT_HIGH</span><span class="p">)</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">free_gpio</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">GPIOF_EXPORT</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">gpio_export</span><span class="p">(</span><span class="n">gpio</span><span class="p">,</span> <span class="n">flags</span> <span class="o">&amp;</span> <span class="n">GPIOF_EXPORT_CHANGEABLE</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">free_gpio</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

 <span class="nl">free_gpio:</span>
	<span class="n">gpio_free</span><span class="p">(</span><span class="n">gpio</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">gpio_request_one</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * gpio_request_array - request multiple GPIOs in a single call</span>
<span class="cm"> * @array:	array of the &#39;struct gpio&#39;</span>
<span class="cm"> * @num:	how many GPIOs in the array</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">gpio_request_array</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">gpio</span> <span class="o">*</span><span class="n">array</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">num</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">err</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">num</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">,</span> <span class="n">array</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">gpio_request_one</span><span class="p">(</span><span class="n">array</span><span class="o">-&gt;</span><span class="n">gpio</span><span class="p">,</span> <span class="n">array</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">,</span> <span class="n">array</span><span class="o">-&gt;</span><span class="n">label</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">err_free</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">err_free:</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">i</span><span class="o">--</span><span class="p">)</span>
		<span class="n">gpio_free</span><span class="p">((</span><span class="o">--</span><span class="n">array</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">gpio</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">gpio_request_array</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * gpio_free_array - release multiple GPIOs in a single call</span>
<span class="cm"> * @array:	array of the &#39;struct gpio&#39;</span>
<span class="cm"> * @num:	how many GPIOs in the array</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">gpio_free_array</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">gpio</span> <span class="o">*</span><span class="n">array</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">num</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">num</span><span class="o">--</span><span class="p">)</span>
		<span class="n">gpio_free</span><span class="p">((</span><span class="n">array</span><span class="o">++</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">gpio</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">gpio_free_array</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * gpiochip_is_requested - return string iff signal was requested</span>
<span class="cm"> * @chip: controller managing the signal</span>
<span class="cm"> * @offset: of signal within controller&#39;s 0..(ngpio - 1) range</span>
<span class="cm"> *</span>
<span class="cm"> * Returns NULL if the GPIO is not currently requested, else a string.</span>
<span class="cm"> * If debugfs support is enabled, the string returned is the label passed</span>
<span class="cm"> * to gpio_request(); otherwise it is a meaningless constant.</span>
<span class="cm"> *</span>
<span class="cm"> * This function is for use by GPIO controller drivers.  The label can</span>
<span class="cm"> * help with diagnostics, and knowing that the signal is used as a GPIO</span>
<span class="cm"> * can help avoid accidentally multiplexing it to another controller.</span>
<span class="cm"> */</span>
<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="nf">gpiochip_is_requested</span><span class="p">(</span><span class="k">struct</span> <span class="n">gpio_chip</span> <span class="o">*</span><span class="n">chip</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">offset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="n">gpio</span> <span class="o">=</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">base</span> <span class="o">+</span> <span class="n">offset</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">gpio_is_valid</span><span class="p">(</span><span class="n">gpio</span><span class="p">)</span> <span class="o">||</span> <span class="n">gpio_desc</span><span class="p">[</span><span class="n">gpio</span><span class="p">].</span><span class="n">chip</span> <span class="o">!=</span> <span class="n">chip</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">FLAG_REQUESTED</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">gpio_desc</span><span class="p">[</span><span class="n">gpio</span><span class="p">].</span><span class="n">flags</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="cp">#ifdef CONFIG_DEBUG_FS</span>
	<span class="k">return</span> <span class="n">gpio_desc</span><span class="p">[</span><span class="n">gpio</span><span class="p">].</span><span class="n">label</span><span class="p">;</span>
<span class="cp">#else</span>
	<span class="k">return</span> <span class="s">&quot;?&quot;</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">gpiochip_is_requested</span><span class="p">);</span>


<span class="cm">/* Drivers MUST set GPIO direction before making get/set calls.  In</span>
<span class="cm"> * some cases this is done in early boot, before IRQs are enabled.</span>
<span class="cm"> *</span>
<span class="cm"> * As a rule these aren&#39;t called more than once (except for drivers</span>
<span class="cm"> * using the open-drain emulation idiom) so these are natural places</span>
<span class="cm"> * to accumulate extra debugging checks.  Note that we can&#39;t (yet)</span>
<span class="cm"> * rely on gpio_request() having been called beforehand.</span>
<span class="cm"> */</span>

<span class="kt">int</span> <span class="nf">gpio_direction_input</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">gpio</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">flags</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">gpio_chip</span>	<span class="o">*</span><span class="n">chip</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">gpio_desc</span>	<span class="o">*</span><span class="n">desc</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">gpio_desc</span><span class="p">[</span><span class="n">gpio</span><span class="p">];</span>
	<span class="kt">int</span>			<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gpio_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">gpio_is_valid</span><span class="p">(</span><span class="n">gpio</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
	<span class="n">chip</span> <span class="o">=</span> <span class="n">desc</span><span class="o">-&gt;</span><span class="n">chip</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">chip</span> <span class="o">||</span> <span class="o">!</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">get</span> <span class="o">||</span> <span class="o">!</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">direction_input</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
	<span class="n">gpio</span> <span class="o">-=</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">gpio</span> <span class="o">&gt;=</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">ngpio</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
	<span class="n">status</span> <span class="o">=</span> <span class="n">gpio_ensure_requested</span><span class="p">(</span><span class="n">desc</span><span class="p">,</span> <span class="n">gpio</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>

	<span class="cm">/* now we know the gpio is valid and chip won&#39;t vanish */</span>

	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gpio_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">might_sleep_if</span><span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">can_sleep</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">status</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">request</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">gpio</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;GPIO-%d: chip request fail, %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">chip</span><span class="o">-&gt;</span><span class="n">base</span> <span class="o">+</span> <span class="n">gpio</span><span class="p">,</span> <span class="n">status</span><span class="p">);</span>
			<span class="cm">/* and it&#39;s not available to anyone else ...</span>
<span class="cm">			 * gpio_request() is the fully clean solution.</span>
<span class="cm">			 */</span>
			<span class="k">goto</span> <span class="n">lose</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">status</span> <span class="o">=</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">direction_input</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">gpio</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">clear_bit</span><span class="p">(</span><span class="n">FLAG_IS_OUT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>

	<span class="n">trace_gpio_direction</span><span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">base</span> <span class="o">+</span> <span class="n">gpio</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">status</span><span class="p">);</span>
<span class="nl">lose:</span>
	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="nl">fail:</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gpio_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span><span class="p">)</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;%s: gpio-%d status %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">__func__</span><span class="p">,</span> <span class="n">gpio</span><span class="p">,</span> <span class="n">status</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">gpio_direction_input</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">gpio_direction_output</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">gpio</span><span class="p">,</span> <span class="kt">int</span> <span class="n">value</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">flags</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">gpio_chip</span>	<span class="o">*</span><span class="n">chip</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">gpio_desc</span>	<span class="o">*</span><span class="n">desc</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">gpio_desc</span><span class="p">[</span><span class="n">gpio</span><span class="p">];</span>
	<span class="kt">int</span>			<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="cm">/* Open drain pin should not be driven to 1 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">value</span> <span class="o">&amp;&amp;</span> <span class="n">test_bit</span><span class="p">(</span><span class="n">FLAG_OPEN_DRAIN</span><span class="p">,</span>  <span class="o">&amp;</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">gpio_direction_input</span><span class="p">(</span><span class="n">gpio</span><span class="p">);</span>

	<span class="cm">/* Open source pin should not be driven to 0 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">value</span> <span class="o">&amp;&amp;</span> <span class="n">test_bit</span><span class="p">(</span><span class="n">FLAG_OPEN_SOURCE</span><span class="p">,</span>  <span class="o">&amp;</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">gpio_direction_input</span><span class="p">(</span><span class="n">gpio</span><span class="p">);</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gpio_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">gpio_is_valid</span><span class="p">(</span><span class="n">gpio</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
	<span class="n">chip</span> <span class="o">=</span> <span class="n">desc</span><span class="o">-&gt;</span><span class="n">chip</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">chip</span> <span class="o">||</span> <span class="o">!</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">set</span> <span class="o">||</span> <span class="o">!</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">direction_output</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
	<span class="n">gpio</span> <span class="o">-=</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">gpio</span> <span class="o">&gt;=</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">ngpio</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
	<span class="n">status</span> <span class="o">=</span> <span class="n">gpio_ensure_requested</span><span class="p">(</span><span class="n">desc</span><span class="p">,</span> <span class="n">gpio</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>

	<span class="cm">/* now we know the gpio is valid and chip won&#39;t vanish */</span>

	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gpio_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">might_sleep_if</span><span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">can_sleep</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">status</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">request</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">gpio</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;GPIO-%d: chip request fail, %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">chip</span><span class="o">-&gt;</span><span class="n">base</span> <span class="o">+</span> <span class="n">gpio</span><span class="p">,</span> <span class="n">status</span><span class="p">);</span>
			<span class="cm">/* and it&#39;s not available to anyone else ...</span>
<span class="cm">			 * gpio_request() is the fully clean solution.</span>
<span class="cm">			 */</span>
			<span class="k">goto</span> <span class="n">lose</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">status</span> <span class="o">=</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">direction_output</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">gpio</span><span class="p">,</span> <span class="n">value</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">set_bit</span><span class="p">(</span><span class="n">FLAG_IS_OUT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
	<span class="n">trace_gpio_value</span><span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">base</span> <span class="o">+</span> <span class="n">gpio</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">value</span><span class="p">);</span>
	<span class="n">trace_gpio_direction</span><span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">base</span> <span class="o">+</span> <span class="n">gpio</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">status</span><span class="p">);</span>
<span class="nl">lose:</span>
	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="nl">fail:</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gpio_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span><span class="p">)</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;%s: gpio-%d status %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">__func__</span><span class="p">,</span> <span class="n">gpio</span><span class="p">,</span> <span class="n">status</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">gpio_direction_output</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * gpio_set_debounce - sets @debounce time for a @gpio</span>
<span class="cm"> * @gpio: the gpio to set debounce time</span>
<span class="cm"> * @debounce: debounce time is microseconds</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">gpio_set_debounce</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">gpio</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">debounce</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">flags</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">gpio_chip</span>	<span class="o">*</span><span class="n">chip</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">gpio_desc</span>	<span class="o">*</span><span class="n">desc</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">gpio_desc</span><span class="p">[</span><span class="n">gpio</span><span class="p">];</span>
	<span class="kt">int</span>			<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gpio_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">gpio_is_valid</span><span class="p">(</span><span class="n">gpio</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
	<span class="n">chip</span> <span class="o">=</span> <span class="n">desc</span><span class="o">-&gt;</span><span class="n">chip</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">chip</span> <span class="o">||</span> <span class="o">!</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">set</span> <span class="o">||</span> <span class="o">!</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">set_debounce</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
	<span class="n">gpio</span> <span class="o">-=</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">gpio</span> <span class="o">&gt;=</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">ngpio</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
	<span class="n">status</span> <span class="o">=</span> <span class="n">gpio_ensure_requested</span><span class="p">(</span><span class="n">desc</span><span class="p">,</span> <span class="n">gpio</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>

	<span class="cm">/* now we know the gpio is valid and chip won&#39;t vanish */</span>

	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gpio_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">might_sleep_if</span><span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">can_sleep</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">set_debounce</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">gpio</span><span class="p">,</span> <span class="n">debounce</span><span class="p">);</span>

<span class="nl">fail:</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gpio_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span><span class="p">)</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;%s: gpio-%d status %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">__func__</span><span class="p">,</span> <span class="n">gpio</span><span class="p">,</span> <span class="n">status</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">gpio_set_debounce</span><span class="p">);</span>

<span class="cm">/* I/O calls are only valid after configuration completed; the relevant</span>
<span class="cm"> * &quot;is this a valid GPIO&quot; error checks should already have been done.</span>
<span class="cm"> *</span>
<span class="cm"> * &quot;Get&quot; operations are often inlinable as reading a pin value register,</span>
<span class="cm"> * and masking the relevant bit in that register.</span>
<span class="cm"> *</span>
<span class="cm"> * When &quot;set&quot; operations are inlinable, they involve writing that mask to</span>
<span class="cm"> * one register to set a low value, or a different register to set it high.</span>
<span class="cm"> * Otherwise locking is needed, so there may be little value to inlining.</span>
<span class="cm"> *</span>
<span class="cm"> *------------------------------------------------------------------------</span>
<span class="cm"> *</span>
<span class="cm"> * IMPORTANT!!!  The hot paths -- get/set value -- assume that callers</span>
<span class="cm"> * have requested the GPIO.  That can include implicit requesting by</span>
<span class="cm"> * a direction setting call.  Marking a gpio as requested locks its chip</span>
<span class="cm"> * in memory, guaranteeing that these table lookups need no more locking</span>
<span class="cm"> * and that gpiochip_remove() will fail.</span>
<span class="cm"> *</span>
<span class="cm"> * REVISIT when debugging, consider adding some instrumentation to ensure</span>
<span class="cm"> * that the GPIO was actually requested.</span>
<span class="cm"> */</span>

<span class="cm">/**</span>
<span class="cm"> * __gpio_get_value() - return a gpio&#39;s value</span>
<span class="cm"> * @gpio: gpio whose value will be returned</span>
<span class="cm"> * Context: any</span>
<span class="cm"> *</span>
<span class="cm"> * This is used directly or indirectly to implement gpio_get_value().</span>
<span class="cm"> * It returns the zero or nonzero value provided by the associated</span>
<span class="cm"> * gpio_chip.get() method; or zero if no such method is provided.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">__gpio_get_value</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">gpio</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">gpio_chip</span>	<span class="o">*</span><span class="n">chip</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">value</span><span class="p">;</span>

	<span class="n">chip</span> <span class="o">=</span> <span class="n">gpio_to_chip</span><span class="p">(</span><span class="n">gpio</span><span class="p">);</span>
	<span class="cm">/* Should be using gpio_get_value_cansleep() */</span>
	<span class="n">WARN_ON</span><span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">can_sleep</span><span class="p">);</span>
	<span class="n">value</span> <span class="o">=</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">get</span> <span class="o">?</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">get</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">gpio</span> <span class="o">-</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">)</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">trace_gpio_value</span><span class="p">(</span><span class="n">gpio</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">value</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">value</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">__gpio_get_value</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> *  _gpio_set_open_drain_value() - Set the open drain gpio&#39;s value.</span>
<span class="cm"> * @gpio: Gpio whose state need to be set.</span>
<span class="cm"> * @chip: Gpio chip.</span>
<span class="cm"> * @value: Non-zero for setting it HIGH otherise it will set to LOW.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">_gpio_set_open_drain_value</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">gpio</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">gpio_chip</span> <span class="o">*</span><span class="n">chip</span><span class="p">,</span> <span class="kt">int</span> <span class="n">value</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">direction_input</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">gpio</span> <span class="o">-</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">err</span><span class="p">)</span>
			<span class="n">clear_bit</span><span class="p">(</span><span class="n">FLAG_IS_OUT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">gpio_desc</span><span class="p">[</span><span class="n">gpio</span><span class="p">].</span><span class="n">flags</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">direction_output</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">gpio</span> <span class="o">-</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">err</span><span class="p">)</span>
			<span class="n">set_bit</span><span class="p">(</span><span class="n">FLAG_IS_OUT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">gpio_desc</span><span class="p">[</span><span class="n">gpio</span><span class="p">].</span><span class="n">flags</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">trace_gpio_direction</span><span class="p">(</span><span class="n">gpio</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;%s: Error in set_value for open drain gpio%d err %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">__func__</span><span class="p">,</span> <span class="n">gpio</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *  _gpio_set_open_source() - Set the open source gpio&#39;s value.</span>
<span class="cm"> * @gpio: Gpio whose state need to be set.</span>
<span class="cm"> * @chip: Gpio chip.</span>
<span class="cm"> * @value: Non-zero for setting it HIGH otherise it will set to LOW.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">_gpio_set_open_source_value</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">gpio</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">gpio_chip</span> <span class="o">*</span><span class="n">chip</span><span class="p">,</span> <span class="kt">int</span> <span class="n">value</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">direction_output</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">gpio</span> <span class="o">-</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">err</span><span class="p">)</span>
			<span class="n">set_bit</span><span class="p">(</span><span class="n">FLAG_IS_OUT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">gpio_desc</span><span class="p">[</span><span class="n">gpio</span><span class="p">].</span><span class="n">flags</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">direction_input</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">gpio</span> <span class="o">-</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">err</span><span class="p">)</span>
			<span class="n">clear_bit</span><span class="p">(</span><span class="n">FLAG_IS_OUT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">gpio_desc</span><span class="p">[</span><span class="n">gpio</span><span class="p">].</span><span class="n">flags</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">trace_gpio_direction</span><span class="p">(</span><span class="n">gpio</span><span class="p">,</span> <span class="o">!</span><span class="n">value</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;%s: Error in set_value for open source gpio%d err %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">__func__</span><span class="p">,</span> <span class="n">gpio</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/**</span>
<span class="cm"> * __gpio_set_value() - assign a gpio&#39;s value</span>
<span class="cm"> * @gpio: gpio whose value will be assigned</span>
<span class="cm"> * @value: value to assign</span>
<span class="cm"> * Context: any</span>
<span class="cm"> *</span>
<span class="cm"> * This is used directly or indirectly to implement gpio_set_value().</span>
<span class="cm"> * It invokes the associated gpio_chip.set() method.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">__gpio_set_value</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">gpio</span><span class="p">,</span> <span class="kt">int</span> <span class="n">value</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">gpio_chip</span>	<span class="o">*</span><span class="n">chip</span><span class="p">;</span>

	<span class="n">chip</span> <span class="o">=</span> <span class="n">gpio_to_chip</span><span class="p">(</span><span class="n">gpio</span><span class="p">);</span>
	<span class="cm">/* Should be using gpio_set_value_cansleep() */</span>
	<span class="n">WARN_ON</span><span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">can_sleep</span><span class="p">);</span>
	<span class="n">trace_gpio_value</span><span class="p">(</span><span class="n">gpio</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">value</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">FLAG_OPEN_DRAIN</span><span class="p">,</span>  <span class="o">&amp;</span><span class="n">gpio_desc</span><span class="p">[</span><span class="n">gpio</span><span class="p">].</span><span class="n">flags</span><span class="p">))</span>
		<span class="n">_gpio_set_open_drain_value</span><span class="p">(</span><span class="n">gpio</span><span class="p">,</span> <span class="n">chip</span><span class="p">,</span> <span class="n">value</span><span class="p">);</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">FLAG_OPEN_SOURCE</span><span class="p">,</span>  <span class="o">&amp;</span><span class="n">gpio_desc</span><span class="p">[</span><span class="n">gpio</span><span class="p">].</span><span class="n">flags</span><span class="p">))</span>
		<span class="n">_gpio_set_open_source_value</span><span class="p">(</span><span class="n">gpio</span><span class="p">,</span> <span class="n">chip</span><span class="p">,</span> <span class="n">value</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">chip</span><span class="o">-&gt;</span><span class="n">set</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">gpio</span> <span class="o">-</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">,</span> <span class="n">value</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">__gpio_set_value</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * __gpio_cansleep() - report whether gpio value access will sleep</span>
<span class="cm"> * @gpio: gpio in question</span>
<span class="cm"> * Context: any</span>
<span class="cm"> *</span>
<span class="cm"> * This is used directly or indirectly to implement gpio_cansleep().  It</span>
<span class="cm"> * returns nonzero if access reading or writing the GPIO value can sleep.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">__gpio_cansleep</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">gpio</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">gpio_chip</span>	<span class="o">*</span><span class="n">chip</span><span class="p">;</span>

	<span class="cm">/* only call this on GPIOs that are valid! */</span>
	<span class="n">chip</span> <span class="o">=</span> <span class="n">gpio_to_chip</span><span class="p">(</span><span class="n">gpio</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">can_sleep</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">__gpio_cansleep</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * __gpio_to_irq() - return the IRQ corresponding to a GPIO</span>
<span class="cm"> * @gpio: gpio whose IRQ will be returned (already requested)</span>
<span class="cm"> * Context: any</span>
<span class="cm"> *</span>
<span class="cm"> * This is used directly or indirectly to implement gpio_to_irq().</span>
<span class="cm"> * It returns the number of the IRQ signaled by this (input) GPIO,</span>
<span class="cm"> * or a negative errno.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">__gpio_to_irq</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">gpio</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">gpio_chip</span>	<span class="o">*</span><span class="n">chip</span><span class="p">;</span>

	<span class="n">chip</span> <span class="o">=</span> <span class="n">gpio_to_chip</span><span class="p">(</span><span class="n">gpio</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">to_irq</span> <span class="o">?</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">to_irq</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">gpio</span> <span class="o">-</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">)</span> <span class="o">:</span> <span class="o">-</span><span class="n">ENXIO</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">__gpio_to_irq</span><span class="p">);</span>



<span class="cm">/* There&#39;s no value in making it easy to inline GPIO calls that may sleep.</span>
<span class="cm"> * Common examples include ones connected to I2C or SPI chips.</span>
<span class="cm"> */</span>

<span class="kt">int</span> <span class="nf">gpio_get_value_cansleep</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">gpio</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">gpio_chip</span>	<span class="o">*</span><span class="n">chip</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">value</span><span class="p">;</span>

	<span class="n">might_sleep_if</span><span class="p">(</span><span class="n">extra_checks</span><span class="p">);</span>
	<span class="n">chip</span> <span class="o">=</span> <span class="n">gpio_to_chip</span><span class="p">(</span><span class="n">gpio</span><span class="p">);</span>
	<span class="n">value</span> <span class="o">=</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">get</span> <span class="o">?</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">get</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">gpio</span> <span class="o">-</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">)</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">trace_gpio_value</span><span class="p">(</span><span class="n">gpio</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">value</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">value</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">gpio_get_value_cansleep</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">gpio_set_value_cansleep</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">gpio</span><span class="p">,</span> <span class="kt">int</span> <span class="n">value</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">gpio_chip</span>	<span class="o">*</span><span class="n">chip</span><span class="p">;</span>

	<span class="n">might_sleep_if</span><span class="p">(</span><span class="n">extra_checks</span><span class="p">);</span>
	<span class="n">chip</span> <span class="o">=</span> <span class="n">gpio_to_chip</span><span class="p">(</span><span class="n">gpio</span><span class="p">);</span>
	<span class="n">trace_gpio_value</span><span class="p">(</span><span class="n">gpio</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">value</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">FLAG_OPEN_DRAIN</span><span class="p">,</span>  <span class="o">&amp;</span><span class="n">gpio_desc</span><span class="p">[</span><span class="n">gpio</span><span class="p">].</span><span class="n">flags</span><span class="p">))</span>
		<span class="n">_gpio_set_open_drain_value</span><span class="p">(</span><span class="n">gpio</span><span class="p">,</span> <span class="n">chip</span><span class="p">,</span> <span class="n">value</span><span class="p">);</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">FLAG_OPEN_SOURCE</span><span class="p">,</span>  <span class="o">&amp;</span><span class="n">gpio_desc</span><span class="p">[</span><span class="n">gpio</span><span class="p">].</span><span class="n">flags</span><span class="p">))</span>
		<span class="n">_gpio_set_open_source_value</span><span class="p">(</span><span class="n">gpio</span><span class="p">,</span> <span class="n">chip</span><span class="p">,</span> <span class="n">value</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">chip</span><span class="o">-&gt;</span><span class="n">set</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">gpio</span> <span class="o">-</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">,</span> <span class="n">value</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">gpio_set_value_cansleep</span><span class="p">);</span>


<span class="cp">#ifdef CONFIG_DEBUG_FS</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">gpiolib_dbg_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="k">struct</span> <span class="n">gpio_chip</span> <span class="o">*</span><span class="n">chip</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span>		<span class="n">i</span><span class="p">;</span>
	<span class="kt">unsigned</span>		<span class="n">gpio</span> <span class="o">=</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">gpio_desc</span>	<span class="o">*</span><span class="n">gdesc</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">gpio_desc</span><span class="p">[</span><span class="n">gpio</span><span class="p">];</span>
	<span class="kt">int</span>			<span class="n">is_out</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">ngpio</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">,</span> <span class="n">gpio</span><span class="o">++</span><span class="p">,</span> <span class="n">gdesc</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">test_bit</span><span class="p">(</span><span class="n">FLAG_REQUESTED</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">gdesc</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">is_out</span> <span class="o">=</span> <span class="n">test_bit</span><span class="p">(</span><span class="n">FLAG_IS_OUT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">gdesc</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
		<span class="n">seq_printf</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">&quot; gpio-%-3d (%-20.20s) %s %s&quot;</span><span class="p">,</span>
			<span class="n">gpio</span><span class="p">,</span> <span class="n">gdesc</span><span class="o">-&gt;</span><span class="n">label</span><span class="p">,</span>
			<span class="n">is_out</span> <span class="o">?</span> <span class="s">&quot;out&quot;</span> <span class="o">:</span> <span class="s">&quot;in &quot;</span><span class="p">,</span>
			<span class="n">chip</span><span class="o">-&gt;</span><span class="n">get</span>
				<span class="o">?</span> <span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">get</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="o">?</span> <span class="s">&quot;hi&quot;</span> <span class="o">:</span> <span class="s">&quot;lo&quot;</span><span class="p">)</span>
				<span class="o">:</span> <span class="s">&quot;?  &quot;</span><span class="p">);</span>
		<span class="n">seq_printf</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">gpiolib_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">unused</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">gpio_chip</span>	<span class="o">*</span><span class="n">chip</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">unsigned</span>		<span class="n">gpio</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">started</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* REVISIT this isn&#39;t locked against gpio_chip removal ... */</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">gpio</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">gpio_is_valid</span><span class="p">(</span><span class="n">gpio</span><span class="p">);</span> <span class="n">gpio</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">chip</span> <span class="o">==</span> <span class="n">gpio_desc</span><span class="p">[</span><span class="n">gpio</span><span class="p">].</span><span class="n">chip</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="n">chip</span> <span class="o">=</span> <span class="n">gpio_desc</span><span class="p">[</span><span class="n">gpio</span><span class="p">].</span><span class="n">chip</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">chip</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">seq_printf</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">&quot;%sGPIOs %d-%d&quot;</span><span class="p">,</span>
				<span class="n">started</span> <span class="o">?</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span> <span class="o">:</span> <span class="s">&quot;&quot;</span><span class="p">,</span>
				<span class="n">chip</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">,</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">base</span> <span class="o">+</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">ngpio</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">dev</span> <span class="o">=</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="p">)</span>
			<span class="n">seq_printf</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">&quot;, %s/%s&quot;</span><span class="p">,</span>
				<span class="n">dev</span><span class="o">-&gt;</span><span class="n">bus</span> <span class="o">?</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">bus</span><span class="o">-&gt;</span><span class="n">name</span> <span class="o">:</span> <span class="s">&quot;no-bus&quot;</span><span class="p">,</span>
				<span class="n">dev_name</span><span class="p">(</span><span class="n">dev</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">label</span><span class="p">)</span>
			<span class="n">seq_printf</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">&quot;, %s&quot;</span><span class="p">,</span> <span class="n">chip</span><span class="o">-&gt;</span><span class="n">label</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">can_sleep</span><span class="p">)</span>
			<span class="n">seq_printf</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">&quot;, can sleep&quot;</span><span class="p">);</span>
		<span class="n">seq_printf</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">&quot;:</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

		<span class="n">started</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">dbg_show</span><span class="p">)</span>
			<span class="n">chip</span><span class="o">-&gt;</span><span class="n">dbg_show</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">chip</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">gpiolib_dbg_show</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">chip</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">gpiolib_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">single_open</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">gpiolib_show</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">gpiolib_operations</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">open</span>		<span class="o">=</span> <span class="n">gpiolib_open</span><span class="p">,</span>
	<span class="p">.</span><span class="n">read</span>		<span class="o">=</span> <span class="n">seq_read</span><span class="p">,</span>
	<span class="p">.</span><span class="n">llseek</span>		<span class="o">=</span> <span class="n">seq_lseek</span><span class="p">,</span>
	<span class="p">.</span><span class="n">release</span>	<span class="o">=</span> <span class="n">single_release</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">gpiolib_debugfs_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* /sys/kernel/debug/gpio */</span>
	<span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="n">debugfs_create_file</span><span class="p">(</span><span class="s">&quot;gpio&quot;</span><span class="p">,</span> <span class="n">S_IFREG</span> <span class="o">|</span> <span class="n">S_IRUGO</span><span class="p">,</span>
				<span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">gpiolib_operations</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">subsys_initcall</span><span class="p">(</span><span class="n">gpiolib_debugfs_init</span><span class="p">);</span>

<span class="cp">#endif	</span><span class="cm">/* DEBUG_FS */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
