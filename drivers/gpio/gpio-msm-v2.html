<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › gpio › gpio-msm-v2.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>gpio-msm-v2.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/* Copyright (c) 2010-2011, Code Aurora Forum. All rights reserved.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or modify</span>
<span class="cm"> * it under the terms of the GNU General Public License version 2 and</span>
<span class="cm"> * only version 2 as published by the Free Software Foundation.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is distributed in the hope that it will be useful,</span>
<span class="cm"> * but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="cm"> * GNU General Public License for more details.</span>
<span class="cm"> *</span>
<span class="cm"> * You should have received a copy of the GNU General Public License</span>
<span class="cm"> * along with this program; if not, write to the Free Software</span>
<span class="cm"> * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA</span>
<span class="cm"> * 02110-1301, USA.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="cp">#define pr_fmt(fmt) &quot;%s: &quot; fmt, __func__</span>

<span class="cp">#include &lt;linux/bitmap.h&gt;</span>
<span class="cp">#include &lt;linux/bitops.h&gt;</span>
<span class="cp">#include &lt;linux/gpio.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/interrupt.h&gt;</span>
<span class="cp">#include &lt;linux/io.h&gt;</span>
<span class="cp">#include &lt;linux/irq.h&gt;</span>
<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/platform_device.h&gt;</span>
<span class="cp">#include &lt;linux/spinlock.h&gt;</span>

<span class="cp">#include &lt;asm/mach/irq.h&gt;</span>

<span class="cp">#include &lt;mach/msm_gpiomux.h&gt;</span>
<span class="cp">#include &lt;mach/msm_iomap.h&gt;</span>

<span class="cm">/* Bits of interest in the GPIO_IN_OUT register.</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="p">{</span>
	<span class="n">GPIO_IN</span>  <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	<span class="n">GPIO_OUT</span> <span class="o">=</span> <span class="mi">1</span>
<span class="p">};</span>

<span class="cm">/* Bits of interest in the GPIO_INTR_STATUS register.</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="p">{</span>
	<span class="n">INTR_STATUS</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/* Bits of interest in the GPIO_CFG register.</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="p">{</span>
	<span class="n">GPIO_OE</span> <span class="o">=</span> <span class="mi">9</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/* Bits of interest in the GPIO_INTR_CFG register.</span>
<span class="cm"> * When a GPIO triggers, two separate decisions are made, controlled</span>
<span class="cm"> * by two separate flags.</span>
<span class="cm"> *</span>
<span class="cm"> * - First, INTR_RAW_STATUS_EN controls whether or not the GPIO_INTR_STATUS</span>
<span class="cm"> * register for that GPIO will be updated to reflect the triggering of that</span>
<span class="cm"> * gpio.  If this bit is 0, this register will not be updated.</span>
<span class="cm"> * - Second, INTR_ENABLE controls whether an interrupt is triggered.</span>
<span class="cm"> *</span>
<span class="cm"> * If INTR_ENABLE is set and INTR_RAW_STATUS_EN is NOT set, an interrupt</span>
<span class="cm"> * can be triggered but the status register will not reflect it.</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="p">{</span>
	<span class="n">INTR_ENABLE</span>        <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	<span class="n">INTR_POL_CTL</span>       <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
	<span class="n">INTR_DECT_CTL</span>      <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
	<span class="n">INTR_RAW_STATUS_EN</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/* Codes of interest in GPIO_INTR_CFG_SU.</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="p">{</span>
	<span class="n">TARGET_PROC_SCORPION</span> <span class="o">=</span> <span class="mi">4</span><span class="p">,</span>
	<span class="n">TARGET_PROC_NONE</span>     <span class="o">=</span> <span class="mi">7</span><span class="p">,</span>
<span class="p">};</span>


<span class="cp">#define GPIO_INTR_CFG_SU(gpio)    (MSM_TLMM_BASE + 0x0400 + (0x04 * (gpio)))</span>
<span class="cp">#define GPIO_CONFIG(gpio)         (MSM_TLMM_BASE + 0x1000 + (0x10 * (gpio)))</span>
<span class="cp">#define GPIO_IN_OUT(gpio)         (MSM_TLMM_BASE + 0x1004 + (0x10 * (gpio)))</span>
<span class="cp">#define GPIO_INTR_CFG(gpio)       (MSM_TLMM_BASE + 0x1008 + (0x10 * (gpio)))</span>
<span class="cp">#define GPIO_INTR_STATUS(gpio)    (MSM_TLMM_BASE + 0x100c + (0x10 * (gpio)))</span>

<span class="cm">/**</span>
<span class="cm"> * struct msm_gpio_dev: the MSM8660 SoC GPIO device structure</span>
<span class="cm"> *</span>
<span class="cm"> * @enabled_irqs: a bitmap used to optimize the summary-irq handler.  By</span>
<span class="cm"> * keeping track of which gpios are unmasked as irq sources, we avoid</span>
<span class="cm"> * having to do readl calls on hundreds of iomapped registers each time</span>
<span class="cm"> * the summary interrupt fires in order to locate the active interrupts.</span>
<span class="cm"> *</span>
<span class="cm"> * @wake_irqs: a bitmap for tracking which interrupt lines are enabled</span>
<span class="cm"> * as wakeup sources.  When the device is suspended, interrupts which are</span>
<span class="cm"> * not wakeup sources are disabled.</span>
<span class="cm"> *</span>
<span class="cm"> * @dual_edge_irqs: a bitmap used to track which irqs are configured</span>
<span class="cm"> * as dual-edge, as this is not supported by the hardware and requires</span>
<span class="cm"> * some special handling in the driver.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">msm_gpio_dev</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">gpio_chip</span> <span class="n">gpio_chip</span><span class="p">;</span>
	<span class="n">DECLARE_BITMAP</span><span class="p">(</span><span class="n">enabled_irqs</span><span class="p">,</span> <span class="n">NR_GPIO_IRQS</span><span class="p">);</span>
	<span class="n">DECLARE_BITMAP</span><span class="p">(</span><span class="n">wake_irqs</span><span class="p">,</span> <span class="n">NR_GPIO_IRQS</span><span class="p">);</span>
	<span class="n">DECLARE_BITMAP</span><span class="p">(</span><span class="n">dual_edge_irqs</span><span class="p">,</span> <span class="n">NR_GPIO_IRQS</span><span class="p">);</span>
<span class="p">};</span>

<span class="k">static</span> <span class="n">DEFINE_SPINLOCK</span><span class="p">(</span><span class="n">tlmm_lock</span><span class="p">);</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">msm_gpio_dev</span> <span class="o">*</span><span class="nf">to_msm_gpio_dev</span><span class="p">(</span><span class="k">struct</span> <span class="n">gpio_chip</span> <span class="o">*</span><span class="n">chip</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">container_of</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="k">struct</span> <span class="n">msm_gpio_dev</span><span class="p">,</span> <span class="n">gpio_chip</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">set_gpio_bits</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">n</span><span class="p">,</span> <span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">reg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">readl</span><span class="p">(</span><span class="n">reg</span><span class="p">)</span> <span class="o">|</span> <span class="n">n</span><span class="p">,</span> <span class="n">reg</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">clear_gpio_bits</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">n</span><span class="p">,</span> <span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">reg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">readl</span><span class="p">(</span><span class="n">reg</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">n</span><span class="p">,</span> <span class="n">reg</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">msm_gpio_get</span><span class="p">(</span><span class="k">struct</span> <span class="n">gpio_chip</span> <span class="o">*</span><span class="n">chip</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">offset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">readl</span><span class="p">(</span><span class="n">GPIO_IN_OUT</span><span class="p">(</span><span class="n">offset</span><span class="p">))</span> <span class="o">&amp;</span> <span class="n">BIT</span><span class="p">(</span><span class="n">GPIO_IN</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">msm_gpio_set</span><span class="p">(</span><span class="k">struct</span> <span class="n">gpio_chip</span> <span class="o">*</span><span class="n">chip</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">offset</span><span class="p">,</span> <span class="kt">int</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">val</span> <span class="o">?</span> <span class="n">BIT</span><span class="p">(</span><span class="n">GPIO_OUT</span><span class="p">)</span> <span class="o">:</span> <span class="mi">0</span><span class="p">,</span> <span class="n">GPIO_IN_OUT</span><span class="p">(</span><span class="n">offset</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">msm_gpio_direction_input</span><span class="p">(</span><span class="k">struct</span> <span class="n">gpio_chip</span> <span class="o">*</span><span class="n">chip</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">offset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">irq_flags</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tlmm_lock</span><span class="p">,</span> <span class="n">irq_flags</span><span class="p">);</span>
	<span class="n">clear_gpio_bits</span><span class="p">(</span><span class="n">BIT</span><span class="p">(</span><span class="n">GPIO_OE</span><span class="p">),</span> <span class="n">GPIO_CONFIG</span><span class="p">(</span><span class="n">offset</span><span class="p">));</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tlmm_lock</span><span class="p">,</span> <span class="n">irq_flags</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">msm_gpio_direction_output</span><span class="p">(</span><span class="k">struct</span> <span class="n">gpio_chip</span> <span class="o">*</span><span class="n">chip</span><span class="p">,</span>
				<span class="kt">unsigned</span> <span class="n">offset</span><span class="p">,</span>
				<span class="kt">int</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">irq_flags</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tlmm_lock</span><span class="p">,</span> <span class="n">irq_flags</span><span class="p">);</span>
	<span class="n">msm_gpio_set</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
	<span class="n">set_gpio_bits</span><span class="p">(</span><span class="n">BIT</span><span class="p">(</span><span class="n">GPIO_OE</span><span class="p">),</span> <span class="n">GPIO_CONFIG</span><span class="p">(</span><span class="n">offset</span><span class="p">));</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tlmm_lock</span><span class="p">,</span> <span class="n">irq_flags</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">msm_gpio_request</span><span class="p">(</span><span class="k">struct</span> <span class="n">gpio_chip</span> <span class="o">*</span><span class="n">chip</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">offset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">msm_gpiomux_get</span><span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">base</span> <span class="o">+</span> <span class="n">offset</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">msm_gpio_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">gpio_chip</span> <span class="o">*</span><span class="n">chip</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">offset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">msm_gpiomux_put</span><span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">base</span> <span class="o">+</span> <span class="n">offset</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">msm_gpio_to_irq</span><span class="p">(</span><span class="k">struct</span> <span class="n">gpio_chip</span> <span class="o">*</span><span class="n">chip</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">offset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">MSM_GPIO_TO_INT</span><span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">base</span> <span class="o">+</span> <span class="n">offset</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">msm_irq_to_gpio</span><span class="p">(</span><span class="k">struct</span> <span class="n">gpio_chip</span> <span class="o">*</span><span class="n">chip</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">irq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">irq</span> <span class="o">-</span> <span class="n">MSM_GPIO_TO_INT</span><span class="p">(</span><span class="n">chip</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">msm_gpio_dev</span> <span class="n">msm_gpio</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">gpio_chip</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">base</span>             <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
		<span class="p">.</span><span class="n">ngpio</span>            <span class="o">=</span> <span class="n">NR_GPIO_IRQS</span><span class="p">,</span>
		<span class="p">.</span><span class="n">direction_input</span>  <span class="o">=</span> <span class="n">msm_gpio_direction_input</span><span class="p">,</span>
		<span class="p">.</span><span class="n">direction_output</span> <span class="o">=</span> <span class="n">msm_gpio_direction_output</span><span class="p">,</span>
		<span class="p">.</span><span class="n">get</span>              <span class="o">=</span> <span class="n">msm_gpio_get</span><span class="p">,</span>
		<span class="p">.</span><span class="n">set</span>              <span class="o">=</span> <span class="n">msm_gpio_set</span><span class="p">,</span>
		<span class="p">.</span><span class="n">to_irq</span>           <span class="o">=</span> <span class="n">msm_gpio_to_irq</span><span class="p">,</span>
		<span class="p">.</span><span class="n">request</span>          <span class="o">=</span> <span class="n">msm_gpio_request</span><span class="p">,</span>
		<span class="p">.</span><span class="n">free</span>             <span class="o">=</span> <span class="n">msm_gpio_free</span><span class="p">,</span>
	<span class="p">},</span>
<span class="p">};</span>

<span class="cm">/* For dual-edge interrupts in software, since the hardware has no</span>
<span class="cm"> * such support:</span>
<span class="cm"> *</span>
<span class="cm"> * At appropriate moments, this function may be called to flip the polarity</span>
<span class="cm"> * settings of both-edge irq lines to try and catch the next edge.</span>
<span class="cm"> *</span>
<span class="cm"> * The attempt is considered successful if:</span>
<span class="cm"> * - the status bit goes high, indicating that an edge was caught, or</span>
<span class="cm"> * - the input value of the gpio doesn&#39;t change during the attempt.</span>
<span class="cm"> * If the value changes twice during the process, that would cause the first</span>
<span class="cm"> * test to fail but would force the second, as two opposite</span>
<span class="cm"> * transitions would cause a detection no matter the polarity setting.</span>
<span class="cm"> *</span>
<span class="cm"> * The do-loop tries to sledge-hammer closed the timing hole between</span>
<span class="cm"> * the initial value-read and the polarity-write - if the line value changes</span>
<span class="cm"> * during that window, an interrupt is lost, the new polarity setting is</span>
<span class="cm"> * incorrect, and the first success test will fail, causing a retry.</span>
<span class="cm"> *</span>
<span class="cm"> * Algorithm comes from Google&#39;s msmgpio driver, see mach-msm/gpio.c.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">msm_gpio_update_dual_edge_pos</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">gpio</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">loop_limit</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">val</span><span class="p">,</span> <span class="n">val2</span><span class="p">,</span> <span class="n">intstat</span><span class="p">;</span>

	<span class="k">do</span> <span class="p">{</span>
		<span class="n">val</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="n">GPIO_IN_OUT</span><span class="p">(</span><span class="n">gpio</span><span class="p">))</span> <span class="o">&amp;</span> <span class="n">BIT</span><span class="p">(</span><span class="n">GPIO_IN</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">val</span><span class="p">)</span>
			<span class="n">clear_gpio_bits</span><span class="p">(</span><span class="n">BIT</span><span class="p">(</span><span class="n">INTR_POL_CTL</span><span class="p">),</span> <span class="n">GPIO_INTR_CFG</span><span class="p">(</span><span class="n">gpio</span><span class="p">));</span>
		<span class="k">else</span>
			<span class="n">set_gpio_bits</span><span class="p">(</span><span class="n">BIT</span><span class="p">(</span><span class="n">INTR_POL_CTL</span><span class="p">),</span> <span class="n">GPIO_INTR_CFG</span><span class="p">(</span><span class="n">gpio</span><span class="p">));</span>
		<span class="n">val2</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="n">GPIO_IN_OUT</span><span class="p">(</span><span class="n">gpio</span><span class="p">))</span> <span class="o">&amp;</span> <span class="n">BIT</span><span class="p">(</span><span class="n">GPIO_IN</span><span class="p">);</span>
		<span class="n">intstat</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="n">GPIO_INTR_STATUS</span><span class="p">(</span><span class="n">gpio</span><span class="p">))</span> <span class="o">&amp;</span> <span class="n">BIT</span><span class="p">(</span><span class="n">INTR_STATUS</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">intstat</span> <span class="o">||</span> <span class="n">val</span> <span class="o">==</span> <span class="n">val2</span><span class="p">)</span>
			<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">loop_limit</span><span class="o">--</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;dual-edge irq failed to stabilize, &quot;</span>
	       <span class="s">&quot;interrupts dropped. %#08x != %#08x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	       <span class="n">val</span><span class="p">,</span> <span class="n">val2</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">msm_gpio_irq_ack</span><span class="p">(</span><span class="k">struct</span> <span class="n">irq_data</span> <span class="o">*</span><span class="n">d</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">gpio</span> <span class="o">=</span> <span class="n">msm_irq_to_gpio</span><span class="p">(</span><span class="o">&amp;</span><span class="n">msm_gpio</span><span class="p">.</span><span class="n">gpio_chip</span><span class="p">,</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">);</span>

	<span class="n">writel</span><span class="p">(</span><span class="n">BIT</span><span class="p">(</span><span class="n">INTR_STATUS</span><span class="p">),</span> <span class="n">GPIO_INTR_STATUS</span><span class="p">(</span><span class="n">gpio</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">gpio</span><span class="p">,</span> <span class="n">msm_gpio</span><span class="p">.</span><span class="n">dual_edge_irqs</span><span class="p">))</span>
		<span class="n">msm_gpio_update_dual_edge_pos</span><span class="p">(</span><span class="n">gpio</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">msm_gpio_irq_mask</span><span class="p">(</span><span class="k">struct</span> <span class="n">irq_data</span> <span class="o">*</span><span class="n">d</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">gpio</span> <span class="o">=</span> <span class="n">msm_irq_to_gpio</span><span class="p">(</span><span class="o">&amp;</span><span class="n">msm_gpio</span><span class="p">.</span><span class="n">gpio_chip</span><span class="p">,</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">irq_flags</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tlmm_lock</span><span class="p">,</span> <span class="n">irq_flags</span><span class="p">);</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">TARGET_PROC_NONE</span><span class="p">,</span> <span class="n">GPIO_INTR_CFG_SU</span><span class="p">(</span><span class="n">gpio</span><span class="p">));</span>
	<span class="n">clear_gpio_bits</span><span class="p">(</span><span class="n">INTR_RAW_STATUS_EN</span> <span class="o">|</span> <span class="n">INTR_ENABLE</span><span class="p">,</span> <span class="n">GPIO_INTR_CFG</span><span class="p">(</span><span class="n">gpio</span><span class="p">));</span>
	<span class="n">__clear_bit</span><span class="p">(</span><span class="n">gpio</span><span class="p">,</span> <span class="n">msm_gpio</span><span class="p">.</span><span class="n">enabled_irqs</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tlmm_lock</span><span class="p">,</span> <span class="n">irq_flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">msm_gpio_irq_unmask</span><span class="p">(</span><span class="k">struct</span> <span class="n">irq_data</span> <span class="o">*</span><span class="n">d</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">gpio</span> <span class="o">=</span> <span class="n">msm_irq_to_gpio</span><span class="p">(</span><span class="o">&amp;</span><span class="n">msm_gpio</span><span class="p">.</span><span class="n">gpio_chip</span><span class="p">,</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">irq_flags</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tlmm_lock</span><span class="p">,</span> <span class="n">irq_flags</span><span class="p">);</span>
	<span class="n">__set_bit</span><span class="p">(</span><span class="n">gpio</span><span class="p">,</span> <span class="n">msm_gpio</span><span class="p">.</span><span class="n">enabled_irqs</span><span class="p">);</span>
	<span class="n">set_gpio_bits</span><span class="p">(</span><span class="n">INTR_RAW_STATUS_EN</span> <span class="o">|</span> <span class="n">INTR_ENABLE</span><span class="p">,</span> <span class="n">GPIO_INTR_CFG</span><span class="p">(</span><span class="n">gpio</span><span class="p">));</span>
	<span class="n">writel</span><span class="p">(</span><span class="n">TARGET_PROC_SCORPION</span><span class="p">,</span> <span class="n">GPIO_INTR_CFG_SU</span><span class="p">(</span><span class="n">gpio</span><span class="p">));</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tlmm_lock</span><span class="p">,</span> <span class="n">irq_flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">msm_gpio_irq_set_type</span><span class="p">(</span><span class="k">struct</span> <span class="n">irq_data</span> <span class="o">*</span><span class="n">d</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">flow_type</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">gpio</span> <span class="o">=</span> <span class="n">msm_irq_to_gpio</span><span class="p">(</span><span class="o">&amp;</span><span class="n">msm_gpio</span><span class="p">.</span><span class="n">gpio_chip</span><span class="p">,</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">irq_flags</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">bits</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tlmm_lock</span><span class="p">,</span> <span class="n">irq_flags</span><span class="p">);</span>

	<span class="n">bits</span> <span class="o">=</span> <span class="n">readl</span><span class="p">(</span><span class="n">GPIO_INTR_CFG</span><span class="p">(</span><span class="n">gpio</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">flow_type</span> <span class="o">&amp;</span> <span class="n">IRQ_TYPE_EDGE_BOTH</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">bits</span> <span class="o">|=</span> <span class="n">BIT</span><span class="p">(</span><span class="n">INTR_DECT_CTL</span><span class="p">);</span>
		<span class="n">__irq_set_handler_locked</span><span class="p">(</span><span class="n">d</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">,</span> <span class="n">handle_edge_irq</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">flow_type</span> <span class="o">&amp;</span> <span class="n">IRQ_TYPE_EDGE_BOTH</span><span class="p">)</span> <span class="o">==</span> <span class="n">IRQ_TYPE_EDGE_BOTH</span><span class="p">)</span>
			<span class="n">__set_bit</span><span class="p">(</span><span class="n">gpio</span><span class="p">,</span> <span class="n">msm_gpio</span><span class="p">.</span><span class="n">dual_edge_irqs</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">__clear_bit</span><span class="p">(</span><span class="n">gpio</span><span class="p">,</span> <span class="n">msm_gpio</span><span class="p">.</span><span class="n">dual_edge_irqs</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">bits</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">BIT</span><span class="p">(</span><span class="n">INTR_DECT_CTL</span><span class="p">);</span>
		<span class="n">__irq_set_handler_locked</span><span class="p">(</span><span class="n">d</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">,</span> <span class="n">handle_level_irq</span><span class="p">);</span>
		<span class="n">__clear_bit</span><span class="p">(</span><span class="n">gpio</span><span class="p">,</span> <span class="n">msm_gpio</span><span class="p">.</span><span class="n">dual_edge_irqs</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">flow_type</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">IRQ_TYPE_EDGE_RISING</span> <span class="o">|</span> <span class="n">IRQ_TYPE_LEVEL_HIGH</span><span class="p">))</span>
		<span class="n">bits</span> <span class="o">|=</span> <span class="n">BIT</span><span class="p">(</span><span class="n">INTR_POL_CTL</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">bits</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">BIT</span><span class="p">(</span><span class="n">INTR_POL_CTL</span><span class="p">);</span>

	<span class="n">writel</span><span class="p">(</span><span class="n">bits</span><span class="p">,</span> <span class="n">GPIO_INTR_CFG</span><span class="p">(</span><span class="n">gpio</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">flow_type</span> <span class="o">&amp;</span> <span class="n">IRQ_TYPE_EDGE_BOTH</span><span class="p">)</span> <span class="o">==</span> <span class="n">IRQ_TYPE_EDGE_BOTH</span><span class="p">)</span>
		<span class="n">msm_gpio_update_dual_edge_pos</span><span class="p">(</span><span class="n">gpio</span><span class="p">);</span>

	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tlmm_lock</span><span class="p">,</span> <span class="n">irq_flags</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * When the summary IRQ is raised, any number of GPIO lines may be high.</span>
<span class="cm"> * It is the job of the summary handler to find all those GPIO lines</span>
<span class="cm"> * which have been set as summary IRQ lines and which are triggered,</span>
<span class="cm"> * and to call their interrupt handlers.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">msm_summary_irq_handler</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">irq_desc</span> <span class="o">*</span><span class="n">desc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">irq_chip</span> <span class="o">*</span><span class="n">chip</span> <span class="o">=</span> <span class="n">irq_desc_get_chip</span><span class="p">(</span><span class="n">desc</span><span class="p">);</span>

	<span class="n">chained_irq_enter</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">desc</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">find_first_bit</span><span class="p">(</span><span class="n">msm_gpio</span><span class="p">.</span><span class="n">enabled_irqs</span><span class="p">,</span> <span class="n">NR_GPIO_IRQS</span><span class="p">);</span>
	     <span class="n">i</span> <span class="o">&lt;</span> <span class="n">NR_GPIO_IRQS</span><span class="p">;</span>
	     <span class="n">i</span> <span class="o">=</span> <span class="n">find_next_bit</span><span class="p">(</span><span class="n">msm_gpio</span><span class="p">.</span><span class="n">enabled_irqs</span><span class="p">,</span> <span class="n">NR_GPIO_IRQS</span><span class="p">,</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">readl</span><span class="p">(</span><span class="n">GPIO_INTR_STATUS</span><span class="p">(</span><span class="n">i</span><span class="p">))</span> <span class="o">&amp;</span> <span class="n">BIT</span><span class="p">(</span><span class="n">INTR_STATUS</span><span class="p">))</span>
			<span class="n">generic_handle_irq</span><span class="p">(</span><span class="n">msm_gpio_to_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">msm_gpio</span><span class="p">.</span><span class="n">gpio_chip</span><span class="p">,</span>
							   <span class="n">i</span><span class="p">));</span>
	<span class="p">}</span>

	<span class="n">chained_irq_exit</span><span class="p">(</span><span class="n">chip</span><span class="p">,</span> <span class="n">desc</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">msm_gpio_irq_set_wake</span><span class="p">(</span><span class="k">struct</span> <span class="n">irq_data</span> <span class="o">*</span><span class="n">d</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">on</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">gpio</span> <span class="o">=</span> <span class="n">msm_irq_to_gpio</span><span class="p">(</span><span class="o">&amp;</span><span class="n">msm_gpio</span><span class="p">.</span><span class="n">gpio_chip</span><span class="p">,</span> <span class="n">d</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">on</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">bitmap_empty</span><span class="p">(</span><span class="n">msm_gpio</span><span class="p">.</span><span class="n">wake_irqs</span><span class="p">,</span> <span class="n">NR_GPIO_IRQS</span><span class="p">))</span>
			<span class="n">irq_set_irq_wake</span><span class="p">(</span><span class="n">TLMM_SCSS_SUMMARY_IRQ</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">set_bit</span><span class="p">(</span><span class="n">gpio</span><span class="p">,</span> <span class="n">msm_gpio</span><span class="p">.</span><span class="n">wake_irqs</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">clear_bit</span><span class="p">(</span><span class="n">gpio</span><span class="p">,</span> <span class="n">msm_gpio</span><span class="p">.</span><span class="n">wake_irqs</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">bitmap_empty</span><span class="p">(</span><span class="n">msm_gpio</span><span class="p">.</span><span class="n">wake_irqs</span><span class="p">,</span> <span class="n">NR_GPIO_IRQS</span><span class="p">))</span>
			<span class="n">irq_set_irq_wake</span><span class="p">(</span><span class="n">TLMM_SCSS_SUMMARY_IRQ</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">irq_chip</span> <span class="n">msm_gpio_irq_chip</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">name</span>		<span class="o">=</span> <span class="s">&quot;msmgpio&quot;</span><span class="p">,</span>
	<span class="p">.</span><span class="n">irq_mask</span>	<span class="o">=</span> <span class="n">msm_gpio_irq_mask</span><span class="p">,</span>
	<span class="p">.</span><span class="n">irq_unmask</span>	<span class="o">=</span> <span class="n">msm_gpio_irq_unmask</span><span class="p">,</span>
	<span class="p">.</span><span class="n">irq_ack</span>	<span class="o">=</span> <span class="n">msm_gpio_irq_ack</span><span class="p">,</span>
	<span class="p">.</span><span class="n">irq_set_type</span>	<span class="o">=</span> <span class="n">msm_gpio_irq_set_type</span><span class="p">,</span>
	<span class="p">.</span><span class="n">irq_set_wake</span>	<span class="o">=</span> <span class="n">msm_gpio_irq_set_wake</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__devinit</span> <span class="nf">msm_gpio_probe</span><span class="p">(</span><span class="k">struct</span> <span class="n">platform_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">irq</span><span class="p">,</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">bitmap_zero</span><span class="p">(</span><span class="n">msm_gpio</span><span class="p">.</span><span class="n">enabled_irqs</span><span class="p">,</span> <span class="n">NR_GPIO_IRQS</span><span class="p">);</span>
	<span class="n">bitmap_zero</span><span class="p">(</span><span class="n">msm_gpio</span><span class="p">.</span><span class="n">wake_irqs</span><span class="p">,</span> <span class="n">NR_GPIO_IRQS</span><span class="p">);</span>
	<span class="n">bitmap_zero</span><span class="p">(</span><span class="n">msm_gpio</span><span class="p">.</span><span class="n">dual_edge_irqs</span><span class="p">,</span> <span class="n">NR_GPIO_IRQS</span><span class="p">);</span>
	<span class="n">msm_gpio</span><span class="p">.</span><span class="n">gpio_chip</span><span class="p">.</span><span class="n">label</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">;</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">gpiochip_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">msm_gpio</span><span class="p">.</span><span class="n">gpio_chip</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">msm_gpio</span><span class="p">.</span><span class="n">gpio_chip</span><span class="p">.</span><span class="n">ngpio</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">irq</span> <span class="o">=</span> <span class="n">msm_gpio_to_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">msm_gpio</span><span class="p">.</span><span class="n">gpio_chip</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
		<span class="n">irq_set_chip_and_handler</span><span class="p">(</span><span class="n">irq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">msm_gpio_irq_chip</span><span class="p">,</span>
					 <span class="n">handle_level_irq</span><span class="p">);</span>
		<span class="n">set_irq_flags</span><span class="p">(</span><span class="n">irq</span><span class="p">,</span> <span class="n">IRQF_VALID</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">irq_set_chained_handler</span><span class="p">(</span><span class="n">TLMM_SCSS_SUMMARY_IRQ</span><span class="p">,</span>
				<span class="n">msm_summary_irq_handler</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__devexit</span> <span class="nf">msm_gpio_remove</span><span class="p">(</span><span class="k">struct</span> <span class="n">platform_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">gpiochip_remove</span><span class="p">(</span><span class="o">&amp;</span><span class="n">msm_gpio</span><span class="p">.</span><span class="n">gpio_chip</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">irq_set_handler</span><span class="p">(</span><span class="n">TLMM_SCSS_SUMMARY_IRQ</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">platform_driver</span> <span class="n">msm_gpio_driver</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">probe</span> <span class="o">=</span> <span class="n">msm_gpio_probe</span><span class="p">,</span>
	<span class="p">.</span><span class="n">remove</span> <span class="o">=</span> <span class="n">__devexit_p</span><span class="p">(</span><span class="n">msm_gpio_remove</span><span class="p">),</span>
	<span class="p">.</span><span class="n">driver</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;msmgpio&quot;</span><span class="p">,</span>
		<span class="p">.</span><span class="n">owner</span> <span class="o">=</span> <span class="n">THIS_MODULE</span><span class="p">,</span>
	<span class="p">},</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">platform_device</span> <span class="n">msm_device_gpio</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;msmgpio&quot;</span><span class="p">,</span>
	<span class="p">.</span><span class="n">id</span>   <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">msm_gpio_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">platform_driver_register</span><span class="p">(</span><span class="o">&amp;</span><span class="n">msm_gpio_driver</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">platform_device_register</span><span class="p">(</span><span class="o">&amp;</span><span class="n">msm_device_gpio</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
			<span class="n">platform_driver_unregister</span><span class="p">(</span><span class="o">&amp;</span><span class="n">msm_gpio_driver</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__exit</span> <span class="nf">msm_gpio_exit</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">platform_device_unregister</span><span class="p">(</span><span class="o">&amp;</span><span class="n">msm_device_gpio</span><span class="p">);</span>
	<span class="n">platform_driver_unregister</span><span class="p">(</span><span class="o">&amp;</span><span class="n">msm_gpio_driver</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">postcore_initcall</span><span class="p">(</span><span class="n">msm_gpio_init</span><span class="p">);</span>
<span class="n">module_exit</span><span class="p">(</span><span class="n">msm_gpio_exit</span><span class="p">);</span>

<span class="n">MODULE_AUTHOR</span><span class="p">(</span><span class="s">&quot;Gregory Bean &lt;gbean@codeaurora.org&gt;&quot;</span><span class="p">);</span>
<span class="n">MODULE_DESCRIPTION</span><span class="p">(</span><span class="s">&quot;Driver for Qualcomm MSM TLMMv2 SoC GPIOs&quot;</span><span class="p">);</span>
<span class="n">MODULE_LICENSE</span><span class="p">(</span><span class="s">&quot;GPL v2&quot;</span><span class="p">);</span>
<span class="n">MODULE_ALIAS</span><span class="p">(</span><span class="s">&quot;platform:msmgpio&quot;</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
