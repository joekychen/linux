<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › parport › share.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>share.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Parallel-port resource manager code.</span>
<span class="cm"> * </span>
<span class="cm"> * Authors: David Campbell &lt;campbell@tirian.che.curtin.edu.au&gt;</span>
<span class="cm"> *          Tim Waugh &lt;tim@cyberelk.demon.co.uk&gt;</span>
<span class="cm"> *          Jose Renau &lt;renau@acm.org&gt;</span>
<span class="cm"> *          Philip Blundell &lt;philb@gnu.org&gt;</span>
<span class="cm"> *	    Andrea Arcangeli</span>
<span class="cm"> *</span>
<span class="cm"> * based on work by Grant Guenther &lt;grant@torque.net&gt;</span>
<span class="cm"> *          and Philip Blundell</span>
<span class="cm"> *</span>
<span class="cm"> * Any part of this program may be used in documents licensed under</span>
<span class="cm"> * the GNU Free Documentation License, Version 1.1 or any later version</span>
<span class="cm"> * published by the Free Software Foundation.</span>
<span class="cm"> */</span>

<span class="cp">#undef PARPORT_DEBUG_SHARING		</span><span class="cm">/* undef for production */</span><span class="cp"></span>

<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/string.h&gt;</span>
<span class="cp">#include &lt;linux/threads.h&gt;</span>
<span class="cp">#include &lt;linux/parport.h&gt;</span>
<span class="cp">#include &lt;linux/delay.h&gt;</span>
<span class="cp">#include &lt;linux/errno.h&gt;</span>
<span class="cp">#include &lt;linux/interrupt.h&gt;</span>
<span class="cp">#include &lt;linux/ioport.h&gt;</span>
<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/sched.h&gt;</span>
<span class="cp">#include &lt;linux/kmod.h&gt;</span>

<span class="cp">#include &lt;linux/spinlock.h&gt;</span>
<span class="cp">#include &lt;linux/mutex.h&gt;</span>
<span class="cp">#include &lt;asm/irq.h&gt;</span>

<span class="cp">#undef PARPORT_PARANOID</span>

<span class="cp">#define PARPORT_DEFAULT_TIMESLICE	(HZ/5)</span>

<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">parport_default_timeslice</span> <span class="o">=</span> <span class="n">PARPORT_DEFAULT_TIMESLICE</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">parport_default_spintime</span> <span class="o">=</span>  <span class="n">DEFAULT_SPIN_TIME</span><span class="p">;</span>

<span class="k">static</span> <span class="n">LIST_HEAD</span><span class="p">(</span><span class="n">portlist</span><span class="p">);</span>
<span class="k">static</span> <span class="n">DEFINE_SPINLOCK</span><span class="p">(</span><span class="n">parportlist_lock</span><span class="p">);</span>

<span class="cm">/* list of all allocated ports, sorted by -&gt;number */</span>
<span class="k">static</span> <span class="n">LIST_HEAD</span><span class="p">(</span><span class="n">all_ports</span><span class="p">);</span>
<span class="k">static</span> <span class="n">DEFINE_SPINLOCK</span><span class="p">(</span><span class="n">full_list_lock</span><span class="p">);</span>

<span class="k">static</span> <span class="n">LIST_HEAD</span><span class="p">(</span><span class="n">drivers</span><span class="p">);</span>

<span class="k">static</span> <span class="n">DEFINE_MUTEX</span><span class="p">(</span><span class="n">registration_lock</span><span class="p">);</span>

<span class="cm">/* What you can do to a port that&#39;s gone away.. */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">dead_write_lines</span> <span class="p">(</span><span class="k">struct</span> <span class="n">parport</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">b</span><span class="p">){}</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">dead_read_lines</span> <span class="p">(</span><span class="k">struct</span> <span class="n">parport</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span> <span class="p">}</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="nf">dead_frob_lines</span> <span class="p">(</span><span class="k">struct</span> <span class="n">parport</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">b</span><span class="p">,</span>
			     <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">c</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span> <span class="p">}</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">dead_onearg</span> <span class="p">(</span><span class="k">struct</span> <span class="n">parport</span> <span class="o">*</span><span class="n">p</span><span class="p">){}</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">dead_initstate</span> <span class="p">(</span><span class="k">struct</span> <span class="n">pardevice</span> <span class="o">*</span><span class="n">d</span><span class="p">,</span> <span class="k">struct</span> <span class="n">parport_state</span> <span class="o">*</span><span class="n">s</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">dead_state</span> <span class="p">(</span><span class="k">struct</span> <span class="n">parport</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="k">struct</span> <span class="n">parport_state</span> <span class="o">*</span><span class="n">s</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
<span class="k">static</span> <span class="kt">size_t</span> <span class="nf">dead_write</span> <span class="p">(</span><span class="k">struct</span> <span class="n">parport</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">b</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">l</span><span class="p">,</span> <span class="kt">int</span> <span class="n">f</span><span class="p">)</span>
<span class="p">{</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span> <span class="p">}</span>
<span class="k">static</span> <span class="kt">size_t</span> <span class="nf">dead_read</span> <span class="p">(</span><span class="k">struct</span> <span class="n">parport</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">b</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">l</span><span class="p">,</span> <span class="kt">int</span> <span class="n">f</span><span class="p">)</span>
<span class="p">{</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span> <span class="p">}</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">parport_operations</span> <span class="n">dead_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">write_data</span>	<span class="o">=</span> <span class="n">dead_write_lines</span><span class="p">,</span>	<span class="cm">/* data */</span>
	<span class="p">.</span><span class="n">read_data</span>	<span class="o">=</span> <span class="n">dead_read_lines</span><span class="p">,</span>

	<span class="p">.</span><span class="n">write_control</span>	<span class="o">=</span> <span class="n">dead_write_lines</span><span class="p">,</span>	<span class="cm">/* control */</span>
	<span class="p">.</span><span class="n">read_control</span>	<span class="o">=</span> <span class="n">dead_read_lines</span><span class="p">,</span>
	<span class="p">.</span><span class="n">frob_control</span>	<span class="o">=</span> <span class="n">dead_frob_lines</span><span class="p">,</span>

	<span class="p">.</span><span class="n">read_status</span>	<span class="o">=</span> <span class="n">dead_read_lines</span><span class="p">,</span>	<span class="cm">/* status */</span>

	<span class="p">.</span><span class="n">enable_irq</span>	<span class="o">=</span> <span class="n">dead_onearg</span><span class="p">,</span>		<span class="cm">/* enable_irq */</span>
	<span class="p">.</span><span class="n">disable_irq</span>	<span class="o">=</span> <span class="n">dead_onearg</span><span class="p">,</span>		<span class="cm">/* disable_irq */</span>

	<span class="p">.</span><span class="n">data_forward</span>	<span class="o">=</span> <span class="n">dead_onearg</span><span class="p">,</span>		<span class="cm">/* data_forward */</span>
	<span class="p">.</span><span class="n">data_reverse</span>	<span class="o">=</span> <span class="n">dead_onearg</span><span class="p">,</span>		<span class="cm">/* data_reverse */</span>

	<span class="p">.</span><span class="n">init_state</span>	<span class="o">=</span> <span class="n">dead_initstate</span><span class="p">,</span>	<span class="cm">/* init_state */</span>
	<span class="p">.</span><span class="n">save_state</span>	<span class="o">=</span> <span class="n">dead_state</span><span class="p">,</span>
	<span class="p">.</span><span class="n">restore_state</span>	<span class="o">=</span> <span class="n">dead_state</span><span class="p">,</span>

	<span class="p">.</span><span class="n">epp_write_data</span>	<span class="o">=</span> <span class="n">dead_write</span><span class="p">,</span>		<span class="cm">/* epp */</span>
	<span class="p">.</span><span class="n">epp_read_data</span>	<span class="o">=</span> <span class="n">dead_read</span><span class="p">,</span>
	<span class="p">.</span><span class="n">epp_write_addr</span>	<span class="o">=</span> <span class="n">dead_write</span><span class="p">,</span>
	<span class="p">.</span><span class="n">epp_read_addr</span>	<span class="o">=</span> <span class="n">dead_read</span><span class="p">,</span>

	<span class="p">.</span><span class="n">ecp_write_data</span>	<span class="o">=</span> <span class="n">dead_write</span><span class="p">,</span>		<span class="cm">/* ecp */</span>
	<span class="p">.</span><span class="n">ecp_read_data</span>	<span class="o">=</span> <span class="n">dead_read</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ecp_write_addr</span>	<span class="o">=</span> <span class="n">dead_write</span><span class="p">,</span>
 
	<span class="p">.</span><span class="n">compat_write_data</span>	<span class="o">=</span> <span class="n">dead_write</span><span class="p">,</span>	<span class="cm">/* compat */</span>
	<span class="p">.</span><span class="n">nibble_read_data</span>	<span class="o">=</span> <span class="n">dead_read</span><span class="p">,</span>	<span class="cm">/* nibble */</span>
	<span class="p">.</span><span class="n">byte_read_data</span>		<span class="o">=</span> <span class="n">dead_read</span><span class="p">,</span>	<span class="cm">/* byte */</span>

	<span class="p">.</span><span class="n">owner</span>		<span class="o">=</span> <span class="nb">NULL</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/* Call attach(port) for each registered driver. */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">attach_driver_chain</span><span class="p">(</span><span class="k">struct</span> <span class="n">parport</span> <span class="o">*</span><span class="n">port</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* caller has exclusive registration_lock */</span>
	<span class="k">struct</span> <span class="n">parport_driver</span> <span class="o">*</span><span class="n">drv</span><span class="p">;</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">drv</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">drivers</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span>
		<span class="n">drv</span><span class="o">-&gt;</span><span class="n">attach</span><span class="p">(</span><span class="n">port</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Call detach(port) for each registered driver. */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">detach_driver_chain</span><span class="p">(</span><span class="k">struct</span> <span class="n">parport</span> <span class="o">*</span><span class="n">port</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">parport_driver</span> <span class="o">*</span><span class="n">drv</span><span class="p">;</span>
	<span class="cm">/* caller has exclusive registration_lock */</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">drv</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">drivers</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span>
		<span class="n">drv</span><span class="o">-&gt;</span><span class="n">detach</span> <span class="p">(</span><span class="n">port</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Ask kmod for some lowlevel drivers. */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">get_lowlevel_driver</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* There is no actual module called this: you should set</span>
<span class="cm">	 * up an alias for modutils. */</span>
	<span class="n">request_module</span> <span class="p">(</span><span class="s">&quot;parport_lowlevel&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	parport_register_driver - register a parallel port device driver</span>
<span class="cm"> *	@drv: structure describing the driver</span>
<span class="cm"> *</span>
<span class="cm"> *	This can be called by a parallel port device driver in order</span>
<span class="cm"> *	to receive notifications about ports being found in the</span>
<span class="cm"> *	system, as well as ports no longer available.</span>
<span class="cm"> *</span>
<span class="cm"> *	The @drv structure is allocated by the caller and must not be</span>
<span class="cm"> *	deallocated until after calling parport_unregister_driver().</span>
<span class="cm"> *</span>
<span class="cm"> *	The driver&#39;s attach() function may block.  The port that</span>
<span class="cm"> *	attach() is given will be valid for the duration of the</span>
<span class="cm"> *	callback, but if the driver wants to take a copy of the</span>
<span class="cm"> *	pointer it must call parport_get_port() to do so.  Calling</span>
<span class="cm"> *	parport_register_device() on that port will do this for you.</span>
<span class="cm"> *</span>
<span class="cm"> *	The driver&#39;s detach() function may block.  The port that</span>
<span class="cm"> *	detach() is given will be valid for the duration of the</span>
<span class="cm"> *	callback, but if the driver wants to take a copy of the</span>
<span class="cm"> *	pointer it must call parport_get_port() to do so.</span>
<span class="cm"> *</span>
<span class="cm"> *	Returns 0 on success.  Currently it always succeeds.</span>
<span class="cm"> **/</span>

<span class="kt">int</span> <span class="nf">parport_register_driver</span> <span class="p">(</span><span class="k">struct</span> <span class="n">parport_driver</span> <span class="o">*</span><span class="n">drv</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">parport</span> <span class="o">*</span><span class="n">port</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">portlist</span><span class="p">))</span>
		<span class="n">get_lowlevel_driver</span> <span class="p">();</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">registration_lock</span><span class="p">);</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">port</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">portlist</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span>
		<span class="n">drv</span><span class="o">-&gt;</span><span class="n">attach</span><span class="p">(</span><span class="n">port</span><span class="p">);</span>
	<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">drv</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">drivers</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">registration_lock</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	parport_unregister_driver - deregister a parallel port device driver</span>
<span class="cm"> *	@drv: structure describing the driver that was given to</span>
<span class="cm"> *	      parport_register_driver()</span>
<span class="cm"> *</span>
<span class="cm"> *	This should be called by a parallel port device driver that</span>
<span class="cm"> *	has registered itself using parport_register_driver() when it</span>
<span class="cm"> *	is about to be unloaded.</span>
<span class="cm"> *</span>
<span class="cm"> *	When it returns, the driver&#39;s attach() routine will no longer</span>
<span class="cm"> *	be called, and for each port that attach() was called for, the</span>
<span class="cm"> *	detach() routine will have been called.</span>
<span class="cm"> *</span>
<span class="cm"> *	All the driver&#39;s attach() and detach() calls are guaranteed to have</span>
<span class="cm"> *	finished by the time this function returns.</span>
<span class="cm"> **/</span>

<span class="kt">void</span> <span class="nf">parport_unregister_driver</span> <span class="p">(</span><span class="k">struct</span> <span class="n">parport_driver</span> <span class="o">*</span><span class="n">drv</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">parport</span> <span class="o">*</span><span class="n">port</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">registration_lock</span><span class="p">);</span>
	<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">drv</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">port</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">portlist</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span>
		<span class="n">drv</span><span class="o">-&gt;</span><span class="n">detach</span><span class="p">(</span><span class="n">port</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">registration_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">free_port</span> <span class="p">(</span><span class="k">struct</span> <span class="n">parport</span> <span class="o">*</span><span class="n">port</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">d</span><span class="p">;</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">full_list_lock</span><span class="p">);</span>
	<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">full_list</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">full_list_lock</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">d</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">d</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="p">;</span> <span class="n">d</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">probe_info</span><span class="p">[</span><span class="n">d</span><span class="p">].</span><span class="n">class_name</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">probe_info</span><span class="p">[</span><span class="n">d</span><span class="p">].</span><span class="n">mfr</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">probe_info</span><span class="p">[</span><span class="n">d</span><span class="p">].</span><span class="n">model</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">probe_info</span><span class="p">[</span><span class="n">d</span><span class="p">].</span><span class="n">cmdset</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">probe_info</span><span class="p">[</span><span class="n">d</span><span class="p">].</span><span class="n">description</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">kfree</span><span class="p">(</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">port</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	parport_get_port - increment a port&#39;s reference count</span>
<span class="cm"> *	@port: the port</span>
<span class="cm"> *</span>
<span class="cm"> *	This ensures that a struct parport pointer remains valid</span>
<span class="cm"> *	until the matching parport_put_port() call.</span>
<span class="cm"> **/</span>

<span class="k">struct</span> <span class="n">parport</span> <span class="o">*</span><span class="nf">parport_get_port</span> <span class="p">(</span><span class="k">struct</span> <span class="n">parport</span> <span class="o">*</span><span class="n">port</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">atomic_inc</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">ref_count</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">port</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	parport_put_port - decrement a port&#39;s reference count</span>
<span class="cm"> *	@port: the port</span>
<span class="cm"> *</span>
<span class="cm"> *	This should be called once for each call to parport_get_port(),</span>
<span class="cm"> *	once the port is no longer needed.</span>
<span class="cm"> **/</span>

<span class="kt">void</span> <span class="nf">parport_put_port</span> <span class="p">(</span><span class="k">struct</span> <span class="n">parport</span> <span class="o">*</span><span class="n">port</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">atomic_dec_and_test</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">ref_count</span><span class="p">))</span>
		<span class="cm">/* Can destroy it now. */</span>
		<span class="n">free_port</span> <span class="p">(</span><span class="n">port</span><span class="p">);</span>

	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	parport_register_port - register a parallel port</span>
<span class="cm"> *	@base: base I/O address</span>
<span class="cm"> *	@irq: IRQ line</span>
<span class="cm"> *	@dma: DMA channel</span>
<span class="cm"> *	@ops: pointer to the port driver&#39;s port operations structure</span>
<span class="cm"> *</span>
<span class="cm"> *	When a parallel port (lowlevel) driver finds a port that</span>
<span class="cm"> *	should be made available to parallel port device drivers, it</span>
<span class="cm"> *	should call parport_register_port().  The @base, @irq, and</span>
<span class="cm"> *	@dma parameters are for the convenience of port drivers, and</span>
<span class="cm"> *	for ports where they aren&#39;t meaningful needn&#39;t be set to</span>
<span class="cm"> *	anything special.  They can be altered afterwards by adjusting</span>
<span class="cm"> *	the relevant members of the parport structure that is returned</span>
<span class="cm"> *	and represents the port.  They should not be tampered with</span>
<span class="cm"> *	after calling parport_announce_port, however.</span>
<span class="cm"> *</span>
<span class="cm"> *	If there are parallel port device drivers in the system that</span>
<span class="cm"> *	have registered themselves using parport_register_driver(),</span>
<span class="cm"> *	they are not told about the port at this time; that is done by</span>
<span class="cm"> *	parport_announce_port().</span>
<span class="cm"> *</span>
<span class="cm"> *	The @ops structure is allocated by the caller, and must not be</span>
<span class="cm"> *	deallocated before calling parport_remove_port().</span>
<span class="cm"> *</span>
<span class="cm"> *	If there is no memory to allocate a new parport structure,</span>
<span class="cm"> *	this function will return %NULL.</span>
<span class="cm"> **/</span>

<span class="k">struct</span> <span class="n">parport</span> <span class="o">*</span><span class="nf">parport_register_port</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">base</span><span class="p">,</span> <span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">int</span> <span class="n">dma</span><span class="p">,</span>
				      <span class="k">struct</span> <span class="n">parport_operations</span> <span class="o">*</span><span class="n">ops</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">l</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">parport</span> <span class="o">*</span><span class="n">tmp</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">num</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">device</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">;</span>

	<span class="n">tmp</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">parport</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tmp</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;parport: memory squeeze</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Init our structure */</span>
 	<span class="n">memset</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">parport</span><span class="p">));</span>
	<span class="n">tmp</span><span class="o">-&gt;</span><span class="n">base</span> <span class="o">=</span> <span class="n">base</span><span class="p">;</span>
	<span class="n">tmp</span><span class="o">-&gt;</span><span class="n">irq</span> <span class="o">=</span> <span class="n">irq</span><span class="p">;</span>
	<span class="n">tmp</span><span class="o">-&gt;</span><span class="n">dma</span> <span class="o">=</span> <span class="n">dma</span><span class="p">;</span>
	<span class="n">tmp</span><span class="o">-&gt;</span><span class="n">muxport</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">-&gt;</span><span class="n">daisy</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">-&gt;</span><span class="n">muxsel</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">tmp</span><span class="o">-&gt;</span><span class="n">modes</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
 	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tmp</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
	<span class="n">tmp</span><span class="o">-&gt;</span><span class="n">devices</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">-&gt;</span><span class="n">cad</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">tmp</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">tmp</span><span class="o">-&gt;</span><span class="n">ops</span> <span class="o">=</span> <span class="n">ops</span><span class="p">;</span>
	<span class="n">tmp</span><span class="o">-&gt;</span><span class="n">physport</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">;</span>
	<span class="n">memset</span> <span class="p">(</span><span class="n">tmp</span><span class="o">-&gt;</span><span class="n">probe_info</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">5</span> <span class="o">*</span> <span class="k">sizeof</span> <span class="p">(</span><span class="k">struct</span> <span class="n">parport_device_info</span><span class="p">));</span>
	<span class="n">rwlock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tmp</span><span class="o">-&gt;</span><span class="n">cad_lock</span><span class="p">);</span>
	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tmp</span><span class="o">-&gt;</span><span class="n">waitlist_lock</span><span class="p">);</span>
	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tmp</span><span class="o">-&gt;</span><span class="n">pardevice_lock</span><span class="p">);</span>
	<span class="n">tmp</span><span class="o">-&gt;</span><span class="n">ieee1284</span><span class="p">.</span><span class="n">mode</span> <span class="o">=</span> <span class="n">IEEE1284_MODE_COMPAT</span><span class="p">;</span>
	<span class="n">tmp</span><span class="o">-&gt;</span><span class="n">ieee1284</span><span class="p">.</span><span class="n">phase</span> <span class="o">=</span> <span class="n">IEEE1284_PH_FWD_IDLE</span><span class="p">;</span>
	<span class="n">sema_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tmp</span><span class="o">-&gt;</span><span class="n">ieee1284</span><span class="p">.</span><span class="n">irq</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">tmp</span><span class="o">-&gt;</span><span class="n">spintime</span> <span class="o">=</span> <span class="n">parport_default_spintime</span><span class="p">;</span>
	<span class="n">atomic_set</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">tmp</span><span class="o">-&gt;</span><span class="n">ref_count</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tmp</span><span class="o">-&gt;</span><span class="n">full_list</span><span class="p">);</span>

	<span class="n">name</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="mi">15</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">name</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;parport: memory squeeze</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">tmp</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* Search for the lowest free parport number. */</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">full_list_lock</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">l</span> <span class="o">=</span> <span class="n">all_ports</span><span class="p">.</span><span class="n">next</span><span class="p">,</span> <span class="n">num</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">l</span> <span class="o">!=</span> <span class="o">&amp;</span><span class="n">all_ports</span><span class="p">;</span> <span class="n">l</span> <span class="o">=</span> <span class="n">l</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">,</span> <span class="n">num</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">parport</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="k">struct</span> <span class="n">parport</span><span class="p">,</span> <span class="n">full_list</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">number</span> <span class="o">!=</span> <span class="n">num</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">tmp</span><span class="o">-&gt;</span><span class="n">portnum</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">-&gt;</span><span class="n">number</span> <span class="o">=</span> <span class="n">num</span><span class="p">;</span>
	<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tmp</span><span class="o">-&gt;</span><span class="n">full_list</span><span class="p">,</span> <span class="n">l</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">full_list_lock</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Now that the portnum is known finish doing the Init.</span>
<span class="cm">	 */</span>
	<span class="n">sprintf</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="s">&quot;parport%d&quot;</span><span class="p">,</span> <span class="n">tmp</span><span class="o">-&gt;</span><span class="n">portnum</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">-&gt;</span><span class="n">number</span><span class="p">);</span>
	<span class="n">tmp</span><span class="o">-&gt;</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">device</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">device</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="p">;</span> <span class="n">device</span><span class="o">++</span><span class="p">)</span>
		<span class="cm">/* assume the worst */</span>
		<span class="n">tmp</span><span class="o">-&gt;</span><span class="n">probe_info</span><span class="p">[</span><span class="n">device</span><span class="p">].</span><span class="n">class</span> <span class="o">=</span> <span class="n">PARPORT_CLASS_LEGACY</span><span class="p">;</span>

	<span class="n">tmp</span><span class="o">-&gt;</span><span class="n">waithead</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">-&gt;</span><span class="n">waittail</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">tmp</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	parport_announce_port - tell device drivers about a parallel port</span>
<span class="cm"> *	@port: parallel port to announce</span>
<span class="cm"> *</span>
<span class="cm"> *	After a port driver has registered a parallel port with</span>
<span class="cm"> *	parport_register_port, and performed any necessary</span>
<span class="cm"> *	initialisation or adjustments, it should call</span>
<span class="cm"> *	parport_announce_port() in order to notify all device drivers</span>
<span class="cm"> *	that have called parport_register_driver().  Their attach()</span>
<span class="cm"> *	functions will be called, with @port as the parameter.</span>
<span class="cm"> **/</span>

<span class="kt">void</span> <span class="nf">parport_announce_port</span> <span class="p">(</span><span class="k">struct</span> <span class="n">parport</span> <span class="o">*</span><span class="n">port</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_PARPORT_1284</span>
	<span class="cm">/* Analyse the IEEE1284.3 topology of the port. */</span>
	<span class="n">parport_daisy_init</span><span class="p">(</span><span class="n">port</span><span class="p">);</span>
<span class="cp">#endif</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;%s: fix this legacy &quot;</span>
				<span class="s">&quot;no-device port driver!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">port</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>

	<span class="n">parport_proc_register</span><span class="p">(</span><span class="n">port</span><span class="p">);</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">registration_lock</span><span class="p">);</span>
	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">parportlist_lock</span><span class="p">);</span>
	<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">portlist</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">parport</span> <span class="o">*</span><span class="n">slave</span> <span class="o">=</span> <span class="n">port</span><span class="o">-&gt;</span><span class="n">slaves</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">slave</span><span class="p">)</span>
			<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">slave</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">portlist</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">parportlist_lock</span><span class="p">);</span>

	<span class="cm">/* Let drivers know that new port(s) has arrived. */</span>
	<span class="n">attach_driver_chain</span> <span class="p">(</span><span class="n">port</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">parport</span> <span class="o">*</span><span class="n">slave</span> <span class="o">=</span> <span class="n">port</span><span class="o">-&gt;</span><span class="n">slaves</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">slave</span><span class="p">)</span>
			<span class="n">attach_driver_chain</span><span class="p">(</span><span class="n">slave</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">registration_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	parport_remove_port - deregister a parallel port</span>
<span class="cm"> *	@port: parallel port to deregister</span>
<span class="cm"> *</span>
<span class="cm"> *	When a parallel port driver is forcibly unloaded, or a</span>
<span class="cm"> *	parallel port becomes inaccessible, the port driver must call</span>
<span class="cm"> *	this function in order to deal with device drivers that still</span>
<span class="cm"> *	want to use it.</span>
<span class="cm"> *</span>
<span class="cm"> *	The parport structure associated with the port has its</span>
<span class="cm"> *	operations structure replaced with one containing &#39;null&#39;</span>
<span class="cm"> *	operations that return errors or just don&#39;t do anything.</span>
<span class="cm"> *</span>
<span class="cm"> *	Any drivers that have registered themselves using</span>
<span class="cm"> *	parport_register_driver() are notified that the port is no</span>
<span class="cm"> *	longer accessible by having their detach() routines called</span>
<span class="cm"> *	with @port as the parameter.</span>
<span class="cm"> **/</span>

<span class="kt">void</span> <span class="nf">parport_remove_port</span><span class="p">(</span><span class="k">struct</span> <span class="n">parport</span> <span class="o">*</span><span class="n">port</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">registration_lock</span><span class="p">);</span>

	<span class="cm">/* Spread the word. */</span>
	<span class="n">detach_driver_chain</span> <span class="p">(</span><span class="n">port</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_PARPORT_1284</span>
	<span class="cm">/* Forget the IEEE1284.3 topology of the port. */</span>
	<span class="n">parport_daisy_fini</span><span class="p">(</span><span class="n">port</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">parport</span> <span class="o">*</span><span class="n">slave</span> <span class="o">=</span> <span class="n">port</span><span class="o">-&gt;</span><span class="n">slaves</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">slave</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="n">detach_driver_chain</span><span class="p">(</span><span class="n">slave</span><span class="p">);</span>
		<span class="n">parport_daisy_fini</span><span class="p">(</span><span class="n">slave</span><span class="p">);</span>
	<span class="p">}</span>
<span class="cp">#endif</span>

	<span class="n">port</span><span class="o">-&gt;</span><span class="n">ops</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">dead_ops</span><span class="p">;</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">parportlist_lock</span><span class="p">);</span>
	<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">parport</span> <span class="o">*</span><span class="n">slave</span> <span class="o">=</span> <span class="n">port</span><span class="o">-&gt;</span><span class="n">slaves</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">slave</span><span class="p">)</span>
			<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">slave</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">parportlist_lock</span><span class="p">);</span>

	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">registration_lock</span><span class="p">);</span>

	<span class="n">parport_proc_unregister</span><span class="p">(</span><span class="n">port</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">parport</span> <span class="o">*</span><span class="n">slave</span> <span class="o">=</span> <span class="n">port</span><span class="o">-&gt;</span><span class="n">slaves</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">slave</span><span class="p">)</span>
			<span class="n">parport_put_port</span><span class="p">(</span><span class="n">slave</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	parport_register_device - register a device on a parallel port</span>
<span class="cm"> *	@port: port to which the device is attached</span>
<span class="cm"> *	@name: a name to refer to the device</span>
<span class="cm"> *	@pf: preemption callback</span>
<span class="cm"> *	@kf: kick callback (wake-up)</span>
<span class="cm"> *	@irq_func: interrupt handler</span>
<span class="cm"> *	@flags: registration flags</span>
<span class="cm"> *	@handle: data for callback functions</span>
<span class="cm"> *</span>
<span class="cm"> *	This function, called by parallel port device drivers,</span>
<span class="cm"> *	declares that a device is connected to a port, and tells the</span>
<span class="cm"> *	system all it needs to know.</span>
<span class="cm"> *</span>
<span class="cm"> *	The @name is allocated by the caller and must not be</span>
<span class="cm"> *	deallocated until the caller calls @parport_unregister_device</span>
<span class="cm"> *	for that device.</span>
<span class="cm"> *</span>
<span class="cm"> *	The preemption callback function, @pf, is called when this</span>
<span class="cm"> *	device driver has claimed access to the port but another</span>
<span class="cm"> *	device driver wants to use it.  It is given @handle as its</span>
<span class="cm"> *	parameter, and should return zero if it is willing for the</span>
<span class="cm"> *	system to release the port to another driver on its behalf.</span>
<span class="cm"> *	If it wants to keep control of the port it should return</span>
<span class="cm"> *	non-zero, and no action will be taken.  It is good manners for</span>
<span class="cm"> *	the driver to try to release the port at the earliest</span>
<span class="cm"> *	opportunity after its preemption callback rejects a preemption</span>
<span class="cm"> *	attempt.  Note that if a preemption callback is happy for</span>
<span class="cm"> *	preemption to go ahead, there is no need to release the port;</span>
<span class="cm"> *	it is done automatically.  This function may not block, as it</span>
<span class="cm"> *	may be called from interrupt context.  If the device driver</span>
<span class="cm"> *	does not support preemption, @pf can be %NULL.</span>
<span class="cm"> *</span>
<span class="cm"> *	The wake-up (&quot;kick&quot;) callback function, @kf, is called when</span>
<span class="cm"> *	the port is available to be claimed for exclusive access; that</span>
<span class="cm"> *	is, parport_claim() is guaranteed to succeed when called from</span>
<span class="cm"> *	inside the wake-up callback function.  If the driver wants to</span>
<span class="cm"> *	claim the port it should do so; otherwise, it need not take</span>
<span class="cm"> *	any action.  This function may not block, as it may be called</span>
<span class="cm"> *	from interrupt context.  If the device driver does not want to</span>
<span class="cm"> *	be explicitly invited to claim the port in this way, @kf can</span>
<span class="cm"> *	be %NULL.</span>
<span class="cm"> *</span>
<span class="cm"> *	The interrupt handler, @irq_func, is called when an interrupt</span>
<span class="cm"> *	arrives from the parallel port.  Note that if a device driver</span>
<span class="cm"> *	wants to use interrupts it should use parport_enable_irq(),</span>
<span class="cm"> *	and can also check the irq member of the parport structure</span>
<span class="cm"> *	representing the port.</span>
<span class="cm"> *</span>
<span class="cm"> *	The parallel port (lowlevel) driver is the one that has called</span>
<span class="cm"> *	request_irq() and whose interrupt handler is called first.</span>
<span class="cm"> *	This handler does whatever needs to be done to the hardware to</span>
<span class="cm"> *	acknowledge the interrupt (for PC-style ports there is nothing</span>
<span class="cm"> *	special to be done).  It then tells the IEEE 1284 code about</span>
<span class="cm"> *	the interrupt, which may involve reacting to an IEEE 1284</span>
<span class="cm"> *	event depending on the current IEEE 1284 phase.  After this,</span>
<span class="cm"> *	it calls @irq_func.  Needless to say, @irq_func will be called</span>
<span class="cm"> *	from interrupt context, and may not block.</span>
<span class="cm"> *</span>
<span class="cm"> *	The %PARPORT_DEV_EXCL flag is for preventing port sharing, and</span>
<span class="cm"> *	so should only be used when sharing the port with other device</span>
<span class="cm"> *	drivers is impossible and would lead to incorrect behaviour.</span>
<span class="cm"> *	Use it sparingly!  Normally, @flags will be zero.</span>
<span class="cm"> *</span>
<span class="cm"> *	This function returns a pointer to a structure that represents</span>
<span class="cm"> *	the device on the port, or %NULL if there is not enough memory</span>
<span class="cm"> *	to allocate space for that structure.</span>
<span class="cm"> **/</span>

<span class="k">struct</span> <span class="n">pardevice</span> <span class="o">*</span>
<span class="nf">parport_register_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">parport</span> <span class="o">*</span><span class="n">port</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span>
			<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">pf</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="p">),</span> <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">kf</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="p">),</span>
			<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">irq_func</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="p">),</span> 
			<span class="kt">int</span> <span class="n">flags</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">handle</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pardevice</span> <span class="o">*</span><span class="n">tmp</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">physport</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">PARPORT_FLAG_EXCL</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* An exclusive device is registered. */</span>
		<span class="n">printk</span> <span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;%s: no more devices allowed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">port</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">PARPORT_DEV_LURK</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pf</span> <span class="o">||</span> <span class="o">!</span><span class="n">kf</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;%s: refused to register lurking device (%s) without callbacks</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">port</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">name</span><span class="p">);</span>
			<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* We up our own module reference count, and that of the port</span>
<span class="cm">           on which a device is to be registered, to ensure that</span>
<span class="cm">           neither of us gets unloaded while we sleep in (e.g.)</span>
<span class="cm">           kmalloc.</span>
<span class="cm">         */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">try_module_get</span><span class="p">(</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">owner</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
		
	<span class="n">parport_get_port</span> <span class="p">(</span><span class="n">port</span><span class="p">);</span>

	<span class="n">tmp</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">pardevice</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tmp</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;%s: memory squeeze, couldn&#39;t register %s.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">port</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">name</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">tmp</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">parport_state</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tmp</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;%s: memory squeeze, couldn&#39;t register %s.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">port</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">name</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_free_pardevice</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">tmp</span><span class="o">-&gt;</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span><span class="p">;</span>
	<span class="n">tmp</span><span class="o">-&gt;</span><span class="n">port</span> <span class="o">=</span> <span class="n">port</span><span class="p">;</span>
	<span class="n">tmp</span><span class="o">-&gt;</span><span class="n">daisy</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">tmp</span><span class="o">-&gt;</span><span class="n">preempt</span> <span class="o">=</span> <span class="n">pf</span><span class="p">;</span>
	<span class="n">tmp</span><span class="o">-&gt;</span><span class="n">wakeup</span> <span class="o">=</span> <span class="n">kf</span><span class="p">;</span>
	<span class="n">tmp</span><span class="o">-&gt;</span><span class="n">private</span> <span class="o">=</span> <span class="n">handle</span><span class="p">;</span>
	<span class="n">tmp</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">=</span> <span class="n">flags</span><span class="p">;</span>
	<span class="n">tmp</span><span class="o">-&gt;</span><span class="n">irq_func</span> <span class="o">=</span> <span class="n">irq_func</span><span class="p">;</span>
	<span class="n">tmp</span><span class="o">-&gt;</span><span class="n">waiting</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">tmp</span><span class="o">-&gt;</span><span class="n">timeout</span> <span class="o">=</span> <span class="mi">5</span> <span class="o">*</span> <span class="n">HZ</span><span class="p">;</span>

	<span class="cm">/* Chain this onto the list */</span>
	<span class="n">tmp</span><span class="o">-&gt;</span><span class="n">prev</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * This function must not run from an irq handler so we don&#39; t need</span>
<span class="cm">	 * to clear irq on the local CPU. -arca</span>
<span class="cm">	 */</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">physport</span><span class="o">-&gt;</span><span class="n">pardevice_lock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">PARPORT_DEV_EXCL</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">physport</span><span class="o">-&gt;</span><span class="n">devices</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">spin_unlock</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">physport</span><span class="o">-&gt;</span><span class="n">pardevice_lock</span><span class="p">);</span>
			<span class="n">printk</span> <span class="p">(</span><span class="n">KERN_DEBUG</span>
				<span class="s">&quot;%s: cannot grant exclusive access for &quot;</span>
				<span class="s">&quot;device %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">port</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">name</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">out_free_all</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">port</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">PARPORT_FLAG_EXCL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">tmp</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">port</span><span class="o">-&gt;</span><span class="n">physport</span><span class="o">-&gt;</span><span class="n">devices</span><span class="p">;</span>
	<span class="n">wmb</span><span class="p">();</span> <span class="cm">/* Make sure that tmp-&gt;next is written before it&#39;s</span>
<span class="cm">                  added to the list; see comments marked &#39;no locking</span>
<span class="cm">                  required&#39; */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">physport</span><span class="o">-&gt;</span><span class="n">devices</span><span class="p">)</span>
		<span class="n">port</span><span class="o">-&gt;</span><span class="n">physport</span><span class="o">-&gt;</span><span class="n">devices</span><span class="o">-&gt;</span><span class="n">prev</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">;</span>
	<span class="n">port</span><span class="o">-&gt;</span><span class="n">physport</span><span class="o">-&gt;</span><span class="n">devices</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">;</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">physport</span><span class="o">-&gt;</span><span class="n">pardevice_lock</span><span class="p">);</span>

	<span class="n">init_waitqueue_head</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tmp</span><span class="o">-&gt;</span><span class="n">wait_q</span><span class="p">);</span>
	<span class="n">tmp</span><span class="o">-&gt;</span><span class="n">timeslice</span> <span class="o">=</span> <span class="n">parport_default_timeslice</span><span class="p">;</span>
	<span class="n">tmp</span><span class="o">-&gt;</span><span class="n">waitnext</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">-&gt;</span><span class="n">waitprev</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * This has to be run as last thing since init_state may need other</span>
<span class="cm">	 * pardevice fields. -arca</span>
<span class="cm">	 */</span>
	<span class="n">port</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">init_state</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="n">tmp</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">test_and_set_bit</span><span class="p">(</span><span class="n">PARPORT_DEVPROC_REGISTERED</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">devflags</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">port</span><span class="o">-&gt;</span><span class="n">proc_device</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">;</span>
		<span class="n">parport_device_proc_register</span><span class="p">(</span><span class="n">tmp</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">tmp</span><span class="p">;</span>

 <span class="nl">out_free_all:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">tmp</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">);</span>
 <span class="nl">out_free_pardevice:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">tmp</span><span class="p">);</span>
 <span class="nl">out:</span>
	<span class="n">parport_put_port</span> <span class="p">(</span><span class="n">port</span><span class="p">);</span>
	<span class="n">module_put</span><span class="p">(</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">owner</span><span class="p">);</span>

	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	parport_unregister_device - deregister a device on a parallel port</span>
<span class="cm"> *	@dev: pointer to structure representing device</span>
<span class="cm"> *</span>
<span class="cm"> *	This undoes the effect of parport_register_device().</span>
<span class="cm"> **/</span>

<span class="kt">void</span> <span class="nf">parport_unregister_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">pardevice</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">parport</span> <span class="o">*</span><span class="n">port</span><span class="p">;</span>

<span class="cp">#ifdef PARPORT_PARANOID</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;parport_unregister_device: passed NULL</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
<span class="cp">#endif</span>

	<span class="n">port</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">physport</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">proc_device</span> <span class="o">==</span> <span class="n">dev</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">port</span><span class="o">-&gt;</span><span class="n">proc_device</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">clear_bit</span><span class="p">(</span><span class="n">PARPORT_DEVPROC_REGISTERED</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">devflags</span><span class="p">);</span>
		<span class="n">parport_device_proc_unregister</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">cad</span> <span class="o">==</span> <span class="n">dev</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;%s: %s forgot to release port</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">port</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="n">parport_release</span> <span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">pardevice_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">)</span>
		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">prev</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">prev</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">prev</span><span class="p">)</span>
		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">prev</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">port</span><span class="o">-&gt;</span><span class="n">devices</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">PARPORT_DEV_EXCL</span><span class="p">)</span>
		<span class="n">port</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">PARPORT_FLAG_EXCL</span><span class="p">;</span>

	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">pardevice_lock</span><span class="p">);</span>

	<span class="cm">/* Make sure we haven&#39;t left any pointers around in the wait</span>
<span class="cm">	 * list. */</span>
	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">waitlist_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">waitprev</span> <span class="o">||</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">waitnext</span> <span class="o">||</span> <span class="n">port</span><span class="o">-&gt;</span><span class="n">waithead</span> <span class="o">==</span> <span class="n">dev</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">waitprev</span><span class="p">)</span>
			<span class="n">dev</span><span class="o">-&gt;</span><span class="n">waitprev</span><span class="o">-&gt;</span><span class="n">waitnext</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">waitnext</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">port</span><span class="o">-&gt;</span><span class="n">waithead</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">waitnext</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">waitnext</span><span class="p">)</span>
			<span class="n">dev</span><span class="o">-&gt;</span><span class="n">waitnext</span><span class="o">-&gt;</span><span class="n">waitprev</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">waitprev</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">port</span><span class="o">-&gt;</span><span class="n">waittail</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">waitprev</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">waitlist_lock</span><span class="p">);</span>

	<span class="n">kfree</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="n">module_put</span><span class="p">(</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">owner</span><span class="p">);</span>
	<span class="n">parport_put_port</span> <span class="p">(</span><span class="n">port</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	parport_find_number - find a parallel port by number</span>
<span class="cm"> *	@number: parallel port number</span>
<span class="cm"> *</span>
<span class="cm"> *	This returns the parallel port with the specified number, or</span>
<span class="cm"> *	%NULL if there is none.</span>
<span class="cm"> *</span>
<span class="cm"> *	There is an implicit parport_get_port() done already; to throw</span>
<span class="cm"> *	away the reference to the port that parport_find_number()</span>
<span class="cm"> *	gives you, use parport_put_port().</span>
<span class="cm"> */</span>

<span class="k">struct</span> <span class="n">parport</span> <span class="o">*</span><span class="nf">parport_find_number</span> <span class="p">(</span><span class="kt">int</span> <span class="n">number</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">parport</span> <span class="o">*</span><span class="n">port</span><span class="p">,</span> <span class="o">*</span><span class="n">result</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">portlist</span><span class="p">))</span>
		<span class="n">get_lowlevel_driver</span> <span class="p">();</span>

	<span class="n">spin_lock</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">parportlist_lock</span><span class="p">);</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">port</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">portlist</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">number</span> <span class="o">==</span> <span class="n">number</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">result</span> <span class="o">=</span> <span class="n">parport_get_port</span> <span class="p">(</span><span class="n">port</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">spin_unlock</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">parportlist_lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	parport_find_base - find a parallel port by base address</span>
<span class="cm"> *	@base: base I/O address</span>
<span class="cm"> *</span>
<span class="cm"> *	This returns the parallel port with the specified base</span>
<span class="cm"> *	address, or %NULL if there is none.</span>
<span class="cm"> *</span>
<span class="cm"> *	There is an implicit parport_get_port() done already; to throw</span>
<span class="cm"> *	away the reference to the port that parport_find_base()</span>
<span class="cm"> *	gives you, use parport_put_port().</span>
<span class="cm"> */</span>

<span class="k">struct</span> <span class="n">parport</span> <span class="o">*</span><span class="nf">parport_find_base</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">base</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">parport</span> <span class="o">*</span><span class="n">port</span><span class="p">,</span> <span class="o">*</span><span class="n">result</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">portlist</span><span class="p">))</span>
		<span class="n">get_lowlevel_driver</span> <span class="p">();</span>

	<span class="n">spin_lock</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">parportlist_lock</span><span class="p">);</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">port</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">portlist</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">base</span> <span class="o">==</span> <span class="n">base</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">result</span> <span class="o">=</span> <span class="n">parport_get_port</span> <span class="p">(</span><span class="n">port</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">spin_unlock</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">parportlist_lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	parport_claim - claim access to a parallel port device</span>
<span class="cm"> *	@dev: pointer to structure representing a device on the port</span>
<span class="cm"> *</span>
<span class="cm"> *	This function will not block and so can be used from interrupt</span>
<span class="cm"> *	context.  If parport_claim() succeeds in claiming access to</span>
<span class="cm"> *	the port it returns zero and the port is available to use.  It</span>
<span class="cm"> *	may fail (returning non-zero) if the port is in use by another</span>
<span class="cm"> *	driver and that driver is not willing to relinquish control of</span>
<span class="cm"> *	the port.</span>
<span class="cm"> **/</span>

<span class="kt">int</span> <span class="nf">parport_claim</span><span class="p">(</span><span class="k">struct</span> <span class="n">pardevice</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pardevice</span> <span class="o">*</span><span class="n">oldcad</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">parport</span> <span class="o">*</span><span class="n">port</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">physport</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">cad</span> <span class="o">==</span> <span class="n">dev</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;%s: %s already owner</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">dev</span><span class="o">-&gt;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Preempt any current device */</span>
	<span class="n">write_lock_irqsave</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">cad_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">oldcad</span> <span class="o">=</span> <span class="n">port</span><span class="o">-&gt;</span><span class="n">cad</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">oldcad</span><span class="o">-&gt;</span><span class="n">preempt</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">oldcad</span><span class="o">-&gt;</span><span class="n">preempt</span><span class="p">(</span><span class="n">oldcad</span><span class="o">-&gt;</span><span class="n">private</span><span class="p">))</span>
				<span class="k">goto</span> <span class="n">blocked</span><span class="p">;</span>
			<span class="n">port</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">save_state</span><span class="p">(</span><span class="n">port</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="k">goto</span> <span class="n">blocked</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">cad</span> <span class="o">!=</span> <span class="n">oldcad</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* I think we&#39;ll actually deadlock rather than</span>
<span class="cm">                           get here, but just in case.. */</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span>
			       <span class="s">&quot;%s: %s released port when preempted!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">port</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">oldcad</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">cad</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">blocked</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* Can&#39;t fail from now on, so mark ourselves as no longer waiting.  */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">waiting</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">waiting</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="cm">/* Take ourselves out of the wait list again.  */</span>
		<span class="n">spin_lock_irq</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">waitlist_lock</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">waitprev</span><span class="p">)</span>
			<span class="n">dev</span><span class="o">-&gt;</span><span class="n">waitprev</span><span class="o">-&gt;</span><span class="n">waitnext</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">waitnext</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">port</span><span class="o">-&gt;</span><span class="n">waithead</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">waitnext</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">waitnext</span><span class="p">)</span>
			<span class="n">dev</span><span class="o">-&gt;</span><span class="n">waitnext</span><span class="o">-&gt;</span><span class="n">waitprev</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">waitprev</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">port</span><span class="o">-&gt;</span><span class="n">waittail</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">waitprev</span><span class="p">;</span>
		<span class="n">spin_unlock_irq</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">waitlist_lock</span><span class="p">);</span>
		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">waitprev</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">waitnext</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Now we do the change of devices */</span>
	<span class="n">port</span><span class="o">-&gt;</span><span class="n">cad</span> <span class="o">=</span> <span class="n">dev</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_PARPORT_1284</span>
	<span class="cm">/* If it&#39;s a mux port, select it. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">muxport</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* FIXME */</span>
		<span class="n">port</span><span class="o">-&gt;</span><span class="n">muxsel</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">muxport</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* If it&#39;s a daisy chain device, select it. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">daisy</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* This could be lazier. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">parport_daisy_select</span> <span class="p">(</span><span class="n">port</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">daisy</span><span class="p">,</span>
					   <span class="n">IEEE1284_MODE_COMPAT</span><span class="p">))</span>
			<span class="n">port</span><span class="o">-&gt;</span><span class="n">daisy</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">daisy</span><span class="p">;</span>
	<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* IEEE1284.3 support */</span><span class="cp"></span>

	<span class="cm">/* Restore control registers */</span>
	<span class="n">port</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">restore_state</span><span class="p">(</span><span class="n">port</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">);</span>
	<span class="n">write_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">cad_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">time</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">blocked:</span>
	<span class="cm">/* If this is the first time we tried to claim the port, register an</span>
<span class="cm">	   interest.  This is only allowed for devices sleeping in</span>
<span class="cm">	   parport_claim_or_block(), or those with a wakeup function.  */</span>

	<span class="cm">/* The cad_lock is still held for writing here */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">waiting</span> <span class="o">&amp;</span> <span class="mi">2</span> <span class="o">||</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">wakeup</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_lock</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">waitlist_lock</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">test_and_set_bit</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">waiting</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* First add ourselves to the end of the wait list. */</span>
			<span class="n">dev</span><span class="o">-&gt;</span><span class="n">waitnext</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="n">dev</span><span class="o">-&gt;</span><span class="n">waitprev</span> <span class="o">=</span> <span class="n">port</span><span class="o">-&gt;</span><span class="n">waittail</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">waittail</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">port</span><span class="o">-&gt;</span><span class="n">waittail</span><span class="o">-&gt;</span><span class="n">waitnext</span> <span class="o">=</span> <span class="n">dev</span><span class="p">;</span>
				<span class="n">port</span><span class="o">-&gt;</span><span class="n">waittail</span> <span class="o">=</span> <span class="n">dev</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span>
				<span class="n">port</span><span class="o">-&gt;</span><span class="n">waithead</span> <span class="o">=</span> <span class="n">port</span><span class="o">-&gt;</span><span class="n">waittail</span> <span class="o">=</span> <span class="n">dev</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">spin_unlock</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">waitlist_lock</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">write_unlock_irqrestore</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">cad_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	parport_claim_or_block - claim access to a parallel port device</span>
<span class="cm"> *	@dev: pointer to structure representing a device on the port</span>
<span class="cm"> *</span>
<span class="cm"> *	This behaves like parport_claim(), but will block if necessary</span>
<span class="cm"> *	to wait for the port to be free.  A return value of 1</span>
<span class="cm"> *	indicates that it slept; 0 means that it succeeded without</span>
<span class="cm"> *	needing to sleep.  A negative error code indicates failure.</span>
<span class="cm"> **/</span>

<span class="kt">int</span> <span class="nf">parport_claim_or_block</span><span class="p">(</span><span class="k">struct</span> <span class="n">pardevice</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">r</span><span class="p">;</span>

	<span class="cm">/* Signal to parport_claim() that we can wait even without a</span>
<span class="cm">	   wakeup function.  */</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">waiting</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>

	<span class="cm">/* Try to claim the port.  If this fails, we need to sleep.  */</span>
	<span class="n">r</span> <span class="o">=</span> <span class="n">parport_claim</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">r</span> <span class="o">==</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">)</span> <span class="p">{</span>
<span class="cp">#ifdef PARPORT_DEBUG_SHARING</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;%s: parport_claim() returned -EAGAIN</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
<span class="cp">#endif</span>
		<span class="cm">/*</span>
<span class="cm">		 * FIXME!!! Use the proper locking for dev-&gt;waiting,</span>
<span class="cm">		 * and make this use the &quot;wait_event_interruptible()&quot;</span>
<span class="cm">		 * interfaces. The cli/sti that used to be here</span>
<span class="cm">		 * did nothing.</span>
<span class="cm">		 *</span>
<span class="cm">		 * See also parport_release()</span>
<span class="cm">		 */</span>

		<span class="cm">/* If dev-&gt;waiting is clear now, an interrupt</span>
<span class="cm">		   gave us the port and we would deadlock if we slept.  */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">waiting</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">interruptible_sleep_on</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">wait_q</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">signal_pending</span> <span class="p">(</span><span class="n">current</span><span class="p">))</span> <span class="p">{</span>
				<span class="k">return</span> <span class="o">-</span><span class="n">EINTR</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">r</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">r</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="cp">#ifdef PARPORT_DEBUG_SHARING</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;%s: didn&#39;t sleep in parport_claim_or_block()</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
<span class="cp">#endif</span>
		<span class="p">}</span>

<span class="cp">#ifdef PARPORT_DEBUG_SHARING</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">physport</span><span class="o">-&gt;</span><span class="n">cad</span> <span class="o">!=</span> <span class="n">dev</span><span class="p">)</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;%s: exiting parport_claim_or_block &quot;</span>
			       <span class="s">&quot;but %s owns port!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span>
			       <span class="n">dev</span><span class="o">-&gt;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">physport</span><span class="o">-&gt;</span><span class="n">cad</span> <span class="o">?</span>
			       <span class="n">dev</span><span class="o">-&gt;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">physport</span><span class="o">-&gt;</span><span class="n">cad</span><span class="o">-&gt;</span><span class="n">name</span><span class="o">:</span><span class="s">&quot;nobody&quot;</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="p">}</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">waiting</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">r</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	parport_release - give up access to a parallel port device</span>
<span class="cm"> *	@dev: pointer to structure representing parallel port device</span>
<span class="cm"> *</span>
<span class="cm"> *	This function cannot fail, but it should not be called without</span>
<span class="cm"> *	the port claimed.  Similarly, if the port is already claimed</span>
<span class="cm"> *	you should not try claiming it again.</span>
<span class="cm"> **/</span>

<span class="kt">void</span> <span class="nf">parport_release</span><span class="p">(</span><span class="k">struct</span> <span class="n">pardevice</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">parport</span> <span class="o">*</span><span class="n">port</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">physport</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pardevice</span> <span class="o">*</span><span class="n">pd</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="cm">/* Make sure that dev is the current device */</span>
	<span class="n">write_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">cad_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">cad</span> <span class="o">!=</span> <span class="n">dev</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">write_unlock_irqrestore</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">cad_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;%s: %s tried to release parport &quot;</span>
		       <span class="s">&quot;when not owner</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">port</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

<span class="cp">#ifdef CONFIG_PARPORT_1284</span>
	<span class="cm">/* If this is on a mux port, deselect it. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">muxport</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* FIXME */</span>
		<span class="n">port</span><span class="o">-&gt;</span><span class="n">muxsel</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* If this is a daisy device, deselect it. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">daisy</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">parport_daisy_deselect_all</span> <span class="p">(</span><span class="n">port</span><span class="p">);</span>
		<span class="n">port</span><span class="o">-&gt;</span><span class="n">daisy</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
<span class="cp">#endif</span>

	<span class="n">port</span><span class="o">-&gt;</span><span class="n">cad</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">write_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">cad_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="cm">/* Save control registers */</span>
	<span class="n">port</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">save_state</span><span class="p">(</span><span class="n">port</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">);</span>

	<span class="cm">/* If anybody is waiting, find out who&#39;s been there longest and</span>
<span class="cm">	   then wake them up. (Note: no locking required) */</span>
	<span class="cm">/* !!! LOCKING IS NEEDED HERE */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">pd</span> <span class="o">=</span> <span class="n">port</span><span class="o">-&gt;</span><span class="n">waithead</span><span class="p">;</span> <span class="n">pd</span><span class="p">;</span> <span class="n">pd</span> <span class="o">=</span> <span class="n">pd</span><span class="o">-&gt;</span><span class="n">waitnext</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pd</span><span class="o">-&gt;</span><span class="n">waiting</span> <span class="o">&amp;</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span> <span class="cm">/* sleeping in claim_or_block */</span>
			<span class="n">parport_claim</span><span class="p">(</span><span class="n">pd</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">waitqueue_active</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pd</span><span class="o">-&gt;</span><span class="n">wait_q</span><span class="p">))</span>
				<span class="n">wake_up_interruptible</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pd</span><span class="o">-&gt;</span><span class="n">wait_q</span><span class="p">);</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">pd</span><span class="o">-&gt;</span><span class="n">wakeup</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pd</span><span class="o">-&gt;</span><span class="n">wakeup</span><span class="p">(</span><span class="n">pd</span><span class="o">-&gt;</span><span class="n">private</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">cad</span><span class="p">)</span> <span class="cm">/* racy but no matter */</span>
				<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;%s: don&#39;t know how to wake %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">port</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">pd</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* Nobody was waiting, so walk the list to see if anyone is</span>
<span class="cm">	   interested in being woken up. (Note: no locking required) */</span>
	<span class="cm">/* !!! LOCKING IS NEEDED HERE */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">pd</span> <span class="o">=</span> <span class="n">port</span><span class="o">-&gt;</span><span class="n">devices</span><span class="p">;</span> <span class="p">(</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">cad</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">pd</span><span class="p">;</span> <span class="n">pd</span> <span class="o">=</span> <span class="n">pd</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pd</span><span class="o">-&gt;</span><span class="n">wakeup</span> <span class="o">&amp;&amp;</span> <span class="n">pd</span> <span class="o">!=</span> <span class="n">dev</span><span class="p">)</span>
			<span class="n">pd</span><span class="o">-&gt;</span><span class="n">wakeup</span><span class="p">(</span><span class="n">pd</span><span class="o">-&gt;</span><span class="n">private</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="n">irqreturn_t</span> <span class="nf">parport_irq_handler</span><span class="p">(</span><span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">dev_id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">parport</span> <span class="o">*</span><span class="n">port</span> <span class="o">=</span> <span class="n">dev_id</span><span class="p">;</span>

	<span class="n">parport_generic_irq</span><span class="p">(</span><span class="n">port</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">IRQ_HANDLED</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Exported symbols for modules. */</span>

<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">parport_claim</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">parport_claim_or_block</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">parport_release</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">parport_register_port</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">parport_announce_port</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">parport_remove_port</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">parport_register_driver</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">parport_unregister_driver</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">parport_register_device</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">parport_unregister_device</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">parport_get_port</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">parport_put_port</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">parport_find_number</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">parport_find_base</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">parport_irq_handler</span><span class="p">);</span>

<span class="n">MODULE_LICENSE</span><span class="p">(</span><span class="s">&quot;GPL&quot;</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
