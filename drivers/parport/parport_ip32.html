<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › parport › parport_ip32.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>parport_ip32.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/* Low-level parallel port routines for built-in port on SGI IP32</span>
<span class="cm"> *</span>
<span class="cm"> * Author: Arnaud Giersch &lt;arnaud.giersch@free.fr&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * Based on parport_pc.c by</span>
<span class="cm"> *	Phil Blundell, Tim Waugh, Jose Renau, David Campbell,</span>
<span class="cm"> *	Andrea Arcangeli, et al.</span>
<span class="cm"> *</span>
<span class="cm"> * Thanks to Ilya A. Volynets-Evenbakh for his help.</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 2005, 2006 Arnaud Giersch.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or modify it</span>
<span class="cm"> * under the terms of the GNU General Public License as published by the Free</span>
<span class="cm"> * Software Foundation; either version 2 of the License, or (at your option)</span>
<span class="cm"> * any later version.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is distributed in the hope that it will be useful, but WITHOUT</span>
<span class="cm"> * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or</span>
<span class="cm"> * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for</span>
<span class="cm"> * more details.</span>
<span class="cm"> *</span>
<span class="cm"> * You should have received a copy of the GNU General Public License along</span>
<span class="cm"> * with this program; if not, write to the Free Software Foundation, Inc., 59</span>
<span class="cm"> * Temple Place - Suite 330, Boston, MA 02111-1307, USA.</span>
<span class="cm"> */</span>

<span class="cm">/* Current status:</span>
<span class="cm"> *</span>
<span class="cm"> *	Basic SPP and PS2 modes are supported.</span>
<span class="cm"> *	Support for parallel port IRQ is present.</span>
<span class="cm"> *	Hardware SPP (a.k.a. compatibility), EPP, and ECP modes are</span>
<span class="cm"> *	supported.</span>
<span class="cm"> *	SPP/ECP FIFO can be driven in PIO or DMA mode.  PIO mode can work with</span>
<span class="cm"> *	or without interrupt support.</span>
<span class="cm"> *</span>
<span class="cm"> *	Hardware ECP mode is not fully implemented (ecp_read_data and</span>
<span class="cm"> *	ecp_write_addr are actually missing).</span>
<span class="cm"> *</span>
<span class="cm"> * To do:</span>
<span class="cm"> *</span>
<span class="cm"> *	Fully implement ECP mode.</span>
<span class="cm"> *	EPP and ECP mode need to be tested.  I currently do not own any</span>
<span class="cm"> *	peripheral supporting these extended mode, and cannot test them.</span>
<span class="cm"> *	If DMA mode works well, decide if support for PIO FIFO modes should be</span>
<span class="cm"> *	dropped.</span>
<span class="cm"> *	Use the io{read,write} family functions when they become available in</span>
<span class="cm"> *	the linux-mips.org tree.  Note: the MIPS specific functions readsb()</span>
<span class="cm"> *	and writesb() are to be translated by ioread8_rep() and iowrite8_rep()</span>
<span class="cm"> *	respectively.</span>
<span class="cm"> */</span>

<span class="cm">/* The built-in parallel port on the SGI 02 workstation (a.k.a. IP32) is an</span>
<span class="cm"> * IEEE 1284 parallel port driven by a Texas Instrument TL16PIR552PH chip[1].</span>
<span class="cm"> * This chip supports SPP, bidirectional, EPP and ECP modes.  It has a 16 byte</span>
<span class="cm"> * FIFO buffer and supports DMA transfers.</span>
<span class="cm"> *</span>
<span class="cm"> * [1] http://focus.ti.com/docs/prod/folders/print/tl16pir552.html</span>
<span class="cm"> *</span>
<span class="cm"> * Theoretically, we could simply use the parport_pc module.  It is however</span>
<span class="cm"> * not so simple.  The parport_pc code assumes that the parallel port</span>
<span class="cm"> * registers are port-mapped.  On the O2, they are memory-mapped.</span>
<span class="cm"> * Furthermore, each register is replicated on 256 consecutive addresses (as</span>
<span class="cm"> * it is for the built-in serial ports on the same chip).</span>
<span class="cm"> */</span>

<span class="cm">/*--- Some configuration defines ---------------------------------------*/</span>

<span class="cm">/* DEBUG_PARPORT_IP32</span>
<span class="cm"> *	0	disable debug</span>
<span class="cm"> *	1	standard level: pr_debug1 is enabled</span>
<span class="cm"> *	2	parport_ip32_dump_state is enabled</span>
<span class="cm"> *	&gt;=3	verbose level: pr_debug is enabled</span>
<span class="cm"> */</span>
<span class="cp">#if !defined(DEBUG_PARPORT_IP32)</span>
<span class="cp">#	define DEBUG_PARPORT_IP32  0	</span><span class="cm">/* 0 (disabled) for production */</span><span class="cp"></span>
<span class="cp">#endif</span>

<span class="cm">/*----------------------------------------------------------------------*/</span>

<span class="cm">/* Setup DEBUG macros.  This is done before any includes, just in case we</span>
<span class="cm"> * activate pr_debug() with DEBUG_PARPORT_IP32 &gt;= 3.</span>
<span class="cm"> */</span>
<span class="cp">#if DEBUG_PARPORT_IP32 == 1</span>
<span class="cp">#	warning DEBUG_PARPORT_IP32 == 1</span>
<span class="cp">#elif DEBUG_PARPORT_IP32 == 2</span>
<span class="cp">#	warning DEBUG_PARPORT_IP32 == 2</span>
<span class="cp">#elif DEBUG_PARPORT_IP32 &gt;= 3</span>
<span class="cp">#	warning DEBUG_PARPORT_IP32 &gt;= 3</span>
<span class="cp">#	if !defined(DEBUG)</span>
<span class="cp">#		define DEBUG </span><span class="cm">/* enable pr_debug() in kernel.h */</span><span class="cp"></span>
<span class="cp">#	endif</span>
<span class="cp">#endif</span>

<span class="cp">#include &lt;linux/completion.h&gt;</span>
<span class="cp">#include &lt;linux/delay.h&gt;</span>
<span class="cp">#include &lt;linux/dma-mapping.h&gt;</span>
<span class="cp">#include &lt;linux/err.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/interrupt.h&gt;</span>
<span class="cp">#include &lt;linux/jiffies.h&gt;</span>
<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/parport.h&gt;</span>
<span class="cp">#include &lt;linux/sched.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/spinlock.h&gt;</span>
<span class="cp">#include &lt;linux/stddef.h&gt;</span>
<span class="cp">#include &lt;linux/types.h&gt;</span>
<span class="cp">#include &lt;asm/io.h&gt;</span>
<span class="cp">#include &lt;asm/ip32/ip32_ints.h&gt;</span>
<span class="cp">#include &lt;asm/ip32/mace.h&gt;</span>

<span class="cm">/*--- Global variables -------------------------------------------------*/</span>

<span class="cm">/* Verbose probing on by default for debugging. */</span>
<span class="cp">#if DEBUG_PARPORT_IP32 &gt;= 1</span>
<span class="cp">#	define DEFAULT_VERBOSE_PROBING	1</span>
<span class="cp">#else</span>
<span class="cp">#	define DEFAULT_VERBOSE_PROBING	0</span>
<span class="cp">#endif</span>

<span class="cm">/* Default prefix for printk */</span>
<span class="cp">#define PPIP32 &quot;parport_ip32: &quot;</span>

<span class="cm">/*</span>
<span class="cm"> * These are the module parameters:</span>
<span class="cm"> * @features:		bit mask of features to enable/disable</span>
<span class="cm"> *			(all enabled by default)</span>
<span class="cm"> * @verbose_probing:	log chit-chat during initialization</span>
<span class="cm"> */</span>
<span class="cp">#define PARPORT_IP32_ENABLE_IRQ	(1U &lt;&lt; 0)</span>
<span class="cp">#define PARPORT_IP32_ENABLE_DMA	(1U &lt;&lt; 1)</span>
<span class="cp">#define PARPORT_IP32_ENABLE_SPP	(1U &lt;&lt; 2)</span>
<span class="cp">#define PARPORT_IP32_ENABLE_EPP	(1U &lt;&lt; 3)</span>
<span class="cp">#define PARPORT_IP32_ENABLE_ECP	(1U &lt;&lt; 4)</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">features</span> <span class="o">=</span>	<span class="o">~</span><span class="mi">0U</span><span class="p">;</span>
<span class="k">static</span> <span class="n">bool</span> <span class="n">verbose_probing</span> <span class="o">=</span>	<span class="n">DEFAULT_VERBOSE_PROBING</span><span class="p">;</span>

<span class="cm">/* We do not support more than one port. */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">parport</span> <span class="o">*</span><span class="n">this_port</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

<span class="cm">/* Timing constants for FIFO modes.  */</span>
<span class="cp">#define FIFO_NFAULT_TIMEOUT	100	</span><span class="cm">/* milliseconds */</span><span class="cp"></span>
<span class="cp">#define FIFO_POLLING_INTERVAL	50	</span><span class="cm">/* microseconds */</span><span class="cp"></span>

<span class="cm">/*--- I/O register definitions -----------------------------------------*/</span>

<span class="cm">/**</span>
<span class="cm"> * struct parport_ip32_regs - virtual addresses of parallel port registers</span>
<span class="cm"> * @data:	Data Register</span>
<span class="cm"> * @dsr:	Device Status Register</span>
<span class="cm"> * @dcr:	Device Control Register</span>
<span class="cm"> * @eppAddr:	EPP Address Register</span>
<span class="cm"> * @eppData0:	EPP Data Register 0</span>
<span class="cm"> * @eppData1:	EPP Data Register 1</span>
<span class="cm"> * @eppData2:	EPP Data Register 2</span>
<span class="cm"> * @eppData3:	EPP Data Register 3</span>
<span class="cm"> * @ecpAFifo:	ECP Address FIFO</span>
<span class="cm"> * @fifo:	General FIFO register.  The same address is used for:</span>
<span class="cm"> *		- cFifo, the Parallel Port DATA FIFO</span>
<span class="cm"> *		- ecpDFifo, the ECP Data FIFO</span>
<span class="cm"> *		- tFifo, the ECP Test FIFO</span>
<span class="cm"> * @cnfgA:	Configuration Register A</span>
<span class="cm"> * @cnfgB:	Configuration Register B</span>
<span class="cm"> * @ecr:	Extended Control Register</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">parport_ip32_regs</span> <span class="p">{</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">data</span><span class="p">;</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">dsr</span><span class="p">;</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">dcr</span><span class="p">;</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">eppAddr</span><span class="p">;</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">eppData0</span><span class="p">;</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">eppData1</span><span class="p">;</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">eppData2</span><span class="p">;</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">eppData3</span><span class="p">;</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">ecpAFifo</span><span class="p">;</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">fifo</span><span class="p">;</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">cnfgA</span><span class="p">;</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">cnfgB</span><span class="p">;</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">ecr</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* Device Status Register */</span>
<span class="cp">#define DSR_nBUSY		(1U &lt;&lt; 7)	</span><span class="cm">/* PARPORT_STATUS_BUSY */</span><span class="cp"></span>
<span class="cp">#define DSR_nACK		(1U &lt;&lt; 6)	</span><span class="cm">/* PARPORT_STATUS_ACK */</span><span class="cp"></span>
<span class="cp">#define DSR_PERROR		(1U &lt;&lt; 5)	</span><span class="cm">/* PARPORT_STATUS_PAPEROUT */</span><span class="cp"></span>
<span class="cp">#define DSR_SELECT		(1U &lt;&lt; 4)	</span><span class="cm">/* PARPORT_STATUS_SELECT */</span><span class="cp"></span>
<span class="cp">#define DSR_nFAULT		(1U &lt;&lt; 3)	</span><span class="cm">/* PARPORT_STATUS_ERROR */</span><span class="cp"></span>
<span class="cp">#define DSR_nPRINT		(1U &lt;&lt; 2)	</span><span class="cm">/* specific to TL16PIR552 */</span><span class="cp"></span>
<span class="cm">/* #define DSR_reserved		(1U &lt;&lt; 1) */</span>
<span class="cp">#define DSR_TIMEOUT		(1U &lt;&lt; 0)	</span><span class="cm">/* EPP timeout */</span><span class="cp"></span>

<span class="cm">/* Device Control Register */</span>
<span class="cm">/* #define DCR_reserved		(1U &lt;&lt; 7) | (1U &lt;&lt;  6) */</span>
<span class="cp">#define DCR_DIR			(1U &lt;&lt; 5)	</span><span class="cm">/* direction */</span><span class="cp"></span>
<span class="cp">#define DCR_IRQ			(1U &lt;&lt; 4)	</span><span class="cm">/* interrupt on nAck */</span><span class="cp"></span>
<span class="cp">#define DCR_SELECT		(1U &lt;&lt; 3)	</span><span class="cm">/* PARPORT_CONTROL_SELECT */</span><span class="cp"></span>
<span class="cp">#define DCR_nINIT		(1U &lt;&lt; 2)	</span><span class="cm">/* PARPORT_CONTROL_INIT */</span><span class="cp"></span>
<span class="cp">#define DCR_AUTOFD		(1U &lt;&lt; 1)	</span><span class="cm">/* PARPORT_CONTROL_AUTOFD */</span><span class="cp"></span>
<span class="cp">#define DCR_STROBE		(1U &lt;&lt; 0)	</span><span class="cm">/* PARPORT_CONTROL_STROBE */</span><span class="cp"></span>

<span class="cm">/* ECP Configuration Register A */</span>
<span class="cp">#define CNFGA_IRQ		(1U &lt;&lt; 7)</span>
<span class="cp">#define CNFGA_ID_MASK		((1U &lt;&lt; 6) | (1U &lt;&lt; 5) | (1U &lt;&lt; 4))</span>
<span class="cp">#define CNFGA_ID_SHIFT		4</span>
<span class="cp">#define CNFGA_ID_16		(00U &lt;&lt; CNFGA_ID_SHIFT)</span>
<span class="cp">#define CNFGA_ID_8		(01U &lt;&lt; CNFGA_ID_SHIFT)</span>
<span class="cp">#define CNFGA_ID_32		(02U &lt;&lt; CNFGA_ID_SHIFT)</span>
<span class="cm">/* #define CNFGA_reserved	(1U &lt;&lt; 3) */</span>
<span class="cp">#define CNFGA_nBYTEINTRANS	(1U &lt;&lt; 2)</span>
<span class="cp">#define CNFGA_PWORDLEFT		((1U &lt;&lt; 1) | (1U &lt;&lt; 0))</span>

<span class="cm">/* ECP Configuration Register B */</span>
<span class="cp">#define CNFGB_COMPRESS		(1U &lt;&lt; 7)</span>
<span class="cp">#define CNFGB_INTRVAL		(1U &lt;&lt; 6)</span>
<span class="cp">#define CNFGB_IRQ_MASK		((1U &lt;&lt; 5) | (1U &lt;&lt; 4) | (1U &lt;&lt; 3))</span>
<span class="cp">#define CNFGB_IRQ_SHIFT		3</span>
<span class="cp">#define CNFGB_DMA_MASK		((1U &lt;&lt; 2) | (1U &lt;&lt; 1) | (1U &lt;&lt; 0))</span>
<span class="cp">#define CNFGB_DMA_SHIFT		0</span>

<span class="cm">/* Extended Control Register */</span>
<span class="cp">#define ECR_MODE_MASK		((1U &lt;&lt; 7) | (1U &lt;&lt; 6) | (1U &lt;&lt; 5))</span>
<span class="cp">#define ECR_MODE_SHIFT		5</span>
<span class="cp">#define ECR_MODE_SPP		(00U &lt;&lt; ECR_MODE_SHIFT)</span>
<span class="cp">#define ECR_MODE_PS2		(01U &lt;&lt; ECR_MODE_SHIFT)</span>
<span class="cp">#define ECR_MODE_PPF		(02U &lt;&lt; ECR_MODE_SHIFT)</span>
<span class="cp">#define ECR_MODE_ECP		(03U &lt;&lt; ECR_MODE_SHIFT)</span>
<span class="cp">#define ECR_MODE_EPP		(04U &lt;&lt; ECR_MODE_SHIFT)</span>
<span class="cm">/* #define ECR_MODE_reserved	(05U &lt;&lt; ECR_MODE_SHIFT) */</span>
<span class="cp">#define ECR_MODE_TST		(06U &lt;&lt; ECR_MODE_SHIFT)</span>
<span class="cp">#define ECR_MODE_CFG		(07U &lt;&lt; ECR_MODE_SHIFT)</span>
<span class="cp">#define ECR_nERRINTR		(1U &lt;&lt; 4)</span>
<span class="cp">#define ECR_DMAEN		(1U &lt;&lt; 3)</span>
<span class="cp">#define ECR_SERVINTR		(1U &lt;&lt; 2)</span>
<span class="cp">#define ECR_F_FULL		(1U &lt;&lt; 1)</span>
<span class="cp">#define ECR_F_EMPTY		(1U &lt;&lt; 0)</span>

<span class="cm">/*--- Private data -----------------------------------------------------*/</span>

<span class="cm">/**</span>
<span class="cm"> * enum parport_ip32_irq_mode - operation mode of interrupt handler</span>
<span class="cm"> * @PARPORT_IP32_IRQ_FWD:	forward interrupt to the upper parport layer</span>
<span class="cm"> * @PARPORT_IP32_IRQ_HERE:	interrupt is handled locally</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="n">parport_ip32_irq_mode</span> <span class="p">{</span> <span class="n">PARPORT_IP32_IRQ_FWD</span><span class="p">,</span> <span class="n">PARPORT_IP32_IRQ_HERE</span> <span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * struct parport_ip32_private - private stuff for &amp;struct parport</span>
<span class="cm"> * @regs:		register addresses</span>
<span class="cm"> * @dcr_cache:		cached contents of DCR</span>
<span class="cm"> * @dcr_writable:	bit mask of writable DCR bits</span>
<span class="cm"> * @pword:		number of bytes per PWord</span>
<span class="cm"> * @fifo_depth:		number of PWords that FIFO will hold</span>
<span class="cm"> * @readIntrThreshold:	minimum number of PWords we can read</span>
<span class="cm"> *			if we get an interrupt</span>
<span class="cm"> * @writeIntrThreshold:	minimum number of PWords we can write</span>
<span class="cm"> *			if we get an interrupt</span>
<span class="cm"> * @irq_mode:		operation mode of interrupt handler for this port</span>
<span class="cm"> * @irq_complete:	mutex used to wait for an interrupt to occur</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">parport_ip32_private</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">parport_ip32_regs</span>	<span class="n">regs</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>			<span class="n">dcr_cache</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>			<span class="n">dcr_writable</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>			<span class="n">pword</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>			<span class="n">fifo_depth</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>			<span class="n">readIntrThreshold</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>			<span class="n">writeIntrThreshold</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">parport_ip32_irq_mode</span>	<span class="n">irq_mode</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">completion</span>		<span class="n">irq_complete</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/*--- Debug code -------------------------------------------------------*/</span>

<span class="cm">/*</span>
<span class="cm"> * pr_debug1 - print debug messages</span>
<span class="cm"> *</span>
<span class="cm"> * This is like pr_debug(), but is defined for %DEBUG_PARPORT_IP32 &gt;= 1</span>
<span class="cm"> */</span>
<span class="cp">#if DEBUG_PARPORT_IP32 &gt;= 1</span>
<span class="cp">#	define pr_debug1(...)	printk(KERN_DEBUG __VA_ARGS__)</span>
<span class="cp">#else </span><span class="cm">/* DEBUG_PARPORT_IP32 &lt; 1 */</span><span class="cp"></span>
<span class="cp">#	define pr_debug1(...)	do { } while (0)</span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> * pr_trace, pr_trace1 - trace function calls</span>
<span class="cm"> * @p:		pointer to &amp;struct parport</span>
<span class="cm"> * @fmt:	printk format string</span>
<span class="cm"> * @...:	parameters for format string</span>
<span class="cm"> *</span>
<span class="cm"> * Macros used to trace function calls.  The given string is formatted after</span>
<span class="cm"> * function name.  pr_trace() uses pr_debug(), and pr_trace1() uses</span>
<span class="cm"> * pr_debug1().  __pr_trace() is the low-level macro and is not to be used</span>
<span class="cm"> * directly.</span>
<span class="cm"> */</span>
<span class="cp">#define __pr_trace(pr, p, fmt, ...)					\</span>
<span class="cp">	pr(&quot;%s: %s&quot; fmt &quot;\n&quot;,						\</span>
<span class="cp">	   ({ const struct parport *__p = (p);				\</span>
<span class="cp">		   __p ? __p-&gt;name : &quot;parport_ip32&quot;; }),		\</span>
<span class="cp">	   __func__ , ##__VA_ARGS__)</span>
<span class="cp">#define pr_trace(p, fmt, ...)	__pr_trace(pr_debug, p, fmt , ##__VA_ARGS__)</span>
<span class="cp">#define pr_trace1(p, fmt, ...)	__pr_trace(pr_debug1, p, fmt , ##__VA_ARGS__)</span>

<span class="cm">/*</span>
<span class="cm"> * __pr_probe, pr_probe - print message if @verbose_probing is true</span>
<span class="cm"> * @p:		pointer to &amp;struct parport</span>
<span class="cm"> * @fmt:	printk format string</span>
<span class="cm"> * @...:	parameters for format string</span>
<span class="cm"> *</span>
<span class="cm"> * For new lines, use pr_probe().  Use __pr_probe() for continued lines.</span>
<span class="cm"> */</span>
<span class="cp">#define __pr_probe(...)							\</span>
<span class="cp">	do { if (verbose_probing) printk(__VA_ARGS__); } while (0)</span>
<span class="cp">#define pr_probe(p, fmt, ...)						\</span>
<span class="cp">	__pr_probe(KERN_INFO PPIP32 &quot;0x%lx: &quot; fmt, (p)-&gt;base , ##__VA_ARGS__)</span>

<span class="cm">/*</span>
<span class="cm"> * parport_ip32_dump_state - print register status of parport</span>
<span class="cm"> * @p:		pointer to &amp;struct parport</span>
<span class="cm"> * @str:	string to add in message</span>
<span class="cm"> * @show_ecp_config:	shall we dump ECP configuration registers too?</span>
<span class="cm"> *</span>
<span class="cm"> * This function is only here for debugging purpose, and should be used with</span>
<span class="cm"> * care.  Reading the parallel port registers may have undesired side effects.</span>
<span class="cm"> * Especially if @show_ecp_config is true, the parallel port is resetted.</span>
<span class="cm"> * This function is only defined if %DEBUG_PARPORT_IP32 &gt;= 2.</span>
<span class="cm"> */</span>
<span class="cp">#if DEBUG_PARPORT_IP32 &gt;= 2</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">parport_ip32_dump_state</span><span class="p">(</span><span class="k">struct</span> <span class="n">parport</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">,</span>
				    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">show_ecp_config</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">parport_ip32_private</span> <span class="o">*</span> <span class="k">const</span> <span class="n">priv</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">physport</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="n">PPIP32</span> <span class="s">&quot;%s: state (%s):</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">str</span><span class="p">);</span>
	<span class="p">{</span>
		<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">ecr_modes</span><span class="p">[</span><span class="mi">8</span><span class="p">][</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s">&quot;SPP&quot;</span><span class="p">,</span> <span class="s">&quot;PS2&quot;</span><span class="p">,</span> <span class="s">&quot;PPF&quot;</span><span class="p">,</span>
						     <span class="s">&quot;ECP&quot;</span><span class="p">,</span> <span class="s">&quot;EPP&quot;</span><span class="p">,</span> <span class="s">&quot;???&quot;</span><span class="p">,</span>
						     <span class="s">&quot;TST&quot;</span><span class="p">,</span> <span class="s">&quot;CFG&quot;</span><span class="p">};</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ecr</span> <span class="o">=</span> <span class="n">readb</span><span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">.</span><span class="n">ecr</span><span class="p">);</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="n">PPIP32</span> <span class="s">&quot;    ecr=0x%02x&quot;</span><span class="p">,</span> <span class="n">ecr</span><span class="p">);</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot; %s&quot;</span><span class="p">,</span>
		       <span class="n">ecr_modes</span><span class="p">[(</span><span class="n">ecr</span> <span class="o">&amp;</span> <span class="n">ECR_MODE_MASK</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">ECR_MODE_SHIFT</span><span class="p">]);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ecr</span> <span class="o">&amp;</span> <span class="n">ECR_nERRINTR</span><span class="p">)</span>
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot;,nErrIntrEn&quot;</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ecr</span> <span class="o">&amp;</span> <span class="n">ECR_DMAEN</span><span class="p">)</span>
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot;,dmaEn&quot;</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ecr</span> <span class="o">&amp;</span> <span class="n">ECR_SERVINTR</span><span class="p">)</span>
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot;,serviceIntr&quot;</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ecr</span> <span class="o">&amp;</span> <span class="n">ECR_F_FULL</span><span class="p">)</span>
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot;,f_full&quot;</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ecr</span> <span class="o">&amp;</span> <span class="n">ECR_F_EMPTY</span><span class="p">)</span>
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot;,f_empty&quot;</span><span class="p">);</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">show_ecp_config</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">oecr</span><span class="p">,</span> <span class="n">cnfgA</span><span class="p">,</span> <span class="n">cnfgB</span><span class="p">;</span>
		<span class="n">oecr</span> <span class="o">=</span> <span class="n">readb</span><span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">.</span><span class="n">ecr</span><span class="p">);</span>
		<span class="n">writeb</span><span class="p">(</span><span class="n">ECR_MODE_PS2</span><span class="p">,</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">.</span><span class="n">ecr</span><span class="p">);</span>
		<span class="n">writeb</span><span class="p">(</span><span class="n">ECR_MODE_CFG</span><span class="p">,</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">.</span><span class="n">ecr</span><span class="p">);</span>
		<span class="n">cnfgA</span> <span class="o">=</span> <span class="n">readb</span><span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">.</span><span class="n">cnfgA</span><span class="p">);</span>
		<span class="n">cnfgB</span> <span class="o">=</span> <span class="n">readb</span><span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">.</span><span class="n">cnfgB</span><span class="p">);</span>
		<span class="n">writeb</span><span class="p">(</span><span class="n">ECR_MODE_PS2</span><span class="p">,</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">.</span><span class="n">ecr</span><span class="p">);</span>
		<span class="n">writeb</span><span class="p">(</span><span class="n">oecr</span><span class="p">,</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">.</span><span class="n">ecr</span><span class="p">);</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="n">PPIP32</span> <span class="s">&quot;    cnfgA=0x%02x&quot;</span><span class="p">,</span> <span class="n">cnfgA</span><span class="p">);</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot; ISA-%s&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">cnfgA</span> <span class="o">&amp;</span> <span class="n">CNFGA_IRQ</span><span class="p">)</span> <span class="o">?</span> <span class="s">&quot;Level&quot;</span> <span class="o">:</span> <span class="s">&quot;Pulses&quot;</span><span class="p">);</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">cnfgA</span> <span class="o">&amp;</span> <span class="n">CNFGA_ID_MASK</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">CNFGA_ID_8</span>:
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot;,8 bits&quot;</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">CNFGA_ID_16</span>:
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot;,16 bits&quot;</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">CNFGA_ID_32</span>:
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot;,32 bits&quot;</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="nl">default:</span>
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot;,unknown ID&quot;</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">cnfgA</span> <span class="o">&amp;</span> <span class="n">CNFGA_nBYTEINTRANS</span><span class="p">))</span>
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot;,ByteInTrans&quot;</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">cnfgA</span> <span class="o">&amp;</span> <span class="n">CNFGA_ID_MASK</span><span class="p">)</span> <span class="o">!=</span> <span class="n">CNFGA_ID_8</span><span class="p">)</span>
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot;,%d byte%s left&quot;</span><span class="p">,</span> <span class="n">cnfgA</span> <span class="o">&amp;</span> <span class="n">CNFGA_PWORDLEFT</span><span class="p">,</span>
			       <span class="p">((</span><span class="n">cnfgA</span> <span class="o">&amp;</span> <span class="n">CNFGA_PWORDLEFT</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">?</span> <span class="s">&quot;s&quot;</span> <span class="o">:</span> <span class="s">&quot;&quot;</span><span class="p">);</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="n">PPIP32</span> <span class="s">&quot;    cnfgB=0x%02x&quot;</span><span class="p">,</span> <span class="n">cnfgB</span><span class="p">);</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot; irq=%u,dma=%u&quot;</span><span class="p">,</span>
		       <span class="p">(</span><span class="n">cnfgB</span> <span class="o">&amp;</span> <span class="n">CNFGB_IRQ_MASK</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">CNFGB_IRQ_SHIFT</span><span class="p">,</span>
		       <span class="p">(</span><span class="n">cnfgB</span> <span class="o">&amp;</span> <span class="n">CNFGB_DMA_MASK</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">CNFGB_DMA_SHIFT</span><span class="p">);</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;,intrValue=%d&quot;</span><span class="p">,</span> <span class="o">!!</span><span class="p">(</span><span class="n">cnfgB</span> <span class="o">&amp;</span> <span class="n">CNFGB_INTRVAL</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cnfgB</span> <span class="o">&amp;</span> <span class="n">CNFGB_COMPRESS</span><span class="p">)</span>
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot;,compress&quot;</span><span class="p">);</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">dcr</span> <span class="o">=</span> <span class="n">i</span> <span class="o">?</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">dcr_cache</span> <span class="o">:</span> <span class="n">readb</span><span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">.</span><span class="n">dcr</span><span class="p">);</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="n">PPIP32</span> <span class="s">&quot;    dcr(%s)=0x%02x&quot;</span><span class="p">,</span>
		       <span class="n">i</span> <span class="o">?</span> <span class="s">&quot;soft&quot;</span> <span class="o">:</span> <span class="s">&quot;hard&quot;</span><span class="p">,</span> <span class="n">dcr</span><span class="p">);</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot; %s&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">dcr</span> <span class="o">&amp;</span> <span class="n">DCR_DIR</span><span class="p">)</span> <span class="o">?</span> <span class="s">&quot;rev&quot;</span> <span class="o">:</span> <span class="s">&quot;fwd&quot;</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dcr</span> <span class="o">&amp;</span> <span class="n">DCR_IRQ</span><span class="p">)</span>
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot;,ackIntEn&quot;</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">dcr</span> <span class="o">&amp;</span> <span class="n">DCR_SELECT</span><span class="p">))</span>
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot;,nSelectIn&quot;</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dcr</span> <span class="o">&amp;</span> <span class="n">DCR_nINIT</span><span class="p">)</span>
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot;,nInit&quot;</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">dcr</span> <span class="o">&amp;</span> <span class="n">DCR_AUTOFD</span><span class="p">))</span>
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot;,nAutoFD&quot;</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">dcr</span> <span class="o">&amp;</span> <span class="n">DCR_STROBE</span><span class="p">))</span>
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot;,nStrobe&quot;</span><span class="p">);</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span>
<span class="cp">#define sep (f++ ? &#39;,&#39; : &#39; &#39;)</span>
	<span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">f</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">dsr</span> <span class="o">=</span> <span class="n">readb</span><span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">.</span><span class="n">dsr</span><span class="p">);</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="n">PPIP32</span> <span class="s">&quot;    dsr=0x%02x&quot;</span><span class="p">,</span> <span class="n">dsr</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">dsr</span> <span class="o">&amp;</span> <span class="n">DSR_nBUSY</span><span class="p">))</span>
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%cBusy&quot;</span><span class="p">,</span> <span class="n">sep</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dsr</span> <span class="o">&amp;</span> <span class="n">DSR_nACK</span><span class="p">)</span>
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%cnAck&quot;</span><span class="p">,</span> <span class="n">sep</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dsr</span> <span class="o">&amp;</span> <span class="n">DSR_PERROR</span><span class="p">)</span>
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%cPError&quot;</span><span class="p">,</span> <span class="n">sep</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dsr</span> <span class="o">&amp;</span> <span class="n">DSR_SELECT</span><span class="p">)</span>
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%cSelect&quot;</span><span class="p">,</span> <span class="n">sep</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dsr</span> <span class="o">&amp;</span> <span class="n">DSR_nFAULT</span><span class="p">)</span>
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%cnFault&quot;</span><span class="p">,</span> <span class="n">sep</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">dsr</span> <span class="o">&amp;</span> <span class="n">DSR_nPRINT</span><span class="p">))</span>
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%c(Print)&quot;</span><span class="p">,</span> <span class="n">sep</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dsr</span> <span class="o">&amp;</span> <span class="n">DSR_TIMEOUT</span><span class="p">)</span>
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%cTimeout&quot;</span><span class="p">,</span> <span class="n">sep</span><span class="p">);</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span>
<span class="cp">#undef sep</span>
<span class="p">}</span>
<span class="cp">#else </span><span class="cm">/* DEBUG_PARPORT_IP32 &lt; 2 */</span><span class="cp"></span>
<span class="cp">#define parport_ip32_dump_state(...)	do { } while (0)</span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> * CHECK_EXTRA_BITS - track and log extra bits</span>
<span class="cm"> * @p:		pointer to &amp;struct parport</span>
<span class="cm"> * @b:		byte to inspect</span>
<span class="cm"> * @m:		bit mask of authorized bits</span>
<span class="cm"> *</span>
<span class="cm"> * This is used to track and log extra bits that should not be there in</span>
<span class="cm"> * parport_ip32_write_control() and parport_ip32_frob_control().  It is only</span>
<span class="cm"> * defined if %DEBUG_PARPORT_IP32 &gt;= 1.</span>
<span class="cm"> */</span>
<span class="cp">#if DEBUG_PARPORT_IP32 &gt;= 1</span>
<span class="cp">#define CHECK_EXTRA_BITS(p, b, m)					\</span>
<span class="cp">	do {								\</span>
<span class="cp">		unsigned int __b = (b), __m = (m);			\</span>
<span class="cp">		if (__b &amp; ~__m)						\</span>
<span class="cp">			pr_debug1(PPIP32 &quot;%s: extra bits in %s(%s): &quot;	\</span>
<span class="cp">				  &quot;0x%02x/0x%02x\n&quot;,			\</span>
<span class="cp">				  (p)-&gt;name, __func__, #b, __b, __m);	\</span>
<span class="cp">	} while (0)</span>
<span class="cp">#else </span><span class="cm">/* DEBUG_PARPORT_IP32 &lt; 1 */</span><span class="cp"></span>
<span class="cp">#define CHECK_EXTRA_BITS(...)	do { } while (0)</span>
<span class="cp">#endif</span>

<span class="cm">/*--- IP32 parallel port DMA operations --------------------------------*/</span>

<span class="cm">/**</span>
<span class="cm"> * struct parport_ip32_dma_data - private data needed for DMA operation</span>
<span class="cm"> * @dir:	DMA direction (from or to device)</span>
<span class="cm"> * @buf:	buffer physical address</span>
<span class="cm"> * @len:	buffer length</span>
<span class="cm"> * @next:	address of next bytes to DMA transfer</span>
<span class="cm"> * @left:	number of bytes remaining</span>
<span class="cm"> * @ctx:	next context to write (0: context_a; 1: context_b)</span>
<span class="cm"> * @irq_on:	are the DMA IRQs currently enabled?</span>
<span class="cm"> * @lock:	spinlock to protect access to the structure</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">parport_ip32_dma_data</span> <span class="p">{</span>
	<span class="k">enum</span> <span class="n">dma_data_direction</span>		<span class="n">dir</span><span class="p">;</span>
	<span class="n">dma_addr_t</span>			<span class="n">buf</span><span class="p">;</span>
	<span class="n">dma_addr_t</span>			<span class="n">next</span><span class="p">;</span>
	<span class="kt">size_t</span>				<span class="n">len</span><span class="p">;</span>
	<span class="kt">size_t</span>				<span class="n">left</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>			<span class="n">ctx</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>			<span class="n">irq_on</span><span class="p">;</span>
	<span class="n">spinlock_t</span>			<span class="n">lock</span><span class="p">;</span>
<span class="p">};</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">parport_ip32_dma_data</span> <span class="n">parport_ip32_dma</span><span class="p">;</span>

<span class="cm">/**</span>
<span class="cm"> * parport_ip32_dma_setup_context - setup next DMA context</span>
<span class="cm"> * @limit:	maximum data size for the context</span>
<span class="cm"> *</span>
<span class="cm"> * The alignment constraints must be verified in caller function, and the</span>
<span class="cm"> * parameter @limit must be set accordingly.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">parport_ip32_dma_setup_context</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">limit</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">parport_ip32_dma</span><span class="p">.</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">parport_ip32_dma</span><span class="p">.</span><span class="n">left</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Note: ctxreg is &quot;volatile&quot; here only because</span>
<span class="cm">		 * mace-&gt;perif.ctrl.parport.context_a and context_b are</span>
<span class="cm">		 * &quot;volatile&quot;.  */</span>
		<span class="k">volatile</span> <span class="n">u64</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">ctxreg</span> <span class="o">=</span> <span class="p">(</span><span class="n">parport_ip32_dma</span><span class="p">.</span><span class="n">ctx</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">?</span>
			<span class="o">&amp;</span><span class="n">mace</span><span class="o">-&gt;</span><span class="n">perif</span><span class="p">.</span><span class="n">ctrl</span><span class="p">.</span><span class="n">parport</span><span class="p">.</span><span class="n">context_a</span> <span class="o">:</span>
			<span class="o">&amp;</span><span class="n">mace</span><span class="o">-&gt;</span><span class="n">perif</span><span class="p">.</span><span class="n">ctrl</span><span class="p">.</span><span class="n">parport</span><span class="p">.</span><span class="n">context_b</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">count</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">ctxval</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">parport_ip32_dma</span><span class="p">.</span><span class="n">left</span> <span class="o">&lt;=</span> <span class="n">limit</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">count</span> <span class="o">=</span> <span class="n">parport_ip32_dma</span><span class="p">.</span><span class="n">left</span><span class="p">;</span>
			<span class="n">ctxval</span> <span class="o">=</span> <span class="n">MACEPAR_CONTEXT_LASTFLAG</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">count</span> <span class="o">=</span> <span class="n">limit</span><span class="p">;</span>
			<span class="n">ctxval</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">pr_trace</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span>
			 <span class="s">&quot;(%u): 0x%04x:0x%04x, %u -&gt; %u%s&quot;</span><span class="p">,</span>
			 <span class="n">limit</span><span class="p">,</span>
			 <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)</span><span class="n">parport_ip32_dma</span><span class="p">.</span><span class="n">buf</span><span class="p">,</span>
			 <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)</span><span class="n">parport_ip32_dma</span><span class="p">.</span><span class="n">next</span><span class="p">,</span>
			 <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)</span><span class="n">count</span><span class="p">,</span>
			 <span class="n">parport_ip32_dma</span><span class="p">.</span><span class="n">ctx</span><span class="p">,</span> <span class="n">ctxval</span> <span class="o">?</span> <span class="s">&quot;*&quot;</span> <span class="o">:</span> <span class="s">&quot;&quot;</span><span class="p">);</span>

		<span class="n">ctxval</span> <span class="o">|=</span> <span class="n">parport_ip32_dma</span><span class="p">.</span><span class="n">next</span> <span class="o">&amp;</span>
			<span class="n">MACEPAR_CONTEXT_BASEADDR_MASK</span><span class="p">;</span>
		<span class="n">ctxval</span> <span class="o">|=</span> <span class="p">((</span><span class="n">count</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">MACEPAR_CONTEXT_DATALEN_SHIFT</span><span class="p">)</span> <span class="o">&amp;</span>
			<span class="n">MACEPAR_CONTEXT_DATALEN_MASK</span><span class="p">;</span>
		<span class="n">writeq</span><span class="p">(</span><span class="n">ctxval</span><span class="p">,</span> <span class="n">ctxreg</span><span class="p">);</span>
		<span class="n">parport_ip32_dma</span><span class="p">.</span><span class="n">next</span> <span class="o">+=</span> <span class="n">count</span><span class="p">;</span>
		<span class="n">parport_ip32_dma</span><span class="p">.</span><span class="n">left</span> <span class="o">-=</span> <span class="n">count</span><span class="p">;</span>
		<span class="n">parport_ip32_dma</span><span class="p">.</span><span class="n">ctx</span> <span class="o">^=</span> <span class="mi">1U</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* If there is nothing more to send, disable IRQs to avoid to</span>
<span class="cm">	 * face an IRQ storm which can lock the machine.  Disable them</span>
<span class="cm">	 * only once. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">parport_ip32_dma</span><span class="p">.</span><span class="n">left</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">parport_ip32_dma</span><span class="p">.</span><span class="n">irq_on</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="n">PPIP32</span> <span class="s">&quot;IRQ off (ctx)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">disable_irq_nosync</span><span class="p">(</span><span class="n">MACEISA_PAR_CTXA_IRQ</span><span class="p">);</span>
		<span class="n">disable_irq_nosync</span><span class="p">(</span><span class="n">MACEISA_PAR_CTXB_IRQ</span><span class="p">);</span>
		<span class="n">parport_ip32_dma</span><span class="p">.</span><span class="n">irq_on</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">parport_ip32_dma</span><span class="p">.</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * parport_ip32_dma_interrupt - DMA interrupt handler</span>
<span class="cm"> * @irq:	interrupt number</span>
<span class="cm"> * @dev_id:	unused</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">irqreturn_t</span> <span class="nf">parport_ip32_dma_interrupt</span><span class="p">(</span><span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">dev_id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">parport_ip32_dma</span><span class="p">.</span><span class="n">left</span><span class="p">)</span>
		<span class="n">pr_trace</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="s">&quot;(%d): ctx=%d&quot;</span><span class="p">,</span> <span class="n">irq</span><span class="p">,</span> <span class="n">parport_ip32_dma</span><span class="p">.</span><span class="n">ctx</span><span class="p">);</span>
	<span class="n">parport_ip32_dma_setup_context</span><span class="p">(</span><span class="n">MACEPAR_CONTEXT_DATA_BOUND</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">IRQ_HANDLED</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#if DEBUG_PARPORT_IP32</span>
<span class="k">static</span> <span class="n">irqreturn_t</span> <span class="nf">parport_ip32_merr_interrupt</span><span class="p">(</span><span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">dev_id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pr_trace1</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="s">&quot;(%d)&quot;</span><span class="p">,</span> <span class="n">irq</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">IRQ_HANDLED</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="cm">/**</span>
<span class="cm"> * parport_ip32_dma_start - begins a DMA transfer</span>
<span class="cm"> * @dir:	DMA direction: DMA_TO_DEVICE or DMA_FROM_DEVICE</span>
<span class="cm"> * @addr:	pointer to data buffer</span>
<span class="cm"> * @count:	buffer size</span>
<span class="cm"> *</span>
<span class="cm"> * Calls to parport_ip32_dma_start() and parport_ip32_dma_stop() must be</span>
<span class="cm"> * correctly balanced.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">parport_ip32_dma_start</span><span class="p">(</span><span class="k">enum</span> <span class="n">dma_data_direction</span> <span class="n">dir</span><span class="p">,</span>
				  <span class="kt">void</span> <span class="o">*</span><span class="n">addr</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">limit</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">ctrl</span><span class="p">;</span>

	<span class="n">pr_trace</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="s">&quot;(%d, %lu)&quot;</span><span class="p">,</span> <span class="n">dir</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">count</span><span class="p">);</span>

	<span class="cm">/* FIXME - add support for DMA_FROM_DEVICE.  In this case, buffer must</span>
<span class="cm">	 * be 64 bytes aligned. */</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">dir</span> <span class="o">!=</span> <span class="n">DMA_TO_DEVICE</span><span class="p">);</span>

	<span class="cm">/* Reset DMA controller */</span>
	<span class="n">ctrl</span> <span class="o">=</span> <span class="n">MACEPAR_CTLSTAT_RESET</span><span class="p">;</span>
	<span class="n">writeq</span><span class="p">(</span><span class="n">ctrl</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mace</span><span class="o">-&gt;</span><span class="n">perif</span><span class="p">.</span><span class="n">ctrl</span><span class="p">.</span><span class="n">parport</span><span class="p">.</span><span class="n">cntlstat</span><span class="p">);</span>

	<span class="cm">/* DMA IRQs should normally be enabled */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">parport_ip32_dma</span><span class="p">.</span><span class="n">irq_on</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">WARN_ON</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
		<span class="n">enable_irq</span><span class="p">(</span><span class="n">MACEISA_PAR_CTXA_IRQ</span><span class="p">);</span>
		<span class="n">enable_irq</span><span class="p">(</span><span class="n">MACEISA_PAR_CTXB_IRQ</span><span class="p">);</span>
		<span class="n">parport_ip32_dma</span><span class="p">.</span><span class="n">irq_on</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Prepare DMA pointers */</span>
	<span class="n">parport_ip32_dma</span><span class="p">.</span><span class="n">dir</span> <span class="o">=</span> <span class="n">dir</span><span class="p">;</span>
	<span class="n">parport_ip32_dma</span><span class="p">.</span><span class="n">buf</span> <span class="o">=</span> <span class="n">dma_map_single</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">count</span><span class="p">,</span> <span class="n">dir</span><span class="p">);</span>
	<span class="n">parport_ip32_dma</span><span class="p">.</span><span class="n">len</span> <span class="o">=</span> <span class="n">count</span><span class="p">;</span>
	<span class="n">parport_ip32_dma</span><span class="p">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">parport_ip32_dma</span><span class="p">.</span><span class="n">buf</span><span class="p">;</span>
	<span class="n">parport_ip32_dma</span><span class="p">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">parport_ip32_dma</span><span class="p">.</span><span class="n">len</span><span class="p">;</span>
	<span class="n">parport_ip32_dma</span><span class="p">.</span><span class="n">ctx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Setup DMA direction and first two contexts */</span>
	<span class="n">ctrl</span> <span class="o">=</span> <span class="p">(</span><span class="n">dir</span> <span class="o">==</span> <span class="n">DMA_TO_DEVICE</span><span class="p">)</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="n">MACEPAR_CTLSTAT_DIRECTION</span><span class="p">;</span>
	<span class="n">writeq</span><span class="p">(</span><span class="n">ctrl</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mace</span><span class="o">-&gt;</span><span class="n">perif</span><span class="p">.</span><span class="n">ctrl</span><span class="p">.</span><span class="n">parport</span><span class="p">.</span><span class="n">cntlstat</span><span class="p">);</span>
	<span class="cm">/* Single transfer should not cross a 4K page boundary */</span>
	<span class="n">limit</span> <span class="o">=</span> <span class="n">MACEPAR_CONTEXT_DATA_BOUND</span> <span class="o">-</span>
		<span class="p">(</span><span class="n">parport_ip32_dma</span><span class="p">.</span><span class="n">next</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">MACEPAR_CONTEXT_DATA_BOUND</span> <span class="o">-</span> <span class="mi">1</span><span class="p">));</span>
	<span class="n">parport_ip32_dma_setup_context</span><span class="p">(</span><span class="n">limit</span><span class="p">);</span>
	<span class="n">parport_ip32_dma_setup_context</span><span class="p">(</span><span class="n">MACEPAR_CONTEXT_DATA_BOUND</span><span class="p">);</span>

	<span class="cm">/* Real start of DMA transfer */</span>
	<span class="n">ctrl</span> <span class="o">|=</span> <span class="n">MACEPAR_CTLSTAT_ENABLE</span><span class="p">;</span>
	<span class="n">writeq</span><span class="p">(</span><span class="n">ctrl</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mace</span><span class="o">-&gt;</span><span class="n">perif</span><span class="p">.</span><span class="n">ctrl</span><span class="p">.</span><span class="n">parport</span><span class="p">.</span><span class="n">cntlstat</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * parport_ip32_dma_stop - ends a running DMA transfer</span>
<span class="cm"> *</span>
<span class="cm"> * Calls to parport_ip32_dma_start() and parport_ip32_dma_stop() must be</span>
<span class="cm"> * correctly balanced.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">parport_ip32_dma_stop</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u64</span> <span class="n">ctx_a</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">ctx_b</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">ctrl</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">diag</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">res</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>	<span class="cm">/* {[0] = res_a, [1] = res_b} */</span>

	<span class="n">pr_trace</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="s">&quot;()&quot;</span><span class="p">);</span>

	<span class="cm">/* Disable IRQs */</span>
	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">parport_ip32_dma</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">parport_ip32_dma</span><span class="p">.</span><span class="n">irq_on</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="n">PPIP32</span> <span class="s">&quot;IRQ off (stop)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">disable_irq_nosync</span><span class="p">(</span><span class="n">MACEISA_PAR_CTXA_IRQ</span><span class="p">);</span>
		<span class="n">disable_irq_nosync</span><span class="p">(</span><span class="n">MACEISA_PAR_CTXB_IRQ</span><span class="p">);</span>
		<span class="n">parport_ip32_dma</span><span class="p">.</span><span class="n">irq_on</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">parport_ip32_dma</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>
	<span class="cm">/* Force IRQ synchronization, even if the IRQs were disabled</span>
<span class="cm">	 * elsewhere. */</span>
	<span class="n">synchronize_irq</span><span class="p">(</span><span class="n">MACEISA_PAR_CTXA_IRQ</span><span class="p">);</span>
	<span class="n">synchronize_irq</span><span class="p">(</span><span class="n">MACEISA_PAR_CTXB_IRQ</span><span class="p">);</span>

	<span class="cm">/* Stop DMA transfer */</span>
	<span class="n">ctrl</span> <span class="o">=</span> <span class="n">readq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mace</span><span class="o">-&gt;</span><span class="n">perif</span><span class="p">.</span><span class="n">ctrl</span><span class="p">.</span><span class="n">parport</span><span class="p">.</span><span class="n">cntlstat</span><span class="p">);</span>
	<span class="n">ctrl</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">MACEPAR_CTLSTAT_ENABLE</span><span class="p">;</span>
	<span class="n">writeq</span><span class="p">(</span><span class="n">ctrl</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mace</span><span class="o">-&gt;</span><span class="n">perif</span><span class="p">.</span><span class="n">ctrl</span><span class="p">.</span><span class="n">parport</span><span class="p">.</span><span class="n">cntlstat</span><span class="p">);</span>

	<span class="cm">/* Adjust residue (parport_ip32_dma.left) */</span>
	<span class="n">ctx_a</span> <span class="o">=</span> <span class="n">readq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mace</span><span class="o">-&gt;</span><span class="n">perif</span><span class="p">.</span><span class="n">ctrl</span><span class="p">.</span><span class="n">parport</span><span class="p">.</span><span class="n">context_a</span><span class="p">);</span>
	<span class="n">ctx_b</span> <span class="o">=</span> <span class="n">readq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mace</span><span class="o">-&gt;</span><span class="n">perif</span><span class="p">.</span><span class="n">ctrl</span><span class="p">.</span><span class="n">parport</span><span class="p">.</span><span class="n">context_b</span><span class="p">);</span>
	<span class="n">ctrl</span> <span class="o">=</span> <span class="n">readq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mace</span><span class="o">-&gt;</span><span class="n">perif</span><span class="p">.</span><span class="n">ctrl</span><span class="p">.</span><span class="n">parport</span><span class="p">.</span><span class="n">cntlstat</span><span class="p">);</span>
	<span class="n">diag</span> <span class="o">=</span> <span class="n">readq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mace</span><span class="o">-&gt;</span><span class="n">perif</span><span class="p">.</span><span class="n">ctrl</span><span class="p">.</span><span class="n">parport</span><span class="p">.</span><span class="n">diagnostic</span><span class="p">);</span>
	<span class="n">res</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">ctrl</span> <span class="o">&amp;</span> <span class="n">MACEPAR_CTLSTAT_CTXA_VALID</span><span class="p">)</span> <span class="o">?</span>
		<span class="mi">1</span> <span class="o">+</span> <span class="p">((</span><span class="n">ctx_a</span> <span class="o">&amp;</span> <span class="n">MACEPAR_CONTEXT_DATALEN_MASK</span><span class="p">)</span> <span class="o">&gt;&gt;</span>
		     <span class="n">MACEPAR_CONTEXT_DATALEN_SHIFT</span><span class="p">)</span> <span class="o">:</span>
		<span class="mi">0</span><span class="p">;</span>
	<span class="n">res</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">ctrl</span> <span class="o">&amp;</span> <span class="n">MACEPAR_CTLSTAT_CTXB_VALID</span><span class="p">)</span> <span class="o">?</span>
		<span class="mi">1</span> <span class="o">+</span> <span class="p">((</span><span class="n">ctx_b</span> <span class="o">&amp;</span> <span class="n">MACEPAR_CONTEXT_DATALEN_MASK</span><span class="p">)</span> <span class="o">&gt;&gt;</span>
		     <span class="n">MACEPAR_CONTEXT_DATALEN_SHIFT</span><span class="p">)</span> <span class="o">:</span>
		<span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">diag</span> <span class="o">&amp;</span> <span class="n">MACEPAR_DIAG_DMACTIVE</span><span class="p">)</span>
		<span class="n">res</span><span class="p">[(</span><span class="n">diag</span> <span class="o">&amp;</span> <span class="n">MACEPAR_DIAG_CTXINUSE</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span>
			<span class="mi">1</span> <span class="o">+</span> <span class="p">((</span><span class="n">diag</span> <span class="o">&amp;</span> <span class="n">MACEPAR_DIAG_CTRMASK</span><span class="p">)</span> <span class="o">&gt;&gt;</span>
			     <span class="n">MACEPAR_DIAG_CTRSHIFT</span><span class="p">);</span>
	<span class="n">parport_ip32_dma</span><span class="p">.</span><span class="n">left</span> <span class="o">+=</span> <span class="n">res</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">res</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>

	<span class="cm">/* Reset DMA controller, and re-enable IRQs */</span>
	<span class="n">ctrl</span> <span class="o">=</span> <span class="n">MACEPAR_CTLSTAT_RESET</span><span class="p">;</span>
	<span class="n">writeq</span><span class="p">(</span><span class="n">ctrl</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mace</span><span class="o">-&gt;</span><span class="n">perif</span><span class="p">.</span><span class="n">ctrl</span><span class="p">.</span><span class="n">parport</span><span class="p">.</span><span class="n">cntlstat</span><span class="p">);</span>
	<span class="n">pr_debug</span><span class="p">(</span><span class="n">PPIP32</span> <span class="s">&quot;IRQ on (stop)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">enable_irq</span><span class="p">(</span><span class="n">MACEISA_PAR_CTXA_IRQ</span><span class="p">);</span>
	<span class="n">enable_irq</span><span class="p">(</span><span class="n">MACEISA_PAR_CTXB_IRQ</span><span class="p">);</span>
	<span class="n">parport_ip32_dma</span><span class="p">.</span><span class="n">irq_on</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">dma_unmap_single</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">parport_ip32_dma</span><span class="p">.</span><span class="n">buf</span><span class="p">,</span> <span class="n">parport_ip32_dma</span><span class="p">.</span><span class="n">len</span><span class="p">,</span>
			 <span class="n">parport_ip32_dma</span><span class="p">.</span><span class="n">dir</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * parport_ip32_dma_get_residue - get residue from last DMA transfer</span>
<span class="cm"> *</span>
<span class="cm"> * Returns the number of bytes remaining from last DMA transfer.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">size_t</span> <span class="nf">parport_ip32_dma_get_residue</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">parport_ip32_dma</span><span class="p">.</span><span class="n">left</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * parport_ip32_dma_register - initialize DMA engine</span>
<span class="cm"> *</span>
<span class="cm"> * Returns zero for success.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">parport_ip32_dma_register</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">parport_ip32_dma</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">parport_ip32_dma</span><span class="p">.</span><span class="n">irq_on</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/* Reset DMA controller */</span>
	<span class="n">writeq</span><span class="p">(</span><span class="n">MACEPAR_CTLSTAT_RESET</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mace</span><span class="o">-&gt;</span><span class="n">perif</span><span class="p">.</span><span class="n">ctrl</span><span class="p">.</span><span class="n">parport</span><span class="p">.</span><span class="n">cntlstat</span><span class="p">);</span>

	<span class="cm">/* Request IRQs */</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">request_irq</span><span class="p">(</span><span class="n">MACEISA_PAR_CTXA_IRQ</span><span class="p">,</span> <span class="n">parport_ip32_dma_interrupt</span><span class="p">,</span>
			  <span class="mi">0</span><span class="p">,</span> <span class="s">&quot;parport_ip32&quot;</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">fail_a</span><span class="p">;</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">request_irq</span><span class="p">(</span><span class="n">MACEISA_PAR_CTXB_IRQ</span><span class="p">,</span> <span class="n">parport_ip32_dma_interrupt</span><span class="p">,</span>
			  <span class="mi">0</span><span class="p">,</span> <span class="s">&quot;parport_ip32&quot;</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">fail_b</span><span class="p">;</span>
<span class="cp">#if DEBUG_PARPORT_IP32</span>
	<span class="cm">/* FIXME - what is this IRQ for? */</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">request_irq</span><span class="p">(</span><span class="n">MACEISA_PAR_MERR_IRQ</span><span class="p">,</span> <span class="n">parport_ip32_merr_interrupt</span><span class="p">,</span>
			  <span class="mi">0</span><span class="p">,</span> <span class="s">&quot;parport_ip32&quot;</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">fail_merr</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="cp">#if DEBUG_PARPORT_IP32</span>
<span class="nl">fail_merr:</span>
	<span class="n">free_irq</span><span class="p">(</span><span class="n">MACEISA_PAR_CTXB_IRQ</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="cp">#endif</span>
<span class="nl">fail_b:</span>
	<span class="n">free_irq</span><span class="p">(</span><span class="n">MACEISA_PAR_CTXA_IRQ</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="nl">fail_a:</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * parport_ip32_dma_unregister - release and free resources for DMA engine</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">parport_ip32_dma_unregister</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#if DEBUG_PARPORT_IP32</span>
	<span class="n">free_irq</span><span class="p">(</span><span class="n">MACEISA_PAR_MERR_IRQ</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="n">free_irq</span><span class="p">(</span><span class="n">MACEISA_PAR_CTXB_IRQ</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">free_irq</span><span class="p">(</span><span class="n">MACEISA_PAR_CTXA_IRQ</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*--- Interrupt handlers and associates --------------------------------*/</span>

<span class="cm">/**</span>
<span class="cm"> * parport_ip32_wakeup - wakes up code waiting for an interrupt</span>
<span class="cm"> * @p:		pointer to &amp;struct parport</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">parport_ip32_wakeup</span><span class="p">(</span><span class="k">struct</span> <span class="n">parport</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">parport_ip32_private</span> <span class="o">*</span> <span class="k">const</span> <span class="n">priv</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">physport</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="n">complete</span><span class="p">(</span><span class="o">&amp;</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">irq_complete</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * parport_ip32_interrupt - interrupt handler</span>
<span class="cm"> * @irq:	interrupt number</span>
<span class="cm"> * @dev_id:	pointer to &amp;struct parport</span>
<span class="cm"> *</span>
<span class="cm"> * Caught interrupts are forwarded to the upper parport layer if IRQ_mode is</span>
<span class="cm"> * %PARPORT_IP32_IRQ_FWD.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">irqreturn_t</span> <span class="nf">parport_ip32_interrupt</span><span class="p">(</span><span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">dev_id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">parport</span> <span class="o">*</span> <span class="k">const</span> <span class="n">p</span> <span class="o">=</span> <span class="n">dev_id</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">parport_ip32_private</span> <span class="o">*</span> <span class="k">const</span> <span class="n">priv</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">physport</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">parport_ip32_irq_mode</span> <span class="n">irq_mode</span> <span class="o">=</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">irq_mode</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">irq_mode</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">PARPORT_IP32_IRQ_FWD</span>:
		<span class="k">return</span> <span class="n">parport_irq_handler</span><span class="p">(</span><span class="n">irq</span><span class="p">,</span> <span class="n">dev_id</span><span class="p">);</span>

	<span class="k">case</span> <span class="n">PARPORT_IP32_IRQ_HERE</span>:
		<span class="n">parport_ip32_wakeup</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">IRQ_HANDLED</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*--- Some utility function to manipulate ECR register -----------------*/</span>

<span class="cm">/**</span>
<span class="cm"> * parport_ip32_read_econtrol - read contents of the ECR register</span>
<span class="cm"> * @p:		pointer to &amp;struct parport</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">parport_ip32_read_econtrol</span><span class="p">(</span><span class="k">struct</span> <span class="n">parport</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">parport_ip32_private</span> <span class="o">*</span> <span class="k">const</span> <span class="n">priv</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">physport</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">readb</span><span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">.</span><span class="n">ecr</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * parport_ip32_write_econtrol - write new contents to the ECR register</span>
<span class="cm"> * @p:		pointer to &amp;struct parport</span>
<span class="cm"> * @c:		new value to write</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">parport_ip32_write_econtrol</span><span class="p">(</span><span class="k">struct</span> <span class="n">parport</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span>
					       <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">c</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">parport_ip32_private</span> <span class="o">*</span> <span class="k">const</span> <span class="n">priv</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">physport</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="n">writeb</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">.</span><span class="n">ecr</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * parport_ip32_frob_econtrol - change bits from the ECR register</span>
<span class="cm"> * @p:		pointer to &amp;struct parport</span>
<span class="cm"> * @mask:	bit mask of bits to change</span>
<span class="cm"> * @val:	new value for changed bits</span>
<span class="cm"> *</span>
<span class="cm"> * Read from the ECR, mask out the bits in @mask, exclusive-or with the bits</span>
<span class="cm"> * in @val, and write the result to the ECR.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">parport_ip32_frob_econtrol</span><span class="p">(</span><span class="k">struct</span> <span class="n">parport</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span>
					      <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">mask</span><span class="p">,</span>
					      <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">c</span><span class="p">;</span>
	<span class="n">c</span> <span class="o">=</span> <span class="p">(</span><span class="n">parport_ip32_read_econtrol</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">mask</span><span class="p">)</span> <span class="o">^</span> <span class="n">val</span><span class="p">;</span>
	<span class="n">parport_ip32_write_econtrol</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">c</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * parport_ip32_set_mode - change mode of ECP port</span>
<span class="cm"> * @p:		pointer to &amp;struct parport</span>
<span class="cm"> * @mode:	new mode to write in ECR</span>
<span class="cm"> *</span>
<span class="cm"> * ECR is reset in a sane state (interrupts and DMA disabled), and placed in</span>
<span class="cm"> * mode @mode.  Go through PS2 mode if needed.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">parport_ip32_set_mode</span><span class="p">(</span><span class="k">struct</span> <span class="n">parport</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">mode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">omode</span><span class="p">;</span>

	<span class="n">mode</span> <span class="o">&amp;=</span> <span class="n">ECR_MODE_MASK</span><span class="p">;</span>
	<span class="n">omode</span> <span class="o">=</span> <span class="n">parport_ip32_read_econtrol</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">ECR_MODE_MASK</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">mode</span> <span class="o">==</span> <span class="n">ECR_MODE_SPP</span> <span class="o">||</span> <span class="n">mode</span> <span class="o">==</span> <span class="n">ECR_MODE_PS2</span>
	      <span class="o">||</span> <span class="n">omode</span> <span class="o">==</span> <span class="n">ECR_MODE_SPP</span> <span class="o">||</span> <span class="n">omode</span> <span class="o">==</span> <span class="n">ECR_MODE_PS2</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* We have to go through PS2 mode */</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ecr</span> <span class="o">=</span> <span class="n">ECR_MODE_PS2</span> <span class="o">|</span> <span class="n">ECR_nERRINTR</span> <span class="o">|</span> <span class="n">ECR_SERVINTR</span><span class="p">;</span>
		<span class="n">parport_ip32_write_econtrol</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">ecr</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">parport_ip32_write_econtrol</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">mode</span> <span class="o">|</span> <span class="n">ECR_nERRINTR</span> <span class="o">|</span> <span class="n">ECR_SERVINTR</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*--- Basic functions needed for parport -------------------------------*/</span>

<span class="cm">/**</span>
<span class="cm"> * parport_ip32_read_data - return current contents of the DATA register</span>
<span class="cm"> * @p:		pointer to &amp;struct parport</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="nf">parport_ip32_read_data</span><span class="p">(</span><span class="k">struct</span> <span class="n">parport</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">parport_ip32_private</span> <span class="o">*</span> <span class="k">const</span> <span class="n">priv</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">physport</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">readb</span><span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">.</span><span class="n">data</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * parport_ip32_write_data - set new contents for the DATA register</span>
<span class="cm"> * @p:		pointer to &amp;struct parport</span>
<span class="cm"> * @d:		new value to write</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">parport_ip32_write_data</span><span class="p">(</span><span class="k">struct</span> <span class="n">parport</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">d</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">parport_ip32_private</span> <span class="o">*</span> <span class="k">const</span> <span class="n">priv</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">physport</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="n">writeb</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">.</span><span class="n">data</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * parport_ip32_read_status - return current contents of the DSR register</span>
<span class="cm"> * @p:		pointer to &amp;struct parport</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="nf">parport_ip32_read_status</span><span class="p">(</span><span class="k">struct</span> <span class="n">parport</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">parport_ip32_private</span> <span class="o">*</span> <span class="k">const</span> <span class="n">priv</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">physport</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">readb</span><span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">.</span><span class="n">dsr</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * __parport_ip32_read_control - return cached contents of the DCR register</span>
<span class="cm"> * @p:		pointer to &amp;struct parport</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">__parport_ip32_read_control</span><span class="p">(</span><span class="k">struct</span> <span class="n">parport</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">parport_ip32_private</span> <span class="o">*</span> <span class="k">const</span> <span class="n">priv</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">physport</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">dcr_cache</span><span class="p">;</span> <span class="cm">/* use soft copy */</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * __parport_ip32_write_control - set new contents for the DCR register</span>
<span class="cm"> * @p:		pointer to &amp;struct parport</span>
<span class="cm"> * @c:		new value to write</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">__parport_ip32_write_control</span><span class="p">(</span><span class="k">struct</span> <span class="n">parport</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span>
						<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">c</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">parport_ip32_private</span> <span class="o">*</span> <span class="k">const</span> <span class="n">priv</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">physport</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="n">CHECK_EXTRA_BITS</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">dcr_writable</span><span class="p">);</span>
	<span class="n">c</span> <span class="o">&amp;=</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">dcr_writable</span><span class="p">;</span> <span class="cm">/* only writable bits */</span>
	<span class="n">writeb</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">.</span><span class="n">dcr</span><span class="p">);</span>
	<span class="n">priv</span><span class="o">-&gt;</span><span class="n">dcr_cache</span> <span class="o">=</span> <span class="n">c</span><span class="p">;</span>		<span class="cm">/* update soft copy */</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * __parport_ip32_frob_control - change bits from the DCR register</span>
<span class="cm"> * @p:		pointer to &amp;struct parport</span>
<span class="cm"> * @mask:	bit mask of bits to change</span>
<span class="cm"> * @val:	new value for changed bits</span>
<span class="cm"> *</span>
<span class="cm"> * This is equivalent to read from the DCR, mask out the bits in @mask,</span>
<span class="cm"> * exclusive-or with the bits in @val, and write the result to the DCR.</span>
<span class="cm"> * Actually, the cached contents of the DCR is used.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">__parport_ip32_frob_control</span><span class="p">(</span><span class="k">struct</span> <span class="n">parport</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span>
					       <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">mask</span><span class="p">,</span>
					       <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">c</span><span class="p">;</span>
	<span class="n">c</span> <span class="o">=</span> <span class="p">(</span><span class="n">__parport_ip32_read_control</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">mask</span><span class="p">)</span> <span class="o">^</span> <span class="n">val</span><span class="p">;</span>
	<span class="n">__parport_ip32_write_control</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">c</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * parport_ip32_read_control - return cached contents of the DCR register</span>
<span class="cm"> * @p:		pointer to &amp;struct parport</span>
<span class="cm"> *</span>
<span class="cm"> * The return value is masked so as to only return the value of %DCR_STROBE,</span>
<span class="cm"> * %DCR_AUTOFD, %DCR_nINIT, and %DCR_SELECT.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="nf">parport_ip32_read_control</span><span class="p">(</span><span class="k">struct</span> <span class="n">parport</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">rm</span> <span class="o">=</span>
		<span class="n">DCR_STROBE</span> <span class="o">|</span> <span class="n">DCR_AUTOFD</span> <span class="o">|</span> <span class="n">DCR_nINIT</span> <span class="o">|</span> <span class="n">DCR_SELECT</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">__parport_ip32_read_control</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">rm</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * parport_ip32_write_control - set new contents for the DCR register</span>
<span class="cm"> * @p:		pointer to &amp;struct parport</span>
<span class="cm"> * @c:		new value to write</span>
<span class="cm"> *</span>
<span class="cm"> * The value is masked so as to only change the value of %DCR_STROBE,</span>
<span class="cm"> * %DCR_AUTOFD, %DCR_nINIT, and %DCR_SELECT.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">parport_ip32_write_control</span><span class="p">(</span><span class="k">struct</span> <span class="n">parport</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span>
					      <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">c</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">wm</span> <span class="o">=</span>
		<span class="n">DCR_STROBE</span> <span class="o">|</span> <span class="n">DCR_AUTOFD</span> <span class="o">|</span> <span class="n">DCR_nINIT</span> <span class="o">|</span> <span class="n">DCR_SELECT</span><span class="p">;</span>
	<span class="n">CHECK_EXTRA_BITS</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">wm</span><span class="p">);</span>
	<span class="n">__parport_ip32_frob_control</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">wm</span><span class="p">,</span> <span class="n">c</span> <span class="o">&amp;</span> <span class="n">wm</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * parport_ip32_frob_control - change bits from the DCR register</span>
<span class="cm"> * @p:		pointer to &amp;struct parport</span>
<span class="cm"> * @mask:	bit mask of bits to change</span>
<span class="cm"> * @val:	new value for changed bits</span>
<span class="cm"> *</span>
<span class="cm"> * This differs from __parport_ip32_frob_control() in that it only allows to</span>
<span class="cm"> * change the value of %DCR_STROBE, %DCR_AUTOFD, %DCR_nINIT, and %DCR_SELECT.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="nf">parport_ip32_frob_control</span><span class="p">(</span><span class="k">struct</span> <span class="n">parport</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span>
						      <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">mask</span><span class="p">,</span>
						      <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">wm</span> <span class="o">=</span>
		<span class="n">DCR_STROBE</span> <span class="o">|</span> <span class="n">DCR_AUTOFD</span> <span class="o">|</span> <span class="n">DCR_nINIT</span> <span class="o">|</span> <span class="n">DCR_SELECT</span><span class="p">;</span>
	<span class="n">CHECK_EXTRA_BITS</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="n">wm</span><span class="p">);</span>
	<span class="n">CHECK_EXTRA_BITS</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">wm</span><span class="p">);</span>
	<span class="n">__parport_ip32_frob_control</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">mask</span> <span class="o">&amp;</span> <span class="n">wm</span><span class="p">,</span> <span class="n">val</span> <span class="o">&amp;</span> <span class="n">wm</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">parport_ip32_read_control</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * parport_ip32_disable_irq - disable interrupts on the rising edge of nACK</span>
<span class="cm"> * @p:		pointer to &amp;struct parport</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">parport_ip32_disable_irq</span><span class="p">(</span><span class="k">struct</span> <span class="n">parport</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__parport_ip32_frob_control</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">DCR_IRQ</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * parport_ip32_enable_irq - enable interrupts on the rising edge of nACK</span>
<span class="cm"> * @p:		pointer to &amp;struct parport</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">parport_ip32_enable_irq</span><span class="p">(</span><span class="k">struct</span> <span class="n">parport</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__parport_ip32_frob_control</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">DCR_IRQ</span><span class="p">,</span> <span class="n">DCR_IRQ</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * parport_ip32_data_forward - enable host-to-peripheral communications</span>
<span class="cm"> * @p:		pointer to &amp;struct parport</span>
<span class="cm"> *</span>
<span class="cm"> * Enable the data line drivers, for 8-bit host-to-peripheral communications.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">parport_ip32_data_forward</span><span class="p">(</span><span class="k">struct</span> <span class="n">parport</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__parport_ip32_frob_control</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">DCR_DIR</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * parport_ip32_data_reverse - enable peripheral-to-host communications</span>
<span class="cm"> * @p:		pointer to &amp;struct parport</span>
<span class="cm"> *</span>
<span class="cm"> * Place the data bus in a high impedance state, if @p-&gt;modes has the</span>
<span class="cm"> * PARPORT_MODE_TRISTATE bit set.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">parport_ip32_data_reverse</span><span class="p">(</span><span class="k">struct</span> <span class="n">parport</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__parport_ip32_frob_control</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">DCR_DIR</span><span class="p">,</span> <span class="n">DCR_DIR</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * parport_ip32_init_state - for core parport code</span>
<span class="cm"> * @dev:	pointer to &amp;struct pardevice</span>
<span class="cm"> * @s:		pointer to &amp;struct parport_state to initialize</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">parport_ip32_init_state</span><span class="p">(</span><span class="k">struct</span> <span class="n">pardevice</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">parport_state</span> <span class="o">*</span><span class="n">s</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">s</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">ip32</span><span class="p">.</span><span class="n">dcr</span> <span class="o">=</span> <span class="n">DCR_SELECT</span> <span class="o">|</span> <span class="n">DCR_nINIT</span><span class="p">;</span>
	<span class="n">s</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">ip32</span><span class="p">.</span><span class="n">ecr</span> <span class="o">=</span> <span class="n">ECR_MODE_PS2</span> <span class="o">|</span> <span class="n">ECR_nERRINTR</span> <span class="o">|</span> <span class="n">ECR_SERVINTR</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * parport_ip32_save_state - for core parport code</span>
<span class="cm"> * @p:		pointer to &amp;struct parport</span>
<span class="cm"> * @s:		pointer to &amp;struct parport_state to save state to</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">parport_ip32_save_state</span><span class="p">(</span><span class="k">struct</span> <span class="n">parport</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">parport_state</span> <span class="o">*</span><span class="n">s</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">s</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">ip32</span><span class="p">.</span><span class="n">dcr</span> <span class="o">=</span> <span class="n">__parport_ip32_read_control</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
	<span class="n">s</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">ip32</span><span class="p">.</span><span class="n">ecr</span> <span class="o">=</span> <span class="n">parport_ip32_read_econtrol</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * parport_ip32_restore_state - for core parport code</span>
<span class="cm"> * @p:		pointer to &amp;struct parport</span>
<span class="cm"> * @s:		pointer to &amp;struct parport_state to restore state from</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">parport_ip32_restore_state</span><span class="p">(</span><span class="k">struct</span> <span class="n">parport</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span>
				       <span class="k">struct</span> <span class="n">parport_state</span> <span class="o">*</span><span class="n">s</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">parport_ip32_set_mode</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">ip32</span><span class="p">.</span><span class="n">ecr</span> <span class="o">&amp;</span> <span class="n">ECR_MODE_MASK</span><span class="p">);</span>
	<span class="n">parport_ip32_write_econtrol</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">ip32</span><span class="p">.</span><span class="n">ecr</span><span class="p">);</span>
	<span class="n">__parport_ip32_write_control</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">ip32</span><span class="p">.</span><span class="n">dcr</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*--- EPP mode functions -----------------------------------------------*/</span>

<span class="cm">/**</span>
<span class="cm"> * parport_ip32_clear_epp_timeout - clear Timeout bit in EPP mode</span>
<span class="cm"> * @p:		pointer to &amp;struct parport</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 1 if the Timeout bit is clear, and 0 otherwise.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">parport_ip32_clear_epp_timeout</span><span class="p">(</span><span class="k">struct</span> <span class="n">parport</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">parport_ip32_private</span> <span class="o">*</span> <span class="k">const</span> <span class="n">priv</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">physport</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cleared</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">parport_ip32_read_status</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">DSR_TIMEOUT</span><span class="p">))</span>
		<span class="n">cleared</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">r</span><span class="p">;</span>
		<span class="cm">/* To clear timeout some chips require double read */</span>
		<span class="n">parport_ip32_read_status</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
		<span class="n">r</span> <span class="o">=</span> <span class="n">parport_ip32_read_status</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
		<span class="cm">/* Some reset by writing 1 */</span>
		<span class="n">writeb</span><span class="p">(</span><span class="n">r</span> <span class="o">|</span> <span class="n">DSR_TIMEOUT</span><span class="p">,</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">.</span><span class="n">dsr</span><span class="p">);</span>
		<span class="cm">/* Others by writing 0 */</span>
		<span class="n">writeb</span><span class="p">(</span><span class="n">r</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">DSR_TIMEOUT</span><span class="p">,</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">.</span><span class="n">dsr</span><span class="p">);</span>

		<span class="n">r</span> <span class="o">=</span> <span class="n">parport_ip32_read_status</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
		<span class="n">cleared</span> <span class="o">=</span> <span class="o">!</span><span class="p">(</span><span class="n">r</span> <span class="o">&amp;</span> <span class="n">DSR_TIMEOUT</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">pr_trace</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="s">&quot;(): %s&quot;</span><span class="p">,</span> <span class="n">cleared</span> <span class="o">?</span> <span class="s">&quot;cleared&quot;</span> <span class="o">:</span> <span class="s">&quot;failed&quot;</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">cleared</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * parport_ip32_epp_read - generic EPP read function</span>
<span class="cm"> * @eppreg:	I/O register to read from</span>
<span class="cm"> * @p:		pointer to &amp;struct parport</span>
<span class="cm"> * @buf:	buffer to store read data</span>
<span class="cm"> * @len:	length of buffer @buf</span>
<span class="cm"> * @flags:	may be PARPORT_EPP_FAST</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">size_t</span> <span class="nf">parport_ip32_epp_read</span><span class="p">(</span><span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">eppreg</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">parport</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span>
				    <span class="kt">size_t</span> <span class="n">len</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">parport_ip32_private</span> <span class="o">*</span> <span class="k">const</span> <span class="n">priv</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">physport</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">got</span><span class="p">;</span>
	<span class="n">parport_ip32_set_mode</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">ECR_MODE_EPP</span><span class="p">);</span>
	<span class="n">parport_ip32_data_reverse</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
	<span class="n">parport_ip32_write_control</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">DCR_nINIT</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">PARPORT_EPP_FAST</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">len</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">readsb</span><span class="p">(</span><span class="n">eppreg</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">readb</span><span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">.</span><span class="n">dsr</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">DSR_TIMEOUT</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">parport_ip32_clear_epp_timeout</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">got</span> <span class="o">=</span> <span class="n">len</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">u8</span> <span class="o">*</span><span class="n">bufp</span> <span class="o">=</span> <span class="n">buf</span><span class="p">;</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">got</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">got</span> <span class="o">&lt;</span> <span class="n">len</span><span class="p">;</span> <span class="n">got</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="o">*</span><span class="n">bufp</span><span class="o">++</span> <span class="o">=</span> <span class="n">readb</span><span class="p">(</span><span class="n">eppreg</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">readb</span><span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">.</span><span class="n">dsr</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">DSR_TIMEOUT</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">parport_ip32_clear_epp_timeout</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">parport_ip32_data_forward</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
	<span class="n">parport_ip32_set_mode</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">ECR_MODE_PS2</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">got</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * parport_ip32_epp_write - generic EPP write function</span>
<span class="cm"> * @eppreg:	I/O register to write to</span>
<span class="cm"> * @p:		pointer to &amp;struct parport</span>
<span class="cm"> * @buf:	buffer of data to write</span>
<span class="cm"> * @len:	length of buffer @buf</span>
<span class="cm"> * @flags:	may be PARPORT_EPP_FAST</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">size_t</span> <span class="nf">parport_ip32_epp_write</span><span class="p">(</span><span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">eppreg</span><span class="p">,</span>
				     <span class="k">struct</span> <span class="n">parport</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span>
				     <span class="kt">size_t</span> <span class="n">len</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">parport_ip32_private</span> <span class="o">*</span> <span class="k">const</span> <span class="n">priv</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">physport</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">written</span><span class="p">;</span>
	<span class="n">parport_ip32_set_mode</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">ECR_MODE_EPP</span><span class="p">);</span>
	<span class="n">parport_ip32_data_forward</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
	<span class="n">parport_ip32_write_control</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">DCR_nINIT</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">PARPORT_EPP_FAST</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">len</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">writesb</span><span class="p">(</span><span class="n">eppreg</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">readb</span><span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">.</span><span class="n">dsr</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">DSR_TIMEOUT</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">parport_ip32_clear_epp_timeout</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">written</span> <span class="o">=</span> <span class="n">len</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">const</span> <span class="n">u8</span> <span class="o">*</span><span class="n">bufp</span> <span class="o">=</span> <span class="n">buf</span><span class="p">;</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">written</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">written</span> <span class="o">&lt;</span> <span class="n">len</span><span class="p">;</span> <span class="n">written</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">writeb</span><span class="p">(</span><span class="o">*</span><span class="n">bufp</span><span class="o">++</span><span class="p">,</span> <span class="n">eppreg</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">readb</span><span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">.</span><span class="n">dsr</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">DSR_TIMEOUT</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">parport_ip32_clear_epp_timeout</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">parport_ip32_set_mode</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">ECR_MODE_PS2</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">written</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * parport_ip32_epp_read_data - read a block of data in EPP mode</span>
<span class="cm"> * @p:		pointer to &amp;struct parport</span>
<span class="cm"> * @buf:	buffer to store read data</span>
<span class="cm"> * @len:	length of buffer @buf</span>
<span class="cm"> * @flags:	may be PARPORT_EPP_FAST</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">size_t</span> <span class="nf">parport_ip32_epp_read_data</span><span class="p">(</span><span class="k">struct</span> <span class="n">parport</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span>
					 <span class="kt">size_t</span> <span class="n">len</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">parport_ip32_private</span> <span class="o">*</span> <span class="k">const</span> <span class="n">priv</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">physport</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">parport_ip32_epp_read</span><span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">.</span><span class="n">eppData0</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * parport_ip32_epp_write_data - write a block of data in EPP mode</span>
<span class="cm"> * @p:		pointer to &amp;struct parport</span>
<span class="cm"> * @buf:	buffer of data to write</span>
<span class="cm"> * @len:	length of buffer @buf</span>
<span class="cm"> * @flags:	may be PARPORT_EPP_FAST</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">size_t</span> <span class="nf">parport_ip32_epp_write_data</span><span class="p">(</span><span class="k">struct</span> <span class="n">parport</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span>
					  <span class="kt">size_t</span> <span class="n">len</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">parport_ip32_private</span> <span class="o">*</span> <span class="k">const</span> <span class="n">priv</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">physport</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">parport_ip32_epp_write</span><span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">.</span><span class="n">eppData0</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * parport_ip32_epp_read_addr - read a block of addresses in EPP mode</span>
<span class="cm"> * @p:		pointer to &amp;struct parport</span>
<span class="cm"> * @buf:	buffer to store read data</span>
<span class="cm"> * @len:	length of buffer @buf</span>
<span class="cm"> * @flags:	may be PARPORT_EPP_FAST</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">size_t</span> <span class="nf">parport_ip32_epp_read_addr</span><span class="p">(</span><span class="k">struct</span> <span class="n">parport</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span>
					 <span class="kt">size_t</span> <span class="n">len</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">parport_ip32_private</span> <span class="o">*</span> <span class="k">const</span> <span class="n">priv</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">physport</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">parport_ip32_epp_read</span><span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">.</span><span class="n">eppAddr</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * parport_ip32_epp_write_addr - write a block of addresses in EPP mode</span>
<span class="cm"> * @p:		pointer to &amp;struct parport</span>
<span class="cm"> * @buf:	buffer of data to write</span>
<span class="cm"> * @len:	length of buffer @buf</span>
<span class="cm"> * @flags:	may be PARPORT_EPP_FAST</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">size_t</span> <span class="nf">parport_ip32_epp_write_addr</span><span class="p">(</span><span class="k">struct</span> <span class="n">parport</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span>
					  <span class="kt">size_t</span> <span class="n">len</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">parport_ip32_private</span> <span class="o">*</span> <span class="k">const</span> <span class="n">priv</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">physport</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">parport_ip32_epp_write</span><span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">.</span><span class="n">eppAddr</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*--- ECP mode functions (FIFO) ----------------------------------------*/</span>

<span class="cm">/**</span>
<span class="cm"> * parport_ip32_fifo_wait_break - check if the waiting function should return</span>
<span class="cm"> * @p:		pointer to &amp;struct parport</span>
<span class="cm"> * @expire:	timeout expiring date, in jiffies</span>
<span class="cm"> *</span>
<span class="cm"> * parport_ip32_fifo_wait_break() checks if the waiting function should return</span>
<span class="cm"> * immediately or not.  The break conditions are:</span>
<span class="cm"> *	- expired timeout;</span>
<span class="cm"> *	- a pending signal;</span>
<span class="cm"> *	- nFault asserted low.</span>
<span class="cm"> * This function also calls cond_resched().</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">parport_ip32_fifo_wait_break</span><span class="p">(</span><span class="k">struct</span> <span class="n">parport</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span>
						 <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">expire</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">cond_resched</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">time_after</span><span class="p">(</span><span class="n">jiffies</span><span class="p">,</span> <span class="n">expire</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">pr_debug1</span><span class="p">(</span><span class="n">PPIP32</span> <span class="s">&quot;%s: FIFO write timed out</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">signal_pending</span><span class="p">(</span><span class="n">current</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">pr_debug1</span><span class="p">(</span><span class="n">PPIP32</span> <span class="s">&quot;%s: Signal pending</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">parport_ip32_read_status</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">DSR_nFAULT</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">pr_debug1</span><span class="p">(</span><span class="n">PPIP32</span> <span class="s">&quot;%s: nFault asserted low</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * parport_ip32_fwp_wait_polling - wait for FIFO to empty (polling)</span>
<span class="cm"> * @p:		pointer to &amp;struct parport</span>
<span class="cm"> *</span>
<span class="cm"> * Returns the number of bytes that can safely be written in the FIFO.  A</span>
<span class="cm"> * return value of zero means that the calling function should terminate as</span>
<span class="cm"> * fast as possible.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">parport_ip32_fwp_wait_polling</span><span class="p">(</span><span class="k">struct</span> <span class="n">parport</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">parport_ip32_private</span> <span class="o">*</span> <span class="k">const</span> <span class="n">priv</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">physport</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">parport</span> <span class="o">*</span> <span class="k">const</span> <span class="n">physport</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">physport</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">expire</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">count</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ecr</span><span class="p">;</span>

	<span class="n">expire</span> <span class="o">=</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="n">physport</span><span class="o">-&gt;</span><span class="n">cad</span><span class="o">-&gt;</span><span class="n">timeout</span><span class="p">;</span>
	<span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">parport_ip32_fifo_wait_break</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">expire</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="cm">/* Check FIFO state.  We do nothing when the FIFO is nor full,</span>
<span class="cm">		 * nor empty.  It appears that the FIFO full bit is not always</span>
<span class="cm">		 * reliable, the FIFO state is sometimes wrongly reported, and</span>
<span class="cm">		 * the chip gets confused if we give it another byte. */</span>
		<span class="n">ecr</span> <span class="o">=</span> <span class="n">parport_ip32_read_econtrol</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ecr</span> <span class="o">&amp;</span> <span class="n">ECR_F_EMPTY</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* FIFO is empty, fill it up */</span>
			<span class="n">count</span> <span class="o">=</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">fifo_depth</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* Wait a moment... */</span>
		<span class="n">udelay</span><span class="p">(</span><span class="n">FIFO_POLLING_INTERVAL</span><span class="p">);</span>
	<span class="p">}</span> <span class="cm">/* while (1) */</span>

	<span class="k">return</span> <span class="n">count</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * parport_ip32_fwp_wait_interrupt - wait for FIFO to empty (interrupt-driven)</span>
<span class="cm"> * @p:		pointer to &amp;struct parport</span>
<span class="cm"> *</span>
<span class="cm"> * Returns the number of bytes that can safely be written in the FIFO.  A</span>
<span class="cm"> * return value of zero means that the calling function should terminate as</span>
<span class="cm"> * fast as possible.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">parport_ip32_fwp_wait_interrupt</span><span class="p">(</span><span class="k">struct</span> <span class="n">parport</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">lost_interrupt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">parport_ip32_private</span> <span class="o">*</span> <span class="k">const</span> <span class="n">priv</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">physport</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">parport</span> <span class="o">*</span> <span class="k">const</span> <span class="n">physport</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">physport</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">nfault_timeout</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">expire</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">count</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ecr</span><span class="p">;</span>

	<span class="n">nfault_timeout</span> <span class="o">=</span> <span class="n">min</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">physport</span><span class="o">-&gt;</span><span class="n">cad</span><span class="o">-&gt;</span><span class="n">timeout</span><span class="p">,</span>
			     <span class="n">msecs_to_jiffies</span><span class="p">(</span><span class="n">FIFO_NFAULT_TIMEOUT</span><span class="p">));</span>
	<span class="n">expire</span> <span class="o">=</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="n">physport</span><span class="o">-&gt;</span><span class="n">cad</span><span class="o">-&gt;</span><span class="n">timeout</span><span class="p">;</span>
	<span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">parport_ip32_fifo_wait_break</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">expire</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="cm">/* Initialize mutex used to take interrupts into account */</span>
		<span class="n">INIT_COMPLETION</span><span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">irq_complete</span><span class="p">);</span>

		<span class="cm">/* Enable serviceIntr */</span>
		<span class="n">parport_ip32_frob_econtrol</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">ECR_SERVINTR</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

		<span class="cm">/* Enabling serviceIntr while the FIFO is empty does not</span>
<span class="cm">		 * always generate an interrupt, so check for emptiness</span>
<span class="cm">		 * now. */</span>
		<span class="n">ecr</span> <span class="o">=</span> <span class="n">parport_ip32_read_econtrol</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">ecr</span> <span class="o">&amp;</span> <span class="n">ECR_F_EMPTY</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/* FIFO is not empty: wait for an interrupt or a</span>
<span class="cm">			 * timeout to occur */</span>
			<span class="n">wait_for_completion_interruptible_timeout</span><span class="p">(</span>
				<span class="o">&amp;</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">irq_complete</span><span class="p">,</span> <span class="n">nfault_timeout</span><span class="p">);</span>
			<span class="n">ecr</span> <span class="o">=</span> <span class="n">parport_ip32_read_econtrol</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">ecr</span> <span class="o">&amp;</span> <span class="n">ECR_F_EMPTY</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">ecr</span> <span class="o">&amp;</span> <span class="n">ECR_SERVINTR</span><span class="p">)</span>
			    <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">lost_interrupt</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="n">PPIP32</span>
				       <span class="s">&quot;%s: lost interrupt in %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				       <span class="n">p</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
				<span class="n">lost_interrupt</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="cm">/* Disable serviceIntr */</span>
		<span class="n">parport_ip32_frob_econtrol</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">ECR_SERVINTR</span><span class="p">,</span> <span class="n">ECR_SERVINTR</span><span class="p">);</span>

		<span class="cm">/* Check FIFO state */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ecr</span> <span class="o">&amp;</span> <span class="n">ECR_F_EMPTY</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* FIFO is empty, fill it up */</span>
			<span class="n">count</span> <span class="o">=</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">fifo_depth</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">ecr</span> <span class="o">&amp;</span> <span class="n">ECR_SERVINTR</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* FIFO is not empty, but we know that can safely push</span>
<span class="cm">			 * writeIntrThreshold bytes into it */</span>
			<span class="n">count</span> <span class="o">=</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">writeIntrThreshold</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/* FIFO is not empty, and we did not get any interrupt.</span>
<span class="cm">		 * Either it&#39;s time to check for nFault, or a signal is</span>
<span class="cm">		 * pending.  This is verified in</span>
<span class="cm">		 * parport_ip32_fifo_wait_break(), so we continue the loop. */</span>
	<span class="p">}</span> <span class="cm">/* while (1) */</span>

	<span class="k">return</span> <span class="n">count</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * parport_ip32_fifo_write_block_pio - write a block of data (PIO mode)</span>
<span class="cm"> * @p:		pointer to &amp;struct parport</span>
<span class="cm"> * @buf:	buffer of data to write</span>
<span class="cm"> * @len:	length of buffer @buf</span>
<span class="cm"> *</span>
<span class="cm"> * Uses PIO to write the contents of the buffer @buf into the parallel port</span>
<span class="cm"> * FIFO.  Returns the number of bytes that were actually written.  It can work</span>
<span class="cm"> * with or without the help of interrupts.  The parallel port must be</span>
<span class="cm"> * correctly initialized before calling parport_ip32_fifo_write_block_pio().</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">size_t</span> <span class="nf">parport_ip32_fifo_write_block_pio</span><span class="p">(</span><span class="k">struct</span> <span class="n">parport</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span>
						<span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">parport_ip32_private</span> <span class="o">*</span> <span class="k">const</span> <span class="n">priv</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">physport</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="k">const</span> <span class="n">u8</span> <span class="o">*</span><span class="n">bufp</span> <span class="o">=</span> <span class="n">buf</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">left</span> <span class="o">=</span> <span class="n">len</span><span class="p">;</span>

	<span class="n">priv</span><span class="o">-&gt;</span><span class="n">irq_mode</span> <span class="o">=</span> <span class="n">PARPORT_IP32_IRQ_HERE</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">left</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">count</span><span class="p">;</span>

		<span class="n">count</span> <span class="o">=</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">irq</span> <span class="o">==</span> <span class="n">PARPORT_IRQ_NONE</span><span class="p">)</span> <span class="o">?</span>
			<span class="n">parport_ip32_fwp_wait_polling</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="o">:</span>
			<span class="n">parport_ip32_fwp_wait_interrupt</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>	<span class="cm">/* Transmission should be stopped */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">&gt;</span> <span class="n">left</span><span class="p">)</span>
			<span class="n">count</span> <span class="o">=</span> <span class="n">left</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">writeb</span><span class="p">(</span><span class="o">*</span><span class="n">bufp</span><span class="p">,</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">.</span><span class="n">fifo</span><span class="p">);</span>
			<span class="n">bufp</span><span class="o">++</span><span class="p">,</span> <span class="n">left</span><span class="o">--</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">writesb</span><span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">.</span><span class="n">fifo</span><span class="p">,</span> <span class="n">bufp</span><span class="p">,</span> <span class="n">count</span><span class="p">);</span>
			<span class="n">bufp</span> <span class="o">+=</span> <span class="n">count</span><span class="p">,</span> <span class="n">left</span> <span class="o">-=</span> <span class="n">count</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">priv</span><span class="o">-&gt;</span><span class="n">irq_mode</span> <span class="o">=</span> <span class="n">PARPORT_IP32_IRQ_FWD</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">len</span> <span class="o">-</span> <span class="n">left</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * parport_ip32_fifo_write_block_dma - write a block of data (DMA mode)</span>
<span class="cm"> * @p:		pointer to &amp;struct parport</span>
<span class="cm"> * @buf:	buffer of data to write</span>
<span class="cm"> * @len:	length of buffer @buf</span>
<span class="cm"> *</span>
<span class="cm"> * Uses DMA to write the contents of the buffer @buf into the parallel port</span>
<span class="cm"> * FIFO.  Returns the number of bytes that were actually written.  The</span>
<span class="cm"> * parallel port must be correctly initialized before calling</span>
<span class="cm"> * parport_ip32_fifo_write_block_dma().</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">size_t</span> <span class="nf">parport_ip32_fifo_write_block_dma</span><span class="p">(</span><span class="k">struct</span> <span class="n">parport</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span>
						<span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">parport_ip32_private</span> <span class="o">*</span> <span class="k">const</span> <span class="n">priv</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">physport</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">parport</span> <span class="o">*</span> <span class="k">const</span> <span class="n">physport</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">physport</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">nfault_timeout</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">expire</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">written</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ecr</span><span class="p">;</span>

	<span class="n">priv</span><span class="o">-&gt;</span><span class="n">irq_mode</span> <span class="o">=</span> <span class="n">PARPORT_IP32_IRQ_HERE</span><span class="p">;</span>

	<span class="n">parport_ip32_dma_start</span><span class="p">(</span><span class="n">DMA_TO_DEVICE</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">buf</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
	<span class="n">INIT_COMPLETION</span><span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">irq_complete</span><span class="p">);</span>
	<span class="n">parport_ip32_frob_econtrol</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">ECR_DMAEN</span> <span class="o">|</span> <span class="n">ECR_SERVINTR</span><span class="p">,</span> <span class="n">ECR_DMAEN</span><span class="p">);</span>

	<span class="n">nfault_timeout</span> <span class="o">=</span> <span class="n">min</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">physport</span><span class="o">-&gt;</span><span class="n">cad</span><span class="o">-&gt;</span><span class="n">timeout</span><span class="p">,</span>
			     <span class="n">msecs_to_jiffies</span><span class="p">(</span><span class="n">FIFO_NFAULT_TIMEOUT</span><span class="p">));</span>
	<span class="n">expire</span> <span class="o">=</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="n">physport</span><span class="o">-&gt;</span><span class="n">cad</span><span class="o">-&gt;</span><span class="n">timeout</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">parport_ip32_fifo_wait_break</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">expire</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">wait_for_completion_interruptible_timeout</span><span class="p">(</span><span class="o">&amp;</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">irq_complete</span><span class="p">,</span>
							  <span class="n">nfault_timeout</span><span class="p">);</span>
		<span class="n">ecr</span> <span class="o">=</span> <span class="n">parport_ip32_read_econtrol</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ecr</span> <span class="o">&amp;</span> <span class="n">ECR_SERVINTR</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>	<span class="cm">/* DMA transfer just finished */</span>
	<span class="p">}</span>
	<span class="n">parport_ip32_dma_stop</span><span class="p">();</span>
	<span class="n">written</span> <span class="o">=</span> <span class="n">len</span> <span class="o">-</span> <span class="n">parport_ip32_dma_get_residue</span><span class="p">();</span>

	<span class="n">priv</span><span class="o">-&gt;</span><span class="n">irq_mode</span> <span class="o">=</span> <span class="n">PARPORT_IP32_IRQ_FWD</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">written</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * parport_ip32_fifo_write_block - write a block of data</span>
<span class="cm"> * @p:		pointer to &amp;struct parport</span>
<span class="cm"> * @buf:	buffer of data to write</span>
<span class="cm"> * @len:	length of buffer @buf</span>
<span class="cm"> *</span>
<span class="cm"> * Uses PIO or DMA to write the contents of the buffer @buf into the parallel</span>
<span class="cm"> * p FIFO.  Returns the number of bytes that were actually written.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">size_t</span> <span class="nf">parport_ip32_fifo_write_block</span><span class="p">(</span><span class="k">struct</span> <span class="n">parport</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span>
					    <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">size_t</span> <span class="n">written</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">len</span><span class="p">)</span>
		<span class="cm">/* FIXME - Maybe some threshold value should be set for @len</span>
<span class="cm">		 * under which we revert to PIO mode? */</span>
		<span class="n">written</span> <span class="o">=</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">modes</span> <span class="o">&amp;</span> <span class="n">PARPORT_MODE_DMA</span><span class="p">)</span> <span class="o">?</span>
			<span class="n">parport_ip32_fifo_write_block_dma</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">len</span><span class="p">)</span> <span class="o">:</span>
			<span class="n">parport_ip32_fifo_write_block_pio</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">written</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * parport_ip32_drain_fifo - wait for FIFO to empty</span>
<span class="cm"> * @p:		pointer to &amp;struct parport</span>
<span class="cm"> * @timeout:	timeout, in jiffies</span>
<span class="cm"> *</span>
<span class="cm"> * This function waits for FIFO to empty.  It returns 1 when FIFO is empty, or</span>
<span class="cm"> * 0 if the timeout @timeout is reached before, or if a signal is pending.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">parport_ip32_drain_fifo</span><span class="p">(</span><span class="k">struct</span> <span class="n">parport</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span>
					    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">timeout</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">expire</span> <span class="o">=</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="n">timeout</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">polling_interval</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">counter</span><span class="p">;</span>

	<span class="cm">/* Busy wait for approx. 200us */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">counter</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">counter</span> <span class="o">&lt;</span> <span class="mi">40</span><span class="p">;</span> <span class="n">counter</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">parport_ip32_read_econtrol</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">ECR_F_EMPTY</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">time_after</span><span class="p">(</span><span class="n">jiffies</span><span class="p">,</span> <span class="n">expire</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">signal_pending</span><span class="p">(</span><span class="n">current</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">udelay</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="cm">/* Poll slowly.  Polling interval starts with 1 millisecond, and is</span>
<span class="cm">	 * increased exponentially until 128.  */</span>
	<span class="n">polling_interval</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="cm">/* msecs */</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">parport_ip32_read_econtrol</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">ECR_F_EMPTY</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">time_after_eq</span><span class="p">(</span><span class="n">jiffies</span><span class="p">,</span> <span class="n">expire</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">msleep_interruptible</span><span class="p">(</span><span class="n">polling_interval</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">signal_pending</span><span class="p">(</span><span class="n">current</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">polling_interval</span> <span class="o">&lt;</span> <span class="mi">128</span><span class="p">)</span>
			<span class="n">polling_interval</span> <span class="o">*=</span> <span class="mi">2</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="o">!!</span><span class="p">(</span><span class="n">parport_ip32_read_econtrol</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">ECR_F_EMPTY</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * parport_ip32_get_fifo_residue - reset FIFO</span>
<span class="cm"> * @p:		pointer to &amp;struct parport</span>
<span class="cm"> * @mode:	current operation mode (ECR_MODE_PPF or ECR_MODE_ECP)</span>
<span class="cm"> *</span>
<span class="cm"> * This function resets FIFO, and returns the number of bytes remaining in it.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">parport_ip32_get_fifo_residue</span><span class="p">(</span><span class="k">struct</span> <span class="n">parport</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span>
						  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">mode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">parport_ip32_private</span> <span class="o">*</span> <span class="k">const</span> <span class="n">priv</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">physport</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">residue</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cnfga</span><span class="p">;</span>

	<span class="cm">/* FIXME - We are missing one byte if the printer is off-line.  I</span>
<span class="cm">	 * don&#39;t know how to detect this.  It looks that the full bit is not</span>
<span class="cm">	 * always reliable.  For the moment, the problem is avoided in most</span>
<span class="cm">	 * cases by testing for BUSY in parport_ip32_compat_write_data().</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">parport_ip32_read_econtrol</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">ECR_F_EMPTY</span><span class="p">)</span>
		<span class="n">residue</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="n">pr_debug1</span><span class="p">(</span><span class="n">PPIP32</span> <span class="s">&quot;%s: FIFO is stuck</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>

		<span class="cm">/* Stop all transfers.</span>
<span class="cm">		 *</span>
<span class="cm">		 * Microsoft&#39;s document instructs to drive DCR_STROBE to 0,</span>
<span class="cm">		 * but it doesn&#39;t work (at least in Compatibility mode, not</span>
<span class="cm">		 * tested in ECP mode).  Switching directly to Test mode (as</span>
<span class="cm">		 * in parport_pc) is not an option: it does confuse the port,</span>
<span class="cm">		 * ECP service interrupts are no more working after that.  A</span>
<span class="cm">		 * hard reset is then needed to revert to a sane state.</span>
<span class="cm">		 *</span>
<span class="cm">		 * Let&#39;s hope that the FIFO is really stuck and that the</span>
<span class="cm">		 * peripheral doesn&#39;t wake up now.</span>
<span class="cm">		 */</span>
		<span class="n">parport_ip32_frob_control</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">DCR_STROBE</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

		<span class="cm">/* Fill up FIFO */</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">residue</span> <span class="o">=</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">fifo_depth</span><span class="p">;</span> <span class="n">residue</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">;</span> <span class="n">residue</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">parport_ip32_read_econtrol</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">ECR_F_FULL</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="n">writeb</span><span class="p">(</span><span class="mh">0x00</span><span class="p">,</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">.</span><span class="n">fifo</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">residue</span><span class="p">)</span>
		<span class="n">pr_debug1</span><span class="p">(</span><span class="n">PPIP32</span> <span class="s">&quot;%s: %d PWord%s left in FIFO</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			  <span class="n">p</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">residue</span><span class="p">,</span>
			  <span class="p">(</span><span class="n">residue</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="o">?</span> <span class="s">&quot; was&quot;</span> <span class="o">:</span> <span class="s">&quot;s were&quot;</span><span class="p">);</span>

	<span class="cm">/* Now reset the FIFO */</span>
	<span class="n">parport_ip32_set_mode</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">ECR_MODE_PS2</span><span class="p">);</span>

	<span class="cm">/* Host recovery for ECP mode */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mode</span> <span class="o">==</span> <span class="n">ECR_MODE_ECP</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">parport_ip32_data_reverse</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
		<span class="n">parport_ip32_frob_control</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">DCR_nINIT</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">parport_wait_peripheral</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">DSR_PERROR</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
			<span class="n">pr_debug1</span><span class="p">(</span><span class="n">PPIP32</span> <span class="s">&quot;%s: PEerror timeout 1 in %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				  <span class="n">p</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
		<span class="n">parport_ip32_frob_control</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">DCR_STROBE</span><span class="p">,</span> <span class="n">DCR_STROBE</span><span class="p">);</span>
		<span class="n">parport_ip32_frob_control</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">DCR_nINIT</span><span class="p">,</span> <span class="n">DCR_nINIT</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">parport_wait_peripheral</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">DSR_PERROR</span><span class="p">,</span> <span class="n">DSR_PERROR</span><span class="p">))</span>
			<span class="n">pr_debug1</span><span class="p">(</span><span class="n">PPIP32</span> <span class="s">&quot;%s: PEerror timeout 2 in %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				  <span class="n">p</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Adjust residue if needed */</span>
	<span class="n">parport_ip32_set_mode</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">ECR_MODE_CFG</span><span class="p">);</span>
	<span class="n">cnfga</span> <span class="o">=</span> <span class="n">readb</span><span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">.</span><span class="n">cnfgA</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">cnfga</span> <span class="o">&amp;</span> <span class="n">CNFGA_nBYTEINTRANS</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">pr_debug1</span><span class="p">(</span><span class="n">PPIP32</span> <span class="s">&quot;%s: cnfgA contains 0x%02x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			  <span class="n">p</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">cnfga</span><span class="p">);</span>
		<span class="n">pr_debug1</span><span class="p">(</span><span class="n">PPIP32</span> <span class="s">&quot;%s: Accounting for extra byte</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			  <span class="n">p</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="n">residue</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Don&#39;t care about partial PWords since we do not support</span>
<span class="cm">	 * PWord != 1 byte. */</span>

	<span class="cm">/* Back to forward PS2 mode. */</span>
	<span class="n">parport_ip32_set_mode</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">ECR_MODE_PS2</span><span class="p">);</span>
	<span class="n">parport_ip32_data_forward</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">residue</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * parport_ip32_compat_write_data - write a block of data in SPP mode</span>
<span class="cm"> * @p:		pointer to &amp;struct parport</span>
<span class="cm"> * @buf:	buffer of data to write</span>
<span class="cm"> * @len:	length of buffer @buf</span>
<span class="cm"> * @flags:	ignored</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">size_t</span> <span class="nf">parport_ip32_compat_write_data</span><span class="p">(</span><span class="k">struct</span> <span class="n">parport</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span>
					     <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">len</span><span class="p">,</span>
					     <span class="kt">int</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ready_before</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">parport_ip32_private</span> <span class="o">*</span> <span class="k">const</span> <span class="n">priv</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">physport</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">parport</span> <span class="o">*</span> <span class="k">const</span> <span class="n">physport</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">physport</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">written</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Special case: a timeout of zero means we cannot call schedule().</span>
<span class="cm">	 * Also if O_NONBLOCK is set then use the default implementation. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">physport</span><span class="o">-&gt;</span><span class="n">cad</span><span class="o">-&gt;</span><span class="n">timeout</span> <span class="o">&lt;=</span> <span class="n">PARPORT_INACTIVITY_O_NONBLOCK</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">parport_ieee1284_write_compat</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="cm">/* Reset FIFO, go in forward mode, and disable ackIntEn */</span>
	<span class="n">parport_ip32_set_mode</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">ECR_MODE_PS2</span><span class="p">);</span>
	<span class="n">parport_ip32_write_control</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">DCR_SELECT</span> <span class="o">|</span> <span class="n">DCR_nINIT</span><span class="p">);</span>
	<span class="n">parport_ip32_data_forward</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
	<span class="n">parport_ip32_disable_irq</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
	<span class="n">parport_ip32_set_mode</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">ECR_MODE_PPF</span><span class="p">);</span>
	<span class="n">physport</span><span class="o">-&gt;</span><span class="n">ieee1284</span><span class="p">.</span><span class="n">phase</span> <span class="o">=</span> <span class="n">IEEE1284_PH_FWD_DATA</span><span class="p">;</span>

	<span class="cm">/* Wait for peripheral to become ready */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">parport_wait_peripheral</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">DSR_nBUSY</span> <span class="o">|</span> <span class="n">DSR_nFAULT</span><span class="p">,</span>
				       <span class="n">DSR_nBUSY</span> <span class="o">|</span> <span class="n">DSR_nFAULT</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* Avoid to flood the logs */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ready_before</span><span class="p">)</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="n">PPIP32</span> <span class="s">&quot;%s: not ready in %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">p</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
		<span class="n">ready_before</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">stop</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">ready_before</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">written</span> <span class="o">=</span> <span class="n">parport_ip32_fifo_write_block</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>

	<span class="cm">/* Wait FIFO to empty.  Timeout is proportional to FIFO_depth.  */</span>
	<span class="n">parport_ip32_drain_fifo</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">physport</span><span class="o">-&gt;</span><span class="n">cad</span><span class="o">-&gt;</span><span class="n">timeout</span> <span class="o">*</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">fifo_depth</span><span class="p">);</span>

	<span class="cm">/* Check for a potential residue */</span>
	<span class="n">written</span> <span class="o">-=</span> <span class="n">parport_ip32_get_fifo_residue</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">ECR_MODE_PPF</span><span class="p">);</span>

	<span class="cm">/* Then, wait for BUSY to get low. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">parport_wait_peripheral</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">DSR_nBUSY</span><span class="p">,</span> <span class="n">DSR_nBUSY</span><span class="p">))</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="n">PPIP32</span> <span class="s">&quot;%s: BUSY timeout in %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">p</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>

<span class="nl">stop:</span>
	<span class="cm">/* Reset FIFO */</span>
	<span class="n">parport_ip32_set_mode</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">ECR_MODE_PS2</span><span class="p">);</span>
	<span class="n">physport</span><span class="o">-&gt;</span><span class="n">ieee1284</span><span class="p">.</span><span class="n">phase</span> <span class="o">=</span> <span class="n">IEEE1284_PH_FWD_IDLE</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">written</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * FIXME - Insert here parport_ip32_ecp_read_data().</span>
<span class="cm"> */</span>

<span class="cm">/**</span>
<span class="cm"> * parport_ip32_ecp_write_data - write a block of data in ECP mode</span>
<span class="cm"> * @p:		pointer to &amp;struct parport</span>
<span class="cm"> * @buf:	buffer of data to write</span>
<span class="cm"> * @len:	length of buffer @buf</span>
<span class="cm"> * @flags:	ignored</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">size_t</span> <span class="nf">parport_ip32_ecp_write_data</span><span class="p">(</span><span class="k">struct</span> <span class="n">parport</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span>
					  <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">len</span><span class="p">,</span>
					  <span class="kt">int</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ready_before</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">parport_ip32_private</span> <span class="o">*</span> <span class="k">const</span> <span class="n">priv</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">physport</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">parport</span> <span class="o">*</span> <span class="k">const</span> <span class="n">physport</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">physport</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">written</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Special case: a timeout of zero means we cannot call schedule().</span>
<span class="cm">	 * Also if O_NONBLOCK is set then use the default implementation. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">physport</span><span class="o">-&gt;</span><span class="n">cad</span><span class="o">-&gt;</span><span class="n">timeout</span> <span class="o">&lt;=</span> <span class="n">PARPORT_INACTIVITY_O_NONBLOCK</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">parport_ieee1284_ecp_write_data</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="cm">/* Negotiate to forward mode if necessary. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">physport</span><span class="o">-&gt;</span><span class="n">ieee1284</span><span class="p">.</span><span class="n">phase</span> <span class="o">!=</span> <span class="n">IEEE1284_PH_FWD_IDLE</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Event 47: Set nInit high. */</span>
		<span class="n">parport_ip32_frob_control</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">DCR_nINIT</span> <span class="o">|</span> <span class="n">DCR_AUTOFD</span><span class="p">,</span>
					     <span class="n">DCR_nINIT</span> <span class="o">|</span> <span class="n">DCR_AUTOFD</span><span class="p">);</span>

		<span class="cm">/* Event 49: PError goes high. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">parport_wait_peripheral</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">DSR_PERROR</span><span class="p">,</span> <span class="n">DSR_PERROR</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="n">PPIP32</span> <span class="s">&quot;%s: PError timeout in %s&quot;</span><span class="p">,</span>
			       <span class="n">p</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
			<span class="n">physport</span><span class="o">-&gt;</span><span class="n">ieee1284</span><span class="p">.</span><span class="n">phase</span> <span class="o">=</span> <span class="n">IEEE1284_PH_ECP_DIR_UNKNOWN</span><span class="p">;</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* Reset FIFO, go in forward mode, and disable ackIntEn */</span>
	<span class="n">parport_ip32_set_mode</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">ECR_MODE_PS2</span><span class="p">);</span>
	<span class="n">parport_ip32_write_control</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">DCR_SELECT</span> <span class="o">|</span> <span class="n">DCR_nINIT</span><span class="p">);</span>
	<span class="n">parport_ip32_data_forward</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
	<span class="n">parport_ip32_disable_irq</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
	<span class="n">parport_ip32_set_mode</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">ECR_MODE_ECP</span><span class="p">);</span>
	<span class="n">physport</span><span class="o">-&gt;</span><span class="n">ieee1284</span><span class="p">.</span><span class="n">phase</span> <span class="o">=</span> <span class="n">IEEE1284_PH_FWD_DATA</span><span class="p">;</span>

	<span class="cm">/* Wait for peripheral to become ready */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">parport_wait_peripheral</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">DSR_nBUSY</span> <span class="o">|</span> <span class="n">DSR_nFAULT</span><span class="p">,</span>
				       <span class="n">DSR_nBUSY</span> <span class="o">|</span> <span class="n">DSR_nFAULT</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* Avoid to flood the logs */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ready_before</span><span class="p">)</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="n">PPIP32</span> <span class="s">&quot;%s: not ready in %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">p</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
		<span class="n">ready_before</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">stop</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">ready_before</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">written</span> <span class="o">=</span> <span class="n">parport_ip32_fifo_write_block</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>

	<span class="cm">/* Wait FIFO to empty.  Timeout is proportional to FIFO_depth.  */</span>
	<span class="n">parport_ip32_drain_fifo</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">physport</span><span class="o">-&gt;</span><span class="n">cad</span><span class="o">-&gt;</span><span class="n">timeout</span> <span class="o">*</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">fifo_depth</span><span class="p">);</span>

	<span class="cm">/* Check for a potential residue */</span>
	<span class="n">written</span> <span class="o">-=</span> <span class="n">parport_ip32_get_fifo_residue</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">ECR_MODE_ECP</span><span class="p">);</span>

	<span class="cm">/* Then, wait for BUSY to get low. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">parport_wait_peripheral</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">DSR_nBUSY</span><span class="p">,</span> <span class="n">DSR_nBUSY</span><span class="p">))</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="n">PPIP32</span> <span class="s">&quot;%s: BUSY timeout in %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">p</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>

<span class="nl">stop:</span>
	<span class="cm">/* Reset FIFO */</span>
	<span class="n">parport_ip32_set_mode</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">ECR_MODE_PS2</span><span class="p">);</span>
	<span class="n">physport</span><span class="o">-&gt;</span><span class="n">ieee1284</span><span class="p">.</span><span class="n">phase</span> <span class="o">=</span> <span class="n">IEEE1284_PH_FWD_IDLE</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">written</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * FIXME - Insert here parport_ip32_ecp_write_addr().</span>
<span class="cm"> */</span>

<span class="cm">/*--- Default parport operations ---------------------------------------*/</span>

<span class="k">static</span> <span class="n">__initdata</span> <span class="k">struct</span> <span class="n">parport_operations</span> <span class="n">parport_ip32_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">write_data</span>		<span class="o">=</span> <span class="n">parport_ip32_write_data</span><span class="p">,</span>
	<span class="p">.</span><span class="n">read_data</span>		<span class="o">=</span> <span class="n">parport_ip32_read_data</span><span class="p">,</span>

	<span class="p">.</span><span class="n">write_control</span>		<span class="o">=</span> <span class="n">parport_ip32_write_control</span><span class="p">,</span>
	<span class="p">.</span><span class="n">read_control</span>		<span class="o">=</span> <span class="n">parport_ip32_read_control</span><span class="p">,</span>
	<span class="p">.</span><span class="n">frob_control</span>		<span class="o">=</span> <span class="n">parport_ip32_frob_control</span><span class="p">,</span>

	<span class="p">.</span><span class="n">read_status</span>		<span class="o">=</span> <span class="n">parport_ip32_read_status</span><span class="p">,</span>

	<span class="p">.</span><span class="n">enable_irq</span>		<span class="o">=</span> <span class="n">parport_ip32_enable_irq</span><span class="p">,</span>
	<span class="p">.</span><span class="n">disable_irq</span>		<span class="o">=</span> <span class="n">parport_ip32_disable_irq</span><span class="p">,</span>

	<span class="p">.</span><span class="n">data_forward</span>		<span class="o">=</span> <span class="n">parport_ip32_data_forward</span><span class="p">,</span>
	<span class="p">.</span><span class="n">data_reverse</span>		<span class="o">=</span> <span class="n">parport_ip32_data_reverse</span><span class="p">,</span>

	<span class="p">.</span><span class="n">init_state</span>		<span class="o">=</span> <span class="n">parport_ip32_init_state</span><span class="p">,</span>
	<span class="p">.</span><span class="n">save_state</span>		<span class="o">=</span> <span class="n">parport_ip32_save_state</span><span class="p">,</span>
	<span class="p">.</span><span class="n">restore_state</span>		<span class="o">=</span> <span class="n">parport_ip32_restore_state</span><span class="p">,</span>

	<span class="p">.</span><span class="n">epp_write_data</span>		<span class="o">=</span> <span class="n">parport_ieee1284_epp_write_data</span><span class="p">,</span>
	<span class="p">.</span><span class="n">epp_read_data</span>		<span class="o">=</span> <span class="n">parport_ieee1284_epp_read_data</span><span class="p">,</span>
	<span class="p">.</span><span class="n">epp_write_addr</span>		<span class="o">=</span> <span class="n">parport_ieee1284_epp_write_addr</span><span class="p">,</span>
	<span class="p">.</span><span class="n">epp_read_addr</span>		<span class="o">=</span> <span class="n">parport_ieee1284_epp_read_addr</span><span class="p">,</span>

	<span class="p">.</span><span class="n">ecp_write_data</span>		<span class="o">=</span> <span class="n">parport_ieee1284_ecp_write_data</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ecp_read_data</span>		<span class="o">=</span> <span class="n">parport_ieee1284_ecp_read_data</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ecp_write_addr</span>		<span class="o">=</span> <span class="n">parport_ieee1284_ecp_write_addr</span><span class="p">,</span>

	<span class="p">.</span><span class="n">compat_write_data</span>	<span class="o">=</span> <span class="n">parport_ieee1284_write_compat</span><span class="p">,</span>
	<span class="p">.</span><span class="n">nibble_read_data</span>	<span class="o">=</span> <span class="n">parport_ieee1284_read_nibble</span><span class="p">,</span>
	<span class="p">.</span><span class="n">byte_read_data</span>		<span class="o">=</span> <span class="n">parport_ieee1284_read_byte</span><span class="p">,</span>

	<span class="p">.</span><span class="n">owner</span>			<span class="o">=</span> <span class="n">THIS_MODULE</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/*--- Device detection -------------------------------------------------*/</span>

<span class="cm">/**</span>
<span class="cm"> * parport_ip32_ecp_supported - check for an ECP port</span>
<span class="cm"> * @p:		pointer to the &amp;parport structure</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 1 if an ECP port is found, and 0 otherwise.  This function actually</span>
<span class="cm"> * checks if an Extended Control Register seems to be present.  On successful</span>
<span class="cm"> * return, the port is placed in SPP mode.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">__init</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">parport_ip32_ecp_supported</span><span class="p">(</span><span class="k">struct</span> <span class="n">parport</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">parport_ip32_private</span> <span class="o">*</span> <span class="k">const</span> <span class="n">priv</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">physport</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ecr</span><span class="p">;</span>

	<span class="n">ecr</span> <span class="o">=</span> <span class="n">ECR_MODE_PS2</span> <span class="o">|</span> <span class="n">ECR_nERRINTR</span> <span class="o">|</span> <span class="n">ECR_SERVINTR</span><span class="p">;</span>
	<span class="n">writeb</span><span class="p">(</span><span class="n">ecr</span><span class="p">,</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">.</span><span class="n">ecr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">readb</span><span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">.</span><span class="n">ecr</span><span class="p">)</span> <span class="o">!=</span> <span class="p">(</span><span class="n">ecr</span> <span class="o">|</span> <span class="n">ECR_F_EMPTY</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>

	<span class="n">pr_probe</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="s">&quot;Found working ECR register</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">parport_ip32_set_mode</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">ECR_MODE_SPP</span><span class="p">);</span>
	<span class="n">parport_ip32_write_control</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">DCR_SELECT</span> <span class="o">|</span> <span class="n">DCR_nINIT</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

<span class="nl">fail:</span>
	<span class="n">pr_probe</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="s">&quot;ECR register not found</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * parport_ip32_fifo_supported - check for FIFO parameters</span>
<span class="cm"> * @p:		pointer to the &amp;parport structure</span>
<span class="cm"> *</span>
<span class="cm"> * Check for FIFO parameters of an Extended Capabilities Port.  Returns 1 on</span>
<span class="cm"> * success, and 0 otherwise.  Adjust FIFO parameters in the parport structure.</span>
<span class="cm"> * On return, the port is placed in SPP mode.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">__init</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">parport_ip32_fifo_supported</span><span class="p">(</span><span class="k">struct</span> <span class="n">parport</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">parport_ip32_private</span> <span class="o">*</span> <span class="k">const</span> <span class="n">priv</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">physport</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">configa</span><span class="p">,</span> <span class="n">configb</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">pword</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="cm">/* Configuration mode */</span>
	<span class="n">parport_ip32_set_mode</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">ECR_MODE_CFG</span><span class="p">);</span>
	<span class="n">configa</span> <span class="o">=</span> <span class="n">readb</span><span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">.</span><span class="n">cnfgA</span><span class="p">);</span>
	<span class="n">configb</span> <span class="o">=</span> <span class="n">readb</span><span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">.</span><span class="n">cnfgB</span><span class="p">);</span>

	<span class="cm">/* Find out PWord size */</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">configa</span> <span class="o">&amp;</span> <span class="n">CNFGA_ID_MASK</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">CNFGA_ID_8</span>:
		<span class="n">pword</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">CNFGA_ID_16</span>:
		<span class="n">pword</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">CNFGA_ID_32</span>:
		<span class="n">pword</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">pr_probe</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="s">&quot;Unknown implementation ID: 0x%0x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			 <span class="p">(</span><span class="n">configa</span> <span class="o">&amp;</span> <span class="n">CNFGA_ID_MASK</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">CNFGA_ID_SHIFT</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pword</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_probe</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="s">&quot;Unsupported PWord size: %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">pword</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">priv</span><span class="o">-&gt;</span><span class="n">pword</span> <span class="o">=</span> <span class="n">pword</span><span class="p">;</span>
	<span class="n">pr_probe</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="s">&quot;PWord is %u bits</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="mi">8</span> <span class="o">*</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">pword</span><span class="p">);</span>

	<span class="cm">/* Check for compression support */</span>
	<span class="n">writeb</span><span class="p">(</span><span class="n">configb</span> <span class="o">|</span> <span class="n">CNFGB_COMPRESS</span><span class="p">,</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">.</span><span class="n">cnfgB</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">readb</span><span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">.</span><span class="n">cnfgB</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">CNFGB_COMPRESS</span><span class="p">)</span>
		<span class="n">pr_probe</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="s">&quot;Hardware compression detected (unsupported)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">writeb</span><span class="p">(</span><span class="n">configb</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">CNFGB_COMPRESS</span><span class="p">,</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">.</span><span class="n">cnfgB</span><span class="p">);</span>

	<span class="cm">/* Reset FIFO and go in test mode (no interrupt, no DMA) */</span>
	<span class="n">parport_ip32_set_mode</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">ECR_MODE_TST</span><span class="p">);</span>

	<span class="cm">/* FIFO must be empty now */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">readb</span><span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">.</span><span class="n">ecr</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">ECR_F_EMPTY</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">pr_probe</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="s">&quot;FIFO not reset</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Find out FIFO depth. */</span>
	<span class="n">priv</span><span class="o">-&gt;</span><span class="n">fifo_depth</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">1024</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">readb</span><span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">.</span><span class="n">ecr</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">ECR_F_FULL</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* FIFO full */</span>
			<span class="n">priv</span><span class="o">-&gt;</span><span class="n">fifo_depth</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">writeb</span><span class="p">((</span><span class="n">u8</span><span class="p">)</span><span class="n">i</span><span class="p">,</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">.</span><span class="n">fifo</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">1024</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_probe</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="s">&quot;Can&#39;t fill FIFO</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">fifo_depth</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_probe</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="s">&quot;Can&#39;t get FIFO depth</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">pr_probe</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="s">&quot;FIFO is %u PWords deep</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">fifo_depth</span><span class="p">);</span>

	<span class="cm">/* Enable interrupts */</span>
	<span class="n">parport_ip32_frob_econtrol</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">ECR_SERVINTR</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="cm">/* Find out writeIntrThreshold: number of PWords we know we can write</span>
<span class="cm">	 * if we get an interrupt. */</span>
	<span class="n">priv</span><span class="o">-&gt;</span><span class="n">writeIntrThreshold</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">fifo_depth</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">readb</span><span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">.</span><span class="n">fifo</span><span class="p">)</span> <span class="o">!=</span> <span class="p">(</span><span class="n">u8</span><span class="p">)</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pr_probe</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="s">&quot;Invalid data in FIFO</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">writeIntrThreshold</span>
		    <span class="o">&amp;&amp;</span> <span class="n">readb</span><span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">.</span><span class="n">ecr</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">ECR_SERVINTR</span><span class="p">)</span>
			<span class="cm">/* writeIntrThreshold reached */</span>
			<span class="n">priv</span><span class="o">-&gt;</span><span class="n">writeIntrThreshold</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&lt;</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">fifo_depth</span>
		    <span class="o">&amp;&amp;</span> <span class="n">readb</span><span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">.</span><span class="n">ecr</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">ECR_F_EMPTY</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* FIFO empty before the last byte? */</span>
			<span class="n">pr_probe</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="s">&quot;Data lost in FIFO</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">writeIntrThreshold</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_probe</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="s">&quot;Can&#39;t get writeIntrThreshold</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">pr_probe</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="s">&quot;writeIntrThreshold is %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">writeIntrThreshold</span><span class="p">);</span>

	<span class="cm">/* FIFO must be empty now */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">readb</span><span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">.</span><span class="n">ecr</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">ECR_F_EMPTY</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">pr_probe</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="s">&quot;Can&#39;t empty FIFO</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Reset FIFO */</span>
	<span class="n">parport_ip32_set_mode</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">ECR_MODE_PS2</span><span class="p">);</span>
	<span class="cm">/* Set reverse direction (must be in PS2 mode) */</span>
	<span class="n">parport_ip32_data_reverse</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
	<span class="cm">/* Test FIFO, no interrupt, no DMA */</span>
	<span class="n">parport_ip32_set_mode</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">ECR_MODE_TST</span><span class="p">);</span>
	<span class="cm">/* Enable interrupts */</span>
	<span class="n">parport_ip32_frob_econtrol</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">ECR_SERVINTR</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="cm">/* Find out readIntrThreshold: number of PWords we can read if we get</span>
<span class="cm">	 * an interrupt. */</span>
	<span class="n">priv</span><span class="o">-&gt;</span><span class="n">readIntrThreshold</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">fifo_depth</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">writeb</span><span class="p">(</span><span class="mh">0xaa</span><span class="p">,</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">.</span><span class="n">fifo</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">readb</span><span class="p">(</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">.</span><span class="n">ecr</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">ECR_SERVINTR</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* readIntrThreshold reached */</span>
			<span class="n">priv</span><span class="o">-&gt;</span><span class="n">readIntrThreshold</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">readIntrThreshold</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_probe</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="s">&quot;Can&#39;t get readIntrThreshold</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">pr_probe</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="s">&quot;readIntrThreshold is %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">priv</span><span class="o">-&gt;</span><span class="n">readIntrThreshold</span><span class="p">);</span>

	<span class="cm">/* Reset ECR */</span>
	<span class="n">parport_ip32_set_mode</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">ECR_MODE_PS2</span><span class="p">);</span>
	<span class="n">parport_ip32_data_forward</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
	<span class="n">parport_ip32_set_mode</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">ECR_MODE_SPP</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

<span class="nl">fail:</span>
	<span class="n">priv</span><span class="o">-&gt;</span><span class="n">fifo_depth</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">parport_ip32_set_mode</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">ECR_MODE_SPP</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*--- Initialization code ----------------------------------------------*/</span>

<span class="cm">/**</span>
<span class="cm"> * parport_ip32_make_isa_registers - compute (ISA) register addresses</span>
<span class="cm"> * @regs:	pointer to &amp;struct parport_ip32_regs to fill</span>
<span class="cm"> * @base:	base address of standard and EPP registers</span>
<span class="cm"> * @base_hi:	base address of ECP registers</span>
<span class="cm"> * @regshift:	how much to shift register offset by</span>
<span class="cm"> *</span>
<span class="cm"> * Compute register addresses, according to the ISA standard.  The addresses</span>
<span class="cm"> * of the standard and EPP registers are computed from address @base.  The</span>
<span class="cm"> * addresses of the ECP registers are computed from address @base_hi.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">__init</span>
<span class="nf">parport_ip32_make_isa_registers</span><span class="p">(</span><span class="k">struct</span> <span class="n">parport_ip32_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">,</span>
				<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">base</span><span class="p">,</span> <span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">base_hi</span><span class="p">,</span>
				<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">regshift</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#define r_base(offset)    ((u8 __iomem *)base    + ((offset) &lt;&lt; regshift))</span>
<span class="cp">#define r_base_hi(offset) ((u8 __iomem *)base_hi + ((offset) &lt;&lt; regshift))</span>
	<span class="o">*</span><span class="n">regs</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">parport_ip32_regs</span><span class="p">){</span>
		<span class="p">.</span><span class="n">data</span>		<span class="o">=</span> <span class="n">r_base</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span>
		<span class="p">.</span><span class="n">dsr</span>		<span class="o">=</span> <span class="n">r_base</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span>
		<span class="p">.</span><span class="n">dcr</span>		<span class="o">=</span> <span class="n">r_base</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span>
		<span class="p">.</span><span class="n">eppAddr</span>	<span class="o">=</span> <span class="n">r_base</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span>
		<span class="p">.</span><span class="n">eppData0</span>	<span class="o">=</span> <span class="n">r_base</span><span class="p">(</span><span class="mi">4</span><span class="p">),</span>
		<span class="p">.</span><span class="n">eppData1</span>	<span class="o">=</span> <span class="n">r_base</span><span class="p">(</span><span class="mi">5</span><span class="p">),</span>
		<span class="p">.</span><span class="n">eppData2</span>	<span class="o">=</span> <span class="n">r_base</span><span class="p">(</span><span class="mi">6</span><span class="p">),</span>
		<span class="p">.</span><span class="n">eppData3</span>	<span class="o">=</span> <span class="n">r_base</span><span class="p">(</span><span class="mi">7</span><span class="p">),</span>
		<span class="p">.</span><span class="n">ecpAFifo</span>	<span class="o">=</span> <span class="n">r_base</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span>
		<span class="p">.</span><span class="n">fifo</span>		<span class="o">=</span> <span class="n">r_base_hi</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span>
		<span class="p">.</span><span class="n">cnfgA</span>		<span class="o">=</span> <span class="n">r_base_hi</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span>
		<span class="p">.</span><span class="n">cnfgB</span>		<span class="o">=</span> <span class="n">r_base_hi</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span>
		<span class="p">.</span><span class="n">ecr</span>		<span class="o">=</span> <span class="n">r_base_hi</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
	<span class="p">};</span>
<span class="cp">#undef r_base_hi</span>
<span class="cp">#undef r_base</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * parport_ip32_probe_port - probe and register IP32 built-in parallel port</span>
<span class="cm"> *</span>
<span class="cm"> * Returns the new allocated &amp;parport structure.  On error, an error code is</span>
<span class="cm"> * encoded in return value with the ERR_PTR function.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">__init</span> <span class="k">struct</span> <span class="n">parport</span> <span class="o">*</span><span class="nf">parport_ip32_probe_port</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">parport_ip32_regs</span> <span class="n">regs</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">parport_ip32_private</span> <span class="o">*</span><span class="n">priv</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">parport_operations</span> <span class="o">*</span><span class="n">ops</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">parport</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">parport_ip32_make_isa_registers</span><span class="p">(</span><span class="o">&amp;</span><span class="n">regs</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mace</span><span class="o">-&gt;</span><span class="n">isa</span><span class="p">.</span><span class="n">parallel</span><span class="p">,</span>
					<span class="o">&amp;</span><span class="n">mace</span><span class="o">-&gt;</span><span class="n">isa</span><span class="p">.</span><span class="n">ecp1284</span><span class="p">,</span> <span class="mi">8</span> <span class="cm">/* regshift */</span><span class="p">);</span>

	<span class="n">ops</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">parport_operations</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="n">priv</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">parport_ip32_private</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="n">p</span> <span class="o">=</span> <span class="n">parport_register_port</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">PARPORT_IRQ_NONE</span><span class="p">,</span> <span class="n">PARPORT_DMA_NONE</span><span class="p">,</span> <span class="n">ops</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ops</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="o">||</span> <span class="n">priv</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="o">||</span> <span class="n">p</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">p</span><span class="o">-&gt;</span><span class="n">base</span> <span class="o">=</span> <span class="n">MACE_BASE</span> <span class="o">+</span> <span class="n">offsetof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sgi_mace</span><span class="p">,</span> <span class="n">isa</span><span class="p">.</span><span class="n">parallel</span><span class="p">);</span>
	<span class="n">p</span><span class="o">-&gt;</span><span class="n">base_hi</span> <span class="o">=</span> <span class="n">MACE_BASE</span> <span class="o">+</span> <span class="n">offsetof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sgi_mace</span><span class="p">,</span> <span class="n">isa</span><span class="p">.</span><span class="n">ecp1284</span><span class="p">);</span>
	<span class="n">p</span><span class="o">-&gt;</span><span class="n">private_data</span> <span class="o">=</span> <span class="n">priv</span><span class="p">;</span>

	<span class="o">*</span><span class="n">ops</span> <span class="o">=</span> <span class="n">parport_ip32_ops</span><span class="p">;</span>
	<span class="o">*</span><span class="n">priv</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">parport_ip32_private</span><span class="p">){</span>
		<span class="p">.</span><span class="n">regs</span>			<span class="o">=</span> <span class="n">regs</span><span class="p">,</span>
		<span class="p">.</span><span class="n">dcr_writable</span>		<span class="o">=</span> <span class="n">DCR_DIR</span> <span class="o">|</span> <span class="n">DCR_SELECT</span> <span class="o">|</span> <span class="n">DCR_nINIT</span> <span class="o">|</span>
					  <span class="n">DCR_AUTOFD</span> <span class="o">|</span> <span class="n">DCR_STROBE</span><span class="p">,</span>
		<span class="p">.</span><span class="n">irq_mode</span>		<span class="o">=</span> <span class="n">PARPORT_IP32_IRQ_FWD</span><span class="p">,</span>
	<span class="p">};</span>
	<span class="n">init_completion</span><span class="p">(</span><span class="o">&amp;</span><span class="n">priv</span><span class="o">-&gt;</span><span class="n">irq_complete</span><span class="p">);</span>

	<span class="cm">/* Probe port. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">parport_ip32_ecp_supported</span><span class="p">(</span><span class="n">p</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">parport_ip32_dump_state</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="s">&quot;begin init&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="cm">/* We found what looks like a working ECR register.  Simply assume</span>
<span class="cm">	 * that all modes are correctly supported.  Enable basic modes. */</span>
	<span class="n">p</span><span class="o">-&gt;</span><span class="n">modes</span> <span class="o">=</span> <span class="n">PARPORT_MODE_PCSPP</span> <span class="o">|</span> <span class="n">PARPORT_MODE_SAFEININT</span><span class="p">;</span>
	<span class="n">p</span><span class="o">-&gt;</span><span class="n">modes</span> <span class="o">|=</span> <span class="n">PARPORT_MODE_TRISTATE</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">parport_ip32_fifo_supported</span><span class="p">(</span><span class="n">p</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="n">PPIP32</span>
		       <span class="s">&quot;%s: error: FIFO disabled</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="cm">/* Disable hardware modes depending on a working FIFO. */</span>
		<span class="n">features</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">PARPORT_IP32_ENABLE_SPP</span><span class="p">;</span>
		<span class="n">features</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">PARPORT_IP32_ENABLE_ECP</span><span class="p">;</span>
		<span class="cm">/* DMA is not needed if FIFO is not supported.  */</span>
		<span class="n">features</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">PARPORT_IP32_ENABLE_DMA</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Request IRQ */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">features</span> <span class="o">&amp;</span> <span class="n">PARPORT_IP32_ENABLE_IRQ</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">irq</span> <span class="o">=</span> <span class="n">MACEISA_PARALLEL_IRQ</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">request_irq</span><span class="p">(</span><span class="n">irq</span><span class="p">,</span> <span class="n">parport_ip32_interrupt</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">p</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="n">PPIP32</span>
			       <span class="s">&quot;%s: error: IRQ disabled</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
			<span class="cm">/* DMA cannot work without interrupts. */</span>
			<span class="n">features</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">PARPORT_IP32_ENABLE_DMA</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">pr_probe</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="s">&quot;Interrupt support enabled</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">p</span><span class="o">-&gt;</span><span class="n">irq</span> <span class="o">=</span> <span class="n">irq</span><span class="p">;</span>
			<span class="n">priv</span><span class="o">-&gt;</span><span class="n">dcr_writable</span> <span class="o">|=</span> <span class="n">DCR_IRQ</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* Allocate DMA resources */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">features</span> <span class="o">&amp;</span> <span class="n">PARPORT_IP32_ENABLE_DMA</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">parport_ip32_dma_register</span><span class="p">())</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="n">PPIP32</span>
			       <span class="s">&quot;%s: error: DMA disabled</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="k">else</span> <span class="p">{</span>
			<span class="n">pr_probe</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="s">&quot;DMA support enabled</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">p</span><span class="o">-&gt;</span><span class="n">dma</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="cm">/* arbitrary value != PARPORT_DMA_NONE */</span>
			<span class="n">p</span><span class="o">-&gt;</span><span class="n">modes</span> <span class="o">|=</span> <span class="n">PARPORT_MODE_DMA</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">features</span> <span class="o">&amp;</span> <span class="n">PARPORT_IP32_ENABLE_SPP</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Enable compatibility FIFO mode */</span>
		<span class="n">p</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">compat_write_data</span> <span class="o">=</span> <span class="n">parport_ip32_compat_write_data</span><span class="p">;</span>
		<span class="n">p</span><span class="o">-&gt;</span><span class="n">modes</span> <span class="o">|=</span> <span class="n">PARPORT_MODE_COMPAT</span><span class="p">;</span>
		<span class="n">pr_probe</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="s">&quot;Hardware support for SPP mode enabled</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">features</span> <span class="o">&amp;</span> <span class="n">PARPORT_IP32_ENABLE_EPP</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Set up access functions to use EPP hardware. */</span>
		<span class="n">p</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">epp_read_data</span> <span class="o">=</span> <span class="n">parport_ip32_epp_read_data</span><span class="p">;</span>
		<span class="n">p</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">epp_write_data</span> <span class="o">=</span> <span class="n">parport_ip32_epp_write_data</span><span class="p">;</span>
		<span class="n">p</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">epp_read_addr</span> <span class="o">=</span> <span class="n">parport_ip32_epp_read_addr</span><span class="p">;</span>
		<span class="n">p</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">epp_write_addr</span> <span class="o">=</span> <span class="n">parport_ip32_epp_write_addr</span><span class="p">;</span>
		<span class="n">p</span><span class="o">-&gt;</span><span class="n">modes</span> <span class="o">|=</span> <span class="n">PARPORT_MODE_EPP</span><span class="p">;</span>
		<span class="n">pr_probe</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="s">&quot;Hardware support for EPP mode enabled</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">features</span> <span class="o">&amp;</span> <span class="n">PARPORT_IP32_ENABLE_ECP</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Enable ECP FIFO mode */</span>
		<span class="n">p</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">ecp_write_data</span> <span class="o">=</span> <span class="n">parport_ip32_ecp_write_data</span><span class="p">;</span>
		<span class="cm">/* FIXME - not implemented */</span>
<span class="cm">/*		p-&gt;ops-&gt;ecp_read_data  = parport_ip32_ecp_read_data; */</span>
<span class="cm">/*		p-&gt;ops-&gt;ecp_write_addr = parport_ip32_ecp_write_addr; */</span>
		<span class="n">p</span><span class="o">-&gt;</span><span class="n">modes</span> <span class="o">|=</span> <span class="n">PARPORT_MODE_ECP</span><span class="p">;</span>
		<span class="n">pr_probe</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="s">&quot;Hardware support for ECP mode enabled</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Initialize the port with sensible values */</span>
	<span class="n">parport_ip32_set_mode</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">ECR_MODE_PS2</span><span class="p">);</span>
	<span class="n">parport_ip32_write_control</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">DCR_SELECT</span> <span class="o">|</span> <span class="n">DCR_nINIT</span><span class="p">);</span>
	<span class="n">parport_ip32_data_forward</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
	<span class="n">parport_ip32_disable_irq</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
	<span class="n">parport_ip32_write_data</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">);</span>
	<span class="n">parport_ip32_dump_state</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="s">&quot;end init&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="cm">/* Print out what we found */</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;%s: SGI IP32 at 0x%lx (0x%lx)&quot;</span><span class="p">,</span>
	       <span class="n">p</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">,</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">base_hi</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">irq</span> <span class="o">!=</span> <span class="n">PARPORT_IRQ_NONE</span><span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;, irq %d&quot;</span><span class="p">,</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot; [&quot;</span><span class="p">);</span>
<span class="cp">#define printmode(x)	if (p-&gt;modes &amp; PARPORT_MODE_##x)		\</span>
<span class="cp">				printk(&quot;%s%s&quot;, f++ ? &quot;,&quot; : &quot;&quot;, #x)</span>
	<span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">f</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">printmode</span><span class="p">(</span><span class="n">PCSPP</span><span class="p">);</span>
		<span class="n">printmode</span><span class="p">(</span><span class="n">TRISTATE</span><span class="p">);</span>
		<span class="n">printmode</span><span class="p">(</span><span class="n">COMPAT</span><span class="p">);</span>
		<span class="n">printmode</span><span class="p">(</span><span class="n">EPP</span><span class="p">);</span>
		<span class="n">printmode</span><span class="p">(</span><span class="n">ECP</span><span class="p">);</span>
		<span class="n">printmode</span><span class="p">(</span><span class="n">DMA</span><span class="p">);</span>
	<span class="p">}</span>
<span class="cp">#undef printmode</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;]</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="n">parport_announce_port</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">p</span><span class="p">;</span>

<span class="nl">fail:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="p">)</span>
		<span class="n">parport_put_port</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">priv</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">ops</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="n">err</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * parport_ip32_unregister_port - unregister a parallel port</span>
<span class="cm"> * @p:		pointer to the &amp;struct parport</span>
<span class="cm"> *</span>
<span class="cm"> * Unregisters a parallel port and free previously allocated resources</span>
<span class="cm"> * (memory, IRQ, ...).</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">__exit</span> <span class="kt">void</span> <span class="nf">parport_ip32_unregister_port</span><span class="p">(</span><span class="k">struct</span> <span class="n">parport</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">parport_ip32_private</span> <span class="o">*</span> <span class="k">const</span> <span class="n">priv</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">physport</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">parport_operations</span> <span class="o">*</span><span class="n">ops</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">ops</span><span class="p">;</span>

	<span class="n">parport_remove_port</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">modes</span> <span class="o">&amp;</span> <span class="n">PARPORT_MODE_DMA</span><span class="p">)</span>
		<span class="n">parport_ip32_dma_unregister</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">irq</span> <span class="o">!=</span> <span class="n">PARPORT_IRQ_NONE</span><span class="p">)</span>
		<span class="n">free_irq</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
	<span class="n">parport_put_port</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">priv</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">ops</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * parport_ip32_init - module initialization function</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">parport_ip32_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pr_info</span><span class="p">(</span><span class="n">PPIP32</span> <span class="s">&quot;SGI IP32 built-in parallel port driver v0.6</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">this_port</span> <span class="o">=</span> <span class="n">parport_ip32_probe_port</span><span class="p">();</span>
	<span class="k">return</span> <span class="n">IS_ERR</span><span class="p">(</span><span class="n">this_port</span><span class="p">)</span> <span class="o">?</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">this_port</span><span class="p">)</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * parport_ip32_exit - module termination function</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">__exit</span> <span class="nf">parport_ip32_exit</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">parport_ip32_unregister_port</span><span class="p">(</span><span class="n">this_port</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*--- Module stuff -----------------------------------------------------*/</span>

<span class="n">MODULE_AUTHOR</span><span class="p">(</span><span class="s">&quot;Arnaud Giersch &lt;arnaud.giersch@free.fr&gt;&quot;</span><span class="p">);</span>
<span class="n">MODULE_DESCRIPTION</span><span class="p">(</span><span class="s">&quot;SGI IP32 built-in parallel port driver&quot;</span><span class="p">);</span>
<span class="n">MODULE_LICENSE</span><span class="p">(</span><span class="s">&quot;GPL&quot;</span><span class="p">);</span>
<span class="n">MODULE_VERSION</span><span class="p">(</span><span class="s">&quot;0.6&quot;</span><span class="p">);</span>		<span class="cm">/* update in parport_ip32_init() too */</span>

<span class="n">module_init</span><span class="p">(</span><span class="n">parport_ip32_init</span><span class="p">);</span>
<span class="n">module_exit</span><span class="p">(</span><span class="n">parport_ip32_exit</span><span class="p">);</span>

<span class="n">module_param</span><span class="p">(</span><span class="n">verbose_probing</span><span class="p">,</span> <span class="n">bool</span><span class="p">,</span> <span class="n">S_IRUGO</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">verbose_probing</span><span class="p">,</span> <span class="s">&quot;Log chit-chat during initialization&quot;</span><span class="p">);</span>

<span class="n">module_param</span><span class="p">(</span><span class="n">features</span><span class="p">,</span> <span class="n">uint</span><span class="p">,</span> <span class="n">S_IRUGO</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">features</span><span class="p">,</span>
		 <span class="s">&quot;Bit mask of features to enable&quot;</span>
		 <span class="s">&quot;, bit 0: IRQ support&quot;</span>
		 <span class="s">&quot;, bit 1: DMA support&quot;</span>
		 <span class="s">&quot;, bit 2: hardware SPP mode&quot;</span>
		 <span class="s">&quot;, bit 3: hardware EPP mode&quot;</span>
		 <span class="s">&quot;, bit 4: hardware ECP mode&quot;</span><span class="p">);</span>

<span class="cm">/*--- Inform (X)Emacs about preferred coding style ---------------------*/</span>
<span class="cm">/*</span>
<span class="cm"> * Local Variables:</span>
<span class="cm"> * mode: c</span>
<span class="cm"> * c-file-style: &quot;linux&quot;</span>
<span class="cm"> * indent-tabs-mode: t</span>
<span class="cm"> * tab-width: 8</span>
<span class="cm"> * fill-column: 78</span>
<span class="cm"> * ispell-local-dictionary: &quot;american&quot;</span>
<span class="cm"> * End:</span>
<span class="cm"> */</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
