<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › parport › ieee1284.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>ieee1284.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * IEEE-1284 implementation for parport.</span>
<span class="cm"> *</span>
<span class="cm"> * Authors: Phil Blundell &lt;philb@gnu.org&gt;</span>
<span class="cm"> *          Carsten Gross &lt;carsten@sol.wohnheim.uni-ulm.de&gt;</span>
<span class="cm"> *	    Jose Renau &lt;renau@acm.org&gt;</span>
<span class="cm"> *          Tim Waugh &lt;tim@cyberelk.demon.co.uk&gt; (largely rewritten)</span>
<span class="cm"> *</span>
<span class="cm"> * This file is responsible for IEEE 1284 negotiation, and for handing</span>
<span class="cm"> * read/write requests to low-level drivers.</span>
<span class="cm"> *</span>
<span class="cm"> * Any part of this program may be used in documents licensed under</span>
<span class="cm"> * the GNU Free Documentation License, Version 1.1 or any later version</span>
<span class="cm"> * published by the Free Software Foundation.</span>
<span class="cm"> *</span>
<span class="cm"> * Various hacks, Fred Barnes &lt;frmb2@ukc.ac.uk&gt;, 04/2000</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/threads.h&gt;</span>
<span class="cp">#include &lt;linux/parport.h&gt;</span>
<span class="cp">#include &lt;linux/delay.h&gt;</span>
<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/interrupt.h&gt;</span>
<span class="cp">#include &lt;linux/timer.h&gt;</span>
<span class="cp">#include &lt;linux/sched.h&gt;</span>

<span class="cp">#undef DEBUG </span><span class="cm">/* undef me for production */</span><span class="cp"></span>

<span class="cp">#ifdef CONFIG_LP_CONSOLE</span>
<span class="cp">#undef DEBUG </span><span class="cm">/* Don&#39;t want a garbled console */</span><span class="cp"></span>
<span class="cp">#endif</span>

<span class="cp">#ifdef DEBUG</span>
<span class="cp">#define DPRINTK(stuff...) printk (stuff)</span>
<span class="cp">#else</span>
<span class="cp">#define DPRINTK(stuff...)</span>
<span class="cp">#endif</span>

<span class="cm">/* Make parport_wait_peripheral wake up.</span>
<span class="cm"> * It will be useful to call this from an interrupt handler. */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">parport_ieee1284_wakeup</span> <span class="p">(</span><span class="k">struct</span> <span class="n">parport</span> <span class="o">*</span><span class="n">port</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">up</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">physport</span><span class="o">-&gt;</span><span class="n">ieee1284</span><span class="p">.</span><span class="n">irq</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">parport</span> <span class="o">*</span><span class="n">port_from_cookie</span><span class="p">[</span><span class="n">PARPORT_MAX</span><span class="p">];</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">timeout_waiting_on_port</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">cookie</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">parport_ieee1284_wakeup</span> <span class="p">(</span><span class="n">port_from_cookie</span><span class="p">[</span><span class="n">cookie</span> <span class="o">%</span> <span class="n">PARPORT_MAX</span><span class="p">]);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	parport_wait_event - wait for an event on a parallel port</span>
<span class="cm"> *	@port: port to wait on</span>
<span class="cm"> *	@timeout: time to wait (in jiffies)</span>
<span class="cm"> *</span>
<span class="cm"> *	This function waits for up to @timeout jiffies for an</span>
<span class="cm"> *	interrupt to occur on a parallel port.  If the port timeout is</span>
<span class="cm"> *	set to zero, it returns immediately.</span>
<span class="cm"> *</span>
<span class="cm"> *	If an interrupt occurs before the timeout period elapses, this</span>
<span class="cm"> *	function returns zero immediately.  If it times out, it returns</span>
<span class="cm"> *	one.  An error code less than zero indicates an error (most</span>
<span class="cm"> *	likely a pending signal), and the calling code should finish</span>
<span class="cm"> *	what it&#39;s doing as soon as it can.</span>
<span class="cm"> */</span>

<span class="kt">int</span> <span class="nf">parport_wait_event</span> <span class="p">(</span><span class="k">struct</span> <span class="n">parport</span> <span class="o">*</span><span class="n">port</span><span class="p">,</span> <span class="kt">signed</span> <span class="kt">long</span> <span class="n">timeout</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">timer_list</span> <span class="n">timer</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">physport</span><span class="o">-&gt;</span><span class="n">cad</span><span class="o">-&gt;</span><span class="n">timeout</span><span class="p">)</span>
		<span class="cm">/* Zero timeout is special, and we can&#39;t down() the</span>
<span class="cm">		   semaphore. */</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">init_timer_on_stack</span><span class="p">(</span><span class="o">&amp;</span><span class="n">timer</span><span class="p">);</span>
	<span class="n">timer</span><span class="p">.</span><span class="n">expires</span> <span class="o">=</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="n">timeout</span><span class="p">;</span>
	<span class="n">timer</span><span class="p">.</span><span class="n">function</span> <span class="o">=</span> <span class="n">timeout_waiting_on_port</span><span class="p">;</span>
	<span class="n">port_from_cookie</span><span class="p">[</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">number</span> <span class="o">%</span> <span class="n">PARPORT_MAX</span><span class="p">]</span> <span class="o">=</span> <span class="n">port</span><span class="p">;</span>
	<span class="n">timer</span><span class="p">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">port</span><span class="o">-&gt;</span><span class="n">number</span><span class="p">;</span>

	<span class="n">add_timer</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">timer</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">down_interruptible</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">physport</span><span class="o">-&gt;</span><span class="n">ieee1284</span><span class="p">.</span><span class="n">irq</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">del_timer_sync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">timer</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">ret</span><span class="p">)</span>
		<span class="cm">/* Timed out. */</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">destroy_timer_on_stack</span><span class="p">(</span><span class="o">&amp;</span><span class="n">timer</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	parport_poll_peripheral - poll status lines</span>
<span class="cm"> *	@port: port to watch</span>
<span class="cm"> *	@mask: status lines to watch</span>
<span class="cm"> *	@result: desired values of chosen status lines</span>
<span class="cm"> *	@usec: timeout</span>
<span class="cm"> *</span>
<span class="cm"> *	This function busy-waits until the masked status lines have</span>
<span class="cm"> *	the desired values, or until the timeout period elapses.  The</span>
<span class="cm"> *	@mask and @result parameters are bitmasks, with the bits</span>
<span class="cm"> *	defined by the constants in parport.h: %PARPORT_STATUS_BUSY,</span>
<span class="cm"> *	and so on.</span>
<span class="cm"> *</span>
<span class="cm"> *	This function does not call schedule(); instead it busy-waits</span>
<span class="cm"> *	using udelay().  It currently has a resolution of 5usec.</span>
<span class="cm"> *</span>
<span class="cm"> *	If the status lines take on the desired values before the</span>
<span class="cm"> *	timeout period elapses, parport_poll_peripheral() returns zero</span>
<span class="cm"> *	immediately.  A return value greater than zero indicates</span>
<span class="cm"> *	a timeout.  An error code (less than zero) indicates an error,</span>
<span class="cm"> *	most likely a signal that arrived, and the caller should</span>
<span class="cm"> *	finish what it is doing as soon as possible.</span>
<span class="cm">*/</span>

<span class="kt">int</span> <span class="nf">parport_poll_peripheral</span><span class="p">(</span><span class="k">struct</span> <span class="n">parport</span> <span class="o">*</span><span class="n">port</span><span class="p">,</span>
			    <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">mask</span><span class="p">,</span>
			    <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">result</span><span class="p">,</span>
			    <span class="kt">int</span> <span class="n">usec</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Zero return code is success, &gt;0 is timeout. */</span>
	<span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="n">usec</span> <span class="o">/</span> <span class="mi">5</span> <span class="o">+</span> <span class="mi">2</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">status</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">parport_read_status</span> <span class="p">(</span><span class="n">port</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">mask</span><span class="p">)</span> <span class="o">==</span> <span class="n">result</span><span class="p">)</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">signal_pending</span> <span class="p">(</span><span class="n">current</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINTR</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">need_resched</span><span class="p">())</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">)</span>
			<span class="n">udelay</span> <span class="p">(</span><span class="mi">5</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	parport_wait_peripheral - wait for status lines to change in 35ms</span>
<span class="cm"> *	@port: port to watch</span>
<span class="cm"> *	@mask: status lines to watch</span>
<span class="cm"> *	@result: desired values of chosen status lines</span>
<span class="cm"> *</span>
<span class="cm"> *	This function waits until the masked status lines have the</span>
<span class="cm"> *	desired values, or until 35ms have elapsed (see IEEE 1284-1994</span>
<span class="cm"> *	page 24 to 25 for why this value in particular is hardcoded).</span>
<span class="cm"> *	The @mask and @result parameters are bitmasks, with the bits</span>
<span class="cm"> *	defined by the constants in parport.h: %PARPORT_STATUS_BUSY,</span>
<span class="cm"> *	and so on.</span>
<span class="cm"> *</span>
<span class="cm"> *	The port is polled quickly to start off with, in anticipation</span>
<span class="cm"> *	of a fast response from the peripheral.  This fast polling</span>
<span class="cm"> *	time is configurable (using /proc), and defaults to 500usec.</span>
<span class="cm"> *	If the timeout for this port (see parport_set_timeout()) is</span>
<span class="cm"> *	zero, the fast polling time is 35ms, and this function does</span>
<span class="cm"> *	not call schedule().</span>
<span class="cm"> *</span>
<span class="cm"> *	If the timeout for this port is non-zero, after the fast</span>
<span class="cm"> *	polling fails it uses parport_wait_event() to wait for up to</span>
<span class="cm"> *	10ms, waking up if an interrupt occurs.</span>
<span class="cm"> */</span>

<span class="kt">int</span> <span class="nf">parport_wait_peripheral</span><span class="p">(</span><span class="k">struct</span> <span class="n">parport</span> <span class="o">*</span><span class="n">port</span><span class="p">,</span>
			    <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">mask</span><span class="p">,</span> 
			    <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">result</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">usec</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">deadline</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">status</span><span class="p">;</span>

	<span class="n">usec</span> <span class="o">=</span> <span class="n">port</span><span class="o">-&gt;</span><span class="n">physport</span><span class="o">-&gt;</span><span class="n">spintime</span><span class="p">;</span> <span class="cm">/* usecs of fast polling */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">physport</span><span class="o">-&gt;</span><span class="n">cad</span><span class="o">-&gt;</span><span class="n">timeout</span><span class="p">)</span>
		<span class="cm">/* A zero timeout is &quot;special&quot;: busy wait for the</span>
<span class="cm">		   entire 35ms. */</span>
		<span class="n">usec</span> <span class="o">=</span> <span class="mi">35000</span><span class="p">;</span>

	<span class="cm">/* Fast polling.</span>
<span class="cm">	 *</span>
<span class="cm">	 * This should be adjustable.</span>
<span class="cm">	 * How about making a note (in the device structure) of how long</span>
<span class="cm">	 * it takes, so we know for next time?</span>
<span class="cm">	 */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">parport_poll_peripheral</span> <span class="p">(</span><span class="n">port</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="n">result</span><span class="p">,</span> <span class="n">usec</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">physport</span><span class="o">-&gt;</span><span class="n">cad</span><span class="o">-&gt;</span><span class="n">timeout</span><span class="p">)</span>
		<span class="cm">/* We may be in an interrupt handler, so we can&#39;t poll</span>
<span class="cm">		 * slowly anyway. */</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/* 40ms of slow polling. */</span>
	<span class="n">deadline</span> <span class="o">=</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="n">msecs_to_jiffies</span><span class="p">(</span><span class="mi">40</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">time_before</span> <span class="p">(</span><span class="n">jiffies</span><span class="p">,</span> <span class="n">deadline</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">signal_pending</span> <span class="p">(</span><span class="n">current</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINTR</span><span class="p">;</span>

		<span class="cm">/* Wait for 10ms (or until an interrupt occurs if</span>
<span class="cm">		 * the handler is set) */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">ret</span> <span class="o">=</span> <span class="n">parport_wait_event</span> <span class="p">(</span><span class="n">port</span><span class="p">,</span> <span class="n">msecs_to_jiffies</span><span class="p">(</span><span class="mi">10</span><span class="p">)))</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

		<span class="n">status</span> <span class="o">=</span> <span class="n">parport_read_status</span> <span class="p">(</span><span class="n">port</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">mask</span><span class="p">)</span> <span class="o">==</span> <span class="n">result</span><span class="p">)</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* parport_wait_event didn&#39;t time out, but the</span>
<span class="cm">			 * peripheral wasn&#39;t actually ready either.</span>
<span class="cm">			 * Wait for another 10ms. */</span>
			<span class="n">schedule_timeout_interruptible</span><span class="p">(</span><span class="n">msecs_to_jiffies</span><span class="p">(</span><span class="mi">10</span><span class="p">));</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_PARPORT_1284</span>
<span class="cm">/* Terminate a negotiated mode. */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">parport_ieee1284_terminate</span> <span class="p">(</span><span class="k">struct</span> <span class="n">parport</span> <span class="o">*</span><span class="n">port</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">r</span><span class="p">;</span>
	<span class="n">port</span> <span class="o">=</span> <span class="n">port</span><span class="o">-&gt;</span><span class="n">physport</span><span class="p">;</span>

	<span class="cm">/* EPP terminates differently. */</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">ieee1284</span><span class="p">.</span><span class="n">mode</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">IEEE1284_MODE_EPP</span>:
	<span class="k">case</span> <span class="n">IEEE1284_MODE_EPPSL</span>:
	<span class="k">case</span> <span class="n">IEEE1284_MODE_EPPSWE</span>:
		<span class="cm">/* Terminate from EPP mode. */</span>

		<span class="cm">/* Event 68: Set nInit low */</span>
		<span class="n">parport_frob_control</span> <span class="p">(</span><span class="n">port</span><span class="p">,</span> <span class="n">PARPORT_CONTROL_INIT</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">udelay</span> <span class="p">(</span><span class="mi">50</span><span class="p">);</span>

		<span class="cm">/* Event 69: Set nInit high, nSelectIn low */</span>
		<span class="n">parport_frob_control</span> <span class="p">(</span><span class="n">port</span><span class="p">,</span>
				      <span class="n">PARPORT_CONTROL_SELECT</span>
				      <span class="o">|</span> <span class="n">PARPORT_CONTROL_INIT</span><span class="p">,</span>
				      <span class="n">PARPORT_CONTROL_SELECT</span>
				      <span class="o">|</span> <span class="n">PARPORT_CONTROL_INIT</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">IEEE1284_MODE_ECP</span>:
	<span class="k">case</span> <span class="n">IEEE1284_MODE_ECPRLE</span>:
	<span class="k">case</span> <span class="n">IEEE1284_MODE_ECPSWE</span>:
		<span class="cm">/* In ECP we can only terminate from fwd idle phase. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">ieee1284</span><span class="p">.</span><span class="n">phase</span> <span class="o">!=</span> <span class="n">IEEE1284_PH_FWD_IDLE</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Event 47: Set nInit high */</span>
			<span class="n">parport_frob_control</span> <span class="p">(</span><span class="n">port</span><span class="p">,</span>
					      <span class="n">PARPORT_CONTROL_INIT</span>
					      <span class="o">|</span> <span class="n">PARPORT_CONTROL_AUTOFD</span><span class="p">,</span>
					      <span class="n">PARPORT_CONTROL_INIT</span>
					      <span class="o">|</span> <span class="n">PARPORT_CONTROL_AUTOFD</span><span class="p">);</span>

			<span class="cm">/* Event 49: PError goes high */</span>
			<span class="n">r</span> <span class="o">=</span> <span class="n">parport_wait_peripheral</span> <span class="p">(</span><span class="n">port</span><span class="p">,</span>
						     <span class="n">PARPORT_STATUS_PAPEROUT</span><span class="p">,</span>
						     <span class="n">PARPORT_STATUS_PAPEROUT</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="p">)</span>
				<span class="n">DPRINTK</span> <span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;%s: Timeout at event 49</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					 <span class="n">port</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>

			<span class="n">parport_data_forward</span> <span class="p">(</span><span class="n">port</span><span class="p">);</span>
			<span class="n">DPRINTK</span> <span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;%s: ECP direction: forward</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				 <span class="n">port</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
			<span class="n">port</span><span class="o">-&gt;</span><span class="n">ieee1284</span><span class="p">.</span><span class="n">phase</span> <span class="o">=</span> <span class="n">IEEE1284_PH_FWD_IDLE</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* fall-though.. */</span>

	<span class="nl">default:</span>
		<span class="cm">/* Terminate from all other modes. */</span>

		<span class="cm">/* Event 22: Set nSelectIn low, nAutoFd high */</span>
		<span class="n">parport_frob_control</span> <span class="p">(</span><span class="n">port</span><span class="p">,</span>
				      <span class="n">PARPORT_CONTROL_SELECT</span>
				      <span class="o">|</span> <span class="n">PARPORT_CONTROL_AUTOFD</span><span class="p">,</span>
				      <span class="n">PARPORT_CONTROL_SELECT</span><span class="p">);</span>

		<span class="cm">/* Event 24: nAck goes low */</span>
		<span class="n">r</span> <span class="o">=</span> <span class="n">parport_wait_peripheral</span> <span class="p">(</span><span class="n">port</span><span class="p">,</span> <span class="n">PARPORT_STATUS_ACK</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="p">)</span>
			<span class="n">DPRINTK</span> <span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;%s: Timeout at event 24</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				 <span class="n">port</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>

		<span class="cm">/* Event 25: Set nAutoFd low */</span>
		<span class="n">parport_frob_control</span> <span class="p">(</span><span class="n">port</span><span class="p">,</span>
				      <span class="n">PARPORT_CONTROL_AUTOFD</span><span class="p">,</span>
				      <span class="n">PARPORT_CONTROL_AUTOFD</span><span class="p">);</span>

		<span class="cm">/* Event 27: nAck goes high */</span>
		<span class="n">r</span> <span class="o">=</span> <span class="n">parport_wait_peripheral</span> <span class="p">(</span><span class="n">port</span><span class="p">,</span>
					     <span class="n">PARPORT_STATUS_ACK</span><span class="p">,</span> 
					     <span class="n">PARPORT_STATUS_ACK</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="p">)</span>
			<span class="n">DPRINTK</span> <span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;%s: Timeout at event 27</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				 <span class="n">port</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>

		<span class="cm">/* Event 29: Set nAutoFd high */</span>
		<span class="n">parport_frob_control</span> <span class="p">(</span><span class="n">port</span><span class="p">,</span> <span class="n">PARPORT_CONTROL_AUTOFD</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">port</span><span class="o">-&gt;</span><span class="n">ieee1284</span><span class="p">.</span><span class="n">mode</span> <span class="o">=</span> <span class="n">IEEE1284_MODE_COMPAT</span><span class="p">;</span>
	<span class="n">port</span><span class="o">-&gt;</span><span class="n">ieee1284</span><span class="p">.</span><span class="n">phase</span> <span class="o">=</span> <span class="n">IEEE1284_PH_FWD_IDLE</span><span class="p">;</span>

	<span class="n">DPRINTK</span> <span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;%s: In compatibility (forward idle) mode</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		 <span class="n">port</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
<span class="p">}</span>		
<span class="cp">#endif </span><span class="cm">/* IEEE1284 support */</span><span class="cp"></span>

<span class="cm">/**</span>
<span class="cm"> *	parport_negotiate - negotiate an IEEE 1284 mode</span>
<span class="cm"> *	@port: port to use</span>
<span class="cm"> *	@mode: mode to negotiate to</span>
<span class="cm"> *</span>
<span class="cm"> *	Use this to negotiate to a particular IEEE 1284 transfer mode.</span>
<span class="cm"> *	The @mode parameter should be one of the constants in</span>
<span class="cm"> *	parport.h starting %IEEE1284_MODE_xxx.</span>
<span class="cm"> *</span>
<span class="cm"> *	The return value is 0 if the peripheral has accepted the</span>
<span class="cm"> *	negotiation to the mode specified, -1 if the peripheral is not</span>
<span class="cm"> *	IEEE 1284 compliant (or not present), or 1 if the peripheral</span>
<span class="cm"> *	has rejected the negotiation.</span>
<span class="cm"> */</span>

<span class="kt">int</span> <span class="nf">parport_negotiate</span> <span class="p">(</span><span class="k">struct</span> <span class="n">parport</span> <span class="o">*</span><span class="n">port</span><span class="p">,</span> <span class="kt">int</span> <span class="n">mode</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifndef CONFIG_PARPORT_1284</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mode</span> <span class="o">==</span> <span class="n">IEEE1284_MODE_COMPAT</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">printk</span> <span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;parport: IEEE1284 not supported in this kernel</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="cp">#else</span>
	<span class="kt">int</span> <span class="n">m</span> <span class="o">=</span> <span class="n">mode</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">IEEE1284_ADDR</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">r</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">xflag</span><span class="p">;</span>

	<span class="n">port</span> <span class="o">=</span> <span class="n">port</span><span class="o">-&gt;</span><span class="n">physport</span><span class="p">;</span>

	<span class="cm">/* Is there anything to do? */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">ieee1284</span><span class="p">.</span><span class="n">mode</span> <span class="o">==</span> <span class="n">mode</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Is the difference just an address-or-not bit? */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">ieee1284</span><span class="p">.</span><span class="n">mode</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">IEEE1284_ADDR</span><span class="p">)</span> <span class="o">==</span> <span class="p">(</span><span class="n">mode</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">IEEE1284_ADDR</span><span class="p">)){</span>
		<span class="n">port</span><span class="o">-&gt;</span><span class="n">ieee1284</span><span class="p">.</span><span class="n">mode</span> <span class="o">=</span> <span class="n">mode</span><span class="p">;</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Go to compatibility forward idle mode */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">ieee1284</span><span class="p">.</span><span class="n">mode</span> <span class="o">!=</span> <span class="n">IEEE1284_MODE_COMPAT</span><span class="p">)</span>
		<span class="n">parport_ieee1284_terminate</span> <span class="p">(</span><span class="n">port</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">mode</span> <span class="o">==</span> <span class="n">IEEE1284_MODE_COMPAT</span><span class="p">)</span>
		<span class="cm">/* Compatibility mode: no negotiation. */</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span> 

	<span class="k">switch</span> <span class="p">(</span><span class="n">mode</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">IEEE1284_MODE_ECPSWE</span>:
		<span class="n">m</span> <span class="o">=</span> <span class="n">IEEE1284_MODE_ECP</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">IEEE1284_MODE_EPPSL</span>:
	<span class="k">case</span> <span class="n">IEEE1284_MODE_EPPSWE</span>:
		<span class="n">m</span> <span class="o">=</span> <span class="n">IEEE1284_MODE_EPP</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">IEEE1284_MODE_BECP</span>:
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOSYS</span><span class="p">;</span> <span class="cm">/* FIXME (implement BECP) */</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">mode</span> <span class="o">&amp;</span> <span class="n">IEEE1284_EXT_LINK</span><span class="p">)</span>
		<span class="n">m</span> <span class="o">=</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">7</span><span class="p">;</span> <span class="cm">/* request extensibility link */</span>

	<span class="n">port</span><span class="o">-&gt;</span><span class="n">ieee1284</span><span class="p">.</span><span class="n">phase</span> <span class="o">=</span> <span class="n">IEEE1284_PH_NEGOTIATION</span><span class="p">;</span>

	<span class="cm">/* Start off with nStrobe and nAutoFd high, and nSelectIn low */</span>
	<span class="n">parport_frob_control</span> <span class="p">(</span><span class="n">port</span><span class="p">,</span>
			      <span class="n">PARPORT_CONTROL_STROBE</span>
			      <span class="o">|</span> <span class="n">PARPORT_CONTROL_AUTOFD</span>
			      <span class="o">|</span> <span class="n">PARPORT_CONTROL_SELECT</span><span class="p">,</span>
			      <span class="n">PARPORT_CONTROL_SELECT</span><span class="p">);</span>
	<span class="n">udelay</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>

	<span class="cm">/* Event 0: Set data */</span>
	<span class="n">parport_data_forward</span> <span class="p">(</span><span class="n">port</span><span class="p">);</span>
	<span class="n">parport_write_data</span> <span class="p">(</span><span class="n">port</span><span class="p">,</span> <span class="n">m</span><span class="p">);</span>
	<span class="n">udelay</span> <span class="p">(</span><span class="mi">400</span><span class="p">);</span> <span class="cm">/* Shouldn&#39;t need to wait this long. */</span>

	<span class="cm">/* Event 1: Set nSelectIn high, nAutoFd low */</span>
	<span class="n">parport_frob_control</span> <span class="p">(</span><span class="n">port</span><span class="p">,</span>
			      <span class="n">PARPORT_CONTROL_SELECT</span>
			      <span class="o">|</span> <span class="n">PARPORT_CONTROL_AUTOFD</span><span class="p">,</span>
			      <span class="n">PARPORT_CONTROL_AUTOFD</span><span class="p">);</span>

	<span class="cm">/* Event 2: PError, Select, nFault go high, nAck goes low */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">parport_wait_peripheral</span> <span class="p">(</span><span class="n">port</span><span class="p">,</span>
				     <span class="n">PARPORT_STATUS_ERROR</span>
				     <span class="o">|</span> <span class="n">PARPORT_STATUS_SELECT</span>
				     <span class="o">|</span> <span class="n">PARPORT_STATUS_PAPEROUT</span>
				     <span class="o">|</span> <span class="n">PARPORT_STATUS_ACK</span><span class="p">,</span>
				     <span class="n">PARPORT_STATUS_ERROR</span>
				     <span class="o">|</span> <span class="n">PARPORT_STATUS_SELECT</span>
				     <span class="o">|</span> <span class="n">PARPORT_STATUS_PAPEROUT</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* Timeout */</span>
		<span class="n">parport_frob_control</span> <span class="p">(</span><span class="n">port</span><span class="p">,</span>
				      <span class="n">PARPORT_CONTROL_SELECT</span>
				      <span class="o">|</span> <span class="n">PARPORT_CONTROL_AUTOFD</span><span class="p">,</span>
				      <span class="n">PARPORT_CONTROL_SELECT</span><span class="p">);</span>
		<span class="n">DPRINTK</span> <span class="p">(</span><span class="n">KERN_DEBUG</span>
			 <span class="s">&quot;%s: Peripheral not IEEE1284 compliant (0x%02X)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			 <span class="n">port</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">parport_read_status</span> <span class="p">(</span><span class="n">port</span><span class="p">));</span>
		<span class="n">port</span><span class="o">-&gt;</span><span class="n">ieee1284</span><span class="p">.</span><span class="n">phase</span> <span class="o">=</span> <span class="n">IEEE1284_PH_FWD_IDLE</span><span class="p">;</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="cm">/* Not IEEE1284 compliant */</span>
	<span class="p">}</span>

	<span class="cm">/* Event 3: Set nStrobe low */</span>
	<span class="n">parport_frob_control</span> <span class="p">(</span><span class="n">port</span><span class="p">,</span>
			      <span class="n">PARPORT_CONTROL_STROBE</span><span class="p">,</span>
			      <span class="n">PARPORT_CONTROL_STROBE</span><span class="p">);</span>

	<span class="cm">/* Event 4: Set nStrobe and nAutoFd high */</span>
	<span class="n">udelay</span> <span class="p">(</span><span class="mi">5</span><span class="p">);</span>
	<span class="n">parport_frob_control</span> <span class="p">(</span><span class="n">port</span><span class="p">,</span>
			      <span class="n">PARPORT_CONTROL_STROBE</span>
			      <span class="o">|</span> <span class="n">PARPORT_CONTROL_AUTOFD</span><span class="p">,</span>
			      <span class="mi">0</span><span class="p">);</span>

	<span class="cm">/* Event 6: nAck goes high */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">parport_wait_peripheral</span> <span class="p">(</span><span class="n">port</span><span class="p">,</span>
				     <span class="n">PARPORT_STATUS_ACK</span><span class="p">,</span>
				     <span class="n">PARPORT_STATUS_ACK</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* This shouldn&#39;t really happen with a compliant device. */</span>
		<span class="n">DPRINTK</span> <span class="p">(</span><span class="n">KERN_DEBUG</span>
			 <span class="s">&quot;%s: Mode 0x%02x not supported? (0x%02x)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			 <span class="n">port</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="n">port</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">read_status</span> <span class="p">(</span><span class="n">port</span><span class="p">));</span>
		<span class="n">parport_ieee1284_terminate</span> <span class="p">(</span><span class="n">port</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">xflag</span> <span class="o">=</span> <span class="n">parport_read_status</span> <span class="p">(</span><span class="n">port</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">PARPORT_STATUS_SELECT</span><span class="p">;</span>

	<span class="cm">/* xflag should be high for all modes other than nibble (0). */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mode</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">xflag</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Mode not supported. */</span>
		<span class="n">DPRINTK</span> <span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;%s: Mode 0x%02x rejected by peripheral</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			 <span class="n">port</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">mode</span><span class="p">);</span>
		<span class="n">parport_ieee1284_terminate</span> <span class="p">(</span><span class="n">port</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* More to do if we&#39;ve requested extensibility link. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mode</span> <span class="o">&amp;</span> <span class="n">IEEE1284_EXT_LINK</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">m</span> <span class="o">=</span> <span class="n">mode</span> <span class="o">&amp;</span> <span class="mh">0x7f</span><span class="p">;</span>
		<span class="n">udelay</span> <span class="p">(</span><span class="mi">1</span><span class="p">);</span>
		<span class="n">parport_write_data</span> <span class="p">(</span><span class="n">port</span><span class="p">,</span> <span class="n">m</span><span class="p">);</span>
		<span class="n">udelay</span> <span class="p">(</span><span class="mi">1</span><span class="p">);</span>

		<span class="cm">/* Event 51: Set nStrobe low */</span>
		<span class="n">parport_frob_control</span> <span class="p">(</span><span class="n">port</span><span class="p">,</span>
				      <span class="n">PARPORT_CONTROL_STROBE</span><span class="p">,</span>
				      <span class="n">PARPORT_CONTROL_STROBE</span><span class="p">);</span>

		<span class="cm">/* Event 52: nAck goes low */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">parport_wait_peripheral</span> <span class="p">(</span><span class="n">port</span><span class="p">,</span> <span class="n">PARPORT_STATUS_ACK</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/* This peripheral is _very_ slow. */</span>
			<span class="n">DPRINTK</span> <span class="p">(</span><span class="n">KERN_DEBUG</span>
				 <span class="s">&quot;%s: Event 52 didn&#39;t happen</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				 <span class="n">port</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
			<span class="n">parport_ieee1284_terminate</span> <span class="p">(</span><span class="n">port</span><span class="p">);</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* Event 53: Set nStrobe high */</span>
		<span class="n">parport_frob_control</span> <span class="p">(</span><span class="n">port</span><span class="p">,</span>
				      <span class="n">PARPORT_CONTROL_STROBE</span><span class="p">,</span>
				      <span class="mi">0</span><span class="p">);</span>

		<span class="cm">/* Event 55: nAck goes high */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">parport_wait_peripheral</span> <span class="p">(</span><span class="n">port</span><span class="p">,</span>
					     <span class="n">PARPORT_STATUS_ACK</span><span class="p">,</span>
					     <span class="n">PARPORT_STATUS_ACK</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/* This shouldn&#39;t really happen with a compliant</span>
<span class="cm">			 * device. */</span>
			<span class="n">DPRINTK</span> <span class="p">(</span><span class="n">KERN_DEBUG</span>
				 <span class="s">&quot;%s: Mode 0x%02x not supported? (0x%02x)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				 <span class="n">port</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span>
				 <span class="n">port</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">read_status</span> <span class="p">(</span><span class="n">port</span><span class="p">));</span>
			<span class="n">parport_ieee1284_terminate</span> <span class="p">(</span><span class="n">port</span><span class="p">);</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* Event 54: Peripheral sets XFlag to reflect support */</span>
		<span class="n">xflag</span> <span class="o">=</span> <span class="n">parport_read_status</span> <span class="p">(</span><span class="n">port</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">PARPORT_STATUS_SELECT</span><span class="p">;</span>

		<span class="cm">/* xflag should be high. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">xflag</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Extended mode not supported. */</span>
			<span class="n">DPRINTK</span> <span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;%s: Extended mode 0x%02x not &quot;</span>
				 <span class="s">&quot;supported</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">port</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">mode</span><span class="p">);</span>
			<span class="n">parport_ieee1284_terminate</span> <span class="p">(</span><span class="n">port</span><span class="p">);</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* Any further setup is left to the caller. */</span>
	<span class="p">}</span>

	<span class="cm">/* Mode is supported */</span>
	<span class="n">DPRINTK</span> <span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;%s: In mode 0x%02x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">port</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">mode</span><span class="p">);</span>
	<span class="n">port</span><span class="o">-&gt;</span><span class="n">ieee1284</span><span class="p">.</span><span class="n">mode</span> <span class="o">=</span> <span class="n">mode</span><span class="p">;</span>

	<span class="cm">/* But ECP is special */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">mode</span> <span class="o">&amp;</span> <span class="n">IEEE1284_EXT_LINK</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">m</span> <span class="o">&amp;</span> <span class="n">IEEE1284_MODE_ECP</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">port</span><span class="o">-&gt;</span><span class="n">ieee1284</span><span class="p">.</span><span class="n">phase</span> <span class="o">=</span> <span class="n">IEEE1284_PH_ECP_SETUP</span><span class="p">;</span>

		<span class="cm">/* Event 30: Set nAutoFd low */</span>
		<span class="n">parport_frob_control</span> <span class="p">(</span><span class="n">port</span><span class="p">,</span>
				      <span class="n">PARPORT_CONTROL_AUTOFD</span><span class="p">,</span>
				      <span class="n">PARPORT_CONTROL_AUTOFD</span><span class="p">);</span>

		<span class="cm">/* Event 31: PError goes high. */</span>
		<span class="n">r</span> <span class="o">=</span> <span class="n">parport_wait_peripheral</span> <span class="p">(</span><span class="n">port</span><span class="p">,</span>
					     <span class="n">PARPORT_STATUS_PAPEROUT</span><span class="p">,</span>
					     <span class="n">PARPORT_STATUS_PAPEROUT</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">DPRINTK</span> <span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;%s: Timeout at event 31</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">port</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="n">port</span><span class="o">-&gt;</span><span class="n">ieee1284</span><span class="p">.</span><span class="n">phase</span> <span class="o">=</span> <span class="n">IEEE1284_PH_FWD_IDLE</span><span class="p">;</span>
		<span class="n">DPRINTK</span> <span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;%s: ECP direction: forward</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			 <span class="n">port</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">switch</span> <span class="p">(</span><span class="n">mode</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">IEEE1284_MODE_NIBBLE</span>:
	<span class="k">case</span> <span class="n">IEEE1284_MODE_BYTE</span>:
		<span class="n">port</span><span class="o">-&gt;</span><span class="n">ieee1284</span><span class="p">.</span><span class="n">phase</span> <span class="o">=</span> <span class="n">IEEE1284_PH_REV_IDLE</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">port</span><span class="o">-&gt;</span><span class="n">ieee1284</span><span class="p">.</span><span class="n">phase</span> <span class="o">=</span> <span class="n">IEEE1284_PH_FWD_IDLE</span><span class="p">;</span>
	<span class="p">}</span>


	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="cp">#endif </span><span class="cm">/* IEEE1284 support */</span><span class="cp"></span>
<span class="p">}</span>

<span class="cm">/* Acknowledge that the peripheral has data available.</span>
<span class="cm"> * Events 18-20, in order to get from Reverse Idle phase</span>
<span class="cm"> * to Host Busy Data Available.</span>
<span class="cm"> * This will most likely be called from an interrupt.</span>
<span class="cm"> * Returns zero if data was available.</span>
<span class="cm"> */</span>
<span class="cp">#ifdef CONFIG_PARPORT_1284</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">parport_ieee1284_ack_data_avail</span> <span class="p">(</span><span class="k">struct</span> <span class="n">parport</span> <span class="o">*</span><span class="n">port</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">parport_read_status</span> <span class="p">(</span><span class="n">port</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">PARPORT_STATUS_ERROR</span><span class="p">)</span>
		<span class="cm">/* Event 18 didn&#39;t happen. */</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="cm">/* Event 20: nAutoFd goes high. */</span>
	<span class="n">port</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">frob_control</span> <span class="p">(</span><span class="n">port</span><span class="p">,</span> <span class="n">PARPORT_CONTROL_AUTOFD</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">port</span><span class="o">-&gt;</span><span class="n">ieee1284</span><span class="p">.</span><span class="n">phase</span> <span class="o">=</span> <span class="n">IEEE1284_PH_HBUSY_DAVAIL</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* IEEE1284 support */</span><span class="cp"></span>

<span class="cm">/* Handle an interrupt. */</span>
<span class="kt">void</span> <span class="nf">parport_ieee1284_interrupt</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">handle</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">parport</span> <span class="o">*</span><span class="n">port</span> <span class="o">=</span> <span class="n">handle</span><span class="p">;</span>
	<span class="n">parport_ieee1284_wakeup</span> <span class="p">(</span><span class="n">port</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_PARPORT_1284</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">ieee1284</span><span class="p">.</span><span class="n">phase</span> <span class="o">==</span> <span class="n">IEEE1284_PH_REV_IDLE</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* An interrupt in this phase means that data</span>
<span class="cm">		 * is now available. */</span>
		<span class="n">DPRINTK</span> <span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;%s: Data available</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">port</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="n">parport_ieee1284_ack_data_avail</span> <span class="p">(</span><span class="n">port</span><span class="p">);</span>
	<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* IEEE1284 support */</span><span class="cp"></span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	parport_write - write a block of data to a parallel port</span>
<span class="cm"> *	@port: port to write to</span>
<span class="cm"> *	@buffer: data buffer (in kernel space)</span>
<span class="cm"> *	@len: number of bytes of data to transfer</span>
<span class="cm"> *</span>
<span class="cm"> *	This will write up to @len bytes of @buffer to the port</span>
<span class="cm"> *	specified, using the IEEE 1284 transfer mode most recently</span>
<span class="cm"> *	negotiated to (using parport_negotiate()), as long as that</span>
<span class="cm"> *	mode supports forward transfers (host to peripheral).</span>
<span class="cm"> *</span>
<span class="cm"> *	It is the caller&#39;s responsibility to ensure that the first</span>
<span class="cm"> *	@len bytes of @buffer are valid.</span>
<span class="cm"> *</span>
<span class="cm"> *	This function returns the number of bytes transferred (if zero</span>
<span class="cm"> *	or positive), or else an error code.</span>
<span class="cm"> */</span>

<span class="kt">ssize_t</span> <span class="nf">parport_write</span> <span class="p">(</span><span class="k">struct</span> <span class="n">parport</span> <span class="o">*</span><span class="n">port</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifndef CONFIG_PARPORT_1284</span>
	<span class="k">return</span> <span class="n">port</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">compat_write_data</span> <span class="p">(</span><span class="n">port</span><span class="p">,</span> <span class="n">buffer</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="cp">#else</span>
	<span class="kt">ssize_t</span> <span class="n">retval</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">mode</span> <span class="o">=</span> <span class="n">port</span><span class="o">-&gt;</span><span class="n">ieee1284</span><span class="p">.</span><span class="n">mode</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">addr</span> <span class="o">=</span> <span class="n">mode</span> <span class="o">&amp;</span> <span class="n">IEEE1284_ADDR</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="p">(</span><span class="o">*</span><span class="n">fn</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">parport</span> <span class="o">*</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="p">,</span> <span class="kt">size_t</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>

	<span class="cm">/* Ignore the device-ID-request bit and the address bit. */</span>
	<span class="n">mode</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">IEEE1284_DEVICEID</span> <span class="o">|</span> <span class="n">IEEE1284_ADDR</span><span class="p">);</span>

	<span class="cm">/* Use the mode we&#39;re in. */</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">mode</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">IEEE1284_MODE_NIBBLE</span>:
	<span class="k">case</span> <span class="n">IEEE1284_MODE_BYTE</span>:
		<span class="n">parport_negotiate</span> <span class="p">(</span><span class="n">port</span><span class="p">,</span> <span class="n">IEEE1284_MODE_COMPAT</span><span class="p">);</span>
	<span class="k">case</span> <span class="n">IEEE1284_MODE_COMPAT</span>:
		<span class="n">DPRINTK</span> <span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;%s: Using compatibility mode</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			 <span class="n">port</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="n">fn</span> <span class="o">=</span> <span class="n">port</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">compat_write_data</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">IEEE1284_MODE_EPP</span>:
		<span class="n">DPRINTK</span> <span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;%s: Using EPP mode</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">port</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">addr</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">fn</span> <span class="o">=</span> <span class="n">port</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">epp_write_addr</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">fn</span> <span class="o">=</span> <span class="n">port</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">epp_write_data</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">IEEE1284_MODE_EPPSWE</span>:
		<span class="n">DPRINTK</span> <span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;%s: Using software-emulated EPP mode</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">port</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">addr</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">fn</span> <span class="o">=</span> <span class="n">parport_ieee1284_epp_write_addr</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">fn</span> <span class="o">=</span> <span class="n">parport_ieee1284_epp_write_data</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">IEEE1284_MODE_ECP</span>:
	<span class="k">case</span> <span class="n">IEEE1284_MODE_ECPRLE</span>:
		<span class="n">DPRINTK</span> <span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;%s: Using ECP mode</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">port</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">addr</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">fn</span> <span class="o">=</span> <span class="n">port</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">ecp_write_addr</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">fn</span> <span class="o">=</span> <span class="n">port</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">ecp_write_data</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">IEEE1284_MODE_ECPSWE</span>:
		<span class="n">DPRINTK</span> <span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;%s: Using software-emulated ECP mode</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			 <span class="n">port</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="cm">/* The caller has specified that it must be emulated,</span>
<span class="cm">		 * even if we have ECP hardware! */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">addr</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">fn</span> <span class="o">=</span> <span class="n">parport_ieee1284_ecp_write_addr</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">fn</span> <span class="o">=</span> <span class="n">parport_ieee1284_ecp_write_data</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="nl">default:</span>
		<span class="n">DPRINTK</span> <span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;%s: Unknown mode 0x%02x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">port</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span>
			<span class="n">port</span><span class="o">-&gt;</span><span class="n">ieee1284</span><span class="p">.</span><span class="n">mode</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOSYS</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">retval</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="n">fn</span><span class="p">)</span> <span class="p">(</span><span class="n">port</span><span class="p">,</span> <span class="n">buffer</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">DPRINTK</span> <span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;%s: wrote %d/%d bytes</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">port</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">retval</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="cp">#endif </span><span class="cm">/* IEEE1284 support */</span><span class="cp"></span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	parport_read - read a block of data from a parallel port</span>
<span class="cm"> *	@port: port to read from</span>
<span class="cm"> *	@buffer: data buffer (in kernel space)</span>
<span class="cm"> *	@len: number of bytes of data to transfer</span>
<span class="cm"> *</span>
<span class="cm"> *	This will read up to @len bytes of @buffer to the port</span>
<span class="cm"> *	specified, using the IEEE 1284 transfer mode most recently</span>
<span class="cm"> *	negotiated to (using parport_negotiate()), as long as that</span>
<span class="cm"> *	mode supports reverse transfers (peripheral to host).</span>
<span class="cm"> *</span>
<span class="cm"> *	It is the caller&#39;s responsibility to ensure that the first</span>
<span class="cm"> *	@len bytes of @buffer are available to write to.</span>
<span class="cm"> *</span>
<span class="cm"> *	This function returns the number of bytes transferred (if zero</span>
<span class="cm"> *	or positive), or else an error code.</span>
<span class="cm"> */</span>

<span class="kt">ssize_t</span> <span class="nf">parport_read</span> <span class="p">(</span><span class="k">struct</span> <span class="n">parport</span> <span class="o">*</span><span class="n">port</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifndef CONFIG_PARPORT_1284</span>
	<span class="n">printk</span> <span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;parport: IEEE1284 not supported in this kernel</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
<span class="cp">#else</span>
	<span class="kt">int</span> <span class="n">mode</span> <span class="o">=</span> <span class="n">port</span><span class="o">-&gt;</span><span class="n">physport</span><span class="o">-&gt;</span><span class="n">ieee1284</span><span class="p">.</span><span class="n">mode</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">addr</span> <span class="o">=</span> <span class="n">mode</span> <span class="o">&amp;</span> <span class="n">IEEE1284_ADDR</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="p">(</span><span class="o">*</span><span class="n">fn</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">parport</span> <span class="o">*</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="p">,</span> <span class="kt">size_t</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>

	<span class="cm">/* Ignore the device-ID-request bit and the address bit. */</span>
	<span class="n">mode</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">IEEE1284_DEVICEID</span> <span class="o">|</span> <span class="n">IEEE1284_ADDR</span><span class="p">);</span>

	<span class="cm">/* Use the mode we&#39;re in. */</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">mode</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">IEEE1284_MODE_COMPAT</span>:
		<span class="cm">/* if we can tri-state use BYTE mode instead of NIBBLE mode,</span>
<span class="cm">		 * if that fails, revert to NIBBLE mode -- ought to store somewhere</span>
<span class="cm">		 * the device&#39;s ability to do BYTE mode reverse transfers, so we don&#39;t</span>
<span class="cm">		 * end up needlessly calling negotiate(BYTE) repeately..  (fb)</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">physport</span><span class="o">-&gt;</span><span class="n">modes</span> <span class="o">&amp;</span> <span class="n">PARPORT_MODE_TRISTATE</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="o">!</span><span class="n">parport_negotiate</span> <span class="p">(</span><span class="n">port</span><span class="p">,</span> <span class="n">IEEE1284_MODE_BYTE</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/* got into BYTE mode OK */</span>
			<span class="n">DPRINTK</span> <span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;%s: Using byte mode</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">port</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
			<span class="n">fn</span> <span class="o">=</span> <span class="n">port</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">byte_read_data</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">parport_negotiate</span> <span class="p">(</span><span class="n">port</span><span class="p">,</span> <span class="n">IEEE1284_MODE_NIBBLE</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/* fall through to NIBBLE */</span>
	<span class="k">case</span> <span class="n">IEEE1284_MODE_NIBBLE</span>:
		<span class="n">DPRINTK</span> <span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;%s: Using nibble mode</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">port</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="n">fn</span> <span class="o">=</span> <span class="n">port</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">nibble_read_data</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">IEEE1284_MODE_BYTE</span>:
		<span class="n">DPRINTK</span> <span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;%s: Using byte mode</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">port</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="n">fn</span> <span class="o">=</span> <span class="n">port</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">byte_read_data</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">IEEE1284_MODE_EPP</span>:
		<span class="n">DPRINTK</span> <span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;%s: Using EPP mode</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">port</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">addr</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">fn</span> <span class="o">=</span> <span class="n">port</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">epp_read_addr</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">fn</span> <span class="o">=</span> <span class="n">port</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">epp_read_data</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">IEEE1284_MODE_EPPSWE</span>:
		<span class="n">DPRINTK</span> <span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;%s: Using software-emulated EPP mode</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">port</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">addr</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">fn</span> <span class="o">=</span> <span class="n">parport_ieee1284_epp_read_addr</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">fn</span> <span class="o">=</span> <span class="n">parport_ieee1284_epp_read_data</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">IEEE1284_MODE_ECP</span>:
	<span class="k">case</span> <span class="n">IEEE1284_MODE_ECPRLE</span>:
		<span class="n">DPRINTK</span> <span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;%s: Using ECP mode</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">port</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="n">fn</span> <span class="o">=</span> <span class="n">port</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">ecp_read_data</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">IEEE1284_MODE_ECPSWE</span>:
		<span class="n">DPRINTK</span> <span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;%s: Using software-emulated ECP mode</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			 <span class="n">port</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="n">fn</span> <span class="o">=</span> <span class="n">parport_ieee1284_ecp_read_data</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="nl">default:</span>
		<span class="n">DPRINTK</span> <span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;%s: Unknown mode 0x%02x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">port</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span>
			 <span class="n">port</span><span class="o">-&gt;</span><span class="n">physport</span><span class="o">-&gt;</span><span class="n">ieee1284</span><span class="p">.</span><span class="n">mode</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOSYS</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="p">(</span><span class="o">*</span><span class="n">fn</span><span class="p">)</span> <span class="p">(</span><span class="n">port</span><span class="p">,</span> <span class="n">buffer</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="cp">#endif </span><span class="cm">/* IEEE1284 support */</span><span class="cp"></span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	parport_set_timeout - set the inactivity timeout for a device</span>
<span class="cm"> *	@dev: device on a port</span>
<span class="cm"> *	@inactivity: inactivity timeout (in jiffies)</span>
<span class="cm"> *</span>
<span class="cm"> *	This sets the inactivity timeout for a particular device on a</span>
<span class="cm"> *	port.  This affects functions like parport_wait_peripheral().</span>
<span class="cm"> *	The special value 0 means not to call schedule() while dealing</span>
<span class="cm"> *	with this device.</span>
<span class="cm"> *</span>
<span class="cm"> *	The return value is the previous inactivity timeout.</span>
<span class="cm"> *</span>
<span class="cm"> *	Any callers of parport_wait_event() for this device are woken</span>
<span class="cm"> *	up.</span>
<span class="cm"> */</span>

<span class="kt">long</span> <span class="nf">parport_set_timeout</span> <span class="p">(</span><span class="k">struct</span> <span class="n">pardevice</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">long</span> <span class="n">inactivity</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">long</span> <span class="kt">int</span> <span class="n">old</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">timeout</span><span class="p">;</span>

	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">timeout</span> <span class="o">=</span> <span class="n">inactivity</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">port</span><span class="o">-&gt;</span><span class="n">physport</span><span class="o">-&gt;</span><span class="n">cad</span> <span class="o">==</span> <span class="n">dev</span><span class="p">)</span>
		<span class="n">parport_ieee1284_wakeup</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">port</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">old</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Exported symbols for modules. */</span>

<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">parport_negotiate</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">parport_write</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">parport_read</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">parport_wait_peripheral</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">parport_wait_event</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">parport_set_timeout</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">parport_ieee1284_interrupt</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
