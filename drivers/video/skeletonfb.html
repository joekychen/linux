<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › video › skeletonfb.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>skeletonfb.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * linux/drivers/video/skeletonfb.c -- Skeleton for a frame buffer device</span>
<span class="cm"> *</span>
<span class="cm"> *  Modified to new api Jan 2001 by James Simmons (jsimmons@transvirtual.com)</span>
<span class="cm"> *</span>
<span class="cm"> *  Created 28 Dec 1997 by Geert Uytterhoeven</span>
<span class="cm"> *</span>
<span class="cm"> *</span>
<span class="cm"> *  I have started rewriting this driver as a example of the upcoming new API</span>
<span class="cm"> *  The primary goal is to remove the console code from fbdev and place it</span>
<span class="cm"> *  into fbcon.c. This reduces the code and makes writing a new fbdev driver</span>
<span class="cm"> *  easy since the author doesn&#39;t need to worry about console internals. It</span>
<span class="cm"> *  also allows the ability to run fbdev without a console/tty system on top </span>
<span class="cm"> *  of it. </span>
<span class="cm"> *</span>
<span class="cm"> *  First the roles of struct fb_info and struct display have changed. Struct</span>
<span class="cm"> *  display will go away. The way the new framebuffer console code will</span>
<span class="cm"> *  work is that it will act to translate data about the tty/console in </span>
<span class="cm"> *  struct vc_data to data in a device independent way in struct fb_info. Then</span>
<span class="cm"> *  various functions in struct fb_ops will be called to store the device </span>
<span class="cm"> *  dependent state in the par field in struct fb_info and to change the </span>
<span class="cm"> *  hardware to that state. This allows a very clean separation of the fbdev</span>
<span class="cm"> *  layer from the console layer. It also allows one to use fbdev on its own</span>
<span class="cm"> *  which is a bounus for embedded devices. The reason this approach works is  </span>
<span class="cm"> *  for each framebuffer device when used as a tty/console device is allocated</span>
<span class="cm"> *  a set of virtual terminals to it. Only one virtual terminal can be active </span>
<span class="cm"> *  per framebuffer device. We already have all the data we need in struct </span>
<span class="cm"> *  vc_data so why store a bunch of colormaps and other fbdev specific data</span>
<span class="cm"> *  per virtual terminal. </span>
<span class="cm"> *</span>
<span class="cm"> *  As you can see doing this makes the con parameter pretty much useless</span>
<span class="cm"> *  for struct fb_ops functions, as it should be. Also having struct  </span>
<span class="cm"> *  fb_var_screeninfo and other data in fb_info pretty much eliminates the </span>
<span class="cm"> *  need for get_fix and get_var. Once all drivers use the fix, var, and cmap</span>
<span class="cm"> *  fbcon can be written around these fields. This will also eliminate the</span>
<span class="cm"> *  need to regenerate struct fb_var_screeninfo, struct fb_fix_screeninfo</span>
<span class="cm"> *  struct fb_cmap every time get_var, get_fix, get_cmap functions are called</span>
<span class="cm"> *  as many drivers do now. </span>
<span class="cm"> *</span>
<span class="cm"> *  This file is subject to the terms and conditions of the GNU General Public</span>
<span class="cm"> *  License. See the file COPYING in the main directory of this archive for</span>
<span class="cm"> *  more details.</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/errno.h&gt;</span>
<span class="cp">#include &lt;linux/string.h&gt;</span>
<span class="cp">#include &lt;linux/mm.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/delay.h&gt;</span>
<span class="cp">#include &lt;linux/fb.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/pci.h&gt;</span>

    <span class="cm">/*</span>
<span class="cm">     *  This is just simple sample code.</span>
<span class="cm">     *</span>
<span class="cm">     *  No warranty that it actually compiles.</span>
<span class="cm">     *  Even less warranty that it actually works :-)</span>
<span class="cm">     */</span>

<span class="cm">/*</span>
<span class="cm"> * Driver data</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">char</span> <span class="o">*</span><span class="n">mode_option</span> <span class="n">__devinitdata</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> *  If your driver supports multiple boards, you should make the  </span>
<span class="cm"> *  below data types arrays, or allocate them dynamically (using kmalloc()). </span>
<span class="cm"> */</span> 

<span class="cm">/* </span>
<span class="cm"> * This structure defines the hardware state of the graphics card. Normally</span>
<span class="cm"> * you place this in a header file in linux/include/video. This file usually</span>
<span class="cm"> * also includes register information. That allows other driver subsystems</span>
<span class="cm"> * and userland applications the ability to use the same header file to </span>
<span class="cm"> * avoid duplicate work and easy porting of software. </span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">xxx_par</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * Here we define the default structs fb_fix_screeninfo and fb_var_screeninfo</span>
<span class="cm"> * if we don&#39;t use modedb. If we do use modedb see xxxfb_init how to use it</span>
<span class="cm"> * to get a fb_var_screeninfo. Otherwise define a default var as well. </span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">fb_fix_screeninfo</span> <span class="n">xxxfb_fix</span> <span class="n">__devinitdata</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">id</span> <span class="o">=</span>		<span class="s">&quot;FB&#39;s name&quot;</span><span class="p">,</span> 
	<span class="p">.</span><span class="n">type</span> <span class="o">=</span>		<span class="n">FB_TYPE_PACKED_PIXELS</span><span class="p">,</span>
	<span class="p">.</span><span class="n">visual</span> <span class="o">=</span>	<span class="n">FB_VISUAL_PSEUDOCOLOR</span><span class="p">,</span>
	<span class="p">.</span><span class="n">xpanstep</span> <span class="o">=</span>	<span class="mi">1</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ypanstep</span> <span class="o">=</span>	<span class="mi">1</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ywrapstep</span> <span class="o">=</span>	<span class="mi">1</span><span class="p">,</span> 
	<span class="p">.</span><span class="n">accel</span> <span class="o">=</span>	<span class="n">FB_ACCEL_NONE</span><span class="p">,</span>
<span class="p">};</span>

    <span class="cm">/*</span>
<span class="cm">     * 	Modern graphical hardware not only supports pipelines but some </span>
<span class="cm">     *  also support multiple monitors where each display can have its  </span>
<span class="cm">     *  its own unique data. In this case each display could be  </span>
<span class="cm">     *  represented by a separate framebuffer device thus a separate </span>
<span class="cm">     *  struct fb_info. Now the struct xxx_par represents the graphics</span>
<span class="cm">     *  hardware state thus only one exist per card. In this case the </span>
<span class="cm">     *  struct xxx_par for each graphics card would be shared between </span>
<span class="cm">     *  every struct fb_info that represents a framebuffer on that card. </span>
<span class="cm">     *  This allows when one display changes it video resolution (info-&gt;var) </span>
<span class="cm">     *  the other displays know instantly. Each display can always be</span>
<span class="cm">     *  aware of the entire hardware state that affects it because they share</span>
<span class="cm">     *  the same xxx_par struct. The other side of the coin is multiple</span>
<span class="cm">     *  graphics cards that pass data around until it is finally displayed</span>
<span class="cm">     *  on one monitor. Such examples are the voodoo 1 cards and high end</span>
<span class="cm">     *  NUMA graphics servers. For this case we have a bunch of pars, each</span>
<span class="cm">     *  one that represents a graphics state, that belong to one struct </span>
<span class="cm">     *  fb_info. Their you would want to have *par point to a array of device</span>
<span class="cm">     *  states and have each struct fb_ops function deal with all those </span>
<span class="cm">     *  states. I hope this covers every possible hardware design. If not</span>
<span class="cm">     *  feel free to send your ideas at jsimmons@users.sf.net </span>
<span class="cm">     */</span>

    <span class="cm">/*</span>
<span class="cm">     *  If your driver supports multiple boards or it supports multiple </span>
<span class="cm">     *  framebuffers, you should make these arrays, or allocate them </span>
<span class="cm">     *  dynamically using framebuffer_alloc() and free them with</span>
<span class="cm">     *  framebuffer_release().</span>
<span class="cm">     */</span> 
<span class="k">static</span> <span class="k">struct</span> <span class="n">fb_info</span> <span class="n">info</span><span class="p">;</span>

    <span class="cm">/* </span>
<span class="cm">     * Each one represents the state of the hardware. Most hardware have</span>
<span class="cm">     * just one hardware state. These here represent the default state(s). </span>
<span class="cm">     */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">xxx_par</span> <span class="n">__initdata</span> <span class="n">current_par</span><span class="p">;</span>

<span class="kt">int</span> <span class="n">xxxfb_init</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> *	xxxfb_open - Optional function. Called when the framebuffer is</span>
<span class="cm"> *		     first accessed.</span>
<span class="cm"> *	@info: frame buffer structure that represents a single frame buffer</span>
<span class="cm"> *	@user: tell us if the userland (value=1) or the console is accessing</span>
<span class="cm"> *	       the framebuffer. </span>
<span class="cm"> *</span>
<span class="cm"> *	This function is the first function called in the framebuffer api.</span>
<span class="cm"> *	Usually you don&#39;t need to provide this function. The case where it </span>
<span class="cm"> *	is used is to change from a text mode hardware state to a graphics</span>
<span class="cm"> * 	mode state. </span>
<span class="cm"> *</span>
<span class="cm"> *	Returns negative errno on error, or zero on success.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">xxxfb_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">fb_info</span> <span class="o">*</span><span class="n">info</span><span class="p">,</span> <span class="kt">int</span> <span class="n">user</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	xxxfb_release - Optional function. Called when the framebuffer </span>
<span class="cm"> *			device is closed. </span>
<span class="cm"> *	@info: frame buffer structure that represents a single frame buffer</span>
<span class="cm"> *	@user: tell us if the userland (value=1) or the console is accessing</span>
<span class="cm"> *	       the framebuffer. </span>
<span class="cm"> *	</span>
<span class="cm"> *	Thus function is called when we close /dev/fb or the framebuffer </span>
<span class="cm"> *	console system is released. Usually you don&#39;t need this function.</span>
<span class="cm"> *	The case where it is usually used is to go from a graphics state</span>
<span class="cm"> *	to a text mode state.</span>
<span class="cm"> *</span>
<span class="cm"> *	Returns negative errno on error, or zero on success.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">xxxfb_release</span><span class="p">(</span><span class="k">struct</span> <span class="n">fb_info</span> <span class="o">*</span><span class="n">info</span><span class="p">,</span> <span class="kt">int</span> <span class="n">user</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *      xxxfb_check_var - Optional function. Validates a var passed in. </span>
<span class="cm"> *      @var: frame buffer variable screen structure</span>
<span class="cm"> *      @info: frame buffer structure that represents a single frame buffer </span>
<span class="cm"> *</span>
<span class="cm"> *	Checks to see if the hardware supports the state requested by</span>
<span class="cm"> *	var passed in. This function does not alter the hardware state!!! </span>
<span class="cm"> *	This means the data stored in struct fb_info and struct xxx_par do </span>
<span class="cm"> *      not change. This includes the var inside of struct fb_info. </span>
<span class="cm"> *	Do NOT change these. This function can be called on its own if we</span>
<span class="cm"> *	intent to only test a mode and not actually set it. The stuff in </span>
<span class="cm"> *	modedb.c is a example of this. If the var passed in is slightly </span>
<span class="cm"> *	off by what the hardware can support then we alter the var PASSED in</span>
<span class="cm"> *	to what we can do.</span>
<span class="cm"> *</span>
<span class="cm"> *      For values that are off, this function must round them _up_ to the</span>
<span class="cm"> *      next value that is supported by the hardware.  If the value is</span>
<span class="cm"> *      greater than the highest value supported by the hardware, then this</span>
<span class="cm"> *      function must return -EINVAL.</span>
<span class="cm"> *</span>
<span class="cm"> *      Exception to the above rule:  Some drivers have a fixed mode, ie,</span>
<span class="cm"> *      the hardware is already set at boot up, and cannot be changed.  In</span>
<span class="cm"> *      this case, it is more acceptable that this function just return</span>
<span class="cm"> *      a copy of the currently working var (info-&gt;var). Better is to not</span>
<span class="cm"> *      implement this function, as the upper layer will do the copying</span>
<span class="cm"> *      of the current var for you.</span>
<span class="cm"> *</span>
<span class="cm"> *      Note:  This is the only function where the contents of var can be</span>
<span class="cm"> *      freely adjusted after the driver has been registered. If you find</span>
<span class="cm"> *      that you have code outside of this function that alters the content</span>
<span class="cm"> *      of var, then you are doing something wrong.  Note also that the</span>
<span class="cm"> *      contents of info-&gt;var must be left untouched at all times after</span>
<span class="cm"> *      driver registration.</span>
<span class="cm"> *</span>
<span class="cm"> *	Returns negative errno on error, or zero on success.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">xxxfb_check_var</span><span class="p">(</span><span class="k">struct</span> <span class="n">fb_var_screeninfo</span> <span class="o">*</span><span class="n">var</span><span class="p">,</span> <span class="k">struct</span> <span class="n">fb_info</span> <span class="o">*</span><span class="n">info</span><span class="p">)</span>
<span class="p">{</span>
    <span class="cm">/* ... */</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>	   	
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *      xxxfb_set_par - Optional function. Alters the hardware state.</span>
<span class="cm"> *      @info: frame buffer structure that represents a single frame buffer</span>
<span class="cm"> *</span>
<span class="cm"> *	Using the fb_var_screeninfo in fb_info we set the resolution of the</span>
<span class="cm"> *	this particular framebuffer. This function alters the par AND the</span>
<span class="cm"> *	fb_fix_screeninfo stored in fb_info. It doesn&#39;t not alter var in </span>
<span class="cm"> *	fb_info since we are using that data. This means we depend on the</span>
<span class="cm"> *	data in var inside fb_info to be supported by the hardware. </span>
<span class="cm"> *</span>
<span class="cm"> *      This function is also used to recover/restore the hardware to a</span>
<span class="cm"> *      known working state.</span>
<span class="cm"> *</span>
<span class="cm"> *	xxxfb_check_var is always called before xxxfb_set_par to ensure that</span>
<span class="cm"> *      the contents of var is always valid.</span>
<span class="cm"> *</span>
<span class="cm"> *	Again if you can&#39;t change the resolution you don&#39;t need this function.</span>
<span class="cm"> *</span>
<span class="cm"> *      However, even if your hardware does not support mode changing,</span>
<span class="cm"> *      a set_par might be needed to at least initialize the hardware to</span>
<span class="cm"> *      a known working state, especially if it came back from another</span>
<span class="cm"> *      process that also modifies the same hardware, such as X.</span>
<span class="cm"> *</span>
<span class="cm"> *      If this is the case, a combination such as the following should work:</span>
<span class="cm"> *</span>
<span class="cm"> *      static int xxxfb_check_var(struct fb_var_screeninfo *var,</span>
<span class="cm"> *                                struct fb_info *info)</span>
<span class="cm"> *      {</span>
<span class="cm"> *              *var = info-&gt;var;</span>
<span class="cm"> *              return 0;</span>
<span class="cm"> *      }</span>
<span class="cm"> *</span>
<span class="cm"> *      static int xxxfb_set_par(struct fb_info *info)</span>
<span class="cm"> *      {</span>
<span class="cm"> *              init your hardware here</span>
<span class="cm"> *      }</span>
<span class="cm"> *</span>
<span class="cm"> *	Returns negative errno on error, or zero on success.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">xxxfb_set_par</span><span class="p">(</span><span class="k">struct</span> <span class="n">fb_info</span> <span class="o">*</span><span class="n">info</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">struct</span> <span class="n">xxx_par</span> <span class="o">*</span><span class="n">par</span> <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">par</span><span class="p">;</span>
    <span class="cm">/* ... */</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>	
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *  	xxxfb_setcolreg - Optional function. Sets a color register.</span>
<span class="cm"> *      @regno: Which register in the CLUT we are programming </span>
<span class="cm"> *      @red: The red value which can be up to 16 bits wide </span>
<span class="cm"> *	@green: The green value which can be up to 16 bits wide </span>
<span class="cm"> *	@blue:  The blue value which can be up to 16 bits wide.</span>
<span class="cm"> *	@transp: If supported, the alpha value which can be up to 16 bits wide.</span>
<span class="cm"> *      @info: frame buffer info structure</span>
<span class="cm"> * </span>
<span class="cm"> *  	Set a single color register. The values supplied have a 16 bit</span>
<span class="cm"> *  	magnitude which needs to be scaled in this function for the hardware. </span>
<span class="cm"> *	Things to take into consideration are how many color registers, if</span>
<span class="cm"> *	any, are supported with the current color visual. With truecolor mode</span>
<span class="cm"> *	no color palettes are supported. Here a pseudo palette is created</span>
<span class="cm"> *	which we store the value in pseudo_palette in struct fb_info. For</span>
<span class="cm"> *	pseudocolor mode we have a limited color palette. To deal with this</span>
<span class="cm"> *	we can program what color is displayed for a particular pixel value.</span>
<span class="cm"> *	DirectColor is similar in that we can program each color field. If</span>
<span class="cm"> *	we have a static colormap we don&#39;t need to implement this function. </span>
<span class="cm"> * </span>
<span class="cm"> *	Returns negative errno on error, or zero on success.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">xxxfb_setcolreg</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">regno</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">red</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">green</span><span class="p">,</span>
			   <span class="kt">unsigned</span> <span class="n">blue</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">transp</span><span class="p">,</span>
			   <span class="k">struct</span> <span class="n">fb_info</span> <span class="o">*</span><span class="n">info</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">regno</span> <span class="o">&gt;=</span> <span class="mi">256</span><span class="p">)</span>  <span class="cm">/* no. of hw registers */</span>
       <span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
    <span class="cm">/*</span>
<span class="cm">     * Program hardware... do anything you want with transp</span>
<span class="cm">     */</span>

    <span class="cm">/* grayscale works only partially under directcolor */</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">var</span><span class="p">.</span><span class="n">grayscale</span><span class="p">)</span> <span class="p">{</span>
       <span class="cm">/* grayscale = 0.30*R + 0.59*G + 0.11*B */</span>
       <span class="n">red</span> <span class="o">=</span> <span class="n">green</span> <span class="o">=</span> <span class="n">blue</span> <span class="o">=</span> <span class="p">(</span><span class="n">red</span> <span class="o">*</span> <span class="mi">77</span> <span class="o">+</span> <span class="n">green</span> <span class="o">*</span> <span class="mi">151</span> <span class="o">+</span> <span class="n">blue</span> <span class="o">*</span> <span class="mi">28</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="cm">/* Directcolor:</span>
<span class="cm">     *   var-&gt;{color}.offset contains start of bitfield</span>
<span class="cm">     *   var-&gt;{color}.length contains length of bitfield</span>
<span class="cm">     *   {hardwarespecific} contains width of DAC</span>
<span class="cm">     *   pseudo_palette[X] is programmed to (X &lt;&lt; red.offset) |</span>
<span class="cm">     *                                      (X &lt;&lt; green.offset) |</span>
<span class="cm">     *                                      (X &lt;&lt; blue.offset)</span>
<span class="cm">     *   RAMDAC[X] is programmed to (red, green, blue)</span>
<span class="cm">     *   color depth = SUM(var-&gt;{color}.length)</span>
<span class="cm">     *</span>
<span class="cm">     * Pseudocolor:</span>
<span class="cm">     *    var-&gt;{color}.offset is 0 unless the palette index takes less than</span>
<span class="cm">     *                        bits_per_pixel bits and is stored in the upper</span>
<span class="cm">     *                        bits of the pixel value</span>
<span class="cm">     *    var-&gt;{color}.length is set so that 1 &lt;&lt; length is the number of</span>
<span class="cm">     *                        available palette entries</span>
<span class="cm">     *    pseudo_palette is not used</span>
<span class="cm">     *    RAMDAC[X] is programmed to (red, green, blue)</span>
<span class="cm">     *    color depth = var-&gt;{color}.length</span>
<span class="cm">     *</span>
<span class="cm">     * Static pseudocolor:</span>
<span class="cm">     *    same as Pseudocolor, but the RAMDAC is not programmed (read-only)</span>
<span class="cm">     *</span>
<span class="cm">     * Mono01/Mono10:</span>
<span class="cm">     *    Has only 2 values, black on white or white on black (fg on bg),</span>
<span class="cm">     *    var-&gt;{color}.offset is 0</span>
<span class="cm">     *    white = (1 &lt;&lt; var-&gt;{color}.length) - 1, black = 0</span>
<span class="cm">     *    pseudo_palette is not used</span>
<span class="cm">     *    RAMDAC does not exist</span>
<span class="cm">     *    color depth is always 2</span>
<span class="cm">     *</span>
<span class="cm">     * Truecolor:</span>
<span class="cm">     *    does not use RAMDAC (usually has 3 of them).</span>
<span class="cm">     *    var-&gt;{color}.offset contains start of bitfield</span>
<span class="cm">     *    var-&gt;{color}.length contains length of bitfield</span>
<span class="cm">     *    pseudo_palette is programmed to (red &lt;&lt; red.offset) |</span>
<span class="cm">     *                                    (green &lt;&lt; green.offset) |</span>
<span class="cm">     *                                    (blue &lt;&lt; blue.offset) |</span>
<span class="cm">     *                                    (transp &lt;&lt; transp.offset)</span>
<span class="cm">     *    RAMDAC does not exist</span>
<span class="cm">     *    color depth = SUM(var-&gt;{color}.length})</span>
<span class="cm">     *</span>
<span class="cm">     *  The color depth is used by fbcon for choosing the logo and also</span>
<span class="cm">     *  for color palette transformation if color depth &lt; 4</span>
<span class="cm">     *</span>
<span class="cm">     *  As can be seen from the above, the field bits_per_pixel is _NOT_</span>
<span class="cm">     *  a criteria for describing the color visual.</span>
<span class="cm">     *</span>
<span class="cm">     *  A common mistake is assuming that bits_per_pixel &lt;= 8 is pseudocolor,</span>
<span class="cm">     *  and higher than that, true/directcolor.  This is incorrect, one needs</span>
<span class="cm">     *  to look at the fix-&gt;visual.</span>
<span class="cm">     *</span>
<span class="cm">     *  Another common mistake is using bits_per_pixel to calculate the color</span>
<span class="cm">     *  depth.  The bits_per_pixel field does not directly translate to color</span>
<span class="cm">     *  depth. You have to compute for the color depth (using the color</span>
<span class="cm">     *  bitfields) and fix-&gt;visual as seen above.</span>
<span class="cm">     */</span>

    <span class="cm">/*</span>
<span class="cm">     * This is the point where the color is converted to something that</span>
<span class="cm">     * is acceptable by the hardware.</span>
<span class="cm">     */</span>
<span class="cp">#define CNVT_TOHW(val,width) ((((val)&lt;&lt;(width))+0x7FFF-(val))&gt;&gt;16)</span>
    <span class="n">red</span> <span class="o">=</span> <span class="n">CNVT_TOHW</span><span class="p">(</span><span class="n">red</span><span class="p">,</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">var</span><span class="p">.</span><span class="n">red</span><span class="p">.</span><span class="n">length</span><span class="p">);</span>
    <span class="n">green</span> <span class="o">=</span> <span class="n">CNVT_TOHW</span><span class="p">(</span><span class="n">green</span><span class="p">,</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">var</span><span class="p">.</span><span class="n">green</span><span class="p">.</span><span class="n">length</span><span class="p">);</span>
    <span class="n">blue</span> <span class="o">=</span> <span class="n">CNVT_TOHW</span><span class="p">(</span><span class="n">blue</span><span class="p">,</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">var</span><span class="p">.</span><span class="n">blue</span><span class="p">.</span><span class="n">length</span><span class="p">);</span>
    <span class="n">transp</span> <span class="o">=</span> <span class="n">CNVT_TOHW</span><span class="p">(</span><span class="n">transp</span><span class="p">,</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">var</span><span class="p">.</span><span class="n">transp</span><span class="p">.</span><span class="n">length</span><span class="p">);</span>
<span class="cp">#undef CNVT_TOHW</span>
    <span class="cm">/*</span>
<span class="cm">     * This is the point where the function feeds the color to the hardware</span>
<span class="cm">     * palette after converting the colors to something acceptable by</span>
<span class="cm">     * the hardware. Note, only FB_VISUAL_DIRECTCOLOR and</span>
<span class="cm">     * FB_VISUAL_PSEUDOCOLOR visuals need to write to the hardware palette.</span>
<span class="cm">     * If you have code that writes to the hardware CLUT, and it&#39;s not</span>
<span class="cm">     * any of the above visuals, then you are doing something wrong.</span>
<span class="cm">     */</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">fix</span><span class="p">.</span><span class="n">visual</span> <span class="o">==</span> <span class="n">FB_VISUAL_DIRECTCOLOR</span> <span class="o">||</span>
	<span class="n">info</span><span class="o">-&gt;</span><span class="n">fix</span><span class="p">.</span><span class="n">visual</span> <span class="o">==</span> <span class="n">FB_VISUAL_TRUECOLOR</span><span class="p">)</span>
	    <span class="n">write_</span><span class="p">{</span><span class="n">red</span><span class="o">|</span><span class="n">green</span><span class="o">|</span><span class="n">blue</span><span class="o">|</span><span class="n">transp</span><span class="p">}</span><span class="n">_to_clut</span><span class="p">();</span>

    <span class="cm">/* This is the point were you need to fill up the contents of</span>
<span class="cm">     * info-&gt;pseudo_palette. This structure is used _only_ by fbcon, thus</span>
<span class="cm">     * it only contains 16 entries to match the number of colors supported</span>
<span class="cm">     * by the console. The pseudo_palette is used only if the visual is</span>
<span class="cm">     * in directcolor or truecolor mode.  With other visuals, the</span>
<span class="cm">     * pseudo_palette is not used. (This might change in the future.)</span>
<span class="cm">     *</span>
<span class="cm">     * The contents of the pseudo_palette is in raw pixel format.  Ie, each</span>
<span class="cm">     * entry can be written directly to the framebuffer without any conversion.</span>
<span class="cm">     * The pseudo_palette is (void *).  However, if using the generic</span>
<span class="cm">     * drawing functions (cfb_imageblit, cfb_fillrect), the pseudo_palette</span>
<span class="cm">     * must be casted to (u32 *) _regardless_ of the bits per pixel. If the</span>
<span class="cm">     * driver is using its own drawing functions, then it can use whatever</span>
<span class="cm">     * size it wants.</span>
<span class="cm">     */</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">fix</span><span class="p">.</span><span class="n">visual</span> <span class="o">==</span> <span class="n">FB_VISUAL_TRUECOLOR</span> <span class="o">||</span>
	<span class="n">info</span><span class="o">-&gt;</span><span class="n">fix</span><span class="p">.</span><span class="n">visual</span> <span class="o">==</span> <span class="n">FB_VISUAL_DIRECTCOLOR</span><span class="p">)</span> <span class="p">{</span>
	    <span class="n">u32</span> <span class="n">v</span><span class="p">;</span>

	    <span class="k">if</span> <span class="p">(</span><span class="n">regno</span> <span class="o">&gt;=</span> <span class="mi">16</span><span class="p">)</span>
		    <span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	    <span class="n">v</span> <span class="o">=</span> <span class="p">(</span><span class="n">red</span> <span class="o">&lt;&lt;</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">var</span><span class="p">.</span><span class="n">red</span><span class="p">.</span><span class="n">offset</span><span class="p">)</span> <span class="o">|</span>
		    <span class="p">(</span><span class="n">green</span> <span class="o">&lt;&lt;</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">var</span><span class="p">.</span><span class="n">green</span><span class="p">.</span><span class="n">offset</span><span class="p">)</span> <span class="o">|</span>
		    <span class="p">(</span><span class="n">blue</span> <span class="o">&lt;&lt;</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">var</span><span class="p">.</span><span class="n">blue</span><span class="p">.</span><span class="n">offset</span><span class="p">)</span> <span class="o">|</span>
		    <span class="p">(</span><span class="n">transp</span> <span class="o">&lt;&lt;</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">var</span><span class="p">.</span><span class="n">transp</span><span class="p">.</span><span class="n">offset</span><span class="p">);</span>

	    <span class="p">((</span><span class="n">u32</span><span class="o">*</span><span class="p">)(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">pseudo_palette</span><span class="p">))[</span><span class="n">regno</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="cm">/* ... */</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *      xxxfb_pan_display - NOT a required function. Pans the display.</span>
<span class="cm"> *      @var: frame buffer variable screen structure</span>
<span class="cm"> *      @info: frame buffer structure that represents a single frame buffer</span>
<span class="cm"> *</span>
<span class="cm"> *	Pan (or wrap, depending on the `vmode&#39; field) the display using the</span>
<span class="cm"> *  	`xoffset&#39; and `yoffset&#39; fields of the `var&#39; structure.</span>
<span class="cm"> *  	If the values don&#39;t fit, return -EINVAL.</span>
<span class="cm"> *</span>
<span class="cm"> *      Returns negative errno on error, or zero on success.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">xxxfb_pan_display</span><span class="p">(</span><span class="k">struct</span> <span class="n">fb_var_screeninfo</span> <span class="o">*</span><span class="n">var</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">fb_info</span> <span class="o">*</span><span class="n">info</span><span class="p">)</span>
<span class="p">{</span>
    <span class="cm">/*</span>
<span class="cm">     * If your hardware does not support panning, _do_ _not_ implement this</span>
<span class="cm">     * function. Creating a dummy function will just confuse user apps.</span>
<span class="cm">     */</span>

    <span class="cm">/*</span>
<span class="cm">     * Note that even if this function is fully functional, a setting of</span>
<span class="cm">     * 0 in both xpanstep and ypanstep means that this function will never</span>
<span class="cm">     * get called.</span>
<span class="cm">     */</span>

    <span class="cm">/* ... */</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *      xxxfb_blank - NOT a required function. Blanks the display.</span>
<span class="cm"> *      @blank_mode: the blank mode we want. </span>
<span class="cm"> *      @info: frame buffer structure that represents a single frame buffer</span>
<span class="cm"> *</span>
<span class="cm"> *      Blank the screen if blank_mode != FB_BLANK_UNBLANK, else unblank.</span>
<span class="cm"> *      Return 0 if blanking succeeded, != 0 if un-/blanking failed due to</span>
<span class="cm"> *      e.g. a video mode which doesn&#39;t support it.</span>
<span class="cm"> *</span>
<span class="cm"> *      Implements VESA suspend and powerdown modes on hardware that supports</span>
<span class="cm"> *      disabling hsync/vsync:</span>
<span class="cm"> *</span>
<span class="cm"> *      FB_BLANK_NORMAL = display is blanked, syncs are on.</span>
<span class="cm"> *      FB_BLANK_HSYNC_SUSPEND = hsync off</span>
<span class="cm"> *      FB_BLANK_VSYNC_SUSPEND = vsync off</span>
<span class="cm"> *      FB_BLANK_POWERDOWN =  hsync and vsync off</span>
<span class="cm"> *</span>
<span class="cm"> *      If implementing this function, at least support FB_BLANK_UNBLANK.</span>
<span class="cm"> *      Return !0 for any modes that are unimplemented.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">xxxfb_blank</span><span class="p">(</span><span class="kt">int</span> <span class="n">blank_mode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">fb_info</span> <span class="o">*</span><span class="n">info</span><span class="p">)</span>
<span class="p">{</span>
    <span class="cm">/* ... */</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* ------------ Accelerated Functions --------------------- */</span>

<span class="cm">/*</span>
<span class="cm"> * We provide our own functions if we have hardware acceleration</span>
<span class="cm"> * or non packed pixel format layouts. If we have no hardware </span>
<span class="cm"> * acceleration, we can use a generic unaccelerated function. If using</span>
<span class="cm"> * a pack pixel format just use the functions in cfb_*.c. Each file </span>
<span class="cm"> * has one of the three different accel functions we support.</span>
<span class="cm"> */</span>

<span class="cm">/**</span>
<span class="cm"> *      xxxfb_fillrect - REQUIRED function. Can use generic routines if </span>
<span class="cm"> *		 	 non acclerated hardware and packed pixel based.</span>
<span class="cm"> *			 Draws a rectangle on the screen.		</span>
<span class="cm"> *</span>
<span class="cm"> *      @info: frame buffer structure that represents a single frame buffer</span>
<span class="cm"> *	@region: The structure representing the rectangular region we </span>
<span class="cm"> *		 wish to draw to.</span>
<span class="cm"> *</span>
<span class="cm"> *	This drawing operation places/removes a retangle on the screen </span>
<span class="cm"> *	depending on the rastering operation with the value of color which</span>
<span class="cm"> *	is in the current color depth format.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">xxxfb_fillrect</span><span class="p">(</span><span class="k">struct</span> <span class="n">fb_info</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">fb_fillrect</span> <span class="o">*</span><span class="n">region</span><span class="p">)</span>
<span class="p">{</span>
<span class="cm">/*	Meaning of struct fb_fillrect</span>
<span class="cm"> *</span>
<span class="cm"> *	@dx: The x and y corrdinates of the upper left hand corner of the </span>
<span class="cm"> *	@dy: area we want to draw to. </span>
<span class="cm"> *	@width: How wide the rectangle is we want to draw.</span>
<span class="cm"> *	@height: How tall the rectangle is we want to draw.</span>
<span class="cm"> *	@color:	The color to fill in the rectangle with. </span>
<span class="cm"> *	@rop: The raster operation. We can draw the rectangle with a COPY</span>
<span class="cm"> *	      of XOR which provides erasing effect. </span>
<span class="cm"> */</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *      xxxfb_copyarea - REQUIRED function. Can use generic routines if</span>
<span class="cm"> *                       non acclerated hardware and packed pixel based.</span>
<span class="cm"> *                       Copies one area of the screen to another area.</span>
<span class="cm"> *</span>
<span class="cm"> *      @info: frame buffer structure that represents a single frame buffer</span>
<span class="cm"> *      @area: Structure providing the data to copy the framebuffer contents</span>
<span class="cm"> *	       from one region to another.</span>
<span class="cm"> *</span>
<span class="cm"> *      This drawing operation copies a rectangular area from one area of the</span>
<span class="cm"> *	screen to another area.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">xxxfb_copyarea</span><span class="p">(</span><span class="k">struct</span> <span class="n">fb_info</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">fb_copyarea</span> <span class="o">*</span><span class="n">area</span><span class="p">)</span> 
<span class="p">{</span>
<span class="cm">/*</span>
<span class="cm"> *      @dx: The x and y coordinates of the upper left hand corner of the</span>
<span class="cm"> *	@dy: destination area on the screen.</span>
<span class="cm"> *      @width: How wide the rectangle is we want to copy.</span>
<span class="cm"> *      @height: How tall the rectangle is we want to copy.</span>
<span class="cm"> *      @sx: The x and y coordinates of the upper left hand corner of the</span>
<span class="cm"> *      @sy: source area on the screen.</span>
<span class="cm"> */</span>
<span class="p">}</span>


<span class="cm">/**</span>
<span class="cm"> *      xxxfb_imageblit - REQUIRED function. Can use generic routines if</span>
<span class="cm"> *                        non acclerated hardware and packed pixel based.</span>
<span class="cm"> *                        Copies a image from system memory to the screen. </span>
<span class="cm"> *</span>
<span class="cm"> *      @info: frame buffer structure that represents a single frame buffer</span>
<span class="cm"> *	@image:	structure defining the image.</span>
<span class="cm"> *</span>
<span class="cm"> *      This drawing operation draws a image on the screen. It can be a </span>
<span class="cm"> *	mono image (needed for font handling) or a color image (needed for</span>
<span class="cm"> *	tux). </span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">xxxfb_imageblit</span><span class="p">(</span><span class="k">struct</span> <span class="n">fb_info</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">fb_image</span> <span class="o">*</span><span class="n">image</span><span class="p">)</span> 
<span class="p">{</span>
<span class="cm">/*</span>
<span class="cm"> *      @dx: The x and y coordinates of the upper left hand corner of the</span>
<span class="cm"> *	@dy: destination area to place the image on the screen.</span>
<span class="cm"> *      @width: How wide the image is we want to copy.</span>
<span class="cm"> *      @height: How tall the image is we want to copy.</span>
<span class="cm"> *      @fg_color: For mono bitmap images this is color data for     </span>
<span class="cm"> *      @bg_color: the foreground and background of the image to</span>
<span class="cm"> *		   write directly to the frmaebuffer.</span>
<span class="cm"> *	@depth:	How many bits represent a single pixel for this image.</span>
<span class="cm"> *	@data: The actual data used to construct the image on the display.</span>
<span class="cm"> *	@cmap: The colormap used for color images.   </span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * The generic function, cfb_imageblit, expects that the bitmap scanlines are</span>
<span class="cm"> * padded to the next byte.  Most hardware accelerators may require padding to</span>
<span class="cm"> * the next u16 or the next u32.  If that is the case, the driver can specify</span>
<span class="cm"> * this by setting info-&gt;pixmap.scan_align = 2 or 4.  See a more</span>
<span class="cm"> * comprehensive description of the pixmap below.</span>
<span class="cm"> */</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	xxxfb_cursor - 	OPTIONAL. If your hardware lacks support</span>
<span class="cm"> *			for a cursor, leave this field NULL.</span>
<span class="cm"> *</span>
<span class="cm"> *      @info: frame buffer structure that represents a single frame buffer</span>
<span class="cm"> *	@cursor: structure defining the cursor to draw.</span>
<span class="cm"> *</span>
<span class="cm"> *      This operation is used to set or alter the properities of the</span>
<span class="cm"> *	cursor.</span>
<span class="cm"> *</span>
<span class="cm"> *	Returns negative errno on error, or zero on success.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">xxxfb_cursor</span><span class="p">(</span><span class="k">struct</span> <span class="n">fb_info</span> <span class="o">*</span><span class="n">info</span><span class="p">,</span> <span class="k">struct</span> <span class="n">fb_cursor</span> <span class="o">*</span><span class="n">cursor</span><span class="p">)</span>
<span class="p">{</span>
<span class="cm">/*</span>
<span class="cm"> *      @set: 	Which fields we are altering in struct fb_cursor </span>
<span class="cm"> *	@enable: Disable or enable the cursor </span>
<span class="cm"> *      @rop: 	The bit operation we want to do. </span>
<span class="cm"> *      @mask:  This is the cursor mask bitmap. </span>
<span class="cm"> *      @dest:  A image of the area we are going to display the cursor.</span>
<span class="cm"> *		Used internally by the driver.	 </span>
<span class="cm"> *      @hot:	The hot spot. </span>
<span class="cm"> *	@image:	The actual data for the cursor image.</span>
<span class="cm"> *</span>
<span class="cm"> *      NOTES ON FLAGS (cursor-&gt;set):</span>
<span class="cm"> *</span>
<span class="cm"> *      FB_CUR_SETIMAGE - the cursor image has changed (cursor-&gt;image.data)</span>
<span class="cm"> *      FB_CUR_SETPOS   - the cursor position has changed (cursor-&gt;image.dx|dy)</span>
<span class="cm"> *      FB_CUR_SETHOT   - the cursor hot spot has changed (cursor-&gt;hot.dx|dy)</span>
<span class="cm"> *      FB_CUR_SETCMAP  - the cursor colors has changed (cursor-&gt;fg_color|bg_color)</span>
<span class="cm"> *      FB_CUR_SETSHAPE - the cursor bitmask has changed (cursor-&gt;mask)</span>
<span class="cm"> *      FB_CUR_SETSIZE  - the cursor size has changed (cursor-&gt;width|height)</span>
<span class="cm"> *      FB_CUR_SETALL   - everything has changed</span>
<span class="cm"> *</span>
<span class="cm"> *      NOTES ON ROPs (cursor-&gt;rop, Raster Operation)</span>
<span class="cm"> *</span>
<span class="cm"> *      ROP_XOR         - cursor-&gt;image.data XOR cursor-&gt;mask</span>
<span class="cm"> *      ROP_COPY        - curosr-&gt;image.data AND cursor-&gt;mask</span>
<span class="cm"> *</span>
<span class="cm"> *      OTHER NOTES:</span>
<span class="cm"> *</span>
<span class="cm"> *      - fbcon only supports a 2-color cursor (cursor-&gt;image.depth = 1)</span>
<span class="cm"> *      - The fb_cursor structure, @cursor, _will_ always contain valid</span>
<span class="cm"> *        fields, whether any particular bitfields in cursor-&gt;set is set</span>
<span class="cm"> *        or not.</span>
<span class="cm"> */</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	xxxfb_rotate -  NOT a required function. If your hardware</span>
<span class="cm"> *			supports rotation the whole screen then </span>
<span class="cm"> *			you would provide a hook for this. </span>
<span class="cm"> *</span>
<span class="cm"> *      @info: frame buffer structure that represents a single frame buffer</span>
<span class="cm"> *	@angle: The angle we rotate the screen.   </span>
<span class="cm"> *</span>
<span class="cm"> *      This operation is used to set or alter the properities of the</span>
<span class="cm"> *	cursor.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">xxxfb_rotate</span><span class="p">(</span><span class="k">struct</span> <span class="n">fb_info</span> <span class="o">*</span><span class="n">info</span><span class="p">,</span> <span class="kt">int</span> <span class="n">angle</span><span class="p">)</span>
<span class="p">{</span>
<span class="cm">/* Will be deprecated */</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	xxxfb_sync - NOT a required function. Normally the accel engine </span>
<span class="cm"> *		     for a graphics card take a specific amount of time.</span>
<span class="cm"> *		     Often we have to wait for the accelerator to finish</span>
<span class="cm"> *		     its operation before we can write to the framebuffer</span>
<span class="cm"> *		     so we can have consistent display output. </span>
<span class="cm"> *</span>
<span class="cm"> *      @info: frame buffer structure that represents a single frame buffer</span>
<span class="cm"> *</span>
<span class="cm"> *      If the driver has implemented its own hardware-based drawing function,</span>
<span class="cm"> *      implementing this function is highly recommended.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">xxxfb_sync</span><span class="p">(</span><span class="k">struct</span> <span class="n">fb_info</span> <span class="o">*</span><span class="n">info</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

    <span class="cm">/*</span>
<span class="cm">     *  Frame buffer operations</span>
<span class="cm">     */</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">fb_ops</span> <span class="n">xxxfb_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">owner</span>		<span class="o">=</span> <span class="n">THIS_MODULE</span><span class="p">,</span>
	<span class="p">.</span><span class="n">fb_open</span>	<span class="o">=</span> <span class="n">xxxfb_open</span><span class="p">,</span>
	<span class="p">.</span><span class="n">fb_read</span>	<span class="o">=</span> <span class="n">xxxfb_read</span><span class="p">,</span>
	<span class="p">.</span><span class="n">fb_write</span>	<span class="o">=</span> <span class="n">xxxfb_write</span><span class="p">,</span>
	<span class="p">.</span><span class="n">fb_release</span>	<span class="o">=</span> <span class="n">xxxfb_release</span><span class="p">,</span>
	<span class="p">.</span><span class="n">fb_check_var</span>	<span class="o">=</span> <span class="n">xxxfb_check_var</span><span class="p">,</span>
	<span class="p">.</span><span class="n">fb_set_par</span>	<span class="o">=</span> <span class="n">xxxfb_set_par</span><span class="p">,</span>
	<span class="p">.</span><span class="n">fb_setcolreg</span>	<span class="o">=</span> <span class="n">xxxfb_setcolreg</span><span class="p">,</span>
	<span class="p">.</span><span class="n">fb_blank</span>	<span class="o">=</span> <span class="n">xxxfb_blank</span><span class="p">,</span>
	<span class="p">.</span><span class="n">fb_pan_display</span>	<span class="o">=</span> <span class="n">xxxfb_pan_display</span><span class="p">,</span>
	<span class="p">.</span><span class="n">fb_fillrect</span>	<span class="o">=</span> <span class="n">xxxfb_fillrect</span><span class="p">,</span> 	<span class="cm">/* Needed !!! */</span>
	<span class="p">.</span><span class="n">fb_copyarea</span>	<span class="o">=</span> <span class="n">xxxfb_copyarea</span><span class="p">,</span>	<span class="cm">/* Needed !!! */</span>
	<span class="p">.</span><span class="n">fb_imageblit</span>	<span class="o">=</span> <span class="n">xxxfb_imageblit</span><span class="p">,</span>	<span class="cm">/* Needed !!! */</span>
	<span class="p">.</span><span class="n">fb_cursor</span>	<span class="o">=</span> <span class="n">xxxfb_cursor</span><span class="p">,</span>		<span class="cm">/* Optional !!! */</span>
	<span class="p">.</span><span class="n">fb_rotate</span>	<span class="o">=</span> <span class="n">xxxfb_rotate</span><span class="p">,</span>
	<span class="p">.</span><span class="n">fb_sync</span>	<span class="o">=</span> <span class="n">xxxfb_sync</span><span class="p">,</span>
	<span class="p">.</span><span class="n">fb_ioctl</span>	<span class="o">=</span> <span class="n">xxxfb_ioctl</span><span class="p">,</span>
	<span class="p">.</span><span class="n">fb_mmap</span>	<span class="o">=</span> <span class="n">xxxfb_mmap</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/* ------------------------------------------------------------------------- */</span>

    <span class="cm">/*</span>
<span class="cm">     *  Initialization</span>
<span class="cm">     */</span>

<span class="cm">/* static int __init xxfb_probe (struct platform_device *pdev) -- for platform devs */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__devinit</span> <span class="nf">xxxfb_probe</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
			      <span class="k">const</span> <span class="k">struct</span> <span class="n">pci_device_id</span> <span class="o">*</span><span class="n">ent</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">struct</span> <span class="n">fb_info</span> <span class="o">*</span><span class="n">info</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">xxx_par</span> <span class="o">*</span><span class="n">par</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">device</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span> <span class="cm">/* or &amp;pdev-&gt;dev */</span>
    <span class="kt">int</span> <span class="n">cmap_len</span><span class="p">,</span> <span class="n">retval</span><span class="p">;</span>	
   
    <span class="cm">/*</span>
<span class="cm">     * Dynamically allocate info and par</span>
<span class="cm">     */</span>
    <span class="n">info</span> <span class="o">=</span> <span class="n">framebuffer_alloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">xxx_par</span><span class="p">),</span> <span class="n">device</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">info</span><span class="p">)</span> <span class="p">{</span>
	    <span class="cm">/* goto error path */</span>
    <span class="p">}</span>

    <span class="n">par</span> <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">par</span><span class="p">;</span>

    <span class="cm">/* </span>
<span class="cm">     * Here we set the screen_base to the virtual memory address</span>
<span class="cm">     * for the framebuffer. Usually we obtain the resource address</span>
<span class="cm">     * from the bus layer and then translate it to virtual memory</span>
<span class="cm">     * space via ioremap. Consult ioport.h. </span>
<span class="cm">     */</span>
    <span class="n">info</span><span class="o">-&gt;</span><span class="n">screen_base</span> <span class="o">=</span> <span class="n">framebuffer_virtual_memory</span><span class="p">;</span>
    <span class="n">info</span><span class="o">-&gt;</span><span class="n">fbops</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">xxxfb_ops</span><span class="p">;</span>
    <span class="n">info</span><span class="o">-&gt;</span><span class="n">fix</span> <span class="o">=</span> <span class="n">xxxfb_fix</span><span class="p">;</span> <span class="cm">/* this will be the only time xxxfb_fix will be</span>
<span class="cm">			    * used, so mark it as __devinitdata</span>
<span class="cm">			    */</span>
    <span class="n">info</span><span class="o">-&gt;</span><span class="n">pseudo_palette</span> <span class="o">=</span> <span class="n">pseudo_palette</span><span class="p">;</span> <span class="cm">/* The pseudopalette is an</span>
<span class="cm">					    * 16-member array</span>
<span class="cm">					    */</span>
    <span class="cm">/*</span>
<span class="cm">     * Set up flags to indicate what sort of acceleration your</span>
<span class="cm">     * driver can provide (pan/wrap/copyarea/etc.) and whether it</span>
<span class="cm">     * is a module -- see FBINFO_* in include/linux/fb.h</span>
<span class="cm">     *</span>
<span class="cm">     * If your hardware can support any of the hardware accelerated functions</span>
<span class="cm">     * fbcon performance will improve if info-&gt;flags is set properly.</span>
<span class="cm">     *</span>
<span class="cm">     * FBINFO_HWACCEL_COPYAREA - hardware moves</span>
<span class="cm">     * FBINFO_HWACCEL_FILLRECT - hardware fills</span>
<span class="cm">     * FBINFO_HWACCEL_IMAGEBLIT - hardware mono-&gt;color expansion</span>
<span class="cm">     * FBINFO_HWACCEL_YPAN - hardware can pan display in y-axis</span>
<span class="cm">     * FBINFO_HWACCEL_YWRAP - hardware can wrap display in y-axis</span>
<span class="cm">     * FBINFO_HWACCEL_DISABLED - supports hardware accels, but disabled</span>
<span class="cm">     * FBINFO_READS_FAST - if set, prefer moves over mono-&gt;color expansion</span>
<span class="cm">     * FBINFO_MISC_TILEBLITTING - hardware can do tile blits</span>
<span class="cm">     *</span>
<span class="cm">     * NOTE: These are for fbcon use only.</span>
<span class="cm">     */</span>
    <span class="n">info</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">=</span> <span class="n">FBINFO_DEFAULT</span><span class="p">;</span>

<span class="cm">/********************* This stage is optional ******************************/</span>
     <span class="cm">/*</span>
<span class="cm">     * The struct pixmap is a scratch pad for the drawing functions. This</span>
<span class="cm">     * is where the monochrome bitmap is constructed by the higher layers</span>
<span class="cm">     * and then passed to the accelerator.  For drivers that uses</span>
<span class="cm">     * cfb_imageblit, you can skip this part.  For those that have a more</span>
<span class="cm">     * rigorous requirement, this stage is needed</span>
<span class="cm">     */</span>

    <span class="cm">/* PIXMAP_SIZE should be small enough to optimize drawing, but not</span>
<span class="cm">     * large enough that memory is wasted.  A safe size is</span>
<span class="cm">     * (max_xres * max_font_height/8). max_xres is driver dependent,</span>
<span class="cm">     * max_font_height is 32.</span>
<span class="cm">     */</span>
    <span class="n">info</span><span class="o">-&gt;</span><span class="n">pixmap</span><span class="p">.</span><span class="n">addr</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="n">PIXMAP_SIZE</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">pixmap</span><span class="p">.</span><span class="n">addr</span><span class="p">)</span> <span class="p">{</span>
	    <span class="cm">/* goto error */</span>
    <span class="p">}</span>

    <span class="n">info</span><span class="o">-&gt;</span><span class="n">pixmap</span><span class="p">.</span><span class="n">size</span> <span class="o">=</span> <span class="n">PIXMAP_SIZE</span><span class="p">;</span>

    <span class="cm">/*</span>
<span class="cm">     * FB_PIXMAP_SYSTEM - memory is in system ram</span>
<span class="cm">     * FB_PIXMAP_IO     - memory is iomapped</span>
<span class="cm">     * FB_PIXMAP_SYNC   - if set, will call fb_sync() per access to pixmap,</span>
<span class="cm">     *                    usually if FB_PIXMAP_IO is set.</span>
<span class="cm">     *</span>
<span class="cm">     * Currently, FB_PIXMAP_IO is unimplemented.</span>
<span class="cm">     */</span>
    <span class="n">info</span><span class="o">-&gt;</span><span class="n">pixmap</span><span class="p">.</span><span class="n">flags</span> <span class="o">=</span> <span class="n">FB_PIXMAP_SYSTEM</span><span class="p">;</span>

    <span class="cm">/*</span>
<span class="cm">     * scan_align is the number of padding for each scanline.  It is in bytes.</span>
<span class="cm">     * Thus for accelerators that need padding to the next u32, put 4 here.</span>
<span class="cm">     */</span>
    <span class="n">info</span><span class="o">-&gt;</span><span class="n">pixmap</span><span class="p">.</span><span class="n">scan_align</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>

    <span class="cm">/*</span>
<span class="cm">     * buf_align is the amount to be padded for the buffer. For example,</span>
<span class="cm">     * the i810fb needs a scan_align of 2 but expects it to be fed with</span>
<span class="cm">     * dwords, so a buf_align = 4 is required.</span>
<span class="cm">     */</span>
    <span class="n">info</span><span class="o">-&gt;</span><span class="n">pixmap</span><span class="p">.</span><span class="n">buf_align</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>

    <span class="cm">/* access_align is how many bits can be accessed from the framebuffer</span>
<span class="cm">     * ie. some epson cards allow 16-bit access only.  Most drivers will</span>
<span class="cm">     * be safe with u32 here.</span>
<span class="cm">     *</span>
<span class="cm">     * NOTE: This field is currently unused.</span>
<span class="cm">     */</span>
    <span class="n">info</span><span class="o">-&gt;</span><span class="n">pixmap</span><span class="p">.</span><span class="n">access_align</span> <span class="o">=</span> <span class="mi">32</span><span class="p">;</span>
<span class="cm">/***************************** End optional stage ***************************/</span>

    <span class="cm">/*</span>
<span class="cm">     * This should give a reasonable default video mode. The following is</span>
<span class="cm">     * done when we can set a video mode. </span>
<span class="cm">     */</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mode_option</span><span class="p">)</span>
	<span class="n">mode_option</span> <span class="o">=</span> <span class="s">&quot;640x480@60&quot;</span><span class="p">;</span>	 	

    <span class="n">retval</span> <span class="o">=</span> <span class="n">fb_find_mode</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">var</span><span class="p">,</span> <span class="n">info</span><span class="p">,</span> <span class="n">mode_option</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">8</span><span class="p">);</span>
  
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">retval</span> <span class="o">||</span> <span class="n">retval</span> <span class="o">==</span> <span class="mi">4</span><span class="p">)</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>			

    <span class="cm">/* This has to be done! */</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">fb_alloc_cmap</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">cmap</span><span class="p">,</span> <span class="n">cmap_len</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	
    <span class="cm">/* </span>
<span class="cm">     * The following is done in the case of having hardware with a static </span>
<span class="cm">     * mode. If we are setting the mode ourselves we don&#39;t call this. </span>
<span class="cm">     */</span>	
    <span class="n">info</span><span class="o">-&gt;</span><span class="n">var</span> <span class="o">=</span> <span class="n">xxxfb_var</span><span class="p">;</span>

    <span class="cm">/*</span>
<span class="cm">     * For drivers that can...</span>
<span class="cm">     */</span>
    <span class="n">xxxfb_check_var</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">var</span><span class="p">,</span> <span class="n">info</span><span class="p">);</span>

    <span class="cm">/*</span>
<span class="cm">     * Does a call to fb_set_par() before register_framebuffer needed?  This</span>
<span class="cm">     * will depend on you and the hardware.  If you are sure that your driver</span>
<span class="cm">     * is the only device in the system, a call to fb_set_par() is safe.</span>
<span class="cm">     *</span>
<span class="cm">     * Hardware in x86 systems has a VGA core.  Calling set_par() at this</span>
<span class="cm">     * point will corrupt the VGA console, so it might be safer to skip a</span>
<span class="cm">     * call to set_par here and just allow fbcon to do it for you.</span>
<span class="cm">     */</span>
    <span class="cm">/* xxxfb_set_par(info); */</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">register_framebuffer</span><span class="p">(</span><span class="n">info</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">fb_dealloc_cmap</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">cmap</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;fb%d: %s frame buffer device</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">,</span>
	   <span class="n">info</span><span class="o">-&gt;</span><span class="n">fix</span><span class="p">.</span><span class="n">id</span><span class="p">);</span>
    <span class="n">pci_set_drvdata</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">info</span><span class="p">);</span> <span class="cm">/* or platform_set_drvdata(pdev, info) */</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

    <span class="cm">/*</span>
<span class="cm">     *  Cleanup</span>
<span class="cm">     */</span>
<span class="cm">/* static void __devexit xxxfb_remove(struct platform_device *pdev) */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">__devexit</span> <span class="nf">xxxfb_remove</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fb_info</span> <span class="o">*</span><span class="n">info</span> <span class="o">=</span> <span class="n">pci_get_drvdata</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="cm">/* or platform_get_drvdata(pdev); */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">info</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">unregister_framebuffer</span><span class="p">(</span><span class="n">info</span><span class="p">);</span>
		<span class="n">fb_dealloc_cmap</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">cmap</span><span class="p">);</span>
		<span class="cm">/* ... */</span>
		<span class="n">framebuffer_release</span><span class="p">(</span><span class="n">info</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_PCI</span>
<span class="cp">#ifdef CONFIG_PM</span>
<span class="cm">/**</span>
<span class="cm"> *	xxxfb_suspend - Optional but recommended function. Suspend the device.</span>
<span class="cm"> *	@dev: PCI device</span>
<span class="cm"> *	@msg: the suspend event code.</span>
<span class="cm"> *</span>
<span class="cm"> *      See Documentation/power/devices.txt for more information</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">xxxfb_suspend</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="n">pm_message_t</span> <span class="n">msg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fb_info</span> <span class="o">*</span><span class="n">info</span> <span class="o">=</span> <span class="n">pci_get_drvdata</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">xxxfb_par</span> <span class="o">*</span><span class="n">par</span> <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">par</span><span class="p">;</span>

	<span class="cm">/* suspend here */</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	xxxfb_resume - Optional but recommended function. Resume the device.</span>
<span class="cm"> *	@dev: PCI device</span>
<span class="cm"> *</span>
<span class="cm"> *      See Documentation/power/devices.txt for more information</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">xxxfb_resume</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fb_info</span> <span class="o">*</span><span class="n">info</span> <span class="o">=</span> <span class="n">pci_get_drvdata</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">xxxfb_par</span> <span class="o">*</span><span class="n">par</span> <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">par</span><span class="p">;</span>

	<span class="cm">/* resume here */</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#else</span>
<span class="cp">#define xxxfb_suspend NULL</span>
<span class="cp">#define xxxfb_resume NULL</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_PM */</span><span class="cp"></span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">pci_device_id</span> <span class="n">xxxfb_id_table</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">{</span> <span class="n">PCI_VENDOR_ID_XXX</span><span class="p">,</span> <span class="n">PCI_DEVICE_ID_XXX</span><span class="p">,</span>
	  <span class="n">PCI_ANY_ID</span><span class="p">,</span> <span class="n">PCI_ANY_ID</span><span class="p">,</span> <span class="n">PCI_BASE_CLASS_DISPLAY</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">,</span>
	  <span class="n">PCI_CLASS_MASK</span><span class="p">,</span> <span class="mi">0</span> <span class="p">},</span>
	<span class="p">{</span> <span class="mi">0</span><span class="p">,</span> <span class="p">}</span>
<span class="p">};</span>

<span class="cm">/* For PCI drivers */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">pci_driver</span> <span class="n">xxxfb_driver</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">name</span> <span class="o">=</span>		<span class="s">&quot;xxxfb&quot;</span><span class="p">,</span>
	<span class="p">.</span><span class="n">id_table</span> <span class="o">=</span>	<span class="n">xxxfb_id_table</span><span class="p">,</span>
	<span class="p">.</span><span class="n">probe</span> <span class="o">=</span>	<span class="n">xxxfb_probe</span><span class="p">,</span>
	<span class="p">.</span><span class="n">remove</span> <span class="o">=</span>	<span class="n">__devexit_p</span><span class="p">(</span><span class="n">xxxfb_remove</span><span class="p">),</span>
	<span class="p">.</span><span class="n">suspend</span> <span class="o">=</span>      <span class="n">xxxfb_suspend</span><span class="p">,</span> <span class="cm">/* optional but recommended */</span>
	<span class="p">.</span><span class="n">resume</span> <span class="o">=</span>       <span class="n">xxxfb_resume</span><span class="p">,</span>  <span class="cm">/* optional but recommended */</span>
<span class="p">};</span>

<span class="n">MODULE_DEVICE_TABLE</span><span class="p">(</span><span class="n">pci</span><span class="p">,</span> <span class="n">xxxfb_id_table</span><span class="p">);</span>

<span class="kt">int</span> <span class="n">__init</span> <span class="nf">xxxfb_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 *  For kernel boot options (in &#39;video=xxxfb:&lt;options&gt;&#39; format)</span>
<span class="cm">	 */</span>
<span class="cp">#ifndef MODULE</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">option</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">fb_get_options</span><span class="p">(</span><span class="s">&quot;xxxfb&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">option</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
	<span class="n">xxxfb_setup</span><span class="p">(</span><span class="n">option</span><span class="p">);</span>
<span class="cp">#endif</span>

	<span class="k">return</span> <span class="n">pci_register_driver</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xxxfb_driver</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__exit</span> <span class="nf">xxxfb_exit</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pci_unregister_driver</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xxxfb_driver</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#else </span><span class="cm">/* non PCI, platform drivers */</span><span class="cp"></span>
<span class="cp">#include &lt;linux/platform_device.h&gt;</span>
<span class="cm">/* for platform devices */</span>

<span class="cp">#ifdef CONFIG_PM</span>
<span class="cm">/**</span>
<span class="cm"> *	xxxfb_suspend - Optional but recommended function. Suspend the device.</span>
<span class="cm"> *	@dev: platform device</span>
<span class="cm"> *	@msg: the suspend event code.</span>
<span class="cm"> *</span>
<span class="cm"> *      See Documentation/power/devices.txt for more information</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">xxxfb_suspend</span><span class="p">(</span><span class="k">struct</span> <span class="n">platform_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="n">pm_message_t</span> <span class="n">msg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fb_info</span> <span class="o">*</span><span class="n">info</span> <span class="o">=</span> <span class="n">platform_get_drvdata</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">xxxfb_par</span> <span class="o">*</span><span class="n">par</span> <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">par</span><span class="p">;</span>

	<span class="cm">/* suspend here */</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	xxxfb_resume - Optional but recommended function. Resume the device.</span>
<span class="cm"> *	@dev: platform device</span>
<span class="cm"> *</span>
<span class="cm"> *      See Documentation/power/devices.txt for more information</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">xxxfb_resume</span><span class="p">(</span><span class="k">struct</span> <span class="n">platform_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fb_info</span> <span class="o">*</span><span class="n">info</span> <span class="o">=</span> <span class="n">platform_get_drvdata</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">xxxfb_par</span> <span class="o">*</span><span class="n">par</span> <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">par</span><span class="p">;</span>

	<span class="cm">/* resume here */</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#else</span>
<span class="cp">#define xxxfb_suspend NULL</span>
<span class="cp">#define xxxfb_resume NULL</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_PM */</span><span class="cp"></span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">platform_device_driver</span> <span class="n">xxxfb_driver</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">probe</span> <span class="o">=</span> <span class="n">xxxfb_probe</span><span class="p">,</span>
	<span class="p">.</span><span class="n">remove</span> <span class="o">=</span> <span class="n">xxxfb_remove</span><span class="p">,</span>
	<span class="p">.</span><span class="n">suspend</span> <span class="o">=</span> <span class="n">xxxfb_suspend</span><span class="p">,</span> <span class="cm">/* optional but recommended */</span>
	<span class="p">.</span><span class="n">resume</span> <span class="o">=</span> <span class="n">xxxfb_resume</span><span class="p">,</span>   <span class="cm">/* optional but recommended */</span>
	<span class="p">.</span><span class="n">driver</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;xxxfb&quot;</span><span class="p">,</span>
	<span class="p">},</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">platform_device</span> <span class="o">*</span><span class="n">xxxfb_device</span><span class="p">;</span>

<span class="cp">#ifndef MODULE</span>
    <span class="cm">/*</span>
<span class="cm">     *  Setup</span>
<span class="cm">     */</span>

<span class="cm">/*</span>
<span class="cm"> * Only necessary if your driver takes special options,</span>
<span class="cm"> * otherwise we fall back on the generic fb_setup().</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">__init</span> <span class="nf">xxxfb_setup</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">options</span><span class="p">)</span>
<span class="p">{</span>
    <span class="cm">/* Parse user specified options (`video=xxxfb:&#39;) */</span>
<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* MODULE */</span><span class="cp"></span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">xxxfb_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 *  For kernel boot options (in &#39;video=xxxfb:&lt;options&gt;&#39; format)</span>
<span class="cm">	 */</span>
<span class="cp">#ifndef MODULE</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">option</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">fb_get_options</span><span class="p">(</span><span class="s">&quot;xxxfb&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">option</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
	<span class="n">xxxfb_setup</span><span class="p">(</span><span class="n">option</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">platform_driver_register</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xxxfb_driver</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">xxxfb_device</span> <span class="o">=</span> <span class="n">platform_device_register_simple</span><span class="p">(</span><span class="s">&quot;xxxfb&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
								<span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">xxxfb_device</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">platform_driver_unregister</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xxxfb_driver</span><span class="p">);</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">xxxfb_device</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__exit</span> <span class="nf">xxxfb_exit</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">platform_device_unregister</span><span class="p">(</span><span class="n">xxxfb_device</span><span class="p">);</span>
	<span class="n">platform_driver_unregister</span><span class="p">(</span><span class="o">&amp;</span><span class="n">xxxfb_driver</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_PCI */</span><span class="cp"></span>

<span class="cm">/* ------------------------------------------------------------------------- */</span>


    <span class="cm">/*</span>
<span class="cm">     *  Modularization</span>
<span class="cm">     */</span>

<span class="n">module_init</span><span class="p">(</span><span class="n">xxxfb_init</span><span class="p">);</span>
<span class="n">module_exit</span><span class="p">(</span><span class="n">xxxfb_exit</span><span class="p">);</span>

<span class="n">MODULE_LICENSE</span><span class="p">(</span><span class="s">&quot;GPL&quot;</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
