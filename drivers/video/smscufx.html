<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › video › smscufx.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>smscufx.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * smscufx.c -- Framebuffer driver for SMSC UFX USB controller</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 2011 Steve Glendinning &lt;steve.glendinning@smsc.com&gt;</span>
<span class="cm"> * Copyright (C) 2009 Roberto De Ioris &lt;roberto@unbit.it&gt;</span>
<span class="cm"> * Copyright (C) 2009 Jaya Kumar &lt;jayakumar.lkml@gmail.com&gt;</span>
<span class="cm"> * Copyright (C) 2009 Bernie Thompson &lt;bernie@plugable.com&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * This file is subject to the terms and conditions of the GNU General Public</span>
<span class="cm"> * License v2. See the file COPYING in the main directory of this archive for</span>
<span class="cm"> * more details.</span>
<span class="cm"> *</span>
<span class="cm"> * Based on udlfb, with work from Florian Echtler, Henrik Bjerregaard Pedersen,</span>
<span class="cm"> * and others.</span>
<span class="cm"> *</span>
<span class="cm"> * Works well with Bernie Thompson&#39;s X DAMAGE patch to xf86-video-fbdev</span>
<span class="cm"> * available from http://git.plugable.com</span>
<span class="cm"> *</span>
<span class="cm"> * Layout is based on skeletonfb by James Simmons and Geert Uytterhoeven,</span>
<span class="cm"> * usb-skeleton by GregKH.</span>
<span class="cm"> */</span>

<span class="cp">#define pr_fmt(fmt) KBUILD_MODNAME &quot;: &quot; fmt</span>

<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/usb.h&gt;</span>
<span class="cp">#include &lt;linux/uaccess.h&gt;</span>
<span class="cp">#include &lt;linux/mm.h&gt;</span>
<span class="cp">#include &lt;linux/fb.h&gt;</span>
<span class="cp">#include &lt;linux/vmalloc.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/delay.h&gt;</span>
<span class="cp">#include &quot;edid.h&quot;</span>

<span class="cp">#define check_warn(status, fmt, args...) \</span>
<span class="cp">	({ if (status &lt; 0) pr_warn(fmt, ##args); })</span>

<span class="cp">#define check_warn_return(status, fmt, args...) \</span>
<span class="cp">	({ if (status &lt; 0) { pr_warn(fmt, ##args); return status; } })</span>

<span class="cp">#define check_warn_goto_error(status, fmt, args...) \</span>
<span class="cp">	({ if (status &lt; 0) { pr_warn(fmt, ##args); goto error; } })</span>

<span class="cp">#define all_bits_set(x, bits) (((x) &amp; (bits)) == (bits))</span>

<span class="cp">#define USB_VENDOR_REQUEST_WRITE_REGISTER	0xA0</span>
<span class="cp">#define USB_VENDOR_REQUEST_READ_REGISTER	0xA1</span>

<span class="cm">/*</span>
<span class="cm"> * TODO: Propose standard fb.h ioctl for reporting damage,</span>
<span class="cm"> * using _IOWR() and one of the existing area structs from fb.h</span>
<span class="cm"> * Consider these ioctls deprecated, but they&#39;re still used by the</span>
<span class="cm"> * DisplayLink X server as yet - need both to be modified in tandem</span>
<span class="cm"> * when new ioctl(s) are ready.</span>
<span class="cm"> */</span>
<span class="cp">#define UFX_IOCTL_RETURN_EDID	(0xAD)</span>
<span class="cp">#define UFX_IOCTL_REPORT_DAMAGE	(0xAA)</span>

<span class="cm">/* -BULK_SIZE as per usb-skeleton. Can we get full page and avoid overhead? */</span>
<span class="cp">#define BULK_SIZE		(512)</span>
<span class="cp">#define MAX_TRANSFER		(PAGE_SIZE*16 - BULK_SIZE)</span>
<span class="cp">#define WRITES_IN_FLIGHT	(4)</span>

<span class="cp">#define GET_URB_TIMEOUT		(HZ)</span>
<span class="cp">#define FREE_URB_TIMEOUT	(HZ*2)</span>

<span class="cp">#define BPP			2</span>

<span class="cp">#define UFX_DEFIO_WRITE_DELAY	5 </span><span class="cm">/* fb_deferred_io.delay in jiffies */</span><span class="cp"></span>
<span class="cp">#define UFX_DEFIO_WRITE_DISABLE	(HZ*60) </span><span class="cm">/* &quot;disable&quot; with long delay */</span><span class="cp"></span>

<span class="k">struct</span> <span class="n">dloarea</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">w</span><span class="p">,</span> <span class="n">h</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">urb_node</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">entry</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ufx_data</span> <span class="o">*</span><span class="n">dev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">delayed_work</span> <span class="n">release_urb_work</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">urb</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">urb_list</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">list</span><span class="p">;</span>
	<span class="n">spinlock_t</span> <span class="n">lock</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">semaphore</span> <span class="n">limit_sem</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">available</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">count</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">size</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">ufx_data</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">udev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">gdev</span><span class="p">;</span> <span class="cm">/* &amp;udev-&gt;dev */</span>
	<span class="k">struct</span> <span class="n">fb_info</span> <span class="o">*</span><span class="n">info</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">urb_list</span> <span class="n">urbs</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">kref</span> <span class="n">kref</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">fb_count</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">virtualized</span><span class="p">;</span> <span class="cm">/* true when physical usb device not present */</span>
	<span class="k">struct</span> <span class="n">delayed_work</span> <span class="n">free_framebuffer_work</span><span class="p">;</span>
	<span class="n">atomic_t</span> <span class="n">usb_active</span><span class="p">;</span> <span class="cm">/* 0 = update virtual buffer, but no usb traffic */</span>
	<span class="n">atomic_t</span> <span class="n">lost_pixels</span><span class="p">;</span> <span class="cm">/* 1 = a render op failed. Need screen refresh */</span>
	<span class="n">u8</span> <span class="o">*</span><span class="n">edid</span><span class="p">;</span> <span class="cm">/* null until we read edid from hw or get from sysfs */</span>
	<span class="kt">size_t</span> <span class="n">edid_size</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">pseudo_palette</span><span class="p">[</span><span class="mi">256</span><span class="p">];</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">fb_fix_screeninfo</span> <span class="n">ufx_fix</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">id</span> <span class="o">=</span>           <span class="s">&quot;smscufx&quot;</span><span class="p">,</span>
	<span class="p">.</span><span class="n">type</span> <span class="o">=</span>         <span class="n">FB_TYPE_PACKED_PIXELS</span><span class="p">,</span>
	<span class="p">.</span><span class="n">visual</span> <span class="o">=</span>       <span class="n">FB_VISUAL_TRUECOLOR</span><span class="p">,</span>
	<span class="p">.</span><span class="n">xpanstep</span> <span class="o">=</span>     <span class="mi">0</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ypanstep</span> <span class="o">=</span>     <span class="mi">0</span><span class="p">,</span>
	<span class="p">.</span><span class="n">ywrapstep</span> <span class="o">=</span>    <span class="mi">0</span><span class="p">,</span>
	<span class="p">.</span><span class="n">accel</span> <span class="o">=</span>        <span class="n">FB_ACCEL_NONE</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">const</span> <span class="n">u32</span> <span class="n">smscufx_info_flags</span> <span class="o">=</span> <span class="n">FBINFO_DEFAULT</span> <span class="o">|</span> <span class="n">FBINFO_READS_FAST</span> <span class="o">|</span>
	<span class="n">FBINFO_VIRTFB</span> <span class="o">|</span>	<span class="n">FBINFO_HWACCEL_IMAGEBLIT</span> <span class="o">|</span> <span class="n">FBINFO_HWACCEL_FILLRECT</span> <span class="o">|</span>
	<span class="n">FBINFO_HWACCEL_COPYAREA</span> <span class="o">|</span> <span class="n">FBINFO_MISC_ALWAYS_SETPAR</span><span class="p">;</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">usb_device_id</span> <span class="n">id_table</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">{</span><span class="n">USB_DEVICE</span><span class="p">(</span><span class="mh">0x0424</span><span class="p">,</span> <span class="mh">0x9d00</span><span class="p">),},</span>
	<span class="p">{</span><span class="n">USB_DEVICE</span><span class="p">(</span><span class="mh">0x0424</span><span class="p">,</span> <span class="mh">0x9d01</span><span class="p">),},</span>
	<span class="p">{},</span>
<span class="p">};</span>
<span class="n">MODULE_DEVICE_TABLE</span><span class="p">(</span><span class="n">usb</span><span class="p">,</span> <span class="n">id_table</span><span class="p">);</span>

<span class="cm">/* module options */</span>
<span class="k">static</span> <span class="n">bool</span> <span class="n">console</span><span class="p">;</span>   <span class="cm">/* Optionally allow fbcon to consume first framebuffer */</span>
<span class="k">static</span> <span class="n">bool</span> <span class="n">fb_defio</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>  <span class="cm">/* Optionally enable fb_defio mmap support */</span>

<span class="cm">/* ufx keeps a list of urbs for efficient bulk transfers */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">ufx_urb_completion</span><span class="p">(</span><span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">urb</span><span class="p">);</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">ufx_get_urb</span><span class="p">(</span><span class="k">struct</span> <span class="n">ufx_data</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">ufx_submit_urb</span><span class="p">(</span><span class="k">struct</span> <span class="n">ufx_data</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span> <span class="n">urb</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">len</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">ufx_alloc_urb_list</span><span class="p">(</span><span class="k">struct</span> <span class="n">ufx_data</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">count</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">ufx_free_urb_list</span><span class="p">(</span><span class="k">struct</span> <span class="n">ufx_data</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>

<span class="cm">/* reads a control register */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">ufx_reg_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">ufx_data</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="n">u32</span> <span class="n">index</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="o">*</span><span class="n">buf</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">dev</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">buf</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">usb_control_msg</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">udev</span><span class="p">,</span> <span class="n">usb_rcvctrlpipe</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">udev</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
		<span class="n">USB_VENDOR_REQUEST_READ_REGISTER</span><span class="p">,</span>
		<span class="n">USB_DIR_IN</span> <span class="o">|</span> <span class="n">USB_TYPE_VENDOR</span> <span class="o">|</span> <span class="n">USB_RECIP_DEVICE</span><span class="p">,</span>
		<span class="mo">00</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="n">USB_CTRL_GET_TIMEOUT</span><span class="p">);</span>

	<span class="n">le32_to_cpus</span><span class="p">(</span><span class="n">buf</span><span class="p">);</span>
	<span class="o">*</span><span class="n">data</span> <span class="o">=</span> <span class="o">*</span><span class="n">buf</span><span class="p">;</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">buf</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">))</span>
		<span class="n">pr_warn</span><span class="p">(</span><span class="s">&quot;Failed to read register index 0x%08x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">index</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* writes a control register */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">ufx_reg_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">ufx_data</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="n">u32</span> <span class="n">index</span><span class="p">,</span> <span class="n">u32</span> <span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="o">*</span><span class="n">buf</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">dev</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">buf</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="o">*</span><span class="n">buf</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>
	<span class="n">cpu_to_le32s</span><span class="p">(</span><span class="n">buf</span><span class="p">);</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">usb_control_msg</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">udev</span><span class="p">,</span> <span class="n">usb_sndctrlpipe</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">udev</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
		<span class="n">USB_VENDOR_REQUEST_WRITE_REGISTER</span><span class="p">,</span>
		<span class="n">USB_DIR_OUT</span> <span class="o">|</span> <span class="n">USB_TYPE_VENDOR</span> <span class="o">|</span> <span class="n">USB_RECIP_DEVICE</span><span class="p">,</span>
		<span class="mo">00</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="n">USB_CTRL_SET_TIMEOUT</span><span class="p">);</span>

	<span class="n">kfree</span><span class="p">(</span><span class="n">buf</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">))</span>
		<span class="n">pr_warn</span><span class="p">(</span><span class="s">&quot;Failed to write register index 0x%08x with value &quot;</span>
			<span class="s">&quot;0x%08x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">ufx_reg_clear_and_set_bits</span><span class="p">(</span><span class="k">struct</span> <span class="n">ufx_data</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="n">u32</span> <span class="n">index</span><span class="p">,</span>
	<span class="n">u32</span> <span class="n">bits_to_clear</span><span class="p">,</span> <span class="n">u32</span> <span class="n">bits_to_set</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">data</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">status</span> <span class="o">=</span> <span class="n">ufx_reg_read</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">data</span><span class="p">);</span>
	<span class="n">check_warn_return</span><span class="p">(</span><span class="n">status</span><span class="p">,</span> <span class="s">&quot;ufx_reg_clear_and_set_bits error reading &quot;</span>
		<span class="s">&quot;0x%x&quot;</span><span class="p">,</span> <span class="n">index</span><span class="p">);</span>

	<span class="n">data</span> <span class="o">&amp;=</span> <span class="p">(</span><span class="o">~</span><span class="n">bits_to_clear</span><span class="p">);</span>
	<span class="n">data</span> <span class="o">|=</span> <span class="n">bits_to_set</span><span class="p">;</span>

	<span class="n">status</span> <span class="o">=</span> <span class="n">ufx_reg_write</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>
	<span class="n">check_warn_return</span><span class="p">(</span><span class="n">status</span><span class="p">,</span> <span class="s">&quot;ufx_reg_clear_and_set_bits error writing &quot;</span>
		<span class="s">&quot;0x%x&quot;</span><span class="p">,</span> <span class="n">index</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">ufx_reg_set_bits</span><span class="p">(</span><span class="k">struct</span> <span class="n">ufx_data</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="n">u32</span> <span class="n">index</span><span class="p">,</span> <span class="n">u32</span> <span class="n">bits</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">ufx_reg_clear_and_set_bits</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">bits</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">ufx_reg_clear_bits</span><span class="p">(</span><span class="k">struct</span> <span class="n">ufx_data</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="n">u32</span> <span class="n">index</span><span class="p">,</span> <span class="n">u32</span> <span class="n">bits</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">ufx_reg_clear_and_set_bits</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">bits</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">ufx_lite_reset</span><span class="p">(</span><span class="k">struct</span> <span class="n">ufx_data</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">status</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">value</span><span class="p">;</span>

	<span class="n">status</span> <span class="o">=</span> <span class="n">ufx_reg_write</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mh">0x3008</span><span class="p">,</span> <span class="mh">0x00000001</span><span class="p">);</span>
	<span class="n">check_warn_return</span><span class="p">(</span><span class="n">status</span><span class="p">,</span> <span class="s">&quot;ufx_lite_reset error writing 0x3008&quot;</span><span class="p">);</span>

	<span class="n">status</span> <span class="o">=</span> <span class="n">ufx_reg_read</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mh">0x3008</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">value</span><span class="p">);</span>
	<span class="n">check_warn_return</span><span class="p">(</span><span class="n">status</span><span class="p">,</span> <span class="s">&quot;ufx_lite_reset error reading 0x3008&quot;</span><span class="p">);</span>

	<span class="k">return</span> <span class="p">(</span><span class="n">value</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* If display is unblanked, then blank it */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">ufx_blank</span><span class="p">(</span><span class="k">struct</span> <span class="n">ufx_data</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="n">bool</span> <span class="n">wait</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">dc_ctrl</span><span class="p">,</span> <span class="n">dc_sts</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="kt">int</span> <span class="n">status</span> <span class="o">=</span> <span class="n">ufx_reg_read</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mh">0x2004</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dc_sts</span><span class="p">);</span>
	<span class="n">check_warn_return</span><span class="p">(</span><span class="n">status</span><span class="p">,</span> <span class="s">&quot;ufx_blank error reading 0x2004&quot;</span><span class="p">);</span>

	<span class="n">status</span> <span class="o">=</span> <span class="n">ufx_reg_read</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mh">0x2000</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dc_ctrl</span><span class="p">);</span>
	<span class="n">check_warn_return</span><span class="p">(</span><span class="n">status</span><span class="p">,</span> <span class="s">&quot;ufx_blank error reading 0x2000&quot;</span><span class="p">);</span>

	<span class="cm">/* return success if display is already blanked */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">dc_sts</span> <span class="o">&amp;</span> <span class="mh">0x00000100</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">dc_ctrl</span> <span class="o">&amp;</span> <span class="mh">0x00000100</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* request the DC to blank the display */</span>
	<span class="n">dc_ctrl</span> <span class="o">|=</span> <span class="mh">0x00000100</span><span class="p">;</span>
	<span class="n">status</span> <span class="o">=</span> <span class="n">ufx_reg_write</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mh">0x2000</span><span class="p">,</span> <span class="n">dc_ctrl</span><span class="p">);</span>
	<span class="n">check_warn_return</span><span class="p">(</span><span class="n">status</span><span class="p">,</span> <span class="s">&quot;ufx_blank error writing 0x2000&quot;</span><span class="p">);</span>

	<span class="cm">/* return success immediately if we don&#39;t have to wait */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">wait</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">250</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">ufx_reg_read</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mh">0x2004</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dc_sts</span><span class="p">);</span>
		<span class="n">check_warn_return</span><span class="p">(</span><span class="n">status</span><span class="p">,</span> <span class="s">&quot;ufx_blank error reading 0x2004&quot;</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">dc_sts</span> <span class="o">&amp;</span> <span class="mh">0x00000100</span><span class="p">)</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* timed out waiting for display to blank */</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* If display is blanked, then unblank it */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">ufx_unblank</span><span class="p">(</span><span class="k">struct</span> <span class="n">ufx_data</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="n">bool</span> <span class="n">wait</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">dc_ctrl</span><span class="p">,</span> <span class="n">dc_sts</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="kt">int</span> <span class="n">status</span> <span class="o">=</span> <span class="n">ufx_reg_read</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mh">0x2004</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dc_sts</span><span class="p">);</span>
	<span class="n">check_warn_return</span><span class="p">(</span><span class="n">status</span><span class="p">,</span> <span class="s">&quot;ufx_unblank error reading 0x2004&quot;</span><span class="p">);</span>

	<span class="n">status</span> <span class="o">=</span> <span class="n">ufx_reg_read</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mh">0x2000</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dc_ctrl</span><span class="p">);</span>
	<span class="n">check_warn_return</span><span class="p">(</span><span class="n">status</span><span class="p">,</span> <span class="s">&quot;ufx_unblank error reading 0x2000&quot;</span><span class="p">);</span>

	<span class="cm">/* return success if display is already unblanked */</span>
	<span class="k">if</span> <span class="p">(((</span><span class="n">dc_sts</span> <span class="o">&amp;</span> <span class="mh">0x00000100</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">||</span> <span class="p">((</span><span class="n">dc_ctrl</span> <span class="o">&amp;</span> <span class="mh">0x00000100</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* request the DC to unblank the display */</span>
	<span class="n">dc_ctrl</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="mh">0x00000100</span><span class="p">;</span>
	<span class="n">status</span> <span class="o">=</span> <span class="n">ufx_reg_write</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mh">0x2000</span><span class="p">,</span> <span class="n">dc_ctrl</span><span class="p">);</span>
	<span class="n">check_warn_return</span><span class="p">(</span><span class="n">status</span><span class="p">,</span> <span class="s">&quot;ufx_unblank error writing 0x2000&quot;</span><span class="p">);</span>

	<span class="cm">/* return success immediately if we don&#39;t have to wait */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">wait</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">250</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">ufx_reg_read</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mh">0x2004</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dc_sts</span><span class="p">);</span>
		<span class="n">check_warn_return</span><span class="p">(</span><span class="n">status</span><span class="p">,</span> <span class="s">&quot;ufx_unblank error reading 0x2004&quot;</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">((</span><span class="n">dc_sts</span> <span class="o">&amp;</span> <span class="mh">0x00000100</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* timed out waiting for display to unblank */</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* If display is enabled, then disable it */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">ufx_disable</span><span class="p">(</span><span class="k">struct</span> <span class="n">ufx_data</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="n">bool</span> <span class="n">wait</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">dc_ctrl</span><span class="p">,</span> <span class="n">dc_sts</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="kt">int</span> <span class="n">status</span> <span class="o">=</span> <span class="n">ufx_reg_read</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mh">0x2004</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dc_sts</span><span class="p">);</span>
	<span class="n">check_warn_return</span><span class="p">(</span><span class="n">status</span><span class="p">,</span> <span class="s">&quot;ufx_disable error reading 0x2004&quot;</span><span class="p">);</span>

	<span class="n">status</span> <span class="o">=</span> <span class="n">ufx_reg_read</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mh">0x2000</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dc_ctrl</span><span class="p">);</span>
	<span class="n">check_warn_return</span><span class="p">(</span><span class="n">status</span><span class="p">,</span> <span class="s">&quot;ufx_disable error reading 0x2000&quot;</span><span class="p">);</span>

	<span class="cm">/* return success if display is already disabled */</span>
	<span class="k">if</span> <span class="p">(((</span><span class="n">dc_sts</span> <span class="o">&amp;</span> <span class="mh">0x00000001</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">||</span> <span class="p">((</span><span class="n">dc_ctrl</span> <span class="o">&amp;</span> <span class="mh">0x00000001</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* request the DC to disable the display */</span>
	<span class="n">dc_ctrl</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="mh">0x00000001</span><span class="p">);</span>
	<span class="n">status</span> <span class="o">=</span> <span class="n">ufx_reg_write</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mh">0x2000</span><span class="p">,</span> <span class="n">dc_ctrl</span><span class="p">);</span>
	<span class="n">check_warn_return</span><span class="p">(</span><span class="n">status</span><span class="p">,</span> <span class="s">&quot;ufx_disable error writing 0x2000&quot;</span><span class="p">);</span>

	<span class="cm">/* return success immediately if we don&#39;t have to wait */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">wait</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">250</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">ufx_reg_read</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mh">0x2004</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dc_sts</span><span class="p">);</span>
		<span class="n">check_warn_return</span><span class="p">(</span><span class="n">status</span><span class="p">,</span> <span class="s">&quot;ufx_disable error reading 0x2004&quot;</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">((</span><span class="n">dc_sts</span> <span class="o">&amp;</span> <span class="mh">0x00000001</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* timed out waiting for display to disable */</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* If display is disabled, then enable it */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">ufx_enable</span><span class="p">(</span><span class="k">struct</span> <span class="n">ufx_data</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="n">bool</span> <span class="n">wait</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">dc_ctrl</span><span class="p">,</span> <span class="n">dc_sts</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="kt">int</span> <span class="n">status</span> <span class="o">=</span> <span class="n">ufx_reg_read</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mh">0x2004</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dc_sts</span><span class="p">);</span>
	<span class="n">check_warn_return</span><span class="p">(</span><span class="n">status</span><span class="p">,</span> <span class="s">&quot;ufx_enable error reading 0x2004&quot;</span><span class="p">);</span>

	<span class="n">status</span> <span class="o">=</span> <span class="n">ufx_reg_read</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mh">0x2000</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dc_ctrl</span><span class="p">);</span>
	<span class="n">check_warn_return</span><span class="p">(</span><span class="n">status</span><span class="p">,</span> <span class="s">&quot;ufx_enable error reading 0x2000&quot;</span><span class="p">);</span>

	<span class="cm">/* return success if display is already enabled */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">dc_sts</span> <span class="o">&amp;</span> <span class="mh">0x00000001</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">dc_ctrl</span> <span class="o">&amp;</span> <span class="mh">0x00000001</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* request the DC to enable the display */</span>
	<span class="n">dc_ctrl</span> <span class="o">|=</span> <span class="mh">0x00000001</span><span class="p">;</span>
	<span class="n">status</span> <span class="o">=</span> <span class="n">ufx_reg_write</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mh">0x2000</span><span class="p">,</span> <span class="n">dc_ctrl</span><span class="p">);</span>
	<span class="n">check_warn_return</span><span class="p">(</span><span class="n">status</span><span class="p">,</span> <span class="s">&quot;ufx_enable error writing 0x2000&quot;</span><span class="p">);</span>

	<span class="cm">/* return success immediately if we don&#39;t have to wait */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">wait</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">250</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">ufx_reg_read</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mh">0x2004</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dc_sts</span><span class="p">);</span>
		<span class="n">check_warn_return</span><span class="p">(</span><span class="n">status</span><span class="p">,</span> <span class="s">&quot;ufx_enable error reading 0x2004&quot;</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">dc_sts</span> <span class="o">&amp;</span> <span class="mh">0x00000001</span><span class="p">)</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* timed out waiting for display to enable */</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">ufx_config_sys_clk</span><span class="p">(</span><span class="k">struct</span> <span class="n">ufx_data</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">status</span> <span class="o">=</span> <span class="n">ufx_reg_write</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mh">0x700C</span><span class="p">,</span> <span class="mh">0x8000000F</span><span class="p">);</span>
	<span class="n">check_warn_return</span><span class="p">(</span><span class="n">status</span><span class="p">,</span> <span class="s">&quot;error writing 0x700C&quot;</span><span class="p">);</span>

	<span class="n">status</span> <span class="o">=</span> <span class="n">ufx_reg_write</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mh">0x7014</span><span class="p">,</span> <span class="mh">0x0010024F</span><span class="p">);</span>
	<span class="n">check_warn_return</span><span class="p">(</span><span class="n">status</span><span class="p">,</span> <span class="s">&quot;error writing 0x7014&quot;</span><span class="p">);</span>

	<span class="n">status</span> <span class="o">=</span> <span class="n">ufx_reg_write</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mh">0x7010</span><span class="p">,</span> <span class="mh">0x00000000</span><span class="p">);</span>
	<span class="n">check_warn_return</span><span class="p">(</span><span class="n">status</span><span class="p">,</span> <span class="s">&quot;error writing 0x7010&quot;</span><span class="p">);</span>

	<span class="n">status</span> <span class="o">=</span> <span class="n">ufx_reg_clear_bits</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mh">0x700C</span><span class="p">,</span> <span class="mh">0x0000000A</span><span class="p">);</span>
	<span class="n">check_warn_return</span><span class="p">(</span><span class="n">status</span><span class="p">,</span> <span class="s">&quot;error clearing PLL1 bypass in 0x700C&quot;</span><span class="p">);</span>
	<span class="n">msleep</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>

	<span class="n">status</span> <span class="o">=</span> <span class="n">ufx_reg_clear_bits</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mh">0x700C</span><span class="p">,</span> <span class="mh">0x80000000</span><span class="p">);</span>
	<span class="n">check_warn_return</span><span class="p">(</span><span class="n">status</span><span class="p">,</span> <span class="s">&quot;error clearing output gate in 0x700C&quot;</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">ufx_config_ddr2</span><span class="p">(</span><span class="k">struct</span> <span class="n">ufx_data</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">status</span><span class="p">,</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">tmp</span><span class="p">;</span>

	<span class="n">status</span> <span class="o">=</span> <span class="n">ufx_reg_write</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mh">0x0004</span><span class="p">,</span> <span class="mh">0x001F0F77</span><span class="p">);</span>
	<span class="n">check_warn_return</span><span class="p">(</span><span class="n">status</span><span class="p">,</span> <span class="s">&quot;error writing 0x0004&quot;</span><span class="p">);</span>

	<span class="n">status</span> <span class="o">=</span> <span class="n">ufx_reg_write</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mh">0x0008</span><span class="p">,</span> <span class="mh">0xFFF00000</span><span class="p">);</span>
	<span class="n">check_warn_return</span><span class="p">(</span><span class="n">status</span><span class="p">,</span> <span class="s">&quot;error writing 0x0008&quot;</span><span class="p">);</span>

	<span class="n">status</span> <span class="o">=</span> <span class="n">ufx_reg_write</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mh">0x000C</span><span class="p">,</span> <span class="mh">0x0FFF2222</span><span class="p">);</span>
	<span class="n">check_warn_return</span><span class="p">(</span><span class="n">status</span><span class="p">,</span> <span class="s">&quot;error writing 0x000C&quot;</span><span class="p">);</span>

	<span class="n">status</span> <span class="o">=</span> <span class="n">ufx_reg_write</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mh">0x0010</span><span class="p">,</span> <span class="mh">0x00030814</span><span class="p">);</span>
	<span class="n">check_warn_return</span><span class="p">(</span><span class="n">status</span><span class="p">,</span> <span class="s">&quot;error writing 0x0010&quot;</span><span class="p">);</span>

	<span class="n">status</span> <span class="o">=</span> <span class="n">ufx_reg_write</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mh">0x0014</span><span class="p">,</span> <span class="mh">0x00500019</span><span class="p">);</span>
	<span class="n">check_warn_return</span><span class="p">(</span><span class="n">status</span><span class="p">,</span> <span class="s">&quot;error writing 0x0014&quot;</span><span class="p">);</span>

	<span class="n">status</span> <span class="o">=</span> <span class="n">ufx_reg_write</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mh">0x0018</span><span class="p">,</span> <span class="mh">0x020D0F15</span><span class="p">);</span>
	<span class="n">check_warn_return</span><span class="p">(</span><span class="n">status</span><span class="p">,</span> <span class="s">&quot;error writing 0x0018&quot;</span><span class="p">);</span>

	<span class="n">status</span> <span class="o">=</span> <span class="n">ufx_reg_write</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mh">0x001C</span><span class="p">,</span> <span class="mh">0x02532305</span><span class="p">);</span>
	<span class="n">check_warn_return</span><span class="p">(</span><span class="n">status</span><span class="p">,</span> <span class="s">&quot;error writing 0x001C&quot;</span><span class="p">);</span>

	<span class="n">status</span> <span class="o">=</span> <span class="n">ufx_reg_write</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mh">0x0020</span><span class="p">,</span> <span class="mh">0x0B030905</span><span class="p">);</span>
	<span class="n">check_warn_return</span><span class="p">(</span><span class="n">status</span><span class="p">,</span> <span class="s">&quot;error writing 0x0020&quot;</span><span class="p">);</span>

	<span class="n">status</span> <span class="o">=</span> <span class="n">ufx_reg_write</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mh">0x0024</span><span class="p">,</span> <span class="mh">0x00000827</span><span class="p">);</span>
	<span class="n">check_warn_return</span><span class="p">(</span><span class="n">status</span><span class="p">,</span> <span class="s">&quot;error writing 0x0024&quot;</span><span class="p">);</span>

	<span class="n">status</span> <span class="o">=</span> <span class="n">ufx_reg_write</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mh">0x0028</span><span class="p">,</span> <span class="mh">0x00000000</span><span class="p">);</span>
	<span class="n">check_warn_return</span><span class="p">(</span><span class="n">status</span><span class="p">,</span> <span class="s">&quot;error writing 0x0028&quot;</span><span class="p">);</span>

	<span class="n">status</span> <span class="o">=</span> <span class="n">ufx_reg_write</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mh">0x002C</span><span class="p">,</span> <span class="mh">0x00000042</span><span class="p">);</span>
	<span class="n">check_warn_return</span><span class="p">(</span><span class="n">status</span><span class="p">,</span> <span class="s">&quot;error writing 0x002C&quot;</span><span class="p">);</span>

	<span class="n">status</span> <span class="o">=</span> <span class="n">ufx_reg_write</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mh">0x0030</span><span class="p">,</span> <span class="mh">0x09520000</span><span class="p">);</span>
	<span class="n">check_warn_return</span><span class="p">(</span><span class="n">status</span><span class="p">,</span> <span class="s">&quot;error writing 0x0030&quot;</span><span class="p">);</span>

	<span class="n">status</span> <span class="o">=</span> <span class="n">ufx_reg_write</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mh">0x0034</span><span class="p">,</span> <span class="mh">0x02223314</span><span class="p">);</span>
	<span class="n">check_warn_return</span><span class="p">(</span><span class="n">status</span><span class="p">,</span> <span class="s">&quot;error writing 0x0034&quot;</span><span class="p">);</span>

	<span class="n">status</span> <span class="o">=</span> <span class="n">ufx_reg_write</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mh">0x0038</span><span class="p">,</span> <span class="mh">0x00430043</span><span class="p">);</span>
	<span class="n">check_warn_return</span><span class="p">(</span><span class="n">status</span><span class="p">,</span> <span class="s">&quot;error writing 0x0038&quot;</span><span class="p">);</span>

	<span class="n">status</span> <span class="o">=</span> <span class="n">ufx_reg_write</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mh">0x003C</span><span class="p">,</span> <span class="mh">0xF00F000F</span><span class="p">);</span>
	<span class="n">check_warn_return</span><span class="p">(</span><span class="n">status</span><span class="p">,</span> <span class="s">&quot;error writing 0x003C&quot;</span><span class="p">);</span>

	<span class="n">status</span> <span class="o">=</span> <span class="n">ufx_reg_write</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mh">0x0040</span><span class="p">,</span> <span class="mh">0xF380F00F</span><span class="p">);</span>
	<span class="n">check_warn_return</span><span class="p">(</span><span class="n">status</span><span class="p">,</span> <span class="s">&quot;error writing 0x0040&quot;</span><span class="p">);</span>

	<span class="n">status</span> <span class="o">=</span> <span class="n">ufx_reg_write</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mh">0x0044</span><span class="p">,</span> <span class="mh">0xF00F0496</span><span class="p">);</span>
	<span class="n">check_warn_return</span><span class="p">(</span><span class="n">status</span><span class="p">,</span> <span class="s">&quot;error writing 0x0044&quot;</span><span class="p">);</span>

	<span class="n">status</span> <span class="o">=</span> <span class="n">ufx_reg_write</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mh">0x0048</span><span class="p">,</span> <span class="mh">0x03080406</span><span class="p">);</span>
	<span class="n">check_warn_return</span><span class="p">(</span><span class="n">status</span><span class="p">,</span> <span class="s">&quot;error writing 0x0048&quot;</span><span class="p">);</span>

	<span class="n">status</span> <span class="o">=</span> <span class="n">ufx_reg_write</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mh">0x004C</span><span class="p">,</span> <span class="mh">0x00001000</span><span class="p">);</span>
	<span class="n">check_warn_return</span><span class="p">(</span><span class="n">status</span><span class="p">,</span> <span class="s">&quot;error writing 0x004C&quot;</span><span class="p">);</span>

	<span class="n">status</span> <span class="o">=</span> <span class="n">ufx_reg_write</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mh">0x005C</span><span class="p">,</span> <span class="mh">0x00000007</span><span class="p">);</span>
	<span class="n">check_warn_return</span><span class="p">(</span><span class="n">status</span><span class="p">,</span> <span class="s">&quot;error writing 0x005C&quot;</span><span class="p">);</span>

	<span class="n">status</span> <span class="o">=</span> <span class="n">ufx_reg_write</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mh">0x0100</span><span class="p">,</span> <span class="mh">0x54F00012</span><span class="p">);</span>
	<span class="n">check_warn_return</span><span class="p">(</span><span class="n">status</span><span class="p">,</span> <span class="s">&quot;error writing 0x0100&quot;</span><span class="p">);</span>

	<span class="n">status</span> <span class="o">=</span> <span class="n">ufx_reg_write</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mh">0x0104</span><span class="p">,</span> <span class="mh">0x00004012</span><span class="p">);</span>
	<span class="n">check_warn_return</span><span class="p">(</span><span class="n">status</span><span class="p">,</span> <span class="s">&quot;error writing 0x0104&quot;</span><span class="p">);</span>

	<span class="n">status</span> <span class="o">=</span> <span class="n">ufx_reg_write</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mh">0x0118</span><span class="p">,</span> <span class="mh">0x40404040</span><span class="p">);</span>
	<span class="n">check_warn_return</span><span class="p">(</span><span class="n">status</span><span class="p">,</span> <span class="s">&quot;error writing 0x0118&quot;</span><span class="p">);</span>

	<span class="n">status</span> <span class="o">=</span> <span class="n">ufx_reg_write</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mh">0x0000</span><span class="p">,</span> <span class="mh">0x00000001</span><span class="p">);</span>
	<span class="n">check_warn_return</span><span class="p">(</span><span class="n">status</span><span class="p">,</span> <span class="s">&quot;error writing 0x0000&quot;</span><span class="p">);</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">i</span><span class="o">++</span> <span class="o">&lt;</span> <span class="mi">500</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">ufx_reg_read</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mh">0x0000</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tmp</span><span class="p">);</span>
		<span class="n">check_warn_return</span><span class="p">(</span><span class="n">status</span><span class="p">,</span> <span class="s">&quot;error reading 0x0000&quot;</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">all_bits_set</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="mh">0xC0000000</span><span class="p">))</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;DDR2 initialisation timed out, reg 0x0000=0x%08x&quot;</span><span class="p">,</span> <span class="n">tmp</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">ETIMEDOUT</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">pll_values</span> <span class="p">{</span>
	<span class="n">u32</span> <span class="n">div_r0</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">div_f0</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">div_q0</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">range0</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">div_r1</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">div_f1</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">div_q1</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">range1</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="n">u32</span> <span class="nf">ufx_calc_range</span><span class="p">(</span><span class="n">u32</span> <span class="n">ref_freq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ref_freq</span> <span class="o">&gt;=</span> <span class="mi">88000000</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">7</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ref_freq</span> <span class="o">&gt;=</span> <span class="mi">54000000</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">6</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ref_freq</span> <span class="o">&gt;=</span> <span class="mi">34000000</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">5</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ref_freq</span> <span class="o">&gt;=</span> <span class="mi">21000000</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">4</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ref_freq</span> <span class="o">&gt;=</span> <span class="mi">13000000</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">3</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ref_freq</span> <span class="o">&gt;=</span> <span class="mi">8000000</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">2</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* calculates PLL divider settings for a desired target frequency */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">ufx_calc_pll_values</span><span class="p">(</span><span class="k">const</span> <span class="n">u32</span> <span class="n">clk_pixel_pll</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pll_values</span> <span class="o">*</span><span class="n">asic_pll</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="n">u32</span> <span class="n">ref_clk</span> <span class="o">=</span> <span class="mi">25000000</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">div_r0</span><span class="p">,</span> <span class="n">div_f0</span><span class="p">,</span> <span class="n">div_q0</span><span class="p">,</span> <span class="n">div_r1</span><span class="p">,</span> <span class="n">div_f1</span><span class="p">,</span> <span class="n">div_q1</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">min_error</span> <span class="o">=</span> <span class="n">clk_pixel_pll</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">div_r0</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">div_r0</span> <span class="o">&lt;=</span> <span class="mi">32</span><span class="p">;</span> <span class="n">div_r0</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">u32</span> <span class="n">ref_freq0</span> <span class="o">=</span> <span class="n">ref_clk</span> <span class="o">/</span> <span class="n">div_r0</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ref_freq0</span> <span class="o">&lt;</span> <span class="mi">5000000</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">ref_freq0</span> <span class="o">&gt;</span> <span class="mi">200000000</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">div_f0</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">div_f0</span> <span class="o">&lt;=</span> <span class="mi">256</span><span class="p">;</span> <span class="n">div_f0</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">u32</span> <span class="n">vco_freq0</span> <span class="o">=</span> <span class="n">ref_freq0</span> <span class="o">*</span> <span class="n">div_f0</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">vco_freq0</span> <span class="o">&lt;</span> <span class="mi">350000000</span><span class="p">)</span>
				<span class="k">continue</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">vco_freq0</span> <span class="o">&gt;</span> <span class="mi">700000000</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>

			<span class="k">for</span> <span class="p">(</span><span class="n">div_q0</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">div_q0</span> <span class="o">&lt;</span> <span class="mi">7</span><span class="p">;</span> <span class="n">div_q0</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">u32</span> <span class="n">pllout_freq0</span> <span class="o">=</span> <span class="n">vco_freq0</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">div_q0</span><span class="p">);</span>

				<span class="k">if</span> <span class="p">(</span><span class="n">pllout_freq0</span> <span class="o">&lt;</span> <span class="mi">5000000</span><span class="p">)</span>
					<span class="k">break</span><span class="p">;</span>

				<span class="k">if</span> <span class="p">(</span><span class="n">pllout_freq0</span> <span class="o">&gt;</span> <span class="mi">200000000</span><span class="p">)</span>
					<span class="k">continue</span><span class="p">;</span>

				<span class="k">for</span> <span class="p">(</span><span class="n">div_r1</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">div_r1</span> <span class="o">&lt;=</span> <span class="mi">32</span><span class="p">;</span> <span class="n">div_r1</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">u32</span> <span class="n">ref_freq1</span> <span class="o">=</span> <span class="n">pllout_freq0</span> <span class="o">/</span> <span class="n">div_r1</span><span class="p">;</span>

					<span class="k">if</span> <span class="p">(</span><span class="n">ref_freq1</span> <span class="o">&lt;</span> <span class="mi">5000000</span><span class="p">)</span>
						<span class="k">break</span><span class="p">;</span>

					<span class="k">for</span> <span class="p">(</span><span class="n">div_f1</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">div_f1</span> <span class="o">&lt;=</span> <span class="mi">256</span><span class="p">;</span> <span class="n">div_f1</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
						<span class="n">u32</span> <span class="n">vco_freq1</span> <span class="o">=</span> <span class="n">ref_freq1</span> <span class="o">*</span> <span class="n">div_f1</span><span class="p">;</span>

						<span class="k">if</span> <span class="p">(</span><span class="n">vco_freq1</span> <span class="o">&lt;</span> <span class="mi">350000000</span><span class="p">)</span>
							<span class="k">continue</span><span class="p">;</span>

						<span class="k">if</span> <span class="p">(</span><span class="n">vco_freq1</span> <span class="o">&gt;</span> <span class="mi">700000000</span><span class="p">)</span>
							<span class="k">break</span><span class="p">;</span>

						<span class="k">for</span> <span class="p">(</span><span class="n">div_q1</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">div_q1</span> <span class="o">&lt;</span> <span class="mi">7</span><span class="p">;</span> <span class="n">div_q1</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
							<span class="n">u32</span> <span class="n">pllout_freq1</span> <span class="o">=</span> <span class="n">vco_freq1</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">div_q1</span><span class="p">);</span>
							<span class="kt">int</span> <span class="n">error</span> <span class="o">=</span> <span class="n">abs</span><span class="p">(</span><span class="n">pllout_freq1</span> <span class="o">-</span> <span class="n">clk_pixel_pll</span><span class="p">);</span>

							<span class="k">if</span> <span class="p">(</span><span class="n">pllout_freq1</span> <span class="o">&lt;</span> <span class="mi">5000000</span><span class="p">)</span>
								<span class="k">break</span><span class="p">;</span>

							<span class="k">if</span> <span class="p">(</span><span class="n">pllout_freq1</span> <span class="o">&gt;</span> <span class="mi">700000000</span><span class="p">)</span>
								<span class="k">continue</span><span class="p">;</span>

							<span class="k">if</span> <span class="p">(</span><span class="n">error</span> <span class="o">&lt;</span> <span class="n">min_error</span><span class="p">)</span> <span class="p">{</span>
								<span class="n">min_error</span> <span class="o">=</span> <span class="n">error</span><span class="p">;</span>

								<span class="cm">/* final returned value is equal to calculated value - 1</span>
<span class="cm">								 * because a value of 0 = divide by 1 */</span>
								<span class="n">asic_pll</span><span class="o">-&gt;</span><span class="n">div_r0</span> <span class="o">=</span> <span class="n">div_r0</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
								<span class="n">asic_pll</span><span class="o">-&gt;</span><span class="n">div_f0</span> <span class="o">=</span> <span class="n">div_f0</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
								<span class="n">asic_pll</span><span class="o">-&gt;</span><span class="n">div_q0</span> <span class="o">=</span> <span class="n">div_q0</span><span class="p">;</span>
								<span class="n">asic_pll</span><span class="o">-&gt;</span><span class="n">div_r1</span> <span class="o">=</span> <span class="n">div_r1</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
								<span class="n">asic_pll</span><span class="o">-&gt;</span><span class="n">div_f1</span> <span class="o">=</span> <span class="n">div_f1</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
								<span class="n">asic_pll</span><span class="o">-&gt;</span><span class="n">div_q1</span> <span class="o">=</span> <span class="n">div_q1</span><span class="p">;</span>

								<span class="n">asic_pll</span><span class="o">-&gt;</span><span class="n">range0</span> <span class="o">=</span> <span class="n">ufx_calc_range</span><span class="p">(</span><span class="n">ref_freq0</span><span class="p">);</span>
								<span class="n">asic_pll</span><span class="o">-&gt;</span><span class="n">range1</span> <span class="o">=</span> <span class="n">ufx_calc_range</span><span class="p">(</span><span class="n">ref_freq1</span><span class="p">);</span>

								<span class="k">if</span> <span class="p">(</span><span class="n">min_error</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
									<span class="k">return</span><span class="p">;</span>
							<span class="p">}</span>
						<span class="p">}</span>
					<span class="p">}</span>
				<span class="p">}</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* sets analog bit PLL configuration values */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">ufx_config_pix_clk</span><span class="p">(</span><span class="k">struct</span> <span class="n">ufx_data</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="n">u32</span> <span class="n">pixclock</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pll_values</span> <span class="n">asic_pll</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span>
	<span class="n">u32</span> <span class="n">value</span><span class="p">,</span> <span class="n">clk_pixel</span><span class="p">,</span> <span class="n">clk_pixel_pll</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">status</span><span class="p">;</span>

	<span class="cm">/* convert pixclock (in ps) to frequency (in Hz) */</span>
	<span class="n">clk_pixel</span> <span class="o">=</span> <span class="n">PICOS2KHZ</span><span class="p">(</span><span class="n">pixclock</span><span class="p">)</span> <span class="o">*</span> <span class="mi">1000</span><span class="p">;</span>
	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;pixclock %d ps = clk_pixel %d Hz&quot;</span><span class="p">,</span> <span class="n">pixclock</span><span class="p">,</span> <span class="n">clk_pixel</span><span class="p">);</span>

	<span class="cm">/* clk_pixel = 1/2 clk_pixel_pll */</span>
	<span class="n">clk_pixel_pll</span> <span class="o">=</span> <span class="n">clk_pixel</span> <span class="o">*</span> <span class="mi">2</span><span class="p">;</span>

	<span class="n">ufx_calc_pll_values</span><span class="p">(</span><span class="n">clk_pixel_pll</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">asic_pll</span><span class="p">);</span>

	<span class="cm">/* Keep BYPASS and RESET signals asserted until configured */</span>
	<span class="n">status</span> <span class="o">=</span> <span class="n">ufx_reg_write</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mh">0x7000</span><span class="p">,</span> <span class="mh">0x8000000F</span><span class="p">);</span>
	<span class="n">check_warn_return</span><span class="p">(</span><span class="n">status</span><span class="p">,</span> <span class="s">&quot;error writing 0x7000&quot;</span><span class="p">);</span>

	<span class="n">value</span> <span class="o">=</span> <span class="p">(</span><span class="n">asic_pll</span><span class="p">.</span><span class="n">div_f1</span> <span class="o">|</span> <span class="p">(</span><span class="n">asic_pll</span><span class="p">.</span><span class="n">div_r1</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">|</span>
		<span class="p">(</span><span class="n">asic_pll</span><span class="p">.</span><span class="n">div_q1</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">asic_pll</span><span class="p">.</span><span class="n">range1</span> <span class="o">&lt;&lt;</span> <span class="mi">20</span><span class="p">));</span>
	<span class="n">status</span> <span class="o">=</span> <span class="n">ufx_reg_write</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mh">0x7008</span><span class="p">,</span> <span class="n">value</span><span class="p">);</span>
	<span class="n">check_warn_return</span><span class="p">(</span><span class="n">status</span><span class="p">,</span> <span class="s">&quot;error writing 0x7008&quot;</span><span class="p">);</span>

	<span class="n">value</span> <span class="o">=</span> <span class="p">(</span><span class="n">asic_pll</span><span class="p">.</span><span class="n">div_f0</span> <span class="o">|</span> <span class="p">(</span><span class="n">asic_pll</span><span class="p">.</span><span class="n">div_r0</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">|</span>
		<span class="p">(</span><span class="n">asic_pll</span><span class="p">.</span><span class="n">div_q0</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">asic_pll</span><span class="p">.</span><span class="n">range0</span> <span class="o">&lt;&lt;</span> <span class="mi">20</span><span class="p">));</span>
	<span class="n">status</span> <span class="o">=</span> <span class="n">ufx_reg_write</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mh">0x7004</span><span class="p">,</span> <span class="n">value</span><span class="p">);</span>
	<span class="n">check_warn_return</span><span class="p">(</span><span class="n">status</span><span class="p">,</span> <span class="s">&quot;error writing 0x7004&quot;</span><span class="p">);</span>

	<span class="n">status</span> <span class="o">=</span> <span class="n">ufx_reg_clear_bits</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mh">0x7000</span><span class="p">,</span> <span class="mh">0x00000005</span><span class="p">);</span>
	<span class="n">check_warn_return</span><span class="p">(</span><span class="n">status</span><span class="p">,</span>
		<span class="s">&quot;error clearing PLL0 bypass bits in 0x7000&quot;</span><span class="p">);</span>
	<span class="n">msleep</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>

	<span class="n">status</span> <span class="o">=</span> <span class="n">ufx_reg_clear_bits</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mh">0x7000</span><span class="p">,</span> <span class="mh">0x0000000A</span><span class="p">);</span>
	<span class="n">check_warn_return</span><span class="p">(</span><span class="n">status</span><span class="p">,</span>
		<span class="s">&quot;error clearing PLL1 bypass bits in 0x7000&quot;</span><span class="p">);</span>
	<span class="n">msleep</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>

	<span class="n">status</span> <span class="o">=</span> <span class="n">ufx_reg_clear_bits</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mh">0x7000</span><span class="p">,</span> <span class="mh">0x80000000</span><span class="p">);</span>
	<span class="n">check_warn_return</span><span class="p">(</span><span class="n">status</span><span class="p">,</span> <span class="s">&quot;error clearing gate bits in 0x7000&quot;</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">ufx_set_vid_mode</span><span class="p">(</span><span class="k">struct</span> <span class="n">ufx_data</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">fb_var_screeninfo</span> <span class="o">*</span><span class="n">var</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">temp</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">h_total</span><span class="p">,</span> <span class="n">h_active</span><span class="p">,</span> <span class="n">h_blank_start</span><span class="p">,</span> <span class="n">h_blank_end</span><span class="p">,</span> <span class="n">h_sync_start</span><span class="p">,</span> <span class="n">h_sync_end</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">v_total</span><span class="p">,</span> <span class="n">v_active</span><span class="p">,</span> <span class="n">v_blank_start</span><span class="p">,</span> <span class="n">v_blank_end</span><span class="p">,</span> <span class="n">v_sync_start</span><span class="p">,</span> <span class="n">v_sync_end</span><span class="p">;</span>

	<span class="kt">int</span> <span class="n">status</span> <span class="o">=</span> <span class="n">ufx_reg_write</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mh">0x8028</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">check_warn_return</span><span class="p">(</span><span class="n">status</span><span class="p">,</span> <span class="s">&quot;ufx_set_vid_mode error disabling RGB pad&quot;</span><span class="p">);</span>

	<span class="n">status</span> <span class="o">=</span> <span class="n">ufx_reg_write</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mh">0x8024</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">check_warn_return</span><span class="p">(</span><span class="n">status</span><span class="p">,</span> <span class="s">&quot;ufx_set_vid_mode error disabling VDAC&quot;</span><span class="p">);</span>

	<span class="cm">/* shut everything down before changing timing */</span>
	<span class="n">status</span> <span class="o">=</span> <span class="n">ufx_blank</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
	<span class="n">check_warn_return</span><span class="p">(</span><span class="n">status</span><span class="p">,</span> <span class="s">&quot;ufx_set_vid_mode error blanking display&quot;</span><span class="p">);</span>

	<span class="n">status</span> <span class="o">=</span> <span class="n">ufx_disable</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
	<span class="n">check_warn_return</span><span class="p">(</span><span class="n">status</span><span class="p">,</span> <span class="s">&quot;ufx_set_vid_mode error disabling display&quot;</span><span class="p">);</span>

	<span class="n">status</span> <span class="o">=</span> <span class="n">ufx_config_pix_clk</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">var</span><span class="o">-&gt;</span><span class="n">pixclock</span><span class="p">);</span>
	<span class="n">check_warn_return</span><span class="p">(</span><span class="n">status</span><span class="p">,</span> <span class="s">&quot;ufx_set_vid_mode error configuring pixclock&quot;</span><span class="p">);</span>

	<span class="n">status</span> <span class="o">=</span> <span class="n">ufx_reg_write</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mh">0x2000</span><span class="p">,</span> <span class="mh">0x00000104</span><span class="p">);</span>
	<span class="n">check_warn_return</span><span class="p">(</span><span class="n">status</span><span class="p">,</span> <span class="s">&quot;ufx_set_vid_mode error writing 0x2000&quot;</span><span class="p">);</span>

	<span class="cm">/* set horizontal timings */</span>
	<span class="n">h_total</span> <span class="o">=</span> <span class="n">var</span><span class="o">-&gt;</span><span class="n">xres</span> <span class="o">+</span> <span class="n">var</span><span class="o">-&gt;</span><span class="n">right_margin</span> <span class="o">+</span> <span class="n">var</span><span class="o">-&gt;</span><span class="n">hsync_len</span> <span class="o">+</span> <span class="n">var</span><span class="o">-&gt;</span><span class="n">left_margin</span><span class="p">;</span>
	<span class="n">h_active</span> <span class="o">=</span> <span class="n">var</span><span class="o">-&gt;</span><span class="n">xres</span><span class="p">;</span>
	<span class="n">h_blank_start</span> <span class="o">=</span> <span class="n">var</span><span class="o">-&gt;</span><span class="n">xres</span> <span class="o">+</span> <span class="n">var</span><span class="o">-&gt;</span><span class="n">right_margin</span><span class="p">;</span>
	<span class="n">h_blank_end</span> <span class="o">=</span> <span class="n">var</span><span class="o">-&gt;</span><span class="n">xres</span> <span class="o">+</span> <span class="n">var</span><span class="o">-&gt;</span><span class="n">right_margin</span> <span class="o">+</span> <span class="n">var</span><span class="o">-&gt;</span><span class="n">hsync_len</span><span class="p">;</span>
	<span class="n">h_sync_start</span> <span class="o">=</span> <span class="n">var</span><span class="o">-&gt;</span><span class="n">xres</span> <span class="o">+</span> <span class="n">var</span><span class="o">-&gt;</span><span class="n">right_margin</span><span class="p">;</span>
	<span class="n">h_sync_end</span> <span class="o">=</span> <span class="n">var</span><span class="o">-&gt;</span><span class="n">xres</span> <span class="o">+</span> <span class="n">var</span><span class="o">-&gt;</span><span class="n">right_margin</span> <span class="o">+</span> <span class="n">var</span><span class="o">-&gt;</span><span class="n">hsync_len</span><span class="p">;</span>

	<span class="n">temp</span> <span class="o">=</span> <span class="p">((</span><span class="n">h_total</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">h_active</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">status</span> <span class="o">=</span> <span class="n">ufx_reg_write</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mh">0x2008</span><span class="p">,</span> <span class="n">temp</span><span class="p">);</span>
	<span class="n">check_warn_return</span><span class="p">(</span><span class="n">status</span><span class="p">,</span> <span class="s">&quot;ufx_set_vid_mode error writing 0x2008&quot;</span><span class="p">);</span>

	<span class="n">temp</span> <span class="o">=</span> <span class="p">((</span><span class="n">h_blank_start</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">h_blank_end</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">status</span> <span class="o">=</span> <span class="n">ufx_reg_write</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mh">0x200C</span><span class="p">,</span> <span class="n">temp</span><span class="p">);</span>
	<span class="n">check_warn_return</span><span class="p">(</span><span class="n">status</span><span class="p">,</span> <span class="s">&quot;ufx_set_vid_mode error writing 0x200C&quot;</span><span class="p">);</span>

	<span class="n">temp</span> <span class="o">=</span> <span class="p">((</span><span class="n">h_sync_start</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">h_sync_end</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">status</span> <span class="o">=</span> <span class="n">ufx_reg_write</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mh">0x2010</span><span class="p">,</span> <span class="n">temp</span><span class="p">);</span>
	<span class="n">check_warn_return</span><span class="p">(</span><span class="n">status</span><span class="p">,</span> <span class="s">&quot;ufx_set_vid_mode error writing 0x2010&quot;</span><span class="p">);</span>

	<span class="cm">/* set vertical timings */</span>
	<span class="n">v_total</span> <span class="o">=</span> <span class="n">var</span><span class="o">-&gt;</span><span class="n">upper_margin</span> <span class="o">+</span> <span class="n">var</span><span class="o">-&gt;</span><span class="n">yres</span> <span class="o">+</span> <span class="n">var</span><span class="o">-&gt;</span><span class="n">lower_margin</span> <span class="o">+</span> <span class="n">var</span><span class="o">-&gt;</span><span class="n">vsync_len</span><span class="p">;</span>
	<span class="n">v_active</span> <span class="o">=</span> <span class="n">var</span><span class="o">-&gt;</span><span class="n">yres</span><span class="p">;</span>
	<span class="n">v_blank_start</span> <span class="o">=</span> <span class="n">var</span><span class="o">-&gt;</span><span class="n">yres</span> <span class="o">+</span> <span class="n">var</span><span class="o">-&gt;</span><span class="n">lower_margin</span><span class="p">;</span>
	<span class="n">v_blank_end</span> <span class="o">=</span> <span class="n">var</span><span class="o">-&gt;</span><span class="n">yres</span> <span class="o">+</span> <span class="n">var</span><span class="o">-&gt;</span><span class="n">lower_margin</span> <span class="o">+</span> <span class="n">var</span><span class="o">-&gt;</span><span class="n">vsync_len</span><span class="p">;</span>
	<span class="n">v_sync_start</span> <span class="o">=</span> <span class="n">var</span><span class="o">-&gt;</span><span class="n">yres</span> <span class="o">+</span> <span class="n">var</span><span class="o">-&gt;</span><span class="n">lower_margin</span><span class="p">;</span>
	<span class="n">v_sync_end</span> <span class="o">=</span> <span class="n">var</span><span class="o">-&gt;</span><span class="n">yres</span> <span class="o">+</span> <span class="n">var</span><span class="o">-&gt;</span><span class="n">lower_margin</span> <span class="o">+</span> <span class="n">var</span><span class="o">-&gt;</span><span class="n">vsync_len</span><span class="p">;</span>

	<span class="n">temp</span> <span class="o">=</span> <span class="p">((</span><span class="n">v_total</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">v_active</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">status</span> <span class="o">=</span> <span class="n">ufx_reg_write</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mh">0x2014</span><span class="p">,</span> <span class="n">temp</span><span class="p">);</span>
	<span class="n">check_warn_return</span><span class="p">(</span><span class="n">status</span><span class="p">,</span> <span class="s">&quot;ufx_set_vid_mode error writing 0x2014&quot;</span><span class="p">);</span>

	<span class="n">temp</span> <span class="o">=</span> <span class="p">((</span><span class="n">v_blank_start</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">v_blank_end</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">status</span> <span class="o">=</span> <span class="n">ufx_reg_write</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mh">0x2018</span><span class="p">,</span> <span class="n">temp</span><span class="p">);</span>
	<span class="n">check_warn_return</span><span class="p">(</span><span class="n">status</span><span class="p">,</span> <span class="s">&quot;ufx_set_vid_mode error writing 0x2018&quot;</span><span class="p">);</span>

	<span class="n">temp</span> <span class="o">=</span> <span class="p">((</span><span class="n">v_sync_start</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">v_sync_end</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">status</span> <span class="o">=</span> <span class="n">ufx_reg_write</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mh">0x201C</span><span class="p">,</span> <span class="n">temp</span><span class="p">);</span>
	<span class="n">check_warn_return</span><span class="p">(</span><span class="n">status</span><span class="p">,</span> <span class="s">&quot;ufx_set_vid_mode error writing 0x201C&quot;</span><span class="p">);</span>

	<span class="n">status</span> <span class="o">=</span> <span class="n">ufx_reg_write</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mh">0x2020</span><span class="p">,</span> <span class="mh">0x00000000</span><span class="p">);</span>
	<span class="n">check_warn_return</span><span class="p">(</span><span class="n">status</span><span class="p">,</span> <span class="s">&quot;ufx_set_vid_mode error writing 0x2020&quot;</span><span class="p">);</span>

	<span class="n">status</span> <span class="o">=</span> <span class="n">ufx_reg_write</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mh">0x2024</span><span class="p">,</span> <span class="mh">0x00000000</span><span class="p">);</span>
	<span class="n">check_warn_return</span><span class="p">(</span><span class="n">status</span><span class="p">,</span> <span class="s">&quot;ufx_set_vid_mode error writing 0x2024&quot;</span><span class="p">);</span>

	<span class="cm">/* Set the frame length register (#pix * 2 bytes/pixel) */</span>
	<span class="n">temp</span> <span class="o">=</span> <span class="n">var</span><span class="o">-&gt;</span><span class="n">xres</span> <span class="o">*</span> <span class="n">var</span><span class="o">-&gt;</span><span class="n">yres</span> <span class="o">*</span> <span class="mi">2</span><span class="p">;</span>
	<span class="n">temp</span> <span class="o">=</span> <span class="p">(</span><span class="n">temp</span> <span class="o">+</span> <span class="mi">7</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="o">~</span><span class="mh">0x7</span><span class="p">);</span>
	<span class="n">status</span> <span class="o">=</span> <span class="n">ufx_reg_write</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mh">0x2028</span><span class="p">,</span> <span class="n">temp</span><span class="p">);</span>
	<span class="n">check_warn_return</span><span class="p">(</span><span class="n">status</span><span class="p">,</span> <span class="s">&quot;ufx_set_vid_mode error writing 0x2028&quot;</span><span class="p">);</span>

	<span class="cm">/* enable desired output interface &amp; disable others */</span>
	<span class="n">status</span> <span class="o">=</span> <span class="n">ufx_reg_write</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mh">0x2040</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">check_warn_return</span><span class="p">(</span><span class="n">status</span><span class="p">,</span> <span class="s">&quot;ufx_set_vid_mode error writing 0x2040&quot;</span><span class="p">);</span>

	<span class="n">status</span> <span class="o">=</span> <span class="n">ufx_reg_write</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mh">0x2044</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">check_warn_return</span><span class="p">(</span><span class="n">status</span><span class="p">,</span> <span class="s">&quot;ufx_set_vid_mode error writing 0x2044&quot;</span><span class="p">);</span>

	<span class="n">status</span> <span class="o">=</span> <span class="n">ufx_reg_write</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mh">0x2048</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">check_warn_return</span><span class="p">(</span><span class="n">status</span><span class="p">,</span> <span class="s">&quot;ufx_set_vid_mode error writing 0x2048&quot;</span><span class="p">);</span>

	<span class="cm">/* set the sync polarities &amp; enable bit */</span>
	<span class="n">temp</span> <span class="o">=</span> <span class="mh">0x00000001</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">var</span><span class="o">-&gt;</span><span class="n">sync</span> <span class="o">&amp;</span> <span class="n">FB_SYNC_HOR_HIGH_ACT</span><span class="p">)</span>
		<span class="n">temp</span> <span class="o">|=</span> <span class="mh">0x00000010</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">var</span><span class="o">-&gt;</span><span class="n">sync</span> <span class="o">&amp;</span> <span class="n">FB_SYNC_VERT_HIGH_ACT</span><span class="p">)</span>
		<span class="n">temp</span> <span class="o">|=</span> <span class="mh">0x00000008</span><span class="p">;</span>

	<span class="n">status</span> <span class="o">=</span> <span class="n">ufx_reg_write</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mh">0x2040</span><span class="p">,</span> <span class="n">temp</span><span class="p">);</span>
	<span class="n">check_warn_return</span><span class="p">(</span><span class="n">status</span><span class="p">,</span> <span class="s">&quot;ufx_set_vid_mode error writing 0x2040&quot;</span><span class="p">);</span>

	<span class="cm">/* start everything back up */</span>
	<span class="n">status</span> <span class="o">=</span> <span class="n">ufx_enable</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
	<span class="n">check_warn_return</span><span class="p">(</span><span class="n">status</span><span class="p">,</span> <span class="s">&quot;ufx_set_vid_mode error enabling display&quot;</span><span class="p">);</span>

	<span class="cm">/* Unblank the display */</span>
	<span class="n">status</span> <span class="o">=</span> <span class="n">ufx_unblank</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
	<span class="n">check_warn_return</span><span class="p">(</span><span class="n">status</span><span class="p">,</span> <span class="s">&quot;ufx_set_vid_mode error unblanking display&quot;</span><span class="p">);</span>

	<span class="cm">/* enable RGB pad */</span>
	<span class="n">status</span> <span class="o">=</span> <span class="n">ufx_reg_write</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mh">0x8028</span><span class="p">,</span> <span class="mh">0x00000003</span><span class="p">);</span>
	<span class="n">check_warn_return</span><span class="p">(</span><span class="n">status</span><span class="p">,</span> <span class="s">&quot;ufx_set_vid_mode error enabling RGB pad&quot;</span><span class="p">);</span>

	<span class="cm">/* enable VDAC */</span>
	<span class="n">status</span> <span class="o">=</span> <span class="n">ufx_reg_write</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mh">0x8024</span><span class="p">,</span> <span class="mh">0x00000007</span><span class="p">);</span>
	<span class="n">check_warn_return</span><span class="p">(</span><span class="n">status</span><span class="p">,</span> <span class="s">&quot;ufx_set_vid_mode error enabling VDAC&quot;</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">ufx_ops_mmap</span><span class="p">(</span><span class="k">struct</span> <span class="n">fb_info</span> <span class="o">*</span><span class="n">info</span><span class="p">,</span> <span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">start</span> <span class="o">=</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_start</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">size</span> <span class="o">=</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_end</span> <span class="o">-</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_start</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">offset</span> <span class="o">=</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_pgoff</span> <span class="o">&lt;&lt;</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">page</span><span class="p">,</span> <span class="n">pos</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">offset</span> <span class="o">+</span> <span class="n">size</span> <span class="o">&gt;</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">fix</span><span class="p">.</span><span class="n">smem_len</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">pos</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">fix</span><span class="p">.</span><span class="n">smem_start</span> <span class="o">+</span> <span class="n">offset</span><span class="p">;</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;mmap() framebuffer addr:%lu size:%lu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		  <span class="n">pos</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">page</span> <span class="o">=</span> <span class="n">vmalloc_to_pfn</span><span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">pos</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">remap_pfn_range</span><span class="p">(</span><span class="n">vma</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">page</span><span class="p">,</span> <span class="n">PAGE_SIZE</span><span class="p">,</span> <span class="n">PAGE_SHARED</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">;</span>

		<span class="n">start</span> <span class="o">+=</span> <span class="n">PAGE_SIZE</span><span class="p">;</span>
		<span class="n">pos</span> <span class="o">+=</span> <span class="n">PAGE_SIZE</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="o">&gt;</span> <span class="n">PAGE_SIZE</span><span class="p">)</span>
			<span class="n">size</span> <span class="o">-=</span> <span class="n">PAGE_SIZE</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_flags</span> <span class="o">|=</span> <span class="n">VM_RESERVED</span><span class="p">;</span>	<span class="cm">/* avoid to swap out this VMA */</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">ufx_raw_rect</span><span class="p">(</span><span class="k">struct</span> <span class="n">ufx_data</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="n">u16</span> <span class="o">*</span><span class="n">cmd</span><span class="p">,</span> <span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span><span class="p">,</span>
	<span class="kt">int</span> <span class="n">width</span><span class="p">,</span> <span class="kt">int</span> <span class="n">height</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">size_t</span> <span class="n">packed_line_len</span> <span class="o">=</span> <span class="n">ALIGN</span><span class="p">((</span><span class="n">width</span> <span class="o">*</span> <span class="mi">2</span><span class="p">),</span> <span class="mi">4</span><span class="p">);</span>
	<span class="kt">size_t</span> <span class="n">packed_rect_len</span> <span class="o">=</span> <span class="n">packed_line_len</span> <span class="o">*</span> <span class="n">height</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">line</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">info</span><span class="p">);</span>

	<span class="cm">/* command word */</span>
	<span class="o">*</span><span class="p">((</span><span class="n">u32</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">cmd</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="mh">0x01</span><span class="p">);</span>

	<span class="cm">/* length word */</span>
	<span class="o">*</span><span class="p">((</span><span class="n">u32</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">cmd</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">packed_rect_len</span> <span class="o">+</span> <span class="mi">16</span><span class="p">);</span>

	<span class="n">cmd</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
	<span class="n">cmd</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">y</span><span class="p">);</span>
	<span class="n">cmd</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span> <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">width</span><span class="p">);</span>
	<span class="n">cmd</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span> <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">height</span><span class="p">);</span>

	<span class="cm">/* frame base address */</span>
	<span class="o">*</span><span class="p">((</span><span class="n">u32</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">cmd</span><span class="p">[</span><span class="mi">8</span><span class="p">])</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>

	<span class="cm">/* color mode and horizontal resolution */</span>
	<span class="n">cmd</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span> <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="mh">0x4000</span> <span class="o">|</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">var</span><span class="p">.</span><span class="n">xres</span><span class="p">);</span>

	<span class="cm">/* vertical resolution */</span>
	<span class="n">cmd</span><span class="p">[</span><span class="mi">11</span><span class="p">]</span> <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">var</span><span class="p">.</span><span class="n">yres</span><span class="p">);</span>

	<span class="cm">/* packed data */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">line</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">line</span> <span class="o">&lt;</span> <span class="n">height</span><span class="p">;</span> <span class="n">line</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">const</span> <span class="kt">int</span> <span class="n">line_offset</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">fix</span><span class="p">.</span><span class="n">line_length</span> <span class="o">*</span> <span class="p">(</span><span class="n">y</span> <span class="o">+</span> <span class="n">line</span><span class="p">);</span>
		<span class="k">const</span> <span class="kt">int</span> <span class="n">byte_offset</span> <span class="o">=</span> <span class="n">line_offset</span> <span class="o">+</span> <span class="p">(</span><span class="n">x</span> <span class="o">*</span> <span class="n">BPP</span><span class="p">);</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmd</span><span class="p">[(</span><span class="mi">24</span> <span class="o">+</span> <span class="p">(</span><span class="n">packed_line_len</span> <span class="o">*</span> <span class="n">line</span><span class="p">))</span> <span class="o">/</span> <span class="mi">2</span><span class="p">],</span>
			<span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">fix</span><span class="p">.</span><span class="n">smem_start</span> <span class="o">+</span> <span class="n">byte_offset</span><span class="p">,</span> <span class="n">width</span> <span class="o">*</span> <span class="n">BPP</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">ufx_handle_damage</span><span class="p">(</span><span class="k">struct</span> <span class="n">ufx_data</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span><span class="p">,</span>
	<span class="kt">int</span> <span class="n">width</span><span class="p">,</span> <span class="kt">int</span> <span class="n">height</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">size_t</span> <span class="n">packed_line_len</span> <span class="o">=</span> <span class="n">ALIGN</span><span class="p">((</span><span class="n">width</span> <span class="o">*</span> <span class="mi">2</span><span class="p">),</span> <span class="mi">4</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">len</span><span class="p">,</span> <span class="n">status</span><span class="p">,</span> <span class="n">urb_lines</span><span class="p">,</span> <span class="n">start_line</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">width</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">height</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">||</span>
	    <span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">width</span> <span class="o">&gt;</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">var</span><span class="p">.</span><span class="n">xres</span><span class="p">)</span> <span class="o">||</span>
	    <span class="p">(</span><span class="n">y</span> <span class="o">+</span> <span class="n">height</span> <span class="o">&gt;</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">var</span><span class="p">.</span><span class="n">yres</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">usb_active</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">start_line</span> <span class="o">&lt;</span> <span class="n">height</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">urb</span> <span class="o">=</span> <span class="n">ufx_get_urb</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">urb</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pr_warn</span><span class="p">(</span><span class="s">&quot;ufx_handle_damage unable to get urb&quot;</span><span class="p">);</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* assume we have enough space to transfer at least one line */</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_buffer_length</span> <span class="o">&lt;</span> <span class="p">(</span><span class="mi">24</span> <span class="o">+</span> <span class="p">(</span><span class="n">width</span> <span class="o">*</span> <span class="mi">2</span><span class="p">)));</span>

		<span class="cm">/* calculate the maximum number of lines we could fit in */</span>
		<span class="n">urb_lines</span> <span class="o">=</span> <span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_buffer_length</span> <span class="o">-</span> <span class="mi">24</span><span class="p">)</span> <span class="o">/</span> <span class="n">packed_line_len</span><span class="p">;</span>

		<span class="cm">/* but we might not need this many */</span>
		<span class="n">urb_lines</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">urb_lines</span><span class="p">,</span> <span class="p">(</span><span class="n">height</span> <span class="o">-</span> <span class="n">start_line</span><span class="p">));</span>

		<span class="n">memset</span><span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_buffer</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_buffer_length</span><span class="p">);</span>

		<span class="n">ufx_raw_rect</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_buffer</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="p">(</span><span class="n">y</span> <span class="o">+</span> <span class="n">start_line</span><span class="p">),</span> <span class="n">width</span><span class="p">,</span> <span class="n">urb_lines</span><span class="p">);</span>
		<span class="n">len</span> <span class="o">=</span> <span class="mi">24</span> <span class="o">+</span> <span class="p">(</span><span class="n">packed_line_len</span> <span class="o">*</span> <span class="n">urb_lines</span><span class="p">);</span>

		<span class="n">status</span> <span class="o">=</span> <span class="n">ufx_submit_urb</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">urb</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
		<span class="n">check_warn_return</span><span class="p">(</span><span class="n">status</span><span class="p">,</span> <span class="s">&quot;Error submitting URB&quot;</span><span class="p">);</span>

		<span class="n">start_line</span> <span class="o">+=</span> <span class="n">urb_lines</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Path triggered by usermode clients who write to filesystem</span>
<span class="cm"> * e.g. cat filename &gt; /dev/fb1</span>
<span class="cm"> * Not used by X Windows or text-mode console. But useful for testing.</span>
<span class="cm"> * Slow because of extra copy and we must assume all pixels dirty. */</span>
<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">ufx_ops_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">fb_info</span> <span class="o">*</span><span class="n">info</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span>
			  <span class="kt">size_t</span> <span class="n">count</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">ppos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">ssize_t</span> <span class="n">result</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ufx_data</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">par</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">offset</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span> <span class="o">*</span><span class="n">ppos</span><span class="p">;</span>

	<span class="n">result</span> <span class="o">=</span> <span class="n">fb_sys_write</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">count</span><span class="p">,</span> <span class="n">ppos</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">start</span> <span class="o">=</span> <span class="n">max</span><span class="p">((</span><span class="kt">int</span><span class="p">)(</span><span class="n">offset</span> <span class="o">/</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">fix</span><span class="p">.</span><span class="n">line_length</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="kt">int</span> <span class="n">lines</span> <span class="o">=</span> <span class="n">min</span><span class="p">((</span><span class="n">u32</span><span class="p">)((</span><span class="n">result</span> <span class="o">/</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">fix</span><span class="p">.</span><span class="n">line_length</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span>
				<span class="p">(</span><span class="n">u32</span><span class="p">)</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">var</span><span class="p">.</span><span class="n">yres</span><span class="p">);</span>

		<span class="n">ufx_handle_damage</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">var</span><span class="p">.</span><span class="n">xres</span><span class="p">,</span> <span class="n">lines</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">ufx_ops_copyarea</span><span class="p">(</span><span class="k">struct</span> <span class="n">fb_info</span> <span class="o">*</span><span class="n">info</span><span class="p">,</span>
				<span class="k">const</span> <span class="k">struct</span> <span class="n">fb_copyarea</span> <span class="o">*</span><span class="n">area</span><span class="p">)</span>
<span class="p">{</span>

	<span class="k">struct</span> <span class="n">ufx_data</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">par</span><span class="p">;</span>

	<span class="n">sys_copyarea</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="n">area</span><span class="p">);</span>

	<span class="n">ufx_handle_damage</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">area</span><span class="o">-&gt;</span><span class="n">dx</span><span class="p">,</span> <span class="n">area</span><span class="o">-&gt;</span><span class="n">dy</span><span class="p">,</span>
			<span class="n">area</span><span class="o">-&gt;</span><span class="n">width</span><span class="p">,</span> <span class="n">area</span><span class="o">-&gt;</span><span class="n">height</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">ufx_ops_imageblit</span><span class="p">(</span><span class="k">struct</span> <span class="n">fb_info</span> <span class="o">*</span><span class="n">info</span><span class="p">,</span>
				<span class="k">const</span> <span class="k">struct</span> <span class="n">fb_image</span> <span class="o">*</span><span class="n">image</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ufx_data</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">par</span><span class="p">;</span>

	<span class="n">sys_imageblit</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="n">image</span><span class="p">);</span>

	<span class="n">ufx_handle_damage</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">image</span><span class="o">-&gt;</span><span class="n">dx</span><span class="p">,</span> <span class="n">image</span><span class="o">-&gt;</span><span class="n">dy</span><span class="p">,</span>
			<span class="n">image</span><span class="o">-&gt;</span><span class="n">width</span><span class="p">,</span> <span class="n">image</span><span class="o">-&gt;</span><span class="n">height</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">ufx_ops_fillrect</span><span class="p">(</span><span class="k">struct</span> <span class="n">fb_info</span> <span class="o">*</span><span class="n">info</span><span class="p">,</span>
			  <span class="k">const</span> <span class="k">struct</span> <span class="n">fb_fillrect</span> <span class="o">*</span><span class="n">rect</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ufx_data</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">par</span><span class="p">;</span>

	<span class="n">sys_fillrect</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="n">rect</span><span class="p">);</span>

	<span class="n">ufx_handle_damage</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">rect</span><span class="o">-&gt;</span><span class="n">dx</span><span class="p">,</span> <span class="n">rect</span><span class="o">-&gt;</span><span class="n">dy</span><span class="p">,</span> <span class="n">rect</span><span class="o">-&gt;</span><span class="n">width</span><span class="p">,</span>
			      <span class="n">rect</span><span class="o">-&gt;</span><span class="n">height</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* NOTE: fb_defio.c is holding info-&gt;fbdefio.mutex</span>
<span class="cm"> *   Touching ANY framebuffer memory that triggers a page fault</span>
<span class="cm"> *   in fb_defio will cause a deadlock, when it also tries to</span>
<span class="cm"> *   grab the same mutex. */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">ufx_dpy_deferred_io</span><span class="p">(</span><span class="k">struct</span> <span class="n">fb_info</span> <span class="o">*</span><span class="n">info</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">pagelist</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">cur</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fb_deferred_io</span> <span class="o">*</span><span class="n">fbdefio</span> <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">fbdefio</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ufx_data</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">par</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">fb_defio</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">usb_active</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/* walk the written page list and render each to device */</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">cur</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fbdefio</span><span class="o">-&gt;</span><span class="n">pagelist</span><span class="p">,</span> <span class="n">lru</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* create a rectangle of full screen width that encloses the</span>
<span class="cm">		 * entire dirty framebuffer page */</span>
		<span class="k">const</span> <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">const</span> <span class="kt">int</span> <span class="n">width</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">var</span><span class="p">.</span><span class="n">xres</span><span class="p">;</span>
		<span class="k">const</span> <span class="kt">int</span> <span class="n">y</span> <span class="o">=</span> <span class="p">(</span><span class="n">cur</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">&lt;&lt;</span> <span class="n">PAGE_SHIFT</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">width</span> <span class="o">*</span> <span class="mi">2</span><span class="p">);</span>
		<span class="kt">int</span> <span class="n">height</span> <span class="o">=</span> <span class="p">(</span><span class="n">PAGE_SIZE</span> <span class="o">/</span> <span class="p">(</span><span class="n">width</span> <span class="o">*</span> <span class="mi">2</span><span class="p">))</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">height</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">height</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">var</span><span class="p">.</span><span class="n">yres</span> <span class="o">-</span> <span class="n">y</span><span class="p">));</span>

		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">y</span> <span class="o">&gt;=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">var</span><span class="p">.</span><span class="n">yres</span><span class="p">);</span>
		<span class="n">BUG_ON</span><span class="p">((</span><span class="n">y</span> <span class="o">+</span> <span class="n">height</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">var</span><span class="p">.</span><span class="n">yres</span><span class="p">);</span>

		<span class="n">ufx_handle_damage</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">ufx_ops_ioctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">fb_info</span> <span class="o">*</span><span class="n">info</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">,</span>
			 <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ufx_data</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">par</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dloarea</span> <span class="o">*</span><span class="n">area</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">usb_active</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* TODO: Update X server to get this from sysfs instead */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span> <span class="o">==</span> <span class="n">UFX_IOCTL_RETURN_EDID</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">u8</span> <span class="n">__user</span> <span class="o">*</span><span class="n">edid</span> <span class="o">=</span> <span class="p">(</span><span class="n">u8</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span><span class="n">arg</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">copy_to_user</span><span class="p">(</span><span class="n">edid</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">edid</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">edid_size</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* TODO: Help propose a standard fb.h ioctl to report mmap damage */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span> <span class="o">==</span> <span class="n">UFX_IOCTL_REPORT_DAMAGE</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* If we have a damage-aware client, turn fb_defio &quot;off&quot;</span>
<span class="cm">		 * To avoid perf imact of unecessary page fault handling.</span>
<span class="cm">		 * Done by resetting the delay for this fb_info to a very</span>
<span class="cm">		 * long period. Pages will become writable and stay that way.</span>
<span class="cm">		 * Reset to normal value when all clients have closed this fb.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">fbdefio</span><span class="p">)</span>
			<span class="n">info</span><span class="o">-&gt;</span><span class="n">fbdefio</span><span class="o">-&gt;</span><span class="n">delay</span> <span class="o">=</span> <span class="n">UFX_DEFIO_WRITE_DISABLE</span><span class="p">;</span>

		<span class="n">area</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">dloarea</span> <span class="o">*</span><span class="p">)</span><span class="n">arg</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">area</span><span class="o">-&gt;</span><span class="n">x</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">area</span><span class="o">-&gt;</span><span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">area</span><span class="o">-&gt;</span><span class="n">x</span> <span class="o">&gt;</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">var</span><span class="p">.</span><span class="n">xres</span><span class="p">)</span>
			<span class="n">area</span><span class="o">-&gt;</span><span class="n">x</span> <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">var</span><span class="p">.</span><span class="n">xres</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">area</span><span class="o">-&gt;</span><span class="n">y</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">area</span><span class="o">-&gt;</span><span class="n">y</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">area</span><span class="o">-&gt;</span><span class="n">y</span> <span class="o">&gt;</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">var</span><span class="p">.</span><span class="n">yres</span><span class="p">)</span>
			<span class="n">area</span><span class="o">-&gt;</span><span class="n">y</span> <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">var</span><span class="p">.</span><span class="n">yres</span><span class="p">;</span>

		<span class="n">ufx_handle_damage</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">area</span><span class="o">-&gt;</span><span class="n">x</span><span class="p">,</span> <span class="n">area</span><span class="o">-&gt;</span><span class="n">y</span><span class="p">,</span> <span class="n">area</span><span class="o">-&gt;</span><span class="n">w</span><span class="p">,</span> <span class="n">area</span><span class="o">-&gt;</span><span class="n">h</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* taken from vesafb */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">ufx_ops_setcolreg</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">regno</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">red</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">green</span><span class="p">,</span>
	       <span class="kt">unsigned</span> <span class="n">blue</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">transp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">fb_info</span> <span class="o">*</span><span class="n">info</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">regno</span> <span class="o">&gt;=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">cmap</span><span class="p">.</span><span class="n">len</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">regno</span> <span class="o">&lt;</span> <span class="mi">16</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">var</span><span class="p">.</span><span class="n">red</span><span class="p">.</span><span class="n">offset</span> <span class="o">==</span> <span class="mi">10</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* 1:5:5:5 */</span>
			<span class="p">((</span><span class="n">u32</span> <span class="o">*</span><span class="p">)</span> <span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">pseudo_palette</span><span class="p">))[</span><span class="n">regno</span><span class="p">]</span> <span class="o">=</span>
			    <span class="p">((</span><span class="n">red</span> <span class="o">&amp;</span> <span class="mh">0xf800</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">|</span>
			    <span class="p">((</span><span class="n">green</span> <span class="o">&amp;</span> <span class="mh">0xf800</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">6</span><span class="p">)</span> <span class="o">|</span> <span class="p">((</span><span class="n">blue</span> <span class="o">&amp;</span> <span class="mh">0xf800</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">11</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/* 0:5:6:5 */</span>
			<span class="p">((</span><span class="n">u32</span> <span class="o">*</span><span class="p">)</span> <span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">pseudo_palette</span><span class="p">))[</span><span class="n">regno</span><span class="p">]</span> <span class="o">=</span>
			    <span class="p">((</span><span class="n">red</span> <span class="o">&amp;</span> <span class="mh">0xf800</span><span class="p">))</span> <span class="o">|</span>
			    <span class="p">((</span><span class="n">green</span> <span class="o">&amp;</span> <span class="mh">0xfc00</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">5</span><span class="p">)</span> <span class="o">|</span> <span class="p">((</span><span class="n">blue</span> <span class="o">&amp;</span> <span class="mh">0xf800</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">11</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* It&#39;s common for several clients to have framebuffer open simultaneously.</span>
<span class="cm"> * e.g. both fbcon and X. Makes things interesting.</span>
<span class="cm"> * Assumes caller is holding info-&gt;lock (for open and release at least) */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">ufx_ops_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">fb_info</span> <span class="o">*</span><span class="n">info</span><span class="p">,</span> <span class="kt">int</span> <span class="n">user</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ufx_data</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">par</span><span class="p">;</span>

	<span class="cm">/* fbcon aggressively connects to first framebuffer it finds,</span>
<span class="cm">	 * preventing other clients (X) from working properly. Usually</span>
<span class="cm">	 * not what the user wants. Fail by default with option to enable. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">user</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">console</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>

	<span class="cm">/* If the USB device is gone, we don&#39;t accept new opens */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">virtualized</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>

	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">fb_count</span><span class="o">++</span><span class="p">;</span>

	<span class="n">kref_get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">kref</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">fb_defio</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">fbdefio</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* enable defio at last moment if not disabled by client */</span>

		<span class="k">struct</span> <span class="n">fb_deferred_io</span> <span class="o">*</span><span class="n">fbdefio</span><span class="p">;</span>

		<span class="n">fbdefio</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">fb_deferred_io</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">fbdefio</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">fbdefio</span><span class="o">-&gt;</span><span class="n">delay</span> <span class="o">=</span> <span class="n">UFX_DEFIO_WRITE_DELAY</span><span class="p">;</span>
			<span class="n">fbdefio</span><span class="o">-&gt;</span><span class="n">deferred_io</span> <span class="o">=</span> <span class="n">ufx_dpy_deferred_io</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">info</span><span class="o">-&gt;</span><span class="n">fbdefio</span> <span class="o">=</span> <span class="n">fbdefio</span><span class="p">;</span>
		<span class="n">fb_deferred_io_init</span><span class="p">(</span><span class="n">info</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;open /dev/fb%d user=%d fb_info=%p count=%d&quot;</span><span class="p">,</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">,</span> <span class="n">user</span><span class="p">,</span> <span class="n">info</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">fb_count</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Called when all client interfaces to start transactions have been disabled,</span>
<span class="cm"> * and all references to our device instance (ufx_data) are released.</span>
<span class="cm"> * Every transaction must have a reference, so we know are fully spun down</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">ufx_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">kref</span> <span class="o">*</span><span class="n">kref</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ufx_data</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">kref</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ufx_data</span><span class="p">,</span> <span class="n">kref</span><span class="p">);</span>

	<span class="cm">/* this function will wait for all in-flight urbs to complete */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">urbs</span><span class="p">.</span><span class="n">count</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">ufx_free_urb_list</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;freeing ufx_data %p&quot;</span><span class="p">,</span> <span class="n">dev</span><span class="p">);</span>

	<span class="n">kfree</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">ufx_release_urb_work</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">urb_node</span> <span class="o">*</span><span class="n">unode</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">work</span><span class="p">,</span> <span class="k">struct</span> <span class="n">urb_node</span><span class="p">,</span>
					      <span class="n">release_urb_work</span><span class="p">.</span><span class="n">work</span><span class="p">);</span>

	<span class="n">up</span><span class="p">(</span><span class="o">&amp;</span><span class="n">unode</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">urbs</span><span class="p">.</span><span class="n">limit_sem</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">ufx_free_framebuffer_work</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ufx_data</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">work</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ufx_data</span><span class="p">,</span>
					    <span class="n">free_framebuffer_work</span><span class="p">.</span><span class="n">work</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">fb_info</span> <span class="o">*</span><span class="n">info</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">info</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">node</span> <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">;</span>

	<span class="n">unregister_framebuffer</span><span class="p">(</span><span class="n">info</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">cmap</span><span class="p">.</span><span class="n">len</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">fb_dealloc_cmap</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">cmap</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">monspecs</span><span class="p">.</span><span class="n">modedb</span><span class="p">)</span>
		<span class="n">fb_destroy_modedb</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">monspecs</span><span class="p">.</span><span class="n">modedb</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">screen_base</span><span class="p">)</span>
		<span class="n">vfree</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">screen_base</span><span class="p">);</span>

	<span class="n">fb_destroy_modelist</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">modelist</span><span class="p">);</span>

	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">info</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Assume info structure is freed after this point */</span>
	<span class="n">framebuffer_release</span><span class="p">(</span><span class="n">info</span><span class="p">);</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;fb_info for /dev/fb%d has been freed&quot;</span><span class="p">,</span> <span class="n">node</span><span class="p">);</span>

	<span class="cm">/* ref taken in probe() as part of registering framebfufer */</span>
	<span class="n">kref_put</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">kref</span><span class="p">,</span> <span class="n">ufx_free</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Assumes caller is holding info-&gt;lock mutex (for open and release at least)</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">ufx_ops_release</span><span class="p">(</span><span class="k">struct</span> <span class="n">fb_info</span> <span class="o">*</span><span class="n">info</span><span class="p">,</span> <span class="kt">int</span> <span class="n">user</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ufx_data</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">par</span><span class="p">;</span>

	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">fb_count</span><span class="o">--</span><span class="p">;</span>

	<span class="cm">/* We can&#39;t free fb_info here - fbmem will touch it when we return */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">virtualized</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">fb_count</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span>
		<span class="n">schedule_delayed_work</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">free_framebuffer_work</span><span class="p">,</span> <span class="n">HZ</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">fb_count</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">fbdefio</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">fb_deferred_io_cleanup</span><span class="p">(</span><span class="n">info</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">fbdefio</span><span class="p">);</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">fbdefio</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">fbops</span><span class="o">-&gt;</span><span class="n">fb_mmap</span> <span class="o">=</span> <span class="n">ufx_ops_mmap</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;released /dev/fb%d user=%d count=%d&quot;</span><span class="p">,</span>
		  <span class="n">info</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">,</span> <span class="n">user</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">fb_count</span><span class="p">);</span>

	<span class="n">kref_put</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">kref</span><span class="p">,</span> <span class="n">ufx_free</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Check whether a video mode is supported by the chip</span>
<span class="cm"> * We start from monitor&#39;s modes, so don&#39;t need to filter that here */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">ufx_is_valid_mode</span><span class="p">(</span><span class="k">struct</span> <span class="n">fb_videomode</span> <span class="o">*</span><span class="n">mode</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">fb_info</span> <span class="o">*</span><span class="n">info</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">mode</span><span class="o">-&gt;</span><span class="n">xres</span> <span class="o">*</span> <span class="n">mode</span><span class="o">-&gt;</span><span class="n">yres</span><span class="p">)</span> <span class="o">&gt;</span> <span class="p">(</span><span class="mi">2048</span> <span class="o">*</span> <span class="mi">1152</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;%dx%d too many pixels&quot;</span><span class="p">,</span>
		       <span class="n">mode</span><span class="o">-&gt;</span><span class="n">xres</span><span class="p">,</span> <span class="n">mode</span><span class="o">-&gt;</span><span class="n">yres</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">mode</span><span class="o">-&gt;</span><span class="n">pixclock</span> <span class="o">&lt;</span> <span class="mi">5000</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;%dx%d %dps pixel clock too fast&quot;</span><span class="p">,</span>
		       <span class="n">mode</span><span class="o">-&gt;</span><span class="n">xres</span><span class="p">,</span> <span class="n">mode</span><span class="o">-&gt;</span><span class="n">yres</span><span class="p">,</span> <span class="n">mode</span><span class="o">-&gt;</span><span class="n">pixclock</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;%dx%d (pixclk %dps %dMHz) valid mode&quot;</span><span class="p">,</span> <span class="n">mode</span><span class="o">-&gt;</span><span class="n">xres</span><span class="p">,</span> <span class="n">mode</span><span class="o">-&gt;</span><span class="n">yres</span><span class="p">,</span>
		<span class="n">mode</span><span class="o">-&gt;</span><span class="n">pixclock</span><span class="p">,</span> <span class="p">(</span><span class="mi">1000000</span> <span class="o">/</span> <span class="n">mode</span><span class="o">-&gt;</span><span class="n">pixclock</span><span class="p">));</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">ufx_var_color_format</span><span class="p">(</span><span class="k">struct</span> <span class="n">fb_var_screeninfo</span> <span class="o">*</span><span class="n">var</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">fb_bitfield</span> <span class="n">red</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">11</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">0</span> <span class="p">};</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">fb_bitfield</span> <span class="n">green</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">0</span> <span class="p">};</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">fb_bitfield</span> <span class="n">blue</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">0</span> <span class="p">};</span>

	<span class="n">var</span><span class="o">-&gt;</span><span class="n">bits_per_pixel</span> <span class="o">=</span> <span class="mi">16</span><span class="p">;</span>
	<span class="n">var</span><span class="o">-&gt;</span><span class="n">red</span> <span class="o">=</span> <span class="n">red</span><span class="p">;</span>
	<span class="n">var</span><span class="o">-&gt;</span><span class="n">green</span> <span class="o">=</span> <span class="n">green</span><span class="p">;</span>
	<span class="n">var</span><span class="o">-&gt;</span><span class="n">blue</span> <span class="o">=</span> <span class="n">blue</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">ufx_ops_check_var</span><span class="p">(</span><span class="k">struct</span> <span class="n">fb_var_screeninfo</span> <span class="o">*</span><span class="n">var</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">fb_info</span> <span class="o">*</span><span class="n">info</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fb_videomode</span> <span class="n">mode</span><span class="p">;</span>

	<span class="cm">/* TODO: support dynamically changing framebuffer size */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">var</span><span class="o">-&gt;</span><span class="n">xres</span> <span class="o">*</span> <span class="n">var</span><span class="o">-&gt;</span><span class="n">yres</span> <span class="o">*</span> <span class="mi">2</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">fix</span><span class="p">.</span><span class="n">smem_len</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="cm">/* set device-specific elements of var unrelated to mode */</span>
	<span class="n">ufx_var_color_format</span><span class="p">(</span><span class="n">var</span><span class="p">);</span>

	<span class="n">fb_var_to_videomode</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mode</span><span class="p">,</span> <span class="n">var</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ufx_is_valid_mode</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mode</span><span class="p">,</span> <span class="n">info</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">ufx_ops_set_par</span><span class="p">(</span><span class="k">struct</span> <span class="n">fb_info</span> <span class="o">*</span><span class="n">info</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ufx_data</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">par</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">result</span><span class="p">;</span>
	<span class="n">u16</span> <span class="o">*</span><span class="n">pix_framebuffer</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;set_par mode %dx%d&quot;</span><span class="p">,</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">var</span><span class="p">.</span><span class="n">xres</span><span class="p">,</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">var</span><span class="p">.</span><span class="n">yres</span><span class="p">);</span>
	<span class="n">result</span> <span class="o">=</span> <span class="n">ufx_set_vid_mode</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">var</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">result</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">fb_count</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* paint greenscreen */</span>
		<span class="n">pix_framebuffer</span> <span class="o">=</span> <span class="p">(</span><span class="n">u16</span> <span class="o">*</span><span class="p">)</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">screen_base</span><span class="p">;</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">fix</span><span class="p">.</span><span class="n">smem_len</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
			<span class="n">pix_framebuffer</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x37e6</span><span class="p">;</span>

		<span class="n">ufx_handle_damage</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">var</span><span class="p">.</span><span class="n">xres</span><span class="p">,</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">var</span><span class="p">.</span><span class="n">yres</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* re-enable defio if previously disabled by damage tracking */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">fbdefio</span><span class="p">)</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">fbdefio</span><span class="o">-&gt;</span><span class="n">delay</span> <span class="o">=</span> <span class="n">UFX_DEFIO_WRITE_DELAY</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* In order to come back from full DPMS off, we need to set the mode again */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">ufx_ops_blank</span><span class="p">(</span><span class="kt">int</span> <span class="n">blank_mode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">fb_info</span> <span class="o">*</span><span class="n">info</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ufx_data</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">par</span><span class="p">;</span>
	<span class="n">ufx_set_vid_mode</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">var</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">fb_ops</span> <span class="n">ufx_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">owner</span> <span class="o">=</span> <span class="n">THIS_MODULE</span><span class="p">,</span>
	<span class="p">.</span><span class="n">fb_read</span> <span class="o">=</span> <span class="n">fb_sys_read</span><span class="p">,</span>
	<span class="p">.</span><span class="n">fb_write</span> <span class="o">=</span> <span class="n">ufx_ops_write</span><span class="p">,</span>
	<span class="p">.</span><span class="n">fb_setcolreg</span> <span class="o">=</span> <span class="n">ufx_ops_setcolreg</span><span class="p">,</span>
	<span class="p">.</span><span class="n">fb_fillrect</span> <span class="o">=</span> <span class="n">ufx_ops_fillrect</span><span class="p">,</span>
	<span class="p">.</span><span class="n">fb_copyarea</span> <span class="o">=</span> <span class="n">ufx_ops_copyarea</span><span class="p">,</span>
	<span class="p">.</span><span class="n">fb_imageblit</span> <span class="o">=</span> <span class="n">ufx_ops_imageblit</span><span class="p">,</span>
	<span class="p">.</span><span class="n">fb_mmap</span> <span class="o">=</span> <span class="n">ufx_ops_mmap</span><span class="p">,</span>
	<span class="p">.</span><span class="n">fb_ioctl</span> <span class="o">=</span> <span class="n">ufx_ops_ioctl</span><span class="p">,</span>
	<span class="p">.</span><span class="n">fb_open</span> <span class="o">=</span> <span class="n">ufx_ops_open</span><span class="p">,</span>
	<span class="p">.</span><span class="n">fb_release</span> <span class="o">=</span> <span class="n">ufx_ops_release</span><span class="p">,</span>
	<span class="p">.</span><span class="n">fb_blank</span> <span class="o">=</span> <span class="n">ufx_ops_blank</span><span class="p">,</span>
	<span class="p">.</span><span class="n">fb_check_var</span> <span class="o">=</span> <span class="n">ufx_ops_check_var</span><span class="p">,</span>
	<span class="p">.</span><span class="n">fb_set_par</span> <span class="o">=</span> <span class="n">ufx_ops_set_par</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/* Assumes &amp;info-&gt;lock held by caller</span>
<span class="cm"> * Assumes no active clients have framebuffer open */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">ufx_realloc_framebuffer</span><span class="p">(</span><span class="k">struct</span> <span class="n">ufx_data</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">fb_info</span> <span class="o">*</span><span class="n">info</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">old_len</span> <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">fix</span><span class="p">.</span><span class="n">smem_len</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">new_len</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">old_fb</span> <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">screen_base</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">new_fb</span><span class="p">;</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;Reallocating framebuffer. Addresses will change!&quot;</span><span class="p">);</span>

	<span class="n">new_len</span> <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">fix</span><span class="p">.</span><span class="n">line_length</span> <span class="o">*</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">var</span><span class="p">.</span><span class="n">yres</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">PAGE_ALIGN</span><span class="p">(</span><span class="n">new_len</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">old_len</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Alloc system memory for virtual framebuffer</span>
<span class="cm">		 */</span>
		<span class="n">new_fb</span> <span class="o">=</span> <span class="n">vmalloc</span><span class="p">(</span><span class="n">new_len</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">new_fb</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;Virtual framebuffer alloc failed&quot;</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">screen_base</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">memcpy</span><span class="p">(</span><span class="n">new_fb</span><span class="p">,</span> <span class="n">old_fb</span><span class="p">,</span> <span class="n">old_len</span><span class="p">);</span>
			<span class="n">vfree</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">screen_base</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="n">info</span><span class="o">-&gt;</span><span class="n">screen_base</span> <span class="o">=</span> <span class="n">new_fb</span><span class="p">;</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">fix</span><span class="p">.</span><span class="n">smem_len</span> <span class="o">=</span> <span class="n">PAGE_ALIGN</span><span class="p">(</span><span class="n">new_len</span><span class="p">);</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">fix</span><span class="p">.</span><span class="n">smem_start</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">new_fb</span><span class="p">;</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">=</span> <span class="n">smscufx_info_flags</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">retval</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">error:</span>
	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* sets up I2C Controller for 100 Kbps, std. speed, 7-bit addr, master,</span>
<span class="cm"> * restart enabled, but no start byte, enable controller */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">ufx_i2c_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">ufx_data</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">tmp</span><span class="p">;</span>

	<span class="cm">/* disable the controller before it can be reprogrammed */</span>
	<span class="kt">int</span> <span class="n">status</span> <span class="o">=</span> <span class="n">ufx_reg_write</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mh">0x106C</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">);</span>
	<span class="n">check_warn_return</span><span class="p">(</span><span class="n">status</span><span class="p">,</span> <span class="s">&quot;failed to disable I2C&quot;</span><span class="p">);</span>

	<span class="cm">/* Setup the clock count registers</span>
<span class="cm">	 * (12+1) = 13 clks @ 2.5 MHz = 5.2 uS */</span>
	<span class="n">status</span> <span class="o">=</span> <span class="n">ufx_reg_write</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mh">0x1018</span><span class="p">,</span> <span class="mi">12</span><span class="p">);</span>
	<span class="n">check_warn_return</span><span class="p">(</span><span class="n">status</span><span class="p">,</span> <span class="s">&quot;error writing 0x1018&quot;</span><span class="p">);</span>

	<span class="cm">/* (6+8) = 14 clks @ 2.5 MHz = 5.6 uS */</span>
	<span class="n">status</span> <span class="o">=</span> <span class="n">ufx_reg_write</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mh">0x1014</span><span class="p">,</span> <span class="mi">6</span><span class="p">);</span>
	<span class="n">check_warn_return</span><span class="p">(</span><span class="n">status</span><span class="p">,</span> <span class="s">&quot;error writing 0x1014&quot;</span><span class="p">);</span>

	<span class="n">status</span> <span class="o">=</span> <span class="n">ufx_reg_read</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mh">0x1000</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tmp</span><span class="p">);</span>
	<span class="n">check_warn_return</span><span class="p">(</span><span class="n">status</span><span class="p">,</span> <span class="s">&quot;error reading 0x1000&quot;</span><span class="p">);</span>

	<span class="cm">/* set speed to std mode */</span>
	<span class="n">tmp</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="mh">0x06</span><span class="p">);</span>
	<span class="n">tmp</span> <span class="o">|=</span> <span class="mh">0x02</span><span class="p">;</span>

	<span class="cm">/* 7-bit (not 10-bit) addressing */</span>
	<span class="n">tmp</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="mh">0x10</span><span class="p">);</span>

	<span class="cm">/* enable restart conditions and master mode */</span>
	<span class="n">tmp</span> <span class="o">|=</span> <span class="mh">0x21</span><span class="p">;</span>

	<span class="n">status</span> <span class="o">=</span> <span class="n">ufx_reg_write</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mh">0x1000</span><span class="p">,</span> <span class="n">tmp</span><span class="p">);</span>
	<span class="n">check_warn_return</span><span class="p">(</span><span class="n">status</span><span class="p">,</span> <span class="s">&quot;error writing 0x1000&quot;</span><span class="p">);</span>

	<span class="cm">/* Set normal tx using target address 0 */</span>
	<span class="n">status</span> <span class="o">=</span> <span class="n">ufx_reg_clear_and_set_bits</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mh">0x1004</span><span class="p">,</span> <span class="mh">0xC00</span><span class="p">,</span> <span class="mh">0x000</span><span class="p">);</span>
	<span class="n">check_warn_return</span><span class="p">(</span><span class="n">status</span><span class="p">,</span> <span class="s">&quot;error setting TX mode bits in 0x1004&quot;</span><span class="p">);</span>

	<span class="cm">/* Enable the controller */</span>
	<span class="n">status</span> <span class="o">=</span> <span class="n">ufx_reg_write</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mh">0x106C</span><span class="p">,</span> <span class="mh">0x01</span><span class="p">);</span>
	<span class="n">check_warn_return</span><span class="p">(</span><span class="n">status</span><span class="p">,</span> <span class="s">&quot;failed to enable I2C&quot;</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* sets the I2C port mux and target address */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">ufx_i2c_configure</span><span class="p">(</span><span class="k">struct</span> <span class="n">ufx_data</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">status</span> <span class="o">=</span> <span class="n">ufx_reg_write</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mh">0x106C</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">);</span>
	<span class="n">check_warn_return</span><span class="p">(</span><span class="n">status</span><span class="p">,</span> <span class="s">&quot;failed to disable I2C&quot;</span><span class="p">);</span>

	<span class="n">status</span> <span class="o">=</span> <span class="n">ufx_reg_write</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mh">0x3010</span><span class="p">,</span> <span class="mh">0x00000000</span><span class="p">);</span>
	<span class="n">check_warn_return</span><span class="p">(</span><span class="n">status</span><span class="p">,</span> <span class="s">&quot;failed to write 0x3010&quot;</span><span class="p">);</span>

	<span class="cm">/* A0h is std for any EDID, right shifted by one */</span>
	<span class="n">status</span> <span class="o">=</span> <span class="n">ufx_reg_clear_and_set_bits</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mh">0x1004</span><span class="p">,</span> <span class="mh">0x3FF</span><span class="p">,</span>	<span class="p">(</span><span class="mh">0xA0</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">));</span>
	<span class="n">check_warn_return</span><span class="p">(</span><span class="n">status</span><span class="p">,</span> <span class="s">&quot;failed to set TAR bits in 0x1004&quot;</span><span class="p">);</span>

	<span class="n">status</span> <span class="o">=</span> <span class="n">ufx_reg_write</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mh">0x106C</span><span class="p">,</span> <span class="mh">0x01</span><span class="p">);</span>
	<span class="n">check_warn_return</span><span class="p">(</span><span class="n">status</span><span class="p">,</span> <span class="s">&quot;failed to enable I2C&quot;</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* wait for BUSY to clear, with a timeout of 50ms with 10ms sleeps. if no</span>
<span class="cm"> * monitor is connected, there is no error except for timeout */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">ufx_i2c_wait_busy</span><span class="p">(</span><span class="k">struct</span> <span class="n">ufx_data</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">tmp</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">status</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">15</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">ufx_reg_read</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mh">0x1100</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tmp</span><span class="p">);</span>
		<span class="n">check_warn_return</span><span class="p">(</span><span class="n">status</span><span class="p">,</span> <span class="s">&quot;0x1100 read failed&quot;</span><span class="p">);</span>

		<span class="cm">/* if BUSY is clear, check for error */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">tmp</span> <span class="o">&amp;</span> <span class="mh">0x80000000</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">tmp</span> <span class="o">&amp;</span> <span class="mh">0x20000000</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">pr_warn</span><span class="p">(</span><span class="s">&quot;I2C read failed, 0x1100=0x%08x&quot;</span><span class="p">,</span> <span class="n">tmp</span><span class="p">);</span>
				<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* perform the first 10 retries without delay */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">10</span><span class="p">)</span>
			<span class="n">msleep</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">pr_warn</span><span class="p">(</span><span class="s">&quot;I2C access timed out, resetting I2C hardware&quot;</span><span class="p">);</span>
	<span class="n">status</span> <span class="o">=</span>  <span class="n">ufx_reg_write</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mh">0x1100</span><span class="p">,</span> <span class="mh">0x40000000</span><span class="p">);</span>
	<span class="n">check_warn_return</span><span class="p">(</span><span class="n">status</span><span class="p">,</span> <span class="s">&quot;0x1100 write failed&quot;</span><span class="p">);</span>

	<span class="k">return</span> <span class="o">-</span><span class="n">ETIMEDOUT</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* reads a 128-byte EDID block from the currently selected port and TAR */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">ufx_read_edid</span><span class="p">(</span><span class="k">struct</span> <span class="n">ufx_data</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="n">u8</span> <span class="o">*</span><span class="n">edid</span><span class="p">,</span> <span class="kt">int</span> <span class="n">edid_len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">status</span><span class="p">;</span>
	<span class="n">u32</span> <span class="o">*</span><span class="n">edid_u32</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span> <span class="o">*</span><span class="p">)</span><span class="n">edid</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">edid_len</span> <span class="o">!=</span> <span class="n">EDID_LENGTH</span><span class="p">);</span>

	<span class="n">status</span> <span class="o">=</span> <span class="n">ufx_i2c_configure</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;ufx_i2c_configure failed&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">memset</span><span class="p">(</span><span class="n">edid</span><span class="p">,</span> <span class="mh">0xff</span><span class="p">,</span> <span class="n">EDID_LENGTH</span><span class="p">);</span>

	<span class="cm">/* Read the 128-byte EDID as 2 bursts of 64 bytes */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">u32</span> <span class="n">temp</span> <span class="o">=</span> <span class="mh">0x28070000</span> <span class="o">|</span> <span class="p">(</span><span class="mi">63</span> <span class="o">&lt;&lt;</span> <span class="mi">20</span><span class="p">)</span> <span class="o">|</span> <span class="p">(((</span><span class="n">u32</span><span class="p">)(</span><span class="n">i</span> <span class="o">*</span> <span class="mi">64</span><span class="p">))</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">);</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">ufx_reg_write</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mh">0x1100</span><span class="p">,</span> <span class="n">temp</span><span class="p">);</span>
		<span class="n">check_warn_return</span><span class="p">(</span><span class="n">status</span><span class="p">,</span> <span class="s">&quot;Failed to write 0x1100&quot;</span><span class="p">);</span>

		<span class="n">temp</span> <span class="o">|=</span> <span class="mh">0x80000000</span><span class="p">;</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">ufx_reg_write</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mh">0x1100</span><span class="p">,</span> <span class="n">temp</span><span class="p">);</span>
		<span class="n">check_warn_return</span><span class="p">(</span><span class="n">status</span><span class="p">,</span> <span class="s">&quot;Failed to write 0x1100&quot;</span><span class="p">);</span>

		<span class="n">status</span> <span class="o">=</span> <span class="n">ufx_i2c_wait_busy</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
		<span class="n">check_warn_return</span><span class="p">(</span><span class="n">status</span><span class="p">,</span> <span class="s">&quot;Timeout waiting for I2C BUSY to clear&quot;</span><span class="p">);</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="mi">16</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">u32</span> <span class="n">data_reg_addr</span> <span class="o">=</span> <span class="mh">0x1110</span> <span class="o">+</span> <span class="p">(</span><span class="n">j</span> <span class="o">*</span> <span class="mi">4</span><span class="p">);</span>
			<span class="n">status</span> <span class="o">=</span> <span class="n">ufx_reg_read</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">data_reg_addr</span><span class="p">,</span> <span class="n">edid_u32</span><span class="o">++</span><span class="p">);</span>
			<span class="n">check_warn_return</span><span class="p">(</span><span class="n">status</span><span class="p">,</span> <span class="s">&quot;Error reading i2c data&quot;</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* all FF&#39;s in the first 16 bytes indicates nothing is connected */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">16</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">edid</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="mh">0xFF</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;edid data read succesfully&quot;</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">EDID_LENGTH</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">pr_warn</span><span class="p">(</span><span class="s">&quot;edid data contains all 0xff&quot;</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">ETIMEDOUT</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* 1) use sw default</span>
<span class="cm"> * 2) Parse into various fb_info structs</span>
<span class="cm"> * 3) Allocate virtual framebuffer memory to back highest res mode</span>
<span class="cm"> *</span>
<span class="cm"> * Parses EDID into three places used by various parts of fbdev:</span>
<span class="cm"> * fb_var_screeninfo contains the timing of the monitor&#39;s preferred mode</span>
<span class="cm"> * fb_info.monspecs is full parsed EDID info, including monspecs.modedb</span>
<span class="cm"> * fb_info.modelist is a linked list of all monitor &amp; VESA modes which work</span>
<span class="cm"> *</span>
<span class="cm"> * If EDID is not readable/valid, then modelist is all VESA modes,</span>
<span class="cm"> * monspecs is NULL, and fb_var_screeninfo is set to safe VESA mode</span>
<span class="cm"> * Returns 0 if successful */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">ufx_setup_modes</span><span class="p">(</span><span class="k">struct</span> <span class="n">ufx_data</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">fb_info</span> <span class="o">*</span><span class="n">info</span><span class="p">,</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">default_edid</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">default_edid_size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">fb_videomode</span> <span class="o">*</span><span class="n">default_vmode</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">u8</span> <span class="o">*</span><span class="n">edid</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">result</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">tries</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">)</span> <span class="cm">/* only use mutex if info has been registered */</span>
		<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="n">edid</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="n">EDID_LENGTH</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">edid</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">result</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">fb_destroy_modelist</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">modelist</span><span class="p">);</span>
	<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">monspecs</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">monspecs</span><span class="p">));</span>

	<span class="cm">/* Try to (re)read EDID from hardware first</span>
<span class="cm">	 * EDID data may return, but not parse as valid</span>
<span class="cm">	 * Try again a few times, in case of e.g. analog cable noise */</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">tries</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">i</span> <span class="o">=</span> <span class="n">ufx_read_edid</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">edid</span><span class="p">,</span> <span class="n">EDID_LENGTH</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&gt;=</span> <span class="n">EDID_LENGTH</span><span class="p">)</span>
			<span class="n">fb_edid_to_monspecs</span><span class="p">(</span><span class="n">edid</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">monspecs</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">monspecs</span><span class="p">.</span><span class="n">modedb_len</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dev</span><span class="o">-&gt;</span><span class="n">edid</span> <span class="o">=</span> <span class="n">edid</span><span class="p">;</span>
			<span class="n">dev</span><span class="o">-&gt;</span><span class="n">edid_size</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* If that fails, use a previously returned EDID if available */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">monspecs</span><span class="p">.</span><span class="n">modedb_len</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;Unable to get valid EDID from device/display</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">edid</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">fb_edid_to_monspecs</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">edid</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">monspecs</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">monspecs</span><span class="p">.</span><span class="n">modedb_len</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
				<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;Using previously queried EDID</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* If that fails, use the default EDID we were handed */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">monspecs</span><span class="p">.</span><span class="n">modedb_len</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">default_edid_size</span> <span class="o">&gt;=</span> <span class="n">EDID_LENGTH</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">fb_edid_to_monspecs</span><span class="p">(</span><span class="n">default_edid</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">monspecs</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">monspecs</span><span class="p">.</span><span class="n">modedb_len</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">memcpy</span><span class="p">(</span><span class="n">edid</span><span class="p">,</span> <span class="n">default_edid</span><span class="p">,</span> <span class="n">default_edid_size</span><span class="p">);</span>
				<span class="n">dev</span><span class="o">-&gt;</span><span class="n">edid</span> <span class="o">=</span> <span class="n">edid</span><span class="p">;</span>
				<span class="n">dev</span><span class="o">-&gt;</span><span class="n">edid_size</span> <span class="o">=</span> <span class="n">default_edid_size</span><span class="p">;</span>
				<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;Using default/backup EDID</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* If we&#39;ve got modes, let&#39;s pick a best default mode */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">monspecs</span><span class="p">.</span><span class="n">modedb_len</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">monspecs</span><span class="p">.</span><span class="n">modedb_len</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ufx_is_valid_mode</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">monspecs</span><span class="p">.</span><span class="n">modedb</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">info</span><span class="p">))</span>
				<span class="n">fb_add_videomode</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">monspecs</span><span class="p">.</span><span class="n">modedb</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
					<span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">modelist</span><span class="p">);</span>
			<span class="k">else</span> <span class="cm">/* if we&#39;ve removed top/best mode */</span>
				<span class="n">info</span><span class="o">-&gt;</span><span class="n">monspecs</span><span class="p">.</span><span class="n">misc</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">FB_MISC_1ST_DETAIL</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">default_vmode</span> <span class="o">=</span> <span class="n">fb_find_best_display</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">monspecs</span><span class="p">,</span>
						     <span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">modelist</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* If everything else has failed, fall back to safe default mode */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">default_vmode</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>

		<span class="k">struct</span> <span class="n">fb_videomode</span> <span class="n">fb_vmode</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span>

		<span class="cm">/* Add the standard VESA modes to our modelist</span>
<span class="cm">		 * Since we don&#39;t have EDID, there may be modes that</span>
<span class="cm">		 * overspec monitor and/or are incorrect aspect ratio, etc.</span>
<span class="cm">		 * But at least the user has a chance to choose</span>
<span class="cm">		 */</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">VESA_MODEDB_SIZE</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ufx_is_valid_mode</span><span class="p">((</span><span class="k">struct</span> <span class="n">fb_videomode</span> <span class="o">*</span><span class="p">)</span>
						<span class="o">&amp;</span><span class="n">vesa_modes</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">info</span><span class="p">))</span>
				<span class="n">fb_add_videomode</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vesa_modes</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
						 <span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">modelist</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="cm">/* default to resolution safe for projectors</span>
<span class="cm">		 * (since they are most common case without EDID)</span>
<span class="cm">		 */</span>
		<span class="n">fb_vmode</span><span class="p">.</span><span class="n">xres</span> <span class="o">=</span> <span class="mi">800</span><span class="p">;</span>
		<span class="n">fb_vmode</span><span class="p">.</span><span class="n">yres</span> <span class="o">=</span> <span class="mi">600</span><span class="p">;</span>
		<span class="n">fb_vmode</span><span class="p">.</span><span class="n">refresh</span> <span class="o">=</span> <span class="mi">60</span><span class="p">;</span>
		<span class="n">default_vmode</span> <span class="o">=</span> <span class="n">fb_find_nearest_mode</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fb_vmode</span><span class="p">,</span>
						     <span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">modelist</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* If we have good mode and no active clients */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">default_vmode</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">fb_count</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>

		<span class="n">fb_videomode_to_var</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">var</span><span class="p">,</span> <span class="n">default_vmode</span><span class="p">);</span>
		<span class="n">ufx_var_color_format</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">var</span><span class="p">);</span>

		<span class="cm">/* with mode size info, we can now alloc our framebuffer */</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">fix</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ufx_fix</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">ufx_fix</span><span class="p">));</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">fix</span><span class="p">.</span><span class="n">line_length</span> <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">var</span><span class="p">.</span><span class="n">xres</span> <span class="o">*</span>
			<span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">var</span><span class="p">.</span><span class="n">bits_per_pixel</span> <span class="o">/</span> <span class="mi">8</span><span class="p">);</span>

		<span class="n">result</span> <span class="o">=</span> <span class="n">ufx_realloc_framebuffer</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">info</span><span class="p">);</span>

	<span class="p">}</span> <span class="k">else</span>
		<span class="n">result</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

<span class="nl">error:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">edid</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">edid</span> <span class="o">!=</span> <span class="n">edid</span><span class="p">))</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">edid</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">)</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">ufx_usb_probe</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_interface</span> <span class="o">*</span><span class="n">interface</span><span class="p">,</span>
			<span class="k">const</span> <span class="k">struct</span> <span class="n">usb_device_id</span> <span class="o">*</span><span class="n">id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">usb_device</span> <span class="o">*</span><span class="n">usbdev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ufx_data</span> <span class="o">*</span><span class="n">dev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fb_info</span> <span class="o">*</span><span class="n">info</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">id_rev</span><span class="p">,</span> <span class="n">fpga_rev</span><span class="p">;</span>

	<span class="cm">/* usb initialization */</span>
	<span class="n">usbdev</span> <span class="o">=</span> <span class="n">interface_to_usbdev</span><span class="p">(</span><span class="n">interface</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">usbdev</span><span class="p">);</span>

	<span class="n">dev</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">dev</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">usbdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;ufx_usb_probe: failed alloc of dev struct</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* we need to wait for both usb and fbdev to spin down on disconnect */</span>
	<span class="n">kref_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">kref</span><span class="p">);</span> <span class="cm">/* matching kref_put in usb .disconnect fn */</span>
	<span class="n">kref_get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">kref</span><span class="p">);</span> <span class="cm">/* matching kref_put in free_framebuffer_work */</span>

	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">udev</span> <span class="o">=</span> <span class="n">usbdev</span><span class="p">;</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">gdev</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">usbdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span> <span class="cm">/* our generic struct device * */</span>
	<span class="n">usb_set_intfdata</span><span class="p">(</span><span class="n">interface</span><span class="p">,</span> <span class="n">dev</span><span class="p">);</span>

	<span class="n">dev_dbg</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">gdev</span><span class="p">,</span> <span class="s">&quot;%s %s - serial #%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">usbdev</span><span class="o">-&gt;</span><span class="n">manufacturer</span><span class="p">,</span> <span class="n">usbdev</span><span class="o">-&gt;</span><span class="n">product</span><span class="p">,</span> <span class="n">usbdev</span><span class="o">-&gt;</span><span class="n">serial</span><span class="p">);</span>
	<span class="n">dev_dbg</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">gdev</span><span class="p">,</span> <span class="s">&quot;vid_%04x&amp;pid_%04x&amp;rev_%04x driver&#39;s ufx_data struct at %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">usbdev</span><span class="o">-&gt;</span><span class="n">descriptor</span><span class="p">.</span><span class="n">idVendor</span><span class="p">,</span> <span class="n">usbdev</span><span class="o">-&gt;</span><span class="n">descriptor</span><span class="p">.</span><span class="n">idProduct</span><span class="p">,</span>
		<span class="n">usbdev</span><span class="o">-&gt;</span><span class="n">descriptor</span><span class="p">.</span><span class="n">bcdDevice</span><span class="p">,</span> <span class="n">dev</span><span class="p">);</span>
	<span class="n">dev_dbg</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">gdev</span><span class="p">,</span> <span class="s">&quot;console enable=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">console</span><span class="p">);</span>
	<span class="n">dev_dbg</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">gdev</span><span class="p">,</span> <span class="s">&quot;fb_defio enable=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">fb_defio</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ufx_alloc_urb_list</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">WRITES_IN_FLIGHT</span><span class="p">,</span> <span class="n">MAX_TRANSFER</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">gdev</span><span class="p">,</span> <span class="s">&quot;ufx_alloc_urb_list failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* We don&#39;t register a new USB class. Our client interface is fbdev */</span>

	<span class="cm">/* allocates framebuffer driver structure, not framebuffer memory */</span>
	<span class="n">info</span> <span class="o">=</span> <span class="n">framebuffer_alloc</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">usbdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">info</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">gdev</span><span class="p">,</span> <span class="s">&quot;framebuffer_alloc failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">info</span> <span class="o">=</span> <span class="n">info</span><span class="p">;</span>
	<span class="n">info</span><span class="o">-&gt;</span><span class="n">par</span> <span class="o">=</span> <span class="n">dev</span><span class="p">;</span>
	<span class="n">info</span><span class="o">-&gt;</span><span class="n">pseudo_palette</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">pseudo_palette</span><span class="p">;</span>
	<span class="n">info</span><span class="o">-&gt;</span><span class="n">fbops</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ufx_ops</span><span class="p">;</span>

	<span class="n">retval</span> <span class="o">=</span> <span class="n">fb_alloc_cmap</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">cmap</span><span class="p">,</span> <span class="mi">256</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">gdev</span><span class="p">,</span> <span class="s">&quot;fb_alloc_cmap failed %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">retval</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">INIT_DELAYED_WORK</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">free_framebuffer_work</span><span class="p">,</span>
			  <span class="n">ufx_free_framebuffer_work</span><span class="p">);</span>

	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">modelist</span><span class="p">);</span>

	<span class="n">retval</span> <span class="o">=</span> <span class="n">ufx_reg_read</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mh">0x3000</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">id_rev</span><span class="p">);</span>
	<span class="n">check_warn_goto_error</span><span class="p">(</span><span class="n">retval</span><span class="p">,</span> <span class="s">&quot;error %d reading 0x3000 register from device&quot;</span><span class="p">,</span> <span class="n">retval</span><span class="p">);</span>
	<span class="n">dev_dbg</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">gdev</span><span class="p">,</span> <span class="s">&quot;ID_REV register value 0x%08x&quot;</span><span class="p">,</span> <span class="n">id_rev</span><span class="p">);</span>

	<span class="n">retval</span> <span class="o">=</span> <span class="n">ufx_reg_read</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mh">0x3004</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fpga_rev</span><span class="p">);</span>
	<span class="n">check_warn_goto_error</span><span class="p">(</span><span class="n">retval</span><span class="p">,</span> <span class="s">&quot;error %d reading 0x3004 register from device&quot;</span><span class="p">,</span> <span class="n">retval</span><span class="p">);</span>
	<span class="n">dev_dbg</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">gdev</span><span class="p">,</span> <span class="s">&quot;FPGA_REV register value 0x%08x&quot;</span><span class="p">,</span> <span class="n">fpga_rev</span><span class="p">);</span>

	<span class="n">dev_dbg</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">gdev</span><span class="p">,</span> <span class="s">&quot;resetting device&quot;</span><span class="p">);</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="n">ufx_lite_reset</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">check_warn_goto_error</span><span class="p">(</span><span class="n">retval</span><span class="p">,</span> <span class="s">&quot;error %d resetting device&quot;</span><span class="p">,</span> <span class="n">retval</span><span class="p">);</span>

	<span class="n">dev_dbg</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">gdev</span><span class="p">,</span> <span class="s">&quot;configuring system clock&quot;</span><span class="p">);</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="n">ufx_config_sys_clk</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">check_warn_goto_error</span><span class="p">(</span><span class="n">retval</span><span class="p">,</span> <span class="s">&quot;error %d configuring system clock&quot;</span><span class="p">,</span> <span class="n">retval</span><span class="p">);</span>

	<span class="n">dev_dbg</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">gdev</span><span class="p">,</span> <span class="s">&quot;configuring DDR2 controller&quot;</span><span class="p">);</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="n">ufx_config_ddr2</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">check_warn_goto_error</span><span class="p">(</span><span class="n">retval</span><span class="p">,</span> <span class="s">&quot;error %d initialising DDR2 controller&quot;</span><span class="p">,</span> <span class="n">retval</span><span class="p">);</span>

	<span class="n">dev_dbg</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">gdev</span><span class="p">,</span> <span class="s">&quot;configuring I2C controller&quot;</span><span class="p">);</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="n">ufx_i2c_init</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">check_warn_goto_error</span><span class="p">(</span><span class="n">retval</span><span class="p">,</span> <span class="s">&quot;error %d initialising I2C controller&quot;</span><span class="p">,</span> <span class="n">retval</span><span class="p">);</span>

	<span class="n">dev_dbg</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">gdev</span><span class="p">,</span> <span class="s">&quot;selecting display mode&quot;</span><span class="p">);</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="n">ufx_setup_modes</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">info</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">check_warn_goto_error</span><span class="p">(</span><span class="n">retval</span><span class="p">,</span> <span class="s">&quot;unable to find common mode for display and adapter&quot;</span><span class="p">);</span>

	<span class="n">retval</span> <span class="o">=</span> <span class="n">ufx_reg_set_bits</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mh">0x4000</span><span class="p">,</span> <span class="mh">0x00000001</span><span class="p">);</span>
	<span class="n">check_warn_goto_error</span><span class="p">(</span><span class="n">retval</span><span class="p">,</span> <span class="s">&quot;error %d enabling graphics engine&quot;</span><span class="p">,</span> <span class="n">retval</span><span class="p">);</span>

	<span class="cm">/* ready to begin using device */</span>
	<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">usb_active</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

	<span class="n">dev_dbg</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">gdev</span><span class="p">,</span> <span class="s">&quot;checking var&quot;</span><span class="p">);</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="n">ufx_ops_check_var</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">var</span><span class="p">,</span> <span class="n">info</span><span class="p">);</span>
	<span class="n">check_warn_goto_error</span><span class="p">(</span><span class="n">retval</span><span class="p">,</span> <span class="s">&quot;error %d ufx_ops_check_var&quot;</span><span class="p">,</span> <span class="n">retval</span><span class="p">);</span>

	<span class="n">dev_dbg</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">gdev</span><span class="p">,</span> <span class="s">&quot;setting par&quot;</span><span class="p">);</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="n">ufx_ops_set_par</span><span class="p">(</span><span class="n">info</span><span class="p">);</span>
	<span class="n">check_warn_goto_error</span><span class="p">(</span><span class="n">retval</span><span class="p">,</span> <span class="s">&quot;error %d ufx_ops_set_par&quot;</span><span class="p">,</span> <span class="n">retval</span><span class="p">);</span>

	<span class="n">dev_dbg</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">gdev</span><span class="p">,</span> <span class="s">&quot;registering framebuffer&quot;</span><span class="p">);</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="n">register_framebuffer</span><span class="p">(</span><span class="n">info</span><span class="p">);</span>
	<span class="n">check_warn_goto_error</span><span class="p">(</span><span class="n">retval</span><span class="p">,</span> <span class="s">&quot;error %d register_framebuffer&quot;</span><span class="p">,</span> <span class="n">retval</span><span class="p">);</span>

	<span class="n">dev_info</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">gdev</span><span class="p">,</span> <span class="s">&quot;SMSC UDX USB device /dev/fb%d attached. %dx%d resolution.&quot;</span>
		<span class="s">&quot; Using %dK framebuffer memory</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">,</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">var</span><span class="p">.</span><span class="n">xres</span><span class="p">,</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">var</span><span class="p">.</span><span class="n">yres</span><span class="p">,</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">fix</span><span class="p">.</span><span class="n">smem_len</span> <span class="o">&gt;&gt;</span> <span class="mi">10</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">error:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">info</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">cmap</span><span class="p">.</span><span class="n">len</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
				<span class="n">fb_dealloc_cmap</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">cmap</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">monspecs</span><span class="p">.</span><span class="n">modedb</span><span class="p">)</span>
				<span class="n">fb_destroy_modedb</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">monspecs</span><span class="p">.</span><span class="n">modedb</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">screen_base</span><span class="p">)</span>
				<span class="n">vfree</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">screen_base</span><span class="p">);</span>

			<span class="n">fb_destroy_modelist</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">modelist</span><span class="p">);</span>

			<span class="n">framebuffer_release</span><span class="p">(</span><span class="n">info</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="n">kref_put</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">kref</span><span class="p">,</span> <span class="n">ufx_free</span><span class="p">);</span> <span class="cm">/* ref for framebuffer */</span>
		<span class="n">kref_put</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">kref</span><span class="p">,</span> <span class="n">ufx_free</span><span class="p">);</span> <span class="cm">/* last ref from kref_init */</span>

		<span class="cm">/* dev has been deallocated. Do not dereference */</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">ufx_usb_disconnect</span><span class="p">(</span><span class="k">struct</span> <span class="n">usb_interface</span> <span class="o">*</span><span class="n">interface</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ufx_data</span> <span class="o">*</span><span class="n">dev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fb_info</span> <span class="o">*</span><span class="n">info</span><span class="p">;</span>

	<span class="n">dev</span> <span class="o">=</span> <span class="n">usb_get_intfdata</span><span class="p">(</span><span class="n">interface</span><span class="p">);</span>
	<span class="n">info</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">info</span><span class="p">;</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;USB disconnect starting</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="cm">/* we virtualize until all fb clients release. Then we free */</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">virtualized</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>

	<span class="cm">/* When non-active we&#39;ll update virtual framebuffer, but no new urbs */</span>
	<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">usb_active</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="n">usb_set_intfdata</span><span class="p">(</span><span class="n">interface</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

	<span class="cm">/* if clients still have us open, will be freed on last close */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">fb_count</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">schedule_delayed_work</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">free_framebuffer_work</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="cm">/* release reference taken by kref_init in probe() */</span>
	<span class="n">kref_put</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">kref</span><span class="p">,</span> <span class="n">ufx_free</span><span class="p">);</span>

	<span class="cm">/* consider ufx_data freed */</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">usb_driver</span> <span class="n">ufx_driver</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;smscufx&quot;</span><span class="p">,</span>
	<span class="p">.</span><span class="n">probe</span> <span class="o">=</span> <span class="n">ufx_usb_probe</span><span class="p">,</span>
	<span class="p">.</span><span class="n">disconnect</span> <span class="o">=</span> <span class="n">ufx_usb_disconnect</span><span class="p">,</span>
	<span class="p">.</span><span class="n">id_table</span> <span class="o">=</span> <span class="n">id_table</span><span class="p">,</span>
<span class="p">};</span>

<span class="n">module_usb_driver</span><span class="p">(</span><span class="n">ufx_driver</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">ufx_urb_completion</span><span class="p">(</span><span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">urb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">urb_node</span> <span class="o">*</span><span class="n">unode</span> <span class="o">=</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">context</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ufx_data</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">unode</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="cm">/* sync/async unlink faults aren&#39;t errors */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">==</span> <span class="o">-</span><span class="n">ENOENT</span> <span class="o">||</span>
		    <span class="n">urb</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">==</span> <span class="o">-</span><span class="n">ECONNRESET</span> <span class="o">||</span>
		    <span class="n">urb</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">==</span> <span class="o">-</span><span class="n">ESHUTDOWN</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;%s - nonzero write bulk status received: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">__func__</span><span class="p">,</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">);</span>
			<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">lost_pixels</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_buffer_length</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">urbs</span><span class="p">.</span><span class="n">size</span><span class="p">;</span> <span class="cm">/* reset to actual */</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">urbs</span><span class="p">.</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">unode</span><span class="o">-&gt;</span><span class="n">entry</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">urbs</span><span class="p">.</span><span class="n">list</span><span class="p">);</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">urbs</span><span class="p">.</span><span class="n">available</span><span class="o">++</span><span class="p">;</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">urbs</span><span class="p">.</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="cm">/* When using fb_defio, we deadlock if up() is called</span>
<span class="cm">	 * while another is waiting. So queue to another process */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">fb_defio</span><span class="p">)</span>
		<span class="n">schedule_delayed_work</span><span class="p">(</span><span class="o">&amp;</span><span class="n">unode</span><span class="o">-&gt;</span><span class="n">release_urb_work</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">up</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">urbs</span><span class="p">.</span><span class="n">limit_sem</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">ufx_free_urb_list</span><span class="p">(</span><span class="k">struct</span> <span class="n">ufx_data</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">urbs</span><span class="p">.</span><span class="n">count</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">node</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">urb_node</span> <span class="o">*</span><span class="n">unode</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">urb</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;Waiting for completes and freeing all render urbs</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="cm">/* keep waiting and freeing, until we&#39;ve got &#39;em all */</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">count</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Getting interrupted means a leak, but ok at shutdown*/</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">down_interruptible</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">urbs</span><span class="p">.</span><span class="n">limit_sem</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">urbs</span><span class="p">.</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

		<span class="n">node</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">urbs</span><span class="p">.</span><span class="n">list</span><span class="p">.</span><span class="n">next</span><span class="p">;</span> <span class="cm">/* have reserved one with sem */</span>
		<span class="n">list_del_init</span><span class="p">(</span><span class="n">node</span><span class="p">);</span>

		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">urbs</span><span class="p">.</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

		<span class="n">unode</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="k">struct</span> <span class="n">urb_node</span><span class="p">,</span> <span class="n">entry</span><span class="p">);</span>
		<span class="n">urb</span> <span class="o">=</span> <span class="n">unode</span><span class="o">-&gt;</span><span class="n">urb</span><span class="p">;</span>

		<span class="cm">/* Free each separately allocated piece */</span>
		<span class="n">usb_free_coherent</span><span class="p">(</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">urbs</span><span class="p">.</span><span class="n">size</span><span class="p">,</span>
				  <span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_buffer</span><span class="p">,</span> <span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_dma</span><span class="p">);</span>
		<span class="n">usb_free_urb</span><span class="p">(</span><span class="n">urb</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">node</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">ufx_alloc_urb_list</span><span class="p">(</span><span class="k">struct</span> <span class="n">ufx_data</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">count</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">urb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">urb_node</span> <span class="o">*</span><span class="n">unode</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">;</span>

	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">urbs</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>

	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">urbs</span><span class="p">.</span><span class="n">size</span> <span class="o">=</span> <span class="n">size</span><span class="p">;</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">urbs</span><span class="p">.</span><span class="n">list</span><span class="p">);</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">count</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">unode</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">urb_node</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">unode</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">unode</span><span class="o">-&gt;</span><span class="n">dev</span> <span class="o">=</span> <span class="n">dev</span><span class="p">;</span>

		<span class="n">INIT_DELAYED_WORK</span><span class="p">(</span><span class="o">&amp;</span><span class="n">unode</span><span class="o">-&gt;</span><span class="n">release_urb_work</span><span class="p">,</span>
			  <span class="n">ufx_release_urb_work</span><span class="p">);</span>

		<span class="n">urb</span> <span class="o">=</span> <span class="n">usb_alloc_urb</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">urb</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">kfree</span><span class="p">(</span><span class="n">unode</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">unode</span><span class="o">-&gt;</span><span class="n">urb</span> <span class="o">=</span> <span class="n">urb</span><span class="p">;</span>

		<span class="n">buf</span> <span class="o">=</span> <span class="n">usb_alloc_coherent</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">udev</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">,</span>
					 <span class="o">&amp;</span><span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_dma</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">buf</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">kfree</span><span class="p">(</span><span class="n">unode</span><span class="p">);</span>
			<span class="n">usb_free_urb</span><span class="p">(</span><span class="n">urb</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* urb-&gt;transfer_buffer_length set to actual before submit */</span>
		<span class="n">usb_fill_bulk_urb</span><span class="p">(</span><span class="n">urb</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">udev</span><span class="p">,</span> <span class="n">usb_sndbulkpipe</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">udev</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
			<span class="n">buf</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">ufx_urb_completion</span><span class="p">,</span> <span class="n">unode</span><span class="p">);</span>
		<span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_flags</span> <span class="o">|=</span> <span class="n">URB_NO_TRANSFER_DMA_MAP</span><span class="p">;</span>

		<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">unode</span><span class="o">-&gt;</span><span class="n">entry</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">urbs</span><span class="p">.</span><span class="n">list</span><span class="p">);</span>

		<span class="n">i</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">sema_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">urbs</span><span class="p">.</span><span class="n">limit_sem</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">urbs</span><span class="p">.</span><span class="n">count</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">urbs</span><span class="p">.</span><span class="n">available</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;allocated %d %d byte urbs</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="n">size</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">i</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="nf">ufx_get_urb</span><span class="p">(</span><span class="k">struct</span> <span class="n">ufx_data</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">entry</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">urb_node</span> <span class="o">*</span><span class="n">unode</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">urb</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="cm">/* Wait for an in-flight buffer to complete and get re-queued */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">down_timeout</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">urbs</span><span class="p">.</span><span class="n">limit_sem</span><span class="p">,</span> <span class="n">GET_URB_TIMEOUT</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">lost_pixels</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">pr_warn</span><span class="p">(</span><span class="s">&quot;wait for urb interrupted: %x available: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">ret</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">urbs</span><span class="p">.</span><span class="n">available</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">urbs</span><span class="p">.</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">urbs</span><span class="p">.</span><span class="n">list</span><span class="p">));</span> <span class="cm">/* reserved one with limit_sem */</span>
	<span class="n">entry</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">urbs</span><span class="p">.</span><span class="n">list</span><span class="p">.</span><span class="n">next</span><span class="p">;</span>
	<span class="n">list_del_init</span><span class="p">(</span><span class="n">entry</span><span class="p">);</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">urbs</span><span class="p">.</span><span class="n">available</span><span class="o">--</span><span class="p">;</span>

	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">urbs</span><span class="p">.</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">unode</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">entry</span><span class="p">,</span> <span class="k">struct</span> <span class="n">urb_node</span><span class="p">,</span> <span class="n">entry</span><span class="p">);</span>
	<span class="n">urb</span> <span class="o">=</span> <span class="n">unode</span><span class="o">-&gt;</span><span class="n">urb</span><span class="p">;</span>

<span class="nl">error:</span>
	<span class="k">return</span> <span class="n">urb</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">ufx_submit_urb</span><span class="p">(</span><span class="k">struct</span> <span class="n">ufx_data</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">urb</span> <span class="o">*</span><span class="n">urb</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">len</span> <span class="o">&gt;</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">urbs</span><span class="p">.</span><span class="n">size</span><span class="p">);</span>

	<span class="n">urb</span><span class="o">-&gt;</span><span class="n">transfer_buffer_length</span> <span class="o">=</span> <span class="n">len</span><span class="p">;</span> <span class="cm">/* set to actual payload len */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">usb_submit_urb</span><span class="p">(</span><span class="n">urb</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ufx_urb_completion</span><span class="p">(</span><span class="n">urb</span><span class="p">);</span> <span class="cm">/* because no one else will */</span>
		<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">lost_pixels</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;usb_submit_urb error %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">module_param</span><span class="p">(</span><span class="n">console</span><span class="p">,</span> <span class="n">bool</span><span class="p">,</span> <span class="n">S_IWUSR</span> <span class="o">|</span> <span class="n">S_IRUSR</span> <span class="o">|</span> <span class="n">S_IWGRP</span> <span class="o">|</span> <span class="n">S_IRGRP</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">console</span><span class="p">,</span> <span class="s">&quot;Allow fbcon to be used on this display&quot;</span><span class="p">);</span>

<span class="n">module_param</span><span class="p">(</span><span class="n">fb_defio</span><span class="p">,</span> <span class="n">bool</span><span class="p">,</span> <span class="n">S_IWUSR</span> <span class="o">|</span> <span class="n">S_IRUSR</span> <span class="o">|</span> <span class="n">S_IWGRP</span> <span class="o">|</span> <span class="n">S_IRGRP</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">fb_defio</span><span class="p">,</span> <span class="s">&quot;Enable fb_defio mmap support&quot;</span><span class="p">);</span>

<span class="n">MODULE_AUTHOR</span><span class="p">(</span><span class="s">&quot;Steve Glendinning &lt;steve.glendinning@smsc.com&gt;&quot;</span><span class="p">);</span>
<span class="n">MODULE_DESCRIPTION</span><span class="p">(</span><span class="s">&quot;SMSC UFX kernel framebuffer driver&quot;</span><span class="p">);</span>
<span class="n">MODULE_LICENSE</span><span class="p">(</span><span class="s">&quot;GPL&quot;</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
