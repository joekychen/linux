<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › video › kyro › STG4000OverlayDevice.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>STG4000OverlayDevice.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> *  linux/drivers/video/kyro/STG4000OverlayDevice.c</span>
<span class="cm"> *</span>
<span class="cm"> *  Copyright (C) 2000 Imagination Technologies Ltd</span>
<span class="cm"> *  Copyright (C) 2002 STMicroelectronics</span>
<span class="cm"> *</span>
<span class="cm"> * This file is subject to the terms and conditions of the GNU General Public</span>
<span class="cm"> * License.  See the file COPYING in the main directory of this archive</span>
<span class="cm"> * for more details.</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/errno.h&gt;</span>
<span class="cp">#include &lt;linux/types.h&gt;</span>

<span class="cp">#include &quot;STG4000Reg.h&quot;</span>
<span class="cp">#include &quot;STG4000Interface.h&quot;</span>

<span class="cm">/* HW Defines */</span>

<span class="cp">#define STG4000_NO_SCALING    0x800</span>
<span class="cp">#define STG4000_NO_DECIMATION 0xFFFFFFFF</span>

<span class="cm">/* Primary surface */</span>
<span class="cp">#define STG4000_PRIM_NUM_PIX   5</span>
<span class="cp">#define STG4000_PRIM_ALIGN     4</span>
<span class="cp">#define STG4000_PRIM_ADDR_BITS 20</span>

<span class="cp">#define STG4000_PRIM_MIN_WIDTH  640</span>
<span class="cp">#define STG4000_PRIM_MAX_WIDTH  1600</span>
<span class="cp">#define STG4000_PRIM_MIN_HEIGHT 480</span>
<span class="cp">#define STG4000_PRIM_MAX_HEIGHT 1200</span>

<span class="cm">/* Overlay surface */</span>
<span class="cp">#define STG4000_OVRL_NUM_PIX   4</span>
<span class="cp">#define STG4000_OVRL_ALIGN     2</span>
<span class="cp">#define STG4000_OVRL_ADDR_BITS 20</span>
<span class="cp">#define STG4000_OVRL_NUM_MODES 5</span>

<span class="cp">#define STG4000_OVRL_MIN_WIDTH  0</span>
<span class="cp">#define STG4000_OVRL_MAX_WIDTH  720</span>
<span class="cp">#define STG4000_OVRL_MIN_HEIGHT 0</span>
<span class="cp">#define STG4000_OVRL_MAX_HEIGHT 576</span>

<span class="cm">/* Decimation and Scaling */</span>
<span class="k">static</span> <span class="n">u32</span> <span class="n">adwDecim8</span><span class="p">[</span><span class="mi">33</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
	    <span class="mh">0xffffffff</span><span class="p">,</span> <span class="mh">0xfffeffff</span><span class="p">,</span> <span class="mh">0xffdffbff</span><span class="p">,</span> <span class="mh">0xfefefeff</span><span class="p">,</span> <span class="mh">0xfdf7efbf</span><span class="p">,</span>
	    <span class="mh">0xfbdf7bdf</span><span class="p">,</span> <span class="mh">0xf7bbddef</span><span class="p">,</span> <span class="mh">0xeeeeeeef</span><span class="p">,</span> <span class="mh">0xeeddbb77</span><span class="p">,</span> <span class="mh">0xedb76db7</span><span class="p">,</span>
	    <span class="mh">0xdb6db6db</span><span class="p">,</span> <span class="mh">0xdb5b5b5b</span><span class="p">,</span> <span class="mh">0xdab5ad6b</span><span class="p">,</span> <span class="mh">0xd5ab55ab</span><span class="p">,</span> <span class="mh">0xd555aaab</span><span class="p">,</span>
	    <span class="mh">0xaaaaaaab</span><span class="p">,</span> <span class="mh">0xaaaa5555</span><span class="p">,</span> <span class="mh">0xaa952a55</span><span class="p">,</span> <span class="mh">0xa94a5295</span><span class="p">,</span> <span class="mh">0xa5252525</span><span class="p">,</span>
	    <span class="mh">0xa4924925</span><span class="p">,</span> <span class="mh">0x92491249</span><span class="p">,</span> <span class="mh">0x91224489</span><span class="p">,</span> <span class="mh">0x91111111</span><span class="p">,</span> <span class="mh">0x90884211</span><span class="p">,</span>
	    <span class="mh">0x88410821</span><span class="p">,</span> <span class="mh">0x88102041</span><span class="p">,</span> <span class="mh">0x81010101</span><span class="p">,</span> <span class="mh">0x80800801</span><span class="p">,</span> <span class="mh">0x80010001</span><span class="p">,</span>
	    <span class="mh">0x80000001</span><span class="p">,</span> <span class="mh">0x00000001</span><span class="p">,</span> <span class="mh">0x00000000</span>
<span class="p">};</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">_OVRL_SRC_DEST</span> <span class="p">{</span>
	<span class="cm">/*clipped on-screen pixel position of overlay */</span>
	<span class="n">u32</span> <span class="n">ulDstX1</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">ulDstY1</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">ulDstX2</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">ulDstY2</span><span class="p">;</span>

	<span class="cm">/*clipped pixel pos of source data within buffer thses need to be 128 bit word aligned */</span>
	<span class="n">u32</span> <span class="n">ulSrcX1</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">ulSrcY1</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">ulSrcX2</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">ulSrcY2</span><span class="p">;</span>

	<span class="cm">/* on-screen pixel position of overlay */</span>
	<span class="n">s32</span> <span class="n">lDstX1</span><span class="p">;</span>
	<span class="n">s32</span> <span class="n">lDstY1</span><span class="p">;</span>
	<span class="n">s32</span> <span class="n">lDstX2</span><span class="p">;</span>
	<span class="n">s32</span> <span class="n">lDstY2</span><span class="p">;</span>
<span class="p">}</span> <span class="n">OVRL_SRC_DEST</span><span class="p">;</span>

<span class="k">static</span> <span class="n">u32</span> <span class="n">ovlWidth</span><span class="p">,</span> <span class="n">ovlHeight</span><span class="p">,</span> <span class="n">ovlStride</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">ovlLinear</span><span class="p">;</span>

<span class="kt">void</span> <span class="nf">ResetOverlayRegisters</span><span class="p">(</span><span class="k">volatile</span> <span class="n">STG4000REG</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">pSTGReg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">tmp</span><span class="p">;</span>

	<span class="cm">/* Set Overlay address to default */</span>
	<span class="n">tmp</span> <span class="o">=</span> <span class="n">STG_READ_REG</span><span class="p">(</span><span class="n">DACOverlayAddr</span><span class="p">);</span>
	<span class="n">CLEAR_BITS_FRM_TO</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">20</span><span class="p">);</span>
	<span class="n">CLEAR_BIT</span><span class="p">(</span><span class="mi">31</span><span class="p">);</span>
	<span class="n">STG_WRITE_REG</span><span class="p">(</span><span class="n">DACOverlayAddr</span><span class="p">,</span> <span class="n">tmp</span><span class="p">);</span>

	<span class="cm">/* Set Overlay U address */</span>
	<span class="n">tmp</span> <span class="o">=</span> <span class="n">STG_READ_REG</span><span class="p">(</span><span class="n">DACOverlayUAddr</span><span class="p">);</span>
	<span class="n">CLEAR_BITS_FRM_TO</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">20</span><span class="p">);</span>
	<span class="n">STG_WRITE_REG</span><span class="p">(</span><span class="n">DACOverlayUAddr</span><span class="p">,</span> <span class="n">tmp</span><span class="p">);</span>

	<span class="cm">/* Set Overlay V address */</span>
	<span class="n">tmp</span> <span class="o">=</span> <span class="n">STG_READ_REG</span><span class="p">(</span><span class="n">DACOverlayVAddr</span><span class="p">);</span>
	<span class="n">CLEAR_BITS_FRM_TO</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">20</span><span class="p">);</span>
	<span class="n">STG_WRITE_REG</span><span class="p">(</span><span class="n">DACOverlayVAddr</span><span class="p">,</span> <span class="n">tmp</span><span class="p">);</span>

	<span class="cm">/* Set Overlay Size */</span>
	<span class="n">tmp</span> <span class="o">=</span> <span class="n">STG_READ_REG</span><span class="p">(</span><span class="n">DACOverlaySize</span><span class="p">);</span>
	<span class="n">CLEAR_BITS_FRM_TO</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">10</span><span class="p">);</span>
	<span class="n">CLEAR_BITS_FRM_TO</span><span class="p">(</span><span class="mi">12</span><span class="p">,</span> <span class="mi">31</span><span class="p">);</span>
	<span class="n">STG_WRITE_REG</span><span class="p">(</span><span class="n">DACOverlaySize</span><span class="p">,</span> <span class="n">tmp</span><span class="p">);</span>

	<span class="cm">/* Set Overlay Vt Decimation */</span>
	<span class="n">tmp</span> <span class="o">=</span> <span class="n">STG4000_NO_DECIMATION</span><span class="p">;</span>
	<span class="n">STG_WRITE_REG</span><span class="p">(</span><span class="n">DACOverlayVtDec</span><span class="p">,</span> <span class="n">tmp</span><span class="p">);</span>

	<span class="cm">/* Set Overlay format to default value */</span>
	<span class="n">tmp</span> <span class="o">=</span> <span class="n">STG_READ_REG</span><span class="p">(</span><span class="n">DACPixelFormat</span><span class="p">);</span>
	<span class="n">CLEAR_BITS_FRM_TO</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">7</span><span class="p">);</span>
	<span class="n">CLEAR_BITS_FRM_TO</span><span class="p">(</span><span class="mi">16</span><span class="p">,</span> <span class="mi">22</span><span class="p">);</span>
	<span class="n">STG_WRITE_REG</span><span class="p">(</span><span class="n">DACPixelFormat</span><span class="p">,</span> <span class="n">tmp</span><span class="p">);</span>

	<span class="cm">/* Set Vertical scaling to default */</span>
	<span class="n">tmp</span> <span class="o">=</span> <span class="n">STG_READ_REG</span><span class="p">(</span><span class="n">DACVerticalScal</span><span class="p">);</span>
	<span class="n">CLEAR_BITS_FRM_TO</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">11</span><span class="p">);</span>
	<span class="n">CLEAR_BITS_FRM_TO</span><span class="p">(</span><span class="mi">16</span><span class="p">,</span> <span class="mi">22</span><span class="p">);</span>
	<span class="n">tmp</span> <span class="o">|=</span> <span class="n">STG4000_NO_SCALING</span><span class="p">;</span>	<span class="cm">/* Set to no scaling */</span>
	<span class="n">STG_WRITE_REG</span><span class="p">(</span><span class="n">DACVerticalScal</span><span class="p">,</span> <span class="n">tmp</span><span class="p">);</span>

	<span class="cm">/* Set Horizontal Scaling to default */</span>
	<span class="n">tmp</span> <span class="o">=</span> <span class="n">STG_READ_REG</span><span class="p">(</span><span class="n">DACHorizontalScal</span><span class="p">);</span>
	<span class="n">CLEAR_BITS_FRM_TO</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">11</span><span class="p">);</span>
	<span class="n">CLEAR_BITS_FRM_TO</span><span class="p">(</span><span class="mi">16</span><span class="p">,</span> <span class="mi">17</span><span class="p">);</span>
	<span class="n">tmp</span> <span class="o">|=</span> <span class="n">STG4000_NO_SCALING</span><span class="p">;</span>	<span class="cm">/* Set to no scaling */</span>
	<span class="n">STG_WRITE_REG</span><span class="p">(</span><span class="n">DACHorizontalScal</span><span class="p">,</span> <span class="n">tmp</span><span class="p">);</span>

	<span class="cm">/* Set Blend mode to Alpha Blend */</span>
	<span class="cm">/* ????? SG 08/11/2001 Surely this isn&#39;t the alpha blend mode,</span>
<span class="cm">	   hopefully its overwrite</span>
<span class="cm">	 */</span>
	<span class="n">tmp</span> <span class="o">=</span> <span class="n">STG_READ_REG</span><span class="p">(</span><span class="n">DACBlendCtrl</span><span class="p">);</span>
	<span class="n">CLEAR_BITS_FRM_TO</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">30</span><span class="p">);</span>
	<span class="n">tmp</span> <span class="o">=</span> <span class="p">(</span><span class="n">GRAPHICS_MODE</span> <span class="o">&lt;&lt;</span> <span class="mi">28</span><span class="p">);</span>
	<span class="n">STG_WRITE_REG</span><span class="p">(</span><span class="n">DACBlendCtrl</span><span class="p">,</span> <span class="n">tmp</span><span class="p">);</span>

<span class="p">}</span>

<span class="kt">int</span> <span class="nf">CreateOverlaySurface</span><span class="p">(</span><span class="k">volatile</span> <span class="n">STG4000REG</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">pSTGReg</span><span class="p">,</span>
			 <span class="n">u32</span> <span class="n">inWidth</span><span class="p">,</span>
			 <span class="n">u32</span> <span class="n">inHeight</span><span class="p">,</span>
			 <span class="kt">int</span> <span class="n">bLinear</span><span class="p">,</span>
			 <span class="n">u32</span> <span class="n">ulOverlayOffset</span><span class="p">,</span>
			 <span class="n">u32</span> <span class="o">*</span> <span class="n">retStride</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span> <span class="n">retUVStride</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">tmp</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">ulStride</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">inWidth</span> <span class="o">&gt;</span> <span class="n">STG4000_OVRL_MAX_WIDTH</span> <span class="o">||</span>
	    <span class="n">inHeight</span> <span class="o">&gt;</span> <span class="n">STG4000_OVRL_MAX_HEIGHT</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Stride in 16 byte words - 16Bpp */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bLinear</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Format is 16bits so num 16 byte words is width/8 */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">inWidth</span> <span class="o">&amp;</span> <span class="mh">0x7</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>	<span class="cm">/* inWidth % 8 */</span>
			<span class="n">ulStride</span> <span class="o">=</span> <span class="p">(</span><span class="n">inWidth</span> <span class="o">/</span> <span class="mi">8</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/* Round up to next 16byte boundary */</span>
			<span class="n">ulStride</span> <span class="o">=</span> <span class="p">((</span><span class="n">inWidth</span> <span class="o">+</span> <span class="mi">8</span><span class="p">)</span> <span class="o">/</span> <span class="mi">8</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* Y component is 8bits so num 16 byte words is width/16 */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">inWidth</span> <span class="o">&amp;</span> <span class="mh">0xf</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>	<span class="cm">/* inWidth % 16 */</span>
			<span class="n">ulStride</span> <span class="o">=</span> <span class="p">(</span><span class="n">inWidth</span> <span class="o">/</span> <span class="mi">16</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/* Round up to next 16byte boundary */</span>
			<span class="n">ulStride</span> <span class="o">=</span> <span class="p">((</span><span class="n">inWidth</span> <span class="o">+</span> <span class="mi">16</span><span class="p">)</span> <span class="o">/</span> <span class="mi">16</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>


	<span class="cm">/* Set Overlay address and Format mode */</span>
	<span class="n">tmp</span> <span class="o">=</span> <span class="n">STG_READ_REG</span><span class="p">(</span><span class="n">DACOverlayAddr</span><span class="p">);</span>
	<span class="n">CLEAR_BITS_FRM_TO</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">20</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bLinear</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">CLEAR_BIT</span><span class="p">(</span><span class="mi">31</span><span class="p">);</span>	<span class="cm">/* Overlay format to Linear */</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">tmp</span> <span class="o">|=</span> <span class="n">SET_BIT</span><span class="p">(</span><span class="mi">31</span><span class="p">);</span>	<span class="cm">/* Overlay format to Planer */</span>
	<span class="p">}</span>

	<span class="cm">/* Only bits 24:4 of the Overlay address */</span>
	<span class="n">tmp</span> <span class="o">|=</span> <span class="p">(</span><span class="n">ulOverlayOffset</span> <span class="o">&gt;&gt;</span> <span class="mi">4</span><span class="p">);</span>
	<span class="n">STG_WRITE_REG</span><span class="p">(</span><span class="n">DACOverlayAddr</span><span class="p">,</span> <span class="n">tmp</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bLinear</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">u32</span> <span class="n">uvSize</span> <span class="o">=</span>
		    <span class="p">(</span><span class="n">inWidth</span> <span class="o">&amp;</span> <span class="mh">0x1</span><span class="p">)</span> <span class="o">?</span> <span class="p">(</span><span class="n">inWidth</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="o">:</span> <span class="p">(</span><span class="n">inWidth</span> <span class="o">/</span> <span class="mi">2</span><span class="p">);</span>
		<span class="n">u32</span> <span class="n">uvStride</span><span class="p">;</span>
		<span class="n">u32</span> <span class="n">ulOffset</span><span class="p">;</span>
		<span class="cm">/* Y component is 8bits so num 32 byte words is width/32 */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">uvSize</span> <span class="o">&amp;</span> <span class="mh">0xf</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>	<span class="cm">/* inWidth % 16 */</span>
			<span class="n">uvStride</span> <span class="o">=</span> <span class="p">(</span><span class="n">uvSize</span> <span class="o">/</span> <span class="mi">16</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/* Round up to next 32byte boundary */</span>
			<span class="n">uvStride</span> <span class="o">=</span> <span class="p">((</span><span class="n">uvSize</span> <span class="o">+</span> <span class="mi">16</span><span class="p">)</span> <span class="o">/</span> <span class="mi">16</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="n">ulOffset</span> <span class="o">=</span> <span class="n">ulOverlayOffset</span> <span class="o">+</span> <span class="p">(</span><span class="n">inHeight</span> <span class="o">*</span> <span class="p">(</span><span class="n">ulStride</span> <span class="o">*</span> <span class="mi">16</span><span class="p">));</span>
		<span class="cm">/* Align U,V data to 32byte boundary */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">ulOffset</span> <span class="o">&amp;</span> <span class="mh">0x1f</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">ulOffset</span> <span class="o">=</span> <span class="p">(</span><span class="n">ulOffset</span> <span class="o">+</span> <span class="mi">32L</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xffffffE0L</span><span class="p">;</span>

		<span class="n">tmp</span> <span class="o">=</span> <span class="n">STG_READ_REG</span><span class="p">(</span><span class="n">DACOverlayUAddr</span><span class="p">);</span>
		<span class="n">CLEAR_BITS_FRM_TO</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">20</span><span class="p">);</span>
		<span class="n">tmp</span> <span class="o">|=</span> <span class="p">(</span><span class="n">ulOffset</span> <span class="o">&gt;&gt;</span> <span class="mi">4</span><span class="p">);</span>
		<span class="n">STG_WRITE_REG</span><span class="p">(</span><span class="n">DACOverlayUAddr</span><span class="p">,</span> <span class="n">tmp</span><span class="p">);</span>

		<span class="n">ulOffset</span> <span class="o">+=</span> <span class="p">(</span><span class="n">inHeight</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">uvStride</span> <span class="o">*</span> <span class="mi">16</span><span class="p">);</span>
		<span class="cm">/* Align U,V data to 32byte boundary */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">ulOffset</span> <span class="o">&amp;</span> <span class="mh">0x1f</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">ulOffset</span> <span class="o">=</span> <span class="p">(</span><span class="n">ulOffset</span> <span class="o">+</span> <span class="mi">32L</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xffffffE0L</span><span class="p">;</span>

		<span class="n">tmp</span> <span class="o">=</span> <span class="n">STG_READ_REG</span><span class="p">(</span><span class="n">DACOverlayVAddr</span><span class="p">);</span>
		<span class="n">CLEAR_BITS_FRM_TO</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">20</span><span class="p">);</span>
		<span class="n">tmp</span> <span class="o">|=</span> <span class="p">(</span><span class="n">ulOffset</span> <span class="o">&gt;&gt;</span> <span class="mi">4</span><span class="p">);</span>
		<span class="n">STG_WRITE_REG</span><span class="p">(</span><span class="n">DACOverlayVAddr</span><span class="p">,</span> <span class="n">tmp</span><span class="p">);</span>

		<span class="o">*</span><span class="n">retUVStride</span> <span class="o">=</span> <span class="n">uvStride</span> <span class="o">*</span> <span class="mi">16</span><span class="p">;</span>
	<span class="p">}</span>


	<span class="cm">/* Set Overlay YUV pixel format</span>
<span class="cm">	 * Make sure that LUT not used - ??????</span>
<span class="cm">	 */</span>
	<span class="n">tmp</span> <span class="o">=</span> <span class="n">STG_READ_REG</span><span class="p">(</span><span class="n">DACPixelFormat</span><span class="p">);</span>
	<span class="cm">/* Only support Planer or UYVY linear formats */</span>
	<span class="n">CLEAR_BITS_FRM_TO</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">9</span><span class="p">);</span>
	<span class="n">STG_WRITE_REG</span><span class="p">(</span><span class="n">DACPixelFormat</span><span class="p">,</span> <span class="n">tmp</span><span class="p">);</span>

	<span class="n">ovlWidth</span> <span class="o">=</span> <span class="n">inWidth</span><span class="p">;</span>
	<span class="n">ovlHeight</span> <span class="o">=</span> <span class="n">inHeight</span><span class="p">;</span>
	<span class="n">ovlStride</span> <span class="o">=</span> <span class="n">ulStride</span><span class="p">;</span>
	<span class="n">ovlLinear</span> <span class="o">=</span> <span class="n">bLinear</span><span class="p">;</span>
	<span class="o">*</span><span class="n">retStride</span> <span class="o">=</span> <span class="n">ulStride</span> <span class="o">&lt;&lt;</span> <span class="mi">4</span><span class="p">;</span>	<span class="cm">/* In bytes */</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">SetOverlayBlendMode</span><span class="p">(</span><span class="k">volatile</span> <span class="n">STG4000REG</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">pSTGReg</span><span class="p">,</span>
			<span class="n">OVRL_BLEND_MODE</span> <span class="n">mode</span><span class="p">,</span>
			<span class="n">u32</span> <span class="n">ulAlpha</span><span class="p">,</span> <span class="n">u32</span> <span class="n">ulColorKey</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">tmp</span><span class="p">;</span>

	<span class="n">tmp</span> <span class="o">=</span> <span class="n">STG_READ_REG</span><span class="p">(</span><span class="n">DACBlendCtrl</span><span class="p">);</span>
	<span class="n">CLEAR_BITS_FRM_TO</span><span class="p">(</span><span class="mi">28</span><span class="p">,</span> <span class="mi">30</span><span class="p">);</span>
	<span class="n">tmp</span> <span class="o">|=</span> <span class="p">(</span><span class="n">mode</span> <span class="o">&lt;&lt;</span> <span class="mi">28</span><span class="p">);</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">mode</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">COLOR_KEY</span>:
		<span class="n">CLEAR_BITS_FRM_TO</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">23</span><span class="p">);</span>
		<span class="n">tmp</span> <span class="o">|=</span> <span class="p">(</span><span class="n">ulColorKey</span> <span class="o">&amp;</span> <span class="mh">0x00FFFFFF</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">GLOBAL_ALPHA</span>:
		<span class="n">CLEAR_BITS_FRM_TO</span><span class="p">(</span><span class="mi">24</span><span class="p">,</span> <span class="mi">27</span><span class="p">);</span>
		<span class="n">tmp</span> <span class="o">|=</span> <span class="p">((</span><span class="n">ulAlpha</span> <span class="o">&amp;</span> <span class="mh">0xF</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">24</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">CK_PIXEL_ALPHA</span>:
		<span class="n">CLEAR_BITS_FRM_TO</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">23</span><span class="p">);</span>
		<span class="n">tmp</span> <span class="o">|=</span> <span class="p">(</span><span class="n">ulColorKey</span> <span class="o">&amp;</span> <span class="mh">0x00FFFFFF</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">CK_GLOBAL_ALPHA</span>:
		<span class="n">CLEAR_BITS_FRM_TO</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">23</span><span class="p">);</span>
		<span class="n">tmp</span> <span class="o">|=</span> <span class="p">(</span><span class="n">ulColorKey</span> <span class="o">&amp;</span> <span class="mh">0x00FFFFFF</span><span class="p">);</span>
		<span class="n">CLEAR_BITS_FRM_TO</span><span class="p">(</span><span class="mi">24</span><span class="p">,</span> <span class="mi">27</span><span class="p">);</span>
		<span class="n">tmp</span> <span class="o">|=</span> <span class="p">((</span><span class="n">ulAlpha</span> <span class="o">&amp;</span> <span class="mh">0xF</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">24</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">GRAPHICS_MODE</span>:
	<span class="k">case</span> <span class="n">PER_PIXEL_ALPHA</span>:
		<span class="k">break</span><span class="p">;</span>

	<span class="nl">default:</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">STG_WRITE_REG</span><span class="p">(</span><span class="n">DACBlendCtrl</span><span class="p">,</span> <span class="n">tmp</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">EnableOverlayPlane</span><span class="p">(</span><span class="k">volatile</span> <span class="n">STG4000REG</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">pSTGReg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">tmp</span><span class="p">;</span>
	<span class="cm">/* Enable Overlay */</span>
	<span class="n">tmp</span> <span class="o">=</span> <span class="n">STG_READ_REG</span><span class="p">(</span><span class="n">DACPixelFormat</span><span class="p">);</span>
	<span class="n">tmp</span> <span class="o">|=</span> <span class="n">SET_BIT</span><span class="p">(</span><span class="mi">7</span><span class="p">);</span>
	<span class="n">STG_WRITE_REG</span><span class="p">(</span><span class="n">DACPixelFormat</span><span class="p">,</span> <span class="n">tmp</span><span class="p">);</span>

	<span class="cm">/* Set video stream control */</span>
	<span class="n">tmp</span> <span class="o">=</span> <span class="n">STG_READ_REG</span><span class="p">(</span><span class="n">DACStreamCtrl</span><span class="p">);</span>
	<span class="n">tmp</span> <span class="o">|=</span> <span class="n">SET_BIT</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>	<span class="cm">/* video stream */</span>
	<span class="n">STG_WRITE_REG</span><span class="p">(</span><span class="n">DACStreamCtrl</span><span class="p">,</span> <span class="n">tmp</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">u32</span> <span class="nf">Overlap</span><span class="p">(</span><span class="n">u32</span> <span class="n">ulBits</span><span class="p">,</span> <span class="n">u32</span> <span class="n">ulPattern</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">ulCount</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">ulBits</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">ulPattern</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">))</span>
			<span class="n">ulCount</span><span class="o">++</span><span class="p">;</span>
		<span class="n">ulBits</span><span class="o">--</span><span class="p">;</span>
		<span class="n">ulPattern</span> <span class="o">=</span> <span class="n">ulPattern</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">ulCount</span><span class="p">;</span>

<span class="p">}</span>

<span class="kt">int</span> <span class="nf">SetOverlayViewPort</span><span class="p">(</span><span class="k">volatile</span> <span class="n">STG4000REG</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">pSTGReg</span><span class="p">,</span>
		       <span class="n">u32</span> <span class="n">left</span><span class="p">,</span> <span class="n">u32</span> <span class="n">top</span><span class="p">,</span>
		       <span class="n">u32</span> <span class="n">right</span><span class="p">,</span> <span class="n">u32</span> <span class="n">bottom</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">OVRL_SRC_DEST</span> <span class="n">srcDest</span><span class="p">;</span>

	<span class="n">u32</span> <span class="n">ulSrcTop</span><span class="p">,</span> <span class="n">ulSrcBottom</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">ulSrc</span><span class="p">,</span> <span class="n">ulDest</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">ulFxScale</span><span class="p">,</span> <span class="n">ulFxOffset</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">ulHeight</span><span class="p">,</span> <span class="n">ulWidth</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">ulPattern</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">ulDecimate</span><span class="p">,</span> <span class="n">ulDecimated</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">ulApplied</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">ulDacXScale</span><span class="p">,</span> <span class="n">ulDacYScale</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">ulScale</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">ulLeft</span><span class="p">,</span> <span class="n">ulRight</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">ulSrcLeft</span><span class="p">,</span> <span class="n">ulSrcRight</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">ulScaleLeft</span><span class="p">,</span> <span class="n">ulScaleRight</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">ulhDecim</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">ulsVal</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">ulVertDecFactor</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">bResult</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">ulClipOff</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">ulBits</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">ulsAdd</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">tmp</span><span class="p">,</span> <span class="n">ulStride</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">ulExcessPixels</span><span class="p">,</span> <span class="n">ulClip</span><span class="p">,</span> <span class="n">ulExtraLines</span><span class="p">;</span>


	<span class="n">srcDest</span><span class="p">.</span><span class="n">ulSrcX1</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">srcDest</span><span class="p">.</span><span class="n">ulSrcY1</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">srcDest</span><span class="p">.</span><span class="n">ulSrcX2</span> <span class="o">=</span> <span class="n">ovlWidth</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">srcDest</span><span class="p">.</span><span class="n">ulSrcY2</span> <span class="o">=</span> <span class="n">ovlHeight</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">srcDest</span><span class="p">.</span><span class="n">ulDstX1</span> <span class="o">=</span> <span class="n">left</span><span class="p">;</span>
	<span class="n">srcDest</span><span class="p">.</span><span class="n">ulDstY1</span> <span class="o">=</span> <span class="n">top</span><span class="p">;</span>
	<span class="n">srcDest</span><span class="p">.</span><span class="n">ulDstX2</span> <span class="o">=</span> <span class="n">right</span><span class="p">;</span>
	<span class="n">srcDest</span><span class="p">.</span><span class="n">ulDstY2</span> <span class="o">=</span> <span class="n">bottom</span><span class="p">;</span>

	<span class="n">srcDest</span><span class="p">.</span><span class="n">lDstX1</span> <span class="o">=</span> <span class="n">srcDest</span><span class="p">.</span><span class="n">ulDstX1</span><span class="p">;</span>
	<span class="n">srcDest</span><span class="p">.</span><span class="n">lDstY1</span> <span class="o">=</span> <span class="n">srcDest</span><span class="p">.</span><span class="n">ulDstY1</span><span class="p">;</span>
	<span class="n">srcDest</span><span class="p">.</span><span class="n">lDstX2</span> <span class="o">=</span> <span class="n">srcDest</span><span class="p">.</span><span class="n">ulDstX2</span><span class="p">;</span>
	<span class="n">srcDest</span><span class="p">.</span><span class="n">lDstY2</span> <span class="o">=</span> <span class="n">srcDest</span><span class="p">.</span><span class="n">ulDstY2</span><span class="p">;</span>

    <span class="cm">/************* Vertical decimation/scaling ******************/</span>

	<span class="cm">/* Get Src Top and Bottom */</span>
	<span class="n">ulSrcTop</span> <span class="o">=</span> <span class="n">srcDest</span><span class="p">.</span><span class="n">ulSrcY1</span><span class="p">;</span>
	<span class="n">ulSrcBottom</span> <span class="o">=</span> <span class="n">srcDest</span><span class="p">.</span><span class="n">ulSrcY2</span><span class="p">;</span>

	<span class="n">ulSrc</span> <span class="o">=</span> <span class="n">ulSrcBottom</span> <span class="o">-</span> <span class="n">ulSrcTop</span><span class="p">;</span>
	<span class="n">ulDest</span> <span class="o">=</span> <span class="n">srcDest</span><span class="p">.</span><span class="n">lDstY2</span> <span class="o">-</span> <span class="n">srcDest</span><span class="p">.</span><span class="n">lDstY1</span><span class="p">;</span>	<span class="cm">/* on-screen overlay */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ulSrc</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="cm">/* First work out the position we are to display as offset from the</span>
<span class="cm">	 * source of the buffer</span>
<span class="cm">	 */</span>
	<span class="n">ulFxScale</span> <span class="o">=</span> <span class="p">(</span><span class="n">ulDest</span> <span class="o">&lt;&lt;</span> <span class="mi">11</span><span class="p">)</span> <span class="o">/</span> <span class="n">ulSrc</span><span class="p">;</span>	<span class="cm">/* fixed point scale factor */</span>
	<span class="n">ulFxOffset</span> <span class="o">=</span> <span class="p">(</span><span class="n">srcDest</span><span class="p">.</span><span class="n">lDstY2</span> <span class="o">-</span> <span class="n">srcDest</span><span class="p">.</span><span class="n">ulDstY2</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">11</span><span class="p">;</span>

	<span class="n">ulSrcBottom</span> <span class="o">=</span> <span class="n">ulSrcBottom</span> <span class="o">-</span> <span class="p">(</span><span class="n">ulFxOffset</span> <span class="o">/</span> <span class="n">ulFxScale</span><span class="p">);</span>
	<span class="n">ulSrc</span> <span class="o">=</span> <span class="n">ulSrcBottom</span> <span class="o">-</span> <span class="n">ulSrcTop</span><span class="p">;</span>
	<span class="n">ulHeight</span> <span class="o">=</span> <span class="n">ulSrc</span><span class="p">;</span>

	<span class="n">ulDest</span> <span class="o">=</span> <span class="n">srcDest</span><span class="p">.</span><span class="n">ulDstY2</span> <span class="o">-</span> <span class="p">(</span><span class="n">srcDest</span><span class="p">.</span><span class="n">ulDstY1</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">ulPattern</span> <span class="o">=</span> <span class="n">adwDecim8</span><span class="p">[</span><span class="n">ulBits</span><span class="p">];</span>

	<span class="cm">/* At this point ulSrc represents the input decimator */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ulSrc</span> <span class="o">&gt;</span> <span class="n">ulDest</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ulDecimate</span> <span class="o">=</span> <span class="n">ulSrc</span> <span class="o">-</span> <span class="n">ulDest</span><span class="p">;</span>
		<span class="n">ulBits</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">ulApplied</span> <span class="o">=</span> <span class="n">ulSrc</span> <span class="o">/</span> <span class="mi">32</span><span class="p">;</span>

		<span class="k">while</span> <span class="p">(((</span><span class="n">ulBits</span> <span class="o">*</span> <span class="n">ulApplied</span><span class="p">)</span> <span class="o">+</span>
			<span class="n">Overlap</span><span class="p">((</span><span class="n">ulSrc</span> <span class="o">%</span> <span class="mi">32</span><span class="p">),</span>
				<span class="n">adwDecim8</span><span class="p">[</span><span class="n">ulBits</span><span class="p">]))</span> <span class="o">&lt;</span> <span class="n">ulDecimate</span><span class="p">)</span>
			<span class="n">ulBits</span><span class="o">++</span><span class="p">;</span>

		<span class="n">ulPattern</span> <span class="o">=</span> <span class="n">adwDecim8</span><span class="p">[</span><span class="n">ulBits</span><span class="p">];</span>
		<span class="n">ulDecimated</span> <span class="o">=</span>
		    <span class="p">(</span><span class="n">ulBits</span> <span class="o">*</span> <span class="n">ulApplied</span><span class="p">)</span> <span class="o">+</span> <span class="n">Overlap</span><span class="p">((</span><span class="n">ulSrc</span> <span class="o">%</span> <span class="mi">32</span><span class="p">),</span>
						   <span class="n">ulPattern</span><span class="p">);</span>
		<span class="n">ulSrc</span> <span class="o">=</span> <span class="n">ulSrc</span> <span class="o">-</span> <span class="n">ulDecimated</span><span class="p">;</span>	<span class="cm">/* the number number of lines that will go into the scaler */</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ulBits</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">ulBits</span> <span class="o">!=</span> <span class="mi">32</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ulVertDecFactor</span> <span class="o">=</span> <span class="p">(</span><span class="mi">63</span> <span class="o">-</span> <span class="n">ulBits</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mi">32</span> <span class="o">-</span> <span class="n">ulBits</span><span class="p">);</span>	<span class="cm">/* vertical decimation factor scaled up to nearest integer */</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">ulVertDecFactor</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ulDacYScale</span> <span class="o">=</span> <span class="p">((</span><span class="n">ulSrc</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2048</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">ulDest</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>

	<span class="n">tmp</span> <span class="o">=</span> <span class="n">STG_READ_REG</span><span class="p">(</span><span class="n">DACOverlayVtDec</span><span class="p">);</span>	<span class="cm">/* Decimation */</span>
	<span class="n">CLEAR_BITS_FRM_TO</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">31</span><span class="p">);</span>
	<span class="n">tmp</span> <span class="o">=</span> <span class="n">ulPattern</span><span class="p">;</span>
	<span class="n">STG_WRITE_REG</span><span class="p">(</span><span class="n">DACOverlayVtDec</span><span class="p">,</span> <span class="n">tmp</span><span class="p">);</span>

	<span class="cm">/***************** Horizontal decimation/scaling ***************************/</span>

	<span class="cm">/*</span>
<span class="cm">	 * Now we handle the horizontal case, this is a simplified version of</span>
<span class="cm">	 * the vertical case in that we decimate by factors of 2.  as we are</span>
<span class="cm">	 * working in words we should always be able to decimate by these</span>
<span class="cm">	 * factors.  as we always have to have a buffer which is aligned to a</span>
<span class="cm">	 * whole number of 128 bit words, we must align the left side to the</span>
<span class="cm">	 * lowest to the next lowest 128 bit boundary, and the right hand edge</span>
<span class="cm">	 * to the next largets boundary, (in a similar way to how we didi it in</span>
<span class="cm">	 * PMX1) as the left and right hand edges are aligned to these</span>
<span class="cm">	 * boundaries normally this only becomes an issue when we are chopping</span>
<span class="cm">	 * of one of the sides We shall work out vertical stuff first</span>
<span class="cm">	 */</span>
	<span class="n">ulSrc</span> <span class="o">=</span> <span class="n">srcDest</span><span class="p">.</span><span class="n">ulSrcX2</span> <span class="o">-</span> <span class="n">srcDest</span><span class="p">.</span><span class="n">ulSrcX1</span><span class="p">;</span>
	<span class="n">ulDest</span> <span class="o">=</span> <span class="n">srcDest</span><span class="p">.</span><span class="n">lDstX2</span> <span class="o">-</span> <span class="n">srcDest</span><span class="p">.</span><span class="n">lDstX1</span><span class="p">;</span>
<span class="cp">#ifdef _OLDCODE</span>
	<span class="n">ulLeft</span> <span class="o">=</span> <span class="n">srcDest</span><span class="p">.</span><span class="n">ulDstX1</span><span class="p">;</span>
	<span class="n">ulRight</span> <span class="o">=</span> <span class="n">srcDest</span><span class="p">.</span><span class="n">ulDstX2</span><span class="p">;</span>
<span class="cp">#else</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">srcDest</span><span class="p">.</span><span class="n">ulDstX1</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ulLeft</span> <span class="o">=</span> <span class="n">srcDest</span><span class="p">.</span><span class="n">ulDstX1</span> <span class="o">+</span> <span class="mi">2</span><span class="p">;</span>
		<span class="n">ulRight</span> <span class="o">=</span> <span class="n">srcDest</span><span class="p">.</span><span class="n">ulDstX2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">ulLeft</span> <span class="o">=</span> <span class="n">srcDest</span><span class="p">.</span><span class="n">ulDstX1</span><span class="p">;</span>
		<span class="n">ulRight</span> <span class="o">=</span> <span class="n">srcDest</span><span class="p">.</span><span class="n">ulDstX2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
<span class="cp">#endif</span>
	<span class="cm">/* first work out the position we are to display as offset from the source of the buffer */</span>
	<span class="n">bResult</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">do</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ulDest</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

		<span class="cm">/* source pixels per dest pixel &lt;&lt;11 */</span>
		<span class="n">ulFxScale</span> <span class="o">=</span> <span class="p">((</span><span class="n">ulSrc</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">11</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">ulDest</span><span class="p">);</span>

		<span class="cm">/* then number of destination pixels out we are */</span>
		<span class="n">ulFxOffset</span> <span class="o">=</span> <span class="n">ulFxScale</span> <span class="o">*</span> <span class="p">((</span><span class="n">srcDest</span><span class="p">.</span><span class="n">ulDstX1</span> <span class="o">-</span> <span class="n">srcDest</span><span class="p">.</span><span class="n">lDstX1</span><span class="p">)</span> <span class="o">+</span> <span class="n">ulClipOff</span><span class="p">);</span>
		<span class="n">ulFxOffset</span> <span class="o">&gt;&gt;=</span> <span class="mi">11</span><span class="p">;</span>

		<span class="cm">/* this replaces the code which was making a decision as to use either ulFxOffset or ulSrcX1 */</span>
		<span class="n">ulSrcLeft</span> <span class="o">=</span> <span class="n">srcDest</span><span class="p">.</span><span class="n">ulSrcX1</span> <span class="o">+</span> <span class="n">ulFxOffset</span><span class="p">;</span>

		<span class="cm">/* then number of destination pixels out we are */</span>
		<span class="n">ulFxOffset</span> <span class="o">=</span> <span class="n">ulFxScale</span> <span class="o">*</span> <span class="p">(</span><span class="n">srcDest</span><span class="p">.</span><span class="n">lDstX2</span> <span class="o">-</span> <span class="n">srcDest</span><span class="p">.</span><span class="n">ulDstX2</span><span class="p">);</span>
		<span class="n">ulFxOffset</span> <span class="o">&gt;&gt;=</span> <span class="mi">11</span><span class="p">;</span>

		<span class="n">ulSrcRight</span> <span class="o">=</span> <span class="n">srcDest</span><span class="p">.</span><span class="n">ulSrcX2</span> <span class="o">-</span> <span class="n">ulFxOffset</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * we must align these to our 128 bit boundaries. we shall</span>
<span class="cm">		 * round down the pixel pos to the nearest 8 pixels.</span>
<span class="cm">		 */</span>
		<span class="n">ulScaleLeft</span> <span class="o">=</span> <span class="n">ulSrcLeft</span><span class="p">;</span>
		<span class="n">ulScaleRight</span> <span class="o">=</span> <span class="n">ulSrcRight</span><span class="p">;</span>

		<span class="cm">/* shift fxscale until it is in the range of the scaler */</span>
		<span class="n">ulhDecim</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">ulScale</span> <span class="o">=</span> <span class="p">(((</span><span class="n">ulSrcRight</span> <span class="o">-</span> <span class="n">ulSrcLeft</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="mi">11</span> <span class="o">-</span> <span class="n">ulhDecim</span><span class="p">))</span> <span class="o">/</span> <span class="p">(</span><span class="n">ulRight</span> <span class="o">-</span> <span class="n">ulLeft</span> <span class="o">+</span> <span class="mi">2</span><span class="p">);</span>

		<span class="k">while</span> <span class="p">(</span><span class="n">ulScale</span> <span class="o">&gt;</span> <span class="mh">0x800</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ulhDecim</span><span class="o">++</span><span class="p">;</span>
			<span class="n">ulScale</span> <span class="o">=</span> <span class="p">(((</span><span class="n">ulSrcRight</span> <span class="o">-</span> <span class="n">ulSrcLeft</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="mi">11</span> <span class="o">-</span> <span class="n">ulhDecim</span><span class="p">))</span> <span class="o">/</span> <span class="p">(</span><span class="n">ulRight</span> <span class="o">-</span> <span class="n">ulLeft</span> <span class="o">+</span> <span class="mi">2</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 * to try and get the best values We first try and use</span>
<span class="cm">		 * src/dwdest for the scale factor, then we move onto src-1</span>
<span class="cm">		 *</span>
<span class="cm">		 * we want to check to see if we will need to clip data, if so</span>
<span class="cm">		 * then we should clip our source so that we don&#39;t need to</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ovlLinear</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ulSrcLeft</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="mh">0x1f</span><span class="p">;</span>

			<span class="cm">/*</span>
<span class="cm">			 * we must align the right hand edge to the next 32</span>
<span class="cm">			 * pixel` boundary, must be on a 256 boundary so u, and</span>
<span class="cm">			 * v are 128 bit aligned</span>
<span class="cm">			 */</span>
			<span class="n">ulSrcRight</span> <span class="o">=</span> <span class="p">(</span><span class="n">ulSrcRight</span> <span class="o">+</span> <span class="mh">0x1f</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="mh">0x1f</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">ulSrcLeft</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="mh">0x7</span><span class="p">;</span>

			<span class="cm">/*</span>
<span class="cm">			 * we must align the right hand edge to the next</span>
<span class="cm">			 * 8pixel` boundary</span>
<span class="cm">			 */</span>
			<span class="n">ulSrcRight</span> <span class="o">=</span> <span class="p">(</span><span class="n">ulSrcRight</span> <span class="o">+</span> <span class="mh">0x7</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="mh">0x7</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* this is the input size line store needs to cope with */</span>
		<span class="n">ulWidth</span> <span class="o">=</span> <span class="n">ulSrcRight</span> <span class="o">-</span> <span class="n">ulSrcLeft</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * use unclipped value to work out scale factror this is the</span>
<span class="cm">		 * scale factor we want we shall now work out the horizonal</span>
<span class="cm">		 * decimation and scaling</span>
<span class="cm">		 */</span>
		<span class="n">ulsVal</span> <span class="o">=</span> <span class="p">((</span><span class="n">ulWidth</span> <span class="o">/</span> <span class="mi">8</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">ulhDecim</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">((</span><span class="n">ulWidth</span> <span class="o">!=</span> <span class="p">(</span><span class="n">ulsVal</span> <span class="o">&lt;&lt;</span> <span class="n">ulhDecim</span><span class="p">)</span> <span class="o">*</span> <span class="mi">8</span><span class="p">))</span>
			<span class="n">ulsAdd</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

		<span class="cm">/* input pixels to scaler; */</span>
		<span class="n">ulSrc</span> <span class="o">=</span> <span class="n">ulWidth</span> <span class="o">&gt;&gt;</span> <span class="n">ulhDecim</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">ulSrc</span> <span class="o">&lt;=</span> <span class="mi">2</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

		<span class="n">ulExcessPixels</span> <span class="o">=</span> <span class="p">((((</span><span class="n">ulScaleLeft</span> <span class="o">-</span> <span class="n">ulSrcLeft</span><span class="p">))</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="mi">11</span> <span class="o">-</span> <span class="n">ulhDecim</span><span class="p">))</span> <span class="o">/</span> <span class="n">ulScale</span><span class="p">);</span>

		<span class="n">ulClip</span> <span class="o">=</span> <span class="p">(</span><span class="n">ulSrc</span> <span class="o">&lt;&lt;</span> <span class="mi">11</span><span class="p">)</span> <span class="o">/</span> <span class="n">ulScale</span><span class="p">;</span>
		<span class="n">ulClip</span> <span class="o">-=</span> <span class="p">(</span><span class="n">ulRight</span> <span class="o">-</span> <span class="n">ulLeft</span><span class="p">);</span>
		<span class="n">ulClip</span> <span class="o">+=</span> <span class="n">ulExcessPixels</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">ulClip</span><span class="p">)</span>
			<span class="n">ulClip</span><span class="o">--</span><span class="p">;</span>

		<span class="cm">/* We may need to do more here if we really have a HW rev &lt; 5 */</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">bResult</span><span class="p">);</span>

	<span class="n">ulExtraLines</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">ulhDecim</span><span class="p">)</span> <span class="o">*</span> <span class="n">ulVertDecFactor</span><span class="p">;</span>
	<span class="n">ulExtraLines</span> <span class="o">+=</span> <span class="mi">64</span><span class="p">;</span>
	<span class="n">ulHeight</span> <span class="o">+=</span> <span class="n">ulExtraLines</span><span class="p">;</span>

	<span class="n">ulDacXScale</span> <span class="o">=</span> <span class="n">ulScale</span><span class="p">;</span>


	<span class="n">tmp</span> <span class="o">=</span> <span class="n">STG_READ_REG</span><span class="p">(</span><span class="n">DACVerticalScal</span><span class="p">);</span>
	<span class="n">CLEAR_BITS_FRM_TO</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">11</span><span class="p">);</span>
	<span class="n">CLEAR_BITS_FRM_TO</span><span class="p">(</span><span class="mi">16</span><span class="p">,</span> <span class="mi">22</span><span class="p">);</span>	<span class="cm">/* Vertical Scaling */</span>

	<span class="cm">/* Calculate new output line stride, this is always the number of 422</span>
<span class="cm">	   words in the line buffer, so it doesn&#39;t matter if the</span>
<span class="cm">	   mode is 420. Then set the vertical scale register.</span>
<span class="cm">	 */</span>
	<span class="n">ulStride</span> <span class="o">=</span> <span class="p">(</span><span class="n">ulWidth</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="n">ulhDecim</span> <span class="o">+</span> <span class="mi">3</span><span class="p">))</span> <span class="o">+</span> <span class="n">ulsAdd</span><span class="p">;</span>
	<span class="n">tmp</span> <span class="o">|=</span> <span class="p">((</span><span class="n">ulStride</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">ulDacYScale</span><span class="p">));</span>	<span class="cm">/* DAC_LS_CTRL = stride */</span>
	<span class="n">STG_WRITE_REG</span><span class="p">(</span><span class="n">DACVerticalScal</span><span class="p">,</span> <span class="n">tmp</span><span class="p">);</span>

	<span class="cm">/* Now set up the overlay size using the modified width and height</span>
<span class="cm">	   from decimate and scaling calculations</span>
<span class="cm">	 */</span>
	<span class="n">tmp</span> <span class="o">=</span> <span class="n">STG_READ_REG</span><span class="p">(</span><span class="n">DACOverlaySize</span><span class="p">);</span>
	<span class="n">CLEAR_BITS_FRM_TO</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">10</span><span class="p">);</span>
	<span class="n">CLEAR_BITS_FRM_TO</span><span class="p">(</span><span class="mi">12</span><span class="p">,</span> <span class="mi">31</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ovlLinear</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">tmp</span> <span class="o">|=</span>
		    <span class="p">(</span><span class="n">ovlStride</span> <span class="o">|</span> <span class="p">((</span><span class="n">ulHeight</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">12</span><span class="p">)</span> <span class="o">|</span>
		     <span class="p">(((</span><span class="n">ulWidth</span> <span class="o">/</span> <span class="mi">8</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">23</span><span class="p">));</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">tmp</span> <span class="o">|=</span>
		    <span class="p">(</span><span class="n">ovlStride</span> <span class="o">|</span> <span class="p">((</span><span class="n">ulHeight</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">12</span><span class="p">)</span> <span class="o">|</span>
		     <span class="p">(((</span><span class="n">ulWidth</span> <span class="o">/</span> <span class="mi">32</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">23</span><span class="p">));</span>
	<span class="p">}</span>

	<span class="n">STG_WRITE_REG</span><span class="p">(</span><span class="n">DACOverlaySize</span><span class="p">,</span> <span class="n">tmp</span><span class="p">);</span>

	<span class="cm">/* Set Video Window Start */</span>
	<span class="n">tmp</span> <span class="o">=</span> <span class="p">((</span><span class="n">ulLeft</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">))</span> <span class="o">|</span> <span class="p">(</span><span class="n">srcDest</span><span class="p">.</span><span class="n">ulDstY1</span><span class="p">);</span>
	<span class="n">STG_WRITE_REG</span><span class="p">(</span><span class="n">DACVidWinStart</span><span class="p">,</span> <span class="n">tmp</span><span class="p">);</span>

	<span class="cm">/* Set Video Window End */</span>
	<span class="n">tmp</span> <span class="o">=</span> <span class="p">((</span><span class="n">ulRight</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">srcDest</span><span class="p">.</span><span class="n">ulDstY2</span><span class="p">);</span>
	<span class="n">STG_WRITE_REG</span><span class="p">(</span><span class="n">DACVidWinEnd</span><span class="p">,</span> <span class="n">tmp</span><span class="p">);</span>

	<span class="cm">/* Finally set up the rest of the overlay regs in the order</span>
<span class="cm">	   done in the IMG driver</span>
<span class="cm">	 */</span>
	<span class="n">tmp</span> <span class="o">=</span> <span class="n">STG_READ_REG</span><span class="p">(</span><span class="n">DACPixelFormat</span><span class="p">);</span>
	<span class="n">tmp</span> <span class="o">=</span> <span class="p">((</span><span class="n">ulExcessPixels</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">|</span> <span class="n">tmp</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x7fffffff</span><span class="p">;</span>
	<span class="n">STG_WRITE_REG</span><span class="p">(</span><span class="n">DACPixelFormat</span><span class="p">,</span> <span class="n">tmp</span><span class="p">);</span>

	<span class="n">tmp</span> <span class="o">=</span> <span class="n">STG_READ_REG</span><span class="p">(</span><span class="n">DACHorizontalScal</span><span class="p">);</span>
	<span class="n">CLEAR_BITS_FRM_TO</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">11</span><span class="p">);</span>
	<span class="n">CLEAR_BITS_FRM_TO</span><span class="p">(</span><span class="mi">16</span><span class="p">,</span> <span class="mi">17</span><span class="p">);</span>
	<span class="n">tmp</span> <span class="o">|=</span> <span class="p">((</span><span class="n">ulhDecim</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">ulDacXScale</span><span class="p">));</span>
	<span class="n">STG_WRITE_REG</span><span class="p">(</span><span class="n">DACHorizontalScal</span><span class="p">,</span> <span class="n">tmp</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
