<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › ata › libata-scsi.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>libata-scsi.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> *  libata-scsi.c - helper library for ATA</span>
<span class="cm"> *</span>
<span class="cm"> *  Maintained by:  Jeff Garzik &lt;jgarzik@pobox.com&gt;</span>
<span class="cm"> *    		    Please ALWAYS copy linux-ide@vger.kernel.org</span>
<span class="cm"> *		    on emails.</span>
<span class="cm"> *</span>
<span class="cm"> *  Copyright 2003-2004 Red Hat, Inc.  All rights reserved.</span>
<span class="cm"> *  Copyright 2003-2004 Jeff Garzik</span>
<span class="cm"> *</span>
<span class="cm"> *</span>
<span class="cm"> *  This program is free software; you can redistribute it and/or modify</span>
<span class="cm"> *  it under the terms of the GNU General Public License as published by</span>
<span class="cm"> *  the Free Software Foundation; either version 2, or (at your option)</span>
<span class="cm"> *  any later version.</span>
<span class="cm"> *</span>
<span class="cm"> *  This program is distributed in the hope that it will be useful,</span>
<span class="cm"> *  but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm"> *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="cm"> *  GNU General Public License for more details.</span>
<span class="cm"> *</span>
<span class="cm"> *  You should have received a copy of the GNU General Public License</span>
<span class="cm"> *  along with this program; see the file COPYING.  If not, write to</span>
<span class="cm"> *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.</span>
<span class="cm"> *</span>
<span class="cm"> *</span>
<span class="cm"> *  libata documentation is available via &#39;make {ps|pdf}docs&#39;,</span>
<span class="cm"> *  as Documentation/DocBook/libata.*</span>
<span class="cm"> *</span>
<span class="cm"> *  Hardware documentation available from</span>
<span class="cm"> *  - http://www.t10.org/</span>
<span class="cm"> *  - http://www.t13.org/</span>
<span class="cm"> *</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/blkdev.h&gt;</span>
<span class="cp">#include &lt;linux/spinlock.h&gt;</span>
<span class="cp">#include &lt;linux/export.h&gt;</span>
<span class="cp">#include &lt;scsi/scsi.h&gt;</span>
<span class="cp">#include &lt;scsi/scsi_host.h&gt;</span>
<span class="cp">#include &lt;scsi/scsi_cmnd.h&gt;</span>
<span class="cp">#include &lt;scsi/scsi_eh.h&gt;</span>
<span class="cp">#include &lt;scsi/scsi_device.h&gt;</span>
<span class="cp">#include &lt;scsi/scsi_tcq.h&gt;</span>
<span class="cp">#include &lt;scsi/scsi_transport.h&gt;</span>
<span class="cp">#include &lt;linux/libata.h&gt;</span>
<span class="cp">#include &lt;linux/hdreg.h&gt;</span>
<span class="cp">#include &lt;linux/uaccess.h&gt;</span>
<span class="cp">#include &lt;linux/suspend.h&gt;</span>
<span class="cp">#include &lt;asm/unaligned.h&gt;</span>

<span class="cp">#include &quot;libata.h&quot;</span>
<span class="cp">#include &quot;libata-transport.h&quot;</span>

<span class="cp">#define ATA_SCSI_RBUF_SIZE	4096</span>

<span class="k">static</span> <span class="n">DEFINE_SPINLOCK</span><span class="p">(</span><span class="n">ata_scsi_rbuf_lock</span><span class="p">);</span>
<span class="k">static</span> <span class="n">u8</span> <span class="n">ata_scsi_rbuf</span><span class="p">[</span><span class="n">ATA_SCSI_RBUF_SIZE</span><span class="p">];</span>

<span class="k">typedef</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">ata_xlat_func_t</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ata_queued_cmd</span> <span class="o">*</span><span class="n">qc</span><span class="p">);</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">ata_device</span> <span class="o">*</span><span class="n">__ata_scsi_find_dev</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span><span class="p">,</span>
					<span class="k">const</span> <span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="n">scsidev</span><span class="p">);</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">ata_device</span> <span class="o">*</span><span class="n">ata_scsi_find_dev</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span><span class="p">,</span>
					    <span class="k">const</span> <span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="n">scsidev</span><span class="p">);</span>

<span class="cp">#define RW_RECOVERY_MPAGE 0x1</span>
<span class="cp">#define RW_RECOVERY_MPAGE_LEN 12</span>
<span class="cp">#define CACHE_MPAGE 0x8</span>
<span class="cp">#define CACHE_MPAGE_LEN 20</span>
<span class="cp">#define CONTROL_MPAGE 0xa</span>
<span class="cp">#define CONTROL_MPAGE_LEN 12</span>
<span class="cp">#define ALL_MPAGES 0x3f</span>
<span class="cp">#define ALL_SUB_MPAGES 0xff</span>


<span class="k">static</span> <span class="k">const</span> <span class="n">u8</span> <span class="n">def_rw_recovery_mpage</span><span class="p">[</span><span class="n">RW_RECOVERY_MPAGE_LEN</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="n">RW_RECOVERY_MPAGE</span><span class="p">,</span>
	<span class="n">RW_RECOVERY_MPAGE_LEN</span> <span class="o">-</span> <span class="mi">2</span><span class="p">,</span>
	<span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">7</span><span class="p">),</span>	<span class="cm">/* AWRE */</span>
	<span class="mi">0</span><span class="p">,</span>		<span class="cm">/* read retry count */</span>
	<span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
	<span class="mi">0</span><span class="p">,</span>		<span class="cm">/* write retry count */</span>
	<span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">const</span> <span class="n">u8</span> <span class="n">def_cache_mpage</span><span class="p">[</span><span class="n">CACHE_MPAGE_LEN</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="n">CACHE_MPAGE</span><span class="p">,</span>
	<span class="n">CACHE_MPAGE_LEN</span> <span class="o">-</span> <span class="mi">2</span><span class="p">,</span>
	<span class="mi">0</span><span class="p">,</span>		<span class="cm">/* contains WCE, needs to be 0 for logic */</span>
	<span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
	<span class="mi">0</span><span class="p">,</span>		<span class="cm">/* contains DRA, needs to be 0 for logic */</span>
	<span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">const</span> <span class="n">u8</span> <span class="n">def_control_mpage</span><span class="p">[</span><span class="n">CONTROL_MPAGE_LEN</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="n">CONTROL_MPAGE</span><span class="p">,</span>
	<span class="n">CONTROL_MPAGE_LEN</span> <span class="o">-</span> <span class="mi">2</span><span class="p">,</span>
	<span class="mi">2</span><span class="p">,</span>	<span class="cm">/* DSENSE=0, GLTSD=1 */</span>
	<span class="mi">0</span><span class="p">,</span>	<span class="cm">/* [QAM+QERR may be 1, see 05-359r1] */</span>
	<span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mh">0xff</span><span class="p">,</span> <span class="mh">0xff</span><span class="p">,</span>
	<span class="mi">0</span><span class="p">,</span> <span class="mi">30</span>	<span class="cm">/* extended self test time, see 05-359r1 */</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">ata_lpm_policy_names</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">[</span><span class="n">ATA_LPM_UNKNOWN</span><span class="p">]</span>	<span class="o">=</span> <span class="s">&quot;max_performance&quot;</span><span class="p">,</span>
	<span class="p">[</span><span class="n">ATA_LPM_MAX_POWER</span><span class="p">]</span>	<span class="o">=</span> <span class="s">&quot;max_performance&quot;</span><span class="p">,</span>
	<span class="p">[</span><span class="n">ATA_LPM_MED_POWER</span><span class="p">]</span>	<span class="o">=</span> <span class="s">&quot;medium_power&quot;</span><span class="p">,</span>
	<span class="p">[</span><span class="n">ATA_LPM_MIN_POWER</span><span class="p">]</span>	<span class="o">=</span> <span class="s">&quot;min_power&quot;</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">ata_scsi_lpm_store</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span>
				  <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span> <span class="o">=</span> <span class="n">class_to_shost</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span> <span class="o">=</span> <span class="n">ata_shost_to_port</span><span class="p">(</span><span class="n">shost</span><span class="p">);</span>
	<span class="k">enum</span> <span class="n">ata_lpm_policy</span> <span class="n">policy</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="cm">/* UNKNOWN is internal state, iterate from MAX_POWER */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">policy</span> <span class="o">=</span> <span class="n">ATA_LPM_MAX_POWER</span><span class="p">;</span>
	     <span class="n">policy</span> <span class="o">&lt;</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">ata_lpm_policy_names</span><span class="p">);</span> <span class="n">policy</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span> <span class="o">=</span> <span class="n">ata_lpm_policy_names</span><span class="p">[</span><span class="n">policy</span><span class="p">];</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">strncmp</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">strlen</span><span class="p">(</span><span class="n">name</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">policy</span> <span class="o">==</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">ata_lpm_policy_names</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">ap</span><span class="o">-&gt;</span><span class="n">target_lpm_policy</span> <span class="o">=</span> <span class="n">policy</span><span class="p">;</span>
	<span class="n">ata_port_schedule_eh</span><span class="p">(</span><span class="n">ap</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">count</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">ata_scsi_lpm_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span> <span class="o">=</span> <span class="n">class_to_shost</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span> <span class="o">=</span> <span class="n">ata_shost_to_port</span><span class="p">(</span><span class="n">shost</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">target_lpm_policy</span> <span class="o">&gt;=</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">ata_lpm_policy_names</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">snprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">PAGE_SIZE</span><span class="p">,</span> <span class="s">&quot;%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">ata_lpm_policy_names</span><span class="p">[</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">target_lpm_policy</span><span class="p">]);</span>
<span class="p">}</span>
<span class="n">DEVICE_ATTR</span><span class="p">(</span><span class="n">link_power_management_policy</span><span class="p">,</span> <span class="n">S_IRUGO</span> <span class="o">|</span> <span class="n">S_IWUSR</span><span class="p">,</span>
	    <span class="n">ata_scsi_lpm_show</span><span class="p">,</span> <span class="n">ata_scsi_lpm_store</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">dev_attr_link_power_management_policy</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">ata_scsi_park_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">device</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="n">sdev</span> <span class="o">=</span> <span class="n">to_scsi_device</span><span class="p">(</span><span class="n">device</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ata_link</span> <span class="o">*</span><span class="n">link</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ata_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">,</span> <span class="n">now</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">uninitialized_var</span><span class="p">(</span><span class="n">msecs</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">ap</span> <span class="o">=</span> <span class="n">ata_shost_to_port</span><span class="p">(</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">);</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">dev</span> <span class="o">=</span> <span class="n">ata_scsi_find_dev</span><span class="p">(</span><span class="n">ap</span><span class="p">,</span> <span class="n">sdev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dev</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">unlock</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">ATA_DFLAG_NO_UNLOAD</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">EOPNOTSUPP</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">unlock</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">link</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">link</span><span class="p">;</span>
	<span class="n">now</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">pflags</span> <span class="o">&amp;</span> <span class="n">ATA_PFLAG_EH_IN_PROGRESS</span> <span class="o">&amp;&amp;</span>
	    <span class="n">link</span><span class="o">-&gt;</span><span class="n">eh_context</span><span class="p">.</span><span class="n">unloaded_mask</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">devno</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="n">time_after</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">unpark_deadline</span><span class="p">,</span> <span class="n">now</span><span class="p">))</span>
		<span class="n">msecs</span> <span class="o">=</span> <span class="n">jiffies_to_msecs</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">unpark_deadline</span> <span class="o">-</span> <span class="n">now</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">msecs</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">unlock:</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">rc</span> <span class="o">?</span> <span class="n">rc</span> <span class="o">:</span> <span class="n">snprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="s">&quot;%u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">msecs</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">ata_scsi_park_store</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">device</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span>
				   <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="n">sdev</span> <span class="o">=</span> <span class="n">to_scsi_device</span><span class="p">(</span><span class="n">device</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ata_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">;</span>
	<span class="kt">long</span> <span class="kt">int</span> <span class="n">input</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">strict_strtol</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">input</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">||</span> <span class="n">input</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mi">2</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">input</span> <span class="o">&gt;</span> <span class="n">ATA_TMOUT_MAX_PARK</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">EOVERFLOW</span><span class="p">;</span>
		<span class="n">input</span> <span class="o">=</span> <span class="n">ATA_TMOUT_MAX_PARK</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ap</span> <span class="o">=</span> <span class="n">ata_shost_to_port</span><span class="p">(</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">);</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">dev</span> <span class="o">=</span> <span class="n">ata_scsi_find_dev</span><span class="p">(</span><span class="n">ap</span><span class="p">,</span> <span class="n">sdev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">dev</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">unlock</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">class</span> <span class="o">!=</span> <span class="n">ATA_DEV_ATA</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">EOPNOTSUPP</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">unlock</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">input</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">ATA_DFLAG_NO_UNLOAD</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">EOPNOTSUPP</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">unlock</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">unpark_deadline</span> <span class="o">=</span> <span class="n">ata_deadline</span><span class="p">(</span><span class="n">jiffies</span><span class="p">,</span> <span class="n">input</span><span class="p">);</span>
		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">link</span><span class="o">-&gt;</span><span class="n">eh_info</span><span class="p">.</span><span class="n">dev_action</span><span class="p">[</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">devno</span><span class="p">]</span> <span class="o">|=</span> <span class="n">ATA_EH_PARK</span><span class="p">;</span>
		<span class="n">ata_port_schedule_eh</span><span class="p">(</span><span class="n">ap</span><span class="p">);</span>
		<span class="n">complete</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">park_req_pending</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">input</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="o">-</span><span class="mi">1</span>:
			<span class="n">dev</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">ATA_DFLAG_NO_UNLOAD</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="o">-</span><span class="mi">2</span>:
			<span class="n">dev</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">ATA_DFLAG_NO_UNLOAD</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="nl">unlock:</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">rc</span> <span class="o">?</span> <span class="n">rc</span> <span class="o">:</span> <span class="n">len</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">DEVICE_ATTR</span><span class="p">(</span><span class="n">unload_heads</span><span class="p">,</span> <span class="n">S_IRUGO</span> <span class="o">|</span> <span class="n">S_IWUSR</span><span class="p">,</span>
	    <span class="n">ata_scsi_park_show</span><span class="p">,</span> <span class="n">ata_scsi_park_store</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">dev_attr_unload_heads</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">ata_scsi_set_sense</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">,</span> <span class="n">u8</span> <span class="n">sk</span><span class="p">,</span> <span class="n">u8</span> <span class="n">asc</span><span class="p">,</span> <span class="n">u8</span> <span class="n">ascq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">=</span> <span class="p">(</span><span class="n">DRIVER_SENSE</span> <span class="o">&lt;&lt;</span> <span class="mi">24</span><span class="p">)</span> <span class="o">|</span> <span class="n">SAM_STAT_CHECK_CONDITION</span><span class="p">;</span>

	<span class="n">scsi_build_sense_buffer</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">sense_buffer</span><span class="p">,</span> <span class="n">sk</span><span class="p">,</span> <span class="n">asc</span><span class="p">,</span> <span class="n">ascq</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span>
<span class="nf">ata_scsi_em_message_store</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span>
			  <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span> <span class="o">=</span> <span class="n">class_to_shost</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span> <span class="o">=</span> <span class="n">ata_shost_to_port</span><span class="p">(</span><span class="n">shost</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">em_store</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">ATA_FLAG_EM</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">ap</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">em_store</span><span class="p">(</span><span class="n">ap</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">count</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span>
<span class="nf">ata_scsi_em_message_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span>
			 <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span> <span class="o">=</span> <span class="n">class_to_shost</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span> <span class="o">=</span> <span class="n">ata_shost_to_port</span><span class="p">(</span><span class="n">shost</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">em_show</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">ATA_FLAG_EM</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">ap</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">em_show</span><span class="p">(</span><span class="n">ap</span><span class="p">,</span> <span class="n">buf</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">DEVICE_ATTR</span><span class="p">(</span><span class="n">em_message</span><span class="p">,</span> <span class="n">S_IRUGO</span> <span class="o">|</span> <span class="n">S_IWUSR</span><span class="p">,</span>
		<span class="n">ata_scsi_em_message_show</span><span class="p">,</span> <span class="n">ata_scsi_em_message_store</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">dev_attr_em_message</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">ssize_t</span>
<span class="nf">ata_scsi_em_message_type_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span>
			      <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span> <span class="o">=</span> <span class="n">class_to_shost</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span> <span class="o">=</span> <span class="n">ata_shost_to_port</span><span class="p">(</span><span class="n">shost</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">snprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="mi">23</span><span class="p">,</span> <span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ap</span><span class="o">-&gt;</span><span class="n">em_message_type</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">DEVICE_ATTR</span><span class="p">(</span><span class="n">em_message_type</span><span class="p">,</span> <span class="n">S_IRUGO</span><span class="p">,</span>
		  <span class="n">ata_scsi_em_message_type_show</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">dev_attr_em_message_type</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">ssize_t</span>
<span class="nf">ata_scsi_activity_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span>
		<span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="n">sdev</span> <span class="o">=</span> <span class="n">to_scsi_device</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span> <span class="o">=</span> <span class="n">ata_shost_to_port</span><span class="p">(</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">ata_device</span> <span class="o">*</span><span class="n">atadev</span> <span class="o">=</span> <span class="n">ata_scsi_find_dev</span><span class="p">(</span><span class="n">ap</span><span class="p">,</span> <span class="n">sdev</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">sw_activity_show</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">ATA_FLAG_SW_ACTIVITY</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">ap</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">sw_activity_show</span><span class="p">(</span><span class="n">atadev</span><span class="p">,</span> <span class="n">buf</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span>
<span class="nf">ata_scsi_activity_store</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="n">sdev</span> <span class="o">=</span> <span class="n">to_scsi_device</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span> <span class="o">=</span> <span class="n">ata_shost_to_port</span><span class="p">(</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">ata_device</span> <span class="o">*</span><span class="n">atadev</span> <span class="o">=</span> <span class="n">ata_scsi_find_dev</span><span class="p">(</span><span class="n">ap</span><span class="p">,</span> <span class="n">sdev</span><span class="p">);</span>
	<span class="k">enum</span> <span class="n">sw_activity</span> <span class="n">val</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">sw_activity_store</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">ATA_FLAG_SW_ACTIVITY</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">val</span> <span class="o">=</span> <span class="n">simple_strtoul</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">val</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">OFF</span>: <span class="k">case</span> <span class="n">BLINK_ON</span>: <span class="k">case</span> <span class="n">BLINK_OFF</span>:
			<span class="n">rc</span> <span class="o">=</span> <span class="n">ap</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">sw_activity_store</span><span class="p">(</span><span class="n">atadev</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rc</span><span class="p">)</span>
				<span class="k">return</span> <span class="n">count</span><span class="p">;</span>
			<span class="k">else</span>
				<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">DEVICE_ATTR</span><span class="p">(</span><span class="n">sw_activity</span><span class="p">,</span> <span class="n">S_IWUSR</span> <span class="o">|</span> <span class="n">S_IRUGO</span><span class="p">,</span> <span class="n">ata_scsi_activity_show</span><span class="p">,</span>
			<span class="n">ata_scsi_activity_store</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">dev_attr_sw_activity</span><span class="p">);</span>

<span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="n">ata_common_sdev_attrs</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="o">&amp;</span><span class="n">dev_attr_unload_heads</span><span class="p">,</span>
	<span class="nb">NULL</span>
<span class="p">};</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">ata_common_sdev_attrs</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">ata_scsi_invalid_field</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ata_scsi_set_sense</span><span class="p">(</span><span class="n">cmd</span><span class="p">,</span> <span class="n">ILLEGAL_REQUEST</span><span class="p">,</span> <span class="mh">0x24</span><span class="p">,</span> <span class="mh">0x0</span><span class="p">);</span>
	<span class="cm">/* &quot;Invalid field in cbd&quot; */</span>
	<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scsi_done</span><span class="p">(</span><span class="n">cmd</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	ata_std_bios_param - generic bios head/sector/cylinder calculator used by sd.</span>
<span class="cm"> *	@sdev: SCSI device for which BIOS geometry is to be determined</span>
<span class="cm"> *	@bdev: block device associated with @sdev</span>
<span class="cm"> *	@capacity: capacity of SCSI device</span>
<span class="cm"> *	@geom: location to which geometry will be output</span>
<span class="cm"> *</span>
<span class="cm"> *	Generic bios head/sector/cylinder calculator</span>
<span class="cm"> *	used by sd. Most BIOSes nowadays expect a XXX/255/16  (CHS)</span>
<span class="cm"> *	mapping. Some situations may arise where the disk is not</span>
<span class="cm"> *	bootable if this is not used.</span>
<span class="cm"> *</span>
<span class="cm"> *	LOCKING:</span>
<span class="cm"> *	Defined by the SCSI layer.  We don&#39;t really care.</span>
<span class="cm"> *</span>
<span class="cm"> *	RETURNS:</span>
<span class="cm"> *	Zero.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">ata_std_bios_param</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="n">sdev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">block_device</span> <span class="o">*</span><span class="n">bdev</span><span class="p">,</span>
		       <span class="n">sector_t</span> <span class="n">capacity</span><span class="p">,</span> <span class="kt">int</span> <span class="n">geom</span><span class="p">[])</span>
<span class="p">{</span>
	<span class="n">geom</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">255</span><span class="p">;</span>
	<span class="n">geom</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">63</span><span class="p">;</span>
	<span class="n">sector_div</span><span class="p">(</span><span class="n">capacity</span><span class="p">,</span> <span class="mi">255</span><span class="o">*</span><span class="mi">63</span><span class="p">);</span>
	<span class="n">geom</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">capacity</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	ata_scsi_unlock_native_capacity - unlock native capacity</span>
<span class="cm"> *	@sdev: SCSI device to adjust device capacity for</span>
<span class="cm"> *</span>
<span class="cm"> *	This function is called if a partition on @sdev extends beyond</span>
<span class="cm"> *	the end of the device.  It requests EH to unlock HPA.</span>
<span class="cm"> *</span>
<span class="cm"> *	LOCKING:</span>
<span class="cm"> *	Defined by the SCSI layer.  Might sleep.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">ata_scsi_unlock_native_capacity</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="n">sdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span> <span class="o">=</span> <span class="n">ata_shost_to_port</span><span class="p">(</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">ata_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">dev</span> <span class="o">=</span> <span class="n">ata_scsi_find_dev</span><span class="p">(</span><span class="n">ap</span><span class="p">,</span> <span class="n">sdev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span> <span class="o">&amp;&amp;</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">n_sectors</span> <span class="o">&lt;</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">n_native_sectors</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">ATA_DFLAG_UNLOCK_HPA</span><span class="p">;</span>
		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">link</span><span class="o">-&gt;</span><span class="n">eh_info</span><span class="p">.</span><span class="n">action</span> <span class="o">|=</span> <span class="n">ATA_EH_RESET</span><span class="p">;</span>
		<span class="n">ata_port_schedule_eh</span><span class="p">(</span><span class="n">ap</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">ata_port_wait_eh</span><span class="p">(</span><span class="n">ap</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	ata_get_identity - Handler for HDIO_GET_IDENTITY ioctl</span>
<span class="cm"> *	@ap: target port</span>
<span class="cm"> *	@sdev: SCSI device to get identify data for</span>
<span class="cm"> *	@arg: User buffer area for identify data</span>
<span class="cm"> *</span>
<span class="cm"> *	LOCKING:</span>
<span class="cm"> *	Defined by the SCSI layer.  We don&#39;t really care.</span>
<span class="cm"> *</span>
<span class="cm"> *	RETURNS:</span>
<span class="cm"> *	Zero on success, negative errno on error.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">ata_get_identity</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span><span class="p">,</span> <span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="n">sdev</span><span class="p">,</span>
			    <span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ata_device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">ata_scsi_find_dev</span><span class="p">(</span><span class="n">ap</span><span class="p">,</span> <span class="n">sdev</span><span class="p">);</span>
	<span class="n">u16</span> <span class="n">__user</span> <span class="o">*</span><span class="n">dst</span> <span class="o">=</span> <span class="n">arg</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="mi">40</span><span class="p">];</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dev</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMSG</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">copy_to_user</span><span class="p">(</span><span class="n">dst</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">,</span> <span class="n">ATA_ID_WORDS</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">u16</span><span class="p">)))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

	<span class="n">ata_id_string</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">ATA_ID_PROD</span><span class="p">,</span> <span class="n">ATA_ID_PROD_LEN</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">copy_to_user</span><span class="p">(</span><span class="n">dst</span> <span class="o">+</span> <span class="n">ATA_ID_PROD</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">ATA_ID_PROD_LEN</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

	<span class="n">ata_id_string</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">ATA_ID_FW_REV</span><span class="p">,</span> <span class="n">ATA_ID_FW_REV_LEN</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">copy_to_user</span><span class="p">(</span><span class="n">dst</span> <span class="o">+</span> <span class="n">ATA_ID_FW_REV</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">ATA_ID_FW_REV_LEN</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

	<span class="n">ata_id_string</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">ATA_ID_SERNO</span><span class="p">,</span> <span class="n">ATA_ID_SERNO_LEN</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">copy_to_user</span><span class="p">(</span><span class="n">dst</span> <span class="o">+</span> <span class="n">ATA_ID_SERNO</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">ATA_ID_SERNO_LEN</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	ata_cmd_ioctl - Handler for HDIO_DRIVE_CMD ioctl</span>
<span class="cm"> *	@scsidev: Device to which we are issuing command</span>
<span class="cm"> *	@arg: User provided data for issuing command</span>
<span class="cm"> *</span>
<span class="cm"> *	LOCKING:</span>
<span class="cm"> *	Defined by the SCSI layer.  We don&#39;t really care.</span>
<span class="cm"> *</span>
<span class="cm"> *	RETURNS:</span>
<span class="cm"> *	Zero on success, negative errno on error.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">ata_cmd_ioctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="n">scsidev</span><span class="p">,</span> <span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">scsi_cmd</span><span class="p">[</span><span class="n">MAX_COMMAND_SIZE</span><span class="p">];</span>
	<span class="n">u8</span> <span class="n">args</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span> <span class="o">*</span><span class="n">argbuf</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">*</span><span class="n">sensebuf</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">argsize</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">dma_data_direction</span> <span class="n">data_dir</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">cmd_result</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">arg</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">arg</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">args</span><span class="p">)))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

	<span class="n">sensebuf</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="n">SCSI_SENSE_BUFFERSIZE</span><span class="p">,</span> <span class="n">GFP_NOIO</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sensebuf</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">memset</span><span class="p">(</span><span class="n">scsi_cmd</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">scsi_cmd</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span> <span class="p">{</span>
		<span class="n">argsize</span> <span class="o">=</span> <span class="n">ATA_SECT_SIZE</span> <span class="o">*</span> <span class="n">args</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
		<span class="n">argbuf</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="n">argsize</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">argbuf</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">scsi_cmd</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>  <span class="o">=</span> <span class="p">(</span><span class="mi">4</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">);</span> <span class="cm">/* PIO Data-in */</span>
		<span class="n">scsi_cmd</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>  <span class="o">=</span> <span class="mh">0x0e</span><span class="p">;</span>     <span class="cm">/* no off.line or cc, read from dev,</span>
<span class="cm">					    block count in sector count field */</span>
		<span class="n">data_dir</span> <span class="o">=</span> <span class="n">DMA_FROM_DEVICE</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">scsi_cmd</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>  <span class="o">=</span> <span class="p">(</span><span class="mi">3</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">);</span> <span class="cm">/* Non-data */</span>
		<span class="n">scsi_cmd</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>  <span class="o">=</span> <span class="mh">0x20</span><span class="p">;</span>     <span class="cm">/* cc but no off.line or data xfer */</span>
		<span class="n">data_dir</span> <span class="o">=</span> <span class="n">DMA_NONE</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">scsi_cmd</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">ATA_16</span><span class="p">;</span>

	<span class="n">scsi_cmd</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">ATA_CMD_SMART</span><span class="p">)</span> <span class="p">{</span> <span class="cm">/* hack -- ide driver does this too */</span>
		<span class="n">scsi_cmd</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span>  <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
		<span class="n">scsi_cmd</span><span class="p">[</span><span class="mi">8</span><span class="p">]</span>  <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
		<span class="n">scsi_cmd</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x4f</span><span class="p">;</span>
		<span class="n">scsi_cmd</span><span class="p">[</span><span class="mi">12</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0xc2</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">scsi_cmd</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span>  <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
	<span class="p">}</span>
	<span class="n">scsi_cmd</span><span class="p">[</span><span class="mi">14</span><span class="p">]</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>

	<span class="cm">/* Good values for timeout and retries?  Values below</span>
<span class="cm">	   from scsi_ioctl_send_command() for default case... */</span>
	<span class="n">cmd_result</span> <span class="o">=</span> <span class="n">scsi_execute</span><span class="p">(</span><span class="n">scsidev</span><span class="p">,</span> <span class="n">scsi_cmd</span><span class="p">,</span> <span class="n">data_dir</span><span class="p">,</span> <span class="n">argbuf</span><span class="p">,</span> <span class="n">argsize</span><span class="p">,</span>
				  <span class="n">sensebuf</span><span class="p">,</span> <span class="p">(</span><span class="mi">10</span><span class="o">*</span><span class="n">HZ</span><span class="p">),</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">driver_byte</span><span class="p">(</span><span class="n">cmd_result</span><span class="p">)</span> <span class="o">==</span> <span class="n">DRIVER_SENSE</span><span class="p">)</span> <span class="p">{</span><span class="cm">/* sense data available */</span>
		<span class="n">u8</span> <span class="o">*</span><span class="n">desc</span> <span class="o">=</span> <span class="n">sensebuf</span> <span class="o">+</span> <span class="mi">8</span><span class="p">;</span>
		<span class="n">cmd_result</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="mh">0xFF</span><span class="o">&lt;&lt;</span><span class="mi">24</span><span class="p">);</span> <span class="cm">/* DRIVER_SENSE is not an error */</span>

		<span class="cm">/* If we set cc then ATA pass-through will cause a</span>
<span class="cm">		 * check condition even if no error. Filter that. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cmd_result</span> <span class="o">&amp;</span> <span class="n">SAM_STAT_CHECK_CONDITION</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">scsi_sense_hdr</span> <span class="n">sshdr</span><span class="p">;</span>
			<span class="n">scsi_normalize_sense</span><span class="p">(</span><span class="n">sensebuf</span><span class="p">,</span> <span class="n">SCSI_SENSE_BUFFERSIZE</span><span class="p">,</span>
					     <span class="o">&amp;</span><span class="n">sshdr</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">sshdr</span><span class="p">.</span><span class="n">sense_key</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span>
			    <span class="n">sshdr</span><span class="p">.</span><span class="n">asc</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">sshdr</span><span class="p">.</span><span class="n">ascq</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
				<span class="n">cmd_result</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">SAM_STAT_CHECK_CONDITION</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* Send userspace a few ATA registers (same as drivers/ide) */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sensebuf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mh">0x72</span> <span class="o">&amp;&amp;</span>	<span class="cm">/* format is &quot;descriptor&quot; */</span>
		    <span class="n">desc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mh">0x09</span><span class="p">)</span> <span class="p">{</span>		<span class="cm">/* code is &quot;ATA Descriptor&quot; */</span>
			<span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">desc</span><span class="p">[</span><span class="mi">13</span><span class="p">];</span>	<span class="cm">/* status */</span>
			<span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">desc</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>	<span class="cm">/* error */</span>
			<span class="n">args</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">desc</span><span class="p">[</span><span class="mi">5</span><span class="p">];</span>	<span class="cm">/* sector count (0:7) */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">copy_to_user</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">args</span><span class="p">)))</span>
				<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>


	<span class="k">if</span> <span class="p">(</span><span class="n">cmd_result</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">argbuf</span><span class="p">)</span>
	 <span class="o">&amp;&amp;</span> <span class="n">copy_to_user</span><span class="p">(</span><span class="n">arg</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">args</span><span class="p">),</span> <span class="n">argbuf</span><span class="p">,</span> <span class="n">argsize</span><span class="p">))</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
<span class="nl">error:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">sensebuf</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">argbuf</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	ata_task_ioctl - Handler for HDIO_DRIVE_TASK ioctl</span>
<span class="cm"> *	@scsidev: Device to which we are issuing command</span>
<span class="cm"> *	@arg: User provided data for issuing command</span>
<span class="cm"> *</span>
<span class="cm"> *	LOCKING:</span>
<span class="cm"> *	Defined by the SCSI layer.  We don&#39;t really care.</span>
<span class="cm"> *</span>
<span class="cm"> *	RETURNS:</span>
<span class="cm"> *	Zero on success, negative errno on error.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">ata_task_ioctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="n">scsidev</span><span class="p">,</span> <span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">scsi_cmd</span><span class="p">[</span><span class="n">MAX_COMMAND_SIZE</span><span class="p">];</span>
	<span class="n">u8</span> <span class="n">args</span><span class="p">[</span><span class="mi">7</span><span class="p">],</span> <span class="o">*</span><span class="n">sensebuf</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">cmd_result</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">arg</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">arg</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">args</span><span class="p">)))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

	<span class="n">sensebuf</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="n">SCSI_SENSE_BUFFERSIZE</span><span class="p">,</span> <span class="n">GFP_NOIO</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sensebuf</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">memset</span><span class="p">(</span><span class="n">scsi_cmd</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">scsi_cmd</span><span class="p">));</span>
	<span class="n">scsi_cmd</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>  <span class="o">=</span> <span class="n">ATA_16</span><span class="p">;</span>
	<span class="n">scsi_cmd</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>  <span class="o">=</span> <span class="p">(</span><span class="mi">3</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">);</span> <span class="cm">/* Non-data */</span>
	<span class="n">scsi_cmd</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>  <span class="o">=</span> <span class="mh">0x20</span><span class="p">;</span>     <span class="cm">/* cc but no off.line or data xfer */</span>
	<span class="n">scsi_cmd</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span>  <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
	<span class="n">scsi_cmd</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span>  <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
	<span class="n">scsi_cmd</span><span class="p">[</span><span class="mi">8</span><span class="p">]</span>  <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
	<span class="n">scsi_cmd</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
	<span class="n">scsi_cmd</span><span class="p">[</span><span class="mi">12</span><span class="p">]</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">5</span><span class="p">];</span>
	<span class="n">scsi_cmd</span><span class="p">[</span><span class="mi">13</span><span class="p">]</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0x4f</span><span class="p">;</span>
	<span class="n">scsi_cmd</span><span class="p">[</span><span class="mi">14</span><span class="p">]</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>

	<span class="cm">/* Good values for timeout and retries?  Values below</span>
<span class="cm">	   from scsi_ioctl_send_command() for default case... */</span>
	<span class="n">cmd_result</span> <span class="o">=</span> <span class="n">scsi_execute</span><span class="p">(</span><span class="n">scsidev</span><span class="p">,</span> <span class="n">scsi_cmd</span><span class="p">,</span> <span class="n">DMA_NONE</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
				<span class="n">sensebuf</span><span class="p">,</span> <span class="p">(</span><span class="mi">10</span><span class="o">*</span><span class="n">HZ</span><span class="p">),</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">driver_byte</span><span class="p">(</span><span class="n">cmd_result</span><span class="p">)</span> <span class="o">==</span> <span class="n">DRIVER_SENSE</span><span class="p">)</span> <span class="p">{</span><span class="cm">/* sense data available */</span>
		<span class="n">u8</span> <span class="o">*</span><span class="n">desc</span> <span class="o">=</span> <span class="n">sensebuf</span> <span class="o">+</span> <span class="mi">8</span><span class="p">;</span>
		<span class="n">cmd_result</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="mh">0xFF</span><span class="o">&lt;&lt;</span><span class="mi">24</span><span class="p">);</span> <span class="cm">/* DRIVER_SENSE is not an error */</span>

		<span class="cm">/* If we set cc then ATA pass-through will cause a</span>
<span class="cm">		 * check condition even if no error. Filter that. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cmd_result</span> <span class="o">&amp;</span> <span class="n">SAM_STAT_CHECK_CONDITION</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">scsi_sense_hdr</span> <span class="n">sshdr</span><span class="p">;</span>
			<span class="n">scsi_normalize_sense</span><span class="p">(</span><span class="n">sensebuf</span><span class="p">,</span> <span class="n">SCSI_SENSE_BUFFERSIZE</span><span class="p">,</span>
						<span class="o">&amp;</span><span class="n">sshdr</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">sshdr</span><span class="p">.</span><span class="n">sense_key</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span>
				<span class="n">sshdr</span><span class="p">.</span><span class="n">asc</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">sshdr</span><span class="p">.</span><span class="n">ascq</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
				<span class="n">cmd_result</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">SAM_STAT_CHECK_CONDITION</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* Send userspace ATA registers */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sensebuf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mh">0x72</span> <span class="o">&amp;&amp;</span>	<span class="cm">/* format is &quot;descriptor&quot; */</span>
				<span class="n">desc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mh">0x09</span><span class="p">)</span> <span class="p">{</span><span class="cm">/* code is &quot;ATA Descriptor&quot; */</span>
			<span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">desc</span><span class="p">[</span><span class="mi">13</span><span class="p">];</span>	<span class="cm">/* status */</span>
			<span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">desc</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>	<span class="cm">/* error */</span>
			<span class="n">args</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">desc</span><span class="p">[</span><span class="mi">5</span><span class="p">];</span>	<span class="cm">/* sector count (0:7) */</span>
			<span class="n">args</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">desc</span><span class="p">[</span><span class="mi">7</span><span class="p">];</span>	<span class="cm">/* lbal */</span>
			<span class="n">args</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="n">desc</span><span class="p">[</span><span class="mi">9</span><span class="p">];</span>	<span class="cm">/* lbam */</span>
			<span class="n">args</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="n">desc</span><span class="p">[</span><span class="mi">11</span><span class="p">];</span>	<span class="cm">/* lbah */</span>
			<span class="n">args</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span> <span class="o">=</span> <span class="n">desc</span><span class="p">[</span><span class="mi">12</span><span class="p">];</span>	<span class="cm">/* select */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">copy_to_user</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">args</span><span class="p">)))</span>
				<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cmd_result</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
	<span class="p">}</span>

 <span class="nl">error:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">sensebuf</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">ata_ioc32</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">ATA_FLAG_PIO_DMA</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">pflags</span> <span class="o">&amp;</span> <span class="n">ATA_PFLAG_PIO32</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">ata_sas_scsi_ioctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span><span class="p">,</span> <span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="n">scsidev</span><span class="p">,</span>
		     <span class="kt">int</span> <span class="n">cmd</span><span class="p">,</span> <span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">val</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">,</span> <span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">cmd</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">ATA_IOC_GET_IO32</span>:
		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="n">val</span> <span class="o">=</span> <span class="n">ata_ioc32</span><span class="p">(</span><span class="n">ap</span><span class="p">);</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">copy_to_user</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">val</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">ATA_IOC_SET_IO32</span>:
		<span class="n">val</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">arg</span><span class="p">;</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">pflags</span> <span class="o">&amp;</span> <span class="n">ATA_PFLAG_PIO32CHANGE</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">val</span><span class="p">)</span>
				<span class="n">ap</span><span class="o">-&gt;</span><span class="n">pflags</span> <span class="o">|=</span> <span class="n">ATA_PFLAG_PIO32</span><span class="p">;</span>
			<span class="k">else</span>
				<span class="n">ap</span><span class="o">-&gt;</span><span class="n">pflags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">ATA_PFLAG_PIO32</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">val</span> <span class="o">!=</span> <span class="n">ata_ioc32</span><span class="p">(</span><span class="n">ap</span><span class="p">))</span>
				<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">HDIO_GET_IDENTITY</span>:
		<span class="k">return</span> <span class="n">ata_get_identity</span><span class="p">(</span><span class="n">ap</span><span class="p">,</span> <span class="n">scsidev</span><span class="p">,</span> <span class="n">arg</span><span class="p">);</span>

	<span class="k">case</span> <span class="n">HDIO_DRIVE_CMD</span>:
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">capable</span><span class="p">(</span><span class="n">CAP_SYS_ADMIN</span><span class="p">)</span> <span class="o">||</span> <span class="o">!</span><span class="n">capable</span><span class="p">(</span><span class="n">CAP_SYS_RAWIO</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EACCES</span><span class="p">;</span>
		<span class="k">return</span> <span class="n">ata_cmd_ioctl</span><span class="p">(</span><span class="n">scsidev</span><span class="p">,</span> <span class="n">arg</span><span class="p">);</span>

	<span class="k">case</span> <span class="n">HDIO_DRIVE_TASK</span>:
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">capable</span><span class="p">(</span><span class="n">CAP_SYS_ADMIN</span><span class="p">)</span> <span class="o">||</span> <span class="o">!</span><span class="n">capable</span><span class="p">(</span><span class="n">CAP_SYS_RAWIO</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EACCES</span><span class="p">;</span>
		<span class="k">return</span> <span class="n">ata_task_ioctl</span><span class="p">(</span><span class="n">scsidev</span><span class="p">,</span> <span class="n">arg</span><span class="p">);</span>

	<span class="nl">default:</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOTTY</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">ata_sas_scsi_ioctl</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">ata_scsi_ioctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="n">scsidev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">,</span> <span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">ata_sas_scsi_ioctl</span><span class="p">(</span><span class="n">ata_shost_to_port</span><span class="p">(</span><span class="n">scsidev</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">),</span>
				<span class="n">scsidev</span><span class="p">,</span> <span class="n">cmd</span><span class="p">,</span> <span class="n">arg</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">ata_scsi_ioctl</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> *	ata_scsi_qc_new - acquire new ata_queued_cmd reference</span>
<span class="cm"> *	@dev: ATA device to which the new command is attached</span>
<span class="cm"> *	@cmd: SCSI command that originated this ATA command</span>
<span class="cm"> *</span>
<span class="cm"> *	Obtain a reference to an unused ata_queued_cmd structure,</span>
<span class="cm"> *	which is the basic libata structure representing a single</span>
<span class="cm"> *	ATA command sent to the hardware.</span>
<span class="cm"> *</span>
<span class="cm"> *	If a command was available, fill in the SCSI-specific</span>
<span class="cm"> *	portions of the structure with information on the</span>
<span class="cm"> *	current command.</span>
<span class="cm"> *</span>
<span class="cm"> *	LOCKING:</span>
<span class="cm"> *	spin_lock_irqsave(host lock)</span>
<span class="cm"> *</span>
<span class="cm"> *	RETURNS:</span>
<span class="cm"> *	Command allocated, or %NULL if none available.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">ata_queued_cmd</span> <span class="o">*</span><span class="nf">ata_scsi_qc_new</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span>
					      <span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ata_queued_cmd</span> <span class="o">*</span><span class="n">qc</span><span class="p">;</span>

	<span class="n">qc</span> <span class="o">=</span> <span class="n">ata_qc_new_init</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">qc</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">qc</span><span class="o">-&gt;</span><span class="n">scsicmd</span> <span class="o">=</span> <span class="n">cmd</span><span class="p">;</span>
		<span class="n">qc</span><span class="o">-&gt;</span><span class="n">scsidone</span> <span class="o">=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scsi_done</span><span class="p">;</span>

		<span class="n">qc</span><span class="o">-&gt;</span><span class="n">sg</span> <span class="o">=</span> <span class="n">scsi_sglist</span><span class="p">(</span><span class="n">cmd</span><span class="p">);</span>
		<span class="n">qc</span><span class="o">-&gt;</span><span class="n">n_elem</span> <span class="o">=</span> <span class="n">scsi_sg_count</span><span class="p">(</span><span class="n">cmd</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">=</span> <span class="p">(</span><span class="n">DID_OK</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">QUEUE_FULL</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scsi_done</span><span class="p">(</span><span class="n">cmd</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">qc</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">ata_qc_set_pc_nbytes</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_queued_cmd</span> <span class="o">*</span><span class="n">qc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="n">scmd</span> <span class="o">=</span> <span class="n">qc</span><span class="o">-&gt;</span><span class="n">scsicmd</span><span class="p">;</span>

	<span class="n">qc</span><span class="o">-&gt;</span><span class="n">extrabytes</span> <span class="o">=</span> <span class="n">scmd</span><span class="o">-&gt;</span><span class="n">request</span><span class="o">-&gt;</span><span class="n">extra_len</span><span class="p">;</span>
	<span class="n">qc</span><span class="o">-&gt;</span><span class="n">nbytes</span> <span class="o">=</span> <span class="n">scsi_bufflen</span><span class="p">(</span><span class="n">scmd</span><span class="p">)</span> <span class="o">+</span> <span class="n">qc</span><span class="o">-&gt;</span><span class="n">extrabytes</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	ata_dump_status - user friendly display of error info</span>
<span class="cm"> *	@id: id of the port in question</span>
<span class="cm"> *	@tf: ptr to filled out taskfile</span>
<span class="cm"> *</span>
<span class="cm"> *	Decode and dump the ATA error/status registers for the user so</span>
<span class="cm"> *	that they have some idea what really happened at the non</span>
<span class="cm"> *	make-believe layer.</span>
<span class="cm"> *</span>
<span class="cm"> *	LOCKING:</span>
<span class="cm"> *	inherited from caller</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">ata_dump_status</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">id</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ata_taskfile</span> <span class="o">*</span><span class="n">tf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u8</span> <span class="n">stat</span> <span class="o">=</span> <span class="n">tf</span><span class="o">-&gt;</span><span class="n">command</span><span class="p">,</span> <span class="n">err</span> <span class="o">=</span> <span class="n">tf</span><span class="o">-&gt;</span><span class="n">feature</span><span class="p">;</span>

	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;ata%u: status=0x%02x { &quot;</span><span class="p">,</span> <span class="n">id</span><span class="p">,</span> <span class="n">stat</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">stat</span> <span class="o">&amp;</span> <span class="n">ATA_BUSY</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;Busy }</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>	<span class="cm">/* Data is not valid in this case */</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">stat</span> <span class="o">&amp;</span> <span class="mh">0x40</span><span class="p">)</span>	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;DriveReady &quot;</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">stat</span> <span class="o">&amp;</span> <span class="mh">0x20</span><span class="p">)</span>	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;DeviceFault &quot;</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">stat</span> <span class="o">&amp;</span> <span class="mh">0x10</span><span class="p">)</span>	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;SeekComplete &quot;</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">stat</span> <span class="o">&amp;</span> <span class="mh">0x08</span><span class="p">)</span>	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;DataRequest &quot;</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">stat</span> <span class="o">&amp;</span> <span class="mh">0x04</span><span class="p">)</span>	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;CorrectedError &quot;</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">stat</span> <span class="o">&amp;</span> <span class="mh">0x02</span><span class="p">)</span>	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;Index &quot;</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">stat</span> <span class="o">&amp;</span> <span class="mh">0x01</span><span class="p">)</span>	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;Error &quot;</span><span class="p">);</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;}</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;ata%u: error=0x%02x { &quot;</span><span class="p">,</span> <span class="n">id</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&amp;</span> <span class="mh">0x04</span><span class="p">)</span>		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;DriveStatusError &quot;</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&amp;</span> <span class="mh">0x80</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&amp;</span> <span class="mh">0x04</span><span class="p">)</span>	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;BadCRC &quot;</span><span class="p">);</span>
				<span class="k">else</span>		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;Sector &quot;</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&amp;</span> <span class="mh">0x40</span><span class="p">)</span>		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;UncorrectableError &quot;</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&amp;</span> <span class="mh">0x10</span><span class="p">)</span>		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;SectorIdNotFound &quot;</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&amp;</span> <span class="mh">0x02</span><span class="p">)</span>		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;TrackZeroNotFound &quot;</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&amp;</span> <span class="mh">0x01</span><span class="p">)</span>		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;AddrMarkNotFound &quot;</span><span class="p">);</span>
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot;}</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	ata_to_sense_error - convert ATA error to SCSI error</span>
<span class="cm"> *	@id: ATA device number</span>
<span class="cm"> *	@drv_stat: value contained in ATA status register</span>
<span class="cm"> *	@drv_err: value contained in ATA error register</span>
<span class="cm"> *	@sk: the sense key we&#39;ll fill out</span>
<span class="cm"> *	@asc: the additional sense code we&#39;ll fill out</span>
<span class="cm"> *	@ascq: the additional sense code qualifier we&#39;ll fill out</span>
<span class="cm"> *	@verbose: be verbose</span>
<span class="cm"> *</span>
<span class="cm"> *	Converts an ATA error into a SCSI error.  Fill out pointers to</span>
<span class="cm"> *	SK, ASC, and ASCQ bytes for later use in fixed or descriptor</span>
<span class="cm"> *	format sense blocks.</span>
<span class="cm"> *</span>
<span class="cm"> *	LOCKING:</span>
<span class="cm"> *	spin_lock_irqsave(host lock)</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">ata_to_sense_error</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">id</span><span class="p">,</span> <span class="n">u8</span> <span class="n">drv_stat</span><span class="p">,</span> <span class="n">u8</span> <span class="n">drv_err</span><span class="p">,</span> <span class="n">u8</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span>
			       <span class="n">u8</span> <span class="o">*</span><span class="n">asc</span><span class="p">,</span> <span class="n">u8</span> <span class="o">*</span><span class="n">ascq</span><span class="p">,</span> <span class="kt">int</span> <span class="n">verbose</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="cm">/* Based on the 3ware driver translation table */</span>
	<span class="k">static</span> <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">sense_table</span><span class="p">[][</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
		<span class="cm">/* BBD|ECC|ID|MAR */</span>
		<span class="p">{</span><span class="mh">0xd1</span><span class="p">,</span> 		<span class="n">ABORTED_COMMAND</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">},</span> 	<span class="c1">// Device busy                  Aborted command</span>
		<span class="cm">/* BBD|ECC|ID */</span>
		<span class="p">{</span><span class="mh">0xd0</span><span class="p">,</span>  	<span class="n">ABORTED_COMMAND</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">},</span> 	<span class="c1">// Device busy                  Aborted command</span>
		<span class="cm">/* ECC|MC|MARK */</span>
		<span class="p">{</span><span class="mh">0x61</span><span class="p">,</span> 		<span class="n">HARDWARE_ERROR</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">},</span> 	<span class="c1">// Device fault                 Hardware error</span>
		<span class="cm">/* ICRC|ABRT */</span>		<span class="cm">/* NB: ICRC &amp; !ABRT is BBD */</span>
		<span class="p">{</span><span class="mh">0x84</span><span class="p">,</span> 		<span class="n">ABORTED_COMMAND</span><span class="p">,</span> <span class="mh">0x47</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">},</span> 	<span class="c1">// Data CRC error               SCSI parity error</span>
		<span class="cm">/* MC|ID|ABRT|TRK0|MARK */</span>
		<span class="p">{</span><span class="mh">0x37</span><span class="p">,</span> 		<span class="n">NOT_READY</span><span class="p">,</span> <span class="mh">0x04</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">},</span> 	<span class="c1">// Unit offline                 Not ready</span>
		<span class="cm">/* MCR|MARK */</span>
		<span class="p">{</span><span class="mh">0x09</span><span class="p">,</span> 		<span class="n">NOT_READY</span><span class="p">,</span> <span class="mh">0x04</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">},</span> 	<span class="c1">// Unrecovered disk error       Not ready</span>
		<span class="cm">/*  Bad address mark */</span>
		<span class="p">{</span><span class="mh">0x01</span><span class="p">,</span> 		<span class="n">MEDIUM_ERROR</span><span class="p">,</span> <span class="mh">0x13</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">},</span> 	<span class="c1">// Address mark not found       Address mark not found for data field</span>
		<span class="cm">/* TRK0 */</span>
		<span class="p">{</span><span class="mh">0x02</span><span class="p">,</span> 		<span class="n">HARDWARE_ERROR</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">},</span> 	<span class="c1">// Track 0 not found		  Hardware error</span>
		<span class="cm">/* Abort &amp; !ICRC */</span>
		<span class="p">{</span><span class="mh">0x04</span><span class="p">,</span> 		<span class="n">ABORTED_COMMAND</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">},</span> 	<span class="c1">// Aborted command              Aborted command</span>
		<span class="cm">/* Media change request */</span>
		<span class="p">{</span><span class="mh">0x08</span><span class="p">,</span> 		<span class="n">NOT_READY</span><span class="p">,</span> <span class="mh">0x04</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">},</span> 	<span class="c1">// Media change request	  FIXME: faking offline</span>
		<span class="cm">/* SRV */</span>
		<span class="p">{</span><span class="mh">0x10</span><span class="p">,</span> 		<span class="n">ABORTED_COMMAND</span><span class="p">,</span> <span class="mh">0x14</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">},</span> 	<span class="c1">// ID not found                 Recorded entity not found</span>
		<span class="cm">/* Media change */</span>
		<span class="p">{</span><span class="mh">0x08</span><span class="p">,</span>  	<span class="n">NOT_READY</span><span class="p">,</span> <span class="mh">0x04</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">},</span> 	<span class="c1">// Media change		  FIXME: faking offline</span>
		<span class="cm">/* ECC */</span>
		<span class="p">{</span><span class="mh">0x40</span><span class="p">,</span> 		<span class="n">MEDIUM_ERROR</span><span class="p">,</span> <span class="mh">0x11</span><span class="p">,</span> <span class="mh">0x04</span><span class="p">},</span> 	<span class="c1">// Uncorrectable ECC error      Unrecovered read error</span>
		<span class="cm">/* BBD - block marked bad */</span>
		<span class="p">{</span><span class="mh">0x80</span><span class="p">,</span> 		<span class="n">MEDIUM_ERROR</span><span class="p">,</span> <span class="mh">0x11</span><span class="p">,</span> <span class="mh">0x04</span><span class="p">},</span> 	<span class="c1">// Block marked bad		  Medium error, unrecovered read error</span>
		<span class="p">{</span><span class="mh">0xFF</span><span class="p">,</span> <span class="mh">0xFF</span><span class="p">,</span> <span class="mh">0xFF</span><span class="p">,</span> <span class="mh">0xFF</span><span class="p">},</span> <span class="c1">// END mark</span>
	<span class="p">};</span>
	<span class="k">static</span> <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">stat_table</span><span class="p">[][</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
		<span class="cm">/* Must be first because BUSY means no other bits valid */</span>
		<span class="p">{</span><span class="mh">0x80</span><span class="p">,</span> 		<span class="n">ABORTED_COMMAND</span><span class="p">,</span> <span class="mh">0x47</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">},</span>	<span class="c1">// Busy, fake parity for now</span>
		<span class="p">{</span><span class="mh">0x20</span><span class="p">,</span> 		<span class="n">HARDWARE_ERROR</span><span class="p">,</span>  <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">},</span> 	<span class="c1">// Device fault</span>
		<span class="p">{</span><span class="mh">0x08</span><span class="p">,</span> 		<span class="n">ABORTED_COMMAND</span><span class="p">,</span> <span class="mh">0x47</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">},</span>	<span class="c1">// Timed out in xfer, fake parity for now</span>
		<span class="p">{</span><span class="mh">0x04</span><span class="p">,</span> 		<span class="n">RECOVERED_ERROR</span><span class="p">,</span> <span class="mh">0x11</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">},</span>	<span class="c1">// Recovered ECC error	  Medium error, recovered</span>
		<span class="p">{</span><span class="mh">0xFF</span><span class="p">,</span> <span class="mh">0xFF</span><span class="p">,</span> <span class="mh">0xFF</span><span class="p">,</span> <span class="mh">0xFF</span><span class="p">},</span> <span class="c1">// END mark</span>
	<span class="p">};</span>

	<span class="cm">/*</span>
<span class="cm">	 *	Is this an error we can process/parse</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">drv_stat</span> <span class="o">&amp;</span> <span class="n">ATA_BUSY</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">drv_err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>	<span class="cm">/* Ignore the err bits, they&#39;re invalid */</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">drv_err</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Look for drv_err */</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">sense_table</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="mh">0xFF</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Look for best matches first */</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">sense_table</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">drv_err</span><span class="p">)</span> <span class="o">==</span>
			    <span class="n">sense_table</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span> <span class="p">{</span>
				<span class="o">*</span><span class="n">sk</span> <span class="o">=</span> <span class="n">sense_table</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">];</span>
				<span class="o">*</span><span class="n">asc</span> <span class="o">=</span> <span class="n">sense_table</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">2</span><span class="p">];</span>
				<span class="o">*</span><span class="n">ascq</span> <span class="o">=</span> <span class="n">sense_table</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">3</span><span class="p">];</span>
				<span class="k">goto</span> <span class="n">translate_done</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="cm">/* No immediate match */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">verbose</span><span class="p">)</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;ata%u: no sense translation for &quot;</span>
			       <span class="s">&quot;error 0x%02x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">id</span><span class="p">,</span> <span class="n">drv_err</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Fall back to interpreting status bits */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">stat_table</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="mh">0xFF</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">stat_table</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">drv_stat</span><span class="p">)</span> <span class="p">{</span>
			<span class="o">*</span><span class="n">sk</span> <span class="o">=</span> <span class="n">stat_table</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">];</span>
			<span class="o">*</span><span class="n">asc</span> <span class="o">=</span> <span class="n">stat_table</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">2</span><span class="p">];</span>
			<span class="o">*</span><span class="n">ascq</span> <span class="o">=</span> <span class="n">stat_table</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">3</span><span class="p">];</span>
			<span class="k">goto</span> <span class="n">translate_done</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="cm">/* No error?  Undecoded? */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">verbose</span><span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;ata%u: no sense translation for &quot;</span>
		       <span class="s">&quot;status: 0x%02x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">id</span><span class="p">,</span> <span class="n">drv_stat</span><span class="p">);</span>

	<span class="cm">/* We need a sensible error return here, which is tricky, and one</span>
<span class="cm">	   that won&#39;t cause people to do things like return a disk wrongly */</span>
	<span class="o">*</span><span class="n">sk</span> <span class="o">=</span> <span class="n">ABORTED_COMMAND</span><span class="p">;</span>
	<span class="o">*</span><span class="n">asc</span> <span class="o">=</span> <span class="mh">0x00</span><span class="p">;</span>
	<span class="o">*</span><span class="n">ascq</span> <span class="o">=</span> <span class="mh">0x00</span><span class="p">;</span>

 <span class="nl">translate_done:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">verbose</span><span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;ata%u: translated ATA stat/err 0x%02x/%02x &quot;</span>
		       <span class="s">&quot;to SCSI SK/ASC/ASCQ 0x%x/%02x/%02x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">id</span><span class="p">,</span> <span class="n">drv_stat</span><span class="p">,</span> <span class="n">drv_err</span><span class="p">,</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span> <span class="o">*</span><span class="n">asc</span><span class="p">,</span> <span class="o">*</span><span class="n">ascq</span><span class="p">);</span>
	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *	ata_gen_passthru_sense - Generate check condition sense block.</span>
<span class="cm"> *	@qc: Command that completed.</span>
<span class="cm"> *</span>
<span class="cm"> *	This function is specific to the ATA descriptor format sense</span>
<span class="cm"> *	block specified for the ATA pass through commands.  Regardless</span>
<span class="cm"> *	of whether the command errored or not, return a sense</span>
<span class="cm"> *	block. Copy all controller registers into the sense</span>
<span class="cm"> *	block. Clear sense key, ASC &amp; ASCQ if there is no error.</span>
<span class="cm"> *</span>
<span class="cm"> *	LOCKING:</span>
<span class="cm"> *	None.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">ata_gen_passthru_sense</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_queued_cmd</span> <span class="o">*</span><span class="n">qc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="n">cmd</span> <span class="o">=</span> <span class="n">qc</span><span class="o">-&gt;</span><span class="n">scsicmd</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ata_taskfile</span> <span class="o">*</span><span class="n">tf</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">qc</span><span class="o">-&gt;</span><span class="n">result_tf</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">sb</span> <span class="o">=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">sense_buffer</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">desc</span> <span class="o">=</span> <span class="n">sb</span> <span class="o">+</span> <span class="mi">8</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">verbose</span> <span class="o">=</span> <span class="n">qc</span><span class="o">-&gt;</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">error_handler</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">memset</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">SCSI_SENSE_BUFFERSIZE</span><span class="p">);</span>

	<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">=</span> <span class="p">(</span><span class="n">DRIVER_SENSE</span> <span class="o">&lt;&lt;</span> <span class="mi">24</span><span class="p">)</span> <span class="o">|</span> <span class="n">SAM_STAT_CHECK_CONDITION</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Use ata_to_sense_error() to map status register bits</span>
<span class="cm">	 * onto sense key, asc &amp; ascq.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">qc</span><span class="o">-&gt;</span><span class="n">err_mask</span> <span class="o">||</span>
	    <span class="n">tf</span><span class="o">-&gt;</span><span class="n">command</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">ATA_BUSY</span> <span class="o">|</span> <span class="n">ATA_DF</span> <span class="o">|</span> <span class="n">ATA_ERR</span> <span class="o">|</span> <span class="n">ATA_DRQ</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ata_to_sense_error</span><span class="p">(</span><span class="n">qc</span><span class="o">-&gt;</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">print_id</span><span class="p">,</span> <span class="n">tf</span><span class="o">-&gt;</span><span class="n">command</span><span class="p">,</span> <span class="n">tf</span><span class="o">-&gt;</span><span class="n">feature</span><span class="p">,</span>
				   <span class="o">&amp;</span><span class="n">sb</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">sb</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">sb</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">verbose</span><span class="p">);</span>
		<span class="n">sb</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&amp;=</span> <span class="mh">0x0f</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Sense data is current and format is descriptor.</span>
<span class="cm">	 */</span>
	<span class="n">sb</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x72</span><span class="p">;</span>

	<span class="n">desc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x09</span><span class="p">;</span>

	<span class="cm">/* set length of additional sense data */</span>
	<span class="n">sb</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span> <span class="o">=</span> <span class="mi">14</span><span class="p">;</span>
	<span class="n">desc</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">12</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Copy registers into sense buffer.</span>
<span class="cm">	 */</span>
	<span class="n">desc</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x00</span><span class="p">;</span>
	<span class="n">desc</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">tf</span><span class="o">-&gt;</span><span class="n">feature</span><span class="p">;</span>	<span class="cm">/* == error reg */</span>
	<span class="n">desc</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="n">tf</span><span class="o">-&gt;</span><span class="n">nsect</span><span class="p">;</span>
	<span class="n">desc</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span> <span class="o">=</span> <span class="n">tf</span><span class="o">-&gt;</span><span class="n">lbal</span><span class="p">;</span>
	<span class="n">desc</span><span class="p">[</span><span class="mi">9</span><span class="p">]</span> <span class="o">=</span> <span class="n">tf</span><span class="o">-&gt;</span><span class="n">lbam</span><span class="p">;</span>
	<span class="n">desc</span><span class="p">[</span><span class="mi">11</span><span class="p">]</span> <span class="o">=</span> <span class="n">tf</span><span class="o">-&gt;</span><span class="n">lbah</span><span class="p">;</span>
	<span class="n">desc</span><span class="p">[</span><span class="mi">12</span><span class="p">]</span> <span class="o">=</span> <span class="n">tf</span><span class="o">-&gt;</span><span class="n">device</span><span class="p">;</span>
	<span class="n">desc</span><span class="p">[</span><span class="mi">13</span><span class="p">]</span> <span class="o">=</span> <span class="n">tf</span><span class="o">-&gt;</span><span class="n">command</span><span class="p">;</span> <span class="cm">/* == status reg */</span>

	<span class="cm">/*</span>
<span class="cm">	 * Fill in Extend bit, and the high order bytes</span>
<span class="cm">	 * if applicable.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tf</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">ATA_TFLAG_LBA48</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">desc</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">|=</span> <span class="mh">0x01</span><span class="p">;</span>
		<span class="n">desc</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="n">tf</span><span class="o">-&gt;</span><span class="n">hob_nsect</span><span class="p">;</span>
		<span class="n">desc</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span> <span class="o">=</span> <span class="n">tf</span><span class="o">-&gt;</span><span class="n">hob_lbal</span><span class="p">;</span>
		<span class="n">desc</span><span class="p">[</span><span class="mi">8</span><span class="p">]</span> <span class="o">=</span> <span class="n">tf</span><span class="o">-&gt;</span><span class="n">hob_lbam</span><span class="p">;</span>
		<span class="n">desc</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span> <span class="o">=</span> <span class="n">tf</span><span class="o">-&gt;</span><span class="n">hob_lbah</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	ata_gen_ata_sense - generate a SCSI fixed sense block</span>
<span class="cm"> *	@qc: Command that we are erroring out</span>
<span class="cm"> *</span>
<span class="cm"> *	Generate sense block for a failed ATA command @qc.  Descriptor</span>
<span class="cm"> *	format is used to accommodate LBA48 block address.</span>
<span class="cm"> *</span>
<span class="cm"> *	LOCKING:</span>
<span class="cm"> *	None.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">ata_gen_ata_sense</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_queued_cmd</span> <span class="o">*</span><span class="n">qc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ata_device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">qc</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="n">cmd</span> <span class="o">=</span> <span class="n">qc</span><span class="o">-&gt;</span><span class="n">scsicmd</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ata_taskfile</span> <span class="o">*</span><span class="n">tf</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">qc</span><span class="o">-&gt;</span><span class="n">result_tf</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">sb</span> <span class="o">=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">sense_buffer</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">desc</span> <span class="o">=</span> <span class="n">sb</span> <span class="o">+</span> <span class="mi">8</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">verbose</span> <span class="o">=</span> <span class="n">qc</span><span class="o">-&gt;</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">error_handler</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">block</span><span class="p">;</span>

	<span class="n">memset</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">SCSI_SENSE_BUFFERSIZE</span><span class="p">);</span>

	<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">=</span> <span class="p">(</span><span class="n">DRIVER_SENSE</span> <span class="o">&lt;&lt;</span> <span class="mi">24</span><span class="p">)</span> <span class="o">|</span> <span class="n">SAM_STAT_CHECK_CONDITION</span><span class="p">;</span>

	<span class="cm">/* sense data is current and format is descriptor */</span>
	<span class="n">sb</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x72</span><span class="p">;</span>

	<span class="cm">/* Use ata_to_sense_error() to map status register bits</span>
<span class="cm">	 * onto sense key, asc &amp; ascq.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">qc</span><span class="o">-&gt;</span><span class="n">err_mask</span> <span class="o">||</span>
	    <span class="n">tf</span><span class="o">-&gt;</span><span class="n">command</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">ATA_BUSY</span> <span class="o">|</span> <span class="n">ATA_DF</span> <span class="o">|</span> <span class="n">ATA_ERR</span> <span class="o">|</span> <span class="n">ATA_DRQ</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ata_to_sense_error</span><span class="p">(</span><span class="n">qc</span><span class="o">-&gt;</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">print_id</span><span class="p">,</span> <span class="n">tf</span><span class="o">-&gt;</span><span class="n">command</span><span class="p">,</span> <span class="n">tf</span><span class="o">-&gt;</span><span class="n">feature</span><span class="p">,</span>
				   <span class="o">&amp;</span><span class="n">sb</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">sb</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">sb</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">verbose</span><span class="p">);</span>
		<span class="n">sb</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&amp;=</span> <span class="mh">0x0f</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">block</span> <span class="o">=</span> <span class="n">ata_tf_read_block</span><span class="p">(</span><span class="o">&amp;</span><span class="n">qc</span><span class="o">-&gt;</span><span class="n">result_tf</span><span class="p">,</span> <span class="n">dev</span><span class="p">);</span>

	<span class="cm">/* information sense data descriptor */</span>
	<span class="n">sb</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span> <span class="o">=</span> <span class="mi">12</span><span class="p">;</span>
	<span class="n">desc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x00</span><span class="p">;</span>
	<span class="n">desc</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>

	<span class="n">desc</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">|=</span> <span class="mh">0x80</span><span class="p">;</span>	<span class="cm">/* valid */</span>
	<span class="n">desc</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span> <span class="o">=</span> <span class="n">block</span> <span class="o">&gt;&gt;</span> <span class="mi">40</span><span class="p">;</span>
	<span class="n">desc</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span> <span class="o">=</span> <span class="n">block</span> <span class="o">&gt;&gt;</span> <span class="mi">32</span><span class="p">;</span>
	<span class="n">desc</span><span class="p">[</span><span class="mi">8</span><span class="p">]</span> <span class="o">=</span> <span class="n">block</span> <span class="o">&gt;&gt;</span> <span class="mi">24</span><span class="p">;</span>
	<span class="n">desc</span><span class="p">[</span><span class="mi">9</span><span class="p">]</span> <span class="o">=</span> <span class="n">block</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">;</span>
	<span class="n">desc</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span> <span class="o">=</span> <span class="n">block</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">;</span>
	<span class="n">desc</span><span class="p">[</span><span class="mi">11</span><span class="p">]</span> <span class="o">=</span> <span class="n">block</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">ata_scsi_sdev_config</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="n">sdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">sdev</span><span class="o">-&gt;</span><span class="n">use_10_for_rw</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">sdev</span><span class="o">-&gt;</span><span class="n">use_10_for_ms</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/* Schedule policy is determined by -&gt;qc_defer() callback and</span>
<span class="cm">	 * it needs to see every deferred qc.  Set dev_blocked to 1 to</span>
<span class="cm">	 * prevent SCSI midlayer from automatically deferring</span>
<span class="cm">	 * requests.</span>
<span class="cm">	 */</span>
	<span class="n">sdev</span><span class="o">-&gt;</span><span class="n">max_device_blocked</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	atapi_drain_needed - Check whether data transfer may overflow</span>
<span class="cm"> *	@rq: request to be checked</span>
<span class="cm"> *</span>
<span class="cm"> *	ATAPI commands which transfer variable length data to host</span>
<span class="cm"> *	might overflow due to application error or hardare bug.  This</span>
<span class="cm"> *	function checks whether overflow should be drained and ignored</span>
<span class="cm"> *	for @request.</span>
<span class="cm"> *</span>
<span class="cm"> *	LOCKING:</span>
<span class="cm"> *	None.</span>
<span class="cm"> *</span>
<span class="cm"> *	RETURNS:</span>
<span class="cm"> *	1 if ; otherwise, 0.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">atapi_drain_needed</span><span class="p">(</span><span class="k">struct</span> <span class="n">request</span> <span class="o">*</span><span class="n">rq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">cmd_type</span> <span class="o">!=</span> <span class="n">REQ_TYPE_BLOCK_PC</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">blk_rq_bytes</span><span class="p">(</span><span class="n">rq</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">cmd_flags</span> <span class="o">&amp;</span> <span class="n">REQ_WRITE</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">atapi_cmd_type</span><span class="p">(</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">cmd</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">==</span> <span class="n">ATAPI_MISC</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">ata_scsi_dev_config</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="n">sdev</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">ata_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">q</span> <span class="o">=</span> <span class="n">sdev</span><span class="o">-&gt;</span><span class="n">request_queue</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ata_id_has_unload</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">))</span>
		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">ATA_DFLAG_NO_UNLOAD</span><span class="p">;</span>

	<span class="cm">/* configure max sectors */</span>
	<span class="n">blk_queue_max_hw_sectors</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">max_sectors</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">class</span> <span class="o">==</span> <span class="n">ATA_DEV_ATAPI</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">void</span> <span class="o">*</span><span class="n">buf</span><span class="p">;</span>

		<span class="n">sdev</span><span class="o">-&gt;</span><span class="n">sector_size</span> <span class="o">=</span> <span class="n">ATA_SECT_SIZE</span><span class="p">;</span>

		<span class="cm">/* set DMA padding */</span>
		<span class="n">blk_queue_update_dma_pad</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">ATA_DMA_PAD_SZ</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>

		<span class="cm">/* configure draining */</span>
		<span class="n">buf</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="n">ATAPI_MAX_DRAIN</span><span class="p">,</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">bounce_gfp</span> <span class="o">|</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">buf</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ata_dev_err</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;drain buffer allocation failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">blk_queue_dma_drain</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">atapi_drain_needed</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">ATAPI_MAX_DRAIN</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">sdev</span><span class="o">-&gt;</span><span class="n">sector_size</span> <span class="o">=</span> <span class="n">ata_id_logical_sector_size</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">);</span>
		<span class="n">sdev</span><span class="o">-&gt;</span><span class="n">manage_start_stop</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * ata_pio_sectors() expects buffer for each sector to not cross</span>
<span class="cm">	 * page boundary.  Enforce it by requiring buffers to be sector</span>
<span class="cm">	 * aligned, which works iff sector_size is not larger than</span>
<span class="cm">	 * PAGE_SIZE.  ATAPI devices also need the alignment as</span>
<span class="cm">	 * IDENTIFY_PACKET is executed as ATA_PROT_PIO.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">sector_size</span> <span class="o">&gt;</span> <span class="n">PAGE_SIZE</span><span class="p">)</span>
		<span class="n">ata_dev_warn</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span>
			<span class="s">&quot;sector_size=%u &gt; PAGE_SIZE, PIO may malfunction</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">sdev</span><span class="o">-&gt;</span><span class="n">sector_size</span><span class="p">);</span>

	<span class="n">blk_queue_update_dma_alignment</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">sdev</span><span class="o">-&gt;</span><span class="n">sector_size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">ATA_DFLAG_AN</span><span class="p">)</span>
		<span class="n">set_bit</span><span class="p">(</span><span class="n">SDEV_EVT_MEDIA_CHANGE</span><span class="p">,</span> <span class="n">sdev</span><span class="o">-&gt;</span><span class="n">supported_events</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">ATA_DFLAG_NCQ</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">depth</span><span class="p">;</span>

		<span class="n">depth</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">can_queue</span><span class="p">,</span> <span class="n">ata_id_queue_depth</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">));</span>
		<span class="n">depth</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">ATA_MAX_QUEUE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">depth</span><span class="p">);</span>
		<span class="n">scsi_adjust_queue_depth</span><span class="p">(</span><span class="n">sdev</span><span class="p">,</span> <span class="n">MSG_SIMPLE_TAG</span><span class="p">,</span> <span class="n">depth</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">blk_queue_flush_queueable</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>

	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">sdev</span> <span class="o">=</span> <span class="n">sdev</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	ata_scsi_slave_config - Set SCSI device attributes</span>
<span class="cm"> *	@sdev: SCSI device to examine</span>
<span class="cm"> *</span>
<span class="cm"> *	This is called before we actually start reading</span>
<span class="cm"> *	and writing to the device, to configure certain</span>
<span class="cm"> *	SCSI mid-layer behaviors.</span>
<span class="cm"> *</span>
<span class="cm"> *	LOCKING:</span>
<span class="cm"> *	Defined by SCSI layer.  We don&#39;t really care.</span>
<span class="cm"> */</span>

<span class="kt">int</span> <span class="nf">ata_scsi_slave_config</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="n">sdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span> <span class="o">=</span> <span class="n">ata_shost_to_port</span><span class="p">(</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">ata_device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">__ata_scsi_find_dev</span><span class="p">(</span><span class="n">ap</span><span class="p">,</span> <span class="n">sdev</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">ata_scsi_sdev_config</span><span class="p">(</span><span class="n">sdev</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="p">)</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">ata_scsi_dev_config</span><span class="p">(</span><span class="n">sdev</span><span class="p">,</span> <span class="n">dev</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	ata_scsi_slave_destroy - SCSI device is about to be destroyed</span>
<span class="cm"> *	@sdev: SCSI device to be destroyed</span>
<span class="cm"> *</span>
<span class="cm"> *	@sdev is about to be destroyed for hot/warm unplugging.  If</span>
<span class="cm"> *	this unplugging was initiated by libata as indicated by NULL</span>
<span class="cm"> *	dev-&gt;sdev, this function doesn&#39;t have to do anything.</span>
<span class="cm"> *	Otherwise, SCSI layer initiated warm-unplug is in progress.</span>
<span class="cm"> *	Clear dev-&gt;sdev, schedule the device for ATA detach and invoke</span>
<span class="cm"> *	EH.</span>
<span class="cm"> *</span>
<span class="cm"> *	LOCKING:</span>
<span class="cm"> *	Defined by SCSI layer.  We don&#39;t really care.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">ata_scsi_slave_destroy</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="n">sdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span> <span class="o">=</span> <span class="n">ata_shost_to_port</span><span class="p">(</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">q</span> <span class="o">=</span> <span class="n">sdev</span><span class="o">-&gt;</span><span class="n">request_queue</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ata_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">error_handler</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">dev</span> <span class="o">=</span> <span class="n">__ata_scsi_find_dev</span><span class="p">(</span><span class="n">ap</span><span class="p">,</span> <span class="n">sdev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span> <span class="o">&amp;&amp;</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">sdev</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* SCSI device already in CANCEL state, no need to offline it */</span>
		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">sdev</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">ATA_DFLAG_DETACH</span><span class="p">;</span>
		<span class="n">ata_port_schedule_eh</span><span class="p">(</span><span class="n">ap</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">kfree</span><span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">dma_drain_buffer</span><span class="p">);</span>
	<span class="n">q</span><span class="o">-&gt;</span><span class="n">dma_drain_buffer</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">q</span><span class="o">-&gt;</span><span class="n">dma_drain_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	__ata_change_queue_depth - helper for ata_scsi_change_queue_depth</span>
<span class="cm"> *	@ap: ATA port to which the device change the queue depth</span>
<span class="cm"> *	@sdev: SCSI device to configure queue depth for</span>
<span class="cm"> *	@queue_depth: new queue depth</span>
<span class="cm"> *	@reason: calling context</span>
<span class="cm"> *</span>
<span class="cm"> *	libsas and libata have different approaches for associating a sdev to</span>
<span class="cm"> *	its ata_port.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">__ata_change_queue_depth</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span><span class="p">,</span> <span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="n">sdev</span><span class="p">,</span>
			     <span class="kt">int</span> <span class="n">queue_depth</span><span class="p">,</span> <span class="kt">int</span> <span class="n">reason</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ata_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">reason</span> <span class="o">!=</span> <span class="n">SCSI_QDEPTH_DEFAULT</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EOPNOTSUPP</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">queue_depth</span> <span class="o">&lt;</span> <span class="mi">1</span> <span class="o">||</span> <span class="n">queue_depth</span> <span class="o">==</span> <span class="n">sdev</span><span class="o">-&gt;</span><span class="n">queue_depth</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">sdev</span><span class="o">-&gt;</span><span class="n">queue_depth</span><span class="p">;</span>

	<span class="n">dev</span> <span class="o">=</span> <span class="n">ata_scsi_find_dev</span><span class="p">(</span><span class="n">ap</span><span class="p">,</span> <span class="n">sdev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dev</span> <span class="o">||</span> <span class="o">!</span><span class="n">ata_dev_enabled</span><span class="p">(</span><span class="n">dev</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">sdev</span><span class="o">-&gt;</span><span class="n">queue_depth</span><span class="p">;</span>

	<span class="cm">/* NCQ enabled? */</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">ATA_DFLAG_NCQ_OFF</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">queue_depth</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">||</span> <span class="o">!</span><span class="n">ata_ncq_enabled</span><span class="p">(</span><span class="n">dev</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">ATA_DFLAG_NCQ_OFF</span><span class="p">;</span>
		<span class="n">queue_depth</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="cm">/* limit and apply queue depth */</span>
	<span class="n">queue_depth</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">queue_depth</span><span class="p">,</span> <span class="n">sdev</span><span class="o">-&gt;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">can_queue</span><span class="p">);</span>
	<span class="n">queue_depth</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">queue_depth</span><span class="p">,</span> <span class="n">ata_id_queue_depth</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">));</span>
	<span class="n">queue_depth</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">queue_depth</span><span class="p">,</span> <span class="n">ATA_MAX_QUEUE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">queue_depth</span> <span class="o">==</span> <span class="n">queue_depth</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">scsi_adjust_queue_depth</span><span class="p">(</span><span class="n">sdev</span><span class="p">,</span> <span class="n">MSG_SIMPLE_TAG</span><span class="p">,</span> <span class="n">queue_depth</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">queue_depth</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	ata_scsi_change_queue_depth - SCSI callback for queue depth config</span>
<span class="cm"> *	@sdev: SCSI device to configure queue depth for</span>
<span class="cm"> *	@queue_depth: new queue depth</span>
<span class="cm"> *	@reason: calling context</span>
<span class="cm"> *</span>
<span class="cm"> *	This is libata standard hostt-&gt;change_queue_depth callback.</span>
<span class="cm"> *	SCSI will call into this callback when user tries to set queue</span>
<span class="cm"> *	depth via sysfs.</span>
<span class="cm"> *</span>
<span class="cm"> *	LOCKING:</span>
<span class="cm"> *	SCSI layer (we don&#39;t care)</span>
<span class="cm"> *</span>
<span class="cm"> *	RETURNS:</span>
<span class="cm"> *	Newly configured queue depth.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">ata_scsi_change_queue_depth</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="n">sdev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">queue_depth</span><span class="p">,</span>
				<span class="kt">int</span> <span class="n">reason</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span> <span class="o">=</span> <span class="n">ata_shost_to_port</span><span class="p">(</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">__ata_change_queue_depth</span><span class="p">(</span><span class="n">ap</span><span class="p">,</span> <span class="n">sdev</span><span class="p">,</span> <span class="n">queue_depth</span><span class="p">,</span> <span class="n">reason</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	ata_scsi_start_stop_xlat - Translate SCSI START STOP UNIT command</span>
<span class="cm"> *	@qc: Storage for translated ATA taskfile</span>
<span class="cm"> *</span>
<span class="cm"> *	Sets up an ATA taskfile to issue STANDBY (to stop) or READ VERIFY</span>
<span class="cm"> *	(to start). Perhaps these commands should be preceded by</span>
<span class="cm"> *	CHECK POWER MODE to see what power mode the device is already in.</span>
<span class="cm"> *	[See SAT revision 5 at www.t10.org]</span>
<span class="cm"> *</span>
<span class="cm"> *	LOCKING:</span>
<span class="cm"> *	spin_lock_irqsave(host lock)</span>
<span class="cm"> *</span>
<span class="cm"> *	RETURNS:</span>
<span class="cm"> *	Zero on success, non-zero on error.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">ata_scsi_start_stop_xlat</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_queued_cmd</span> <span class="o">*</span><span class="n">qc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="n">scmd</span> <span class="o">=</span> <span class="n">qc</span><span class="o">-&gt;</span><span class="n">scsicmd</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ata_taskfile</span> <span class="o">*</span><span class="n">tf</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">qc</span><span class="o">-&gt;</span><span class="n">tf</span><span class="p">;</span>
	<span class="k">const</span> <span class="n">u8</span> <span class="o">*</span><span class="n">cdb</span> <span class="o">=</span> <span class="n">scmd</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">scmd</span><span class="o">-&gt;</span><span class="n">cmd_len</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">invalid_fld</span><span class="p">;</span>

	<span class="n">tf</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">ATA_TFLAG_DEVICE</span> <span class="o">|</span> <span class="n">ATA_TFLAG_ISADDR</span><span class="p">;</span>
	<span class="n">tf</span><span class="o">-&gt;</span><span class="n">protocol</span> <span class="o">=</span> <span class="n">ATA_PROT_NODATA</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cdb</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0x1</span><span class="p">)</span> <span class="p">{</span>
		<span class="p">;</span>	<span class="cm">/* ignore IMMED bit, violates sat-r05 */</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cdb</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0x2</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">invalid_fld</span><span class="p">;</span>       <span class="cm">/* LOEJ bit set not supported */</span>
	<span class="k">if</span> <span class="p">(((</span><span class="n">cdb</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">&gt;&gt;</span> <span class="mi">4</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xf</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">invalid_fld</span><span class="p">;</span>       <span class="cm">/* power conditions not supported */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cdb</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0x1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">tf</span><span class="o">-&gt;</span><span class="n">nsect</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>	<span class="cm">/* 1 sector, lba=0 */</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">qc</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">ATA_DFLAG_LBA</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">tf</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">ATA_TFLAG_LBA</span><span class="p">;</span>

			<span class="n">tf</span><span class="o">-&gt;</span><span class="n">lbah</span> <span class="o">=</span> <span class="mh">0x0</span><span class="p">;</span>
			<span class="n">tf</span><span class="o">-&gt;</span><span class="n">lbam</span> <span class="o">=</span> <span class="mh">0x0</span><span class="p">;</span>
			<span class="n">tf</span><span class="o">-&gt;</span><span class="n">lbal</span> <span class="o">=</span> <span class="mh">0x0</span><span class="p">;</span>
			<span class="n">tf</span><span class="o">-&gt;</span><span class="n">device</span> <span class="o">|=</span> <span class="n">ATA_LBA</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/* CHS */</span>
			<span class="n">tf</span><span class="o">-&gt;</span><span class="n">lbal</span> <span class="o">=</span> <span class="mh">0x1</span><span class="p">;</span> <span class="cm">/* sect */</span>
			<span class="n">tf</span><span class="o">-&gt;</span><span class="n">lbam</span> <span class="o">=</span> <span class="mh">0x0</span><span class="p">;</span> <span class="cm">/* cyl low */</span>
			<span class="n">tf</span><span class="o">-&gt;</span><span class="n">lbah</span> <span class="o">=</span> <span class="mh">0x0</span><span class="p">;</span> <span class="cm">/* cyl high */</span>
		<span class="p">}</span>

		<span class="n">tf</span><span class="o">-&gt;</span><span class="n">command</span> <span class="o">=</span> <span class="n">ATA_CMD_VERIFY</span><span class="p">;</span>	<span class="cm">/* READ VERIFY */</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* Some odd clown BIOSen issue spindown on power off (ACPI S4</span>
<span class="cm">		 * or S5) causing some drives to spin up and down again.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">qc</span><span class="o">-&gt;</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">ATA_FLAG_NO_POWEROFF_SPINDOWN</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="n">system_state</span> <span class="o">==</span> <span class="n">SYSTEM_POWER_OFF</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">skip</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">((</span><span class="n">qc</span><span class="o">-&gt;</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">ATA_FLAG_NO_HIBERNATE_SPINDOWN</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		     <span class="n">system_entering_hibernation</span><span class="p">())</span>
			<span class="k">goto</span> <span class="n">skip</span><span class="p">;</span>

		<span class="cm">/* Issue ATA STANDBY IMMEDIATE command */</span>
		<span class="n">tf</span><span class="o">-&gt;</span><span class="n">command</span> <span class="o">=</span> <span class="n">ATA_CMD_STANDBYNOW1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Standby and Idle condition timers could be implemented but that</span>
<span class="cm">	 * would require libata to implement the Power condition mode page</span>
<span class="cm">	 * and allow the user to change it. Changing mode pages requires</span>
<span class="cm">	 * MODE SELECT to be implemented.</span>
<span class="cm">	 */</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

 <span class="nl">invalid_fld:</span>
	<span class="n">ata_scsi_set_sense</span><span class="p">(</span><span class="n">scmd</span><span class="p">,</span> <span class="n">ILLEGAL_REQUEST</span><span class="p">,</span> <span class="mh">0x24</span><span class="p">,</span> <span class="mh">0x0</span><span class="p">);</span>
	<span class="cm">/* &quot;Invalid field in cbd&quot; */</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
 <span class="nl">skip:</span>
	<span class="n">scmd</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">=</span> <span class="n">SAM_STAT_GOOD</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/**</span>
<span class="cm"> *	ata_scsi_flush_xlat - Translate SCSI SYNCHRONIZE CACHE command</span>
<span class="cm"> *	@qc: Storage for translated ATA taskfile</span>
<span class="cm"> *</span>
<span class="cm"> *	Sets up an ATA taskfile to issue FLUSH CACHE or</span>
<span class="cm"> *	FLUSH CACHE EXT.</span>
<span class="cm"> *</span>
<span class="cm"> *	LOCKING:</span>
<span class="cm"> *	spin_lock_irqsave(host lock)</span>
<span class="cm"> *</span>
<span class="cm"> *	RETURNS:</span>
<span class="cm"> *	Zero on success, non-zero on error.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">ata_scsi_flush_xlat</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_queued_cmd</span> <span class="o">*</span><span class="n">qc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ata_taskfile</span> <span class="o">*</span><span class="n">tf</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">qc</span><span class="o">-&gt;</span><span class="n">tf</span><span class="p">;</span>

	<span class="n">tf</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">ATA_TFLAG_DEVICE</span><span class="p">;</span>
	<span class="n">tf</span><span class="o">-&gt;</span><span class="n">protocol</span> <span class="o">=</span> <span class="n">ATA_PROT_NODATA</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">qc</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">ATA_DFLAG_FLUSH_EXT</span><span class="p">)</span>
		<span class="n">tf</span><span class="o">-&gt;</span><span class="n">command</span> <span class="o">=</span> <span class="n">ATA_CMD_FLUSH_EXT</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">tf</span><span class="o">-&gt;</span><span class="n">command</span> <span class="o">=</span> <span class="n">ATA_CMD_FLUSH</span><span class="p">;</span>

	<span class="cm">/* flush is critical for IO integrity, consider it an IO command */</span>
	<span class="n">qc</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">ATA_QCFLAG_IO</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	scsi_6_lba_len - Get LBA and transfer length</span>
<span class="cm"> *	@cdb: SCSI command to translate</span>
<span class="cm"> *</span>
<span class="cm"> *	Calculate LBA and transfer length for 6-byte commands.</span>
<span class="cm"> *</span>
<span class="cm"> *	RETURNS:</span>
<span class="cm"> *	@plba: the LBA</span>
<span class="cm"> *	@plen: the transfer length</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">scsi_6_lba_len</span><span class="p">(</span><span class="k">const</span> <span class="n">u8</span> <span class="o">*</span><span class="n">cdb</span><span class="p">,</span> <span class="n">u64</span> <span class="o">*</span><span class="n">plba</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">plen</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u64</span> <span class="n">lba</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">len</span><span class="p">;</span>

	<span class="n">VPRINTK</span><span class="p">(</span><span class="s">&quot;six-byte command</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="n">lba</span> <span class="o">|=</span> <span class="p">((</span><span class="n">u64</span><span class="p">)(</span><span class="n">cdb</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0x1f</span><span class="p">))</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">;</span>
	<span class="n">lba</span> <span class="o">|=</span> <span class="p">((</span><span class="n">u64</span><span class="p">)</span><span class="n">cdb</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">;</span>
	<span class="n">lba</span> <span class="o">|=</span> <span class="p">((</span><span class="n">u64</span><span class="p">)</span><span class="n">cdb</span><span class="p">[</span><span class="mi">3</span><span class="p">]);</span>

	<span class="n">len</span> <span class="o">=</span> <span class="n">cdb</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>

	<span class="o">*</span><span class="n">plba</span> <span class="o">=</span> <span class="n">lba</span><span class="p">;</span>
	<span class="o">*</span><span class="n">plen</span> <span class="o">=</span> <span class="n">len</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	scsi_10_lba_len - Get LBA and transfer length</span>
<span class="cm"> *	@cdb: SCSI command to translate</span>
<span class="cm"> *</span>
<span class="cm"> *	Calculate LBA and transfer length for 10-byte commands.</span>
<span class="cm"> *</span>
<span class="cm"> *	RETURNS:</span>
<span class="cm"> *	@plba: the LBA</span>
<span class="cm"> *	@plen: the transfer length</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">scsi_10_lba_len</span><span class="p">(</span><span class="k">const</span> <span class="n">u8</span> <span class="o">*</span><span class="n">cdb</span><span class="p">,</span> <span class="n">u64</span> <span class="o">*</span><span class="n">plba</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">plen</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u64</span> <span class="n">lba</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">VPRINTK</span><span class="p">(</span><span class="s">&quot;ten-byte command</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="n">lba</span> <span class="o">|=</span> <span class="p">((</span><span class="n">u64</span><span class="p">)</span><span class="n">cdb</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span> <span class="o">&lt;&lt;</span> <span class="mi">24</span><span class="p">;</span>
	<span class="n">lba</span> <span class="o">|=</span> <span class="p">((</span><span class="n">u64</span><span class="p">)</span><span class="n">cdb</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">;</span>
	<span class="n">lba</span> <span class="o">|=</span> <span class="p">((</span><span class="n">u64</span><span class="p">)</span><span class="n">cdb</span><span class="p">[</span><span class="mi">4</span><span class="p">])</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">;</span>
	<span class="n">lba</span> <span class="o">|=</span> <span class="p">((</span><span class="n">u64</span><span class="p">)</span><span class="n">cdb</span><span class="p">[</span><span class="mi">5</span><span class="p">]);</span>

	<span class="n">len</span> <span class="o">|=</span> <span class="p">((</span><span class="n">u32</span><span class="p">)</span><span class="n">cdb</span><span class="p">[</span><span class="mi">7</span><span class="p">])</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">;</span>
	<span class="n">len</span> <span class="o">|=</span> <span class="p">((</span><span class="n">u32</span><span class="p">)</span><span class="n">cdb</span><span class="p">[</span><span class="mi">8</span><span class="p">]);</span>

	<span class="o">*</span><span class="n">plba</span> <span class="o">=</span> <span class="n">lba</span><span class="p">;</span>
	<span class="o">*</span><span class="n">plen</span> <span class="o">=</span> <span class="n">len</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	scsi_16_lba_len - Get LBA and transfer length</span>
<span class="cm"> *	@cdb: SCSI command to translate</span>
<span class="cm"> *</span>
<span class="cm"> *	Calculate LBA and transfer length for 16-byte commands.</span>
<span class="cm"> *</span>
<span class="cm"> *	RETURNS:</span>
<span class="cm"> *	@plba: the LBA</span>
<span class="cm"> *	@plen: the transfer length</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">scsi_16_lba_len</span><span class="p">(</span><span class="k">const</span> <span class="n">u8</span> <span class="o">*</span><span class="n">cdb</span><span class="p">,</span> <span class="n">u64</span> <span class="o">*</span><span class="n">plba</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">plen</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u64</span> <span class="n">lba</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">VPRINTK</span><span class="p">(</span><span class="s">&quot;sixteen-byte command</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="n">lba</span> <span class="o">|=</span> <span class="p">((</span><span class="n">u64</span><span class="p">)</span><span class="n">cdb</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span> <span class="o">&lt;&lt;</span> <span class="mi">56</span><span class="p">;</span>
	<span class="n">lba</span> <span class="o">|=</span> <span class="p">((</span><span class="n">u64</span><span class="p">)</span><span class="n">cdb</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span> <span class="o">&lt;&lt;</span> <span class="mi">48</span><span class="p">;</span>
	<span class="n">lba</span> <span class="o">|=</span> <span class="p">((</span><span class="n">u64</span><span class="p">)</span><span class="n">cdb</span><span class="p">[</span><span class="mi">4</span><span class="p">])</span> <span class="o">&lt;&lt;</span> <span class="mi">40</span><span class="p">;</span>
	<span class="n">lba</span> <span class="o">|=</span> <span class="p">((</span><span class="n">u64</span><span class="p">)</span><span class="n">cdb</span><span class="p">[</span><span class="mi">5</span><span class="p">])</span> <span class="o">&lt;&lt;</span> <span class="mi">32</span><span class="p">;</span>
	<span class="n">lba</span> <span class="o">|=</span> <span class="p">((</span><span class="n">u64</span><span class="p">)</span><span class="n">cdb</span><span class="p">[</span><span class="mi">6</span><span class="p">])</span> <span class="o">&lt;&lt;</span> <span class="mi">24</span><span class="p">;</span>
	<span class="n">lba</span> <span class="o">|=</span> <span class="p">((</span><span class="n">u64</span><span class="p">)</span><span class="n">cdb</span><span class="p">[</span><span class="mi">7</span><span class="p">])</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">;</span>
	<span class="n">lba</span> <span class="o">|=</span> <span class="p">((</span><span class="n">u64</span><span class="p">)</span><span class="n">cdb</span><span class="p">[</span><span class="mi">8</span><span class="p">])</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">;</span>
	<span class="n">lba</span> <span class="o">|=</span> <span class="p">((</span><span class="n">u64</span><span class="p">)</span><span class="n">cdb</span><span class="p">[</span><span class="mi">9</span><span class="p">]);</span>

	<span class="n">len</span> <span class="o">|=</span> <span class="p">((</span><span class="n">u32</span><span class="p">)</span><span class="n">cdb</span><span class="p">[</span><span class="mi">10</span><span class="p">])</span> <span class="o">&lt;&lt;</span> <span class="mi">24</span><span class="p">;</span>
	<span class="n">len</span> <span class="o">|=</span> <span class="p">((</span><span class="n">u32</span><span class="p">)</span><span class="n">cdb</span><span class="p">[</span><span class="mi">11</span><span class="p">])</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">;</span>
	<span class="n">len</span> <span class="o">|=</span> <span class="p">((</span><span class="n">u32</span><span class="p">)</span><span class="n">cdb</span><span class="p">[</span><span class="mi">12</span><span class="p">])</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">;</span>
	<span class="n">len</span> <span class="o">|=</span> <span class="p">((</span><span class="n">u32</span><span class="p">)</span><span class="n">cdb</span><span class="p">[</span><span class="mi">13</span><span class="p">]);</span>

	<span class="o">*</span><span class="n">plba</span> <span class="o">=</span> <span class="n">lba</span><span class="p">;</span>
	<span class="o">*</span><span class="n">plen</span> <span class="o">=</span> <span class="n">len</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	ata_scsi_verify_xlat - Translate SCSI VERIFY command into an ATA one</span>
<span class="cm"> *	@qc: Storage for translated ATA taskfile</span>
<span class="cm"> *</span>
<span class="cm"> *	Converts SCSI VERIFY command to an ATA READ VERIFY command.</span>
<span class="cm"> *</span>
<span class="cm"> *	LOCKING:</span>
<span class="cm"> *	spin_lock_irqsave(host lock)</span>
<span class="cm"> *</span>
<span class="cm"> *	RETURNS:</span>
<span class="cm"> *	Zero on success, non-zero on error.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">ata_scsi_verify_xlat</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_queued_cmd</span> <span class="o">*</span><span class="n">qc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="n">scmd</span> <span class="o">=</span> <span class="n">qc</span><span class="o">-&gt;</span><span class="n">scsicmd</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ata_taskfile</span> <span class="o">*</span><span class="n">tf</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">qc</span><span class="o">-&gt;</span><span class="n">tf</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ata_device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">qc</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">dev_sectors</span> <span class="o">=</span> <span class="n">qc</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">n_sectors</span><span class="p">;</span>
	<span class="k">const</span> <span class="n">u8</span> <span class="o">*</span><span class="n">cdb</span> <span class="o">=</span> <span class="n">scmd</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">block</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">n_block</span><span class="p">;</span>

	<span class="n">tf</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">ATA_TFLAG_ISADDR</span> <span class="o">|</span> <span class="n">ATA_TFLAG_DEVICE</span><span class="p">;</span>
	<span class="n">tf</span><span class="o">-&gt;</span><span class="n">protocol</span> <span class="o">=</span> <span class="n">ATA_PROT_NODATA</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cdb</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">VERIFY</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">scmd</span><span class="o">-&gt;</span><span class="n">cmd_len</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">invalid_fld</span><span class="p">;</span>
		<span class="n">scsi_10_lba_len</span><span class="p">(</span><span class="n">cdb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">block</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">n_block</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">cdb</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">VERIFY_16</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">scmd</span><span class="o">-&gt;</span><span class="n">cmd_len</span> <span class="o">&lt;</span> <span class="mi">16</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">invalid_fld</span><span class="p">;</span>
		<span class="n">scsi_16_lba_len</span><span class="p">(</span><span class="n">cdb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">block</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">n_block</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="k">goto</span> <span class="n">invalid_fld</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">n_block</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">nothing_to_do</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">block</span> <span class="o">&gt;=</span> <span class="n">dev_sectors</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_of_range</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">block</span> <span class="o">+</span> <span class="n">n_block</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">dev_sectors</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_of_range</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">ATA_DFLAG_LBA</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">tf</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">ATA_TFLAG_LBA</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">lba_28_ok</span><span class="p">(</span><span class="n">block</span><span class="p">,</span> <span class="n">n_block</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/* use LBA28 */</span>
			<span class="n">tf</span><span class="o">-&gt;</span><span class="n">command</span> <span class="o">=</span> <span class="n">ATA_CMD_VERIFY</span><span class="p">;</span>
			<span class="n">tf</span><span class="o">-&gt;</span><span class="n">device</span> <span class="o">|=</span> <span class="p">(</span><span class="n">block</span> <span class="o">&gt;&gt;</span> <span class="mi">24</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xf</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">lba_48_ok</span><span class="p">(</span><span class="n">block</span><span class="p">,</span> <span class="n">n_block</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">ATA_DFLAG_LBA48</span><span class="p">))</span>
				<span class="k">goto</span> <span class="n">out_of_range</span><span class="p">;</span>

			<span class="cm">/* use LBA48 */</span>
			<span class="n">tf</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">ATA_TFLAG_LBA48</span><span class="p">;</span>
			<span class="n">tf</span><span class="o">-&gt;</span><span class="n">command</span> <span class="o">=</span> <span class="n">ATA_CMD_VERIFY_EXT</span><span class="p">;</span>

			<span class="n">tf</span><span class="o">-&gt;</span><span class="n">hob_nsect</span> <span class="o">=</span> <span class="p">(</span><span class="n">n_block</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">;</span>

			<span class="n">tf</span><span class="o">-&gt;</span><span class="n">hob_lbah</span> <span class="o">=</span> <span class="p">(</span><span class="n">block</span> <span class="o">&gt;&gt;</span> <span class="mi">40</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">;</span>
			<span class="n">tf</span><span class="o">-&gt;</span><span class="n">hob_lbam</span> <span class="o">=</span> <span class="p">(</span><span class="n">block</span> <span class="o">&gt;&gt;</span> <span class="mi">32</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">;</span>
			<span class="n">tf</span><span class="o">-&gt;</span><span class="n">hob_lbal</span> <span class="o">=</span> <span class="p">(</span><span class="n">block</span> <span class="o">&gt;&gt;</span> <span class="mi">24</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="cm">/* request too large even for LBA48 */</span>
			<span class="k">goto</span> <span class="n">out_of_range</span><span class="p">;</span>

		<span class="n">tf</span><span class="o">-&gt;</span><span class="n">nsect</span> <span class="o">=</span> <span class="n">n_block</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">;</span>

		<span class="n">tf</span><span class="o">-&gt;</span><span class="n">lbah</span> <span class="o">=</span> <span class="p">(</span><span class="n">block</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">;</span>
		<span class="n">tf</span><span class="o">-&gt;</span><span class="n">lbam</span> <span class="o">=</span> <span class="p">(</span><span class="n">block</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">;</span>
		<span class="n">tf</span><span class="o">-&gt;</span><span class="n">lbal</span> <span class="o">=</span> <span class="n">block</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">;</span>

		<span class="n">tf</span><span class="o">-&gt;</span><span class="n">device</span> <span class="o">|=</span> <span class="n">ATA_LBA</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* CHS */</span>
		<span class="n">u32</span> <span class="n">sect</span><span class="p">,</span> <span class="n">head</span><span class="p">,</span> <span class="n">cyl</span><span class="p">,</span> <span class="n">track</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">lba_28_ok</span><span class="p">(</span><span class="n">block</span><span class="p">,</span> <span class="n">n_block</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">out_of_range</span><span class="p">;</span>

		<span class="cm">/* Convert LBA to CHS */</span>
		<span class="n">track</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span><span class="n">block</span> <span class="o">/</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">sectors</span><span class="p">;</span>
		<span class="n">cyl</span>   <span class="o">=</span> <span class="n">track</span> <span class="o">/</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">heads</span><span class="p">;</span>
		<span class="n">head</span>  <span class="o">=</span> <span class="n">track</span> <span class="o">%</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">heads</span><span class="p">;</span>
		<span class="n">sect</span>  <span class="o">=</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span><span class="n">block</span> <span class="o">%</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">sectors</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>

		<span class="n">DPRINTK</span><span class="p">(</span><span class="s">&quot;block %u track %u cyl %u head %u sect %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="p">(</span><span class="n">u32</span><span class="p">)</span><span class="n">block</span><span class="p">,</span> <span class="n">track</span><span class="p">,</span> <span class="n">cyl</span><span class="p">,</span> <span class="n">head</span><span class="p">,</span> <span class="n">sect</span><span class="p">);</span>

		<span class="cm">/* Check whether the converted CHS can fit.</span>
<span class="cm">		   Cylinder: 0-65535</span>
<span class="cm">		   Head: 0-15</span>
<span class="cm">		   Sector: 1-255*/</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">cyl</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">head</span> <span class="o">&gt;&gt;</span> <span class="mi">4</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">sect</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="o">!</span><span class="n">sect</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">out_of_range</span><span class="p">;</span>

		<span class="n">tf</span><span class="o">-&gt;</span><span class="n">command</span> <span class="o">=</span> <span class="n">ATA_CMD_VERIFY</span><span class="p">;</span>
		<span class="n">tf</span><span class="o">-&gt;</span><span class="n">nsect</span> <span class="o">=</span> <span class="n">n_block</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">;</span> <span class="cm">/* Sector count 0 means 256 sectors */</span>
		<span class="n">tf</span><span class="o">-&gt;</span><span class="n">lbal</span> <span class="o">=</span> <span class="n">sect</span><span class="p">;</span>
		<span class="n">tf</span><span class="o">-&gt;</span><span class="n">lbam</span> <span class="o">=</span> <span class="n">cyl</span><span class="p">;</span>
		<span class="n">tf</span><span class="o">-&gt;</span><span class="n">lbah</span> <span class="o">=</span> <span class="n">cyl</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">;</span>
		<span class="n">tf</span><span class="o">-&gt;</span><span class="n">device</span> <span class="o">|=</span> <span class="n">head</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">invalid_fld:</span>
	<span class="n">ata_scsi_set_sense</span><span class="p">(</span><span class="n">scmd</span><span class="p">,</span> <span class="n">ILLEGAL_REQUEST</span><span class="p">,</span> <span class="mh">0x24</span><span class="p">,</span> <span class="mh">0x0</span><span class="p">);</span>
	<span class="cm">/* &quot;Invalid field in cbd&quot; */</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

<span class="nl">out_of_range:</span>
	<span class="n">ata_scsi_set_sense</span><span class="p">(</span><span class="n">scmd</span><span class="p">,</span> <span class="n">ILLEGAL_REQUEST</span><span class="p">,</span> <span class="mh">0x21</span><span class="p">,</span> <span class="mh">0x0</span><span class="p">);</span>
	<span class="cm">/* &quot;Logical Block Address out of range&quot; */</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

<span class="nl">nothing_to_do:</span>
	<span class="n">scmd</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">=</span> <span class="n">SAM_STAT_GOOD</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	ata_scsi_rw_xlat - Translate SCSI r/w command into an ATA one</span>
<span class="cm"> *	@qc: Storage for translated ATA taskfile</span>
<span class="cm"> *</span>
<span class="cm"> *	Converts any of six SCSI read/write commands into the</span>
<span class="cm"> *	ATA counterpart, including starting sector (LBA),</span>
<span class="cm"> *	sector count, and taking into account the device&#39;s LBA48</span>
<span class="cm"> *	support.</span>
<span class="cm"> *</span>
<span class="cm"> *	Commands %READ_6, %READ_10, %READ_16, %WRITE_6, %WRITE_10, and</span>
<span class="cm"> *	%WRITE_16 are currently supported.</span>
<span class="cm"> *</span>
<span class="cm"> *	LOCKING:</span>
<span class="cm"> *	spin_lock_irqsave(host lock)</span>
<span class="cm"> *</span>
<span class="cm"> *	RETURNS:</span>
<span class="cm"> *	Zero on success, non-zero on error.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">ata_scsi_rw_xlat</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_queued_cmd</span> <span class="o">*</span><span class="n">qc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="n">scmd</span> <span class="o">=</span> <span class="n">qc</span><span class="o">-&gt;</span><span class="n">scsicmd</span><span class="p">;</span>
	<span class="k">const</span> <span class="n">u8</span> <span class="o">*</span><span class="n">cdb</span> <span class="o">=</span> <span class="n">scmd</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">tf_flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">block</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">n_block</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cdb</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">WRITE_10</span> <span class="o">||</span> <span class="n">cdb</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">WRITE_6</span> <span class="o">||</span> <span class="n">cdb</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">WRITE_16</span><span class="p">)</span>
		<span class="n">tf_flags</span> <span class="o">|=</span> <span class="n">ATA_TFLAG_WRITE</span><span class="p">;</span>

	<span class="cm">/* Calculate the SCSI LBA, transfer length and FUA. */</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">cdb</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">READ_10</span>:
	<span class="k">case</span> <span class="n">WRITE_10</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">scmd</span><span class="o">-&gt;</span><span class="n">cmd_len</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">invalid_fld</span><span class="p">;</span>
		<span class="n">scsi_10_lba_len</span><span class="p">(</span><span class="n">cdb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">block</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">n_block</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">cdb</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">3</span><span class="p">)))</span>
			<span class="n">tf_flags</span> <span class="o">|=</span> <span class="n">ATA_TFLAG_FUA</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">READ_6</span>:
	<span class="k">case</span> <span class="n">WRITE_6</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">scmd</span><span class="o">-&gt;</span><span class="n">cmd_len</span> <span class="o">&lt;</span> <span class="mi">6</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">invalid_fld</span><span class="p">;</span>
		<span class="n">scsi_6_lba_len</span><span class="p">(</span><span class="n">cdb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">block</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">n_block</span><span class="p">);</span>

		<span class="cm">/* for 6-byte r/w commands, transfer length 0</span>
<span class="cm">		 * means 256 blocks of data, not 0 block.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">n_block</span><span class="p">)</span>
			<span class="n">n_block</span> <span class="o">=</span> <span class="mi">256</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">READ_16</span>:
	<span class="k">case</span> <span class="n">WRITE_16</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">scmd</span><span class="o">-&gt;</span><span class="n">cmd_len</span> <span class="o">&lt;</span> <span class="mi">16</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">invalid_fld</span><span class="p">;</span>
		<span class="n">scsi_16_lba_len</span><span class="p">(</span><span class="n">cdb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">block</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">n_block</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">cdb</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">3</span><span class="p">)))</span>
			<span class="n">tf_flags</span> <span class="o">|=</span> <span class="n">ATA_TFLAG_FUA</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">DPRINTK</span><span class="p">(</span><span class="s">&quot;no-byte command</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">invalid_fld</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Check and compose ATA command */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">n_block</span><span class="p">)</span>
		<span class="cm">/* For 10-byte and 16-byte SCSI R/W commands, transfer</span>
<span class="cm">		 * length 0 means transfer 0 block of data.</span>
<span class="cm">		 * However, for ATA R/W commands, sector count 0 means</span>
<span class="cm">		 * 256 or 65536 sectors, not 0 sectors as in SCSI.</span>
<span class="cm">		 *</span>
<span class="cm">		 * WARNING: one or two older ATA drives treat 0 as 0...</span>
<span class="cm">		 */</span>
		<span class="k">goto</span> <span class="n">nothing_to_do</span><span class="p">;</span>

	<span class="n">qc</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">ATA_QCFLAG_IO</span><span class="p">;</span>
	<span class="n">qc</span><span class="o">-&gt;</span><span class="n">nbytes</span> <span class="o">=</span> <span class="n">n_block</span> <span class="o">*</span> <span class="n">scmd</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">sector_size</span><span class="p">;</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">ata_build_rw_tf</span><span class="p">(</span><span class="o">&amp;</span><span class="n">qc</span><span class="o">-&gt;</span><span class="n">tf</span><span class="p">,</span> <span class="n">qc</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">block</span><span class="p">,</span> <span class="n">n_block</span><span class="p">,</span> <span class="n">tf_flags</span><span class="p">,</span>
			     <span class="n">qc</span><span class="o">-&gt;</span><span class="n">tag</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">rc</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">==</span> <span class="o">-</span><span class="n">ERANGE</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_of_range</span><span class="p">;</span>
	<span class="cm">/* treat all other errors as -EINVAL, fall through */</span>
<span class="nl">invalid_fld:</span>
	<span class="n">ata_scsi_set_sense</span><span class="p">(</span><span class="n">scmd</span><span class="p">,</span> <span class="n">ILLEGAL_REQUEST</span><span class="p">,</span> <span class="mh">0x24</span><span class="p">,</span> <span class="mh">0x0</span><span class="p">);</span>
	<span class="cm">/* &quot;Invalid field in cbd&quot; */</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

<span class="nl">out_of_range:</span>
	<span class="n">ata_scsi_set_sense</span><span class="p">(</span><span class="n">scmd</span><span class="p">,</span> <span class="n">ILLEGAL_REQUEST</span><span class="p">,</span> <span class="mh">0x21</span><span class="p">,</span> <span class="mh">0x0</span><span class="p">);</span>
	<span class="cm">/* &quot;Logical Block Address out of range&quot; */</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

<span class="nl">nothing_to_do:</span>
	<span class="n">scmd</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">=</span> <span class="n">SAM_STAT_GOOD</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">ata_scsi_qc_complete</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_queued_cmd</span> <span class="o">*</span><span class="n">qc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span> <span class="o">=</span> <span class="n">qc</span><span class="o">-&gt;</span><span class="n">ap</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="n">cmd</span> <span class="o">=</span> <span class="n">qc</span><span class="o">-&gt;</span><span class="n">scsicmd</span><span class="p">;</span>
	<span class="n">u8</span> <span class="o">*</span><span class="n">cdb</span> <span class="o">=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">need_sense</span> <span class="o">=</span> <span class="p">(</span><span class="n">qc</span><span class="o">-&gt;</span><span class="n">err_mask</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">);</span>

	<span class="cm">/* For ATA pass thru (SAT) commands, generate a sense block if</span>
<span class="cm">	 * user mandated it or if there&#39;s an error.  Note that if we</span>
<span class="cm">	 * generate because the user forced us to, a check condition</span>
<span class="cm">	 * is generated and the ATA register values are returned</span>
<span class="cm">	 * whether the command completed successfully or not. If there</span>
<span class="cm">	 * was no error, SK, ASC and ASCQ will all be zero.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(((</span><span class="n">cdb</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">ATA_16</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">cdb</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">ATA_12</span><span class="p">))</span> <span class="o">&amp;&amp;</span>
	    <span class="p">((</span><span class="n">cdb</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0x20</span><span class="p">)</span> <span class="o">||</span> <span class="n">need_sense</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ata_gen_passthru_sense</span><span class="p">(</span><span class="n">qc</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">need_sense</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">=</span> <span class="n">SAM_STAT_GOOD</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/* TODO: decide which descriptor format to use</span>
<span class="cm">			 * for 48b LBA devices and call that here</span>
<span class="cm">			 * instead of the fixed desc, which is only</span>
<span class="cm">			 * good for smaller LBA (and maybe CHS?)</span>
<span class="cm">			 * devices.</span>
<span class="cm">			 */</span>
			<span class="n">ata_gen_ata_sense</span><span class="p">(</span><span class="n">qc</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">need_sense</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">error_handler</span><span class="p">)</span>
		<span class="n">ata_dump_status</span><span class="p">(</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">print_id</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">qc</span><span class="o">-&gt;</span><span class="n">result_tf</span><span class="p">);</span>

	<span class="n">qc</span><span class="o">-&gt;</span><span class="n">scsidone</span><span class="p">(</span><span class="n">cmd</span><span class="p">);</span>

	<span class="n">ata_qc_free</span><span class="p">(</span><span class="n">qc</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	ata_scsi_translate - Translate then issue SCSI command to ATA device</span>
<span class="cm"> *	@dev: ATA device to which the command is addressed</span>
<span class="cm"> *	@cmd: SCSI command to execute</span>
<span class="cm"> *	@xlat_func: Actor which translates @cmd to an ATA taskfile</span>
<span class="cm"> *</span>
<span class="cm"> *	Our -&gt;queuecommand() function has decided that the SCSI</span>
<span class="cm"> *	command issued can be directly translated into an ATA</span>
<span class="cm"> *	command, rather than handled internally.</span>
<span class="cm"> *</span>
<span class="cm"> *	This function sets up an ata_queued_cmd structure for the</span>
<span class="cm"> *	SCSI command, and sends that ata_queued_cmd to the hardware.</span>
<span class="cm"> *</span>
<span class="cm"> *	The xlat_func argument (actor) returns 0 if ready to execute</span>
<span class="cm"> *	ATA command, else 1 to finish translation. If 1 is returned</span>
<span class="cm"> *	then cmd-&gt;result (and possibly cmd-&gt;sense_buffer) are assumed</span>
<span class="cm"> *	to be set reflecting an error condition or clean (early)</span>
<span class="cm"> *	termination.</span>
<span class="cm"> *</span>
<span class="cm"> *	LOCKING:</span>
<span class="cm"> *	spin_lock_irqsave(host lock)</span>
<span class="cm"> *</span>
<span class="cm"> *	RETURNS:</span>
<span class="cm"> *	0 on success, SCSI_ML_QUEUE_DEVICE_BUSY if the command</span>
<span class="cm"> *	needs to be deferred.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">ata_scsi_translate</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">,</span>
			      <span class="n">ata_xlat_func_t</span> <span class="n">xlat_func</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">link</span><span class="o">-&gt;</span><span class="n">ap</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ata_queued_cmd</span> <span class="o">*</span><span class="n">qc</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">VPRINTK</span><span class="p">(</span><span class="s">&quot;ENTER</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="n">qc</span> <span class="o">=</span> <span class="n">ata_scsi_qc_new</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">cmd</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">qc</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err_mem</span><span class="p">;</span>

	<span class="cm">/* data is present; dma-map it */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">sc_data_direction</span> <span class="o">==</span> <span class="n">DMA_FROM_DEVICE</span> <span class="o">||</span>
	    <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">sc_data_direction</span> <span class="o">==</span> <span class="n">DMA_TO_DEVICE</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">scsi_bufflen</span><span class="p">(</span><span class="n">cmd</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">ata_dev_warn</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;WARNING: zero len r/w req</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">err_did</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">ata_sg_init</span><span class="p">(</span><span class="n">qc</span><span class="p">,</span> <span class="n">scsi_sglist</span><span class="p">(</span><span class="n">cmd</span><span class="p">),</span> <span class="n">scsi_sg_count</span><span class="p">(</span><span class="n">cmd</span><span class="p">));</span>

		<span class="n">qc</span><span class="o">-&gt;</span><span class="n">dma_dir</span> <span class="o">=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">sc_data_direction</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">qc</span><span class="o">-&gt;</span><span class="n">complete_fn</span> <span class="o">=</span> <span class="n">ata_scsi_qc_complete</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">xlat_func</span><span class="p">(</span><span class="n">qc</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">early_finish</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">qc_defer</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">rc</span> <span class="o">=</span> <span class="n">ap</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">qc_defer</span><span class="p">(</span><span class="n">qc</span><span class="p">)))</span>
			<span class="k">goto</span> <span class="n">defer</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* select device, send command to hardware */</span>
	<span class="n">ata_qc_issue</span><span class="p">(</span><span class="n">qc</span><span class="p">);</span>

	<span class="n">VPRINTK</span><span class="p">(</span><span class="s">&quot;EXIT</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">early_finish:</span>
	<span class="n">ata_qc_free</span><span class="p">(</span><span class="n">qc</span><span class="p">);</span>
	<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scsi_done</span><span class="p">(</span><span class="n">cmd</span><span class="p">);</span>
	<span class="n">DPRINTK</span><span class="p">(</span><span class="s">&quot;EXIT - early finish (good or error)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">err_did:</span>
	<span class="n">ata_qc_free</span><span class="p">(</span><span class="n">qc</span><span class="p">);</span>
	<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">=</span> <span class="p">(</span><span class="n">DID_ERROR</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">);</span>
	<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scsi_done</span><span class="p">(</span><span class="n">cmd</span><span class="p">);</span>
<span class="nl">err_mem:</span>
	<span class="n">DPRINTK</span><span class="p">(</span><span class="s">&quot;EXIT - internal</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">defer:</span>
	<span class="n">ata_qc_free</span><span class="p">(</span><span class="n">qc</span><span class="p">);</span>
	<span class="n">DPRINTK</span><span class="p">(</span><span class="s">&quot;EXIT - defer</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">==</span> <span class="n">ATA_DEFER_LINK</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">SCSI_MLQUEUE_DEVICE_BUSY</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="k">return</span> <span class="n">SCSI_MLQUEUE_HOST_BUSY</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	ata_scsi_rbuf_get - Map response buffer.</span>
<span class="cm"> *	@cmd: SCSI command containing buffer to be mapped.</span>
<span class="cm"> *	@flags: unsigned long variable to store irq enable status</span>
<span class="cm"> *	@copy_in: copy in from user buffer</span>
<span class="cm"> *</span>
<span class="cm"> *	Prepare buffer for simulated SCSI commands.</span>
<span class="cm"> *</span>
<span class="cm"> *	LOCKING:</span>
<span class="cm"> *	spin_lock_irqsave(ata_scsi_rbuf_lock) on success</span>
<span class="cm"> *</span>
<span class="cm"> *	RETURNS:</span>
<span class="cm"> *	Pointer to response buffer.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">ata_scsi_rbuf_get</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">,</span> <span class="n">bool</span> <span class="n">copy_in</span><span class="p">,</span>
			       <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ata_scsi_rbuf_lock</span><span class="p">,</span> <span class="o">*</span><span class="n">flags</span><span class="p">);</span>

	<span class="n">memset</span><span class="p">(</span><span class="n">ata_scsi_rbuf</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">ATA_SCSI_RBUF_SIZE</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">copy_in</span><span class="p">)</span>
		<span class="n">sg_copy_to_buffer</span><span class="p">(</span><span class="n">scsi_sglist</span><span class="p">(</span><span class="n">cmd</span><span class="p">),</span> <span class="n">scsi_sg_count</span><span class="p">(</span><span class="n">cmd</span><span class="p">),</span>
				  <span class="n">ata_scsi_rbuf</span><span class="p">,</span> <span class="n">ATA_SCSI_RBUF_SIZE</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ata_scsi_rbuf</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	ata_scsi_rbuf_put - Unmap response buffer.</span>
<span class="cm"> *	@cmd: SCSI command containing buffer to be unmapped.</span>
<span class="cm"> *	@copy_out: copy out result</span>
<span class="cm"> *	@flags: @flags passed to ata_scsi_rbuf_get()</span>
<span class="cm"> *</span>
<span class="cm"> *	Returns rbuf buffer.  The result is copied to @cmd&#39;s buffer if</span>
<span class="cm"> *	@copy_back is true.</span>
<span class="cm"> *</span>
<span class="cm"> *	LOCKING:</span>
<span class="cm"> *	Unlocks ata_scsi_rbuf_lock.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">ata_scsi_rbuf_put</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">,</span> <span class="n">bool</span> <span class="n">copy_out</span><span class="p">,</span>
				     <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">copy_out</span><span class="p">)</span>
		<span class="n">sg_copy_from_buffer</span><span class="p">(</span><span class="n">scsi_sglist</span><span class="p">(</span><span class="n">cmd</span><span class="p">),</span> <span class="n">scsi_sg_count</span><span class="p">(</span><span class="n">cmd</span><span class="p">),</span>
				    <span class="n">ata_scsi_rbuf</span><span class="p">,</span> <span class="n">ATA_SCSI_RBUF_SIZE</span><span class="p">);</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ata_scsi_rbuf_lock</span><span class="p">,</span> <span class="o">*</span><span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	ata_scsi_rbuf_fill - wrapper for SCSI command simulators</span>
<span class="cm"> *	@args: device IDENTIFY data / SCSI command of interest.</span>
<span class="cm"> *	@actor: Callback hook for desired SCSI command simulator</span>
<span class="cm"> *</span>
<span class="cm"> *	Takes care of the hard work of simulating a SCSI command...</span>
<span class="cm"> *	Mapping the response buffer, calling the command&#39;s handler,</span>
<span class="cm"> *	and handling the handler&#39;s return value.  This return value</span>
<span class="cm"> *	indicates whether the handler wishes the SCSI command to be</span>
<span class="cm"> *	completed successfully (0), or not (in which case cmd-&gt;result</span>
<span class="cm"> *	and sense buffer are assumed to be set).</span>
<span class="cm"> *</span>
<span class="cm"> *	LOCKING:</span>
<span class="cm"> *	spin_lock_irqsave(host lock)</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">ata_scsi_rbuf_fill</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_scsi_args</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">actor</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ata_scsi_args</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">u8</span> <span class="o">*</span><span class="n">rbuf</span><span class="p">))</span>
<span class="p">{</span>
	<span class="n">u8</span> <span class="o">*</span><span class="n">rbuf</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="n">cmd</span> <span class="o">=</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">cmd</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">rbuf</span> <span class="o">=</span> <span class="n">ata_scsi_rbuf_get</span><span class="p">(</span><span class="n">cmd</span><span class="p">,</span> <span class="nb">false</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">flags</span><span class="p">);</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">actor</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">rbuf</span><span class="p">);</span>
	<span class="n">ata_scsi_rbuf_put</span><span class="p">(</span><span class="n">cmd</span><span class="p">,</span> <span class="n">rc</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">flags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">=</span> <span class="n">SAM_STAT_GOOD</span><span class="p">;</span>
	<span class="n">args</span><span class="o">-&gt;</span><span class="n">done</span><span class="p">(</span><span class="n">cmd</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	ata_scsiop_inq_std - Simulate INQUIRY command</span>
<span class="cm"> *	@args: device IDENTIFY data / SCSI command of interest.</span>
<span class="cm"> *	@rbuf: Response buffer, to which simulated SCSI cmd output is sent.</span>
<span class="cm"> *</span>
<span class="cm"> *	Returns standard device identification data associated</span>
<span class="cm"> *	with non-VPD INQUIRY command output.</span>
<span class="cm"> *</span>
<span class="cm"> *	LOCKING:</span>
<span class="cm"> *	spin_lock_irqsave(host lock)</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">ata_scsiop_inq_std</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_scsi_args</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">u8</span> <span class="o">*</span><span class="n">rbuf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="n">u8</span> <span class="n">versions</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
		<span class="mh">0x60</span><span class="p">,</span>	<span class="cm">/* SAM-3 (no version claimed) */</span>

		<span class="mh">0x03</span><span class="p">,</span>
		<span class="mh">0x20</span><span class="p">,</span>	<span class="cm">/* SBC-2 (no version claimed) */</span>

		<span class="mh">0x02</span><span class="p">,</span>
		<span class="mh">0x60</span>	<span class="cm">/* SPC-3 (no version claimed) */</span>
	<span class="p">};</span>
	<span class="n">u8</span> <span class="n">hdr</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
		<span class="n">TYPE_DISK</span><span class="p">,</span>
		<span class="mi">0</span><span class="p">,</span>
		<span class="mh">0x5</span><span class="p">,</span>	<span class="cm">/* claim SPC-3 version compatibility */</span>
		<span class="mi">2</span><span class="p">,</span>
		<span class="mi">95</span> <span class="o">-</span> <span class="mi">4</span>
	<span class="p">};</span>

	<span class="n">VPRINTK</span><span class="p">(</span><span class="s">&quot;ENTER</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="cm">/* set scsi removeable (RMB) bit per ata bit */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ata_id_removeable</span><span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">))</span>
		<span class="n">hdr</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">|=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">7</span><span class="p">);</span>

	<span class="n">memcpy</span><span class="p">(</span><span class="n">rbuf</span><span class="p">,</span> <span class="n">hdr</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">hdr</span><span class="p">));</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rbuf</span><span class="p">[</span><span class="mi">8</span><span class="p">],</span> <span class="s">&quot;ATA     &quot;</span><span class="p">,</span> <span class="mi">8</span><span class="p">);</span>
	<span class="n">ata_id_string</span><span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rbuf</span><span class="p">[</span><span class="mi">16</span><span class="p">],</span> <span class="n">ATA_ID_PROD</span><span class="p">,</span> <span class="mi">16</span><span class="p">);</span>
	<span class="n">ata_id_string</span><span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rbuf</span><span class="p">[</span><span class="mi">32</span><span class="p">],</span> <span class="n">ATA_ID_FW_REV</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">rbuf</span><span class="p">[</span><span class="mi">32</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">rbuf</span><span class="p">[</span><span class="mi">32</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39; &#39;</span><span class="p">)</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rbuf</span><span class="p">[</span><span class="mi">32</span><span class="p">],</span> <span class="s">&quot;n/a &quot;</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>

	<span class="n">memcpy</span><span class="p">(</span><span class="n">rbuf</span> <span class="o">+</span> <span class="mi">59</span><span class="p">,</span> <span class="n">versions</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">versions</span><span class="p">));</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	ata_scsiop_inq_00 - Simulate INQUIRY VPD page 0, list of pages</span>
<span class="cm"> *	@args: device IDENTIFY data / SCSI command of interest.</span>
<span class="cm"> *	@rbuf: Response buffer, to which simulated SCSI cmd output is sent.</span>
<span class="cm"> *</span>
<span class="cm"> *	Returns list of inquiry VPD pages available.</span>
<span class="cm"> *</span>
<span class="cm"> *	LOCKING:</span>
<span class="cm"> *	spin_lock_irqsave(host lock)</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">ata_scsiop_inq_00</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_scsi_args</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">u8</span> <span class="o">*</span><span class="n">rbuf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="n">u8</span> <span class="n">pages</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
		<span class="mh">0x00</span><span class="p">,</span>	<span class="cm">/* page 0x00, this page */</span>
		<span class="mh">0x80</span><span class="p">,</span>	<span class="cm">/* page 0x80, unit serial no page */</span>
		<span class="mh">0x83</span><span class="p">,</span>	<span class="cm">/* page 0x83, device ident page */</span>
		<span class="mh">0x89</span><span class="p">,</span>	<span class="cm">/* page 0x89, ata info page */</span>
		<span class="mh">0xb0</span><span class="p">,</span>	<span class="cm">/* page 0xb0, block limits page */</span>
		<span class="mh">0xb1</span><span class="p">,</span>	<span class="cm">/* page 0xb1, block device characteristics page */</span>
		<span class="mh">0xb2</span><span class="p">,</span>	<span class="cm">/* page 0xb2, thin provisioning page */</span>
	<span class="p">};</span>

	<span class="n">rbuf</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">pages</span><span class="p">);</span>	<span class="cm">/* number of supported VPD pages */</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">rbuf</span> <span class="o">+</span> <span class="mi">4</span><span class="p">,</span> <span class="n">pages</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">pages</span><span class="p">));</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	ata_scsiop_inq_80 - Simulate INQUIRY VPD page 80, device serial number</span>
<span class="cm"> *	@args: device IDENTIFY data / SCSI command of interest.</span>
<span class="cm"> *	@rbuf: Response buffer, to which simulated SCSI cmd output is sent.</span>
<span class="cm"> *</span>
<span class="cm"> *	Returns ATA device serial number.</span>
<span class="cm"> *</span>
<span class="cm"> *	LOCKING:</span>
<span class="cm"> *	spin_lock_irqsave(host lock)</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">ata_scsiop_inq_80</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_scsi_args</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">u8</span> <span class="o">*</span><span class="n">rbuf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="n">u8</span> <span class="n">hdr</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
		<span class="mi">0</span><span class="p">,</span>
		<span class="mh">0x80</span><span class="p">,</span>			<span class="cm">/* this page code */</span>
		<span class="mi">0</span><span class="p">,</span>
		<span class="n">ATA_ID_SERNO_LEN</span><span class="p">,</span>	<span class="cm">/* page len */</span>
	<span class="p">};</span>

	<span class="n">memcpy</span><span class="p">(</span><span class="n">rbuf</span><span class="p">,</span> <span class="n">hdr</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">hdr</span><span class="p">));</span>
	<span class="n">ata_id_string</span><span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">rbuf</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span>
		      <span class="n">ATA_ID_SERNO</span><span class="p">,</span> <span class="n">ATA_ID_SERNO_LEN</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	ata_scsiop_inq_83 - Simulate INQUIRY VPD page 83, device identity</span>
<span class="cm"> *	@args: device IDENTIFY data / SCSI command of interest.</span>
<span class="cm"> *	@rbuf: Response buffer, to which simulated SCSI cmd output is sent.</span>
<span class="cm"> *</span>
<span class="cm"> *	Yields two logical unit device identification designators:</span>
<span class="cm"> *	 - vendor specific ASCII containing the ATA serial number</span>
<span class="cm"> *	 - SAT defined &quot;t10 vendor id based&quot; containing ASCII vendor</span>
<span class="cm"> *	   name (&quot;ATA     &quot;), model and serial numbers.</span>
<span class="cm"> *</span>
<span class="cm"> *	LOCKING:</span>
<span class="cm"> *	spin_lock_irqsave(host lock)</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">ata_scsiop_inq_83</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_scsi_args</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">u8</span> <span class="o">*</span><span class="n">rbuf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="kt">int</span> <span class="n">sat_model_serial_desc_len</span> <span class="o">=</span> <span class="mi">68</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">num</span><span class="p">;</span>

	<span class="n">rbuf</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x83</span><span class="p">;</span>			<span class="cm">/* this page code */</span>
	<span class="n">num</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>

	<span class="cm">/* piv=0, assoc=lu, code_set=ACSII, designator=vendor */</span>
	<span class="n">rbuf</span><span class="p">[</span><span class="n">num</span> <span class="o">+</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
	<span class="n">rbuf</span><span class="p">[</span><span class="n">num</span> <span class="o">+</span> <span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">ATA_ID_SERNO_LEN</span><span class="p">;</span>
	<span class="n">num</span> <span class="o">+=</span> <span class="mi">4</span><span class="p">;</span>
	<span class="n">ata_id_string</span><span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="p">)</span> <span class="n">rbuf</span> <span class="o">+</span> <span class="n">num</span><span class="p">,</span>
		      <span class="n">ATA_ID_SERNO</span><span class="p">,</span> <span class="n">ATA_ID_SERNO_LEN</span><span class="p">);</span>
	<span class="n">num</span> <span class="o">+=</span> <span class="n">ATA_ID_SERNO_LEN</span><span class="p">;</span>

	<span class="cm">/* SAT defined lu model and serial numbers descriptor */</span>
	<span class="cm">/* piv=0, assoc=lu, code_set=ACSII, designator=t10 vendor id */</span>
	<span class="n">rbuf</span><span class="p">[</span><span class="n">num</span> <span class="o">+</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
	<span class="n">rbuf</span><span class="p">[</span><span class="n">num</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">rbuf</span><span class="p">[</span><span class="n">num</span> <span class="o">+</span> <span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">sat_model_serial_desc_len</span><span class="p">;</span>
	<span class="n">num</span> <span class="o">+=</span> <span class="mi">4</span><span class="p">;</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">rbuf</span> <span class="o">+</span> <span class="n">num</span><span class="p">,</span> <span class="s">&quot;ATA     &quot;</span><span class="p">,</span> <span class="mi">8</span><span class="p">);</span>
	<span class="n">num</span> <span class="o">+=</span> <span class="mi">8</span><span class="p">;</span>
	<span class="n">ata_id_string</span><span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="p">)</span> <span class="n">rbuf</span> <span class="o">+</span> <span class="n">num</span><span class="p">,</span> <span class="n">ATA_ID_PROD</span><span class="p">,</span>
		      <span class="n">ATA_ID_PROD_LEN</span><span class="p">);</span>
	<span class="n">num</span> <span class="o">+=</span> <span class="n">ATA_ID_PROD_LEN</span><span class="p">;</span>
	<span class="n">ata_id_string</span><span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="p">)</span> <span class="n">rbuf</span> <span class="o">+</span> <span class="n">num</span><span class="p">,</span> <span class="n">ATA_ID_SERNO</span><span class="p">,</span>
		      <span class="n">ATA_ID_SERNO_LEN</span><span class="p">);</span>
	<span class="n">num</span> <span class="o">+=</span> <span class="n">ATA_ID_SERNO_LEN</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ata_id_has_wwn</span><span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* SAT defined lu world wide name */</span>
		<span class="cm">/* piv=0, assoc=lu, code_set=binary, designator=NAA */</span>
		<span class="n">rbuf</span><span class="p">[</span><span class="n">num</span> <span class="o">+</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">rbuf</span><span class="p">[</span><span class="n">num</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
		<span class="n">rbuf</span><span class="p">[</span><span class="n">num</span> <span class="o">+</span> <span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">ATA_ID_WWN_LEN</span><span class="p">;</span>
		<span class="n">num</span> <span class="o">+=</span> <span class="mi">4</span><span class="p">;</span>
		<span class="n">ata_id_string</span><span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="p">)</span> <span class="n">rbuf</span> <span class="o">+</span> <span class="n">num</span><span class="p">,</span>
			      <span class="n">ATA_ID_WWN</span><span class="p">,</span> <span class="n">ATA_ID_WWN_LEN</span><span class="p">);</span>
		<span class="n">num</span> <span class="o">+=</span> <span class="n">ATA_ID_WWN_LEN</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">rbuf</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">num</span> <span class="o">-</span> <span class="mi">4</span><span class="p">;</span>    <span class="cm">/* page len (assume less than 256 bytes) */</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	ata_scsiop_inq_89 - Simulate INQUIRY VPD page 89, ATA info</span>
<span class="cm"> *	@args: device IDENTIFY data / SCSI command of interest.</span>
<span class="cm"> *	@rbuf: Response buffer, to which simulated SCSI cmd output is sent.</span>
<span class="cm"> *</span>
<span class="cm"> *	Yields SAT-specified ATA VPD page.</span>
<span class="cm"> *</span>
<span class="cm"> *	LOCKING:</span>
<span class="cm"> *	spin_lock_irqsave(host lock)</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">ata_scsiop_inq_89</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_scsi_args</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">u8</span> <span class="o">*</span><span class="n">rbuf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ata_taskfile</span> <span class="n">tf</span><span class="p">;</span>

	<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tf</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">tf</span><span class="p">));</span>

	<span class="n">rbuf</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x89</span><span class="p">;</span>			<span class="cm">/* our page code */</span>
	<span class="n">rbuf</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mh">0x238</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">);</span>		<span class="cm">/* page size fixed at 238h */</span>
	<span class="n">rbuf</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mh">0x238</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">);</span>

	<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rbuf</span><span class="p">[</span><span class="mi">8</span><span class="p">],</span> <span class="s">&quot;linux   &quot;</span><span class="p">,</span> <span class="mi">8</span><span class="p">);</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rbuf</span><span class="p">[</span><span class="mi">16</span><span class="p">],</span> <span class="s">&quot;libata          &quot;</span><span class="p">,</span> <span class="mi">16</span><span class="p">);</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rbuf</span><span class="p">[</span><span class="mi">32</span><span class="p">],</span> <span class="n">DRV_VERSION</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>
	<span class="n">ata_id_string</span><span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rbuf</span><span class="p">[</span><span class="mi">32</span><span class="p">],</span> <span class="n">ATA_ID_FW_REV</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>

	<span class="cm">/* we don&#39;t store the ATA device signature, so we fake it */</span>

	<span class="n">tf</span><span class="p">.</span><span class="n">command</span> <span class="o">=</span> <span class="n">ATA_DRDY</span><span class="p">;</span>		<span class="cm">/* really, this is Status reg */</span>
	<span class="n">tf</span><span class="p">.</span><span class="n">lbal</span> <span class="o">=</span> <span class="mh">0x1</span><span class="p">;</span>
	<span class="n">tf</span><span class="p">.</span><span class="n">nsect</span> <span class="o">=</span> <span class="mh">0x1</span><span class="p">;</span>

	<span class="n">ata_tf_to_fis</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tf</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rbuf</span><span class="p">[</span><span class="mi">36</span><span class="p">]);</span>	<span class="cm">/* TODO: PMP? */</span>
	<span class="n">rbuf</span><span class="p">[</span><span class="mi">36</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x34</span><span class="p">;</span>		<span class="cm">/* force D2H Reg FIS (34h) */</span>

	<span class="n">rbuf</span><span class="p">[</span><span class="mi">56</span><span class="p">]</span> <span class="o">=</span> <span class="n">ATA_CMD_ID_ATA</span><span class="p">;</span>

	<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rbuf</span><span class="p">[</span><span class="mi">60</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">512</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">ata_scsiop_inq_b0</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_scsi_args</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">u8</span> <span class="o">*</span><span class="n">rbuf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u16</span> <span class="n">min_io_sectors</span><span class="p">;</span>

	<span class="n">rbuf</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0xb0</span><span class="p">;</span>
	<span class="n">rbuf</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x3c</span><span class="p">;</span>		<span class="cm">/* required VPD size with unmap support */</span>

	<span class="cm">/*</span>
<span class="cm">	 * Optimal transfer length granularity.</span>
<span class="cm">	 *</span>
<span class="cm">	 * This is always one physical block, but for disks with a smaller</span>
<span class="cm">	 * logical than physical sector size we need to figure out what the</span>
<span class="cm">	 * latter is.</span>
<span class="cm">	 */</span>
	<span class="n">min_io_sectors</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">ata_id_log2_per_physical_sector</span><span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">);</span>
	<span class="n">put_unaligned_be16</span><span class="p">(</span><span class="n">min_io_sectors</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rbuf</span><span class="p">[</span><span class="mi">6</span><span class="p">]);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Optimal unmap granularity.</span>
<span class="cm">	 *</span>
<span class="cm">	 * The ATA spec doesn&#39;t even know about a granularity or alignment</span>
<span class="cm">	 * for the TRIM command.  We can leave away most of the unmap related</span>
<span class="cm">	 * VPD page entries, but we have specifify a granularity to signal</span>
<span class="cm">	 * that we support some form of unmap - in thise case via WRITE SAME</span>
<span class="cm">	 * with the unmap bit set.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ata_id_has_trim</span><span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">put_unaligned_be64</span><span class="p">(</span><span class="mi">65535</span> <span class="o">*</span> <span class="mi">512</span> <span class="o">/</span> <span class="mi">8</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rbuf</span><span class="p">[</span><span class="mi">36</span><span class="p">]);</span>
		<span class="n">put_unaligned_be32</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rbuf</span><span class="p">[</span><span class="mi">28</span><span class="p">]);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">ata_scsiop_inq_b1</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_scsi_args</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">u8</span> <span class="o">*</span><span class="n">rbuf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">form_factor</span> <span class="o">=</span> <span class="n">ata_id_form_factor</span><span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">media_rotation_rate</span> <span class="o">=</span> <span class="n">ata_id_rotation_rate</span><span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">);</span>

	<span class="n">rbuf</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0xb1</span><span class="p">;</span>
	<span class="n">rbuf</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x3c</span><span class="p">;</span>
	<span class="n">rbuf</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="n">media_rotation_rate</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">;</span>
	<span class="n">rbuf</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="n">media_rotation_rate</span><span class="p">;</span>
	<span class="n">rbuf</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span> <span class="o">=</span> <span class="n">form_factor</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">ata_scsiop_inq_b2</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_scsi_args</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">u8</span> <span class="o">*</span><span class="n">rbuf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* SCSI Thin Provisioning VPD page: SBC-3 rev 22 or later */</span>
	<span class="n">rbuf</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0xb2</span><span class="p">;</span>
	<span class="n">rbuf</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x4</span><span class="p">;</span>
	<span class="n">rbuf</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">6</span><span class="p">;</span>	<span class="cm">/* TPWS */</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	ata_scsiop_noop - Command handler that simply returns success.</span>
<span class="cm"> *	@args: device IDENTIFY data / SCSI command of interest.</span>
<span class="cm"> *	@rbuf: Response buffer, to which simulated SCSI cmd output is sent.</span>
<span class="cm"> *</span>
<span class="cm"> *	No operation.  Simply returns success to caller, to indicate</span>
<span class="cm"> *	that the caller should successfully complete this SCSI command.</span>
<span class="cm"> *</span>
<span class="cm"> *	LOCKING:</span>
<span class="cm"> *	spin_lock_irqsave(host lock)</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">ata_scsiop_noop</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_scsi_args</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">u8</span> <span class="o">*</span><span class="n">rbuf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">VPRINTK</span><span class="p">(</span><span class="s">&quot;ENTER</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	ata_msense_caching - Simulate MODE SENSE caching info page</span>
<span class="cm"> *	@id: device IDENTIFY data</span>
<span class="cm"> *	@buf: output buffer</span>
<span class="cm"> *</span>
<span class="cm"> *	Generate a caching info page, which conditionally indicates</span>
<span class="cm"> *	write caching to the SCSI layer, depending on device</span>
<span class="cm"> *	capabilities.</span>
<span class="cm"> *</span>
<span class="cm"> *	LOCKING:</span>
<span class="cm"> *	None.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">ata_msense_caching</span><span class="p">(</span><span class="n">u16</span> <span class="o">*</span><span class="n">id</span><span class="p">,</span> <span class="n">u8</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">def_cache_mpage</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">def_cache_mpage</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ata_id_wcache_enabled</span><span class="p">(</span><span class="n">id</span><span class="p">))</span>
		<span class="n">buf</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">|=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">);</span>	<span class="cm">/* write cache enable */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ata_id_rahead_enabled</span><span class="p">(</span><span class="n">id</span><span class="p">))</span>
		<span class="n">buf</span><span class="p">[</span><span class="mi">12</span><span class="p">]</span> <span class="o">|=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">5</span><span class="p">);</span>	<span class="cm">/* disable read ahead */</span>
	<span class="k">return</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">def_cache_mpage</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	ata_msense_ctl_mode - Simulate MODE SENSE control mode page</span>
<span class="cm"> *	@buf: output buffer</span>
<span class="cm"> *</span>
<span class="cm"> *	Generate a generic MODE SENSE control mode page.</span>
<span class="cm"> *</span>
<span class="cm"> *	LOCKING:</span>
<span class="cm"> *	None.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">ata_msense_ctl_mode</span><span class="p">(</span><span class="n">u8</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">def_control_mpage</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">def_control_mpage</span><span class="p">));</span>
	<span class="k">return</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">def_control_mpage</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	ata_msense_rw_recovery - Simulate MODE SENSE r/w error recovery page</span>
<span class="cm"> *	@buf: output buffer</span>
<span class="cm"> *</span>
<span class="cm"> *	Generate a generic MODE SENSE r/w error recovery page.</span>
<span class="cm"> *</span>
<span class="cm"> *	LOCKING:</span>
<span class="cm"> *	None.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">ata_msense_rw_recovery</span><span class="p">(</span><span class="n">u8</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">def_rw_recovery_mpage</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">def_rw_recovery_mpage</span><span class="p">));</span>
	<span class="k">return</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">def_rw_recovery_mpage</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * We can turn this into a real blacklist if it&#39;s needed, for now just</span>
<span class="cm"> * blacklist any Maxtor BANC1G10 revision firmware</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">ata_dev_supports_fua</span><span class="p">(</span><span class="n">u16</span> <span class="o">*</span><span class="n">id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">model</span><span class="p">[</span><span class="n">ATA_ID_PROD_LEN</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span> <span class="n">fw</span><span class="p">[</span><span class="n">ATA_ID_FW_REV_LEN</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">libata_fua</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ata_id_has_fua</span><span class="p">(</span><span class="n">id</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">ata_id_c_string</span><span class="p">(</span><span class="n">id</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="n">ATA_ID_PROD</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">model</span><span class="p">));</span>
	<span class="n">ata_id_c_string</span><span class="p">(</span><span class="n">id</span><span class="p">,</span> <span class="n">fw</span><span class="p">,</span> <span class="n">ATA_ID_FW_REV</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">fw</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="s">&quot;Maxtor&quot;</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">fw</span><span class="p">,</span> <span class="s">&quot;BANC1G10&quot;</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span> <span class="cm">/* blacklisted */</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	ata_scsiop_mode_sense - Simulate MODE SENSE 6, 10 commands</span>
<span class="cm"> *	@args: device IDENTIFY data / SCSI command of interest.</span>
<span class="cm"> *	@rbuf: Response buffer, to which simulated SCSI cmd output is sent.</span>
<span class="cm"> *</span>
<span class="cm"> *	Simulate MODE SENSE commands. Assume this is invoked for direct</span>
<span class="cm"> *	access devices (e.g. disks) only. There should be no block</span>
<span class="cm"> *	descriptor for other device types.</span>
<span class="cm"> *</span>
<span class="cm"> *	LOCKING:</span>
<span class="cm"> *	spin_lock_irqsave(host lock)</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">ata_scsiop_mode_sense</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_scsi_args</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">u8</span> <span class="o">*</span><span class="n">rbuf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ata_device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>
	<span class="n">u8</span> <span class="o">*</span><span class="n">scsicmd</span> <span class="o">=</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">,</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">rbuf</span><span class="p">;</span>
	<span class="k">const</span> <span class="n">u8</span> <span class="n">sat_blk_desc</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
		<span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>	<span class="cm">/* number of blocks: sat unspecified */</span>
		<span class="mi">0</span><span class="p">,</span>
		<span class="mi">0</span><span class="p">,</span> <span class="mh">0x2</span><span class="p">,</span> <span class="mh">0x0</span>	<span class="cm">/* block length: 512 bytes */</span>
	<span class="p">};</span>
	<span class="n">u8</span> <span class="n">pg</span><span class="p">,</span> <span class="n">spg</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ebd</span><span class="p">,</span> <span class="n">page_control</span><span class="p">,</span> <span class="n">six_byte</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">dpofua</span><span class="p">;</span>

	<span class="n">VPRINTK</span><span class="p">(</span><span class="s">&quot;ENTER</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="n">six_byte</span> <span class="o">=</span> <span class="p">(</span><span class="n">scsicmd</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">MODE_SENSE</span><span class="p">);</span>
	<span class="n">ebd</span> <span class="o">=</span> <span class="o">!</span><span class="p">(</span><span class="n">scsicmd</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0x8</span><span class="p">);</span>      <span class="cm">/* dbd bit inverted == edb */</span>
	<span class="cm">/*</span>
<span class="cm">	 * LLBA bit in msense(10) ignored (compliant)</span>
<span class="cm">	 */</span>

	<span class="n">page_control</span> <span class="o">=</span> <span class="n">scsicmd</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&gt;&gt;</span> <span class="mi">6</span><span class="p">;</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">page_control</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="mi">0</span>: <span class="cm">/* current */</span>
		<span class="k">break</span><span class="p">;</span>  <span class="cm">/* supported */</span>
	<span class="k">case</span> <span class="mi">3</span>: <span class="cm">/* saved */</span>
		<span class="k">goto</span> <span class="n">saving_not_supp</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">1</span>: <span class="cm">/* changeable */</span>
	<span class="k">case</span> <span class="mi">2</span>: <span class="cm">/* defaults */</span>
	<span class="nl">default:</span>
		<span class="k">goto</span> <span class="n">invalid_fld</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">six_byte</span><span class="p">)</span>
		<span class="n">p</span> <span class="o">+=</span> <span class="mi">4</span> <span class="o">+</span> <span class="p">(</span><span class="n">ebd</span> <span class="o">?</span> <span class="mi">8</span> <span class="o">:</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">p</span> <span class="o">+=</span> <span class="mi">8</span> <span class="o">+</span> <span class="p">(</span><span class="n">ebd</span> <span class="o">?</span> <span class="mi">8</span> <span class="o">:</span> <span class="mi">0</span><span class="p">);</span>

	<span class="n">pg</span> <span class="o">=</span> <span class="n">scsicmd</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0x3f</span><span class="p">;</span>
	<span class="n">spg</span> <span class="o">=</span> <span class="n">scsicmd</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
	<span class="cm">/*</span>
<span class="cm">	 * No mode subpages supported (yet) but asking for _all_</span>
<span class="cm">	 * subpages may be valid</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">spg</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">spg</span> <span class="o">!=</span> <span class="n">ALL_SUB_MPAGES</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">invalid_fld</span><span class="p">;</span>

	<span class="k">switch</span><span class="p">(</span><span class="n">pg</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">RW_RECOVERY_MPAGE</span>:
		<span class="n">p</span> <span class="o">+=</span> <span class="n">ata_msense_rw_recovery</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">CACHE_MPAGE</span>:
		<span class="n">p</span> <span class="o">+=</span> <span class="n">ata_msense_caching</span><span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">CONTROL_MPAGE</span>:
		<span class="n">p</span> <span class="o">+=</span> <span class="n">ata_msense_ctl_mode</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">ALL_MPAGES</span>:
		<span class="n">p</span> <span class="o">+=</span> <span class="n">ata_msense_rw_recovery</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
		<span class="n">p</span> <span class="o">+=</span> <span class="n">ata_msense_caching</span><span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
		<span class="n">p</span> <span class="o">+=</span> <span class="n">ata_msense_ctl_mode</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="nl">default:</span>		<span class="cm">/* invalid page code */</span>
		<span class="k">goto</span> <span class="n">invalid_fld</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">dpofua</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ata_dev_supports_fua</span><span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">ATA_DFLAG_LBA48</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">ATA_DFLAG_PIO</span><span class="p">)</span> <span class="o">||</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">multi_count</span><span class="p">))</span>
		<span class="n">dpofua</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">4</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">six_byte</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rbuf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">p</span> <span class="o">-</span> <span class="n">rbuf</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">rbuf</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">|=</span> <span class="n">dpofua</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ebd</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">rbuf</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">sat_blk_desc</span><span class="p">);</span>
			<span class="n">memcpy</span><span class="p">(</span><span class="n">rbuf</span> <span class="o">+</span> <span class="mi">4</span><span class="p">,</span> <span class="n">sat_blk_desc</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">sat_blk_desc</span><span class="p">));</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">output_len</span> <span class="o">=</span> <span class="n">p</span> <span class="o">-</span> <span class="n">rbuf</span> <span class="o">-</span> <span class="mi">2</span><span class="p">;</span>

		<span class="n">rbuf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">output_len</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">;</span>
		<span class="n">rbuf</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">output_len</span><span class="p">;</span>
		<span class="n">rbuf</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">|=</span> <span class="n">dpofua</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ebd</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">rbuf</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">sat_blk_desc</span><span class="p">);</span>
			<span class="n">memcpy</span><span class="p">(</span><span class="n">rbuf</span> <span class="o">+</span> <span class="mi">8</span><span class="p">,</span> <span class="n">sat_blk_desc</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">sat_blk_desc</span><span class="p">));</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">invalid_fld:</span>
	<span class="n">ata_scsi_set_sense</span><span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">cmd</span><span class="p">,</span> <span class="n">ILLEGAL_REQUEST</span><span class="p">,</span> <span class="mh">0x24</span><span class="p">,</span> <span class="mh">0x0</span><span class="p">);</span>
	<span class="cm">/* &quot;Invalid field in cbd&quot; */</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

<span class="nl">saving_not_supp:</span>
	<span class="n">ata_scsi_set_sense</span><span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">cmd</span><span class="p">,</span> <span class="n">ILLEGAL_REQUEST</span><span class="p">,</span> <span class="mh">0x39</span><span class="p">,</span> <span class="mh">0x0</span><span class="p">);</span>
	 <span class="cm">/* &quot;Saving parameters not supported&quot; */</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	ata_scsiop_read_cap - Simulate READ CAPACITY[ 16] commands</span>
<span class="cm"> *	@args: device IDENTIFY data / SCSI command of interest.</span>
<span class="cm"> *	@rbuf: Response buffer, to which simulated SCSI cmd output is sent.</span>
<span class="cm"> *</span>
<span class="cm"> *	Simulate READ CAPACITY commands.</span>
<span class="cm"> *</span>
<span class="cm"> *	LOCKING:</span>
<span class="cm"> *	None.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">ata_scsiop_read_cap</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_scsi_args</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">u8</span> <span class="o">*</span><span class="n">rbuf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ata_device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">last_lba</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">n_sectors</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="cm">/* LBA of the last block */</span>
	<span class="n">u32</span> <span class="n">sector_size</span><span class="p">;</span> <span class="cm">/* physical sector size in bytes */</span>
	<span class="n">u8</span> <span class="n">log2_per_phys</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">lowest_aligned</span><span class="p">;</span>

	<span class="n">sector_size</span> <span class="o">=</span> <span class="n">ata_id_logical_sector_size</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">);</span>
	<span class="n">log2_per_phys</span> <span class="o">=</span> <span class="n">ata_id_log2_per_physical_sector</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">);</span>
	<span class="n">lowest_aligned</span> <span class="o">=</span> <span class="n">ata_id_logical_sector_offset</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">,</span> <span class="n">log2_per_phys</span><span class="p">);</span>

	<span class="n">VPRINTK</span><span class="p">(</span><span class="s">&quot;ENTER</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">READ_CAPACITY</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">last_lba</span> <span class="o">&gt;=</span> <span class="mh">0xffffffffULL</span><span class="p">)</span>
			<span class="n">last_lba</span> <span class="o">=</span> <span class="mh">0xffffffff</span><span class="p">;</span>

		<span class="cm">/* sector count, 32-bit */</span>
		<span class="n">rbuf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">last_lba</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="mi">8</span> <span class="o">*</span> <span class="mi">3</span><span class="p">);</span>
		<span class="n">rbuf</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">last_lba</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="mi">8</span> <span class="o">*</span> <span class="mi">2</span><span class="p">);</span>
		<span class="n">rbuf</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">last_lba</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="mi">8</span> <span class="o">*</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">rbuf</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">last_lba</span><span class="p">;</span>

		<span class="cm">/* sector size */</span>
		<span class="n">rbuf</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="n">sector_size</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="mi">8</span> <span class="o">*</span> <span class="mi">3</span><span class="p">);</span>
		<span class="n">rbuf</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="n">sector_size</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="mi">8</span> <span class="o">*</span> <span class="mi">2</span><span class="p">);</span>
		<span class="n">rbuf</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span> <span class="o">=</span> <span class="n">sector_size</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="mi">8</span> <span class="o">*</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">rbuf</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span> <span class="o">=</span> <span class="n">sector_size</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* sector count, 64-bit */</span>
		<span class="n">rbuf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">last_lba</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="mi">8</span> <span class="o">*</span> <span class="mi">7</span><span class="p">);</span>
		<span class="n">rbuf</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">last_lba</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="mi">8</span> <span class="o">*</span> <span class="mi">6</span><span class="p">);</span>
		<span class="n">rbuf</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">last_lba</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="mi">8</span> <span class="o">*</span> <span class="mi">5</span><span class="p">);</span>
		<span class="n">rbuf</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">last_lba</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="mi">8</span> <span class="o">*</span> <span class="mi">4</span><span class="p">);</span>
		<span class="n">rbuf</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="n">last_lba</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="mi">8</span> <span class="o">*</span> <span class="mi">3</span><span class="p">);</span>
		<span class="n">rbuf</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="n">last_lba</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="mi">8</span> <span class="o">*</span> <span class="mi">2</span><span class="p">);</span>
		<span class="n">rbuf</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span> <span class="o">=</span> <span class="n">last_lba</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="mi">8</span> <span class="o">*</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">rbuf</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span> <span class="o">=</span> <span class="n">last_lba</span><span class="p">;</span>

		<span class="cm">/* sector size */</span>
		<span class="n">rbuf</span><span class="p">[</span> <span class="mi">8</span><span class="p">]</span> <span class="o">=</span> <span class="n">sector_size</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="mi">8</span> <span class="o">*</span> <span class="mi">3</span><span class="p">);</span>
		<span class="n">rbuf</span><span class="p">[</span> <span class="mi">9</span><span class="p">]</span> <span class="o">=</span> <span class="n">sector_size</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="mi">8</span> <span class="o">*</span> <span class="mi">2</span><span class="p">);</span>
		<span class="n">rbuf</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span> <span class="o">=</span> <span class="n">sector_size</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="mi">8</span> <span class="o">*</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">rbuf</span><span class="p">[</span><span class="mi">11</span><span class="p">]</span> <span class="o">=</span> <span class="n">sector_size</span><span class="p">;</span>

		<span class="n">rbuf</span><span class="p">[</span><span class="mi">12</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">rbuf</span><span class="p">[</span><span class="mi">13</span><span class="p">]</span> <span class="o">=</span> <span class="n">log2_per_phys</span><span class="p">;</span>
		<span class="n">rbuf</span><span class="p">[</span><span class="mi">14</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">lowest_aligned</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x3f</span><span class="p">;</span>
		<span class="n">rbuf</span><span class="p">[</span><span class="mi">15</span><span class="p">]</span> <span class="o">=</span> <span class="n">lowest_aligned</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">ata_id_has_trim</span><span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">rbuf</span><span class="p">[</span><span class="mi">14</span><span class="p">]</span> <span class="o">|=</span> <span class="mh">0x80</span><span class="p">;</span> <span class="cm">/* TPE */</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">ata_id_has_zero_after_trim</span><span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">))</span>
				<span class="n">rbuf</span><span class="p">[</span><span class="mi">14</span><span class="p">]</span> <span class="o">|=</span> <span class="mh">0x40</span><span class="p">;</span> <span class="cm">/* TPRZ */</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	ata_scsiop_report_luns - Simulate REPORT LUNS command</span>
<span class="cm"> *	@args: device IDENTIFY data / SCSI command of interest.</span>
<span class="cm"> *	@rbuf: Response buffer, to which simulated SCSI cmd output is sent.</span>
<span class="cm"> *</span>
<span class="cm"> *	Simulate REPORT LUNS command.</span>
<span class="cm"> *</span>
<span class="cm"> *	LOCKING:</span>
<span class="cm"> *	spin_lock_irqsave(host lock)</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">ata_scsiop_report_luns</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_scsi_args</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">u8</span> <span class="o">*</span><span class="n">rbuf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">VPRINTK</span><span class="p">(</span><span class="s">&quot;ENTER</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">rbuf</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="mi">8</span><span class="p">;</span>	<span class="cm">/* just one lun, LUN 0, size 8 bytes */</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">atapi_sense_complete</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_queued_cmd</span> <span class="o">*</span><span class="n">qc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">qc</span><span class="o">-&gt;</span><span class="n">err_mask</span> <span class="o">&amp;&amp;</span> <span class="p">((</span><span class="n">qc</span><span class="o">-&gt;</span><span class="n">err_mask</span> <span class="o">&amp;</span> <span class="n">AC_ERR_DEV</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* FIXME: not quite right; we don&#39;t want the</span>
<span class="cm">		 * translation of taskfile registers into</span>
<span class="cm">		 * a sense descriptors, since that&#39;s only</span>
<span class="cm">		 * correct for ATA, not ATAPI</span>
<span class="cm">		 */</span>
		<span class="n">ata_gen_passthru_sense</span><span class="p">(</span><span class="n">qc</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">qc</span><span class="o">-&gt;</span><span class="n">scsidone</span><span class="p">(</span><span class="n">qc</span><span class="o">-&gt;</span><span class="n">scsicmd</span><span class="p">);</span>
	<span class="n">ata_qc_free</span><span class="p">(</span><span class="n">qc</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* is it pointless to prefer PIO for &quot;safety reasons&quot;? */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">ata_pio_use_silly</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">ATA_FLAG_PIO_DMA</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">atapi_request_sense</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_queued_cmd</span> <span class="o">*</span><span class="n">qc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span> <span class="o">=</span> <span class="n">qc</span><span class="o">-&gt;</span><span class="n">ap</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="n">cmd</span> <span class="o">=</span> <span class="n">qc</span><span class="o">-&gt;</span><span class="n">scsicmd</span><span class="p">;</span>

	<span class="n">DPRINTK</span><span class="p">(</span><span class="s">&quot;ATAPI request sense</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="cm">/* FIXME: is this needed? */</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">sense_buffer</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">SCSI_SENSE_BUFFERSIZE</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_ATA_SFF</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">sff_tf_read</span><span class="p">)</span>
		<span class="n">ap</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">sff_tf_read</span><span class="p">(</span><span class="n">ap</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">qc</span><span class="o">-&gt;</span><span class="n">tf</span><span class="p">);</span>
<span class="cp">#endif</span>

	<span class="cm">/* fill these in, for the case where they are -not- overwritten */</span>
	<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">sense_buffer</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x70</span><span class="p">;</span>
	<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">sense_buffer</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">qc</span><span class="o">-&gt;</span><span class="n">tf</span><span class="p">.</span><span class="n">feature</span> <span class="o">&gt;&gt;</span> <span class="mi">4</span><span class="p">;</span>

	<span class="n">ata_qc_reinit</span><span class="p">(</span><span class="n">qc</span><span class="p">);</span>

	<span class="cm">/* setup sg table and init transfer direction */</span>
	<span class="n">sg_init_one</span><span class="p">(</span><span class="o">&amp;</span><span class="n">qc</span><span class="o">-&gt;</span><span class="n">sgent</span><span class="p">,</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">sense_buffer</span><span class="p">,</span> <span class="n">SCSI_SENSE_BUFFERSIZE</span><span class="p">);</span>
	<span class="n">ata_sg_init</span><span class="p">(</span><span class="n">qc</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">qc</span><span class="o">-&gt;</span><span class="n">sgent</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">qc</span><span class="o">-&gt;</span><span class="n">dma_dir</span> <span class="o">=</span> <span class="n">DMA_FROM_DEVICE</span><span class="p">;</span>

	<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">qc</span><span class="o">-&gt;</span><span class="n">cdb</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">qc</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">cdb_len</span><span class="p">);</span>
	<span class="n">qc</span><span class="o">-&gt;</span><span class="n">cdb</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">REQUEST_SENSE</span><span class="p">;</span>
	<span class="n">qc</span><span class="o">-&gt;</span><span class="n">cdb</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="n">SCSI_SENSE_BUFFERSIZE</span><span class="p">;</span>

	<span class="n">qc</span><span class="o">-&gt;</span><span class="n">tf</span><span class="p">.</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">ATA_TFLAG_ISADDR</span> <span class="o">|</span> <span class="n">ATA_TFLAG_DEVICE</span><span class="p">;</span>
	<span class="n">qc</span><span class="o">-&gt;</span><span class="n">tf</span><span class="p">.</span><span class="n">command</span> <span class="o">=</span> <span class="n">ATA_CMD_PACKET</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ata_pio_use_silly</span><span class="p">(</span><span class="n">ap</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">qc</span><span class="o">-&gt;</span><span class="n">tf</span><span class="p">.</span><span class="n">protocol</span> <span class="o">=</span> <span class="n">ATAPI_PROT_DMA</span><span class="p">;</span>
		<span class="n">qc</span><span class="o">-&gt;</span><span class="n">tf</span><span class="p">.</span><span class="n">feature</span> <span class="o">|=</span> <span class="n">ATAPI_PKT_DMA</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">qc</span><span class="o">-&gt;</span><span class="n">tf</span><span class="p">.</span><span class="n">protocol</span> <span class="o">=</span> <span class="n">ATAPI_PROT_PIO</span><span class="p">;</span>
		<span class="n">qc</span><span class="o">-&gt;</span><span class="n">tf</span><span class="p">.</span><span class="n">lbam</span> <span class="o">=</span> <span class="n">SCSI_SENSE_BUFFERSIZE</span><span class="p">;</span>
		<span class="n">qc</span><span class="o">-&gt;</span><span class="n">tf</span><span class="p">.</span><span class="n">lbah</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">qc</span><span class="o">-&gt;</span><span class="n">nbytes</span> <span class="o">=</span> <span class="n">SCSI_SENSE_BUFFERSIZE</span><span class="p">;</span>

	<span class="n">qc</span><span class="o">-&gt;</span><span class="n">complete_fn</span> <span class="o">=</span> <span class="n">atapi_sense_complete</span><span class="p">;</span>

	<span class="n">ata_qc_issue</span><span class="p">(</span><span class="n">qc</span><span class="p">);</span>

	<span class="n">DPRINTK</span><span class="p">(</span><span class="s">&quot;EXIT</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">atapi_qc_complete</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_queued_cmd</span> <span class="o">*</span><span class="n">qc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="n">cmd</span> <span class="o">=</span> <span class="n">qc</span><span class="o">-&gt;</span><span class="n">scsicmd</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">err_mask</span> <span class="o">=</span> <span class="n">qc</span><span class="o">-&gt;</span><span class="n">err_mask</span><span class="p">;</span>

	<span class="n">VPRINTK</span><span class="p">(</span><span class="s">&quot;ENTER, err_mask 0x%X</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">err_mask</span><span class="p">);</span>

	<span class="cm">/* handle completion from new EH */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">qc</span><span class="o">-&gt;</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">error_handler</span> <span class="o">&amp;&amp;</span>
		     <span class="p">(</span><span class="n">err_mask</span> <span class="o">||</span> <span class="n">qc</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">ATA_QCFLAG_SENSE_VALID</span><span class="p">)))</span> <span class="p">{</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">qc</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">ATA_QCFLAG_SENSE_VALID</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/* FIXME: not quite right; we don&#39;t want the</span>
<span class="cm">			 * translation of taskfile registers into a</span>
<span class="cm">			 * sense descriptors, since that&#39;s only</span>
<span class="cm">			 * correct for ATA, not ATAPI</span>
<span class="cm">			 */</span>
			<span class="n">ata_gen_passthru_sense</span><span class="p">(</span><span class="n">qc</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="cm">/* SCSI EH automatically locks door if sdev-&gt;locked is</span>
<span class="cm">		 * set.  Sometimes door lock request continues to</span>
<span class="cm">		 * fail, for example, when no media is present.  This</span>
<span class="cm">		 * creates a loop - SCSI EH issues door lock which</span>
<span class="cm">		 * fails and gets invoked again to acquire sense data</span>
<span class="cm">		 * for the failed command.</span>
<span class="cm">		 *</span>
<span class="cm">		 * If door lock fails, always clear sdev-&gt;locked to</span>
<span class="cm">		 * avoid this infinite loop.</span>
<span class="cm">		 *</span>
<span class="cm">		 * This may happen before SCSI scan is complete.  Make</span>
<span class="cm">		 * sure qc-&gt;dev-&gt;sdev isn&#39;t NULL before dereferencing.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">qc</span><span class="o">-&gt;</span><span class="n">cdb</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">ALLOW_MEDIUM_REMOVAL</span> <span class="o">&amp;&amp;</span> <span class="n">qc</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">sdev</span><span class="p">)</span>
			<span class="n">qc</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">locked</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="n">qc</span><span class="o">-&gt;</span><span class="n">scsicmd</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">=</span> <span class="n">SAM_STAT_CHECK_CONDITION</span><span class="p">;</span>
		<span class="n">qc</span><span class="o">-&gt;</span><span class="n">scsidone</span><span class="p">(</span><span class="n">cmd</span><span class="p">);</span>
		<span class="n">ata_qc_free</span><span class="p">(</span><span class="n">qc</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* successful completion or old EH failure path */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">err_mask</span> <span class="o">&amp;</span> <span class="n">AC_ERR_DEV</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">=</span> <span class="n">SAM_STAT_CHECK_CONDITION</span><span class="p">;</span>
		<span class="n">atapi_request_sense</span><span class="p">(</span><span class="n">qc</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">err_mask</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* FIXME: not quite right; we don&#39;t want the</span>
<span class="cm">		 * translation of taskfile registers into</span>
<span class="cm">		 * a sense descriptors, since that&#39;s only</span>
<span class="cm">		 * correct for ATA, not ATAPI</span>
<span class="cm">		 */</span>
		<span class="n">ata_gen_passthru_sense</span><span class="p">(</span><span class="n">qc</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">u8</span> <span class="o">*</span><span class="n">scsicmd</span> <span class="o">=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">((</span><span class="n">scsicmd</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">INQUIRY</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">((</span><span class="n">scsicmd</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0x03</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
			<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
			<span class="n">u8</span> <span class="o">*</span><span class="n">buf</span><span class="p">;</span>

			<span class="n">buf</span> <span class="o">=</span> <span class="n">ata_scsi_rbuf_get</span><span class="p">(</span><span class="n">cmd</span><span class="p">,</span> <span class="nb">true</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">flags</span><span class="p">);</span>

	<span class="cm">/* ATAPI devices typically report zero for their SCSI version,</span>
<span class="cm">	 * and sometimes deviate from the spec WRT response data</span>
<span class="cm">	 * format.  If SCSI version is reported as zero like normal,</span>
<span class="cm">	 * then we make the following fixups:  1) Fake MMC-5 version,</span>
<span class="cm">	 * to indicate to the Linux scsi midlayer this is a modern</span>
<span class="cm">	 * device.  2) Ensure response data format / ATAPI information</span>
<span class="cm">	 * are always correct.</span>
<span class="cm">	 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">buf</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">buf</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x5</span><span class="p">;</span>
				<span class="n">buf</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x32</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="n">ata_scsi_rbuf_put</span><span class="p">(</span><span class="n">cmd</span><span class="p">,</span> <span class="nb">true</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">flags</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">=</span> <span class="n">SAM_STAT_GOOD</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">qc</span><span class="o">-&gt;</span><span class="n">scsidone</span><span class="p">(</span><span class="n">cmd</span><span class="p">);</span>
	<span class="n">ata_qc_free</span><span class="p">(</span><span class="n">qc</span><span class="p">);</span>
<span class="p">}</span>
<span class="cm">/**</span>
<span class="cm"> *	atapi_xlat - Initialize PACKET taskfile</span>
<span class="cm"> *	@qc: command structure to be initialized</span>
<span class="cm"> *</span>
<span class="cm"> *	LOCKING:</span>
<span class="cm"> *	spin_lock_irqsave(host lock)</span>
<span class="cm"> *</span>
<span class="cm"> *	RETURNS:</span>
<span class="cm"> *	Zero on success, non-zero on failure.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">atapi_xlat</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_queued_cmd</span> <span class="o">*</span><span class="n">qc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="n">scmd</span> <span class="o">=</span> <span class="n">qc</span><span class="o">-&gt;</span><span class="n">scsicmd</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ata_device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">qc</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">nodata</span> <span class="o">=</span> <span class="p">(</span><span class="n">scmd</span><span class="o">-&gt;</span><span class="n">sc_data_direction</span> <span class="o">==</span> <span class="n">DMA_NONE</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">using_pio</span> <span class="o">=</span> <span class="o">!</span><span class="n">nodata</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">ATA_DFLAG_PIO</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">nbytes</span><span class="p">;</span>

	<span class="n">memset</span><span class="p">(</span><span class="n">qc</span><span class="o">-&gt;</span><span class="n">cdb</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">cdb_len</span><span class="p">);</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">qc</span><span class="o">-&gt;</span><span class="n">cdb</span><span class="p">,</span> <span class="n">scmd</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">,</span> <span class="n">scmd</span><span class="o">-&gt;</span><span class="n">cmd_len</span><span class="p">);</span>

	<span class="n">qc</span><span class="o">-&gt;</span><span class="n">complete_fn</span> <span class="o">=</span> <span class="n">atapi_qc_complete</span><span class="p">;</span>

	<span class="n">qc</span><span class="o">-&gt;</span><span class="n">tf</span><span class="p">.</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">ATA_TFLAG_ISADDR</span> <span class="o">|</span> <span class="n">ATA_TFLAG_DEVICE</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">scmd</span><span class="o">-&gt;</span><span class="n">sc_data_direction</span> <span class="o">==</span> <span class="n">DMA_TO_DEVICE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">qc</span><span class="o">-&gt;</span><span class="n">tf</span><span class="p">.</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">ATA_TFLAG_WRITE</span><span class="p">;</span>
		<span class="n">DPRINTK</span><span class="p">(</span><span class="s">&quot;direction: write</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">qc</span><span class="o">-&gt;</span><span class="n">tf</span><span class="p">.</span><span class="n">command</span> <span class="o">=</span> <span class="n">ATA_CMD_PACKET</span><span class="p">;</span>
	<span class="n">ata_qc_set_pc_nbytes</span><span class="p">(</span><span class="n">qc</span><span class="p">);</span>

	<span class="cm">/* check whether ATAPI DMA is safe */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">nodata</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">using_pio</span> <span class="o">&amp;&amp;</span> <span class="n">atapi_check_dma</span><span class="p">(</span><span class="n">qc</span><span class="p">))</span>
		<span class="n">using_pio</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/* Some controller variants snoop this value for Packet</span>
<span class="cm">	 * transfers to do state machine and FIFO management.  Thus we</span>
<span class="cm">	 * want to set it properly, and for DMA where it is</span>
<span class="cm">	 * effectively meaningless.</span>
<span class="cm">	 */</span>
	<span class="n">nbytes</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">ata_qc_raw_nbytes</span><span class="p">(</span><span class="n">qc</span><span class="p">),</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)</span><span class="mi">63</span> <span class="o">*</span> <span class="mi">1024</span><span class="p">);</span>

	<span class="cm">/* Most ATAPI devices which honor transfer chunk size don&#39;t</span>
<span class="cm">	 * behave according to the spec when odd chunk size which</span>
<span class="cm">	 * matches the transfer length is specified.  If the number of</span>
<span class="cm">	 * bytes to transfer is 2n+1.  According to the spec, what</span>
<span class="cm">	 * should happen is to indicate that 2n+1 is going to be</span>
<span class="cm">	 * transferred and transfer 2n+2 bytes where the last byte is</span>
<span class="cm">	 * padding.</span>
<span class="cm">	 *</span>
<span class="cm">	 * In practice, this doesn&#39;t happen.  ATAPI devices first</span>
<span class="cm">	 * indicate and transfer 2n bytes and then indicate and</span>
<span class="cm">	 * transfer 2 bytes where the last byte is padding.</span>
<span class="cm">	 *</span>
<span class="cm">	 * This inconsistency confuses several controllers which</span>
<span class="cm">	 * perform PIO using DMA such as Intel AHCIs and sil3124/32.</span>
<span class="cm">	 * These controllers use actual number of transferred bytes to</span>
<span class="cm">	 * update DMA poitner and transfer of 4n+2 bytes make those</span>
<span class="cm">	 * controller push DMA pointer by 4n+4 bytes because SATA data</span>
<span class="cm">	 * FISes are aligned to 4 bytes.  This causes data corruption</span>
<span class="cm">	 * and buffer overrun.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Always setting nbytes to even number solves this problem</span>
<span class="cm">	 * because then ATAPI devices don&#39;t have to split data at 2n</span>
<span class="cm">	 * boundaries.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nbytes</span> <span class="o">&amp;</span> <span class="mh">0x1</span><span class="p">)</span>
		<span class="n">nbytes</span><span class="o">++</span><span class="p">;</span>

	<span class="n">qc</span><span class="o">-&gt;</span><span class="n">tf</span><span class="p">.</span><span class="n">lbam</span> <span class="o">=</span> <span class="p">(</span><span class="n">nbytes</span> <span class="o">&amp;</span> <span class="mh">0xFF</span><span class="p">);</span>
	<span class="n">qc</span><span class="o">-&gt;</span><span class="n">tf</span><span class="p">.</span><span class="n">lbah</span> <span class="o">=</span> <span class="p">(</span><span class="n">nbytes</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">nodata</span><span class="p">)</span>
		<span class="n">qc</span><span class="o">-&gt;</span><span class="n">tf</span><span class="p">.</span><span class="n">protocol</span> <span class="o">=</span> <span class="n">ATAPI_PROT_NODATA</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">using_pio</span><span class="p">)</span>
		<span class="n">qc</span><span class="o">-&gt;</span><span class="n">tf</span><span class="p">.</span><span class="n">protocol</span> <span class="o">=</span> <span class="n">ATAPI_PROT_PIO</span><span class="p">;</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* DMA data xfer */</span>
		<span class="n">qc</span><span class="o">-&gt;</span><span class="n">tf</span><span class="p">.</span><span class="n">protocol</span> <span class="o">=</span> <span class="n">ATAPI_PROT_DMA</span><span class="p">;</span>
		<span class="n">qc</span><span class="o">-&gt;</span><span class="n">tf</span><span class="p">.</span><span class="n">feature</span> <span class="o">|=</span> <span class="n">ATAPI_PKT_DMA</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">((</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">ATA_DFLAG_DMADIR</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="p">(</span><span class="n">scmd</span><span class="o">-&gt;</span><span class="n">sc_data_direction</span> <span class="o">!=</span> <span class="n">DMA_TO_DEVICE</span><span class="p">))</span>
			<span class="cm">/* some SATA bridges need us to indicate data xfer direction */</span>
			<span class="n">qc</span><span class="o">-&gt;</span><span class="n">tf</span><span class="p">.</span><span class="n">feature</span> <span class="o">|=</span> <span class="n">ATAPI_DMADIR</span><span class="p">;</span>
	<span class="p">}</span>


	<span class="cm">/* FIXME: We need to translate 0x05 READ_BLOCK_LIMITS to a MODE_SENSE</span>
<span class="cm">	   as ATAPI tape drives don&#39;t get this right otherwise */</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">ata_device</span> <span class="o">*</span><span class="nf">ata_find_dev</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span><span class="p">,</span> <span class="kt">int</span> <span class="n">devno</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sata_pmp_attached</span><span class="p">(</span><span class="n">ap</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">devno</span> <span class="o">&lt;</span> <span class="n">ata_link_max_devices</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">link</span><span class="p">)))</span>
			<span class="k">return</span> <span class="o">&amp;</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">link</span><span class="p">.</span><span class="n">device</span><span class="p">[</span><span class="n">devno</span><span class="p">];</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">devno</span> <span class="o">&lt;</span> <span class="n">ap</span><span class="o">-&gt;</span><span class="n">nr_pmp_links</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">&amp;</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">pmp_link</span><span class="p">[</span><span class="n">devno</span><span class="p">].</span><span class="n">device</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">ata_device</span> <span class="o">*</span><span class="nf">__ata_scsi_find_dev</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span><span class="p">,</span>
					      <span class="k">const</span> <span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="n">scsidev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">devno</span><span class="p">;</span>

	<span class="cm">/* skip commands not addressed to targets we simulate */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sata_pmp_attached</span><span class="p">(</span><span class="n">ap</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">scsidev</span><span class="o">-&gt;</span><span class="n">channel</span> <span class="o">||</span> <span class="n">scsidev</span><span class="o">-&gt;</span><span class="n">lun</span><span class="p">))</span>
			<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">devno</span> <span class="o">=</span> <span class="n">scsidev</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">scsidev</span><span class="o">-&gt;</span><span class="n">id</span> <span class="o">||</span> <span class="n">scsidev</span><span class="o">-&gt;</span><span class="n">lun</span><span class="p">))</span>
			<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">devno</span> <span class="o">=</span> <span class="n">scsidev</span><span class="o">-&gt;</span><span class="n">channel</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">ata_find_dev</span><span class="p">(</span><span class="n">ap</span><span class="p">,</span> <span class="n">devno</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	ata_scsi_find_dev - lookup ata_device from scsi_cmnd</span>
<span class="cm"> *	@ap: ATA port to which the device is attached</span>
<span class="cm"> *	@scsidev: SCSI device from which we derive the ATA device</span>
<span class="cm"> *</span>
<span class="cm"> *	Given various information provided in struct scsi_cmnd,</span>
<span class="cm"> *	map that onto an ATA bus, and using that mapping</span>
<span class="cm"> *	determine which ata_device is associated with the</span>
<span class="cm"> *	SCSI command to be sent.</span>
<span class="cm"> *</span>
<span class="cm"> *	LOCKING:</span>
<span class="cm"> *	spin_lock_irqsave(host lock)</span>
<span class="cm"> *</span>
<span class="cm"> *	RETURNS:</span>
<span class="cm"> *	Associated ATA device, or %NULL if not found.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">ata_device</span> <span class="o">*</span>
<span class="nf">ata_scsi_find_dev</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="n">scsidev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ata_device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">__ata_scsi_find_dev</span><span class="p">(</span><span class="n">ap</span><span class="p">,</span> <span class="n">scsidev</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">dev</span> <span class="o">||</span> <span class="o">!</span><span class="n">ata_dev_enabled</span><span class="p">(</span><span class="n">dev</span><span class="p">)))</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">dev</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *	ata_scsi_map_proto - Map pass-thru protocol value to taskfile value.</span>
<span class="cm"> *	@byte1: Byte 1 from pass-thru CDB.</span>
<span class="cm"> *</span>
<span class="cm"> *	RETURNS:</span>
<span class="cm"> *	ATA_PROT_UNKNOWN if mapping failed/unimplemented, protocol otherwise.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">u8</span>
<span class="nf">ata_scsi_map_proto</span><span class="p">(</span><span class="n">u8</span> <span class="n">byte1</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">switch</span><span class="p">((</span><span class="n">byte1</span> <span class="o">&amp;</span> <span class="mh">0x1e</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="mi">3</span>:		<span class="cm">/* Non-data */</span>
		<span class="k">return</span> <span class="n">ATA_PROT_NODATA</span><span class="p">;</span>

	<span class="k">case</span> <span class="mi">6</span>:		<span class="cm">/* DMA */</span>
	<span class="k">case</span> <span class="mi">10</span>:	<span class="cm">/* UDMA Data-in */</span>
	<span class="k">case</span> <span class="mi">11</span>:	<span class="cm">/* UDMA Data-Out */</span>
		<span class="k">return</span> <span class="n">ATA_PROT_DMA</span><span class="p">;</span>

	<span class="k">case</span> <span class="mi">4</span>:		<span class="cm">/* PIO Data-in */</span>
	<span class="k">case</span> <span class="mi">5</span>:		<span class="cm">/* PIO Data-out */</span>
		<span class="k">return</span> <span class="n">ATA_PROT_PIO</span><span class="p">;</span>

	<span class="k">case</span> <span class="mi">0</span>:		<span class="cm">/* Hard Reset */</span>
	<span class="k">case</span> <span class="mi">1</span>:		<span class="cm">/* SRST */</span>
	<span class="k">case</span> <span class="mi">8</span>:		<span class="cm">/* Device Diagnostic */</span>
	<span class="k">case</span> <span class="mi">9</span>:		<span class="cm">/* Device Reset */</span>
	<span class="k">case</span> <span class="mi">7</span>:		<span class="cm">/* DMA Queued */</span>
	<span class="k">case</span> <span class="mi">12</span>:	<span class="cm">/* FPDMA */</span>
	<span class="k">case</span> <span class="mi">15</span>:	<span class="cm">/* Return Response Info */</span>
	<span class="nl">default:</span>	<span class="cm">/* Reserved */</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">ATA_PROT_UNKNOWN</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	ata_scsi_pass_thru - convert ATA pass-thru CDB to taskfile</span>
<span class="cm"> *	@qc: command structure to be initialized</span>
<span class="cm"> *</span>
<span class="cm"> *	Handles either 12 or 16-byte versions of the CDB.</span>
<span class="cm"> *</span>
<span class="cm"> *	RETURNS:</span>
<span class="cm"> *	Zero on success, non-zero on failure.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">ata_scsi_pass_thru</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_queued_cmd</span> <span class="o">*</span><span class="n">qc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ata_taskfile</span> <span class="o">*</span><span class="n">tf</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">qc</span><span class="o">-&gt;</span><span class="n">tf</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="n">scmd</span> <span class="o">=</span> <span class="n">qc</span><span class="o">-&gt;</span><span class="n">scsicmd</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ata_device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">qc</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>
	<span class="k">const</span> <span class="n">u8</span> <span class="o">*</span><span class="n">cdb</span> <span class="o">=</span> <span class="n">scmd</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">tf</span><span class="o">-&gt;</span><span class="n">protocol</span> <span class="o">=</span> <span class="n">ata_scsi_map_proto</span><span class="p">(</span><span class="n">cdb</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span> <span class="o">==</span> <span class="n">ATA_PROT_UNKNOWN</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">invalid_fld</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * 12 and 16 byte CDBs use different offsets to</span>
<span class="cm">	 * provide the various register values.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cdb</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">ATA_16</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * 16-byte CDB - may contain extended commands.</span>
<span class="cm">		 *</span>
<span class="cm">		 * If that is the case, copy the upper byte register values.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cdb</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0x01</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">tf</span><span class="o">-&gt;</span><span class="n">hob_feature</span> <span class="o">=</span> <span class="n">cdb</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
			<span class="n">tf</span><span class="o">-&gt;</span><span class="n">hob_nsect</span> <span class="o">=</span> <span class="n">cdb</span><span class="p">[</span><span class="mi">5</span><span class="p">];</span>
			<span class="n">tf</span><span class="o">-&gt;</span><span class="n">hob_lbal</span> <span class="o">=</span> <span class="n">cdb</span><span class="p">[</span><span class="mi">7</span><span class="p">];</span>
			<span class="n">tf</span><span class="o">-&gt;</span><span class="n">hob_lbam</span> <span class="o">=</span> <span class="n">cdb</span><span class="p">[</span><span class="mi">9</span><span class="p">];</span>
			<span class="n">tf</span><span class="o">-&gt;</span><span class="n">hob_lbah</span> <span class="o">=</span> <span class="n">cdb</span><span class="p">[</span><span class="mi">11</span><span class="p">];</span>
			<span class="n">tf</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">ATA_TFLAG_LBA48</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="n">tf</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">ATA_TFLAG_LBA48</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * Always copy low byte, device and command registers.</span>
<span class="cm">		 */</span>
		<span class="n">tf</span><span class="o">-&gt;</span><span class="n">feature</span> <span class="o">=</span> <span class="n">cdb</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
		<span class="n">tf</span><span class="o">-&gt;</span><span class="n">nsect</span> <span class="o">=</span> <span class="n">cdb</span><span class="p">[</span><span class="mi">6</span><span class="p">];</span>
		<span class="n">tf</span><span class="o">-&gt;</span><span class="n">lbal</span> <span class="o">=</span> <span class="n">cdb</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span>
		<span class="n">tf</span><span class="o">-&gt;</span><span class="n">lbam</span> <span class="o">=</span> <span class="n">cdb</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span>
		<span class="n">tf</span><span class="o">-&gt;</span><span class="n">lbah</span> <span class="o">=</span> <span class="n">cdb</span><span class="p">[</span><span class="mi">12</span><span class="p">];</span>
		<span class="n">tf</span><span class="o">-&gt;</span><span class="n">device</span> <span class="o">=</span> <span class="n">cdb</span><span class="p">[</span><span class="mi">13</span><span class="p">];</span>
		<span class="n">tf</span><span class="o">-&gt;</span><span class="n">command</span> <span class="o">=</span> <span class="n">cdb</span><span class="p">[</span><span class="mi">14</span><span class="p">];</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * 12-byte CDB - incapable of extended commands.</span>
<span class="cm">		 */</span>
		<span class="n">tf</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">ATA_TFLAG_LBA48</span><span class="p">;</span>

		<span class="n">tf</span><span class="o">-&gt;</span><span class="n">feature</span> <span class="o">=</span> <span class="n">cdb</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
		<span class="n">tf</span><span class="o">-&gt;</span><span class="n">nsect</span> <span class="o">=</span> <span class="n">cdb</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
		<span class="n">tf</span><span class="o">-&gt;</span><span class="n">lbal</span> <span class="o">=</span> <span class="n">cdb</span><span class="p">[</span><span class="mi">5</span><span class="p">];</span>
		<span class="n">tf</span><span class="o">-&gt;</span><span class="n">lbam</span> <span class="o">=</span> <span class="n">cdb</span><span class="p">[</span><span class="mi">6</span><span class="p">];</span>
		<span class="n">tf</span><span class="o">-&gt;</span><span class="n">lbah</span> <span class="o">=</span> <span class="n">cdb</span><span class="p">[</span><span class="mi">7</span><span class="p">];</span>
		<span class="n">tf</span><span class="o">-&gt;</span><span class="n">device</span> <span class="o">=</span> <span class="n">cdb</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span>
		<span class="n">tf</span><span class="o">-&gt;</span><span class="n">command</span> <span class="o">=</span> <span class="n">cdb</span><span class="p">[</span><span class="mi">9</span><span class="p">];</span>
	<span class="p">}</span>

	<span class="cm">/* enforce correct master/slave bit */</span>
	<span class="n">tf</span><span class="o">-&gt;</span><span class="n">device</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">devno</span> <span class="o">?</span>
		<span class="n">tf</span><span class="o">-&gt;</span><span class="n">device</span> <span class="o">|</span> <span class="n">ATA_DEV1</span> <span class="o">:</span> <span class="n">tf</span><span class="o">-&gt;</span><span class="n">device</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">ATA_DEV1</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">tf</span><span class="o">-&gt;</span><span class="n">command</span><span class="p">)</span> <span class="p">{</span>
	<span class="cm">/* READ/WRITE LONG use a non-standard sect_size */</span>
	<span class="k">case</span> <span class="n">ATA_CMD_READ_LONG</span>:
	<span class="k">case</span> <span class="n">ATA_CMD_READ_LONG_ONCE</span>:
	<span class="k">case</span> <span class="n">ATA_CMD_WRITE_LONG</span>:
	<span class="k">case</span> <span class="n">ATA_CMD_WRITE_LONG_ONCE</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">tf</span><span class="o">-&gt;</span><span class="n">protocol</span> <span class="o">!=</span> <span class="n">ATA_PROT_PIO</span> <span class="o">||</span> <span class="n">tf</span><span class="o">-&gt;</span><span class="n">nsect</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">invalid_fld</span><span class="p">;</span>
		<span class="n">qc</span><span class="o">-&gt;</span><span class="n">sect_size</span> <span class="o">=</span> <span class="n">scsi_bufflen</span><span class="p">(</span><span class="n">scmd</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="cm">/* commands using reported Logical Block size (e.g. 512 or 4K) */</span>
	<span class="k">case</span> <span class="n">ATA_CMD_CFA_WRITE_NE</span>:
	<span class="k">case</span> <span class="n">ATA_CMD_CFA_TRANS_SECT</span>:
	<span class="k">case</span> <span class="n">ATA_CMD_CFA_WRITE_MULT_NE</span>:
	<span class="cm">/* XXX: case ATA_CMD_CFA_WRITE_SECTORS_WITHOUT_ERASE: */</span>
	<span class="k">case</span> <span class="n">ATA_CMD_READ</span>:
	<span class="k">case</span> <span class="n">ATA_CMD_READ_EXT</span>:
	<span class="k">case</span> <span class="n">ATA_CMD_READ_QUEUED</span>:
	<span class="cm">/* XXX: case ATA_CMD_READ_QUEUED_EXT: */</span>
	<span class="k">case</span> <span class="n">ATA_CMD_FPDMA_READ</span>:
	<span class="k">case</span> <span class="n">ATA_CMD_READ_MULTI</span>:
	<span class="k">case</span> <span class="n">ATA_CMD_READ_MULTI_EXT</span>:
	<span class="k">case</span> <span class="n">ATA_CMD_PIO_READ</span>:
	<span class="k">case</span> <span class="n">ATA_CMD_PIO_READ_EXT</span>:
	<span class="k">case</span> <span class="n">ATA_CMD_READ_STREAM_DMA_EXT</span>:
	<span class="k">case</span> <span class="n">ATA_CMD_READ_STREAM_EXT</span>:
	<span class="k">case</span> <span class="n">ATA_CMD_VERIFY</span>:
	<span class="k">case</span> <span class="n">ATA_CMD_VERIFY_EXT</span>:
	<span class="k">case</span> <span class="n">ATA_CMD_WRITE</span>:
	<span class="k">case</span> <span class="n">ATA_CMD_WRITE_EXT</span>:
	<span class="k">case</span> <span class="n">ATA_CMD_WRITE_FUA_EXT</span>:
	<span class="k">case</span> <span class="n">ATA_CMD_WRITE_QUEUED</span>:
	<span class="k">case</span> <span class="n">ATA_CMD_WRITE_QUEUED_FUA_EXT</span>:
	<span class="k">case</span> <span class="n">ATA_CMD_FPDMA_WRITE</span>:
	<span class="k">case</span> <span class="n">ATA_CMD_WRITE_MULTI</span>:
	<span class="k">case</span> <span class="n">ATA_CMD_WRITE_MULTI_EXT</span>:
	<span class="k">case</span> <span class="n">ATA_CMD_WRITE_MULTI_FUA_EXT</span>:
	<span class="k">case</span> <span class="n">ATA_CMD_PIO_WRITE</span>:
	<span class="k">case</span> <span class="n">ATA_CMD_PIO_WRITE_EXT</span>:
	<span class="k">case</span> <span class="n">ATA_CMD_WRITE_STREAM_DMA_EXT</span>:
	<span class="k">case</span> <span class="n">ATA_CMD_WRITE_STREAM_EXT</span>:
		<span class="n">qc</span><span class="o">-&gt;</span><span class="n">sect_size</span> <span class="o">=</span> <span class="n">scmd</span><span class="o">-&gt;</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">sector_size</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="cm">/* Everything else uses 512 byte &quot;sectors&quot; */</span>
	<span class="nl">default:</span>
		<span class="n">qc</span><span class="o">-&gt;</span><span class="n">sect_size</span> <span class="o">=</span> <span class="n">ATA_SECT_SIZE</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Set flags so that all registers will be written, pass on</span>
<span class="cm">	 * write indication (used for PIO/DMA setup), result TF is</span>
<span class="cm">	 * copied back and we don&#39;t whine too much about its failure.</span>
<span class="cm">	 */</span>
	<span class="n">tf</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">ATA_TFLAG_ISADDR</span> <span class="o">|</span> <span class="n">ATA_TFLAG_DEVICE</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">scmd</span><span class="o">-&gt;</span><span class="n">sc_data_direction</span> <span class="o">==</span> <span class="n">DMA_TO_DEVICE</span><span class="p">)</span>
		<span class="n">tf</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">ATA_TFLAG_WRITE</span><span class="p">;</span>

	<span class="n">qc</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">ATA_QCFLAG_RESULT_TF</span> <span class="o">|</span> <span class="n">ATA_QCFLAG_QUIET</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Set transfer length.</span>
<span class="cm">	 *</span>
<span class="cm">	 * TODO: find out if we need to do more here to</span>
<span class="cm">	 *       cover scatter/gather case.</span>
<span class="cm">	 */</span>
	<span class="n">ata_qc_set_pc_nbytes</span><span class="p">(</span><span class="n">qc</span><span class="p">);</span>

	<span class="cm">/* We may not issue DMA commands if no DMA mode is set */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tf</span><span class="o">-&gt;</span><span class="n">protocol</span> <span class="o">==</span> <span class="n">ATA_PROT_DMA</span> <span class="o">&amp;&amp;</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">dma_mode</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">invalid_fld</span><span class="p">;</span>

	<span class="cm">/* sanity check for pio multi commands */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">cdb</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0xe0</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">is_multi_taskfile</span><span class="p">(</span><span class="n">tf</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">invalid_fld</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">is_multi_taskfile</span><span class="p">(</span><span class="n">tf</span><span class="p">))</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">multi_count</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">cdb</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;&gt;</span> <span class="mi">5</span><span class="p">);</span>

		<span class="cm">/* compare the passed through multi_count</span>
<span class="cm">		 * with the cached multi_count of libata</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">multi_count</span> <span class="o">!=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">multi_count</span><span class="p">)</span>
			<span class="n">ata_dev_warn</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;invalid multi_count %u ignored</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				     <span class="n">multi_count</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Filter SET_FEATURES - XFER MODE command -- otherwise,</span>
<span class="cm">	 * SET_FEATURES - XFER MODE must be preceded/succeeded</span>
<span class="cm">	 * by an update to hardware-specific registers for each</span>
<span class="cm">	 * controller (i.e. the reason for -&gt;set_piomode(),</span>
<span class="cm">	 * -&gt;set_dmamode(), and -&gt;post_set_mode() hooks).</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tf</span><span class="o">-&gt;</span><span class="n">command</span> <span class="o">==</span> <span class="n">ATA_CMD_SET_FEATURES</span> <span class="o">&amp;&amp;</span>
	    <span class="n">tf</span><span class="o">-&gt;</span><span class="n">feature</span> <span class="o">==</span> <span class="n">SETFEATURES_XFER</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">invalid_fld</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Filter TPM commands by default. These provide an</span>
<span class="cm">	 * essentially uncontrolled encrypted &quot;back door&quot; between</span>
<span class="cm">	 * applications and the disk. Set libata.allow_tpm=1 if you</span>
<span class="cm">	 * have a real reason for wanting to use them. This ensures</span>
<span class="cm">	 * that installed software cannot easily mess stuff up without</span>
<span class="cm">	 * user intent. DVR type users will probably ship with this enabled</span>
<span class="cm">	 * for movie content management.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Note that for ATA8 we can issue a DCS change and DCS freeze lock</span>
<span class="cm">	 * for this and should do in future but that it is not sufficient as</span>
<span class="cm">	 * DCS is an optional feature set. Thus we also do the software filter</span>
<span class="cm">	 * so that we comply with the TC consortium stated goal that the user</span>
<span class="cm">	 * can turn off TC features of their system.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tf</span><span class="o">-&gt;</span><span class="n">command</span> <span class="o">&gt;=</span> <span class="mh">0x5C</span> <span class="o">&amp;&amp;</span> <span class="n">tf</span><span class="o">-&gt;</span><span class="n">command</span> <span class="o">&lt;=</span> <span class="mh">0x5F</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">libata_allow_tpm</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">invalid_fld</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

 <span class="nl">invalid_fld:</span>
	<span class="n">ata_scsi_set_sense</span><span class="p">(</span><span class="n">scmd</span><span class="p">,</span> <span class="n">ILLEGAL_REQUEST</span><span class="p">,</span> <span class="mh">0x24</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">);</span>
	<span class="cm">/* &quot;Invalid field in cdb&quot; */</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">ata_scsi_write_same_xlat</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_queued_cmd</span> <span class="o">*</span><span class="n">qc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ata_taskfile</span> <span class="o">*</span><span class="n">tf</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">qc</span><span class="o">-&gt;</span><span class="n">tf</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="n">scmd</span> <span class="o">=</span> <span class="n">qc</span><span class="o">-&gt;</span><span class="n">scsicmd</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ata_device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">qc</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>
	<span class="k">const</span> <span class="n">u8</span> <span class="o">*</span><span class="n">cdb</span> <span class="o">=</span> <span class="n">scmd</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">block</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">n_block</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">size</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">buf</span><span class="p">;</span>

	<span class="cm">/* we may not issue DMA commands if no DMA mode is set */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dma_mode</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">invalid_fld</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">scmd</span><span class="o">-&gt;</span><span class="n">cmd_len</span> <span class="o">&lt;</span> <span class="mi">16</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">invalid_fld</span><span class="p">;</span>
	<span class="n">scsi_16_lba_len</span><span class="p">(</span><span class="n">cdb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">block</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">n_block</span><span class="p">);</span>

	<span class="cm">/* for now we only support WRITE SAME with the unmap bit set */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">cdb</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0x8</span><span class="p">)))</span>
		<span class="k">goto</span> <span class="n">invalid_fld</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * WRITE SAME always has a sector sized buffer as payload, this</span>
<span class="cm">	 * should never be a multiple entry S/G list.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">scsi_sg_count</span><span class="p">(</span><span class="n">scmd</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">invalid_fld</span><span class="p">;</span>

	<span class="n">buf</span> <span class="o">=</span> <span class="n">page_address</span><span class="p">(</span><span class="n">sg_page</span><span class="p">(</span><span class="n">scsi_sglist</span><span class="p">(</span><span class="n">scmd</span><span class="p">)));</span>
	<span class="n">size</span> <span class="o">=</span> <span class="n">ata_set_lba_range_entries</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="mi">512</span><span class="p">,</span> <span class="n">block</span><span class="p">,</span> <span class="n">n_block</span><span class="p">);</span>

	<span class="n">tf</span><span class="o">-&gt;</span><span class="n">protocol</span> <span class="o">=</span> <span class="n">ATA_PROT_DMA</span><span class="p">;</span>
	<span class="n">tf</span><span class="o">-&gt;</span><span class="n">hob_feature</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">tf</span><span class="o">-&gt;</span><span class="n">feature</span> <span class="o">=</span> <span class="n">ATA_DSM_TRIM</span><span class="p">;</span>
	<span class="n">tf</span><span class="o">-&gt;</span><span class="n">hob_nsect</span> <span class="o">=</span> <span class="p">(</span><span class="n">size</span> <span class="o">/</span> <span class="mi">512</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">;</span>
	<span class="n">tf</span><span class="o">-&gt;</span><span class="n">nsect</span> <span class="o">=</span> <span class="n">size</span> <span class="o">/</span> <span class="mi">512</span><span class="p">;</span>
	<span class="n">tf</span><span class="o">-&gt;</span><span class="n">command</span> <span class="o">=</span> <span class="n">ATA_CMD_DSM</span><span class="p">;</span>
	<span class="n">tf</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">ATA_TFLAG_ISADDR</span> <span class="o">|</span> <span class="n">ATA_TFLAG_DEVICE</span> <span class="o">|</span> <span class="n">ATA_TFLAG_LBA48</span> <span class="o">|</span>
		     <span class="n">ATA_TFLAG_WRITE</span><span class="p">;</span>

	<span class="n">ata_qc_set_pc_nbytes</span><span class="p">(</span><span class="n">qc</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

 <span class="nl">invalid_fld:</span>
	<span class="n">ata_scsi_set_sense</span><span class="p">(</span><span class="n">scmd</span><span class="p">,</span> <span class="n">ILLEGAL_REQUEST</span><span class="p">,</span> <span class="mh">0x24</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">);</span>
	<span class="cm">/* &quot;Invalid field in cdb&quot; */</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	ata_get_xlat_func - check if SCSI to ATA translation is possible</span>
<span class="cm"> *	@dev: ATA device</span>
<span class="cm"> *	@cmd: SCSI command opcode to consider</span>
<span class="cm"> *</span>
<span class="cm"> *	Look up the SCSI command given, and determine whether the</span>
<span class="cm"> *	SCSI command is to be translated or simulated.</span>
<span class="cm"> *</span>
<span class="cm"> *	RETURNS:</span>
<span class="cm"> *	Pointer to translation function if possible, %NULL if not.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">ata_xlat_func_t</span> <span class="nf">ata_get_xlat_func</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="n">u8</span> <span class="n">cmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">cmd</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">READ_6</span>:
	<span class="k">case</span> <span class="n">READ_10</span>:
	<span class="k">case</span> <span class="n">READ_16</span>:

	<span class="k">case</span> <span class="n">WRITE_6</span>:
	<span class="k">case</span> <span class="n">WRITE_10</span>:
	<span class="k">case</span> <span class="n">WRITE_16</span>:
		<span class="k">return</span> <span class="n">ata_scsi_rw_xlat</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">WRITE_SAME_16</span>:
		<span class="k">return</span> <span class="n">ata_scsi_write_same_xlat</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">SYNCHRONIZE_CACHE</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">ata_try_flush_cache</span><span class="p">(</span><span class="n">dev</span><span class="p">))</span>
			<span class="k">return</span> <span class="n">ata_scsi_flush_xlat</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">VERIFY</span>:
	<span class="k">case</span> <span class="n">VERIFY_16</span>:
		<span class="k">return</span> <span class="n">ata_scsi_verify_xlat</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">ATA_12</span>:
	<span class="k">case</span> <span class="n">ATA_16</span>:
		<span class="k">return</span> <span class="n">ata_scsi_pass_thru</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">START_STOP</span>:
		<span class="k">return</span> <span class="n">ata_scsi_start_stop_xlat</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	ata_scsi_dump_cdb - dump SCSI command contents to dmesg</span>
<span class="cm"> *	@ap: ATA port to which the command was being sent</span>
<span class="cm"> *	@cmd: SCSI command to dump</span>
<span class="cm"> *</span>
<span class="cm"> *	Prints the contents of a SCSI command via printk().</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">ata_scsi_dump_cdb</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span><span class="p">,</span>
				     <span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef ATA_DEBUG</span>
	<span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="n">scsidev</span> <span class="o">=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">device</span><span class="p">;</span>
	<span class="n">u8</span> <span class="o">*</span><span class="n">scsicmd</span> <span class="o">=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">;</span>

	<span class="n">DPRINTK</span><span class="p">(</span><span class="s">&quot;CDB (%u:%d,%d,%d) %02x %02x %02x %02x %02x %02x %02x %02x %02x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">ap</span><span class="o">-&gt;</span><span class="n">print_id</span><span class="p">,</span>
		<span class="n">scsidev</span><span class="o">-&gt;</span><span class="n">channel</span><span class="p">,</span> <span class="n">scsidev</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">,</span> <span class="n">scsidev</span><span class="o">-&gt;</span><span class="n">lun</span><span class="p">,</span>
		<span class="n">scsicmd</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">scsicmd</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">scsicmd</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">scsicmd</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span>
		<span class="n">scsicmd</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span> <span class="n">scsicmd</span><span class="p">[</span><span class="mi">5</span><span class="p">],</span> <span class="n">scsicmd</span><span class="p">[</span><span class="mi">6</span><span class="p">],</span> <span class="n">scsicmd</span><span class="p">[</span><span class="mi">7</span><span class="p">],</span>
		<span class="n">scsicmd</span><span class="p">[</span><span class="mi">8</span><span class="p">]);</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">__ata_scsi_queuecmd</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="n">scmd</span><span class="p">,</span>
				      <span class="k">struct</span> <span class="n">ata_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u8</span> <span class="n">scsi_op</span> <span class="o">=</span> <span class="n">scmd</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="n">ata_xlat_func_t</span> <span class="n">xlat_func</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">class</span> <span class="o">==</span> <span class="n">ATA_DEV_ATA</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">scmd</span><span class="o">-&gt;</span><span class="n">cmd_len</span> <span class="o">||</span> <span class="n">scmd</span><span class="o">-&gt;</span><span class="n">cmd_len</span> <span class="o">&gt;</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">cdb_len</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">bad_cdb_len</span><span class="p">;</span>

		<span class="n">xlat_func</span> <span class="o">=</span> <span class="n">ata_get_xlat_func</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">scsi_op</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">scmd</span><span class="o">-&gt;</span><span class="n">cmd_len</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">bad_cdb_len</span><span class="p">;</span>

		<span class="n">xlat_func</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">((</span><span class="n">scsi_op</span> <span class="o">!=</span> <span class="n">ATA_16</span><span class="p">)</span> <span class="o">||</span> <span class="o">!</span><span class="n">atapi_passthru16</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/* relay SCSI command to ATAPI device */</span>
			<span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="n">COMMAND_SIZE</span><span class="p">(</span><span class="n">scsi_op</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">len</span> <span class="o">&gt;</span> <span class="n">scmd</span><span class="o">-&gt;</span><span class="n">cmd_len</span> <span class="o">||</span> <span class="n">len</span> <span class="o">&gt;</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">cdb_len</span><span class="p">))</span>
				<span class="k">goto</span> <span class="n">bad_cdb_len</span><span class="p">;</span>

			<span class="n">xlat_func</span> <span class="o">=</span> <span class="n">atapi_xlat</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/* ATA_16 passthru, treat as an ATA command */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">scmd</span><span class="o">-&gt;</span><span class="n">cmd_len</span> <span class="o">&gt;</span> <span class="mi">16</span><span class="p">))</span>
				<span class="k">goto</span> <span class="n">bad_cdb_len</span><span class="p">;</span>

			<span class="n">xlat_func</span> <span class="o">=</span> <span class="n">ata_get_xlat_func</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">scsi_op</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">xlat_func</span><span class="p">)</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">ata_scsi_translate</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">scmd</span><span class="p">,</span> <span class="n">xlat_func</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">ata_scsi_simulate</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">scmd</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>

 <span class="nl">bad_cdb_len:</span>
	<span class="n">DPRINTK</span><span class="p">(</span><span class="s">&quot;bad CDB len=%u, scsi_op=0x%02x, max=%u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">scmd</span><span class="o">-&gt;</span><span class="n">cmd_len</span><span class="p">,</span> <span class="n">scsi_op</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">cdb_len</span><span class="p">);</span>
	<span class="n">scmd</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">=</span> <span class="n">DID_ERROR</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">;</span>
	<span class="n">scmd</span><span class="o">-&gt;</span><span class="n">scsi_done</span><span class="p">(</span><span class="n">scmd</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	ata_scsi_queuecmd - Issue SCSI cdb to libata-managed device</span>
<span class="cm"> *	@shost: SCSI host of command to be sent</span>
<span class="cm"> *	@cmd: SCSI command to be sent</span>
<span class="cm"> *</span>
<span class="cm"> *	In some cases, this function translates SCSI commands into</span>
<span class="cm"> *	ATA taskfiles, and queues the taskfiles to be sent to</span>
<span class="cm"> *	hardware.  In other cases, this function simulates a</span>
<span class="cm"> *	SCSI device by evaluating and responding to certain</span>
<span class="cm"> *	SCSI commands.  This creates the overall effect of</span>
<span class="cm"> *	ATA and ATAPI devices appearing as SCSI devices.</span>
<span class="cm"> *</span>
<span class="cm"> *	LOCKING:</span>
<span class="cm"> *	ATA host lock</span>
<span class="cm"> *</span>
<span class="cm"> *	RETURNS:</span>
<span class="cm"> *	Return value from __ata_scsi_queuecmd() if @cmd can be queued,</span>
<span class="cm"> *	0 otherwise.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">ata_scsi_queuecmd</span><span class="p">(</span><span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span><span class="p">,</span> <span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ata_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="n">scsidev</span> <span class="o">=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">device</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">irq_flags</span><span class="p">;</span>

	<span class="n">ap</span> <span class="o">=</span> <span class="n">ata_shost_to_port</span><span class="p">(</span><span class="n">shost</span><span class="p">);</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">irq_flags</span><span class="p">);</span>

	<span class="n">ata_scsi_dump_cdb</span><span class="p">(</span><span class="n">ap</span><span class="p">,</span> <span class="n">cmd</span><span class="p">);</span>

	<span class="n">dev</span> <span class="o">=</span> <span class="n">ata_scsi_find_dev</span><span class="p">(</span><span class="n">ap</span><span class="p">,</span> <span class="n">scsidev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">dev</span><span class="p">))</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">__ata_scsi_queuecmd</span><span class="p">(</span><span class="n">cmd</span><span class="p">,</span> <span class="n">dev</span><span class="p">);</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">=</span> <span class="p">(</span><span class="n">DID_BAD_TARGET</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">);</span>
		<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scsi_done</span><span class="p">(</span><span class="n">cmd</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">irq_flags</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	ata_scsi_simulate - simulate SCSI command on ATA device</span>
<span class="cm"> *	@dev: the target device</span>
<span class="cm"> *	@cmd: SCSI command being sent to device.</span>
<span class="cm"> *</span>
<span class="cm"> *	Interprets and directly executes a select list of SCSI commands</span>
<span class="cm"> *	that can be handled internally.</span>
<span class="cm"> *</span>
<span class="cm"> *	LOCKING:</span>
<span class="cm"> *	spin_lock_irqsave(host lock)</span>
<span class="cm"> */</span>

<span class="kt">void</span> <span class="nf">ata_scsi_simulate</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ata_scsi_args</span> <span class="n">args</span><span class="p">;</span>
	<span class="k">const</span> <span class="n">u8</span> <span class="o">*</span><span class="n">scsicmd</span> <span class="o">=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">cmnd</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">tmp8</span><span class="p">;</span>

	<span class="n">args</span><span class="p">.</span><span class="n">dev</span> <span class="o">=</span> <span class="n">dev</span><span class="p">;</span>
	<span class="n">args</span><span class="p">.</span><span class="n">id</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">;</span>
	<span class="n">args</span><span class="p">.</span><span class="n">cmd</span> <span class="o">=</span> <span class="n">cmd</span><span class="p">;</span>
	<span class="n">args</span><span class="p">.</span><span class="n">done</span> <span class="o">=</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scsi_done</span><span class="p">;</span>

	<span class="k">switch</span><span class="p">(</span><span class="n">scsicmd</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="p">{</span>
	<span class="cm">/* TODO: worth improving? */</span>
	<span class="k">case</span> <span class="n">FORMAT_UNIT</span>:
		<span class="n">ata_scsi_invalid_field</span><span class="p">(</span><span class="n">cmd</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">INQUIRY</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">scsicmd</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mi">2</span><span class="p">)</span>	           <span class="cm">/* is CmdDt set?  */</span>
			<span class="n">ata_scsi_invalid_field</span><span class="p">(</span><span class="n">cmd</span><span class="p">);</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">scsicmd</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>    <span class="cm">/* is EVPD clear? */</span>
			<span class="n">ata_scsi_rbuf_fill</span><span class="p">(</span><span class="o">&amp;</span><span class="n">args</span><span class="p">,</span> <span class="n">ata_scsiop_inq_std</span><span class="p">);</span>
		<span class="k">else</span> <span class="k">switch</span> <span class="p">(</span><span class="n">scsicmd</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span> <span class="p">{</span>
		<span class="k">case</span> <span class="mh">0x00</span>:
			<span class="n">ata_scsi_rbuf_fill</span><span class="p">(</span><span class="o">&amp;</span><span class="n">args</span><span class="p">,</span> <span class="n">ata_scsiop_inq_00</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="mh">0x80</span>:
			<span class="n">ata_scsi_rbuf_fill</span><span class="p">(</span><span class="o">&amp;</span><span class="n">args</span><span class="p">,</span> <span class="n">ata_scsiop_inq_80</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="mh">0x83</span>:
			<span class="n">ata_scsi_rbuf_fill</span><span class="p">(</span><span class="o">&amp;</span><span class="n">args</span><span class="p">,</span> <span class="n">ata_scsiop_inq_83</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="mh">0x89</span>:
			<span class="n">ata_scsi_rbuf_fill</span><span class="p">(</span><span class="o">&amp;</span><span class="n">args</span><span class="p">,</span> <span class="n">ata_scsiop_inq_89</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="mh">0xb0</span>:
			<span class="n">ata_scsi_rbuf_fill</span><span class="p">(</span><span class="o">&amp;</span><span class="n">args</span><span class="p">,</span> <span class="n">ata_scsiop_inq_b0</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="mh">0xb1</span>:
			<span class="n">ata_scsi_rbuf_fill</span><span class="p">(</span><span class="o">&amp;</span><span class="n">args</span><span class="p">,</span> <span class="n">ata_scsiop_inq_b1</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="mh">0xb2</span>:
			<span class="n">ata_scsi_rbuf_fill</span><span class="p">(</span><span class="o">&amp;</span><span class="n">args</span><span class="p">,</span> <span class="n">ata_scsiop_inq_b2</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="nl">default:</span>
			<span class="n">ata_scsi_invalid_field</span><span class="p">(</span><span class="n">cmd</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">MODE_SENSE</span>:
	<span class="k">case</span> <span class="n">MODE_SENSE_10</span>:
		<span class="n">ata_scsi_rbuf_fill</span><span class="p">(</span><span class="o">&amp;</span><span class="n">args</span><span class="p">,</span> <span class="n">ata_scsiop_mode_sense</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">MODE_SELECT</span>:	<span class="cm">/* unconditionally return */</span>
	<span class="k">case</span> <span class="n">MODE_SELECT_10</span>:	<span class="cm">/* bad-field-in-cdb */</span>
		<span class="n">ata_scsi_invalid_field</span><span class="p">(</span><span class="n">cmd</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">READ_CAPACITY</span>:
		<span class="n">ata_scsi_rbuf_fill</span><span class="p">(</span><span class="o">&amp;</span><span class="n">args</span><span class="p">,</span> <span class="n">ata_scsiop_read_cap</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">SERVICE_ACTION_IN</span>:
		<span class="k">if</span> <span class="p">((</span><span class="n">scsicmd</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0x1f</span><span class="p">)</span> <span class="o">==</span> <span class="n">SAI_READ_CAPACITY_16</span><span class="p">)</span>
			<span class="n">ata_scsi_rbuf_fill</span><span class="p">(</span><span class="o">&amp;</span><span class="n">args</span><span class="p">,</span> <span class="n">ata_scsiop_read_cap</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">ata_scsi_invalid_field</span><span class="p">(</span><span class="n">cmd</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">REPORT_LUNS</span>:
		<span class="n">ata_scsi_rbuf_fill</span><span class="p">(</span><span class="o">&amp;</span><span class="n">args</span><span class="p">,</span> <span class="n">ata_scsiop_report_luns</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">REQUEST_SENSE</span>:
		<span class="n">ata_scsi_set_sense</span><span class="p">(</span><span class="n">cmd</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">=</span> <span class="p">(</span><span class="n">DRIVER_SENSE</span> <span class="o">&lt;&lt;</span> <span class="mi">24</span><span class="p">);</span>
		<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scsi_done</span><span class="p">(</span><span class="n">cmd</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="cm">/* if we reach this, then writeback caching is disabled,</span>
<span class="cm">	 * turning this into a no-op.</span>
<span class="cm">	 */</span>
	<span class="k">case</span> <span class="n">SYNCHRONIZE_CACHE</span>:
		<span class="cm">/* fall through */</span>

	<span class="cm">/* no-op&#39;s, complete with success */</span>
	<span class="k">case</span> <span class="n">REZERO_UNIT</span>:
	<span class="k">case</span> <span class="n">SEEK_6</span>:
	<span class="k">case</span> <span class="n">SEEK_10</span>:
	<span class="k">case</span> <span class="n">TEST_UNIT_READY</span>:
		<span class="n">ata_scsi_rbuf_fill</span><span class="p">(</span><span class="o">&amp;</span><span class="n">args</span><span class="p">,</span> <span class="n">ata_scsiop_noop</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">SEND_DIAGNOSTIC</span>:
		<span class="n">tmp8</span> <span class="o">=</span> <span class="n">scsicmd</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&amp;</span> <span class="o">~</span><span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">3</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">tmp8</span> <span class="o">==</span> <span class="mh">0x4</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="o">!</span><span class="n">scsicmd</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="o">!</span><span class="n">scsicmd</span><span class="p">[</span><span class="mi">4</span><span class="p">]))</span>
			<span class="n">ata_scsi_rbuf_fill</span><span class="p">(</span><span class="o">&amp;</span><span class="n">args</span><span class="p">,</span> <span class="n">ata_scsiop_noop</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">ata_scsi_invalid_field</span><span class="p">(</span><span class="n">cmd</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="cm">/* all other commands */</span>
	<span class="nl">default:</span>
		<span class="n">ata_scsi_set_sense</span><span class="p">(</span><span class="n">cmd</span><span class="p">,</span> <span class="n">ILLEGAL_REQUEST</span><span class="p">,</span> <span class="mh">0x20</span><span class="p">,</span> <span class="mh">0x0</span><span class="p">);</span>
		<span class="cm">/* &quot;Invalid command operation code&quot; */</span>
		<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scsi_done</span><span class="p">(</span><span class="n">cmd</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">ata_scsi_add_hosts</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_host</span> <span class="o">*</span><span class="n">host</span><span class="p">,</span> <span class="k">struct</span> <span class="n">scsi_host_template</span> <span class="o">*</span><span class="n">sht</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">rc</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">host</span><span class="o">-&gt;</span><span class="n">n_ports</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span> <span class="o">=</span> <span class="n">host</span><span class="o">-&gt;</span><span class="n">ports</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span><span class="p">;</span>

		<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="n">shost</span> <span class="o">=</span> <span class="n">scsi_host_alloc</span><span class="p">(</span><span class="n">sht</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">shost</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">err_alloc</span><span class="p">;</span>

		<span class="n">shost</span><span class="o">-&gt;</span><span class="n">eh_noresume</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="o">*</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_port</span> <span class="o">**</span><span class="p">)</span><span class="o">&amp;</span><span class="n">shost</span><span class="o">-&gt;</span><span class="n">hostdata</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">ap</span><span class="p">;</span>
		<span class="n">ap</span><span class="o">-&gt;</span><span class="n">scsi_host</span> <span class="o">=</span> <span class="n">shost</span><span class="p">;</span>

		<span class="n">shost</span><span class="o">-&gt;</span><span class="n">transportt</span> <span class="o">=</span> <span class="n">ata_scsi_transport_template</span><span class="p">;</span>
		<span class="n">shost</span><span class="o">-&gt;</span><span class="n">unique_id</span> <span class="o">=</span> <span class="n">ap</span><span class="o">-&gt;</span><span class="n">print_id</span><span class="p">;</span>
		<span class="n">shost</span><span class="o">-&gt;</span><span class="n">max_id</span> <span class="o">=</span> <span class="mi">16</span><span class="p">;</span>
		<span class="n">shost</span><span class="o">-&gt;</span><span class="n">max_lun</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">shost</span><span class="o">-&gt;</span><span class="n">max_channel</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">shost</span><span class="o">-&gt;</span><span class="n">max_cmd_len</span> <span class="o">=</span> <span class="mi">16</span><span class="p">;</span>

		<span class="cm">/* Schedule policy is determined by -&gt;qc_defer()</span>
<span class="cm">		 * callback and it needs to see every deferred qc.</span>
<span class="cm">		 * Set host_blocked to 1 to prevent SCSI midlayer from</span>
<span class="cm">		 * automatically deferring requests.</span>
<span class="cm">		 */</span>
		<span class="n">shost</span><span class="o">-&gt;</span><span class="n">max_host_blocked</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

		<span class="n">rc</span> <span class="o">=</span> <span class="n">scsi_add_host_with_dma</span><span class="p">(</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">scsi_host</span><span class="p">,</span>
						<span class="o">&amp;</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">tdev</span><span class="p">,</span> <span class="n">ap</span><span class="o">-&gt;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">err_add</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

 <span class="nl">err_add:</span>
	<span class="n">scsi_host_put</span><span class="p">(</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">ports</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">scsi_host</span><span class="p">);</span>
 <span class="nl">err_alloc:</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">--</span><span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span> <span class="o">=</span> <span class="n">host</span><span class="o">-&gt;</span><span class="n">ports</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">scsi_host</span><span class="p">;</span>

		<span class="n">scsi_remove_host</span><span class="p">(</span><span class="n">shost</span><span class="p">);</span>
		<span class="n">scsi_host_put</span><span class="p">(</span><span class="n">shost</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">ata_scsi_scan_host</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span><span class="p">,</span> <span class="kt">int</span> <span class="n">sync</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">tries</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ata_device</span> <span class="o">*</span><span class="n">last_failed_dev</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ata_link</span> <span class="o">*</span><span class="n">link</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ata_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">;</span>

 <span class="nl">repeat:</span>
	<span class="n">ata_for_each_link</span><span class="p">(</span><span class="n">link</span><span class="p">,</span> <span class="n">ap</span><span class="p">,</span> <span class="n">EDGE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ata_for_each_dev</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">link</span><span class="p">,</span> <span class="n">ENABLED</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="n">sdev</span><span class="p">;</span>
			<span class="kt">int</span> <span class="n">channel</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">id</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">sdev</span><span class="p">)</span>
				<span class="k">continue</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">ata_is_host_link</span><span class="p">(</span><span class="n">link</span><span class="p">))</span>
				<span class="n">id</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">devno</span><span class="p">;</span>
			<span class="k">else</span>
				<span class="n">channel</span> <span class="o">=</span> <span class="n">link</span><span class="o">-&gt;</span><span class="n">pmp</span><span class="p">;</span>

			<span class="n">sdev</span> <span class="o">=</span> <span class="n">__scsi_add_device</span><span class="p">(</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">scsi_host</span><span class="p">,</span> <span class="n">channel</span><span class="p">,</span> <span class="n">id</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
						 <span class="nb">NULL</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">sdev</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">dev</span><span class="o">-&gt;</span><span class="n">sdev</span> <span class="o">=</span> <span class="n">sdev</span><span class="p">;</span>
				<span class="n">scsi_device_put</span><span class="p">(</span><span class="n">sdev</span><span class="p">);</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="n">dev</span><span class="o">-&gt;</span><span class="n">sdev</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* If we scanned while EH was in progress or allocation</span>
<span class="cm">	 * failure occurred, scan would have failed silently.  Check</span>
<span class="cm">	 * whether all devices are attached.</span>
<span class="cm">	 */</span>
	<span class="n">ata_for_each_link</span><span class="p">(</span><span class="n">link</span><span class="p">,</span> <span class="n">ap</span><span class="p">,</span> <span class="n">EDGE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ata_for_each_dev</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">link</span><span class="p">,</span> <span class="n">ENABLED</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">sdev</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">exit_loop</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
 <span class="nl">exit_loop:</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">link</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/* we&#39;re missing some SCSI devices */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sync</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* If caller requested synchrnous scan &amp;&amp; we&#39;ve made</span>
<span class="cm">		 * any progress, sleep briefly and repeat.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dev</span> <span class="o">!=</span> <span class="n">last_failed_dev</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">msleep</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span>
			<span class="n">last_failed_dev</span> <span class="o">=</span> <span class="n">dev</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">repeat</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* We might be failing to detect boot device, give it</span>
<span class="cm">		 * a few more chances.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">--</span><span class="n">tries</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">msleep</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">repeat</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">ata_port_err</span><span class="p">(</span><span class="n">ap</span><span class="p">,</span>
			     <span class="s">&quot;WARNING: synchronous SCSI scan failed without making any progress, switching to async</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">queue_delayed_work</span><span class="p">(</span><span class="n">system_long_wq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">hotplug_task</span><span class="p">,</span>
			   <span class="n">round_jiffies_relative</span><span class="p">(</span><span class="n">HZ</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	ata_scsi_offline_dev - offline attached SCSI device</span>
<span class="cm"> *	@dev: ATA device to offline attached SCSI device for</span>
<span class="cm"> *</span>
<span class="cm"> *	This function is called from ata_eh_hotplug() and responsible</span>
<span class="cm"> *	for taking the SCSI device attached to @dev offline.  This</span>
<span class="cm"> *	function is called with host lock which protects dev-&gt;sdev</span>
<span class="cm"> *	against clearing.</span>
<span class="cm"> *</span>
<span class="cm"> *	LOCKING:</span>
<span class="cm"> *	spin_lock_irqsave(host lock)</span>
<span class="cm"> *</span>
<span class="cm"> *	RETURNS:</span>
<span class="cm"> *	1 if attached SCSI device exists, 0 otherwise.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">ata_scsi_offline_dev</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">sdev</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">scsi_device_set_state</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">sdev</span><span class="p">,</span> <span class="n">SDEV_OFFLINE</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	ata_scsi_remove_dev - remove attached SCSI device</span>
<span class="cm"> *	@dev: ATA device to remove attached SCSI device for</span>
<span class="cm"> *</span>
<span class="cm"> *	This function is called from ata_eh_scsi_hotplug() and</span>
<span class="cm"> *	responsible for removing the SCSI device attached to @dev.</span>
<span class="cm"> *</span>
<span class="cm"> *	LOCKING:</span>
<span class="cm"> *	Kernel thread context (may sleep).</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">ata_scsi_remove_dev</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">link</span><span class="o">-&gt;</span><span class="n">ap</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="n">sdev</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="cm">/* Alas, we need to grab scan_mutex to ensure SCSI device</span>
<span class="cm">	 * state doesn&#39;t change underneath us and thus</span>
<span class="cm">	 * scsi_device_get() always succeeds.  The mutex locking can</span>
<span class="cm">	 * be removed if there is __scsi_device_get() interface which</span>
<span class="cm">	 * increments reference counts regardless of device state.</span>
<span class="cm">	 */</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">scsi_host</span><span class="o">-&gt;</span><span class="n">scan_mutex</span><span class="p">);</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="cm">/* clearing dev-&gt;sdev is protected by host lock */</span>
	<span class="n">sdev</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">sdev</span><span class="p">;</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">sdev</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sdev</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* If user initiated unplug races with us, sdev can go</span>
<span class="cm">		 * away underneath us after the host lock and</span>
<span class="cm">		 * scan_mutex are released.  Hold onto it.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">scsi_device_get</span><span class="p">(</span><span class="n">sdev</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* The following ensures the attached sdev is</span>
<span class="cm">			 * offline on return from ata_scsi_offline_dev()</span>
<span class="cm">			 * regardless it wins or loses the race</span>
<span class="cm">			 * against this function.</span>
<span class="cm">			 */</span>
			<span class="n">scsi_device_set_state</span><span class="p">(</span><span class="n">sdev</span><span class="p">,</span> <span class="n">SDEV_OFFLINE</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">WARN_ON</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
			<span class="n">sdev</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">scsi_host</span><span class="o">-&gt;</span><span class="n">scan_mutex</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sdev</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ata_dev_info</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;detaching (SCSI %s)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			     <span class="n">dev_name</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">sdev_gendev</span><span class="p">));</span>

		<span class="n">scsi_remove_device</span><span class="p">(</span><span class="n">sdev</span><span class="p">);</span>
		<span class="n">scsi_device_put</span><span class="p">(</span><span class="n">sdev</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">ata_scsi_handle_link_detach</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_link</span> <span class="o">*</span><span class="n">link</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span> <span class="o">=</span> <span class="n">link</span><span class="o">-&gt;</span><span class="n">ap</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ata_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">;</span>

	<span class="n">ata_for_each_dev</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">link</span><span class="p">,</span> <span class="n">ALL</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">ATA_DFLAG_DETACHED</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">ATA_DFLAG_DETACHED</span><span class="p">;</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

		<span class="n">ata_scsi_remove_dev</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	ata_scsi_media_change_notify - send media change event</span>
<span class="cm"> *	@dev: Pointer to the disk device with media change event</span>
<span class="cm"> *</span>
<span class="cm"> *	Tell the block layer to send a media change notification</span>
<span class="cm"> *	event.</span>
<span class="cm"> *</span>
<span class="cm"> * 	LOCKING:</span>
<span class="cm"> * 	spin_lock_irqsave(host lock)</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">ata_scsi_media_change_notify</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">sdev</span><span class="p">)</span>
		<span class="n">sdev_evt_send_simple</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">sdev</span><span class="p">,</span> <span class="n">SDEV_EVT_MEDIA_CHANGE</span><span class="p">,</span>
				     <span class="n">GFP_ATOMIC</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	ata_scsi_hotplug - SCSI part of hotplug</span>
<span class="cm"> *	@work: Pointer to ATA port to perform SCSI hotplug on</span>
<span class="cm"> *</span>
<span class="cm"> *	Perform SCSI part of hotplug.  It&#39;s executed from a separate</span>
<span class="cm"> *	workqueue after EH completes.  This is necessary because SCSI</span>
<span class="cm"> *	hot plugging requires working EH and hot unplugging is</span>
<span class="cm"> *	synchronized with hot plugging with a mutex.</span>
<span class="cm"> *</span>
<span class="cm"> *	LOCKING:</span>
<span class="cm"> *	Kernel thread context (may sleep).</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">ata_scsi_hotplug</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span> <span class="o">=</span>
		<span class="n">container_of</span><span class="p">(</span><span class="n">work</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ata_port</span><span class="p">,</span> <span class="n">hotplug_task</span><span class="p">.</span><span class="n">work</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">pflags</span> <span class="o">&amp;</span> <span class="n">ATA_PFLAG_UNLOADING</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">DPRINTK</span><span class="p">(</span><span class="s">&quot;ENTER/EXIT - unloading</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">DPRINTK</span><span class="p">(</span><span class="s">&quot;ENTER</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">scsi_scan_mutex</span><span class="p">);</span>

	<span class="cm">/* Unplug detached devices.  We cannot use link iterator here</span>
<span class="cm">	 * because PMP links have to be scanned even if PMP is</span>
<span class="cm">	 * currently not attached.  Iterate manually.</span>
<span class="cm">	 */</span>
	<span class="n">ata_scsi_handle_link_detach</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">link</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">pmp_link</span><span class="p">)</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">SATA_PMP_MAX_PORTS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
			<span class="n">ata_scsi_handle_link_detach</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">pmp_link</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>

	<span class="cm">/* scan for new ones */</span>
	<span class="n">ata_scsi_scan_host</span><span class="p">(</span><span class="n">ap</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">scsi_scan_mutex</span><span class="p">);</span>
	<span class="n">DPRINTK</span><span class="p">(</span><span class="s">&quot;EXIT</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	ata_scsi_user_scan - indication for user-initiated bus scan</span>
<span class="cm"> *	@shost: SCSI host to scan</span>
<span class="cm"> *	@channel: Channel to scan</span>
<span class="cm"> *	@id: ID to scan</span>
<span class="cm"> *	@lun: LUN to scan</span>
<span class="cm"> *</span>
<span class="cm"> *	This function is called when user explicitly requests bus</span>
<span class="cm"> *	scan.  Set probe pending flag and invoke EH.</span>
<span class="cm"> *</span>
<span class="cm"> *	LOCKING:</span>
<span class="cm"> *	SCSI layer (we don&#39;t care)</span>
<span class="cm"> *</span>
<span class="cm"> *	RETURNS:</span>
<span class="cm"> *	Zero.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">ata_scsi_user_scan</span><span class="p">(</span><span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">channel</span><span class="p">,</span>
		       <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">id</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">lun</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span> <span class="o">=</span> <span class="n">ata_shost_to_port</span><span class="p">(</span><span class="n">shost</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">devno</span><span class="p">,</span> <span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">error_handler</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EOPNOTSUPP</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">lun</span> <span class="o">!=</span> <span class="n">SCAN_WILD_CARD</span> <span class="o">&amp;&amp;</span> <span class="n">lun</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sata_pmp_attached</span><span class="p">(</span><span class="n">ap</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">channel</span> <span class="o">!=</span> <span class="n">SCAN_WILD_CARD</span> <span class="o">&amp;&amp;</span> <span class="n">channel</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="n">devno</span> <span class="o">=</span> <span class="n">id</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">id</span> <span class="o">!=</span> <span class="n">SCAN_WILD_CARD</span> <span class="o">&amp;&amp;</span> <span class="n">id</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="n">devno</span> <span class="o">=</span> <span class="n">channel</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">devno</span> <span class="o">==</span> <span class="n">SCAN_WILD_CARD</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">ata_link</span> <span class="o">*</span><span class="n">link</span><span class="p">;</span>

		<span class="n">ata_for_each_link</span><span class="p">(</span><span class="n">link</span><span class="p">,</span> <span class="n">ap</span><span class="p">,</span> <span class="n">EDGE</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">ata_eh_info</span> <span class="o">*</span><span class="n">ehi</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">link</span><span class="o">-&gt;</span><span class="n">eh_info</span><span class="p">;</span>
			<span class="n">ehi</span><span class="o">-&gt;</span><span class="n">probe_mask</span> <span class="o">|=</span> <span class="n">ATA_ALL_DEVICES</span><span class="p">;</span>
			<span class="n">ehi</span><span class="o">-&gt;</span><span class="n">action</span> <span class="o">|=</span> <span class="n">ATA_EH_RESET</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">ata_device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">ata_find_dev</span><span class="p">(</span><span class="n">ap</span><span class="p">,</span> <span class="n">devno</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">ata_eh_info</span> <span class="o">*</span><span class="n">ehi</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">link</span><span class="o">-&gt;</span><span class="n">eh_info</span><span class="p">;</span>
			<span class="n">ehi</span><span class="o">-&gt;</span><span class="n">probe_mask</span> <span class="o">|=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">devno</span><span class="p">;</span>
			<span class="n">ehi</span><span class="o">-&gt;</span><span class="n">action</span> <span class="o">|=</span> <span class="n">ATA_EH_RESET</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ata_port_schedule_eh</span><span class="p">(</span><span class="n">ap</span><span class="p">);</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="n">ata_port_wait_eh</span><span class="p">(</span><span class="n">ap</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	ata_scsi_dev_rescan - initiate scsi_rescan_device()</span>
<span class="cm"> *	@work: Pointer to ATA port to perform scsi_rescan_device()</span>
<span class="cm"> *</span>
<span class="cm"> *	After ATA pass thru (SAT) commands are executed successfully,</span>
<span class="cm"> *	libata need to propagate the changes to SCSI layer.</span>
<span class="cm"> *</span>
<span class="cm"> *	LOCKING:</span>
<span class="cm"> *	Kernel thread context (may sleep).</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">ata_scsi_dev_rescan</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span> <span class="o">=</span>
		<span class="n">container_of</span><span class="p">(</span><span class="n">work</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ata_port</span><span class="p">,</span> <span class="n">scsi_rescan_task</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">ata_link</span> <span class="o">*</span><span class="n">link</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ata_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">scsi_scan_mutex</span><span class="p">);</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">ata_for_each_link</span><span class="p">(</span><span class="n">link</span><span class="p">,</span> <span class="n">ap</span><span class="p">,</span> <span class="n">EDGE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ata_for_each_dev</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">link</span><span class="p">,</span> <span class="n">ENABLED</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="n">sdev</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">sdev</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sdev</span><span class="p">)</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">scsi_device_get</span><span class="p">(</span><span class="n">sdev</span><span class="p">))</span>
				<span class="k">continue</span><span class="p">;</span>

			<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
			<span class="n">scsi_rescan_device</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">sdev_gendev</span><span class="p">));</span>
			<span class="n">scsi_device_put</span><span class="p">(</span><span class="n">sdev</span><span class="p">);</span>
			<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">scsi_scan_mutex</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	ata_sas_port_alloc - Allocate port for a SAS attached SATA device</span>
<span class="cm"> *	@host: ATA host container for all SAS ports</span>
<span class="cm"> *	@port_info: Information from low-level host driver</span>
<span class="cm"> *	@shost: SCSI host that the scsi device is attached to</span>
<span class="cm"> *</span>
<span class="cm"> *	LOCKING:</span>
<span class="cm"> *	PCI/etc. bus probe sem.</span>
<span class="cm"> *</span>
<span class="cm"> *	RETURNS:</span>
<span class="cm"> *	ata_port pointer on success / NULL on failure.</span>
<span class="cm"> */</span>

<span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="nf">ata_sas_port_alloc</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_host</span> <span class="o">*</span><span class="n">host</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">ata_port_info</span> <span class="o">*</span><span class="n">port_info</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">Scsi_Host</span> <span class="o">*</span><span class="n">shost</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span><span class="p">;</span>

	<span class="n">ap</span> <span class="o">=</span> <span class="n">ata_port_alloc</span><span class="p">(</span><span class="n">host</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ap</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">ap</span><span class="o">-&gt;</span><span class="n">port_no</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ap</span><span class="o">-&gt;</span><span class="n">lock</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">;</span>
	<span class="n">ap</span><span class="o">-&gt;</span><span class="n">pio_mask</span> <span class="o">=</span> <span class="n">port_info</span><span class="o">-&gt;</span><span class="n">pio_mask</span><span class="p">;</span>
	<span class="n">ap</span><span class="o">-&gt;</span><span class="n">mwdma_mask</span> <span class="o">=</span> <span class="n">port_info</span><span class="o">-&gt;</span><span class="n">mwdma_mask</span><span class="p">;</span>
	<span class="n">ap</span><span class="o">-&gt;</span><span class="n">udma_mask</span> <span class="o">=</span> <span class="n">port_info</span><span class="o">-&gt;</span><span class="n">udma_mask</span><span class="p">;</span>
	<span class="n">ap</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">port_info</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">;</span>
	<span class="n">ap</span><span class="o">-&gt;</span><span class="n">ops</span> <span class="o">=</span> <span class="n">port_info</span><span class="o">-&gt;</span><span class="n">port_ops</span><span class="p">;</span>
	<span class="n">ap</span><span class="o">-&gt;</span><span class="n">cbl</span> <span class="o">=</span> <span class="n">ATA_CBL_SATA</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">ap</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">ata_sas_port_alloc</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> *	ata_sas_port_start - Set port up for dma.</span>
<span class="cm"> *	@ap: Port to initialize</span>
<span class="cm"> *</span>
<span class="cm"> *	Called just after data structures for each port are</span>
<span class="cm"> *	initialized.</span>
<span class="cm"> *</span>
<span class="cm"> *	May be used as the port_start() entry in ata_port_operations.</span>
<span class="cm"> *</span>
<span class="cm"> *	LOCKING:</span>
<span class="cm"> *	Inherited from caller.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">ata_sas_port_start</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * the port is marked as frozen at allocation time, but if we don&#39;t</span>
<span class="cm">	 * have new eh, we won&#39;t thaw it</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">error_handler</span><span class="p">)</span>
		<span class="n">ap</span><span class="o">-&gt;</span><span class="n">pflags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">ATA_PFLAG_FROZEN</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">ata_sas_port_start</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> *	ata_port_stop - Undo ata_sas_port_start()</span>
<span class="cm"> *	@ap: Port to shut down</span>
<span class="cm"> *</span>
<span class="cm"> *	May be used as the port_stop() entry in ata_port_operations.</span>
<span class="cm"> *</span>
<span class="cm"> *	LOCKING:</span>
<span class="cm"> *	Inherited from caller.</span>
<span class="cm"> */</span>

<span class="kt">void</span> <span class="nf">ata_sas_port_stop</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">ata_sas_port_stop</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * ata_sas_async_probe - simply schedule probing and return</span>
<span class="cm"> * @ap: Port to probe</span>
<span class="cm"> *</span>
<span class="cm"> * For batch scheduling of probe for sas attached ata devices, assumes</span>
<span class="cm"> * the port has already been through ata_sas_port_init()</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">ata_sas_async_probe</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__ata_port_probe</span><span class="p">(</span><span class="n">ap</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">ata_sas_async_probe</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">ata_sas_sync_probe</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">ata_port_probe</span><span class="p">(</span><span class="n">ap</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">ata_sas_sync_probe</span><span class="p">);</span>


<span class="cm">/**</span>
<span class="cm"> *	ata_sas_port_init - Initialize a SATA device</span>
<span class="cm"> *	@ap: SATA port to initialize</span>
<span class="cm"> *</span>
<span class="cm"> *	LOCKING:</span>
<span class="cm"> *	PCI/etc. bus probe sem.</span>
<span class="cm"> *</span>
<span class="cm"> *	RETURNS:</span>
<span class="cm"> *	Zero on success, non-zero on error.</span>
<span class="cm"> */</span>

<span class="kt">int</span> <span class="nf">ata_sas_port_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="n">ap</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">port_start</span><span class="p">(</span><span class="n">ap</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
	<span class="n">ap</span><span class="o">-&gt;</span><span class="n">print_id</span> <span class="o">=</span> <span class="n">atomic_inc_return</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ata_print_id</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">ata_sas_port_init</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> *	ata_sas_port_destroy - Destroy a SATA port allocated by ata_sas_port_alloc</span>
<span class="cm"> *	@ap: SATA port to destroy</span>
<span class="cm"> *</span>
<span class="cm"> */</span>

<span class="kt">void</span> <span class="nf">ata_sas_port_destroy</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">port_stop</span><span class="p">)</span>
		<span class="n">ap</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">port_stop</span><span class="p">(</span><span class="n">ap</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">ap</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">ata_sas_port_destroy</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> *	ata_sas_slave_configure - Default slave_config routine for libata devices</span>
<span class="cm"> *	@sdev: SCSI device to configure</span>
<span class="cm"> *	@ap: ATA port to which SCSI device is attached</span>
<span class="cm"> *</span>
<span class="cm"> *	RETURNS:</span>
<span class="cm"> *	Zero.</span>
<span class="cm"> */</span>

<span class="kt">int</span> <span class="nf">ata_sas_slave_configure</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_device</span> <span class="o">*</span><span class="n">sdev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ata_scsi_sdev_config</span><span class="p">(</span><span class="n">sdev</span><span class="p">);</span>
	<span class="n">ata_scsi_dev_config</span><span class="p">(</span><span class="n">sdev</span><span class="p">,</span> <span class="n">ap</span><span class="o">-&gt;</span><span class="n">link</span><span class="p">.</span><span class="n">device</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">ata_sas_slave_configure</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> *	ata_sas_queuecmd - Issue SCSI cdb to libata-managed device</span>
<span class="cm"> *	@cmd: SCSI command to be sent</span>
<span class="cm"> *	@ap:	ATA port to which the command is being sent</span>
<span class="cm"> *</span>
<span class="cm"> *	RETURNS:</span>
<span class="cm"> *	Return value from __ata_scsi_queuecmd() if @cmd can be queued,</span>
<span class="cm"> *	0 otherwise.</span>
<span class="cm"> */</span>

<span class="kt">int</span> <span class="nf">ata_sas_queuecmd</span><span class="p">(</span><span class="k">struct</span> <span class="n">scsi_cmnd</span> <span class="o">*</span><span class="n">cmd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">ata_scsi_dump_cdb</span><span class="p">(</span><span class="n">ap</span><span class="p">,</span> <span class="n">cmd</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">ata_dev_enabled</span><span class="p">(</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">link</span><span class="p">.</span><span class="n">device</span><span class="p">)))</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">__ata_scsi_queuecmd</span><span class="p">(</span><span class="n">cmd</span><span class="p">,</span> <span class="n">ap</span><span class="o">-&gt;</span><span class="n">link</span><span class="p">.</span><span class="n">device</span><span class="p">);</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">=</span> <span class="p">(</span><span class="n">DID_BAD_TARGET</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">);</span>
		<span class="n">cmd</span><span class="o">-&gt;</span><span class="n">scsi_done</span><span class="p">(</span><span class="n">cmd</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">ata_sas_queuecmd</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
