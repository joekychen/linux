<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › ata › pata_bf54x.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>pata_bf54x.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * File:         drivers/ata/pata_bf54x.c</span>
<span class="cm"> * Author:       Sonic Zhang &lt;sonic.zhang@analog.com&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * Created:</span>
<span class="cm"> * Description:  PATA Driver for blackfin 54x</span>
<span class="cm"> *</span>
<span class="cm"> * Modified:</span>
<span class="cm"> *               Copyright 2007 Analog Devices Inc.</span>
<span class="cm"> *</span>
<span class="cm"> * Bugs:         Enter bugs at http://blackfin.uclinux.org/</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or modify</span>
<span class="cm"> * it under the terms of the GNU General Public License as published by</span>
<span class="cm"> * the Free Software Foundation; either version 2 of the License, or</span>
<span class="cm"> * (at your option) any later version.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is distributed in the hope that it will be useful,</span>
<span class="cm"> * but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="cm"> * GNU General Public License for more details.</span>
<span class="cm"> *</span>
<span class="cm"> * You should have received a copy of the GNU General Public License</span>
<span class="cm"> * along with this program; if not, see the file COPYING, or write</span>
<span class="cm"> * to the Free Software Foundation, Inc.,</span>
<span class="cm"> * 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/pci.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/blkdev.h&gt;</span>
<span class="cp">#include &lt;linux/delay.h&gt;</span>
<span class="cp">#include &lt;linux/device.h&gt;</span>
<span class="cp">#include &lt;scsi/scsi_host.h&gt;</span>
<span class="cp">#include &lt;linux/libata.h&gt;</span>
<span class="cp">#include &lt;linux/platform_device.h&gt;</span>
<span class="cp">#include &lt;asm/dma.h&gt;</span>
<span class="cp">#include &lt;asm/gpio.h&gt;</span>
<span class="cp">#include &lt;asm/portmux.h&gt;</span>

<span class="cp">#define DRV_NAME		&quot;pata-bf54x&quot;</span>
<span class="cp">#define DRV_VERSION		&quot;0.9&quot;</span>

<span class="cp">#define ATA_REG_CTRL		0x0E</span>
<span class="cp">#define ATA_REG_ALTSTATUS	ATA_REG_CTRL</span>

<span class="cm">/* These are the offset of the controller&#39;s registers */</span>
<span class="cp">#define ATAPI_OFFSET_CONTROL		0x00</span>
<span class="cp">#define ATAPI_OFFSET_STATUS		0x04</span>
<span class="cp">#define ATAPI_OFFSET_DEV_ADDR		0x08</span>
<span class="cp">#define ATAPI_OFFSET_DEV_TXBUF		0x0c</span>
<span class="cp">#define ATAPI_OFFSET_DEV_RXBUF		0x10</span>
<span class="cp">#define ATAPI_OFFSET_INT_MASK		0x14</span>
<span class="cp">#define ATAPI_OFFSET_INT_STATUS		0x18</span>
<span class="cp">#define ATAPI_OFFSET_XFER_LEN		0x1c</span>
<span class="cp">#define ATAPI_OFFSET_LINE_STATUS	0x20</span>
<span class="cp">#define ATAPI_OFFSET_SM_STATE		0x24</span>
<span class="cp">#define ATAPI_OFFSET_TERMINATE		0x28</span>
<span class="cp">#define ATAPI_OFFSET_PIO_TFRCNT		0x2c</span>
<span class="cp">#define ATAPI_OFFSET_DMA_TFRCNT		0x30</span>
<span class="cp">#define ATAPI_OFFSET_UMAIN_TFRCNT	0x34</span>
<span class="cp">#define ATAPI_OFFSET_UDMAOUT_TFRCNT	0x38</span>
<span class="cp">#define ATAPI_OFFSET_REG_TIM_0		0x40</span>
<span class="cp">#define ATAPI_OFFSET_PIO_TIM_0		0x44</span>
<span class="cp">#define ATAPI_OFFSET_PIO_TIM_1		0x48</span>
<span class="cp">#define ATAPI_OFFSET_MULTI_TIM_0	0x50</span>
<span class="cp">#define ATAPI_OFFSET_MULTI_TIM_1	0x54</span>
<span class="cp">#define ATAPI_OFFSET_MULTI_TIM_2	0x58</span>
<span class="cp">#define ATAPI_OFFSET_ULTRA_TIM_0	0x60</span>
<span class="cp">#define ATAPI_OFFSET_ULTRA_TIM_1	0x64</span>
<span class="cp">#define ATAPI_OFFSET_ULTRA_TIM_2	0x68</span>
<span class="cp">#define ATAPI_OFFSET_ULTRA_TIM_3	0x6c</span>


<span class="cp">#define ATAPI_GET_CONTROL(base)\</span>
<span class="cp">	bfin_read16(base + ATAPI_OFFSET_CONTROL)</span>
<span class="cp">#define ATAPI_SET_CONTROL(base, val)\</span>
<span class="cp">	bfin_write16(base + ATAPI_OFFSET_CONTROL, val)</span>
<span class="cp">#define ATAPI_GET_STATUS(base)\</span>
<span class="cp">	bfin_read16(base + ATAPI_OFFSET_STATUS)</span>
<span class="cp">#define ATAPI_GET_DEV_ADDR(base)\</span>
<span class="cp">	bfin_read16(base + ATAPI_OFFSET_DEV_ADDR)</span>
<span class="cp">#define ATAPI_SET_DEV_ADDR(base, val)\</span>
<span class="cp">	bfin_write16(base + ATAPI_OFFSET_DEV_ADDR, val)</span>
<span class="cp">#define ATAPI_GET_DEV_TXBUF(base)\</span>
<span class="cp">	bfin_read16(base + ATAPI_OFFSET_DEV_TXBUF)</span>
<span class="cp">#define ATAPI_SET_DEV_TXBUF(base, val)\</span>
<span class="cp">	bfin_write16(base + ATAPI_OFFSET_DEV_TXBUF, val)</span>
<span class="cp">#define ATAPI_GET_DEV_RXBUF(base)\</span>
<span class="cp">	bfin_read16(base + ATAPI_OFFSET_DEV_RXBUF)</span>
<span class="cp">#define ATAPI_SET_DEV_RXBUF(base, val)\</span>
<span class="cp">	bfin_write16(base + ATAPI_OFFSET_DEV_RXBUF, val)</span>
<span class="cp">#define ATAPI_GET_INT_MASK(base)\</span>
<span class="cp">	bfin_read16(base + ATAPI_OFFSET_INT_MASK)</span>
<span class="cp">#define ATAPI_SET_INT_MASK(base, val)\</span>
<span class="cp">	bfin_write16(base + ATAPI_OFFSET_INT_MASK, val)</span>
<span class="cp">#define ATAPI_GET_INT_STATUS(base)\</span>
<span class="cp">	bfin_read16(base + ATAPI_OFFSET_INT_STATUS)</span>
<span class="cp">#define ATAPI_SET_INT_STATUS(base, val)\</span>
<span class="cp">	bfin_write16(base + ATAPI_OFFSET_INT_STATUS, val)</span>
<span class="cp">#define ATAPI_GET_XFER_LEN(base)\</span>
<span class="cp">	bfin_read16(base + ATAPI_OFFSET_XFER_LEN)</span>
<span class="cp">#define ATAPI_SET_XFER_LEN(base, val)\</span>
<span class="cp">	bfin_write16(base + ATAPI_OFFSET_XFER_LEN, val)</span>
<span class="cp">#define ATAPI_GET_LINE_STATUS(base)\</span>
<span class="cp">	bfin_read16(base + ATAPI_OFFSET_LINE_STATUS)</span>
<span class="cp">#define ATAPI_GET_SM_STATE(base)\</span>
<span class="cp">	bfin_read16(base + ATAPI_OFFSET_SM_STATE)</span>
<span class="cp">#define ATAPI_GET_TERMINATE(base)\</span>
<span class="cp">	bfin_read16(base + ATAPI_OFFSET_TERMINATE)</span>
<span class="cp">#define ATAPI_SET_TERMINATE(base, val)\</span>
<span class="cp">	bfin_write16(base + ATAPI_OFFSET_TERMINATE, val)</span>
<span class="cp">#define ATAPI_GET_PIO_TFRCNT(base)\</span>
<span class="cp">	bfin_read16(base + ATAPI_OFFSET_PIO_TFRCNT)</span>
<span class="cp">#define ATAPI_GET_DMA_TFRCNT(base)\</span>
<span class="cp">	bfin_read16(base + ATAPI_OFFSET_DMA_TFRCNT)</span>
<span class="cp">#define ATAPI_GET_UMAIN_TFRCNT(base)\</span>
<span class="cp">	bfin_read16(base + ATAPI_OFFSET_UMAIN_TFRCNT)</span>
<span class="cp">#define ATAPI_GET_UDMAOUT_TFRCNT(base)\</span>
<span class="cp">	bfin_read16(base + ATAPI_OFFSET_UDMAOUT_TFRCNT)</span>
<span class="cp">#define ATAPI_GET_REG_TIM_0(base)\</span>
<span class="cp">	bfin_read16(base + ATAPI_OFFSET_REG_TIM_0)</span>
<span class="cp">#define ATAPI_SET_REG_TIM_0(base, val)\</span>
<span class="cp">	bfin_write16(base + ATAPI_OFFSET_REG_TIM_0, val)</span>
<span class="cp">#define ATAPI_GET_PIO_TIM_0(base)\</span>
<span class="cp">	bfin_read16(base + ATAPI_OFFSET_PIO_TIM_0)</span>
<span class="cp">#define ATAPI_SET_PIO_TIM_0(base, val)\</span>
<span class="cp">	bfin_write16(base + ATAPI_OFFSET_PIO_TIM_0, val)</span>
<span class="cp">#define ATAPI_GET_PIO_TIM_1(base)\</span>
<span class="cp">	bfin_read16(base + ATAPI_OFFSET_PIO_TIM_1)</span>
<span class="cp">#define ATAPI_SET_PIO_TIM_1(base, val)\</span>
<span class="cp">	bfin_write16(base + ATAPI_OFFSET_PIO_TIM_1, val)</span>
<span class="cp">#define ATAPI_GET_MULTI_TIM_0(base)\</span>
<span class="cp">	bfin_read16(base + ATAPI_OFFSET_MULTI_TIM_0)</span>
<span class="cp">#define ATAPI_SET_MULTI_TIM_0(base, val)\</span>
<span class="cp">	bfin_write16(base + ATAPI_OFFSET_MULTI_TIM_0, val)</span>
<span class="cp">#define ATAPI_GET_MULTI_TIM_1(base)\</span>
<span class="cp">	bfin_read16(base + ATAPI_OFFSET_MULTI_TIM_1)</span>
<span class="cp">#define ATAPI_SET_MULTI_TIM_1(base, val)\</span>
<span class="cp">	bfin_write16(base + ATAPI_OFFSET_MULTI_TIM_1, val)</span>
<span class="cp">#define ATAPI_GET_MULTI_TIM_2(base)\</span>
<span class="cp">	bfin_read16(base + ATAPI_OFFSET_MULTI_TIM_2)</span>
<span class="cp">#define ATAPI_SET_MULTI_TIM_2(base, val)\</span>
<span class="cp">	bfin_write16(base + ATAPI_OFFSET_MULTI_TIM_2, val)</span>
<span class="cp">#define ATAPI_GET_ULTRA_TIM_0(base)\</span>
<span class="cp">	bfin_read16(base + ATAPI_OFFSET_ULTRA_TIM_0)</span>
<span class="cp">#define ATAPI_SET_ULTRA_TIM_0(base, val)\</span>
<span class="cp">	bfin_write16(base + ATAPI_OFFSET_ULTRA_TIM_0, val)</span>
<span class="cp">#define ATAPI_GET_ULTRA_TIM_1(base)\</span>
<span class="cp">	bfin_read16(base + ATAPI_OFFSET_ULTRA_TIM_1)</span>
<span class="cp">#define ATAPI_SET_ULTRA_TIM_1(base, val)\</span>
<span class="cp">	bfin_write16(base + ATAPI_OFFSET_ULTRA_TIM_1, val)</span>
<span class="cp">#define ATAPI_GET_ULTRA_TIM_2(base)\</span>
<span class="cp">	bfin_read16(base + ATAPI_OFFSET_ULTRA_TIM_2)</span>
<span class="cp">#define ATAPI_SET_ULTRA_TIM_2(base, val)\</span>
<span class="cp">	bfin_write16(base + ATAPI_OFFSET_ULTRA_TIM_2, val)</span>
<span class="cp">#define ATAPI_GET_ULTRA_TIM_3(base)\</span>
<span class="cp">	bfin_read16(base + ATAPI_OFFSET_ULTRA_TIM_3)</span>
<span class="cp">#define ATAPI_SET_ULTRA_TIM_3(base, val)\</span>
<span class="cp">	bfin_write16(base + ATAPI_OFFSET_ULTRA_TIM_3, val)</span>

<span class="cm">/**</span>
<span class="cm"> * PIO Mode - Frequency compatibility</span>
<span class="cm"> */</span>
<span class="cm">/* mode: 0         1         2         3         4 */</span>
<span class="k">static</span> <span class="k">const</span> <span class="n">u32</span> <span class="n">pio_fsclk</span><span class="p">[]</span> <span class="o">=</span>
<span class="p">{</span> <span class="mi">33333333</span><span class="p">,</span> <span class="mi">33333333</span><span class="p">,</span> <span class="mi">33333333</span><span class="p">,</span> <span class="mi">33333333</span><span class="p">,</span> <span class="mi">33333333</span> <span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * MDMA Mode - Frequency compatibility</span>
<span class="cm"> */</span>
<span class="cm">/*               mode:      0         1         2        */</span>
<span class="k">static</span> <span class="k">const</span> <span class="n">u32</span> <span class="n">mdma_fsclk</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">33333333</span><span class="p">,</span> <span class="mi">33333333</span><span class="p">,</span> <span class="mi">33333333</span> <span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * UDMA Mode - Frequency compatibility</span>
<span class="cm"> *</span>
<span class="cm"> * UDMA5 - 100 MB/s   - SCLK  = 133 MHz</span>
<span class="cm"> * UDMA4 - 66 MB/s    - SCLK &gt;=  80 MHz</span>
<span class="cm"> * UDMA3 - 44.4 MB/s  - SCLK &gt;=  50 MHz</span>
<span class="cm"> * UDMA2 - 33 MB/s    - SCLK &gt;=  40 MHz</span>
<span class="cm"> */</span>
<span class="cm">/* mode: 0         1         2         3         4          5 */</span>
<span class="k">static</span> <span class="k">const</span> <span class="n">u32</span> <span class="n">udma_fsclk</span><span class="p">[]</span> <span class="o">=</span>
<span class="p">{</span> <span class="mi">33333333</span><span class="p">,</span> <span class="mi">33333333</span><span class="p">,</span> <span class="mi">40000000</span><span class="p">,</span> <span class="mi">50000000</span><span class="p">,</span> <span class="mi">80000000</span><span class="p">,</span> <span class="mi">133333333</span> <span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * Register transfer timing table</span>
<span class="cm"> */</span>
<span class="cm">/*               mode:       0    1    2    3    4    */</span>
<span class="cm">/* Cycle Time                     */</span>
<span class="k">static</span> <span class="k">const</span> <span class="n">u32</span> <span class="n">reg_t0min</span><span class="p">[]</span>   <span class="o">=</span> <span class="p">{</span> <span class="mi">600</span><span class="p">,</span> <span class="mi">383</span><span class="p">,</span> <span class="mi">330</span><span class="p">,</span> <span class="mi">180</span><span class="p">,</span> <span class="mi">120</span> <span class="p">};</span>
<span class="cm">/* DIOR/DIOW to end cycle         */</span>
<span class="k">static</span> <span class="k">const</span> <span class="n">u32</span> <span class="n">reg_t2min</span><span class="p">[]</span>   <span class="o">=</span> <span class="p">{</span> <span class="mi">290</span><span class="p">,</span> <span class="mi">290</span><span class="p">,</span> <span class="mi">290</span><span class="p">,</span> <span class="mi">70</span><span class="p">,</span>  <span class="mi">25</span>  <span class="p">};</span>
<span class="cm">/* DIOR/DIOW asserted pulse width */</span>
<span class="k">static</span> <span class="k">const</span> <span class="n">u32</span> <span class="n">reg_teocmin</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">290</span><span class="p">,</span> <span class="mi">290</span><span class="p">,</span> <span class="mi">290</span><span class="p">,</span> <span class="mi">80</span><span class="p">,</span>  <span class="mi">70</span>  <span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * PIO timing table</span>
<span class="cm"> */</span>
<span class="cm">/*               mode:       0    1    2    3    4    */</span>
<span class="cm">/* Cycle Time                     */</span>
<span class="k">static</span> <span class="k">const</span> <span class="n">u32</span> <span class="n">pio_t0min</span><span class="p">[]</span>   <span class="o">=</span> <span class="p">{</span> <span class="mi">600</span><span class="p">,</span> <span class="mi">383</span><span class="p">,</span> <span class="mi">240</span><span class="p">,</span> <span class="mi">180</span><span class="p">,</span> <span class="mi">120</span> <span class="p">};</span>
<span class="cm">/* Address valid to DIOR/DIORW    */</span>
<span class="k">static</span> <span class="k">const</span> <span class="n">u32</span> <span class="n">pio_t1min</span><span class="p">[]</span>   <span class="o">=</span> <span class="p">{</span> <span class="mi">70</span><span class="p">,</span>  <span class="mi">50</span><span class="p">,</span>  <span class="mi">30</span><span class="p">,</span>  <span class="mi">30</span><span class="p">,</span>  <span class="mi">25</span>  <span class="p">};</span>
<span class="cm">/* DIOR/DIOW to end cycle         */</span>
<span class="k">static</span> <span class="k">const</span> <span class="n">u32</span> <span class="n">pio_t2min</span><span class="p">[]</span>   <span class="o">=</span> <span class="p">{</span> <span class="mi">165</span><span class="p">,</span> <span class="mi">125</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">80</span><span class="p">,</span>  <span class="mi">70</span>  <span class="p">};</span>
<span class="cm">/* DIOR/DIOW asserted pulse width */</span>
<span class="k">static</span> <span class="k">const</span> <span class="n">u32</span> <span class="n">pio_teocmin</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">165</span><span class="p">,</span> <span class="mi">125</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">70</span><span class="p">,</span>  <span class="mi">25</span>  <span class="p">};</span>
<span class="cm">/* DIOW data hold                 */</span>
<span class="k">static</span> <span class="k">const</span> <span class="n">u32</span> <span class="n">pio_t4min</span><span class="p">[]</span>   <span class="o">=</span> <span class="p">{</span> <span class="mi">30</span><span class="p">,</span>  <span class="mi">20</span><span class="p">,</span>  <span class="mi">15</span><span class="p">,</span>  <span class="mi">10</span><span class="p">,</span>  <span class="mi">10</span>  <span class="p">};</span>

<span class="cm">/* ******************************************************************</span>
<span class="cm"> * Multiword DMA timing table</span>
<span class="cm"> * ******************************************************************</span>
<span class="cm"> */</span>
<span class="cm">/*               mode:       0   1    2        */</span>
<span class="cm">/* Cycle Time                     */</span>
<span class="k">static</span> <span class="k">const</span> <span class="n">u32</span> <span class="n">mdma_t0min</span><span class="p">[]</span>  <span class="o">=</span> <span class="p">{</span> <span class="mi">480</span><span class="p">,</span> <span class="mi">150</span><span class="p">,</span> <span class="mi">120</span> <span class="p">};</span>
<span class="cm">/* DIOR/DIOW asserted pulse width */</span>
<span class="k">static</span> <span class="k">const</span> <span class="n">u32</span> <span class="n">mdma_tdmin</span><span class="p">[]</span>  <span class="o">=</span> <span class="p">{</span> <span class="mi">215</span><span class="p">,</span> <span class="mi">80</span><span class="p">,</span>  <span class="mi">70</span>  <span class="p">};</span>
<span class="cm">/* DMACK to read data released    */</span>
<span class="k">static</span> <span class="k">const</span> <span class="n">u32</span> <span class="n">mdma_thmin</span><span class="p">[]</span>  <span class="o">=</span> <span class="p">{</span> <span class="mi">20</span><span class="p">,</span>  <span class="mi">15</span><span class="p">,</span>  <span class="mi">10</span>  <span class="p">};</span>
<span class="cm">/* DIOR/DIOW to DMACK hold        */</span>
<span class="k">static</span> <span class="k">const</span> <span class="n">u32</span> <span class="n">mdma_tjmin</span><span class="p">[]</span>  <span class="o">=</span> <span class="p">{</span> <span class="mi">20</span><span class="p">,</span>  <span class="mi">5</span><span class="p">,</span>   <span class="mi">5</span>   <span class="p">};</span>
<span class="cm">/* DIOR negated pulse width       */</span>
<span class="k">static</span> <span class="k">const</span> <span class="n">u32</span> <span class="n">mdma_tkrmin</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">50</span><span class="p">,</span>  <span class="mi">50</span><span class="p">,</span>  <span class="mi">25</span>  <span class="p">};</span>
<span class="cm">/* DIOR negated pulse width       */</span>
<span class="k">static</span> <span class="k">const</span> <span class="n">u32</span> <span class="n">mdma_tkwmin</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">215</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span>  <span class="mi">25</span>  <span class="p">};</span>
<span class="cm">/* CS[1:0] valid to DIOR/DIOW     */</span>
<span class="k">static</span> <span class="k">const</span> <span class="n">u32</span> <span class="n">mdma_tmmin</span><span class="p">[]</span>  <span class="o">=</span> <span class="p">{</span> <span class="mi">50</span><span class="p">,</span>  <span class="mi">30</span><span class="p">,</span>  <span class="mi">25</span>  <span class="p">};</span>
<span class="cm">/* DMACK to read data released    */</span>
<span class="k">static</span> <span class="k">const</span> <span class="n">u32</span> <span class="n">mdma_tzmax</span><span class="p">[]</span>  <span class="o">=</span> <span class="p">{</span> <span class="mi">20</span><span class="p">,</span>  <span class="mi">25</span><span class="p">,</span>  <span class="mi">25</span>  <span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * Ultra DMA timing table</span>
<span class="cm"> */</span>
<span class="cm">/*               mode:         0    1    2    3    4    5       */</span>
<span class="k">static</span> <span class="k">const</span> <span class="n">u32</span> <span class="n">udma_tcycmin</span><span class="p">[]</span>  <span class="o">=</span> <span class="p">{</span> <span class="mi">112</span><span class="p">,</span> <span class="mi">73</span><span class="p">,</span>  <span class="mi">54</span><span class="p">,</span>  <span class="mi">39</span><span class="p">,</span>  <span class="mi">25</span><span class="p">,</span>  <span class="mi">17</span> <span class="p">};</span>
<span class="k">static</span> <span class="k">const</span> <span class="n">u32</span> <span class="n">udma_tdvsmin</span><span class="p">[]</span>  <span class="o">=</span> <span class="p">{</span> <span class="mi">70</span><span class="p">,</span>  <span class="mi">48</span><span class="p">,</span>  <span class="mi">31</span><span class="p">,</span>  <span class="mi">20</span><span class="p">,</span>  <span class="mi">7</span><span class="p">,</span>   <span class="mi">5</span>  <span class="p">};</span>
<span class="k">static</span> <span class="k">const</span> <span class="n">u32</span> <span class="n">udma_tenvmax</span><span class="p">[]</span>  <span class="o">=</span> <span class="p">{</span> <span class="mi">70</span><span class="p">,</span>  <span class="mi">70</span><span class="p">,</span>  <span class="mi">70</span><span class="p">,</span>  <span class="mi">55</span><span class="p">,</span>  <span class="mi">55</span><span class="p">,</span>  <span class="mi">50</span> <span class="p">};</span>
<span class="k">static</span> <span class="k">const</span> <span class="n">u32</span> <span class="n">udma_trpmin</span><span class="p">[]</span>   <span class="o">=</span> <span class="p">{</span> <span class="mi">160</span><span class="p">,</span> <span class="mi">125</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">85</span> <span class="p">};</span>
<span class="k">static</span> <span class="k">const</span> <span class="n">u32</span> <span class="n">udma_tmin</span><span class="p">[]</span>     <span class="o">=</span> <span class="p">{</span> <span class="mi">5</span><span class="p">,</span>   <span class="mi">5</span><span class="p">,</span>   <span class="mi">5</span><span class="p">,</span>   <span class="mi">5</span><span class="p">,</span>   <span class="mi">3</span><span class="p">,</span>   <span class="mi">3</span>  <span class="p">};</span>


<span class="k">static</span> <span class="k">const</span> <span class="n">u32</span> <span class="n">udma_tmlimin</span> <span class="o">=</span> <span class="mi">20</span><span class="p">;</span>
<span class="k">static</span> <span class="k">const</span> <span class="n">u32</span> <span class="n">udma_tzahmin</span> <span class="o">=</span> <span class="mi">20</span><span class="p">;</span>
<span class="k">static</span> <span class="k">const</span> <span class="n">u32</span> <span class="n">udma_tenvmin</span> <span class="o">=</span> <span class="mi">20</span><span class="p">;</span>
<span class="k">static</span> <span class="k">const</span> <span class="n">u32</span> <span class="n">udma_tackmin</span> <span class="o">=</span> <span class="mi">20</span><span class="p">;</span>
<span class="k">static</span> <span class="k">const</span> <span class="n">u32</span> <span class="n">udma_tssmin</span> <span class="o">=</span> <span class="mi">50</span><span class="p">;</span>

<span class="cp">#define BFIN_MAX_SG_SEGMENTS 4</span>

<span class="cm">/**</span>
<span class="cm"> *</span>
<span class="cm"> *	Function:       num_clocks_min</span>
<span class="cm"> *</span>
<span class="cm"> *	Description:</span>
<span class="cm"> *	calculate number of SCLK cycles to meet minimum timing</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">short</span> <span class="nf">num_clocks_min</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">tmin</span><span class="p">,</span>
				<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">fsclk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">tmp</span> <span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">result</span><span class="p">;</span>

	<span class="n">tmp</span> <span class="o">=</span> <span class="n">tmin</span> <span class="o">*</span> <span class="p">(</span><span class="n">fsclk</span><span class="o">/</span><span class="mi">1000</span><span class="o">/</span><span class="mi">1000</span><span class="p">)</span> <span class="o">/</span> <span class="mi">1000</span><span class="p">;</span>
	<span class="n">result</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">short</span><span class="p">)</span><span class="n">tmp</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">tmp</span><span class="o">*</span><span class="mi">1000</span><span class="o">*</span><span class="mi">1000</span><span class="p">)</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">tmin</span><span class="o">*</span><span class="p">(</span><span class="n">fsclk</span><span class="o">/</span><span class="mi">1000</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">result</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	bfin_set_piomode - Initialize host controller PATA PIO timings</span>
<span class="cm"> *	@ap: Port whose timings we are configuring</span>
<span class="cm"> *	@adev: um</span>
<span class="cm"> *</span>
<span class="cm"> *	Set PIO mode for device.</span>
<span class="cm"> *</span>
<span class="cm"> *	LOCKING:</span>
<span class="cm"> *	None (inherited from caller).</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">bfin_set_piomode</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ata_device</span> <span class="o">*</span><span class="n">adev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">mode</span> <span class="o">=</span> <span class="n">adev</span><span class="o">-&gt;</span><span class="n">pio_mode</span> <span class="o">-</span> <span class="n">XFER_PIO_0</span><span class="p">;</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">base</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="p">)</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">ioaddr</span><span class="p">.</span><span class="n">ctl_addr</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">fsclk</span> <span class="o">=</span> <span class="n">get_sclk</span><span class="p">();</span>
	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">teoc_reg</span><span class="p">,</span> <span class="n">t2_reg</span><span class="p">,</span> <span class="n">teoc_pio</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">t4_reg</span><span class="p">,</span> <span class="n">t2_pio</span><span class="p">,</span> <span class="n">t1_reg</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">n0</span><span class="p">,</span> <span class="n">n6</span><span class="p">,</span> <span class="n">t6min</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>

	<span class="cm">/* the most restrictive timing value is t6 and tc, the DIOW - data hold</span>
<span class="cm">	* If one SCLK pulse is longer than this minimum value then register</span>
<span class="cm">	* transfers cannot be supported at this frequency.</span>
<span class="cm">	*/</span>
	<span class="n">n6</span> <span class="o">=</span> <span class="n">num_clocks_min</span><span class="p">(</span><span class="n">t6min</span><span class="p">,</span> <span class="n">fsclk</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mode</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">mode</span> <span class="o">&lt;=</span> <span class="mi">4</span> <span class="o">&amp;&amp;</span> <span class="n">n6</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_dbg</span><span class="p">(</span><span class="n">adev</span><span class="o">-&gt;</span><span class="n">link</span><span class="o">-&gt;</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;set piomode: mode=%d, fsclk=%ud</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="n">fsclk</span><span class="p">);</span>
		<span class="cm">/* calculate the timing values for register transfers. */</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">mode</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">pio_fsclk</span><span class="p">[</span><span class="n">mode</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">fsclk</span><span class="p">)</span>
			<span class="n">mode</span><span class="o">--</span><span class="p">;</span>

		<span class="cm">/* DIOR/DIOW to end cycle time */</span>
		<span class="n">t2_reg</span> <span class="o">=</span> <span class="n">num_clocks_min</span><span class="p">(</span><span class="n">reg_t2min</span><span class="p">[</span><span class="n">mode</span><span class="p">],</span> <span class="n">fsclk</span><span class="p">);</span>
		<span class="cm">/* DIOR/DIOW asserted pulse width */</span>
		<span class="n">teoc_reg</span> <span class="o">=</span> <span class="n">num_clocks_min</span><span class="p">(</span><span class="n">reg_teocmin</span><span class="p">[</span><span class="n">mode</span><span class="p">],</span> <span class="n">fsclk</span><span class="p">);</span>
		<span class="cm">/* Cycle Time */</span>
		<span class="n">n0</span>  <span class="o">=</span> <span class="n">num_clocks_min</span><span class="p">(</span><span class="n">reg_t0min</span><span class="p">[</span><span class="n">mode</span><span class="p">],</span> <span class="n">fsclk</span><span class="p">);</span>

		<span class="cm">/* increase t2 until we meed the minimum cycle length */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">t2_reg</span> <span class="o">+</span> <span class="n">teoc_reg</span> <span class="o">&lt;</span> <span class="n">n0</span><span class="p">)</span>
			<span class="n">t2_reg</span> <span class="o">=</span> <span class="n">n0</span> <span class="o">-</span> <span class="n">teoc_reg</span><span class="p">;</span>

		<span class="cm">/* calculate the timing values for pio transfers. */</span>

		<span class="cm">/* DIOR/DIOW to end cycle time */</span>
		<span class="n">t2_pio</span> <span class="o">=</span> <span class="n">num_clocks_min</span><span class="p">(</span><span class="n">pio_t2min</span><span class="p">[</span><span class="n">mode</span><span class="p">],</span> <span class="n">fsclk</span><span class="p">);</span>
		<span class="cm">/* DIOR/DIOW asserted pulse width */</span>
		<span class="n">teoc_pio</span> <span class="o">=</span> <span class="n">num_clocks_min</span><span class="p">(</span><span class="n">pio_teocmin</span><span class="p">[</span><span class="n">mode</span><span class="p">],</span> <span class="n">fsclk</span><span class="p">);</span>
		<span class="cm">/* Cycle Time */</span>
		<span class="n">n0</span>  <span class="o">=</span> <span class="n">num_clocks_min</span><span class="p">(</span><span class="n">pio_t0min</span><span class="p">[</span><span class="n">mode</span><span class="p">],</span> <span class="n">fsclk</span><span class="p">);</span>

		<span class="cm">/* increase t2 until we meed the minimum cycle length */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">t2_pio</span> <span class="o">+</span> <span class="n">teoc_pio</span> <span class="o">&lt;</span> <span class="n">n0</span><span class="p">)</span>
			<span class="n">t2_pio</span> <span class="o">=</span> <span class="n">n0</span> <span class="o">-</span> <span class="n">teoc_pio</span><span class="p">;</span>

		<span class="cm">/* Address valid to DIOR/DIORW */</span>
		<span class="n">t1_reg</span> <span class="o">=</span> <span class="n">num_clocks_min</span><span class="p">(</span><span class="n">pio_t1min</span><span class="p">[</span><span class="n">mode</span><span class="p">],</span> <span class="n">fsclk</span><span class="p">);</span>

		<span class="cm">/* DIOW data hold */</span>
		<span class="n">t4_reg</span> <span class="o">=</span> <span class="n">num_clocks_min</span><span class="p">(</span><span class="n">pio_t4min</span><span class="p">[</span><span class="n">mode</span><span class="p">],</span> <span class="n">fsclk</span><span class="p">);</span>

		<span class="n">ATAPI_SET_REG_TIM_0</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="p">(</span><span class="n">teoc_reg</span><span class="o">&lt;&lt;</span><span class="mi">8</span> <span class="o">|</span> <span class="n">t2_reg</span><span class="p">));</span>
		<span class="n">ATAPI_SET_PIO_TIM_0</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="p">(</span><span class="n">t4_reg</span><span class="o">&lt;&lt;</span><span class="mi">12</span> <span class="o">|</span> <span class="n">t2_pio</span><span class="o">&lt;&lt;</span><span class="mi">4</span> <span class="o">|</span> <span class="n">t1_reg</span><span class="p">));</span>
		<span class="n">ATAPI_SET_PIO_TIM_1</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">teoc_pio</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">mode</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ATAPI_SET_CONTROL</span><span class="p">(</span><span class="n">base</span><span class="p">,</span>
				<span class="n">ATAPI_GET_CONTROL</span><span class="p">(</span><span class="n">base</span><span class="p">)</span> <span class="o">|</span> <span class="n">IORDY_EN</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">ATAPI_SET_CONTROL</span><span class="p">(</span><span class="n">base</span><span class="p">,</span>
				<span class="n">ATAPI_GET_CONTROL</span><span class="p">(</span><span class="n">base</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">IORDY_EN</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="cm">/* Disable host ATAPI PIO interrupts */</span>
		<span class="n">ATAPI_SET_INT_MASK</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">ATAPI_GET_INT_MASK</span><span class="p">(</span><span class="n">base</span><span class="p">)</span>
			<span class="o">&amp;</span> <span class="o">~</span><span class="p">(</span><span class="n">PIO_DONE_MASK</span> <span class="o">|</span> <span class="n">HOST_TERM_XFER_MASK</span><span class="p">));</span>
		<span class="n">SSYNC</span><span class="p">();</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	bfin_set_dmamode - Initialize host controller PATA DMA timings</span>
<span class="cm"> *	@ap: Port whose timings we are configuring</span>
<span class="cm"> *	@adev: um</span>
<span class="cm"> *</span>
<span class="cm"> *	Set UDMA mode for device.</span>
<span class="cm"> *</span>
<span class="cm"> *	LOCKING:</span>
<span class="cm"> *	None (inherited from caller).</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">bfin_set_dmamode</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ata_device</span> <span class="o">*</span><span class="n">adev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">mode</span><span class="p">;</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">base</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="p">)</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">ioaddr</span><span class="p">.</span><span class="n">ctl_addr</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">fsclk</span> <span class="o">=</span> <span class="n">get_sclk</span><span class="p">();</span>
	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">tenv</span><span class="p">,</span> <span class="n">tack</span><span class="p">,</span> <span class="n">tcyc_tdvs</span><span class="p">,</span> <span class="n">tdvs</span><span class="p">,</span> <span class="n">tmli</span><span class="p">,</span> <span class="n">tss</span><span class="p">,</span> <span class="n">trp</span><span class="p">,</span> <span class="n">tzah</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">tm</span><span class="p">,</span> <span class="n">td</span><span class="p">,</span> <span class="n">tkr</span><span class="p">,</span> <span class="n">tkw</span><span class="p">,</span> <span class="n">teoc</span><span class="p">,</span> <span class="n">th</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">n0</span><span class="p">,</span> <span class="n">nf</span><span class="p">,</span> <span class="n">tfmin</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">nmin</span><span class="p">,</span> <span class="n">tcyc</span><span class="p">;</span>

	<span class="n">mode</span> <span class="o">=</span> <span class="n">adev</span><span class="o">-&gt;</span><span class="n">dma_mode</span> <span class="o">-</span> <span class="n">XFER_UDMA_0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mode</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">mode</span> <span class="o">&lt;=</span> <span class="mi">5</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_dbg</span><span class="p">(</span><span class="n">adev</span><span class="o">-&gt;</span><span class="n">link</span><span class="o">-&gt;</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;set udmamode: mode=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">mode</span><span class="p">);</span>
		<span class="cm">/* the most restrictive timing value is t6 and tc,</span>
<span class="cm">		 * the DIOW - data hold. If one SCLK pulse is longer</span>
<span class="cm">		 * than this minimum value then register</span>
<span class="cm">		 * transfers cannot be supported at this frequency.</span>
<span class="cm">		 */</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">mode</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">udma_fsclk</span><span class="p">[</span><span class="n">mode</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">fsclk</span><span class="p">)</span>
			<span class="n">mode</span><span class="o">--</span><span class="p">;</span>

		<span class="n">nmin</span> <span class="o">=</span> <span class="n">num_clocks_min</span><span class="p">(</span><span class="n">udma_tmin</span><span class="p">[</span><span class="n">mode</span><span class="p">],</span> <span class="n">fsclk</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">nmin</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* calculate the timing values for Ultra DMA. */</span>
			<span class="n">tdvs</span> <span class="o">=</span> <span class="n">num_clocks_min</span><span class="p">(</span><span class="n">udma_tdvsmin</span><span class="p">[</span><span class="n">mode</span><span class="p">],</span> <span class="n">fsclk</span><span class="p">);</span>
			<span class="n">tcyc</span> <span class="o">=</span> <span class="n">num_clocks_min</span><span class="p">(</span><span class="n">udma_tcycmin</span><span class="p">[</span><span class="n">mode</span><span class="p">],</span> <span class="n">fsclk</span><span class="p">);</span>
			<span class="n">tcyc_tdvs</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>

			<span class="cm">/* increase tcyc - tdvs (tcyc_tdvs) until we meed</span>
<span class="cm">			 * the minimum cycle length</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">tdvs</span> <span class="o">+</span> <span class="n">tcyc_tdvs</span> <span class="o">&lt;</span> <span class="n">tcyc</span><span class="p">)</span>
				<span class="n">tcyc_tdvs</span> <span class="o">=</span> <span class="n">tcyc</span> <span class="o">-</span> <span class="n">tdvs</span><span class="p">;</span>

			<span class="cm">/* Mow assign the values required for the timing</span>
<span class="cm">			 * registers</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">tcyc_tdvs</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">)</span>
				<span class="n">tcyc_tdvs</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">tdvs</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">)</span>
				<span class="n">tdvs</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>

			<span class="n">tack</span> <span class="o">=</span> <span class="n">num_clocks_min</span><span class="p">(</span><span class="n">udma_tackmin</span><span class="p">,</span> <span class="n">fsclk</span><span class="p">);</span>
			<span class="n">tss</span> <span class="o">=</span> <span class="n">num_clocks_min</span><span class="p">(</span><span class="n">udma_tssmin</span><span class="p">,</span> <span class="n">fsclk</span><span class="p">);</span>
			<span class="n">tmli</span> <span class="o">=</span> <span class="n">num_clocks_min</span><span class="p">(</span><span class="n">udma_tmlimin</span><span class="p">,</span> <span class="n">fsclk</span><span class="p">);</span>
			<span class="n">tzah</span> <span class="o">=</span> <span class="n">num_clocks_min</span><span class="p">(</span><span class="n">udma_tzahmin</span><span class="p">,</span> <span class="n">fsclk</span><span class="p">);</span>
			<span class="n">trp</span> <span class="o">=</span> <span class="n">num_clocks_min</span><span class="p">(</span><span class="n">udma_trpmin</span><span class="p">[</span><span class="n">mode</span><span class="p">],</span> <span class="n">fsclk</span><span class="p">);</span>
			<span class="n">tenv</span> <span class="o">=</span> <span class="n">num_clocks_min</span><span class="p">(</span><span class="n">udma_tenvmin</span><span class="p">,</span> <span class="n">fsclk</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">tenv</span> <span class="o">&lt;=</span> <span class="n">udma_tenvmax</span><span class="p">[</span><span class="n">mode</span><span class="p">])</span> <span class="p">{</span>
				<span class="n">ATAPI_SET_ULTRA_TIM_0</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="p">(</span><span class="n">tenv</span><span class="o">&lt;&lt;</span><span class="mi">8</span> <span class="o">|</span> <span class="n">tack</span><span class="p">));</span>
				<span class="n">ATAPI_SET_ULTRA_TIM_1</span><span class="p">(</span><span class="n">base</span><span class="p">,</span>
					<span class="p">(</span><span class="n">tcyc_tdvs</span><span class="o">&lt;&lt;</span><span class="mi">8</span> <span class="o">|</span> <span class="n">tdvs</span><span class="p">));</span>
				<span class="n">ATAPI_SET_ULTRA_TIM_2</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="p">(</span><span class="n">tmli</span><span class="o">&lt;&lt;</span><span class="mi">8</span> <span class="o">|</span> <span class="n">tss</span><span class="p">));</span>
				<span class="n">ATAPI_SET_ULTRA_TIM_3</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="p">(</span><span class="n">trp</span><span class="o">&lt;&lt;</span><span class="mi">8</span> <span class="o">|</span> <span class="n">tzah</span><span class="p">));</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">mode</span> <span class="o">=</span> <span class="n">adev</span><span class="o">-&gt;</span><span class="n">dma_mode</span> <span class="o">-</span> <span class="n">XFER_MW_DMA_0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mode</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">mode</span> <span class="o">&lt;=</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_dbg</span><span class="p">(</span><span class="n">adev</span><span class="o">-&gt;</span><span class="n">link</span><span class="o">-&gt;</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;set mdmamode: mode=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">mode</span><span class="p">);</span>
		<span class="cm">/* the most restrictive timing value is tf, the DMACK to</span>
<span class="cm">		 * read data released. If one SCLK pulse is longer than</span>
<span class="cm">		 * this maximum value then the MDMA mode</span>
<span class="cm">		 * cannot be supported at this frequency.</span>
<span class="cm">		 */</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">mode</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">mdma_fsclk</span><span class="p">[</span><span class="n">mode</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">fsclk</span><span class="p">)</span>
			<span class="n">mode</span><span class="o">--</span><span class="p">;</span>

		<span class="n">nf</span> <span class="o">=</span> <span class="n">num_clocks_min</span><span class="p">(</span><span class="n">tfmin</span><span class="p">,</span> <span class="n">fsclk</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">nf</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* calculate the timing values for Multi-word DMA. */</span>

			<span class="cm">/* DIOR/DIOW asserted pulse width */</span>
			<span class="n">td</span> <span class="o">=</span> <span class="n">num_clocks_min</span><span class="p">(</span><span class="n">mdma_tdmin</span><span class="p">[</span><span class="n">mode</span><span class="p">],</span> <span class="n">fsclk</span><span class="p">);</span>

			<span class="cm">/* DIOR negated pulse width */</span>
			<span class="n">tkw</span> <span class="o">=</span> <span class="n">num_clocks_min</span><span class="p">(</span><span class="n">mdma_tkwmin</span><span class="p">[</span><span class="n">mode</span><span class="p">],</span> <span class="n">fsclk</span><span class="p">);</span>

			<span class="cm">/* Cycle Time */</span>
			<span class="n">n0</span>  <span class="o">=</span> <span class="n">num_clocks_min</span><span class="p">(</span><span class="n">mdma_t0min</span><span class="p">[</span><span class="n">mode</span><span class="p">],</span> <span class="n">fsclk</span><span class="p">);</span>

			<span class="cm">/* increase tk until we meed the minimum cycle length */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">tkw</span> <span class="o">+</span> <span class="n">td</span> <span class="o">&lt;</span> <span class="n">n0</span><span class="p">)</span>
				<span class="n">tkw</span> <span class="o">=</span> <span class="n">n0</span> <span class="o">-</span> <span class="n">td</span><span class="p">;</span>

			<span class="cm">/* DIOR negated pulse width - read */</span>
			<span class="n">tkr</span> <span class="o">=</span> <span class="n">num_clocks_min</span><span class="p">(</span><span class="n">mdma_tkrmin</span><span class="p">[</span><span class="n">mode</span><span class="p">],</span> <span class="n">fsclk</span><span class="p">);</span>
			<span class="cm">/* CS{1:0] valid to DIOR/DIOW */</span>
			<span class="n">tm</span> <span class="o">=</span> <span class="n">num_clocks_min</span><span class="p">(</span><span class="n">mdma_tmmin</span><span class="p">[</span><span class="n">mode</span><span class="p">],</span> <span class="n">fsclk</span><span class="p">);</span>
			<span class="cm">/* DIOR/DIOW to DMACK hold */</span>
			<span class="n">teoc</span> <span class="o">=</span> <span class="n">num_clocks_min</span><span class="p">(</span><span class="n">mdma_tjmin</span><span class="p">[</span><span class="n">mode</span><span class="p">],</span> <span class="n">fsclk</span><span class="p">);</span>
			<span class="cm">/* DIOW Data hold */</span>
			<span class="n">th</span> <span class="o">=</span> <span class="n">num_clocks_min</span><span class="p">(</span><span class="n">mdma_thmin</span><span class="p">[</span><span class="n">mode</span><span class="p">],</span> <span class="n">fsclk</span><span class="p">);</span>

			<span class="n">ATAPI_SET_MULTI_TIM_0</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="p">(</span><span class="n">tm</span><span class="o">&lt;&lt;</span><span class="mi">8</span> <span class="o">|</span> <span class="n">td</span><span class="p">));</span>
			<span class="n">ATAPI_SET_MULTI_TIM_1</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="p">(</span><span class="n">tkr</span><span class="o">&lt;&lt;</span><span class="mi">8</span> <span class="o">|</span> <span class="n">tkw</span><span class="p">));</span>
			<span class="n">ATAPI_SET_MULTI_TIM_2</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="p">(</span><span class="n">teoc</span><span class="o">&lt;&lt;</span><span class="mi">8</span> <span class="o">|</span> <span class="n">th</span><span class="p">));</span>
			<span class="n">SSYNC</span><span class="p">();</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *</span>
<span class="cm"> *    Function:       wait_complete</span>
<span class="cm"> *</span>
<span class="cm"> *    Description:    Waits the interrupt from device</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">wait_complete</span><span class="p">(</span><span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">base</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">mask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">status</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="cp">#define PATA_BF54X_WAIT_TIMEOUT		10000</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">PATA_BF54X_WAIT_TIMEOUT</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">ATAPI_GET_INT_STATUS</span><span class="p">(</span><span class="n">base</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">mask</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">status</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ATAPI_SET_INT_STATUS</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">mask</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *</span>
<span class="cm"> *    Function:       write_atapi_register</span>
<span class="cm"> *</span>
<span class="cm"> *    Description:    Writes to ATA Device Resgister</span>
<span class="cm"> *</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">write_atapi_register</span><span class="p">(</span><span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">base</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ata_reg</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">value</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Program the ATA_DEV_TXBUF register with write data (to be</span>
<span class="cm">	 * written into the device).</span>
<span class="cm">	 */</span>
	<span class="n">ATAPI_SET_DEV_TXBUF</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">value</span><span class="p">);</span>

	<span class="cm">/* Program the ATA_DEV_ADDR register with address of the</span>
<span class="cm">	 * device register (0x01 to 0x0F).</span>
<span class="cm">	 */</span>
	<span class="n">ATAPI_SET_DEV_ADDR</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">ata_reg</span><span class="p">);</span>

	<span class="cm">/* Program the ATA_CTRL register with dir set to write (1)</span>
<span class="cm">	 */</span>
	<span class="n">ATAPI_SET_CONTROL</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="p">(</span><span class="n">ATAPI_GET_CONTROL</span><span class="p">(</span><span class="n">base</span><span class="p">)</span> <span class="o">|</span> <span class="n">XFER_DIR</span><span class="p">));</span>

	<span class="cm">/* ensure PIO DMA is not set */</span>
	<span class="n">ATAPI_SET_CONTROL</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="p">(</span><span class="n">ATAPI_GET_CONTROL</span><span class="p">(</span><span class="n">base</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">PIO_USE_DMA</span><span class="p">));</span>

	<span class="cm">/* and start the transfer */</span>
	<span class="n">ATAPI_SET_CONTROL</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="p">(</span><span class="n">ATAPI_GET_CONTROL</span><span class="p">(</span><span class="n">base</span><span class="p">)</span> <span class="o">|</span> <span class="n">PIO_START</span><span class="p">));</span>

	<span class="cm">/* Wait for the interrupt to indicate the end of the transfer.</span>
<span class="cm">	 * (We need to wait on and clear rhe ATA_DEV_INT interrupt status)</span>
<span class="cm">	 */</span>
	<span class="n">wait_complete</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">PIO_DONE_INT</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *</span>
<span class="cm"> *	Function:       read_atapi_register</span>
<span class="cm"> *</span>
<span class="cm"> *Description:    Reads from ATA Device Resgister</span>
<span class="cm"> *</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">short</span> <span class="nf">read_atapi_register</span><span class="p">(</span><span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">base</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ata_reg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Program the ATA_DEV_ADDR register with address of the</span>
<span class="cm">	 * device register (0x01 to 0x0F).</span>
<span class="cm">	 */</span>
	<span class="n">ATAPI_SET_DEV_ADDR</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">ata_reg</span><span class="p">);</span>

	<span class="cm">/* Program the ATA_CTRL register with dir set to read (0) and</span>
<span class="cm">	 */</span>
	<span class="n">ATAPI_SET_CONTROL</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="p">(</span><span class="n">ATAPI_GET_CONTROL</span><span class="p">(</span><span class="n">base</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">XFER_DIR</span><span class="p">));</span>

	<span class="cm">/* ensure PIO DMA is not set */</span>
	<span class="n">ATAPI_SET_CONTROL</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="p">(</span><span class="n">ATAPI_GET_CONTROL</span><span class="p">(</span><span class="n">base</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">PIO_USE_DMA</span><span class="p">));</span>

	<span class="cm">/* and start the transfer */</span>
	<span class="n">ATAPI_SET_CONTROL</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="p">(</span><span class="n">ATAPI_GET_CONTROL</span><span class="p">(</span><span class="n">base</span><span class="p">)</span> <span class="o">|</span> <span class="n">PIO_START</span><span class="p">));</span>

	<span class="cm">/* Wait for the interrupt to indicate the end of the transfer.</span>
<span class="cm">	 * (PIO_DONE interrupt is set and it doesn&#39;t seem to matter</span>
<span class="cm">	 * that we don&#39;t clear it)</span>
<span class="cm">	 */</span>
	<span class="n">wait_complete</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">PIO_DONE_INT</span><span class="p">);</span>

	<span class="cm">/* Read the ATA_DEV_RXBUF register with write data (to be</span>
<span class="cm">	 * written into the device).</span>
<span class="cm">	 */</span>
	<span class="k">return</span> <span class="n">ATAPI_GET_DEV_RXBUF</span><span class="p">(</span><span class="n">base</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *</span>
<span class="cm"> *    Function:       write_atapi_register_data</span>
<span class="cm"> *</span>
<span class="cm"> *    Description:    Writes to ATA Device Resgister</span>
<span class="cm"> *</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">write_atapi_data</span><span class="p">(</span><span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">base</span><span class="p">,</span>
		<span class="kt">int</span> <span class="n">len</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">short</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="cm">/* Set transfer length to 1 */</span>
	<span class="n">ATAPI_SET_XFER_LEN</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

	<span class="cm">/* Program the ATA_DEV_ADDR register with address of the</span>
<span class="cm">	 * ATA_REG_DATA</span>
<span class="cm">	 */</span>
	<span class="n">ATAPI_SET_DEV_ADDR</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">ATA_REG_DATA</span><span class="p">);</span>

	<span class="cm">/* Program the ATA_CTRL register with dir set to write (1)</span>
<span class="cm">	 */</span>
	<span class="n">ATAPI_SET_CONTROL</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="p">(</span><span class="n">ATAPI_GET_CONTROL</span><span class="p">(</span><span class="n">base</span><span class="p">)</span> <span class="o">|</span> <span class="n">XFER_DIR</span><span class="p">));</span>

	<span class="cm">/* ensure PIO DMA is not set */</span>
	<span class="n">ATAPI_SET_CONTROL</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="p">(</span><span class="n">ATAPI_GET_CONTROL</span><span class="p">(</span><span class="n">base</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">PIO_USE_DMA</span><span class="p">));</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">len</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Program the ATA_DEV_TXBUF register with write data (to be</span>
<span class="cm">		 * written into the device).</span>
<span class="cm">		 */</span>
		<span class="n">ATAPI_SET_DEV_TXBUF</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">buf</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>

		<span class="cm">/* and start the transfer */</span>
		<span class="n">ATAPI_SET_CONTROL</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="p">(</span><span class="n">ATAPI_GET_CONTROL</span><span class="p">(</span><span class="n">base</span><span class="p">)</span> <span class="o">|</span> <span class="n">PIO_START</span><span class="p">));</span>

		<span class="cm">/* Wait for the interrupt to indicate the end of the transfer.</span>
<span class="cm">		 * (We need to wait on and clear rhe ATA_DEV_INT</span>
<span class="cm">		 * interrupt status)</span>
<span class="cm">		 */</span>
		<span class="n">wait_complete</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">PIO_DONE_INT</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *</span>
<span class="cm"> *	Function:       read_atapi_register_data</span>
<span class="cm"> *</span>
<span class="cm"> *	Description:    Reads from ATA Device Resgister</span>
<span class="cm"> *</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">read_atapi_data</span><span class="p">(</span><span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">base</span><span class="p">,</span>
		<span class="kt">int</span> <span class="n">len</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">short</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="cm">/* Set transfer length to 1 */</span>
	<span class="n">ATAPI_SET_XFER_LEN</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

	<span class="cm">/* Program the ATA_DEV_ADDR register with address of the</span>
<span class="cm">	 * ATA_REG_DATA</span>
<span class="cm">	 */</span>
	<span class="n">ATAPI_SET_DEV_ADDR</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">ATA_REG_DATA</span><span class="p">);</span>

	<span class="cm">/* Program the ATA_CTRL register with dir set to read (0) and</span>
<span class="cm">	 */</span>
	<span class="n">ATAPI_SET_CONTROL</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="p">(</span><span class="n">ATAPI_GET_CONTROL</span><span class="p">(</span><span class="n">base</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">XFER_DIR</span><span class="p">));</span>

	<span class="cm">/* ensure PIO DMA is not set */</span>
	<span class="n">ATAPI_SET_CONTROL</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="p">(</span><span class="n">ATAPI_GET_CONTROL</span><span class="p">(</span><span class="n">base</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">PIO_USE_DMA</span><span class="p">));</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">len</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* and start the transfer */</span>
		<span class="n">ATAPI_SET_CONTROL</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="p">(</span><span class="n">ATAPI_GET_CONTROL</span><span class="p">(</span><span class="n">base</span><span class="p">)</span> <span class="o">|</span> <span class="n">PIO_START</span><span class="p">));</span>

		<span class="cm">/* Wait for the interrupt to indicate the end of the transfer.</span>
<span class="cm">		 * (PIO_DONE interrupt is set and it doesn&#39;t seem to matter</span>
<span class="cm">		 * that we don&#39;t clear it)</span>
<span class="cm">		 */</span>
		<span class="n">wait_complete</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">PIO_DONE_INT</span><span class="p">);</span>

		<span class="cm">/* Read the ATA_DEV_RXBUF register with write data (to be</span>
<span class="cm">		 * written into the device).</span>
<span class="cm">		 */</span>
		<span class="n">buf</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">ATAPI_GET_DEV_RXBUF</span><span class="p">(</span><span class="n">base</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	bfin_tf_load - send taskfile registers to host controller</span>
<span class="cm"> *	@ap: Port to which output is sent</span>
<span class="cm"> *	@tf: ATA taskfile register set</span>
<span class="cm"> *</span>
<span class="cm"> *	Note: Original code is ata_sff_tf_load().</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">bfin_tf_load</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">ata_taskfile</span> <span class="o">*</span><span class="n">tf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">base</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="p">)</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">ioaddr</span><span class="p">.</span><span class="n">ctl_addr</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">is_addr</span> <span class="o">=</span> <span class="n">tf</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">ATA_TFLAG_ISADDR</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">tf</span><span class="o">-&gt;</span><span class="n">ctl</span> <span class="o">!=</span> <span class="n">ap</span><span class="o">-&gt;</span><span class="n">last_ctl</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">write_atapi_register</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">ATA_REG_CTRL</span><span class="p">,</span> <span class="n">tf</span><span class="o">-&gt;</span><span class="n">ctl</span><span class="p">);</span>
		<span class="n">ap</span><span class="o">-&gt;</span><span class="n">last_ctl</span> <span class="o">=</span> <span class="n">tf</span><span class="o">-&gt;</span><span class="n">ctl</span><span class="p">;</span>
		<span class="n">ata_wait_idle</span><span class="p">(</span><span class="n">ap</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">is_addr</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tf</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">ATA_TFLAG_LBA48</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">write_atapi_register</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">ATA_REG_FEATURE</span><span class="p">,</span>
						<span class="n">tf</span><span class="o">-&gt;</span><span class="n">hob_feature</span><span class="p">);</span>
			<span class="n">write_atapi_register</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">ATA_REG_NSECT</span><span class="p">,</span>
						<span class="n">tf</span><span class="o">-&gt;</span><span class="n">hob_nsect</span><span class="p">);</span>
			<span class="n">write_atapi_register</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">ATA_REG_LBAL</span><span class="p">,</span> <span class="n">tf</span><span class="o">-&gt;</span><span class="n">hob_lbal</span><span class="p">);</span>
			<span class="n">write_atapi_register</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">ATA_REG_LBAM</span><span class="p">,</span> <span class="n">tf</span><span class="o">-&gt;</span><span class="n">hob_lbam</span><span class="p">);</span>
			<span class="n">write_atapi_register</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">ATA_REG_LBAH</span><span class="p">,</span> <span class="n">tf</span><span class="o">-&gt;</span><span class="n">hob_lbah</span><span class="p">);</span>
			<span class="n">dev_dbg</span><span class="p">(</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;hob: feat 0x%X nsect 0x%X, lba 0x%X &quot;</span>
				 <span class="s">&quot;0x%X 0x%X</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">tf</span><span class="o">-&gt;</span><span class="n">hob_feature</span><span class="p">,</span>
				<span class="n">tf</span><span class="o">-&gt;</span><span class="n">hob_nsect</span><span class="p">,</span>
				<span class="n">tf</span><span class="o">-&gt;</span><span class="n">hob_lbal</span><span class="p">,</span>
				<span class="n">tf</span><span class="o">-&gt;</span><span class="n">hob_lbam</span><span class="p">,</span>
				<span class="n">tf</span><span class="o">-&gt;</span><span class="n">hob_lbah</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="n">write_atapi_register</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">ATA_REG_FEATURE</span><span class="p">,</span> <span class="n">tf</span><span class="o">-&gt;</span><span class="n">feature</span><span class="p">);</span>
		<span class="n">write_atapi_register</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">ATA_REG_NSECT</span><span class="p">,</span> <span class="n">tf</span><span class="o">-&gt;</span><span class="n">nsect</span><span class="p">);</span>
		<span class="n">write_atapi_register</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">ATA_REG_LBAL</span><span class="p">,</span> <span class="n">tf</span><span class="o">-&gt;</span><span class="n">lbal</span><span class="p">);</span>
		<span class="n">write_atapi_register</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">ATA_REG_LBAM</span><span class="p">,</span> <span class="n">tf</span><span class="o">-&gt;</span><span class="n">lbam</span><span class="p">);</span>
		<span class="n">write_atapi_register</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">ATA_REG_LBAH</span><span class="p">,</span> <span class="n">tf</span><span class="o">-&gt;</span><span class="n">lbah</span><span class="p">);</span>
		<span class="n">dev_dbg</span><span class="p">(</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;feat 0x%X nsect 0x%X lba 0x%X 0x%X 0x%X</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">tf</span><span class="o">-&gt;</span><span class="n">feature</span><span class="p">,</span>
			<span class="n">tf</span><span class="o">-&gt;</span><span class="n">nsect</span><span class="p">,</span>
			<span class="n">tf</span><span class="o">-&gt;</span><span class="n">lbal</span><span class="p">,</span>
			<span class="n">tf</span><span class="o">-&gt;</span><span class="n">lbam</span><span class="p">,</span>
			<span class="n">tf</span><span class="o">-&gt;</span><span class="n">lbah</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">tf</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">ATA_TFLAG_DEVICE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">write_atapi_register</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">ATA_REG_DEVICE</span><span class="p">,</span> <span class="n">tf</span><span class="o">-&gt;</span><span class="n">device</span><span class="p">);</span>
		<span class="n">dev_dbg</span><span class="p">(</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;device 0x%X</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">tf</span><span class="o">-&gt;</span><span class="n">device</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">ata_wait_idle</span><span class="p">(</span><span class="n">ap</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	bfin_check_status - Read device status reg &amp; clear interrupt</span>
<span class="cm"> *	@ap: port where the device is</span>
<span class="cm"> *</span>
<span class="cm"> *	Note: Original code is ata_check_status().</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="n">u8</span> <span class="nf">bfin_check_status</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">base</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="p">)</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">ioaddr</span><span class="p">.</span><span class="n">ctl_addr</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">read_atapi_register</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">ATA_REG_STATUS</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	bfin_tf_read - input device&#39;s ATA taskfile shadow registers</span>
<span class="cm"> *	@ap: Port from which input is read</span>
<span class="cm"> *	@tf: ATA taskfile register set for storing input</span>
<span class="cm"> *</span>
<span class="cm"> *	Note: Original code is ata_sff_tf_read().</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">bfin_tf_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ata_taskfile</span> <span class="o">*</span><span class="n">tf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">base</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="p">)</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">ioaddr</span><span class="p">.</span><span class="n">ctl_addr</span><span class="p">;</span>

	<span class="n">tf</span><span class="o">-&gt;</span><span class="n">command</span> <span class="o">=</span> <span class="n">bfin_check_status</span><span class="p">(</span><span class="n">ap</span><span class="p">);</span>
	<span class="n">tf</span><span class="o">-&gt;</span><span class="n">feature</span> <span class="o">=</span> <span class="n">read_atapi_register</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">ATA_REG_ERR</span><span class="p">);</span>
	<span class="n">tf</span><span class="o">-&gt;</span><span class="n">nsect</span> <span class="o">=</span> <span class="n">read_atapi_register</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">ATA_REG_NSECT</span><span class="p">);</span>
	<span class="n">tf</span><span class="o">-&gt;</span><span class="n">lbal</span> <span class="o">=</span> <span class="n">read_atapi_register</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">ATA_REG_LBAL</span><span class="p">);</span>
	<span class="n">tf</span><span class="o">-&gt;</span><span class="n">lbam</span> <span class="o">=</span> <span class="n">read_atapi_register</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">ATA_REG_LBAM</span><span class="p">);</span>
	<span class="n">tf</span><span class="o">-&gt;</span><span class="n">lbah</span> <span class="o">=</span> <span class="n">read_atapi_register</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">ATA_REG_LBAH</span><span class="p">);</span>
	<span class="n">tf</span><span class="o">-&gt;</span><span class="n">device</span> <span class="o">=</span> <span class="n">read_atapi_register</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">ATA_REG_DEVICE</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">tf</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">ATA_TFLAG_LBA48</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">write_atapi_register</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">ATA_REG_CTRL</span><span class="p">,</span> <span class="n">tf</span><span class="o">-&gt;</span><span class="n">ctl</span> <span class="o">|</span> <span class="n">ATA_HOB</span><span class="p">);</span>
		<span class="n">tf</span><span class="o">-&gt;</span><span class="n">hob_feature</span> <span class="o">=</span> <span class="n">read_atapi_register</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">ATA_REG_ERR</span><span class="p">);</span>
		<span class="n">tf</span><span class="o">-&gt;</span><span class="n">hob_nsect</span> <span class="o">=</span> <span class="n">read_atapi_register</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">ATA_REG_NSECT</span><span class="p">);</span>
		<span class="n">tf</span><span class="o">-&gt;</span><span class="n">hob_lbal</span> <span class="o">=</span> <span class="n">read_atapi_register</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">ATA_REG_LBAL</span><span class="p">);</span>
		<span class="n">tf</span><span class="o">-&gt;</span><span class="n">hob_lbam</span> <span class="o">=</span> <span class="n">read_atapi_register</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">ATA_REG_LBAM</span><span class="p">);</span>
		<span class="n">tf</span><span class="o">-&gt;</span><span class="n">hob_lbah</span> <span class="o">=</span> <span class="n">read_atapi_register</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">ATA_REG_LBAH</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	bfin_exec_command - issue ATA command to host controller</span>
<span class="cm"> *	@ap: port to which command is being issued</span>
<span class="cm"> *	@tf: ATA taskfile register set</span>
<span class="cm"> *</span>
<span class="cm"> *	Note: Original code is ata_sff_exec_command().</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">bfin_exec_command</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span><span class="p">,</span>
			      <span class="k">const</span> <span class="k">struct</span> <span class="n">ata_taskfile</span> <span class="o">*</span><span class="n">tf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">base</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="p">)</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">ioaddr</span><span class="p">.</span><span class="n">ctl_addr</span><span class="p">;</span>
	<span class="n">dev_dbg</span><span class="p">(</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;ata%u: cmd 0x%X</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ap</span><span class="o">-&gt;</span><span class="n">print_id</span><span class="p">,</span> <span class="n">tf</span><span class="o">-&gt;</span><span class="n">command</span><span class="p">);</span>

	<span class="n">write_atapi_register</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">ATA_REG_CMD</span><span class="p">,</span> <span class="n">tf</span><span class="o">-&gt;</span><span class="n">command</span><span class="p">);</span>
	<span class="n">ata_sff_pause</span><span class="p">(</span><span class="n">ap</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	bfin_check_altstatus - Read device alternate status reg</span>
<span class="cm"> *	@ap: port where the device is</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="n">u8</span> <span class="nf">bfin_check_altstatus</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">base</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="p">)</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">ioaddr</span><span class="p">.</span><span class="n">ctl_addr</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">read_atapi_register</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">ATA_REG_ALTSTATUS</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	bfin_dev_select - Select device 0/1 on ATA bus</span>
<span class="cm"> *	@ap: ATA channel to manipulate</span>
<span class="cm"> *	@device: ATA device (numbered from zero) to select</span>
<span class="cm"> *</span>
<span class="cm"> *	Note: Original code is ata_sff_dev_select().</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">bfin_dev_select</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">device</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">base</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="p">)</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">ioaddr</span><span class="p">.</span><span class="n">ctl_addr</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">tmp</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">device</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">tmp</span> <span class="o">=</span> <span class="n">ATA_DEVICE_OBS</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">tmp</span> <span class="o">=</span> <span class="n">ATA_DEVICE_OBS</span> <span class="o">|</span> <span class="n">ATA_DEV1</span><span class="p">;</span>

	<span class="n">write_atapi_register</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">ATA_REG_DEVICE</span><span class="p">,</span> <span class="n">tmp</span><span class="p">);</span>
	<span class="n">ata_sff_pause</span><span class="p">(</span><span class="n">ap</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	bfin_set_devctl - Write device control reg</span>
<span class="cm"> *	@ap: port where the device is</span>
<span class="cm"> *	@ctl: value to write</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">bfin_set_devctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span><span class="p">,</span> <span class="n">u8</span> <span class="n">ctl</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">base</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="p">)</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">ioaddr</span><span class="p">.</span><span class="n">ctl_addr</span><span class="p">;</span>
	<span class="n">write_atapi_register</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">ATA_REG_CTRL</span><span class="p">,</span> <span class="n">ctl</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	bfin_bmdma_setup - Set up IDE DMA transaction</span>
<span class="cm"> *	@qc: Info associated with this ATA transaction.</span>
<span class="cm"> *</span>
<span class="cm"> *	Note: Original code is ata_bmdma_setup().</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">bfin_bmdma_setup</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_queued_cmd</span> <span class="o">*</span><span class="n">qc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span> <span class="o">=</span> <span class="n">qc</span><span class="o">-&gt;</span><span class="n">ap</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dma_desc_array</span> <span class="o">*</span><span class="n">dma_desc_cpu</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">dma_desc_array</span> <span class="o">*</span><span class="p">)</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">bmdma_prd</span><span class="p">;</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">base</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="p">)</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">ioaddr</span><span class="p">.</span><span class="n">ctl_addr</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">config</span> <span class="o">=</span> <span class="n">DMAFLOW_ARRAY</span> <span class="o">|</span> <span class="n">NDSIZE_5</span> <span class="o">|</span> <span class="n">RESTART</span> <span class="o">|</span> <span class="n">WDSIZE_16</span> <span class="o">|</span> <span class="n">DMAEN</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">scatterlist</span> <span class="o">*</span><span class="n">sg</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">si</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">channel</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">dir</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">dev_dbg</span><span class="p">(</span><span class="n">qc</span><span class="o">-&gt;</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;in atapi dma setup</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="cm">/* Program the ATA_CTRL register with dir */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">qc</span><span class="o">-&gt;</span><span class="n">tf</span><span class="p">.</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">ATA_TFLAG_WRITE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">channel</span> <span class="o">=</span> <span class="n">CH_ATAPI_TX</span><span class="p">;</span>
		<span class="n">dir</span> <span class="o">=</span> <span class="n">DMA_TO_DEVICE</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">channel</span> <span class="o">=</span> <span class="n">CH_ATAPI_RX</span><span class="p">;</span>
		<span class="n">dir</span> <span class="o">=</span> <span class="n">DMA_FROM_DEVICE</span><span class="p">;</span>
		<span class="n">config</span> <span class="o">|=</span> <span class="n">WNR</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">dma_map_sg</span><span class="p">(</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">qc</span><span class="o">-&gt;</span><span class="n">sg</span><span class="p">,</span> <span class="n">qc</span><span class="o">-&gt;</span><span class="n">n_elem</span><span class="p">,</span> <span class="n">dir</span><span class="p">);</span>

	<span class="cm">/* fill the ATAPI DMA controller */</span>
	<span class="n">for_each_sg</span><span class="p">(</span><span class="n">qc</span><span class="o">-&gt;</span><span class="n">sg</span><span class="p">,</span> <span class="n">sg</span><span class="p">,</span> <span class="n">qc</span><span class="o">-&gt;</span><span class="n">n_elem</span><span class="p">,</span> <span class="n">si</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dma_desc_cpu</span><span class="p">[</span><span class="n">si</span><span class="p">].</span><span class="n">start_addr</span> <span class="o">=</span> <span class="n">sg_dma_address</span><span class="p">(</span><span class="n">sg</span><span class="p">);</span>
		<span class="n">dma_desc_cpu</span><span class="p">[</span><span class="n">si</span><span class="p">].</span><span class="n">cfg</span> <span class="o">=</span> <span class="n">config</span><span class="p">;</span>
		<span class="n">dma_desc_cpu</span><span class="p">[</span><span class="n">si</span><span class="p">].</span><span class="n">x_count</span> <span class="o">=</span> <span class="n">sg_dma_len</span><span class="p">(</span><span class="n">sg</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">dma_desc_cpu</span><span class="p">[</span><span class="n">si</span><span class="p">].</span><span class="n">x_modify</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
		<span class="n">size</span> <span class="o">+=</span> <span class="n">sg_dma_len</span><span class="p">(</span><span class="n">sg</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Set the last descriptor to stop mode */</span>
	<span class="n">dma_desc_cpu</span><span class="p">[</span><span class="n">qc</span><span class="o">-&gt;</span><span class="n">n_elem</span> <span class="o">-</span> <span class="mi">1</span><span class="p">].</span><span class="n">cfg</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">DMAFLOW</span> <span class="o">|</span> <span class="n">NDSIZE</span><span class="p">);</span>

	<span class="n">flush_dcache_range</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)</span><span class="n">dma_desc_cpu</span><span class="p">,</span>
		<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)</span><span class="n">dma_desc_cpu</span> <span class="o">+</span>
			<span class="n">qc</span><span class="o">-&gt;</span><span class="n">n_elem</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">dma_desc_array</span><span class="p">));</span>

	<span class="cm">/* Enable ATA DMA operation*/</span>
	<span class="n">set_dma_curr_desc_addr</span><span class="p">(</span><span class="n">channel</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="p">)</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">bmdma_prd_dma</span><span class="p">);</span>
	<span class="n">set_dma_x_count</span><span class="p">(</span><span class="n">channel</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">set_dma_x_modify</span><span class="p">(</span><span class="n">channel</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">set_dma_config</span><span class="p">(</span><span class="n">channel</span><span class="p">,</span> <span class="n">config</span><span class="p">);</span>

	<span class="n">SSYNC</span><span class="p">();</span>

	<span class="cm">/* Send ATA DMA command */</span>
	<span class="n">bfin_exec_command</span><span class="p">(</span><span class="n">ap</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">qc</span><span class="o">-&gt;</span><span class="n">tf</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">qc</span><span class="o">-&gt;</span><span class="n">tf</span><span class="p">.</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">ATA_TFLAG_WRITE</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* set ATA DMA write direction */</span>
		<span class="n">ATAPI_SET_CONTROL</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="p">(</span><span class="n">ATAPI_GET_CONTROL</span><span class="p">(</span><span class="n">base</span><span class="p">)</span>
			<span class="o">|</span> <span class="n">XFER_DIR</span><span class="p">));</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* set ATA DMA read direction */</span>
		<span class="n">ATAPI_SET_CONTROL</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="p">(</span><span class="n">ATAPI_GET_CONTROL</span><span class="p">(</span><span class="n">base</span><span class="p">)</span>
			<span class="o">&amp;</span> <span class="o">~</span><span class="n">XFER_DIR</span><span class="p">));</span>
	<span class="p">}</span>

	<span class="cm">/* Reset all transfer count */</span>
	<span class="n">ATAPI_SET_CONTROL</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">ATAPI_GET_CONTROL</span><span class="p">(</span><span class="n">base</span><span class="p">)</span> <span class="o">|</span> <span class="n">TFRCNT_RST</span><span class="p">);</span>

	<span class="cm">/* Set ATAPI state machine contorl in terminate sequence */</span>
	<span class="n">ATAPI_SET_CONTROL</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">ATAPI_GET_CONTROL</span><span class="p">(</span><span class="n">base</span><span class="p">)</span> <span class="o">|</span> <span class="n">END_ON_TERM</span><span class="p">);</span>

	<span class="cm">/* Set transfer length to the total size of sg buffers */</span>
	<span class="n">ATAPI_SET_XFER_LEN</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">size</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	bfin_bmdma_start - Start an IDE DMA transaction</span>
<span class="cm"> *	@qc: Info associated with this ATA transaction.</span>
<span class="cm"> *</span>
<span class="cm"> *	Note: Original code is ata_bmdma_start().</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">bfin_bmdma_start</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_queued_cmd</span> <span class="o">*</span><span class="n">qc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span> <span class="o">=</span> <span class="n">qc</span><span class="o">-&gt;</span><span class="n">ap</span><span class="p">;</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">base</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="p">)</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">ioaddr</span><span class="p">.</span><span class="n">ctl_addr</span><span class="p">;</span>

	<span class="n">dev_dbg</span><span class="p">(</span><span class="n">qc</span><span class="o">-&gt;</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;in atapi dma start</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">udma_mask</span> <span class="o">||</span> <span class="n">ap</span><span class="o">-&gt;</span><span class="n">mwdma_mask</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/* start ATAPI transfer*/</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">udma_mask</span><span class="p">)</span>
		<span class="n">ATAPI_SET_CONTROL</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">ATAPI_GET_CONTROL</span><span class="p">(</span><span class="n">base</span><span class="p">)</span>
			<span class="o">|</span> <span class="n">ULTRA_START</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">ATAPI_SET_CONTROL</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">ATAPI_GET_CONTROL</span><span class="p">(</span><span class="n">base</span><span class="p">)</span>
			<span class="o">|</span> <span class="n">MULTI_START</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	bfin_bmdma_stop - Stop IDE DMA transfer</span>
<span class="cm"> *	@qc: Command we are ending DMA for</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">bfin_bmdma_stop</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_queued_cmd</span> <span class="o">*</span><span class="n">qc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span> <span class="o">=</span> <span class="n">qc</span><span class="o">-&gt;</span><span class="n">ap</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">dir</span><span class="p">;</span>

	<span class="n">dev_dbg</span><span class="p">(</span><span class="n">qc</span><span class="o">-&gt;</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;in atapi dma stop</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">udma_mask</span> <span class="o">||</span> <span class="n">ap</span><span class="o">-&gt;</span><span class="n">mwdma_mask</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/* stop ATAPI DMA controller*/</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">qc</span><span class="o">-&gt;</span><span class="n">tf</span><span class="p">.</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">ATA_TFLAG_WRITE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dir</span> <span class="o">=</span> <span class="n">DMA_TO_DEVICE</span><span class="p">;</span>
		<span class="n">disable_dma</span><span class="p">(</span><span class="n">CH_ATAPI_TX</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">dir</span> <span class="o">=</span> <span class="n">DMA_FROM_DEVICE</span><span class="p">;</span>
		<span class="n">disable_dma</span><span class="p">(</span><span class="n">CH_ATAPI_RX</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">dma_unmap_sg</span><span class="p">(</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">qc</span><span class="o">-&gt;</span><span class="n">sg</span><span class="p">,</span> <span class="n">qc</span><span class="o">-&gt;</span><span class="n">n_elem</span><span class="p">,</span> <span class="n">dir</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	bfin_devchk - PATA device presence detection</span>
<span class="cm"> *	@ap: ATA channel to examine</span>
<span class="cm"> *	@device: Device to examine (starting at zero)</span>
<span class="cm"> *</span>
<span class="cm"> *	Note: Original code is ata_devchk().</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">bfin_devchk</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span><span class="p">,</span>
				<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">device</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">base</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="p">)</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">ioaddr</span><span class="p">.</span><span class="n">ctl_addr</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">nsect</span><span class="p">,</span> <span class="n">lbal</span><span class="p">;</span>

	<span class="n">bfin_dev_select</span><span class="p">(</span><span class="n">ap</span><span class="p">,</span> <span class="n">device</span><span class="p">);</span>

	<span class="n">write_atapi_register</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">ATA_REG_NSECT</span><span class="p">,</span> <span class="mh">0x55</span><span class="p">);</span>
	<span class="n">write_atapi_register</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">ATA_REG_LBAL</span><span class="p">,</span> <span class="mh">0xaa</span><span class="p">);</span>

	<span class="n">write_atapi_register</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">ATA_REG_NSECT</span><span class="p">,</span> <span class="mh">0xaa</span><span class="p">);</span>
	<span class="n">write_atapi_register</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">ATA_REG_LBAL</span><span class="p">,</span> <span class="mh">0x55</span><span class="p">);</span>

	<span class="n">write_atapi_register</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">ATA_REG_NSECT</span><span class="p">,</span> <span class="mh">0x55</span><span class="p">);</span>
	<span class="n">write_atapi_register</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">ATA_REG_LBAL</span><span class="p">,</span> <span class="mh">0xaa</span><span class="p">);</span>

	<span class="n">nsect</span> <span class="o">=</span> <span class="n">read_atapi_register</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">ATA_REG_NSECT</span><span class="p">);</span>
	<span class="n">lbal</span> <span class="o">=</span> <span class="n">read_atapi_register</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">ATA_REG_LBAL</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">nsect</span> <span class="o">==</span> <span class="mh">0x55</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">lbal</span> <span class="o">==</span> <span class="mh">0xaa</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>	<span class="cm">/* we found a device */</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>		<span class="cm">/* nothing found */</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	bfin_bus_post_reset - PATA device post reset</span>
<span class="cm"> *</span>
<span class="cm"> *	Note: Original code is ata_bus_post_reset().</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">bfin_bus_post_reset</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">devmask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">base</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="p">)</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">ioaddr</span><span class="p">.</span><span class="n">ctl_addr</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">dev0</span> <span class="o">=</span> <span class="n">devmask</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">0</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">dev1</span> <span class="o">=</span> <span class="n">devmask</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">deadline</span><span class="p">;</span>

	<span class="cm">/* if device 0 was found in ata_devchk, wait for its</span>
<span class="cm">	 * BSY bit to clear</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dev0</span><span class="p">)</span>
		<span class="n">ata_sff_busy_sleep</span><span class="p">(</span><span class="n">ap</span><span class="p">,</span> <span class="n">ATA_TMOUT_BOOT_QUICK</span><span class="p">,</span> <span class="n">ATA_TMOUT_BOOT</span><span class="p">);</span>

	<span class="cm">/* if device 1 was found in ata_devchk, wait for</span>
<span class="cm">	 * register access, then wait for BSY to clear</span>
<span class="cm">	 */</span>
	<span class="n">deadline</span> <span class="o">=</span> <span class="n">ata_deadline</span><span class="p">(</span><span class="n">jiffies</span><span class="p">,</span> <span class="n">ATA_TMOUT_BOOT</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">dev1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">u8</span> <span class="n">nsect</span><span class="p">,</span> <span class="n">lbal</span><span class="p">;</span>

		<span class="n">bfin_dev_select</span><span class="p">(</span><span class="n">ap</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">nsect</span> <span class="o">=</span> <span class="n">read_atapi_register</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">ATA_REG_NSECT</span><span class="p">);</span>
		<span class="n">lbal</span> <span class="o">=</span> <span class="n">read_atapi_register</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">ATA_REG_LBAL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">nsect</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">lbal</span> <span class="o">==</span> <span class="mi">1</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">time_after</span><span class="p">(</span><span class="n">jiffies</span><span class="p">,</span> <span class="n">deadline</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">dev1</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">ata_msleep</span><span class="p">(</span><span class="n">ap</span><span class="p">,</span> <span class="mi">50</span><span class="p">);</span>	<span class="cm">/* give drive a breather */</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dev1</span><span class="p">)</span>
		<span class="n">ata_sff_busy_sleep</span><span class="p">(</span><span class="n">ap</span><span class="p">,</span> <span class="n">ATA_TMOUT_BOOT_QUICK</span><span class="p">,</span> <span class="n">ATA_TMOUT_BOOT</span><span class="p">);</span>

	<span class="cm">/* is all this really necessary? */</span>
	<span class="n">bfin_dev_select</span><span class="p">(</span><span class="n">ap</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dev1</span><span class="p">)</span>
		<span class="n">bfin_dev_select</span><span class="p">(</span><span class="n">ap</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dev0</span><span class="p">)</span>
		<span class="n">bfin_dev_select</span><span class="p">(</span><span class="n">ap</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	bfin_bus_softreset - PATA device software reset</span>
<span class="cm"> *</span>
<span class="cm"> *	Note: Original code is ata_bus_softreset().</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">bfin_bus_softreset</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span><span class="p">,</span>
				       <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">devmask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">base</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="p">)</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">ioaddr</span><span class="p">.</span><span class="n">ctl_addr</span><span class="p">;</span>

	<span class="cm">/* software reset.  causes dev0 to be selected */</span>
	<span class="n">write_atapi_register</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">ATA_REG_CTRL</span><span class="p">,</span> <span class="n">ap</span><span class="o">-&gt;</span><span class="n">ctl</span><span class="p">);</span>
	<span class="n">udelay</span><span class="p">(</span><span class="mi">20</span><span class="p">);</span>
	<span class="n">write_atapi_register</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">ATA_REG_CTRL</span><span class="p">,</span> <span class="n">ap</span><span class="o">-&gt;</span><span class="n">ctl</span> <span class="o">|</span> <span class="n">ATA_SRST</span><span class="p">);</span>
	<span class="n">udelay</span><span class="p">(</span><span class="mi">20</span><span class="p">);</span>
	<span class="n">write_atapi_register</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">ATA_REG_CTRL</span><span class="p">,</span> <span class="n">ap</span><span class="o">-&gt;</span><span class="n">ctl</span><span class="p">);</span>

	<span class="cm">/* spec mandates &quot;&gt;= 2ms&quot; before checking status.</span>
<span class="cm">	 * We wait 150ms, because that was the magic delay used for</span>
<span class="cm">	 * ATAPI devices in Hale Landis&#39;s ATADRVR, for the period of time</span>
<span class="cm">	 * between when the ATA command register is written, and then</span>
<span class="cm">	 * status is checked.  Because waiting for &quot;a while&quot; before</span>
<span class="cm">	 * checking status is fine, post SRST, we perform this magic</span>
<span class="cm">	 * delay here as well.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Old drivers/ide uses the 2mS rule and then waits for ready</span>
<span class="cm">	 */</span>
	<span class="n">ata_msleep</span><span class="p">(</span><span class="n">ap</span><span class="p">,</span> <span class="mi">150</span><span class="p">);</span>

	<span class="cm">/* Before we perform post reset processing we want to see if</span>
<span class="cm">	 * the bus shows 0xFF because the odd clown forgets the D7</span>
<span class="cm">	 * pulldown resistor.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bfin_check_status</span><span class="p">(</span><span class="n">ap</span><span class="p">)</span> <span class="o">==</span> <span class="mh">0xFF</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">bfin_bus_post_reset</span><span class="p">(</span><span class="n">ap</span><span class="p">,</span> <span class="n">devmask</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	bfin_softreset - reset host port via ATA SRST</span>
<span class="cm"> *	@ap: port to reset</span>
<span class="cm"> *	@classes: resulting classes of attached devices</span>
<span class="cm"> *</span>
<span class="cm"> *	Note: Original code is ata_sff_softreset().</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">bfin_softreset</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_link</span> <span class="o">*</span><span class="n">link</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">classes</span><span class="p">,</span>
			  <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">deadline</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span> <span class="o">=</span> <span class="n">link</span><span class="o">-&gt;</span><span class="n">ap</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">slave_possible</span> <span class="o">=</span> <span class="n">ap</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">ATA_FLAG_SLAVE_POSS</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">devmask</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">err_mask</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">err</span><span class="p">;</span>

	<span class="cm">/* determine if device 0/1 are present */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bfin_devchk</span><span class="p">(</span><span class="n">ap</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
		<span class="n">devmask</span> <span class="o">|=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">slave_possible</span> <span class="o">&amp;&amp;</span> <span class="n">bfin_devchk</span><span class="p">(</span><span class="n">ap</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
		<span class="n">devmask</span> <span class="o">|=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">);</span>

	<span class="cm">/* select device 0 again */</span>
	<span class="n">bfin_dev_select</span><span class="p">(</span><span class="n">ap</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="cm">/* issue bus reset */</span>
	<span class="n">err_mask</span> <span class="o">=</span> <span class="n">bfin_bus_softreset</span><span class="p">(</span><span class="n">ap</span><span class="p">,</span> <span class="n">devmask</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err_mask</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ata_port_err</span><span class="p">(</span><span class="n">ap</span><span class="p">,</span> <span class="s">&quot;SRST failed (err_mask=0x%x)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">err_mask</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* determine by signature whether we have ATA or ATAPI devices */</span>
	<span class="n">classes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">ata_sff_dev_classify</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">link</span><span class="p">.</span><span class="n">device</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
				<span class="n">devmask</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">0</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">err</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">slave_possible</span> <span class="o">&amp;&amp;</span> <span class="n">err</span> <span class="o">!=</span> <span class="mh">0x81</span><span class="p">)</span>
		<span class="n">classes</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">ata_sff_dev_classify</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">link</span><span class="p">.</span><span class="n">device</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
					<span class="n">devmask</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">err</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	bfin_bmdma_status - Read IDE DMA status</span>
<span class="cm"> *	@ap: Port associated with this ATA transaction.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="nf">bfin_bmdma_status</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">host_stat</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">base</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="p">)</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">ioaddr</span><span class="p">.</span><span class="n">ctl_addr</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ATAPI_GET_STATUS</span><span class="p">(</span><span class="n">base</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">MULTI_XFER_ON</span> <span class="o">|</span> <span class="n">ULTRA_XFER_ON</span><span class="p">))</span>
		<span class="n">host_stat</span> <span class="o">|=</span> <span class="n">ATA_DMA_ACTIVE</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ATAPI_GET_INT_STATUS</span><span class="p">(</span><span class="n">base</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">ATAPI_DEV_INT</span><span class="p">)</span>
		<span class="n">host_stat</span> <span class="o">|=</span> <span class="n">ATA_DMA_INTR</span><span class="p">;</span>

	<span class="n">dev_dbg</span><span class="p">(</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;ATAPI: host_stat=0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">host_stat</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">host_stat</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	bfin_data_xfer - Transfer data by PIO</span>
<span class="cm"> *	@adev: device for this I/O</span>
<span class="cm"> *	@buf: data buffer</span>
<span class="cm"> *	@buflen: buffer length</span>
<span class="cm"> *	@write_data: read/write</span>
<span class="cm"> *</span>
<span class="cm"> *	Note: Original code is ata_sff_data_xfer().</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">bfin_data_xfer</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span>
				   <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">buflen</span><span class="p">,</span> <span class="kt">int</span> <span class="n">rw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">link</span><span class="o">-&gt;</span><span class="n">ap</span><span class="p">;</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">base</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="p">)</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">ioaddr</span><span class="p">.</span><span class="n">ctl_addr</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">words</span> <span class="o">=</span> <span class="n">buflen</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="o">*</span><span class="n">buf16</span> <span class="o">=</span> <span class="p">(</span><span class="n">u16</span> <span class="o">*</span><span class="p">)</span><span class="n">buf</span><span class="p">;</span>

	<span class="cm">/* Transfer multiple of 2 bytes */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rw</span> <span class="o">==</span> <span class="n">READ</span><span class="p">)</span>
		<span class="n">read_atapi_data</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">words</span><span class="p">,</span> <span class="n">buf16</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">write_atapi_data</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">words</span><span class="p">,</span> <span class="n">buf16</span><span class="p">);</span>

	<span class="cm">/* Transfer trailing 1 byte, if any. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">buflen</span> <span class="o">&amp;</span> <span class="mh">0x01</span><span class="p">))</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">align_buf</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">0</span> <span class="p">};</span>
		<span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">trailing_buf</span> <span class="o">=</span> <span class="n">buf</span> <span class="o">+</span> <span class="n">buflen</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">rw</span> <span class="o">==</span> <span class="n">READ</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">read_atapi_data</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">align_buf</span><span class="p">);</span>
			<span class="n">memcpy</span><span class="p">(</span><span class="n">trailing_buf</span><span class="p">,</span> <span class="n">align_buf</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">memcpy</span><span class="p">(</span><span class="n">align_buf</span><span class="p">,</span> <span class="n">trailing_buf</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
			<span class="n">write_atapi_data</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">align_buf</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">words</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">words</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	bfin_irq_clear - Clear ATAPI interrupt.</span>
<span class="cm"> *	@ap: Port associated with this ATA transaction.</span>
<span class="cm"> *</span>
<span class="cm"> *	Note: Original code is ata_bmdma_irq_clear().</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">bfin_irq_clear</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">base</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="p">)</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">ioaddr</span><span class="p">.</span><span class="n">ctl_addr</span><span class="p">;</span>

	<span class="n">dev_dbg</span><span class="p">(</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;in atapi irq clear</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">ATAPI_SET_INT_STATUS</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">ATAPI_GET_INT_STATUS</span><span class="p">(</span><span class="n">base</span><span class="p">)</span><span class="o">|</span><span class="n">ATAPI_DEV_INT</span>
		<span class="o">|</span> <span class="n">MULTI_DONE_INT</span> <span class="o">|</span> <span class="n">UDMAIN_DONE_INT</span> <span class="o">|</span> <span class="n">UDMAOUT_DONE_INT</span>
		<span class="o">|</span> <span class="n">MULTI_TERM_INT</span> <span class="o">|</span> <span class="n">UDMAIN_TERM_INT</span> <span class="o">|</span> <span class="n">UDMAOUT_TERM_INT</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	bfin_thaw - Thaw DMA controller port</span>
<span class="cm"> *	@ap: port to thaw</span>
<span class="cm"> *</span>
<span class="cm"> *	Note: Original code is ata_sff_thaw().</span>
<span class="cm"> */</span>

<span class="kt">void</span> <span class="nf">bfin_thaw</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">dev_dbg</span><span class="p">(</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;in atapi dma thaw</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">bfin_check_status</span><span class="p">(</span><span class="n">ap</span><span class="p">);</span>
	<span class="n">ata_sff_irq_on</span><span class="p">(</span><span class="n">ap</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	bfin_postreset - standard postreset callback</span>
<span class="cm"> *	@ap: the target ata_port</span>
<span class="cm"> *	@classes: classes of attached devices</span>
<span class="cm"> *</span>
<span class="cm"> *	Note: Original code is ata_sff_postreset().</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">bfin_postreset</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_link</span> <span class="o">*</span><span class="n">link</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">classes</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span> <span class="o">=</span> <span class="n">link</span><span class="o">-&gt;</span><span class="n">ap</span><span class="p">;</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">base</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="p">)</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">ioaddr</span><span class="p">.</span><span class="n">ctl_addr</span><span class="p">;</span>

	<span class="cm">/* re-enable interrupts */</span>
	<span class="n">ata_sff_irq_on</span><span class="p">(</span><span class="n">ap</span><span class="p">);</span>

	<span class="cm">/* is double-select really necessary? */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">classes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">ATA_DEV_NONE</span><span class="p">)</span>
		<span class="n">bfin_dev_select</span><span class="p">(</span><span class="n">ap</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">classes</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="n">ATA_DEV_NONE</span><span class="p">)</span>
		<span class="n">bfin_dev_select</span><span class="p">(</span><span class="n">ap</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="cm">/* bail out if no device is present */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">classes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">ATA_DEV_NONE</span> <span class="o">&amp;&amp;</span> <span class="n">classes</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">ATA_DEV_NONE</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* set up device control */</span>
	<span class="n">write_atapi_register</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">ATA_REG_CTRL</span><span class="p">,</span> <span class="n">ap</span><span class="o">-&gt;</span><span class="n">ctl</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">bfin_port_stop</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">dev_dbg</span><span class="p">(</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;in atapi port stop</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">udma_mask</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">ap</span><span class="o">-&gt;</span><span class="n">mwdma_mask</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dma_free_coherent</span><span class="p">(</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			<span class="n">BFIN_MAX_SG_SEGMENTS</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">dma_desc_array</span><span class="p">),</span>
			<span class="n">ap</span><span class="o">-&gt;</span><span class="n">bmdma_prd</span><span class="p">,</span>
			<span class="n">ap</span><span class="o">-&gt;</span><span class="n">bmdma_prd_dma</span><span class="p">);</span>

		<span class="n">free_dma</span><span class="p">(</span><span class="n">CH_ATAPI_RX</span><span class="p">);</span>
		<span class="n">free_dma</span><span class="p">(</span><span class="n">CH_ATAPI_TX</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">bfin_port_start</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">dev_dbg</span><span class="p">(</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;in atapi port start</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">udma_mask</span> <span class="o">||</span> <span class="n">ap</span><span class="o">-&gt;</span><span class="n">mwdma_mask</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">ap</span><span class="o">-&gt;</span><span class="n">bmdma_prd</span> <span class="o">=</span> <span class="n">dma_alloc_coherent</span><span class="p">(</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
				<span class="n">BFIN_MAX_SG_SEGMENTS</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">dma_desc_array</span><span class="p">),</span>
				<span class="o">&amp;</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">bmdma_prd_dma</span><span class="p">,</span>
				<span class="n">GFP_KERNEL</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">bmdma_prd</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_info</span><span class="p">(</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Unable to allocate DMA descriptor array.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">request_dma</span><span class="p">(</span><span class="n">CH_ATAPI_RX</span><span class="p">,</span> <span class="s">&quot;BFIN ATAPI RX DMA&quot;</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">request_dma</span><span class="p">(</span><span class="n">CH_ATAPI_TX</span><span class="p">,</span>
			<span class="s">&quot;BFIN ATAPI TX DMA&quot;</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

		<span class="n">free_dma</span><span class="p">(</span><span class="n">CH_ATAPI_RX</span><span class="p">);</span>
		<span class="n">dma_free_coherent</span><span class="p">(</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
			<span class="n">BFIN_MAX_SG_SEGMENTS</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">dma_desc_array</span><span class="p">),</span>
			<span class="n">ap</span><span class="o">-&gt;</span><span class="n">bmdma_prd</span><span class="p">,</span>
			<span class="n">ap</span><span class="o">-&gt;</span><span class="n">bmdma_prd_dma</span><span class="p">);</span>
	<span class="p">}</span>

<span class="nl">out:</span>
	<span class="n">ap</span><span class="o">-&gt;</span><span class="n">udma_mask</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ap</span><span class="o">-&gt;</span><span class="n">mwdma_mask</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">dev_err</span><span class="p">(</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Unable to request ATAPI DMA!&quot;</span>
		<span class="s">&quot; Continue in PIO mode.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">bfin_ata_host_intr</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">ata_queued_cmd</span> <span class="o">*</span><span class="n">qc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ata_eh_info</span> <span class="o">*</span><span class="n">ehi</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">link</span><span class="p">.</span><span class="n">eh_info</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">status</span><span class="p">,</span> <span class="n">host_stat</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">VPRINTK</span><span class="p">(</span><span class="s">&quot;ata%u: protocol %d task_state %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">ap</span><span class="o">-&gt;</span><span class="n">print_id</span><span class="p">,</span> <span class="n">qc</span><span class="o">-&gt;</span><span class="n">tf</span><span class="p">.</span><span class="n">protocol</span><span class="p">,</span> <span class="n">ap</span><span class="o">-&gt;</span><span class="n">hsm_task_state</span><span class="p">);</span>

	<span class="cm">/* Check whether we are expecting interrupt in this state */</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">hsm_task_state</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">HSM_ST_FIRST</span>:
		<span class="cm">/* Some pre-ATAPI-4 devices assert INTRQ</span>
<span class="cm">		 * at this state when ready to receive CDB.</span>
<span class="cm">		 */</span>

		<span class="cm">/* Check the ATA_DFLAG_CDB_INTR flag is enough here.</span>
<span class="cm">		 * The flag was turned on only for atapi devices.</span>
<span class="cm">		 * No need to check is_atapi_taskfile(&amp;qc-&gt;tf) again.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">qc</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">ATA_DFLAG_CDB_INTR</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">idle_irq</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">HSM_ST_LAST</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">qc</span><span class="o">-&gt;</span><span class="n">tf</span><span class="p">.</span><span class="n">protocol</span> <span class="o">==</span> <span class="n">ATA_PROT_DMA</span> <span class="o">||</span>
		    <span class="n">qc</span><span class="o">-&gt;</span><span class="n">tf</span><span class="p">.</span><span class="n">protocol</span> <span class="o">==</span> <span class="n">ATAPI_PROT_DMA</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* check status of DMA engine */</span>
			<span class="n">host_stat</span> <span class="o">=</span> <span class="n">ap</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">bmdma_status</span><span class="p">(</span><span class="n">ap</span><span class="p">);</span>
			<span class="n">VPRINTK</span><span class="p">(</span><span class="s">&quot;ata%u: host_stat 0x%X</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">ap</span><span class="o">-&gt;</span><span class="n">print_id</span><span class="p">,</span> <span class="n">host_stat</span><span class="p">);</span>

			<span class="cm">/* if it&#39;s not our irq... */</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">host_stat</span> <span class="o">&amp;</span> <span class="n">ATA_DMA_INTR</span><span class="p">))</span>
				<span class="k">goto</span> <span class="n">idle_irq</span><span class="p">;</span>

			<span class="cm">/* before we do anything else, clear DMA-Start bit */</span>
			<span class="n">ap</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">bmdma_stop</span><span class="p">(</span><span class="n">qc</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">host_stat</span> <span class="o">&amp;</span> <span class="n">ATA_DMA_ERR</span><span class="p">))</span> <span class="p">{</span>
				<span class="cm">/* error when transferring data to/from memory */</span>
				<span class="n">qc</span><span class="o">-&gt;</span><span class="n">err_mask</span> <span class="o">|=</span> <span class="n">AC_ERR_HOST_BUS</span><span class="p">;</span>
				<span class="n">ap</span><span class="o">-&gt;</span><span class="n">hsm_task_state</span> <span class="o">=</span> <span class="n">HSM_ST_ERR</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">HSM_ST</span>:
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">goto</span> <span class="n">idle_irq</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* check altstatus */</span>
	<span class="n">status</span> <span class="o">=</span> <span class="n">ap</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">sff_check_altstatus</span><span class="p">(</span><span class="n">ap</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">ATA_BUSY</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">busy_ata</span><span class="p">;</span>

	<span class="cm">/* check main status, clearing INTRQ */</span>
	<span class="n">status</span> <span class="o">=</span> <span class="n">ap</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">sff_check_status</span><span class="p">(</span><span class="n">ap</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">ATA_BUSY</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">busy_ata</span><span class="p">;</span>

	<span class="cm">/* ack bmdma irq events */</span>
	<span class="n">ap</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">sff_irq_clear</span><span class="p">(</span><span class="n">ap</span><span class="p">);</span>

	<span class="n">ata_sff_hsm_move</span><span class="p">(</span><span class="n">ap</span><span class="p">,</span> <span class="n">qc</span><span class="p">,</span> <span class="n">status</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">qc</span><span class="o">-&gt;</span><span class="n">err_mask</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">qc</span><span class="o">-&gt;</span><span class="n">tf</span><span class="p">.</span><span class="n">protocol</span> <span class="o">==</span> <span class="n">ATA_PROT_DMA</span> <span class="o">||</span>
				       <span class="n">qc</span><span class="o">-&gt;</span><span class="n">tf</span><span class="p">.</span><span class="n">protocol</span> <span class="o">==</span> <span class="n">ATAPI_PROT_DMA</span><span class="p">))</span>
		<span class="n">ata_ehi_push_desc</span><span class="p">(</span><span class="n">ehi</span><span class="p">,</span> <span class="s">&quot;BMDMA stat 0x%x&quot;</span><span class="p">,</span> <span class="n">host_stat</span><span class="p">);</span>

<span class="nl">busy_ata:</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>	<span class="cm">/* irq handled */</span>

<span class="nl">idle_irq:</span>
	<span class="n">ap</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">idle_irq</span><span class="o">++</span><span class="p">;</span>

<span class="cp">#ifdef ATA_IRQ_TRAP</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">idle_irq</span> <span class="o">%</span> <span class="mi">1000</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ap</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">irq_ack</span><span class="p">(</span><span class="n">ap</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span> <span class="cm">/* debug trap */</span>
		<span class="n">ata_port_warn</span><span class="p">(</span><span class="n">ap</span><span class="p">,</span> <span class="s">&quot;irq trap</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
<span class="cp">#endif</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>	<span class="cm">/* irq not handled */</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">irqreturn_t</span> <span class="nf">bfin_ata_interrupt</span><span class="p">(</span><span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">dev_instance</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ata_host</span> <span class="o">*</span><span class="n">host</span> <span class="o">=</span> <span class="n">dev_instance</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">handled</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="cm">/* TODO: make _irqsave conditional on x86 PCI IDE legacy mode */</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">host</span><span class="o">-&gt;</span><span class="n">n_ports</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span> <span class="o">=</span> <span class="n">host</span><span class="o">-&gt;</span><span class="n">ports</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="k">struct</span> <span class="n">ata_queued_cmd</span> <span class="o">*</span><span class="n">qc</span><span class="p">;</span>

		<span class="n">qc</span> <span class="o">=</span> <span class="n">ata_qc_from_tag</span><span class="p">(</span><span class="n">ap</span><span class="p">,</span> <span class="n">ap</span><span class="o">-&gt;</span><span class="n">link</span><span class="p">.</span><span class="n">active_tag</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">qc</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">qc</span><span class="o">-&gt;</span><span class="n">tf</span><span class="p">.</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">ATA_TFLAG_POLLING</span><span class="p">)))</span>
			<span class="n">handled</span> <span class="o">|=</span> <span class="n">bfin_ata_host_intr</span><span class="p">(</span><span class="n">ap</span><span class="p">,</span> <span class="n">qc</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">IRQ_RETVAL</span><span class="p">(</span><span class="n">handled</span><span class="p">);</span>
<span class="p">}</span>


<span class="k">static</span> <span class="k">struct</span> <span class="n">scsi_host_template</span> <span class="n">bfin_sht</span> <span class="o">=</span> <span class="p">{</span>
	<span class="n">ATA_BASE_SHT</span><span class="p">(</span><span class="n">DRV_NAME</span><span class="p">),</span>
	<span class="p">.</span><span class="n">sg_tablesize</span>		<span class="o">=</span> <span class="n">BFIN_MAX_SG_SEGMENTS</span><span class="p">,</span>
	<span class="p">.</span><span class="n">dma_boundary</span>		<span class="o">=</span> <span class="n">ATA_DMA_BOUNDARY</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">ata_port_operations</span> <span class="n">bfin_pata_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">inherits</span>		<span class="o">=</span> <span class="o">&amp;</span><span class="n">ata_bmdma_port_ops</span><span class="p">,</span>

	<span class="p">.</span><span class="n">set_piomode</span>		<span class="o">=</span> <span class="n">bfin_set_piomode</span><span class="p">,</span>
	<span class="p">.</span><span class="n">set_dmamode</span>		<span class="o">=</span> <span class="n">bfin_set_dmamode</span><span class="p">,</span>

	<span class="p">.</span><span class="n">sff_tf_load</span>		<span class="o">=</span> <span class="n">bfin_tf_load</span><span class="p">,</span>
	<span class="p">.</span><span class="n">sff_tf_read</span>		<span class="o">=</span> <span class="n">bfin_tf_read</span><span class="p">,</span>
	<span class="p">.</span><span class="n">sff_exec_command</span>	<span class="o">=</span> <span class="n">bfin_exec_command</span><span class="p">,</span>
	<span class="p">.</span><span class="n">sff_check_status</span>	<span class="o">=</span> <span class="n">bfin_check_status</span><span class="p">,</span>
	<span class="p">.</span><span class="n">sff_check_altstatus</span>	<span class="o">=</span> <span class="n">bfin_check_altstatus</span><span class="p">,</span>
	<span class="p">.</span><span class="n">sff_dev_select</span>		<span class="o">=</span> <span class="n">bfin_dev_select</span><span class="p">,</span>
	<span class="p">.</span><span class="n">sff_set_devctl</span>		<span class="o">=</span> <span class="n">bfin_set_devctl</span><span class="p">,</span>

	<span class="p">.</span><span class="n">bmdma_setup</span>		<span class="o">=</span> <span class="n">bfin_bmdma_setup</span><span class="p">,</span>
	<span class="p">.</span><span class="n">bmdma_start</span>		<span class="o">=</span> <span class="n">bfin_bmdma_start</span><span class="p">,</span>
	<span class="p">.</span><span class="n">bmdma_stop</span>		<span class="o">=</span> <span class="n">bfin_bmdma_stop</span><span class="p">,</span>
	<span class="p">.</span><span class="n">bmdma_status</span>		<span class="o">=</span> <span class="n">bfin_bmdma_status</span><span class="p">,</span>
	<span class="p">.</span><span class="n">sff_data_xfer</span>		<span class="o">=</span> <span class="n">bfin_data_xfer</span><span class="p">,</span>

	<span class="p">.</span><span class="n">qc_prep</span>		<span class="o">=</span> <span class="n">ata_noop_qc_prep</span><span class="p">,</span>

	<span class="p">.</span><span class="n">thaw</span>			<span class="o">=</span> <span class="n">bfin_thaw</span><span class="p">,</span>
	<span class="p">.</span><span class="n">softreset</span>		<span class="o">=</span> <span class="n">bfin_softreset</span><span class="p">,</span>
	<span class="p">.</span><span class="n">postreset</span>		<span class="o">=</span> <span class="n">bfin_postreset</span><span class="p">,</span>

	<span class="p">.</span><span class="n">sff_irq_clear</span>		<span class="o">=</span> <span class="n">bfin_irq_clear</span><span class="p">,</span>

	<span class="p">.</span><span class="n">port_start</span>		<span class="o">=</span> <span class="n">bfin_port_start</span><span class="p">,</span>
	<span class="p">.</span><span class="n">port_stop</span>		<span class="o">=</span> <span class="n">bfin_port_stop</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">ata_port_info</span> <span class="n">bfin_port_info</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">{</span>
		<span class="p">.</span><span class="n">flags</span>		<span class="o">=</span> <span class="n">ATA_FLAG_SLAVE_POSS</span><span class="p">,</span>
		<span class="p">.</span><span class="n">pio_mask</span>	<span class="o">=</span> <span class="n">ATA_PIO4</span><span class="p">,</span>
		<span class="p">.</span><span class="n">mwdma_mask</span>	<span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
		<span class="p">.</span><span class="n">udma_mask</span>	<span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
		<span class="p">.</span><span class="n">port_ops</span>	<span class="o">=</span> <span class="o">&amp;</span><span class="n">bfin_pata_ops</span><span class="p">,</span>
	<span class="p">},</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> *	bfin_reset_controller - initialize BF54x ATAPI controller.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">bfin_reset_controller</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_host</span> <span class="o">*</span><span class="n">host</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">base</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="p">)</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">ports</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">ioaddr</span><span class="p">.</span><span class="n">ctl_addr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">count</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">status</span><span class="p">;</span>

	<span class="cm">/* Disable all ATAPI interrupts */</span>
	<span class="n">ATAPI_SET_INT_MASK</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">SSYNC</span><span class="p">();</span>

	<span class="cm">/* Assert the RESET signal 25us*/</span>
	<span class="n">ATAPI_SET_CONTROL</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">ATAPI_GET_CONTROL</span><span class="p">(</span><span class="n">base</span><span class="p">)</span> <span class="o">|</span> <span class="n">DEV_RST</span><span class="p">);</span>
	<span class="n">udelay</span><span class="p">(</span><span class="mi">30</span><span class="p">);</span>

	<span class="cm">/* Negate the RESET signal for 2ms*/</span>
	<span class="n">ATAPI_SET_CONTROL</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">ATAPI_GET_CONTROL</span><span class="p">(</span><span class="n">base</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">DEV_RST</span><span class="p">);</span>
	<span class="n">msleep</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>

	<span class="cm">/* Wait on Busy flag to clear */</span>
	<span class="n">count</span> <span class="o">=</span> <span class="mi">10000000</span><span class="p">;</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">read_atapi_register</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">ATA_REG_STATUS</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="o">--</span><span class="n">count</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">ATA_BUSY</span><span class="p">));</span>

	<span class="cm">/* Enable only ATAPI Device interrupt */</span>
	<span class="n">ATAPI_SET_INT_MASK</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">SSYNC</span><span class="p">();</span>

	<span class="k">return</span> <span class="p">(</span><span class="o">!</span><span class="n">count</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	atapi_io_port - define atapi peripheral port pins.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">atapi_io_port</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="n">P_ATAPI_RESET</span><span class="p">,</span>
	<span class="n">P_ATAPI_DIOR</span><span class="p">,</span>
	<span class="n">P_ATAPI_DIOW</span><span class="p">,</span>
	<span class="n">P_ATAPI_CS0</span><span class="p">,</span>
	<span class="n">P_ATAPI_CS1</span><span class="p">,</span>
	<span class="n">P_ATAPI_DMACK</span><span class="p">,</span>
	<span class="n">P_ATAPI_DMARQ</span><span class="p">,</span>
	<span class="n">P_ATAPI_INTRQ</span><span class="p">,</span>
	<span class="n">P_ATAPI_IORDY</span><span class="p">,</span>
	<span class="n">P_ATAPI_D0A</span><span class="p">,</span>
	<span class="n">P_ATAPI_D1A</span><span class="p">,</span>
	<span class="n">P_ATAPI_D2A</span><span class="p">,</span>
	<span class="n">P_ATAPI_D3A</span><span class="p">,</span>
	<span class="n">P_ATAPI_D4A</span><span class="p">,</span>
	<span class="n">P_ATAPI_D5A</span><span class="p">,</span>
	<span class="n">P_ATAPI_D6A</span><span class="p">,</span>
	<span class="n">P_ATAPI_D7A</span><span class="p">,</span>
	<span class="n">P_ATAPI_D8A</span><span class="p">,</span>
	<span class="n">P_ATAPI_D9A</span><span class="p">,</span>
	<span class="n">P_ATAPI_D10A</span><span class="p">,</span>
	<span class="n">P_ATAPI_D11A</span><span class="p">,</span>
	<span class="n">P_ATAPI_D12A</span><span class="p">,</span>
	<span class="n">P_ATAPI_D13A</span><span class="p">,</span>
	<span class="n">P_ATAPI_D14A</span><span class="p">,</span>
	<span class="n">P_ATAPI_D15A</span><span class="p">,</span>
	<span class="n">P_ATAPI_A0A</span><span class="p">,</span>
	<span class="n">P_ATAPI_A1A</span><span class="p">,</span>
	<span class="n">P_ATAPI_A2A</span><span class="p">,</span>
	<span class="mi">0</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> *	bfin_atapi_probe	-	attach a bfin atapi interface</span>
<span class="cm"> *	@pdev: platform device</span>
<span class="cm"> *</span>
<span class="cm"> *	Register a bfin atapi interface.</span>
<span class="cm"> *</span>
<span class="cm"> *</span>
<span class="cm"> *	Platform devices are expected to contain 2 resources per port:</span>
<span class="cm"> *</span>
<span class="cm"> *		- I/O Base (IORESOURCE_IO)</span>
<span class="cm"> *		- IRQ	   (IORESOURCE_IRQ)</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__devinit</span> <span class="nf">bfin_atapi_probe</span><span class="p">(</span><span class="k">struct</span> <span class="n">platform_device</span> <span class="o">*</span><span class="n">pdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">board_idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">resource</span> <span class="o">*</span><span class="n">res</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ata_host</span> <span class="o">*</span><span class="n">host</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">fsclk</span> <span class="o">=</span> <span class="n">get_sclk</span><span class="p">();</span>
	<span class="kt">int</span> <span class="n">udma_mode</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">ata_port_info</span> <span class="o">*</span><span class="n">ppi</span><span class="p">[]</span> <span class="o">=</span>
		<span class="p">{</span> <span class="o">&amp;</span><span class="n">bfin_port_info</span><span class="p">[</span><span class="n">board_idx</span><span class="p">],</span> <span class="nb">NULL</span> <span class="p">};</span>

	<span class="cm">/*</span>
<span class="cm">	 * Simple resource validation ..</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">num_resources</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;invalid number of resources</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Get the register base first</span>
<span class="cm">	 */</span>
	<span class="n">res</span> <span class="o">=</span> <span class="n">platform_get_resource</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">IORESOURCE_MEM</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">res</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">bfin_port_info</span><span class="p">[</span><span class="n">board_idx</span><span class="p">].</span><span class="n">udma_mask</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span>
			<span class="n">udma_fsclk</span><span class="p">[</span><span class="n">udma_mode</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">fsclk</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">udma_mode</span><span class="o">--</span><span class="p">;</span>
		<span class="n">bfin_port_info</span><span class="p">[</span><span class="n">board_idx</span><span class="p">].</span><span class="n">udma_mask</span> <span class="o">&gt;&gt;=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Now that that&#39;s out of the way, wire up the port..</span>
<span class="cm">	 */</span>
	<span class="n">host</span> <span class="o">=</span> <span class="n">ata_host_alloc_pinfo</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">ppi</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">host</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">host</span><span class="o">-&gt;</span><span class="n">ports</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">ioaddr</span><span class="p">.</span><span class="n">ctl_addr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">peripheral_request_list</span><span class="p">(</span><span class="n">atapi_io_port</span><span class="p">,</span> <span class="s">&quot;atapi-io-port&quot;</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Requesting Peripherals failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">bfin_reset_controller</span><span class="p">(</span><span class="n">host</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">peripheral_free_list</span><span class="p">(</span><span class="n">atapi_io_port</span><span class="p">);</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Fail to reset ATAPI device</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ata_host_activate</span><span class="p">(</span><span class="n">host</span><span class="p">,</span> <span class="n">platform_get_irq</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
		<span class="n">bfin_ata_interrupt</span><span class="p">,</span> <span class="n">IRQF_SHARED</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bfin_sht</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">peripheral_free_list</span><span class="p">(</span><span class="n">atapi_io_port</span><span class="p">);</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Fail to attach ATAPI device</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">dev_set_drvdata</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">host</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	bfin_atapi_remove	-	unplug a bfin atapi interface</span>
<span class="cm"> *	@pdev: platform device</span>
<span class="cm"> *</span>
<span class="cm"> *	A bfin atapi device has been unplugged. Perform the needed</span>
<span class="cm"> *	cleanup. Also called on module unload for any active devices.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__devexit</span> <span class="nf">bfin_atapi_remove</span><span class="p">(</span><span class="k">struct</span> <span class="n">platform_device</span> <span class="o">*</span><span class="n">pdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ata_host</span> <span class="o">*</span><span class="n">host</span> <span class="o">=</span> <span class="n">dev_get_drvdata</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="n">ata_host_detach</span><span class="p">(</span><span class="n">host</span><span class="p">);</span>
	<span class="n">dev_set_drvdata</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

	<span class="n">peripheral_free_list</span><span class="p">(</span><span class="n">atapi_io_port</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_PM</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">bfin_atapi_suspend</span><span class="p">(</span><span class="k">struct</span> <span class="n">platform_device</span> <span class="o">*</span><span class="n">pdev</span><span class="p">,</span> <span class="n">pm_message_t</span> <span class="n">state</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ata_host</span> <span class="o">*</span><span class="n">host</span> <span class="o">=</span> <span class="n">dev_get_drvdata</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">host</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ata_host_suspend</span><span class="p">(</span><span class="n">host</span><span class="p">,</span> <span class="n">state</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">bfin_atapi_resume</span><span class="p">(</span><span class="k">struct</span> <span class="n">platform_device</span> <span class="o">*</span><span class="n">pdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ata_host</span> <span class="o">*</span><span class="n">host</span> <span class="o">=</span> <span class="n">dev_get_drvdata</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">host</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">bfin_reset_controller</span><span class="p">(</span><span class="n">host</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="n">DRV_NAME</span> <span class="s">&quot;: Error during HW init</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">ata_host_resume</span><span class="p">(</span><span class="n">host</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#else</span>
<span class="cp">#define bfin_atapi_suspend NULL</span>
<span class="cp">#define bfin_atapi_resume NULL</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">platform_driver</span> <span class="n">bfin_atapi_driver</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">probe</span>			<span class="o">=</span> <span class="n">bfin_atapi_probe</span><span class="p">,</span>
	<span class="p">.</span><span class="n">remove</span>			<span class="o">=</span> <span class="n">__devexit_p</span><span class="p">(</span><span class="n">bfin_atapi_remove</span><span class="p">),</span>
	<span class="p">.</span><span class="n">suspend</span>		<span class="o">=</span> <span class="n">bfin_atapi_suspend</span><span class="p">,</span>
	<span class="p">.</span><span class="n">resume</span>			<span class="o">=</span> <span class="n">bfin_atapi_resume</span><span class="p">,</span>
	<span class="p">.</span><span class="n">driver</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">name</span>		<span class="o">=</span> <span class="n">DRV_NAME</span><span class="p">,</span>
		<span class="p">.</span><span class="n">owner</span>		<span class="o">=</span> <span class="n">THIS_MODULE</span><span class="p">,</span>
	<span class="p">},</span>
<span class="p">};</span>

<span class="cp">#define ATAPI_MODE_SIZE		10</span>
<span class="k">static</span> <span class="kt">char</span> <span class="n">bfin_atapi_mode</span><span class="p">[</span><span class="n">ATAPI_MODE_SIZE</span><span class="p">];</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">bfin_atapi_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;register bfin atapi driver</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="k">switch</span><span class="p">(</span><span class="n">bfin_atapi_mode</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="p">{</span>
	<span class="k">case</span> <span class="sc">&#39;p&#39;</span>:
	<span class="k">case</span> <span class="sc">&#39;P&#39;</span>:
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="sc">&#39;m&#39;</span>:
	<span class="k">case</span> <span class="sc">&#39;M&#39;</span>:
		<span class="n">bfin_port_info</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">mwdma_mask</span> <span class="o">=</span> <span class="n">ATA_MWDMA2</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">bfin_port_info</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">udma_mask</span> <span class="o">=</span> <span class="n">ATA_UDMA5</span><span class="p">;</span>
	<span class="p">};</span>

	<span class="k">return</span> <span class="n">platform_driver_register</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bfin_atapi_driver</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__exit</span> <span class="nf">bfin_atapi_exit</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">platform_driver_unregister</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bfin_atapi_driver</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">module_init</span><span class="p">(</span><span class="n">bfin_atapi_init</span><span class="p">);</span>
<span class="n">module_exit</span><span class="p">(</span><span class="n">bfin_atapi_exit</span><span class="p">);</span>
<span class="cm">/*</span>
<span class="cm"> * ATAPI mode:</span>
<span class="cm"> * pio/PIO</span>
<span class="cm"> * udma/UDMA (default)</span>
<span class="cm"> * mwdma/MWDMA</span>
<span class="cm"> */</span>
<span class="n">module_param_string</span><span class="p">(</span><span class="n">bfin_atapi_mode</span><span class="p">,</span> <span class="n">bfin_atapi_mode</span><span class="p">,</span> <span class="n">ATAPI_MODE_SIZE</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

<span class="n">MODULE_AUTHOR</span><span class="p">(</span><span class="s">&quot;Sonic Zhang &lt;sonic.zhang@analog.com&gt;&quot;</span><span class="p">);</span>
<span class="n">MODULE_DESCRIPTION</span><span class="p">(</span><span class="s">&quot;PATA driver for blackfin 54x ATAPI controller&quot;</span><span class="p">);</span>
<span class="n">MODULE_LICENSE</span><span class="p">(</span><span class="s">&quot;GPL&quot;</span><span class="p">);</span>
<span class="n">MODULE_VERSION</span><span class="p">(</span><span class="n">DRV_VERSION</span><span class="p">);</span>
<span class="n">MODULE_ALIAS</span><span class="p">(</span><span class="s">&quot;platform:&quot;</span> <span class="n">DRV_NAME</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
