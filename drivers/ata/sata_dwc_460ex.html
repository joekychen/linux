<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › ata › sata_dwc_460ex.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>sata_dwc_460ex.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * drivers/ata/sata_dwc_460ex.c</span>
<span class="cm"> *</span>
<span class="cm"> * Synopsys DesignWare Cores (DWC) SATA host driver</span>
<span class="cm"> *</span>
<span class="cm"> * Author: Mark Miesfeld &lt;mmiesfeld@amcc.com&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * Ported from 2.6.19.2 to 2.6.25/26 by Stefan Roese &lt;sr@denx.de&gt;</span>
<span class="cm"> * Copyright 2008 DENX Software Engineering</span>
<span class="cm"> *</span>
<span class="cm"> * Based on versions provided by AMCC and Synopsys which are:</span>
<span class="cm"> *          Copyright 2006 Applied Micro Circuits Corporation</span>
<span class="cm"> *          COPYRIGHT (C) 2005  SYNOPSYS, INC.  ALL RIGHTS RESERVED</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute  it and/or modify it</span>
<span class="cm"> * under  the terms of  the GNU General  Public License as published by the</span>
<span class="cm"> * Free Software Foundation;  either version 2 of the  License, or (at your</span>
<span class="cm"> * option) any later version.</span>
<span class="cm"> */</span>

<span class="cp">#ifdef CONFIG_SATA_DWC_DEBUG</span>
<span class="cp">#define DEBUG</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef CONFIG_SATA_DWC_VDEBUG</span>
<span class="cp">#define VERBOSE_DEBUG</span>
<span class="cp">#define DEBUG_NCQ</span>
<span class="cp">#endif</span>

<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/device.h&gt;</span>
<span class="cp">#include &lt;linux/of_platform.h&gt;</span>
<span class="cp">#include &lt;linux/platform_device.h&gt;</span>
<span class="cp">#include &lt;linux/libata.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &quot;libata.h&quot;</span>

<span class="cp">#include &lt;scsi/scsi_host.h&gt;</span>
<span class="cp">#include &lt;scsi/scsi_cmnd.h&gt;</span>

<span class="cm">/* These two are defined in &quot;libata.h&quot; */</span>
<span class="cp">#undef	DRV_NAME</span>
<span class="cp">#undef	DRV_VERSION</span>
<span class="cp">#define DRV_NAME        &quot;sata-dwc&quot;</span>
<span class="cp">#define DRV_VERSION     &quot;1.3&quot;</span>

<span class="cm">/* SATA DMA driver Globals */</span>
<span class="cp">#define DMA_NUM_CHANS		1</span>
<span class="cp">#define DMA_NUM_CHAN_REGS	8</span>

<span class="cm">/* SATA DMA Register definitions */</span>
<span class="cp">#define AHB_DMA_BRST_DFLT	64	</span><span class="cm">/* 16 data items burst length*/</span><span class="cp"></span>

<span class="k">struct</span> <span class="n">dmareg</span> <span class="p">{</span>
	<span class="n">u32</span> <span class="n">low</span><span class="p">;</span>		<span class="cm">/* Low bits 0-31 */</span>
	<span class="n">u32</span> <span class="n">high</span><span class="p">;</span>		<span class="cm">/* High bits 32-63 */</span>
<span class="p">};</span>

<span class="cm">/* DMA Per Channel registers */</span>
<span class="k">struct</span> <span class="n">dma_chan_regs</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">dmareg</span> <span class="n">sar</span><span class="p">;</span>	<span class="cm">/* Source Address */</span>
	<span class="k">struct</span> <span class="n">dmareg</span> <span class="n">dar</span><span class="p">;</span>	<span class="cm">/* Destination address */</span>
	<span class="k">struct</span> <span class="n">dmareg</span> <span class="n">llp</span><span class="p">;</span>	<span class="cm">/* Linked List Pointer */</span>
	<span class="k">struct</span> <span class="n">dmareg</span> <span class="n">ctl</span><span class="p">;</span>	<span class="cm">/* Control */</span>
	<span class="k">struct</span> <span class="n">dmareg</span> <span class="n">sstat</span><span class="p">;</span>	<span class="cm">/* Source Status not implemented in core */</span>
	<span class="k">struct</span> <span class="n">dmareg</span> <span class="n">dstat</span><span class="p">;</span>	<span class="cm">/* Destination Status not implemented in core*/</span>
	<span class="k">struct</span> <span class="n">dmareg</span> <span class="n">sstatar</span><span class="p">;</span>	<span class="cm">/* Source Status Address not impl in core */</span>
	<span class="k">struct</span> <span class="n">dmareg</span> <span class="n">dstatar</span><span class="p">;</span>	<span class="cm">/* Destination Status Address not implemente */</span>
	<span class="k">struct</span> <span class="n">dmareg</span> <span class="n">cfg</span><span class="p">;</span>	<span class="cm">/* Config */</span>
	<span class="k">struct</span> <span class="n">dmareg</span> <span class="n">sgr</span><span class="p">;</span>	<span class="cm">/* Source Gather */</span>
	<span class="k">struct</span> <span class="n">dmareg</span> <span class="n">dsr</span><span class="p">;</span>	<span class="cm">/* Destination Scatter */</span>
<span class="p">};</span>

<span class="cm">/* Generic Interrupt Registers */</span>
<span class="k">struct</span> <span class="n">dma_interrupt_regs</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">dmareg</span> <span class="n">tfr</span><span class="p">;</span>	<span class="cm">/* Transfer Interrupt */</span>
	<span class="k">struct</span> <span class="n">dmareg</span> <span class="n">block</span><span class="p">;</span>	<span class="cm">/* Block Interrupt */</span>
	<span class="k">struct</span> <span class="n">dmareg</span> <span class="n">srctran</span><span class="p">;</span>	<span class="cm">/* Source Transfer Interrupt */</span>
	<span class="k">struct</span> <span class="n">dmareg</span> <span class="n">dsttran</span><span class="p">;</span>	<span class="cm">/* Dest Transfer Interrupt */</span>
	<span class="k">struct</span> <span class="n">dmareg</span> <span class="n">error</span><span class="p">;</span>	<span class="cm">/* Error */</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">ahb_dma_regs</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">dma_chan_regs</span>	<span class="n">chan_regs</span><span class="p">[</span><span class="n">DMA_NUM_CHAN_REGS</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">dma_interrupt_regs</span> <span class="n">interrupt_raw</span><span class="p">;</span>	<span class="cm">/* Raw Interrupt */</span>
	<span class="k">struct</span> <span class="n">dma_interrupt_regs</span> <span class="n">interrupt_status</span><span class="p">;</span>	<span class="cm">/* Interrupt Status */</span>
	<span class="k">struct</span> <span class="n">dma_interrupt_regs</span> <span class="n">interrupt_mask</span><span class="p">;</span>	<span class="cm">/* Interrupt Mask */</span>
	<span class="k">struct</span> <span class="n">dma_interrupt_regs</span> <span class="n">interrupt_clear</span><span class="p">;</span>	<span class="cm">/* Interrupt Clear */</span>
	<span class="k">struct</span> <span class="n">dmareg</span>		<span class="n">statusInt</span><span class="p">;</span>	<span class="cm">/* Interrupt combined*/</span>
	<span class="k">struct</span> <span class="n">dmareg</span>		<span class="n">rq_srcreg</span><span class="p">;</span>	<span class="cm">/* Src Trans Req */</span>
	<span class="k">struct</span> <span class="n">dmareg</span>		<span class="n">rq_dstreg</span><span class="p">;</span>	<span class="cm">/* Dst Trans Req */</span>
	<span class="k">struct</span> <span class="n">dmareg</span>		<span class="n">rq_sgl_srcreg</span><span class="p">;</span>	<span class="cm">/* Sngl Src Trans Req*/</span>
	<span class="k">struct</span> <span class="n">dmareg</span>		<span class="n">rq_sgl_dstreg</span><span class="p">;</span>	<span class="cm">/* Sngl Dst Trans Req*/</span>
	<span class="k">struct</span> <span class="n">dmareg</span>		<span class="n">rq_lst_srcreg</span><span class="p">;</span>	<span class="cm">/* Last Src Trans Req*/</span>
	<span class="k">struct</span> <span class="n">dmareg</span>		<span class="n">rq_lst_dstreg</span><span class="p">;</span>	<span class="cm">/* Last Dst Trans Req*/</span>
	<span class="k">struct</span> <span class="n">dmareg</span>		<span class="n">dma_cfg</span><span class="p">;</span>		<span class="cm">/* DMA Config */</span>
	<span class="k">struct</span> <span class="n">dmareg</span>		<span class="n">dma_chan_en</span><span class="p">;</span>		<span class="cm">/* DMA Channel Enable*/</span>
	<span class="k">struct</span> <span class="n">dmareg</span>		<span class="n">dma_id</span><span class="p">;</span>			<span class="cm">/* DMA ID */</span>
	<span class="k">struct</span> <span class="n">dmareg</span>		<span class="n">dma_test</span><span class="p">;</span>		<span class="cm">/* DMA Test */</span>
	<span class="k">struct</span> <span class="n">dmareg</span>		<span class="n">res1</span><span class="p">;</span>			<span class="cm">/* reserved */</span>
	<span class="k">struct</span> <span class="n">dmareg</span>		<span class="n">res2</span><span class="p">;</span>			<span class="cm">/* reserved */</span>
	<span class="cm">/*</span>
<span class="cm">	 * DMA Comp Params</span>
<span class="cm">	 * Param 6 = dma_param[0], Param 5 = dma_param[1],</span>
<span class="cm">	 * Param 4 = dma_param[2] ...</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">dmareg</span>		<span class="n">dma_params</span><span class="p">[</span><span class="mi">6</span><span class="p">];</span>
<span class="p">};</span>

<span class="cm">/* Data structure for linked list item */</span>
<span class="k">struct</span> <span class="n">lli</span> <span class="p">{</span>
	<span class="n">u32</span>		<span class="n">sar</span><span class="p">;</span>		<span class="cm">/* Source Address */</span>
	<span class="n">u32</span>		<span class="n">dar</span><span class="p">;</span>		<span class="cm">/* Destination address */</span>
	<span class="n">u32</span>		<span class="n">llp</span><span class="p">;</span>		<span class="cm">/* Linked List Pointer */</span>
	<span class="k">struct</span> <span class="n">dmareg</span>	<span class="n">ctl</span><span class="p">;</span>		<span class="cm">/* Control */</span>
	<span class="k">struct</span> <span class="n">dmareg</span>	<span class="n">dstat</span><span class="p">;</span>		<span class="cm">/* Destination Status */</span>
<span class="p">};</span>

<span class="k">enum</span> <span class="p">{</span>
	<span class="n">SATA_DWC_DMAC_LLI_SZ</span> <span class="o">=</span>	<span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">lli</span><span class="p">)),</span>
	<span class="n">SATA_DWC_DMAC_LLI_NUM</span> <span class="o">=</span>	<span class="mi">256</span><span class="p">,</span>
	<span class="n">SATA_DWC_DMAC_LLI_TBL_SZ</span> <span class="o">=</span> <span class="p">(</span><span class="n">SATA_DWC_DMAC_LLI_SZ</span> <span class="o">*</span> \
					<span class="n">SATA_DWC_DMAC_LLI_NUM</span><span class="p">),</span>
	<span class="n">SATA_DWC_DMAC_TWIDTH_BYTES</span> <span class="o">=</span> <span class="mi">4</span><span class="p">,</span>
	<span class="n">SATA_DWC_DMAC_CTRL_TSIZE_MAX</span> <span class="o">=</span> <span class="p">(</span><span class="mh">0x00000800</span> <span class="o">*</span> \
						<span class="n">SATA_DWC_DMAC_TWIDTH_BYTES</span><span class="p">),</span>
<span class="p">};</span>

<span class="cm">/* DMA Register Operation Bits */</span>
<span class="k">enum</span> <span class="p">{</span>
	<span class="n">DMA_EN</span>	<span class="o">=</span>		<span class="mh">0x00000001</span><span class="p">,</span> <span class="cm">/* Enable AHB DMA */</span>
	<span class="n">DMA_CTL_LLP_SRCEN</span> <span class="o">=</span>	<span class="mh">0x10000000</span><span class="p">,</span> <span class="cm">/* Blk chain enable Src */</span>
	<span class="n">DMA_CTL_LLP_DSTEN</span> <span class="o">=</span>	<span class="mh">0x08000000</span><span class="p">,</span> <span class="cm">/* Blk chain enable Dst */</span>
<span class="p">};</span>

<span class="cp">#define	DMA_CTL_BLK_TS(size)	((size) &amp; 0x000000FFF)	</span><span class="cm">/* Blk Transfer size */</span><span class="cp"></span>
<span class="cp">#define DMA_CHANNEL(ch)		(0x00000001 &lt;&lt; (ch))	</span><span class="cm">/* Select channel */</span><span class="cp"></span>
	<span class="cm">/* Enable channel */</span>
<span class="cp">#define	DMA_ENABLE_CHAN(ch)	((0x00000001 &lt;&lt; (ch)) |			\</span>
<span class="cp">				 ((0x000000001 &lt;&lt; (ch)) &lt;&lt; 8))</span>
	<span class="cm">/* Disable channel */</span>
<span class="cp">#define	DMA_DISABLE_CHAN(ch)	(0x00000000 | ((0x000000001 &lt;&lt; (ch)) &lt;&lt; 8))</span>
	<span class="cm">/* Transfer Type &amp; Flow Controller */</span>
<span class="cp">#define	DMA_CTL_TTFC(type)	(((type) &amp; 0x7) &lt;&lt; 20)</span>
<span class="cp">#define	DMA_CTL_SMS(num)	(((num) &amp; 0x3) &lt;&lt; 25) </span><span class="cm">/* Src Master Select */</span><span class="cp"></span>
<span class="cp">#define	DMA_CTL_DMS(num)	(((num) &amp; 0x3) &lt;&lt; 23)</span><span class="cm">/* Dst Master Select */</span><span class="cp"></span>
	<span class="cm">/* Src Burst Transaction Length */</span>
<span class="cp">#define DMA_CTL_SRC_MSIZE(size) (((size) &amp; 0x7) &lt;&lt; 14)</span>
	<span class="cm">/* Dst Burst Transaction Length */</span>
<span class="cp">#define	DMA_CTL_DST_MSIZE(size) (((size) &amp; 0x7) &lt;&lt; 11)</span>
	<span class="cm">/* Source Transfer Width */</span>
<span class="cp">#define	DMA_CTL_SRC_TRWID(size) (((size) &amp; 0x7) &lt;&lt; 4)</span>
	<span class="cm">/* Destination Transfer Width */</span>
<span class="cp">#define	DMA_CTL_DST_TRWID(size) (((size) &amp; 0x7) &lt;&lt; 1)</span>

<span class="cm">/* Assign HW handshaking interface (x) to destination / source peripheral */</span>
<span class="cp">#define	DMA_CFG_HW_HS_DEST(int_num) (((int_num) &amp; 0xF) &lt;&lt; 11)</span>
<span class="cp">#define	DMA_CFG_HW_HS_SRC(int_num) (((int_num) &amp; 0xF) &lt;&lt; 7)</span>
<span class="cp">#define	DMA_LLP_LMS(addr, master) (((addr) &amp; 0xfffffffc) | (master))</span>

<span class="cm">/*</span>
<span class="cm"> * This define is used to set block chaining disabled in the control low</span>
<span class="cm"> * register.  It is already in little endian format so it can be &amp;&#39;d dirctly.</span>
<span class="cm"> * It is essentially: cpu_to_le32(~(DMA_CTL_LLP_SRCEN | DMA_CTL_LLP_DSTEN))</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="p">{</span>
	<span class="n">DMA_CTL_LLP_DISABLE_LE32</span> <span class="o">=</span> <span class="mh">0xffffffe7</span><span class="p">,</span>
	<span class="n">DMA_CTL_TTFC_P2M_DMAC</span> <span class="o">=</span>	<span class="mh">0x00000002</span><span class="p">,</span> <span class="cm">/* Per to mem, DMAC cntr */</span>
	<span class="n">DMA_CTL_TTFC_M2P_PER</span> <span class="o">=</span>	<span class="mh">0x00000003</span><span class="p">,</span> <span class="cm">/* Mem to per, peripheral cntr */</span>
	<span class="n">DMA_CTL_SINC_INC</span> <span class="o">=</span>	<span class="mh">0x00000000</span><span class="p">,</span> <span class="cm">/* Source Address Increment */</span>
	<span class="n">DMA_CTL_SINC_DEC</span> <span class="o">=</span>	<span class="mh">0x00000200</span><span class="p">,</span>
	<span class="n">DMA_CTL_SINC_NOCHANGE</span> <span class="o">=</span>	<span class="mh">0x00000400</span><span class="p">,</span>
	<span class="n">DMA_CTL_DINC_INC</span> <span class="o">=</span>	<span class="mh">0x00000000</span><span class="p">,</span> <span class="cm">/* Destination Address Increment */</span>
	<span class="n">DMA_CTL_DINC_DEC</span> <span class="o">=</span>	<span class="mh">0x00000080</span><span class="p">,</span>
	<span class="n">DMA_CTL_DINC_NOCHANGE</span> <span class="o">=</span>	<span class="mh">0x00000100</span><span class="p">,</span>
	<span class="n">DMA_CTL_INT_EN</span> <span class="o">=</span>	<span class="mh">0x00000001</span><span class="p">,</span> <span class="cm">/* Interrupt Enable */</span>

<span class="cm">/* Channel Configuration Register high bits */</span>
	<span class="n">DMA_CFG_FCMOD_REQ</span> <span class="o">=</span>	<span class="mh">0x00000001</span><span class="p">,</span> <span class="cm">/* Flow Control - request based */</span>
	<span class="n">DMA_CFG_PROTCTL</span>	<span class="o">=</span>	<span class="p">(</span><span class="mh">0x00000003</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">),</span><span class="cm">/* Protection Control */</span>

<span class="cm">/* Channel Configuration Register low bits */</span>
	<span class="n">DMA_CFG_RELD_DST</span> <span class="o">=</span>	<span class="mh">0x80000000</span><span class="p">,</span> <span class="cm">/* Reload Dest / Src Addr */</span>
	<span class="n">DMA_CFG_RELD_SRC</span> <span class="o">=</span>	<span class="mh">0x40000000</span><span class="p">,</span>
	<span class="n">DMA_CFG_HS_SELSRC</span> <span class="o">=</span>	<span class="mh">0x00000800</span><span class="p">,</span> <span class="cm">/* Software handshake Src/ Dest */</span>
	<span class="n">DMA_CFG_HS_SELDST</span> <span class="o">=</span>	<span class="mh">0x00000400</span><span class="p">,</span>
	<span class="n">DMA_CFG_FIFOEMPTY</span> <span class="o">=</span>     <span class="p">(</span><span class="mh">0x00000001</span> <span class="o">&lt;&lt;</span> <span class="mi">9</span><span class="p">),</span> <span class="cm">/* FIFO Empty bit */</span>

<span class="cm">/* Channel Linked List Pointer Register */</span>
	<span class="n">DMA_LLP_AHBMASTER1</span> <span class="o">=</span>	<span class="mi">0</span><span class="p">,</span>	<span class="cm">/* List Master Select */</span>
	<span class="n">DMA_LLP_AHBMASTER2</span> <span class="o">=</span>	<span class="mi">1</span><span class="p">,</span>

	<span class="n">SATA_DWC_MAX_PORTS</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>

	<span class="n">SATA_DWC_SCR_OFFSET</span> <span class="o">=</span> <span class="mh">0x24</span><span class="p">,</span>
	<span class="n">SATA_DWC_REG_OFFSET</span> <span class="o">=</span> <span class="mh">0x64</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/* DWC SATA Registers */</span>
<span class="k">struct</span> <span class="n">sata_dwc_regs</span> <span class="p">{</span>
	<span class="n">u32</span> <span class="n">fptagr</span><span class="p">;</span>		<span class="cm">/* 1st party DMA tag */</span>
	<span class="n">u32</span> <span class="n">fpbor</span><span class="p">;</span>		<span class="cm">/* 1st party DMA buffer offset */</span>
	<span class="n">u32</span> <span class="n">fptcr</span><span class="p">;</span>		<span class="cm">/* 1st party DMA Xfr count */</span>
	<span class="n">u32</span> <span class="n">dmacr</span><span class="p">;</span>		<span class="cm">/* DMA Control */</span>
	<span class="n">u32</span> <span class="n">dbtsr</span><span class="p">;</span>		<span class="cm">/* DMA Burst Transac size */</span>
	<span class="n">u32</span> <span class="n">intpr</span><span class="p">;</span>		<span class="cm">/* Interrupt Pending */</span>
	<span class="n">u32</span> <span class="n">intmr</span><span class="p">;</span>		<span class="cm">/* Interrupt Mask */</span>
	<span class="n">u32</span> <span class="n">errmr</span><span class="p">;</span>		<span class="cm">/* Error Mask */</span>
	<span class="n">u32</span> <span class="n">llcr</span><span class="p">;</span>		<span class="cm">/* Link Layer Control */</span>
	<span class="n">u32</span> <span class="n">phycr</span><span class="p">;</span>		<span class="cm">/* PHY Control */</span>
	<span class="n">u32</span> <span class="n">physr</span><span class="p">;</span>		<span class="cm">/* PHY Status */</span>
	<span class="n">u32</span> <span class="n">rxbistpd</span><span class="p">;</span>		<span class="cm">/* Recvd BIST pattern def register */</span>
	<span class="n">u32</span> <span class="n">rxbistpd1</span><span class="p">;</span>		<span class="cm">/* Recvd BIST data dword1 */</span>
	<span class="n">u32</span> <span class="n">rxbistpd2</span><span class="p">;</span>		<span class="cm">/* Recvd BIST pattern data dword2 */</span>
	<span class="n">u32</span> <span class="n">txbistpd</span><span class="p">;</span>		<span class="cm">/* Trans BIST pattern def register */</span>
	<span class="n">u32</span> <span class="n">txbistpd1</span><span class="p">;</span>		<span class="cm">/* Trans BIST data dword1 */</span>
	<span class="n">u32</span> <span class="n">txbistpd2</span><span class="p">;</span>		<span class="cm">/* Trans BIST data dword2 */</span>
	<span class="n">u32</span> <span class="n">bistcr</span><span class="p">;</span>		<span class="cm">/* BIST Control Register */</span>
	<span class="n">u32</span> <span class="n">bistfctr</span><span class="p">;</span>		<span class="cm">/* BIST FIS Count Register */</span>
	<span class="n">u32</span> <span class="n">bistsr</span><span class="p">;</span>		<span class="cm">/* BIST Status Register */</span>
	<span class="n">u32</span> <span class="n">bistdecr</span><span class="p">;</span>		<span class="cm">/* BIST Dword Error count register */</span>
	<span class="n">u32</span> <span class="n">res</span><span class="p">[</span><span class="mi">15</span><span class="p">];</span>		<span class="cm">/* Reserved locations */</span>
	<span class="n">u32</span> <span class="n">testr</span><span class="p">;</span>		<span class="cm">/* Test Register */</span>
	<span class="n">u32</span> <span class="n">versionr</span><span class="p">;</span>		<span class="cm">/* Version Register */</span>
	<span class="n">u32</span> <span class="n">idr</span><span class="p">;</span>		<span class="cm">/* ID Register */</span>
	<span class="n">u32</span> <span class="n">unimpl</span><span class="p">[</span><span class="mi">192</span><span class="p">];</span>	<span class="cm">/* Unimplemented */</span>
	<span class="n">u32</span> <span class="n">dmadr</span><span class="p">[</span><span class="mi">256</span><span class="p">];</span>	<span class="cm">/* FIFO Locations in DMA Mode */</span>
<span class="p">};</span>

<span class="k">enum</span> <span class="p">{</span>
	<span class="n">SCR_SCONTROL_DET_ENABLE</span>	<span class="o">=</span>	<span class="mh">0x00000001</span><span class="p">,</span>
	<span class="n">SCR_SSTATUS_DET_PRESENT</span>	<span class="o">=</span>	<span class="mh">0x00000001</span><span class="p">,</span>
	<span class="n">SCR_SERROR_DIAG_X</span>	<span class="o">=</span>	<span class="mh">0x04000000</span><span class="p">,</span>
<span class="cm">/* DWC SATA Register Operations */</span>
	<span class="n">SATA_DWC_TXFIFO_DEPTH</span>	<span class="o">=</span>	<span class="mh">0x01FF</span><span class="p">,</span>
	<span class="n">SATA_DWC_RXFIFO_DEPTH</span>	<span class="o">=</span>	<span class="mh">0x01FF</span><span class="p">,</span>
	<span class="n">SATA_DWC_DMACR_TMOD_TXCHEN</span> <span class="o">=</span>	<span class="mh">0x00000004</span><span class="p">,</span>
	<span class="n">SATA_DWC_DMACR_TXCHEN</span>	<span class="o">=</span> <span class="p">(</span><span class="mh">0x00000001</span> <span class="o">|</span> <span class="n">SATA_DWC_DMACR_TMOD_TXCHEN</span><span class="p">),</span>
	<span class="n">SATA_DWC_DMACR_RXCHEN</span>	<span class="o">=</span> <span class="p">(</span><span class="mh">0x00000002</span> <span class="o">|</span> <span class="n">SATA_DWC_DMACR_TMOD_TXCHEN</span><span class="p">),</span>
	<span class="n">SATA_DWC_DMACR_TXRXCH_CLEAR</span> <span class="o">=</span>	<span class="n">SATA_DWC_DMACR_TMOD_TXCHEN</span><span class="p">,</span>
	<span class="n">SATA_DWC_INTPR_DMAT</span>	<span class="o">=</span>	<span class="mh">0x00000001</span><span class="p">,</span>
	<span class="n">SATA_DWC_INTPR_NEWFP</span>	<span class="o">=</span>	<span class="mh">0x00000002</span><span class="p">,</span>
	<span class="n">SATA_DWC_INTPR_PMABRT</span>	<span class="o">=</span>	<span class="mh">0x00000004</span><span class="p">,</span>
	<span class="n">SATA_DWC_INTPR_ERR</span>	<span class="o">=</span>	<span class="mh">0x00000008</span><span class="p">,</span>
	<span class="n">SATA_DWC_INTPR_NEWBIST</span>	<span class="o">=</span>	<span class="mh">0x00000010</span><span class="p">,</span>
	<span class="n">SATA_DWC_INTPR_IPF</span>	<span class="o">=</span>	<span class="mh">0x10000000</span><span class="p">,</span>
	<span class="n">SATA_DWC_INTMR_DMATM</span>	<span class="o">=</span>	<span class="mh">0x00000001</span><span class="p">,</span>
	<span class="n">SATA_DWC_INTMR_NEWFPM</span>	<span class="o">=</span>	<span class="mh">0x00000002</span><span class="p">,</span>
	<span class="n">SATA_DWC_INTMR_PMABRTM</span>	<span class="o">=</span>	<span class="mh">0x00000004</span><span class="p">,</span>
	<span class="n">SATA_DWC_INTMR_ERRM</span>	<span class="o">=</span>	<span class="mh">0x00000008</span><span class="p">,</span>
	<span class="n">SATA_DWC_INTMR_NEWBISTM</span>	<span class="o">=</span>	<span class="mh">0x00000010</span><span class="p">,</span>
	<span class="n">SATA_DWC_LLCR_SCRAMEN</span>	<span class="o">=</span>	<span class="mh">0x00000001</span><span class="p">,</span>
	<span class="n">SATA_DWC_LLCR_DESCRAMEN</span>	<span class="o">=</span>	<span class="mh">0x00000002</span><span class="p">,</span>
	<span class="n">SATA_DWC_LLCR_RPDEN</span>	<span class="o">=</span>	<span class="mh">0x00000004</span><span class="p">,</span>
<span class="cm">/* This is all error bits, zero&#39;s are reserved fields. */</span>
	<span class="n">SATA_DWC_SERROR_ERR_BITS</span> <span class="o">=</span>	<span class="mh">0x0FFF0F03</span>
<span class="p">};</span>

<span class="cp">#define SATA_DWC_SCR0_SPD_GET(v)	(((v) &gt;&gt; 4) &amp; 0x0000000F)</span>
<span class="cp">#define SATA_DWC_DMACR_TX_CLEAR(v)	(((v) &amp; ~SATA_DWC_DMACR_TXCHEN) |\</span>
<span class="cp">						 SATA_DWC_DMACR_TMOD_TXCHEN)</span>
<span class="cp">#define SATA_DWC_DMACR_RX_CLEAR(v)	(((v) &amp; ~SATA_DWC_DMACR_RXCHEN) |\</span>
<span class="cp">						 SATA_DWC_DMACR_TMOD_TXCHEN)</span>
<span class="cp">#define SATA_DWC_DBTSR_MWR(size)	(((size)/4) &amp; SATA_DWC_TXFIFO_DEPTH)</span>
<span class="cp">#define SATA_DWC_DBTSR_MRD(size)	((((size)/4) &amp; SATA_DWC_RXFIFO_DEPTH)\</span>
<span class="cp">						 &lt;&lt; 16)</span>
<span class="k">struct</span> <span class="n">sata_dwc_device</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">device</span>		<span class="o">*</span><span class="n">dev</span><span class="p">;</span>		<span class="cm">/* generic device struct */</span>
	<span class="k">struct</span> <span class="n">ata_probe_ent</span>	<span class="o">*</span><span class="n">pe</span><span class="p">;</span>		<span class="cm">/* ptr to probe-ent */</span>
	<span class="k">struct</span> <span class="n">ata_host</span>		<span class="o">*</span><span class="n">host</span><span class="p">;</span>
	<span class="n">u8</span>			<span class="o">*</span><span class="n">reg_base</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sata_dwc_regs</span>	<span class="o">*</span><span class="n">sata_dwc_regs</span><span class="p">;</span>	<span class="cm">/* DW Synopsys SATA specific */</span>
	<span class="kt">int</span>			<span class="n">irq_dma</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#define SATA_DWC_QCMD_MAX	32</span>

<span class="k">struct</span> <span class="n">sata_dwc_device_port</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">sata_dwc_device</span>	<span class="o">*</span><span class="n">hsdev</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">cmd_issued</span><span class="p">[</span><span class="n">SATA_DWC_QCMD_MAX</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">lli</span>		<span class="o">*</span><span class="n">llit</span><span class="p">[</span><span class="n">SATA_DWC_QCMD_MAX</span><span class="p">];</span>  <span class="cm">/* DMA LLI table */</span>
	<span class="n">dma_addr_t</span>		<span class="n">llit_dma</span><span class="p">[</span><span class="n">SATA_DWC_QCMD_MAX</span><span class="p">];</span>
	<span class="n">u32</span>			<span class="n">dma_chan</span><span class="p">[</span><span class="n">SATA_DWC_QCMD_MAX</span><span class="p">];</span>
	<span class="kt">int</span>			<span class="n">dma_pending</span><span class="p">[</span><span class="n">SATA_DWC_QCMD_MAX</span><span class="p">];</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Commonly used DWC SATA driver Macros</span>
<span class="cm"> */</span>
<span class="cp">#define HSDEV_FROM_HOST(host)  ((struct sata_dwc_device *)\</span>
<span class="cp">					(host)-&gt;private_data)</span>
<span class="cp">#define HSDEV_FROM_AP(ap)  ((struct sata_dwc_device *)\</span>
<span class="cp">					(ap)-&gt;host-&gt;private_data)</span>
<span class="cp">#define HSDEVP_FROM_AP(ap)   ((struct sata_dwc_device_port *)\</span>
<span class="cp">					(ap)-&gt;private_data)</span>
<span class="cp">#define HSDEV_FROM_QC(qc)	((struct sata_dwc_device *)\</span>
<span class="cp">					(qc)-&gt;ap-&gt;host-&gt;private_data)</span>
<span class="cp">#define HSDEV_FROM_HSDEVP(p)	((struct sata_dwc_device *)\</span>
<span class="cp">						(hsdevp)-&gt;hsdev)</span>

<span class="k">enum</span> <span class="p">{</span>
	<span class="n">SATA_DWC_CMD_ISSUED_NOT</span>		<span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	<span class="n">SATA_DWC_CMD_ISSUED_PEND</span>	<span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
	<span class="n">SATA_DWC_CMD_ISSUED_EXEC</span>	<span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
	<span class="n">SATA_DWC_CMD_ISSUED_NODATA</span>	<span class="o">=</span> <span class="mi">3</span><span class="p">,</span>

	<span class="n">SATA_DWC_DMA_PENDING_NONE</span>	<span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	<span class="n">SATA_DWC_DMA_PENDING_TX</span>		<span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
	<span class="n">SATA_DWC_DMA_PENDING_RX</span>		<span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">sata_dwc_host_priv</span> <span class="p">{</span>
	<span class="kt">void</span>	<span class="n">__iomem</span>	 <span class="o">*</span><span class="n">scr_addr_sstatus</span><span class="p">;</span>
	<span class="n">u32</span>	<span class="n">sata_dwc_sactive_issued</span> <span class="p">;</span>
	<span class="n">u32</span>	<span class="n">sata_dwc_sactive_queued</span> <span class="p">;</span>
	<span class="n">u32</span>	<span class="n">dma_interrupt_count</span><span class="p">;</span>
	<span class="k">struct</span>	<span class="n">ahb_dma_regs</span>	<span class="o">*</span><span class="n">sata_dma_regs</span><span class="p">;</span>
	<span class="k">struct</span>	<span class="n">device</span>	<span class="o">*</span><span class="n">dwc_dev</span><span class="p">;</span>
<span class="p">};</span>
<span class="k">struct</span> <span class="n">sata_dwc_host_priv</span> <span class="n">host_pvt</span><span class="p">;</span>
<span class="cm">/*</span>
<span class="cm"> * Prototypes</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">sata_dwc_bmdma_start_by_tag</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_queued_cmd</span> <span class="o">*</span><span class="n">qc</span><span class="p">,</span> <span class="n">u8</span> <span class="n">tag</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">sata_dwc_qc_complete</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ata_queued_cmd</span> <span class="o">*</span><span class="n">qc</span><span class="p">,</span>
				<span class="n">u32</span> <span class="n">check_status</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">sata_dwc_dma_xfer_complete</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span><span class="p">,</span> <span class="n">u32</span> <span class="n">check_status</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">sata_dwc_port_stop</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">sata_dwc_clear_dmacr</span><span class="p">(</span><span class="k">struct</span> <span class="n">sata_dwc_device_port</span> <span class="o">*</span><span class="n">hsdevp</span><span class="p">,</span> <span class="n">u8</span> <span class="n">tag</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">dma_dwc_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">sata_dwc_device</span> <span class="o">*</span><span class="n">hsdev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">irq</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">dma_dwc_exit</span><span class="p">(</span><span class="k">struct</span> <span class="n">sata_dwc_device</span> <span class="o">*</span><span class="n">hsdev</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">dma_dwc_xfer_setup</span><span class="p">(</span><span class="k">struct</span> <span class="n">scatterlist</span> <span class="o">*</span><span class="n">sg</span><span class="p">,</span> <span class="kt">int</span> <span class="n">num_elems</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">lli</span> <span class="o">*</span><span class="n">lli</span><span class="p">,</span> <span class="n">dma_addr_t</span> <span class="n">dma_lli</span><span class="p">,</span>
			      <span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">addr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">dir</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">dma_dwc_xfer_start</span><span class="p">(</span><span class="kt">int</span> <span class="n">dma_ch</span><span class="p">);</span>

<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="nf">get_prot_descript</span><span class="p">(</span><span class="n">u8</span> <span class="n">protocol</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">switch</span> <span class="p">((</span><span class="k">enum</span> <span class="n">ata_tf_protocols</span><span class="p">)</span><span class="n">protocol</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">ATA_PROT_NODATA</span>:
		<span class="k">return</span> <span class="s">&quot;ATA no data&quot;</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">ATA_PROT_PIO</span>:
		<span class="k">return</span> <span class="s">&quot;ATA PIO&quot;</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">ATA_PROT_DMA</span>:
		<span class="k">return</span> <span class="s">&quot;ATA DMA&quot;</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">ATA_PROT_NCQ</span>:
		<span class="k">return</span> <span class="s">&quot;ATA NCQ&quot;</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">ATAPI_PROT_NODATA</span>:
		<span class="k">return</span> <span class="s">&quot;ATAPI no data&quot;</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">ATAPI_PROT_PIO</span>:
		<span class="k">return</span> <span class="s">&quot;ATAPI PIO&quot;</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">ATAPI_PROT_DMA</span>:
		<span class="k">return</span> <span class="s">&quot;ATAPI DMA&quot;</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">return</span> <span class="s">&quot;unknown&quot;</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="nf">get_dma_dir_descript</span><span class="p">(</span><span class="kt">int</span> <span class="n">dma_dir</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">switch</span> <span class="p">((</span><span class="k">enum</span> <span class="n">dma_data_direction</span><span class="p">)</span><span class="n">dma_dir</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">DMA_BIDIRECTIONAL</span>:
		<span class="k">return</span> <span class="s">&quot;bidirectional&quot;</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">DMA_TO_DEVICE</span>:
		<span class="k">return</span> <span class="s">&quot;to device&quot;</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">DMA_FROM_DEVICE</span>:
		<span class="k">return</span> <span class="s">&quot;from device&quot;</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">return</span> <span class="s">&quot;none&quot;</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">sata_dwc_tf_dump</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_taskfile</span> <span class="o">*</span><span class="n">tf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">dev_vdbg</span><span class="p">(</span><span class="n">host_pvt</span><span class="p">.</span><span class="n">dwc_dev</span><span class="p">,</span> <span class="s">&quot;taskfile cmd: 0x%02x protocol: %s flags:&quot;</span>
		<span class="s">&quot;0x%lx device: %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">tf</span><span class="o">-&gt;</span><span class="n">command</span><span class="p">,</span>
		<span class="n">get_prot_descript</span><span class="p">(</span><span class="n">tf</span><span class="o">-&gt;</span><span class="n">protocol</span><span class="p">),</span> <span class="n">tf</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">,</span> <span class="n">tf</span><span class="o">-&gt;</span><span class="n">device</span><span class="p">);</span>
	<span class="n">dev_vdbg</span><span class="p">(</span><span class="n">host_pvt</span><span class="p">.</span><span class="n">dwc_dev</span><span class="p">,</span> <span class="s">&quot;feature: 0x%02x nsect: 0x%x lbal: 0x%x &quot;</span>
		<span class="s">&quot;lbam: 0x%x lbah: 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">tf</span><span class="o">-&gt;</span><span class="n">feature</span><span class="p">,</span> <span class="n">tf</span><span class="o">-&gt;</span><span class="n">nsect</span><span class="p">,</span> <span class="n">tf</span><span class="o">-&gt;</span><span class="n">lbal</span><span class="p">,</span>
		 <span class="n">tf</span><span class="o">-&gt;</span><span class="n">lbam</span><span class="p">,</span> <span class="n">tf</span><span class="o">-&gt;</span><span class="n">lbah</span><span class="p">);</span>
	<span class="n">dev_vdbg</span><span class="p">(</span><span class="n">host_pvt</span><span class="p">.</span><span class="n">dwc_dev</span><span class="p">,</span> <span class="s">&quot;hob_feature: 0x%02x hob_nsect: 0x%x &quot;</span>
		<span class="s">&quot;hob_lbal: 0x%x hob_lbam: 0x%x hob_lbah: 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">tf</span><span class="o">-&gt;</span><span class="n">hob_feature</span><span class="p">,</span> <span class="n">tf</span><span class="o">-&gt;</span><span class="n">hob_nsect</span><span class="p">,</span> <span class="n">tf</span><span class="o">-&gt;</span><span class="n">hob_lbal</span><span class="p">,</span> <span class="n">tf</span><span class="o">-&gt;</span><span class="n">hob_lbam</span><span class="p">,</span>
		<span class="n">tf</span><span class="o">-&gt;</span><span class="n">hob_lbah</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Function: get_burst_length_encode</span>
<span class="cm"> * arguments: datalength: length in bytes of data</span>
<span class="cm"> * returns value to be programmed in register corresponding to data length</span>
<span class="cm"> * This value is effectively the log(base 2) of the length</span>
<span class="cm"> */</span>
<span class="k">static</span>  <span class="kt">int</span> <span class="nf">get_burst_length_encode</span><span class="p">(</span><span class="kt">int</span> <span class="n">datalength</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">items</span> <span class="o">=</span> <span class="n">datalength</span> <span class="o">&gt;&gt;</span> <span class="mi">2</span><span class="p">;</span>	<span class="cm">/* div by 4 to get lword count */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">items</span> <span class="o">&gt;=</span> <span class="mi">64</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">5</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">items</span> <span class="o">&gt;=</span> <span class="mi">32</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">4</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">items</span> <span class="o">&gt;=</span> <span class="mi">16</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">3</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">items</span> <span class="o">&gt;=</span> <span class="mi">8</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">2</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">items</span> <span class="o">&gt;=</span> <span class="mi">4</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span>  <span class="kt">void</span> <span class="nf">clear_chan_interrupts</span><span class="p">(</span><span class="kt">int</span> <span class="n">c</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">out_le32</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">host_pvt</span><span class="p">.</span><span class="n">sata_dma_regs</span><span class="o">-&gt;</span><span class="n">interrupt_clear</span><span class="p">.</span><span class="n">tfr</span><span class="p">.</span><span class="n">low</span><span class="p">),</span>
		 <span class="n">DMA_CHANNEL</span><span class="p">(</span><span class="n">c</span><span class="p">));</span>
	<span class="n">out_le32</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">host_pvt</span><span class="p">.</span><span class="n">sata_dma_regs</span><span class="o">-&gt;</span><span class="n">interrupt_clear</span><span class="p">.</span><span class="n">block</span><span class="p">.</span><span class="n">low</span><span class="p">),</span>
		 <span class="n">DMA_CHANNEL</span><span class="p">(</span><span class="n">c</span><span class="p">));</span>
	<span class="n">out_le32</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">host_pvt</span><span class="p">.</span><span class="n">sata_dma_regs</span><span class="o">-&gt;</span><span class="n">interrupt_clear</span><span class="p">.</span><span class="n">srctran</span><span class="p">.</span><span class="n">low</span><span class="p">),</span>
		 <span class="n">DMA_CHANNEL</span><span class="p">(</span><span class="n">c</span><span class="p">));</span>
	<span class="n">out_le32</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">host_pvt</span><span class="p">.</span><span class="n">sata_dma_regs</span><span class="o">-&gt;</span><span class="n">interrupt_clear</span><span class="p">.</span><span class="n">dsttran</span><span class="p">.</span><span class="n">low</span><span class="p">),</span>
		 <span class="n">DMA_CHANNEL</span><span class="p">(</span><span class="n">c</span><span class="p">));</span>
	<span class="n">out_le32</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">host_pvt</span><span class="p">.</span><span class="n">sata_dma_regs</span><span class="o">-&gt;</span><span class="n">interrupt_clear</span><span class="p">.</span><span class="n">error</span><span class="p">.</span><span class="n">low</span><span class="p">),</span>
		 <span class="n">DMA_CHANNEL</span><span class="p">(</span><span class="n">c</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Function: dma_request_channel</span>
<span class="cm"> * arguments: None</span>
<span class="cm"> * returns channel number if available else -1</span>
<span class="cm"> * This function assigns the next available DMA channel from the list to the</span>
<span class="cm"> * requester</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">dma_request_channel</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">DMA_NUM_CHANS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">in_le32</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">host_pvt</span><span class="p">.</span><span class="n">sata_dma_regs</span><span class="o">-&gt;</span><span class="n">dma_chan_en</span><span class="p">.</span><span class="n">low</span><span class="p">))</span> <span class="o">&amp;</span>\
			<span class="n">DMA_CHANNEL</span><span class="p">(</span><span class="n">i</span><span class="p">)))</span>
			<span class="k">return</span> <span class="n">i</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">dev_err</span><span class="p">(</span><span class="n">host_pvt</span><span class="p">.</span><span class="n">dwc_dev</span><span class="p">,</span> <span class="s">&quot;%s NO channel chan_en: 0x%08x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span>
		<span class="n">in_le32</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">host_pvt</span><span class="p">.</span><span class="n">sata_dma_regs</span><span class="o">-&gt;</span><span class="n">dma_chan_en</span><span class="p">.</span><span class="n">low</span><span class="p">)));</span>
	<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Function: dma_dwc_interrupt</span>
<span class="cm"> * arguments: irq, dev_id, pt_regs</span>
<span class="cm"> * returns channel number if available else -1</span>
<span class="cm"> * Interrupt Handler for DW AHB SATA DMA</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">irqreturn_t</span> <span class="nf">dma_dwc_interrupt</span><span class="p">(</span><span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">hsdev_instance</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">chan</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">tfr_reg</span><span class="p">,</span> <span class="n">err_reg</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sata_dwc_device</span> <span class="o">*</span><span class="n">hsdev</span> <span class="o">=</span>
		<span class="p">(</span><span class="k">struct</span> <span class="n">sata_dwc_device</span> <span class="o">*</span><span class="p">)</span><span class="n">hsdev_instance</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ata_host</span> <span class="o">*</span><span class="n">host</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ata_host</span> <span class="o">*</span><span class="p">)</span><span class="n">hsdev</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sata_dwc_device_port</span> <span class="o">*</span><span class="n">hsdevp</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">tag</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">port</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">ap</span> <span class="o">=</span> <span class="n">host</span><span class="o">-&gt;</span><span class="n">ports</span><span class="p">[</span><span class="n">port</span><span class="p">];</span>
	<span class="n">hsdevp</span> <span class="o">=</span> <span class="n">HSDEVP_FROM_AP</span><span class="p">(</span><span class="n">ap</span><span class="p">);</span>
	<span class="n">tag</span> <span class="o">=</span> <span class="n">ap</span><span class="o">-&gt;</span><span class="n">link</span><span class="p">.</span><span class="n">active_tag</span><span class="p">;</span>

	<span class="n">tfr_reg</span> <span class="o">=</span> <span class="n">in_le32</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">host_pvt</span><span class="p">.</span><span class="n">sata_dma_regs</span><span class="o">-&gt;</span><span class="n">interrupt_status</span><span class="p">.</span><span class="n">tfr</span>\
			<span class="p">.</span><span class="n">low</span><span class="p">));</span>
	<span class="n">err_reg</span> <span class="o">=</span> <span class="n">in_le32</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">host_pvt</span><span class="p">.</span><span class="n">sata_dma_regs</span><span class="o">-&gt;</span><span class="n">interrupt_status</span><span class="p">.</span><span class="n">error</span>\
			<span class="p">.</span><span class="n">low</span><span class="p">));</span>

	<span class="n">dev_dbg</span><span class="p">(</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;eot=0x%08x err=0x%08x pending=%d active port=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">tfr_reg</span><span class="p">,</span> <span class="n">err_reg</span><span class="p">,</span> <span class="n">hsdevp</span><span class="o">-&gt;</span><span class="n">dma_pending</span><span class="p">[</span><span class="n">tag</span><span class="p">],</span> <span class="n">port</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">chan</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">chan</span> <span class="o">&lt;</span> <span class="n">DMA_NUM_CHANS</span><span class="p">;</span> <span class="n">chan</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Check for end-of-transfer interrupt. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tfr_reg</span> <span class="o">&amp;</span> <span class="n">DMA_CHANNEL</span><span class="p">(</span><span class="n">chan</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * Each DMA command produces 2 interrupts.  Only</span>
<span class="cm">			 * complete the command after both interrupts have been</span>
<span class="cm">			 * seen. (See sata_dwc_isr())</span>
<span class="cm">			 */</span>
			<span class="n">host_pvt</span><span class="p">.</span><span class="n">dma_interrupt_count</span><span class="o">++</span><span class="p">;</span>
			<span class="n">sata_dwc_clear_dmacr</span><span class="p">(</span><span class="n">hsdevp</span><span class="p">,</span> <span class="n">tag</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">hsdevp</span><span class="o">-&gt;</span><span class="n">dma_pending</span><span class="p">[</span><span class="n">tag</span><span class="p">]</span> <span class="o">==</span>
			    <span class="n">SATA_DWC_DMA_PENDING_NONE</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">dev_err</span><span class="p">(</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;DMA not pending eot=0x%08x &quot;</span>
					<span class="s">&quot;err=0x%08x tag=0x%02x pending=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">tfr_reg</span><span class="p">,</span> <span class="n">err_reg</span><span class="p">,</span> <span class="n">tag</span><span class="p">,</span>
					<span class="n">hsdevp</span><span class="o">-&gt;</span><span class="n">dma_pending</span><span class="p">[</span><span class="n">tag</span><span class="p">]);</span>
			<span class="p">}</span>

			<span class="k">if</span> <span class="p">((</span><span class="n">host_pvt</span><span class="p">.</span><span class="n">dma_interrupt_count</span> <span class="o">%</span> <span class="mi">2</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
				<span class="n">sata_dwc_dma_xfer_complete</span><span class="p">(</span><span class="n">ap</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

			<span class="cm">/* Clear the interrupt */</span>
			<span class="n">out_le32</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">host_pvt</span><span class="p">.</span><span class="n">sata_dma_regs</span><span class="o">-&gt;</span><span class="n">interrupt_clear</span>\
				<span class="p">.</span><span class="n">tfr</span><span class="p">.</span><span class="n">low</span><span class="p">),</span>
				 <span class="n">DMA_CHANNEL</span><span class="p">(</span><span class="n">chan</span><span class="p">));</span>
		<span class="p">}</span>

		<span class="cm">/* Check for error interrupt. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err_reg</span> <span class="o">&amp;</span> <span class="n">DMA_CHANNEL</span><span class="p">(</span><span class="n">chan</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/* TODO Need error handler ! */</span>
			<span class="n">dev_err</span><span class="p">(</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;error interrupt err_reg=0x%08x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">err_reg</span><span class="p">);</span>

			<span class="cm">/* Clear the interrupt. */</span>
			<span class="n">out_le32</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">host_pvt</span><span class="p">.</span><span class="n">sata_dma_regs</span><span class="o">-&gt;</span><span class="n">interrupt_clear</span>\
				<span class="p">.</span><span class="n">error</span><span class="p">.</span><span class="n">low</span><span class="p">),</span>
				 <span class="n">DMA_CHANNEL</span><span class="p">(</span><span class="n">chan</span><span class="p">));</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">IRQ_HANDLED</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Function: dma_request_interrupts</span>
<span class="cm"> * arguments: hsdev</span>
<span class="cm"> * returns status</span>
<span class="cm"> * This function registers ISR for a particular DMA channel interrupt</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">dma_request_interrupts</span><span class="p">(</span><span class="k">struct</span> <span class="n">sata_dwc_device</span> <span class="o">*</span><span class="n">hsdev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">irq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">retval</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">chan</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">chan</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">chan</span> <span class="o">&lt;</span> <span class="n">DMA_NUM_CHANS</span><span class="p">;</span> <span class="n">chan</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Unmask error interrupt */</span>
		<span class="n">out_le32</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">host_pvt</span><span class="p">.</span><span class="n">sata_dma_regs</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">interrupt_mask</span><span class="p">.</span><span class="n">error</span><span class="p">.</span><span class="n">low</span><span class="p">,</span>
			 <span class="n">DMA_ENABLE_CHAN</span><span class="p">(</span><span class="n">chan</span><span class="p">));</span>

		<span class="cm">/* Unmask end-of-transfer interrupt */</span>
		<span class="n">out_le32</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">host_pvt</span><span class="p">.</span><span class="n">sata_dma_regs</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">interrupt_mask</span><span class="p">.</span><span class="n">tfr</span><span class="p">.</span><span class="n">low</span><span class="p">,</span>
			 <span class="n">DMA_ENABLE_CHAN</span><span class="p">(</span><span class="n">chan</span><span class="p">));</span>
	<span class="p">}</span>

	<span class="n">retval</span> <span class="o">=</span> <span class="n">request_irq</span><span class="p">(</span><span class="n">irq</span><span class="p">,</span> <span class="n">dma_dwc_interrupt</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="s">&quot;SATA DMA&quot;</span><span class="p">,</span> <span class="n">hsdev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">host_pvt</span><span class="p">.</span><span class="n">dwc_dev</span><span class="p">,</span> <span class="s">&quot;%s: could not get IRQ %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">__func__</span><span class="p">,</span> <span class="n">irq</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Mark this interrupt as requested */</span>
	<span class="n">hsdev</span><span class="o">-&gt;</span><span class="n">irq_dma</span> <span class="o">=</span> <span class="n">irq</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Function: map_sg_to_lli</span>
<span class="cm"> * The Synopsis driver has a comment proposing that better performance</span>
<span class="cm"> * is possible by only enabling interrupts on the last item in the linked list.</span>
<span class="cm"> * However, it seems that could be a problem if an error happened on one of the</span>
<span class="cm"> * first items.  The transfer would halt, but no error interrupt would occur.</span>
<span class="cm"> * Currently this function sets interrupts enabled for each linked list item:</span>
<span class="cm"> * DMA_CTL_INT_EN.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">map_sg_to_lli</span><span class="p">(</span><span class="k">struct</span> <span class="n">scatterlist</span> <span class="o">*</span><span class="n">sg</span><span class="p">,</span> <span class="kt">int</span> <span class="n">num_elems</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">lli</span> <span class="o">*</span><span class="n">lli</span><span class="p">,</span> <span class="n">dma_addr_t</span> <span class="n">dma_lli</span><span class="p">,</span>
			<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">dmadr_addr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">dir</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">fis_len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">dma_addr_t</span> <span class="n">next_llp</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">bl</span><span class="p">;</span>

	<span class="n">dev_dbg</span><span class="p">(</span><span class="n">host_pvt</span><span class="p">.</span><span class="n">dwc_dev</span><span class="p">,</span> <span class="s">&quot;%s: sg=%p nelem=%d lli=%p dma_lli=0x%08x&quot;</span>
		<span class="s">&quot; dmadr=0x%08x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">sg</span><span class="p">,</span> <span class="n">num_elems</span><span class="p">,</span> <span class="n">lli</span><span class="p">,</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span><span class="n">dma_lli</span><span class="p">,</span>
		<span class="p">(</span><span class="n">u32</span><span class="p">)</span><span class="n">dmadr_addr</span><span class="p">);</span>

	<span class="n">bl</span> <span class="o">=</span> <span class="n">get_burst_length_encode</span><span class="p">(</span><span class="n">AHB_DMA_BRST_DFLT</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">num_elems</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">,</span> <span class="n">sg</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">u32</span> <span class="n">addr</span><span class="p">,</span> <span class="n">offset</span><span class="p">;</span>
		<span class="n">u32</span> <span class="n">sg_len</span><span class="p">,</span> <span class="n">len</span><span class="p">;</span>

		<span class="n">addr</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span> <span class="n">sg_dma_address</span><span class="p">(</span><span class="n">sg</span><span class="p">);</span>
		<span class="n">sg_len</span> <span class="o">=</span> <span class="n">sg_dma_len</span><span class="p">(</span><span class="n">sg</span><span class="p">);</span>

		<span class="n">dev_dbg</span><span class="p">(</span><span class="n">host_pvt</span><span class="p">.</span><span class="n">dwc_dev</span><span class="p">,</span> <span class="s">&quot;%s: elem=%d sg_addr=0x%x sg_len&quot;</span>
			<span class="s">&quot;=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">sg_len</span><span class="p">);</span>

		<span class="k">while</span> <span class="p">(</span><span class="n">sg_len</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">idx</span> <span class="o">&gt;=</span> <span class="n">SATA_DWC_DMAC_LLI_NUM</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/* The LLI table is not large enough. */</span>
				<span class="n">dev_err</span><span class="p">(</span><span class="n">host_pvt</span><span class="p">.</span><span class="n">dwc_dev</span><span class="p">,</span> <span class="s">&quot;LLI table overrun &quot;</span>
				<span class="s">&quot;(idx=%d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">idx</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">len</span> <span class="o">=</span> <span class="p">(</span><span class="n">sg_len</span> <span class="o">&gt;</span> <span class="n">SATA_DWC_DMAC_CTRL_TSIZE_MAX</span><span class="p">)</span> <span class="o">?</span>
				<span class="n">SATA_DWC_DMAC_CTRL_TSIZE_MAX</span> <span class="o">:</span> <span class="n">sg_len</span><span class="p">;</span>

			<span class="n">offset</span> <span class="o">=</span> <span class="n">addr</span> <span class="o">&amp;</span> <span class="mh">0xffff</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">offset</span> <span class="o">+</span> <span class="n">sg_len</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mh">0x10000</span><span class="p">)</span>
				<span class="n">len</span> <span class="o">=</span> <span class="mh">0x10000</span> <span class="o">-</span> <span class="n">offset</span><span class="p">;</span>

			<span class="cm">/*</span>
<span class="cm">			 * Make sure a LLI block is not created that will span</span>
<span class="cm">			 * 8K max FIS boundary.  If the block spans such a FIS</span>
<span class="cm">			 * boundary, there is a chance that a DMA burst will</span>
<span class="cm">			 * cross that boundary -- this results in an error in</span>
<span class="cm">			 * the host controller.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">fis_len</span> <span class="o">+</span> <span class="n">len</span> <span class="o">&gt;</span> <span class="mi">8192</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">dev_dbg</span><span class="p">(</span><span class="n">host_pvt</span><span class="p">.</span><span class="n">dwc_dev</span><span class="p">,</span> <span class="s">&quot;SPLITTING: fis_len=&quot;</span>
					<span class="s">&quot;%d(0x%x) len=%d(0x%x)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">fis_len</span><span class="p">,</span>
					 <span class="n">fis_len</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
				<span class="n">len</span> <span class="o">=</span> <span class="mi">8192</span> <span class="o">-</span> <span class="n">fis_len</span><span class="p">;</span>
				<span class="n">fis_len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="n">fis_len</span> <span class="o">+=</span> <span class="n">len</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">fis_len</span> <span class="o">==</span> <span class="mi">8192</span><span class="p">)</span>
				<span class="n">fis_len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

			<span class="cm">/*</span>
<span class="cm">			 * Set DMA addresses and lower half of control register</span>
<span class="cm">			 * based on direction.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">dir</span> <span class="o">==</span> <span class="n">DMA_FROM_DEVICE</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">lli</span><span class="p">[</span><span class="n">idx</span><span class="p">].</span><span class="n">dar</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">addr</span><span class="p">);</span>
				<span class="n">lli</span><span class="p">[</span><span class="n">idx</span><span class="p">].</span><span class="n">sar</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">((</span><span class="n">u32</span><span class="p">)</span><span class="n">dmadr_addr</span><span class="p">);</span>

				<span class="n">lli</span><span class="p">[</span><span class="n">idx</span><span class="p">].</span><span class="n">ctl</span><span class="p">.</span><span class="n">low</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span>
					<span class="n">DMA_CTL_TTFC</span><span class="p">(</span><span class="n">DMA_CTL_TTFC_P2M_DMAC</span><span class="p">)</span> <span class="o">|</span>
					<span class="n">DMA_CTL_SMS</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">|</span>
					<span class="n">DMA_CTL_DMS</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">|</span>
					<span class="n">DMA_CTL_SRC_MSIZE</span><span class="p">(</span><span class="n">bl</span><span class="p">)</span> <span class="o">|</span>
					<span class="n">DMA_CTL_DST_MSIZE</span><span class="p">(</span><span class="n">bl</span><span class="p">)</span> <span class="o">|</span>
					<span class="n">DMA_CTL_SINC_NOCHANGE</span> <span class="o">|</span>
					<span class="n">DMA_CTL_SRC_TRWID</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">|</span>
					<span class="n">DMA_CTL_DST_TRWID</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">|</span>
					<span class="n">DMA_CTL_INT_EN</span> <span class="o">|</span>
					<span class="n">DMA_CTL_LLP_SRCEN</span> <span class="o">|</span>
					<span class="n">DMA_CTL_LLP_DSTEN</span><span class="p">);</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>	<span class="cm">/* DMA_TO_DEVICE */</span>
				<span class="n">lli</span><span class="p">[</span><span class="n">idx</span><span class="p">].</span><span class="n">sar</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">addr</span><span class="p">);</span>
				<span class="n">lli</span><span class="p">[</span><span class="n">idx</span><span class="p">].</span><span class="n">dar</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">((</span><span class="n">u32</span><span class="p">)</span><span class="n">dmadr_addr</span><span class="p">);</span>

				<span class="n">lli</span><span class="p">[</span><span class="n">idx</span><span class="p">].</span><span class="n">ctl</span><span class="p">.</span><span class="n">low</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span>
					<span class="n">DMA_CTL_TTFC</span><span class="p">(</span><span class="n">DMA_CTL_TTFC_M2P_PER</span><span class="p">)</span> <span class="o">|</span>
					<span class="n">DMA_CTL_SMS</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">|</span>
					<span class="n">DMA_CTL_DMS</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">|</span>
					<span class="n">DMA_CTL_SRC_MSIZE</span><span class="p">(</span><span class="n">bl</span><span class="p">)</span> <span class="o">|</span>
					<span class="n">DMA_CTL_DST_MSIZE</span><span class="p">(</span><span class="n">bl</span><span class="p">)</span> <span class="o">|</span>
					<span class="n">DMA_CTL_DINC_NOCHANGE</span> <span class="o">|</span>
					<span class="n">DMA_CTL_SRC_TRWID</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">|</span>
					<span class="n">DMA_CTL_DST_TRWID</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">|</span>
					<span class="n">DMA_CTL_INT_EN</span> <span class="o">|</span>
					<span class="n">DMA_CTL_LLP_SRCEN</span> <span class="o">|</span>
					<span class="n">DMA_CTL_LLP_DSTEN</span><span class="p">);</span>
			<span class="p">}</span>

			<span class="n">dev_dbg</span><span class="p">(</span><span class="n">host_pvt</span><span class="p">.</span><span class="n">dwc_dev</span><span class="p">,</span> <span class="s">&quot;%s setting ctl.high len: &quot;</span>
				<span class="s">&quot;0x%08x val: 0x%08x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span>
				<span class="n">len</span><span class="p">,</span> <span class="n">DMA_CTL_BLK_TS</span><span class="p">(</span><span class="n">len</span> <span class="o">/</span> <span class="mi">4</span><span class="p">));</span>

			<span class="cm">/* Program the LLI CTL high register */</span>
			<span class="n">lli</span><span class="p">[</span><span class="n">idx</span><span class="p">].</span><span class="n">ctl</span><span class="p">.</span><span class="n">high</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">DMA_CTL_BLK_TS</span>\
						<span class="p">(</span><span class="n">len</span> <span class="o">/</span> <span class="mi">4</span><span class="p">));</span>

			<span class="cm">/* Program the next pointer.  The next pointer must be</span>
<span class="cm">			 * the physical address, not the virtual address.</span>
<span class="cm">			 */</span>
			<span class="n">next_llp</span> <span class="o">=</span> <span class="p">(</span><span class="n">dma_lli</span> <span class="o">+</span> <span class="p">((</span><span class="n">idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> \
							<span class="n">lli</span><span class="p">)));</span>

			<span class="cm">/* The last 2 bits encode the list master select. */</span>
			<span class="n">next_llp</span> <span class="o">=</span> <span class="n">DMA_LLP_LMS</span><span class="p">(</span><span class="n">next_llp</span><span class="p">,</span> <span class="n">DMA_LLP_AHBMASTER2</span><span class="p">);</span>

			<span class="n">lli</span><span class="p">[</span><span class="n">idx</span><span class="p">].</span><span class="n">llp</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">next_llp</span><span class="p">);</span>
			<span class="n">idx</span><span class="o">++</span><span class="p">;</span>
			<span class="n">sg_len</span> <span class="o">-=</span> <span class="n">len</span><span class="p">;</span>
			<span class="n">addr</span> <span class="o">+=</span> <span class="n">len</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * The last next ptr has to be zero and the last control low register</span>
<span class="cm">	 * has to have LLP_SRC_EN and LLP_DST_EN (linked list pointer source</span>
<span class="cm">	 * and destination enable) set back to 0 (disabled.) This is what tells</span>
<span class="cm">	 * the core that this is the last item in the linked list.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">idx</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lli</span><span class="p">[</span><span class="n">idx</span><span class="o">-</span><span class="mi">1</span><span class="p">].</span><span class="n">llp</span> <span class="o">=</span> <span class="mh">0x00000000</span><span class="p">;</span>
		<span class="n">lli</span><span class="p">[</span><span class="n">idx</span><span class="o">-</span><span class="mi">1</span><span class="p">].</span><span class="n">ctl</span><span class="p">.</span><span class="n">low</span> <span class="o">&amp;=</span> <span class="n">DMA_CTL_LLP_DISABLE_LE32</span><span class="p">;</span>

		<span class="cm">/* Flush cache to memory */</span>
		<span class="n">dma_cache_sync</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">lli</span><span class="p">,</span> <span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">lli</span><span class="p">)</span> <span class="o">*</span> <span class="n">idx</span><span class="p">),</span>
			       <span class="n">DMA_BIDIRECTIONAL</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">idx</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Function: dma_dwc_xfer_start</span>
<span class="cm"> * arguments: Channel number</span>
<span class="cm"> * Return : None</span>
<span class="cm"> * Enables the DMA channel</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">dma_dwc_xfer_start</span><span class="p">(</span><span class="kt">int</span> <span class="n">dma_ch</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Enable the DMA channel */</span>
	<span class="n">out_le32</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">host_pvt</span><span class="p">.</span><span class="n">sata_dma_regs</span><span class="o">-&gt;</span><span class="n">dma_chan_en</span><span class="p">.</span><span class="n">low</span><span class="p">),</span>
		 <span class="n">in_le32</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">host_pvt</span><span class="p">.</span><span class="n">sata_dma_regs</span><span class="o">-&gt;</span><span class="n">dma_chan_en</span><span class="p">.</span><span class="n">low</span><span class="p">))</span> <span class="o">|</span>
		 <span class="n">DMA_ENABLE_CHAN</span><span class="p">(</span><span class="n">dma_ch</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">dma_dwc_xfer_setup</span><span class="p">(</span><span class="k">struct</span> <span class="n">scatterlist</span> <span class="o">*</span><span class="n">sg</span><span class="p">,</span> <span class="kt">int</span> <span class="n">num_elems</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">lli</span> <span class="o">*</span><span class="n">lli</span><span class="p">,</span> <span class="n">dma_addr_t</span> <span class="n">dma_lli</span><span class="p">,</span>
			      <span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">addr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">dir</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">dma_ch</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">num_lli</span><span class="p">;</span>
	<span class="cm">/* Acquire DMA channel */</span>
	<span class="n">dma_ch</span> <span class="o">=</span> <span class="n">dma_request_channel</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dma_ch</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">host_pvt</span><span class="p">.</span><span class="n">dwc_dev</span><span class="p">,</span> <span class="s">&quot;%s: dma channel unavailable</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			 <span class="n">__func__</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Convert SG list to linked list of items (LLIs) for AHB DMA */</span>
	<span class="n">num_lli</span> <span class="o">=</span> <span class="n">map_sg_to_lli</span><span class="p">(</span><span class="n">sg</span><span class="p">,</span> <span class="n">num_elems</span><span class="p">,</span> <span class="n">lli</span><span class="p">,</span> <span class="n">dma_lli</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">dir</span><span class="p">);</span>

	<span class="n">dev_dbg</span><span class="p">(</span><span class="n">host_pvt</span><span class="p">.</span><span class="n">dwc_dev</span><span class="p">,</span> <span class="s">&quot;%s sg: 0x%p, count: %d lli: %p dma_lli:&quot;</span>
		<span class="s">&quot; 0x%0xlx addr: %p lli count: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">sg</span><span class="p">,</span> <span class="n">num_elems</span><span class="p">,</span>
		 <span class="n">lli</span><span class="p">,</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span><span class="n">dma_lli</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">num_lli</span><span class="p">);</span>

	<span class="n">clear_chan_interrupts</span><span class="p">(</span><span class="n">dma_ch</span><span class="p">);</span>

	<span class="cm">/* Program the CFG register. */</span>
	<span class="n">out_le32</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">host_pvt</span><span class="p">.</span><span class="n">sata_dma_regs</span><span class="o">-&gt;</span><span class="n">chan_regs</span><span class="p">[</span><span class="n">dma_ch</span><span class="p">].</span><span class="n">cfg</span><span class="p">.</span><span class="n">high</span><span class="p">),</span>
		 <span class="n">DMA_CFG_PROTCTL</span> <span class="o">|</span> <span class="n">DMA_CFG_FCMOD_REQ</span><span class="p">);</span>
	<span class="n">out_le32</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">host_pvt</span><span class="p">.</span><span class="n">sata_dma_regs</span><span class="o">-&gt;</span><span class="n">chan_regs</span><span class="p">[</span><span class="n">dma_ch</span><span class="p">].</span><span class="n">cfg</span><span class="p">.</span><span class="n">low</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span>

	<span class="cm">/* Program the address of the linked list */</span>
	<span class="n">out_le32</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">host_pvt</span><span class="p">.</span><span class="n">sata_dma_regs</span><span class="o">-&gt;</span><span class="n">chan_regs</span><span class="p">[</span><span class="n">dma_ch</span><span class="p">].</span><span class="n">llp</span><span class="p">.</span><span class="n">low</span><span class="p">),</span>
		 <span class="n">DMA_LLP_LMS</span><span class="p">(</span><span class="n">dma_lli</span><span class="p">,</span> <span class="n">DMA_LLP_AHBMASTER2</span><span class="p">));</span>

	<span class="cm">/* Program the CTL register with src enable / dst enable */</span>
	<span class="n">out_le32</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">host_pvt</span><span class="p">.</span><span class="n">sata_dma_regs</span><span class="o">-&gt;</span><span class="n">chan_regs</span><span class="p">[</span><span class="n">dma_ch</span><span class="p">].</span><span class="n">ctl</span><span class="p">.</span><span class="n">low</span><span class="p">),</span>
		 <span class="n">DMA_CTL_LLP_SRCEN</span> <span class="o">|</span> <span class="n">DMA_CTL_LLP_DSTEN</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">dma_ch</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Function: dma_dwc_exit</span>
<span class="cm"> * arguments: None</span>
<span class="cm"> * returns status</span>
<span class="cm"> * This function exits the SATA DMA driver</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">dma_dwc_exit</span><span class="p">(</span><span class="k">struct</span> <span class="n">sata_dwc_device</span> <span class="o">*</span><span class="n">hsdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">dev_dbg</span><span class="p">(</span><span class="n">host_pvt</span><span class="p">.</span><span class="n">dwc_dev</span><span class="p">,</span> <span class="s">&quot;%s:</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">host_pvt</span><span class="p">.</span><span class="n">sata_dma_regs</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">iounmap</span><span class="p">(</span><span class="n">host_pvt</span><span class="p">.</span><span class="n">sata_dma_regs</span><span class="p">);</span>
		<span class="n">host_pvt</span><span class="p">.</span><span class="n">sata_dma_regs</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">hsdev</span><span class="o">-&gt;</span><span class="n">irq_dma</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">free_irq</span><span class="p">(</span><span class="n">hsdev</span><span class="o">-&gt;</span><span class="n">irq_dma</span><span class="p">,</span> <span class="n">hsdev</span><span class="p">);</span>
		<span class="n">hsdev</span><span class="o">-&gt;</span><span class="n">irq_dma</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Function: dma_dwc_init</span>
<span class="cm"> * arguments: hsdev</span>
<span class="cm"> * returns status</span>
<span class="cm"> * This function initializes the SATA DMA driver</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">dma_dwc_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">sata_dwc_device</span> <span class="o">*</span><span class="n">hsdev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">irq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">dma_request_interrupts</span><span class="p">(</span><span class="n">hsdev</span><span class="p">,</span> <span class="n">irq</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">host_pvt</span><span class="p">.</span><span class="n">dwc_dev</span><span class="p">,</span> <span class="s">&quot;%s: dma_request_interrupts returns&quot;</span>
			<span class="s">&quot; %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">error_out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Enabe DMA */</span>
	<span class="n">out_le32</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">host_pvt</span><span class="p">.</span><span class="n">sata_dma_regs</span><span class="o">-&gt;</span><span class="n">dma_cfg</span><span class="p">.</span><span class="n">low</span><span class="p">),</span> <span class="n">DMA_EN</span><span class="p">);</span>

	<span class="n">dev_notice</span><span class="p">(</span><span class="n">host_pvt</span><span class="p">.</span><span class="n">dwc_dev</span><span class="p">,</span> <span class="s">&quot;DMA initialized</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">dev_dbg</span><span class="p">(</span><span class="n">host_pvt</span><span class="p">.</span><span class="n">dwc_dev</span><span class="p">,</span> <span class="s">&quot;SATA DMA registers=0x%p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">host_pvt</span><span class="p">.</span>\
		<span class="n">sata_dma_regs</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">error_out:</span>
	<span class="n">dma_dwc_exit</span><span class="p">(</span><span class="n">hsdev</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">sata_dwc_scr_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_link</span> <span class="o">*</span><span class="n">link</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">scr</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">scr</span> <span class="o">&gt;</span> <span class="n">SCR_NOTIFICATION</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">link</span><span class="o">-&gt;</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s: Incorrect SCR offset 0x%02x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">__func__</span><span class="p">,</span> <span class="n">scr</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="o">*</span><span class="n">val</span> <span class="o">=</span> <span class="n">in_le32</span><span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">link</span><span class="o">-&gt;</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">ioaddr</span><span class="p">.</span><span class="n">scr_addr</span> <span class="o">+</span> <span class="p">(</span><span class="n">scr</span> <span class="o">*</span> <span class="mi">4</span><span class="p">));</span>
	<span class="n">dev_dbg</span><span class="p">(</span><span class="n">link</span><span class="o">-&gt;</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s: id=%d reg=%d val=val=0x%08x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">__func__</span><span class="p">,</span> <span class="n">link</span><span class="o">-&gt;</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">print_id</span><span class="p">,</span> <span class="n">scr</span><span class="p">,</span> <span class="o">*</span><span class="n">val</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">sata_dwc_scr_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_link</span> <span class="o">*</span><span class="n">link</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">scr</span><span class="p">,</span> <span class="n">u32</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">dev_dbg</span><span class="p">(</span><span class="n">link</span><span class="o">-&gt;</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s: id=%d reg=%d val=val=0x%08x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">__func__</span><span class="p">,</span> <span class="n">link</span><span class="o">-&gt;</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">print_id</span><span class="p">,</span> <span class="n">scr</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">scr</span> <span class="o">&gt;</span> <span class="n">SCR_NOTIFICATION</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">link</span><span class="o">-&gt;</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s: Incorrect SCR offset 0x%02x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			 <span class="n">__func__</span><span class="p">,</span> <span class="n">scr</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">out_le32</span><span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">link</span><span class="o">-&gt;</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">ioaddr</span><span class="p">.</span><span class="n">scr_addr</span> <span class="o">+</span> <span class="p">(</span><span class="n">scr</span> <span class="o">*</span> <span class="mi">4</span><span class="p">),</span> <span class="n">val</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">u32</span> <span class="nf">core_scr_read</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">scr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">in_le32</span><span class="p">((</span><span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="p">)(</span><span class="n">host_pvt</span><span class="p">.</span><span class="n">scr_addr_sstatus</span><span class="p">)</span> <span class="o">+</span>\
			<span class="p">(</span><span class="n">scr</span> <span class="o">*</span> <span class="mi">4</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">core_scr_write</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">scr</span><span class="p">,</span> <span class="n">u32</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">out_le32</span><span class="p">((</span><span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="p">)(</span><span class="n">host_pvt</span><span class="p">.</span><span class="n">scr_addr_sstatus</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">scr</span> <span class="o">*</span> <span class="mi">4</span><span class="p">),</span>
		<span class="n">val</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">clear_serror</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">val</span><span class="p">;</span>
	<span class="n">val</span> <span class="o">=</span> <span class="n">core_scr_read</span><span class="p">(</span><span class="n">SCR_ERROR</span><span class="p">);</span>
	<span class="n">core_scr_write</span><span class="p">(</span><span class="n">SCR_ERROR</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>

<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">clear_interrupt_bit</span><span class="p">(</span><span class="k">struct</span> <span class="n">sata_dwc_device</span> <span class="o">*</span><span class="n">hsdev</span><span class="p">,</span> <span class="n">u32</span> <span class="n">bit</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">out_le32</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hsdev</span><span class="o">-&gt;</span><span class="n">sata_dwc_regs</span><span class="o">-&gt;</span><span class="n">intpr</span><span class="p">,</span>
		 <span class="n">in_le32</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hsdev</span><span class="o">-&gt;</span><span class="n">sata_dwc_regs</span><span class="o">-&gt;</span><span class="n">intpr</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">u32</span> <span class="nf">qcmd_tag_to_mask</span><span class="p">(</span><span class="n">u8</span> <span class="n">tag</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="mh">0x00000001</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">tag</span> <span class="o">&amp;</span> <span class="mh">0x1f</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* See ahci.c */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">sata_dwc_error_intr</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">sata_dwc_device</span> <span class="o">*</span><span class="n">hsdev</span><span class="p">,</span> <span class="n">uint</span> <span class="n">intpr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sata_dwc_device_port</span> <span class="o">*</span><span class="n">hsdevp</span> <span class="o">=</span> <span class="n">HSDEVP_FROM_AP</span><span class="p">(</span><span class="n">ap</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">ata_eh_info</span> <span class="o">*</span><span class="n">ehi</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">link</span><span class="p">.</span><span class="n">eh_info</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">err_mask</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">action</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ata_queued_cmd</span> <span class="o">*</span><span class="n">qc</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">serror</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">status</span><span class="p">,</span> <span class="n">tag</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">err_reg</span><span class="p">;</span>

	<span class="n">ata_ehi_clear_desc</span><span class="p">(</span><span class="n">ehi</span><span class="p">);</span>

	<span class="n">serror</span> <span class="o">=</span> <span class="n">core_scr_read</span><span class="p">(</span><span class="n">SCR_ERROR</span><span class="p">);</span>
	<span class="n">status</span> <span class="o">=</span> <span class="n">ap</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">sff_check_status</span><span class="p">(</span><span class="n">ap</span><span class="p">);</span>

	<span class="n">err_reg</span> <span class="o">=</span> <span class="n">in_le32</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">host_pvt</span><span class="p">.</span><span class="n">sata_dma_regs</span><span class="o">-&gt;</span><span class="n">interrupt_status</span><span class="p">.</span><span class="n">error</span><span class="p">.</span>\
			<span class="n">low</span><span class="p">));</span>
	<span class="n">tag</span> <span class="o">=</span> <span class="n">ap</span><span class="o">-&gt;</span><span class="n">link</span><span class="p">.</span><span class="n">active_tag</span><span class="p">;</span>

	<span class="n">dev_err</span><span class="p">(</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s SCR_ERROR=0x%08x intpr=0x%08x status=0x%08x &quot;</span>
		<span class="s">&quot;dma_intp=%d pending=%d issued=%d dma_err_status=0x%08x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">__func__</span><span class="p">,</span> <span class="n">serror</span><span class="p">,</span> <span class="n">intpr</span><span class="p">,</span> <span class="n">status</span><span class="p">,</span> <span class="n">host_pvt</span><span class="p">.</span><span class="n">dma_interrupt_count</span><span class="p">,</span>
		<span class="n">hsdevp</span><span class="o">-&gt;</span><span class="n">dma_pending</span><span class="p">[</span><span class="n">tag</span><span class="p">],</span> <span class="n">hsdevp</span><span class="o">-&gt;</span><span class="n">cmd_issued</span><span class="p">[</span><span class="n">tag</span><span class="p">],</span> <span class="n">err_reg</span><span class="p">);</span>

	<span class="cm">/* Clear error register and interrupt bit */</span>
	<span class="n">clear_serror</span><span class="p">();</span>
	<span class="n">clear_interrupt_bit</span><span class="p">(</span><span class="n">hsdev</span><span class="p">,</span> <span class="n">SATA_DWC_INTPR_ERR</span><span class="p">);</span>

	<span class="cm">/* This is the only error happening now.  TODO check for exact error */</span>

	<span class="n">err_mask</span> <span class="o">|=</span> <span class="n">AC_ERR_HOST_BUS</span><span class="p">;</span>
	<span class="n">action</span> <span class="o">|=</span> <span class="n">ATA_EH_RESET</span><span class="p">;</span>

	<span class="cm">/* Pass this on to EH */</span>
	<span class="n">ehi</span><span class="o">-&gt;</span><span class="n">serror</span> <span class="o">|=</span> <span class="n">serror</span><span class="p">;</span>
	<span class="n">ehi</span><span class="o">-&gt;</span><span class="n">action</span> <span class="o">|=</span> <span class="n">action</span><span class="p">;</span>

	<span class="n">qc</span> <span class="o">=</span> <span class="n">ata_qc_from_tag</span><span class="p">(</span><span class="n">ap</span><span class="p">,</span> <span class="n">tag</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">qc</span><span class="p">)</span>
		<span class="n">qc</span><span class="o">-&gt;</span><span class="n">err_mask</span> <span class="o">|=</span> <span class="n">err_mask</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">ehi</span><span class="o">-&gt;</span><span class="n">err_mask</span> <span class="o">|=</span> <span class="n">err_mask</span><span class="p">;</span>

	<span class="n">ata_port_abort</span><span class="p">(</span><span class="n">ap</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Function : sata_dwc_isr</span>
<span class="cm"> * arguments : irq, void *dev_instance, struct pt_regs *regs</span>
<span class="cm"> * Return value : irqreturn_t - status of IRQ</span>
<span class="cm"> * This Interrupt handler called via port ops registered function.</span>
<span class="cm"> * .irq_handler = sata_dwc_isr</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">irqreturn_t</span> <span class="nf">sata_dwc_isr</span><span class="p">(</span><span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">dev_instance</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ata_host</span> <span class="o">*</span><span class="n">host</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">ata_host</span> <span class="o">*</span><span class="p">)</span><span class="n">dev_instance</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sata_dwc_device</span> <span class="o">*</span><span class="n">hsdev</span> <span class="o">=</span> <span class="n">HSDEV_FROM_HOST</span><span class="p">(</span><span class="n">host</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ata_queued_cmd</span> <span class="o">*</span><span class="n">qc</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">status</span><span class="p">,</span> <span class="n">tag</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">handled</span><span class="p">,</span> <span class="n">num_processed</span><span class="p">,</span> <span class="n">port</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">uint</span> <span class="n">intpr</span><span class="p">,</span> <span class="n">sactive</span><span class="p">,</span> <span class="n">sactive2</span><span class="p">,</span> <span class="n">tag_mask</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sata_dwc_device_port</span> <span class="o">*</span><span class="n">hsdevp</span><span class="p">;</span>
	<span class="n">host_pvt</span><span class="p">.</span><span class="n">sata_dwc_sactive_issued</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="cm">/* Read the interrupt register */</span>
	<span class="n">intpr</span> <span class="o">=</span> <span class="n">in_le32</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hsdev</span><span class="o">-&gt;</span><span class="n">sata_dwc_regs</span><span class="o">-&gt;</span><span class="n">intpr</span><span class="p">);</span>

	<span class="n">ap</span> <span class="o">=</span> <span class="n">host</span><span class="o">-&gt;</span><span class="n">ports</span><span class="p">[</span><span class="n">port</span><span class="p">];</span>
	<span class="n">hsdevp</span> <span class="o">=</span> <span class="n">HSDEVP_FROM_AP</span><span class="p">(</span><span class="n">ap</span><span class="p">);</span>

	<span class="n">dev_dbg</span><span class="p">(</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s intpr=0x%08x active_tag=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">intpr</span><span class="p">,</span>
		<span class="n">ap</span><span class="o">-&gt;</span><span class="n">link</span><span class="p">.</span><span class="n">active_tag</span><span class="p">);</span>

	<span class="cm">/* Check for error interrupt */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">intpr</span> <span class="o">&amp;</span> <span class="n">SATA_DWC_INTPR_ERR</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">sata_dwc_error_intr</span><span class="p">(</span><span class="n">ap</span><span class="p">,</span> <span class="n">hsdev</span><span class="p">,</span> <span class="n">intpr</span><span class="p">);</span>
		<span class="n">handled</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">DONE</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Check for DMA SETUP FIS (FP DMA) interrupt */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">intpr</span> <span class="o">&amp;</span> <span class="n">SATA_DWC_INTPR_NEWFP</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">clear_interrupt_bit</span><span class="p">(</span><span class="n">hsdev</span><span class="p">,</span> <span class="n">SATA_DWC_INTPR_NEWFP</span><span class="p">);</span>

		<span class="n">tag</span> <span class="o">=</span> <span class="p">(</span><span class="n">u8</span><span class="p">)(</span><span class="n">in_le32</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hsdev</span><span class="o">-&gt;</span><span class="n">sata_dwc_regs</span><span class="o">-&gt;</span><span class="n">fptagr</span><span class="p">));</span>
		<span class="n">dev_dbg</span><span class="p">(</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s: NEWFP tag=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">tag</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">hsdevp</span><span class="o">-&gt;</span><span class="n">cmd_issued</span><span class="p">[</span><span class="n">tag</span><span class="p">]</span> <span class="o">!=</span> <span class="n">SATA_DWC_CMD_ISSUED_PEND</span><span class="p">)</span>
			<span class="n">dev_warn</span><span class="p">(</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;CMD tag=%d not pending?</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">tag</span><span class="p">);</span>

		<span class="n">host_pvt</span><span class="p">.</span><span class="n">sata_dwc_sactive_issued</span> <span class="o">|=</span> <span class="n">qcmd_tag_to_mask</span><span class="p">(</span><span class="n">tag</span><span class="p">);</span>

		<span class="n">qc</span> <span class="o">=</span> <span class="n">ata_qc_from_tag</span><span class="p">(</span><span class="n">ap</span><span class="p">,</span> <span class="n">tag</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * Start FP DMA for NCQ command.  At this point the tag is the</span>
<span class="cm">		 * active tag.  It is the tag that matches the command about to</span>
<span class="cm">		 * be completed.</span>
<span class="cm">		 */</span>
		<span class="n">qc</span><span class="o">-&gt;</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">link</span><span class="p">.</span><span class="n">active_tag</span> <span class="o">=</span> <span class="n">tag</span><span class="p">;</span>
		<span class="n">sata_dwc_bmdma_start_by_tag</span><span class="p">(</span><span class="n">qc</span><span class="p">,</span> <span class="n">tag</span><span class="p">);</span>

		<span class="n">handled</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">DONE</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">sactive</span> <span class="o">=</span> <span class="n">core_scr_read</span><span class="p">(</span><span class="n">SCR_ACTIVE</span><span class="p">);</span>
	<span class="n">tag_mask</span> <span class="o">=</span> <span class="p">(</span><span class="n">host_pvt</span><span class="p">.</span><span class="n">sata_dwc_sactive_issued</span> <span class="o">|</span> <span class="n">sactive</span><span class="p">)</span> <span class="o">^</span> <span class="n">sactive</span><span class="p">;</span>

	<span class="cm">/* If no sactive issued and tag_mask is zero then this is not NCQ */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">host_pvt</span><span class="p">.</span><span class="n">sata_dwc_sactive_issued</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">tag_mask</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">link</span><span class="p">.</span><span class="n">active_tag</span> <span class="o">==</span> <span class="n">ATA_TAG_POISON</span><span class="p">)</span>
			<span class="n">tag</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">tag</span> <span class="o">=</span> <span class="n">ap</span><span class="o">-&gt;</span><span class="n">link</span><span class="p">.</span><span class="n">active_tag</span><span class="p">;</span>
		<span class="n">qc</span> <span class="o">=</span> <span class="n">ata_qc_from_tag</span><span class="p">(</span><span class="n">ap</span><span class="p">,</span> <span class="n">tag</span><span class="p">);</span>

		<span class="cm">/* DEV interrupt w/ no active qc? */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">qc</span> <span class="o">||</span> <span class="p">(</span><span class="n">qc</span><span class="o">-&gt;</span><span class="n">tf</span><span class="p">.</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">ATA_TFLAG_POLLING</span><span class="p">)))</span> <span class="p">{</span>
			<span class="n">dev_err</span><span class="p">(</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s interrupt with no active qc &quot;</span>
				<span class="s">&quot;qc=%p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">qc</span><span class="p">);</span>
			<span class="n">ap</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">sff_check_status</span><span class="p">(</span><span class="n">ap</span><span class="p">);</span>
			<span class="n">handled</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">DONE</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">ap</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">sff_check_status</span><span class="p">(</span><span class="n">ap</span><span class="p">);</span>

		<span class="n">qc</span><span class="o">-&gt;</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">link</span><span class="p">.</span><span class="n">active_tag</span> <span class="o">=</span> <span class="n">tag</span><span class="p">;</span>
		<span class="n">hsdevp</span><span class="o">-&gt;</span><span class="n">cmd_issued</span><span class="p">[</span><span class="n">tag</span><span class="p">]</span> <span class="o">=</span> <span class="n">SATA_DWC_CMD_ISSUED_NOT</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">ATA_ERR</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dev_dbg</span><span class="p">(</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;interrupt ATA_ERR (0x%x)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">status</span><span class="p">);</span>
			<span class="n">sata_dwc_qc_complete</span><span class="p">(</span><span class="n">ap</span><span class="p">,</span> <span class="n">qc</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
			<span class="n">handled</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">DONE</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">dev_dbg</span><span class="p">(</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s non-NCQ cmd interrupt, protocol: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">__func__</span><span class="p">,</span> <span class="n">get_prot_descript</span><span class="p">(</span><span class="n">qc</span><span class="o">-&gt;</span><span class="n">tf</span><span class="p">.</span><span class="n">protocol</span><span class="p">));</span>
<span class="nl">DRVSTILLBUSY:</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ata_is_dma</span><span class="p">(</span><span class="n">qc</span><span class="o">-&gt;</span><span class="n">tf</span><span class="p">.</span><span class="n">protocol</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * Each DMA transaction produces 2 interrupts. The DMAC</span>
<span class="cm">			 * transfer complete interrupt and the SATA controller</span>
<span class="cm">			 * operation done interrupt. The command should be</span>
<span class="cm">			 * completed only after both interrupts are seen.</span>
<span class="cm">			 */</span>
			<span class="n">host_pvt</span><span class="p">.</span><span class="n">dma_interrupt_count</span><span class="o">++</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">hsdevp</span><span class="o">-&gt;</span><span class="n">dma_pending</span><span class="p">[</span><span class="n">tag</span><span class="p">]</span> <span class="o">==</span> \
					<span class="n">SATA_DWC_DMA_PENDING_NONE</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">dev_err</span><span class="p">(</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s: DMA not pending &quot;</span>
					<span class="s">&quot;intpr=0x%08x status=0x%08x pending&quot;</span>
					<span class="s">&quot;=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">intpr</span><span class="p">,</span> <span class="n">status</span><span class="p">,</span>
					<span class="n">hsdevp</span><span class="o">-&gt;</span><span class="n">dma_pending</span><span class="p">[</span><span class="n">tag</span><span class="p">]);</span>
			<span class="p">}</span>

			<span class="k">if</span> <span class="p">((</span><span class="n">host_pvt</span><span class="p">.</span><span class="n">dma_interrupt_count</span> <span class="o">%</span> <span class="mi">2</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
				<span class="n">sata_dwc_dma_xfer_complete</span><span class="p">(</span><span class="n">ap</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">ata_is_pio</span><span class="p">(</span><span class="n">qc</span><span class="o">-&gt;</span><span class="n">tf</span><span class="p">.</span><span class="n">protocol</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">ata_sff_hsm_move</span><span class="p">(</span><span class="n">ap</span><span class="p">,</span> <span class="n">qc</span><span class="p">,</span> <span class="n">status</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
			<span class="n">handled</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">DONE</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">sata_dwc_qc_complete</span><span class="p">(</span><span class="n">ap</span><span class="p">,</span> <span class="n">qc</span><span class="p">,</span> <span class="mi">1</span><span class="p">)))</span>
				<span class="k">goto</span> <span class="n">DRVSTILLBUSY</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">handled</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">DONE</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * This is a NCQ command. At this point we need to figure out for which</span>
<span class="cm">	 * tags we have gotten a completion interrupt.  One interrupt may serve</span>
<span class="cm">	 * as completion for more than one operation when commands are queued</span>
<span class="cm">	 * (NCQ).  We need to process each completed command.</span>
<span class="cm">	 */</span>

	 <span class="cm">/* process completed commands */</span>
	<span class="n">sactive</span> <span class="o">=</span> <span class="n">core_scr_read</span><span class="p">(</span><span class="n">SCR_ACTIVE</span><span class="p">);</span>
	<span class="n">tag_mask</span> <span class="o">=</span> <span class="p">(</span><span class="n">host_pvt</span><span class="p">.</span><span class="n">sata_dwc_sactive_issued</span> <span class="o">|</span> <span class="n">sactive</span><span class="p">)</span> <span class="o">^</span> <span class="n">sactive</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sactive</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">||</span> <span class="p">(</span><span class="n">host_pvt</span><span class="p">.</span><span class="n">sata_dwc_sactive_issued</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="o">||</span> \
							<span class="n">tag_mask</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_dbg</span><span class="p">(</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s NCQ:sactive=0x%08x  sactive_issued=0x%08x&quot;</span>
			<span class="s">&quot;tag_mask=0x%08x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">sactive</span><span class="p">,</span>
			<span class="n">host_pvt</span><span class="p">.</span><span class="n">sata_dwc_sactive_issued</span><span class="p">,</span> <span class="n">tag_mask</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">tag_mask</span> <span class="o">|</span> <span class="p">(</span><span class="n">host_pvt</span><span class="p">.</span><span class="n">sata_dwc_sactive_issued</span><span class="p">))</span> <span class="o">!=</span> \
					<span class="p">(</span><span class="n">host_pvt</span><span class="p">.</span><span class="n">sata_dwc_sactive_issued</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dev_warn</span><span class="p">(</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;Bad tag mask?  sactive=0x%08x &quot;</span>
			 <span class="s">&quot;(host_pvt.sata_dwc_sactive_issued)=0x%08x  tag_mask&quot;</span>
			 <span class="s">&quot;=0x%08x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">sactive</span><span class="p">,</span> <span class="n">host_pvt</span><span class="p">.</span><span class="n">sata_dwc_sactive_issued</span><span class="p">,</span>
			  <span class="n">tag_mask</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* read just to clear ... not bad if currently still busy */</span>
	<span class="n">status</span> <span class="o">=</span> <span class="n">ap</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">sff_check_status</span><span class="p">(</span><span class="n">ap</span><span class="p">);</span>
	<span class="n">dev_dbg</span><span class="p">(</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s ATA status register=0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">status</span><span class="p">);</span>

	<span class="n">tag</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">num_processed</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">tag_mask</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">num_processed</span><span class="o">++</span><span class="p">;</span>
		<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">tag_mask</span> <span class="o">&amp;</span> <span class="mh">0x00000001</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">tag</span><span class="o">++</span><span class="p">;</span>
			<span class="n">tag_mask</span> <span class="o">&lt;&lt;=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">tag_mask</span> <span class="o">&amp;=</span> <span class="p">(</span><span class="o">~</span><span class="mh">0x00000001</span><span class="p">);</span>
		<span class="n">qc</span> <span class="o">=</span> <span class="n">ata_qc_from_tag</span><span class="p">(</span><span class="n">ap</span><span class="p">,</span> <span class="n">tag</span><span class="p">);</span>

		<span class="cm">/* To be picked up by completion functions */</span>
		<span class="n">qc</span><span class="o">-&gt;</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">link</span><span class="p">.</span><span class="n">active_tag</span> <span class="o">=</span> <span class="n">tag</span><span class="p">;</span>
		<span class="n">hsdevp</span><span class="o">-&gt;</span><span class="n">cmd_issued</span><span class="p">[</span><span class="n">tag</span><span class="p">]</span> <span class="o">=</span> <span class="n">SATA_DWC_CMD_ISSUED_NOT</span><span class="p">;</span>

		<span class="cm">/* Let libata/scsi layers handle error */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">ATA_ERR</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dev_dbg</span><span class="p">(</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s ATA_ERR (0x%x)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span>
				<span class="n">status</span><span class="p">);</span>
			<span class="n">sata_dwc_qc_complete</span><span class="p">(</span><span class="n">ap</span><span class="p">,</span> <span class="n">qc</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
			<span class="n">handled</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">DONE</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* Process completed command */</span>
		<span class="n">dev_dbg</span><span class="p">(</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s NCQ command, protocol: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span>
			<span class="n">get_prot_descript</span><span class="p">(</span><span class="n">qc</span><span class="o">-&gt;</span><span class="n">tf</span><span class="p">.</span><span class="n">protocol</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ata_is_dma</span><span class="p">(</span><span class="n">qc</span><span class="o">-&gt;</span><span class="n">tf</span><span class="p">.</span><span class="n">protocol</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">host_pvt</span><span class="p">.</span><span class="n">dma_interrupt_count</span><span class="o">++</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">hsdevp</span><span class="o">-&gt;</span><span class="n">dma_pending</span><span class="p">[</span><span class="n">tag</span><span class="p">]</span> <span class="o">==</span> \
					<span class="n">SATA_DWC_DMA_PENDING_NONE</span><span class="p">)</span>
				<span class="n">dev_warn</span><span class="p">(</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s: DMA not pending?</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">__func__</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">host_pvt</span><span class="p">.</span><span class="n">dma_interrupt_count</span> <span class="o">%</span> <span class="mi">2</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
				<span class="n">sata_dwc_dma_xfer_complete</span><span class="p">(</span><span class="n">ap</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">sata_dwc_qc_complete</span><span class="p">(</span><span class="n">ap</span><span class="p">,</span> <span class="n">qc</span><span class="p">,</span> <span class="mi">1</span><span class="p">)))</span>
				<span class="k">goto</span> <span class="n">STILLBUSY</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">continue</span><span class="p">;</span>

<span class="nl">STILLBUSY:</span>
		<span class="n">ap</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">idle_irq</span><span class="o">++</span><span class="p">;</span>
		<span class="n">dev_warn</span><span class="p">(</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;STILL BUSY IRQ ata%d: irq trap</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">ap</span><span class="o">-&gt;</span><span class="n">print_id</span><span class="p">);</span>
	<span class="p">}</span> <span class="cm">/* while tag_mask */</span>

	<span class="cm">/*</span>
<span class="cm">	 * Check to see if any commands completed while we were processing our</span>
<span class="cm">	 * initial set of completed commands (read status clears interrupts,</span>
<span class="cm">	 * so we might miss a completed command interrupt if one came in while</span>
<span class="cm">	 * we were processing --we read status as part of processing a completed</span>
<span class="cm">	 * command).</span>
<span class="cm">	 */</span>
	<span class="n">sactive2</span> <span class="o">=</span> <span class="n">core_scr_read</span><span class="p">(</span><span class="n">SCR_ACTIVE</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sactive2</span> <span class="o">!=</span> <span class="n">sactive</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_dbg</span><span class="p">(</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;More completed - sactive=0x%x sactive2&quot;</span>
			<span class="s">&quot;=0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">sactive</span><span class="p">,</span> <span class="n">sactive2</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">handled</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

<span class="nl">DONE:</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">IRQ_RETVAL</span><span class="p">(</span><span class="n">handled</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">sata_dwc_clear_dmacr</span><span class="p">(</span><span class="k">struct</span> <span class="n">sata_dwc_device_port</span> <span class="o">*</span><span class="n">hsdevp</span><span class="p">,</span> <span class="n">u8</span> <span class="n">tag</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sata_dwc_device</span> <span class="o">*</span><span class="n">hsdev</span> <span class="o">=</span> <span class="n">HSDEV_FROM_HSDEVP</span><span class="p">(</span><span class="n">hsdevp</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">hsdevp</span><span class="o">-&gt;</span><span class="n">dma_pending</span><span class="p">[</span><span class="n">tag</span><span class="p">]</span> <span class="o">==</span> <span class="n">SATA_DWC_DMA_PENDING_RX</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">out_le32</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">hsdev</span><span class="o">-&gt;</span><span class="n">sata_dwc_regs</span><span class="o">-&gt;</span><span class="n">dmacr</span><span class="p">),</span>
			 <span class="n">SATA_DWC_DMACR_RX_CLEAR</span><span class="p">(</span>
				 <span class="n">in_le32</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">hsdev</span><span class="o">-&gt;</span><span class="n">sata_dwc_regs</span><span class="o">-&gt;</span><span class="n">dmacr</span><span class="p">))));</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">hsdevp</span><span class="o">-&gt;</span><span class="n">dma_pending</span><span class="p">[</span><span class="n">tag</span><span class="p">]</span> <span class="o">==</span> <span class="n">SATA_DWC_DMA_PENDING_TX</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">out_le32</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">hsdev</span><span class="o">-&gt;</span><span class="n">sata_dwc_regs</span><span class="o">-&gt;</span><span class="n">dmacr</span><span class="p">),</span>
			 <span class="n">SATA_DWC_DMACR_TX_CLEAR</span><span class="p">(</span>
				 <span class="n">in_le32</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">hsdev</span><span class="o">-&gt;</span><span class="n">sata_dwc_regs</span><span class="o">-&gt;</span><span class="n">dmacr</span><span class="p">))));</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * This should not happen, it indicates the driver is out of</span>
<span class="cm">		 * sync.  If it does happen, clear dmacr anyway.</span>
<span class="cm">		 */</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">host_pvt</span><span class="p">.</span><span class="n">dwc_dev</span><span class="p">,</span> <span class="s">&quot;%s DMA protocol RX and&quot;</span>
			<span class="s">&quot;TX DMA not pending tag=0x%02x pending=%d&quot;</span>
			<span class="s">&quot; dmacr: 0x%08x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">tag</span><span class="p">,</span>
			<span class="n">hsdevp</span><span class="o">-&gt;</span><span class="n">dma_pending</span><span class="p">[</span><span class="n">tag</span><span class="p">],</span>
			<span class="n">in_le32</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">hsdev</span><span class="o">-&gt;</span><span class="n">sata_dwc_regs</span><span class="o">-&gt;</span><span class="n">dmacr</span><span class="p">)));</span>
		<span class="n">out_le32</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">hsdev</span><span class="o">-&gt;</span><span class="n">sata_dwc_regs</span><span class="o">-&gt;</span><span class="n">dmacr</span><span class="p">),</span>
			<span class="n">SATA_DWC_DMACR_TXRXCH_CLEAR</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">sata_dwc_dma_xfer_complete</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span><span class="p">,</span> <span class="n">u32</span> <span class="n">check_status</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ata_queued_cmd</span> <span class="o">*</span><span class="n">qc</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sata_dwc_device_port</span> <span class="o">*</span><span class="n">hsdevp</span> <span class="o">=</span> <span class="n">HSDEVP_FROM_AP</span><span class="p">(</span><span class="n">ap</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">sata_dwc_device</span> <span class="o">*</span><span class="n">hsdev</span> <span class="o">=</span> <span class="n">HSDEV_FROM_AP</span><span class="p">(</span><span class="n">ap</span><span class="p">);</span>
	<span class="n">u8</span> <span class="n">tag</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">tag</span> <span class="o">=</span> <span class="n">ap</span><span class="o">-&gt;</span><span class="n">link</span><span class="p">.</span><span class="n">active_tag</span><span class="p">;</span>
	<span class="n">qc</span> <span class="o">=</span> <span class="n">ata_qc_from_tag</span><span class="p">(</span><span class="n">ap</span><span class="p">,</span> <span class="n">tag</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">qc</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;failed to get qc&quot;</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

<span class="cp">#ifdef DEBUG_NCQ</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tag</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_info</span><span class="p">(</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s tag=%u cmd=0x%02x dma dir=%s proto=%s &quot;</span>
			 <span class="s">&quot;dmacr=0x%08x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">qc</span><span class="o">-&gt;</span><span class="n">tag</span><span class="p">,</span> <span class="n">qc</span><span class="o">-&gt;</span><span class="n">tf</span><span class="p">.</span><span class="n">command</span><span class="p">,</span>
			 <span class="n">get_dma_dir_descript</span><span class="p">(</span><span class="n">qc</span><span class="o">-&gt;</span><span class="n">dma_dir</span><span class="p">),</span>
			 <span class="n">get_prot_descript</span><span class="p">(</span><span class="n">qc</span><span class="o">-&gt;</span><span class="n">tf</span><span class="p">.</span><span class="n">protocol</span><span class="p">),</span>
			 <span class="n">in_le32</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">hsdev</span><span class="o">-&gt;</span><span class="n">sata_dwc_regs</span><span class="o">-&gt;</span><span class="n">dmacr</span><span class="p">)));</span>
	<span class="p">}</span>
<span class="cp">#endif</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ata_is_dma</span><span class="p">(</span><span class="n">qc</span><span class="o">-&gt;</span><span class="n">tf</span><span class="p">.</span><span class="n">protocol</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">hsdevp</span><span class="o">-&gt;</span><span class="n">dma_pending</span><span class="p">[</span><span class="n">tag</span><span class="p">]</span> <span class="o">==</span> <span class="n">SATA_DWC_DMA_PENDING_NONE</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dev_err</span><span class="p">(</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s DMA protocol RX and TX DMA not &quot;</span>
				<span class="s">&quot;pending dmacr: 0x%08x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span>
				<span class="n">in_le32</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">hsdev</span><span class="o">-&gt;</span><span class="n">sata_dwc_regs</span><span class="o">-&gt;</span><span class="n">dmacr</span><span class="p">)));</span>
		<span class="p">}</span>

		<span class="n">hsdevp</span><span class="o">-&gt;</span><span class="n">dma_pending</span><span class="p">[</span><span class="n">tag</span><span class="p">]</span> <span class="o">=</span> <span class="n">SATA_DWC_DMA_PENDING_NONE</span><span class="p">;</span>
		<span class="n">sata_dwc_qc_complete</span><span class="p">(</span><span class="n">ap</span><span class="p">,</span> <span class="n">qc</span><span class="p">,</span> <span class="n">check_status</span><span class="p">);</span>
		<span class="n">ap</span><span class="o">-&gt;</span><span class="n">link</span><span class="p">.</span><span class="n">active_tag</span> <span class="o">=</span> <span class="n">ATA_TAG_POISON</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">sata_dwc_qc_complete</span><span class="p">(</span><span class="n">ap</span><span class="p">,</span> <span class="n">qc</span><span class="p">,</span> <span class="n">check_status</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">sata_dwc_qc_complete</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ata_queued_cmd</span> <span class="o">*</span><span class="n">qc</span><span class="p">,</span>
				<span class="n">u32</span> <span class="n">check_status</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u8</span> <span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">mask</span> <span class="o">=</span> <span class="mh">0x0</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">tag</span> <span class="o">=</span> <span class="n">qc</span><span class="o">-&gt;</span><span class="n">tag</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sata_dwc_device_port</span> <span class="o">*</span><span class="n">hsdevp</span> <span class="o">=</span> <span class="n">HSDEVP_FROM_AP</span><span class="p">(</span><span class="n">ap</span><span class="p">);</span>
	<span class="n">host_pvt</span><span class="p">.</span><span class="n">sata_dwc_sactive_queued</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">dev_dbg</span><span class="p">(</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s checkstatus? %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">check_status</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">hsdevp</span><span class="o">-&gt;</span><span class="n">dma_pending</span><span class="p">[</span><span class="n">tag</span><span class="p">]</span> <span class="o">==</span> <span class="n">SATA_DWC_DMA_PENDING_TX</span><span class="p">)</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;TX DMA PENDING</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">hsdevp</span><span class="o">-&gt;</span><span class="n">dma_pending</span><span class="p">[</span><span class="n">tag</span><span class="p">]</span> <span class="o">==</span> <span class="n">SATA_DWC_DMA_PENDING_RX</span><span class="p">)</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;RX DMA PENDING</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">dev_dbg</span><span class="p">(</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;QC complete cmd=0x%02x status=0x%02x ata%u:&quot;</span>
		<span class="s">&quot; protocol=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">qc</span><span class="o">-&gt;</span><span class="n">tf</span><span class="p">.</span><span class="n">command</span><span class="p">,</span> <span class="n">status</span><span class="p">,</span> <span class="n">ap</span><span class="o">-&gt;</span><span class="n">print_id</span><span class="p">,</span>
		 <span class="n">qc</span><span class="o">-&gt;</span><span class="n">tf</span><span class="p">.</span><span class="n">protocol</span><span class="p">);</span>

	<span class="cm">/* clear active bit */</span>
	<span class="n">mask</span> <span class="o">=</span> <span class="p">(</span><span class="o">~</span><span class="p">(</span><span class="n">qcmd_tag_to_mask</span><span class="p">(</span><span class="n">tag</span><span class="p">)));</span>
	<span class="n">host_pvt</span><span class="p">.</span><span class="n">sata_dwc_sactive_queued</span> <span class="o">=</span> <span class="p">(</span><span class="n">host_pvt</span><span class="p">.</span><span class="n">sata_dwc_sactive_queued</span><span class="p">)</span> \
						<span class="o">&amp;</span> <span class="n">mask</span><span class="p">;</span>
	<span class="n">host_pvt</span><span class="p">.</span><span class="n">sata_dwc_sactive_issued</span> <span class="o">=</span> <span class="p">(</span><span class="n">host_pvt</span><span class="p">.</span><span class="n">sata_dwc_sactive_issued</span><span class="p">)</span> \
						<span class="o">&amp;</span> <span class="n">mask</span><span class="p">;</span>
	<span class="n">ata_qc_complete</span><span class="p">(</span><span class="n">qc</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">sata_dwc_enable_interrupts</span><span class="p">(</span><span class="k">struct</span> <span class="n">sata_dwc_device</span> <span class="o">*</span><span class="n">hsdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Enable selective interrupts by setting the interrupt maskregister*/</span>
	<span class="n">out_le32</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hsdev</span><span class="o">-&gt;</span><span class="n">sata_dwc_regs</span><span class="o">-&gt;</span><span class="n">intmr</span><span class="p">,</span>
		 <span class="n">SATA_DWC_INTMR_ERRM</span> <span class="o">|</span>
		 <span class="n">SATA_DWC_INTMR_NEWFPM</span> <span class="o">|</span>
		 <span class="n">SATA_DWC_INTMR_PMABRTM</span> <span class="o">|</span>
		 <span class="n">SATA_DWC_INTMR_DMATM</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * Unmask the error bits that should trigger an error interrupt by</span>
<span class="cm">	 * setting the error mask register.</span>
<span class="cm">	 */</span>
	<span class="n">out_le32</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hsdev</span><span class="o">-&gt;</span><span class="n">sata_dwc_regs</span><span class="o">-&gt;</span><span class="n">errmr</span><span class="p">,</span> <span class="n">SATA_DWC_SERROR_ERR_BITS</span><span class="p">);</span>

	<span class="n">dev_dbg</span><span class="p">(</span><span class="n">host_pvt</span><span class="p">.</span><span class="n">dwc_dev</span><span class="p">,</span> <span class="s">&quot;%s: INTMR = 0x%08x, ERRMR = 0x%08x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		 <span class="n">__func__</span><span class="p">,</span> <span class="n">in_le32</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hsdev</span><span class="o">-&gt;</span><span class="n">sata_dwc_regs</span><span class="o">-&gt;</span><span class="n">intmr</span><span class="p">),</span>
		<span class="n">in_le32</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hsdev</span><span class="o">-&gt;</span><span class="n">sata_dwc_regs</span><span class="o">-&gt;</span><span class="n">errmr</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">sata_dwc_setup_port</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_ioports</span> <span class="o">*</span><span class="n">port</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">base</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">port</span><span class="o">-&gt;</span><span class="n">cmd_addr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">base</span> <span class="o">+</span> <span class="mh">0x00</span><span class="p">;</span>
	<span class="n">port</span><span class="o">-&gt;</span><span class="n">data_addr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">base</span> <span class="o">+</span> <span class="mh">0x00</span><span class="p">;</span>

	<span class="n">port</span><span class="o">-&gt;</span><span class="n">error_addr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">base</span> <span class="o">+</span> <span class="mh">0x04</span><span class="p">;</span>
	<span class="n">port</span><span class="o">-&gt;</span><span class="n">feature_addr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">base</span> <span class="o">+</span> <span class="mh">0x04</span><span class="p">;</span>

	<span class="n">port</span><span class="o">-&gt;</span><span class="n">nsect_addr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">base</span> <span class="o">+</span> <span class="mh">0x08</span><span class="p">;</span>

	<span class="n">port</span><span class="o">-&gt;</span><span class="n">lbal_addr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">base</span> <span class="o">+</span> <span class="mh">0x0c</span><span class="p">;</span>
	<span class="n">port</span><span class="o">-&gt;</span><span class="n">lbam_addr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">base</span> <span class="o">+</span> <span class="mh">0x10</span><span class="p">;</span>
	<span class="n">port</span><span class="o">-&gt;</span><span class="n">lbah_addr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">base</span> <span class="o">+</span> <span class="mh">0x14</span><span class="p">;</span>

	<span class="n">port</span><span class="o">-&gt;</span><span class="n">device_addr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">base</span> <span class="o">+</span> <span class="mh">0x18</span><span class="p">;</span>
	<span class="n">port</span><span class="o">-&gt;</span><span class="n">command_addr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">base</span> <span class="o">+</span> <span class="mh">0x1c</span><span class="p">;</span>
	<span class="n">port</span><span class="o">-&gt;</span><span class="n">status_addr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">base</span> <span class="o">+</span> <span class="mh">0x1c</span><span class="p">;</span>

	<span class="n">port</span><span class="o">-&gt;</span><span class="n">altstatus_addr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">base</span> <span class="o">+</span> <span class="mh">0x20</span><span class="p">;</span>
	<span class="n">port</span><span class="o">-&gt;</span><span class="n">ctl_addr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">base</span> <span class="o">+</span> <span class="mh">0x20</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Function : sata_dwc_port_start</span>
<span class="cm"> * arguments : struct ata_ioports *port</span>
<span class="cm"> * Return value : returns 0 if success, error code otherwise</span>
<span class="cm"> * This function allocates the scatter gather LLI table for AHB DMA</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">sata_dwc_port_start</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sata_dwc_device</span> <span class="o">*</span><span class="n">hsdev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sata_dwc_device_port</span> <span class="o">*</span><span class="n">hsdevp</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">pdev</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">hsdev</span> <span class="o">=</span> <span class="n">HSDEV_FROM_AP</span><span class="p">(</span><span class="n">ap</span><span class="p">);</span>

	<span class="n">dev_dbg</span><span class="p">(</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s: port_no=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">ap</span><span class="o">-&gt;</span><span class="n">port_no</span><span class="p">);</span>

	<span class="n">hsdev</span><span class="o">-&gt;</span><span class="n">host</span> <span class="o">=</span> <span class="n">ap</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">;</span>
	<span class="n">pdev</span> <span class="o">=</span> <span class="n">ap</span><span class="o">-&gt;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pdev</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s: no ap-&gt;host-&gt;dev</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">CLEANUP</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Allocate Port Struct */</span>
	<span class="n">hsdevp</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">hsdevp</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hsdevp</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s: kmalloc failed for hsdevp</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">CLEANUP</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">hsdevp</span><span class="o">-&gt;</span><span class="n">hsdev</span> <span class="o">=</span> <span class="n">hsdev</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">SATA_DWC_QCMD_MAX</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">hsdevp</span><span class="o">-&gt;</span><span class="n">cmd_issued</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">SATA_DWC_CMD_ISSUED_NOT</span><span class="p">;</span>

	<span class="n">ap</span><span class="o">-&gt;</span><span class="n">bmdma_prd</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>	<span class="cm">/* set these so libata doesn&#39;t use them */</span>
	<span class="n">ap</span><span class="o">-&gt;</span><span class="n">bmdma_prd_dma</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * DMA - Assign scatter gather LLI table. We can&#39;t use the libata</span>
<span class="cm">	 * version since it&#39;s PRD is IDE PCI specific.</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">SATA_DWC_QCMD_MAX</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">hsdevp</span><span class="o">-&gt;</span><span class="n">llit</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">dma_alloc_coherent</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span>
						     <span class="n">SATA_DWC_DMAC_LLI_TBL_SZ</span><span class="p">,</span>
						     <span class="o">&amp;</span><span class="p">(</span><span class="n">hsdevp</span><span class="o">-&gt;</span><span class="n">llit_dma</span><span class="p">[</span><span class="n">i</span><span class="p">]),</span>
						     <span class="n">GFP_ATOMIC</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hsdevp</span><span class="o">-&gt;</span><span class="n">llit</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">{</span>
			<span class="n">dev_err</span><span class="p">(</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s: dma_alloc_coherent failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				 <span class="n">__func__</span><span class="p">);</span>
			<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">CLEANUP_ALLOC</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">port_no</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>  <span class="p">{</span>
		<span class="n">dev_dbg</span><span class="p">(</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s: clearing TXCHEN, RXCHEN in DMAC</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">__func__</span><span class="p">);</span>
		<span class="n">out_le32</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hsdev</span><span class="o">-&gt;</span><span class="n">sata_dwc_regs</span><span class="o">-&gt;</span><span class="n">dmacr</span><span class="p">,</span>
			 <span class="n">SATA_DWC_DMACR_TXRXCH_CLEAR</span><span class="p">);</span>

		<span class="n">dev_dbg</span><span class="p">(</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s: setting burst size in DBTSR</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			 <span class="n">__func__</span><span class="p">);</span>
		<span class="n">out_le32</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hsdev</span><span class="o">-&gt;</span><span class="n">sata_dwc_regs</span><span class="o">-&gt;</span><span class="n">dbtsr</span><span class="p">,</span>
			 <span class="p">(</span><span class="n">SATA_DWC_DBTSR_MWR</span><span class="p">(</span><span class="n">AHB_DMA_BRST_DFLT</span><span class="p">)</span> <span class="o">|</span>
			  <span class="n">SATA_DWC_DBTSR_MRD</span><span class="p">(</span><span class="n">AHB_DMA_BRST_DFLT</span><span class="p">)));</span>
	<span class="p">}</span>

	<span class="cm">/* Clear any error bits before libata starts issuing commands */</span>
	<span class="n">clear_serror</span><span class="p">();</span>
	<span class="n">ap</span><span class="o">-&gt;</span><span class="n">private_data</span> <span class="o">=</span> <span class="n">hsdevp</span><span class="p">;</span>
	<span class="n">dev_dbg</span><span class="p">(</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s: done</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">CLEANUP_ALLOC:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">hsdevp</span><span class="p">);</span>
<span class="nl">CLEANUP:</span>
	<span class="n">dev_dbg</span><span class="p">(</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s: fail. ap-&gt;id = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">ap</span><span class="o">-&gt;</span><span class="n">print_id</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">sata_dwc_port_stop</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sata_dwc_device</span> <span class="o">*</span><span class="n">hsdev</span> <span class="o">=</span> <span class="n">HSDEV_FROM_AP</span><span class="p">(</span><span class="n">ap</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">sata_dwc_device_port</span> <span class="o">*</span><span class="n">hsdevp</span> <span class="o">=</span> <span class="n">HSDEVP_FROM_AP</span><span class="p">(</span><span class="n">ap</span><span class="p">);</span>

	<span class="n">dev_dbg</span><span class="p">(</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s: ap-&gt;id = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">ap</span><span class="o">-&gt;</span><span class="n">print_id</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">hsdevp</span> <span class="o">&amp;&amp;</span> <span class="n">hsdev</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* deallocate LLI table */</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">SATA_DWC_QCMD_MAX</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dma_free_coherent</span><span class="p">(</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
					  <span class="n">SATA_DWC_DMAC_LLI_TBL_SZ</span><span class="p">,</span>
					 <span class="n">hsdevp</span><span class="o">-&gt;</span><span class="n">llit</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">hsdevp</span><span class="o">-&gt;</span><span class="n">llit_dma</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
		<span class="p">}</span>

		<span class="n">kfree</span><span class="p">(</span><span class="n">hsdevp</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">ap</span><span class="o">-&gt;</span><span class="n">private_data</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Function : sata_dwc_exec_command_by_tag</span>
<span class="cm"> * arguments : ata_port *ap, ata_taskfile *tf, u8 tag, u32 cmd_issued</span>
<span class="cm"> * Return value : None</span>
<span class="cm"> * This function keeps track of individual command tag ids and calls</span>
<span class="cm"> * ata_exec_command in libata</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">sata_dwc_exec_command_by_tag</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span><span class="p">,</span>
					 <span class="k">struct</span> <span class="n">ata_taskfile</span> <span class="o">*</span><span class="n">tf</span><span class="p">,</span>
					 <span class="n">u8</span> <span class="n">tag</span><span class="p">,</span> <span class="n">u32</span> <span class="n">cmd_issued</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sata_dwc_device_port</span> <span class="o">*</span><span class="n">hsdevp</span> <span class="o">=</span> <span class="n">HSDEVP_FROM_AP</span><span class="p">(</span><span class="n">ap</span><span class="p">);</span>

	<span class="n">dev_dbg</span><span class="p">(</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s cmd(0x%02x): %s tag=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">tf</span><span class="o">-&gt;</span><span class="n">command</span><span class="p">,</span>
		<span class="n">ata_get_cmd_descript</span><span class="p">(</span><span class="n">tf</span><span class="o">-&gt;</span><span class="n">command</span><span class="p">),</span> <span class="n">tag</span><span class="p">);</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">hsdevp</span><span class="o">-&gt;</span><span class="n">cmd_issued</span><span class="p">[</span><span class="n">tag</span><span class="p">]</span> <span class="o">=</span> <span class="n">cmd_issued</span><span class="p">;</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * Clear SError before executing a new command.</span>
<span class="cm">	 * sata_dwc_scr_write and read can not be used here. Clearing the PM</span>
<span class="cm">	 * managed SError register for the disk needs to be done before the</span>
<span class="cm">	 * task file is loaded.</span>
<span class="cm">	 */</span>
	<span class="n">clear_serror</span><span class="p">();</span>
	<span class="n">ata_sff_exec_command</span><span class="p">(</span><span class="n">ap</span><span class="p">,</span> <span class="n">tf</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">sata_dwc_bmdma_setup_by_tag</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_queued_cmd</span> <span class="o">*</span><span class="n">qc</span><span class="p">,</span> <span class="n">u8</span> <span class="n">tag</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">sata_dwc_exec_command_by_tag</span><span class="p">(</span><span class="n">qc</span><span class="o">-&gt;</span><span class="n">ap</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">qc</span><span class="o">-&gt;</span><span class="n">tf</span><span class="p">,</span> <span class="n">tag</span><span class="p">,</span>
				     <span class="n">SATA_DWC_CMD_ISSUED_PEND</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">sata_dwc_bmdma_setup</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_queued_cmd</span> <span class="o">*</span><span class="n">qc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u8</span> <span class="n">tag</span> <span class="o">=</span> <span class="n">qc</span><span class="o">-&gt;</span><span class="n">tag</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ata_is_ncq</span><span class="p">(</span><span class="n">qc</span><span class="o">-&gt;</span><span class="n">tf</span><span class="p">.</span><span class="n">protocol</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dev_dbg</span><span class="p">(</span><span class="n">qc</span><span class="o">-&gt;</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s: ap-&gt;link.sactive=0x%08x tag=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">__func__</span><span class="p">,</span> <span class="n">qc</span><span class="o">-&gt;</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">link</span><span class="p">.</span><span class="n">sactive</span><span class="p">,</span> <span class="n">tag</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">tag</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">sata_dwc_bmdma_setup_by_tag</span><span class="p">(</span><span class="n">qc</span><span class="p">,</span> <span class="n">tag</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">sata_dwc_bmdma_start_by_tag</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_queued_cmd</span> <span class="o">*</span><span class="n">qc</span><span class="p">,</span> <span class="n">u8</span> <span class="n">tag</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">start_dma</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">reg</span><span class="p">,</span> <span class="n">dma_chan</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sata_dwc_device</span> <span class="o">*</span><span class="n">hsdev</span> <span class="o">=</span> <span class="n">HSDEV_FROM_QC</span><span class="p">(</span><span class="n">qc</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span> <span class="o">=</span> <span class="n">qc</span><span class="o">-&gt;</span><span class="n">ap</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sata_dwc_device_port</span> <span class="o">*</span><span class="n">hsdevp</span> <span class="o">=</span> <span class="n">HSDEVP_FROM_AP</span><span class="p">(</span><span class="n">ap</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">dir</span> <span class="o">=</span> <span class="n">qc</span><span class="o">-&gt;</span><span class="n">dma_dir</span><span class="p">;</span>
	<span class="n">dma_chan</span> <span class="o">=</span> <span class="n">hsdevp</span><span class="o">-&gt;</span><span class="n">dma_chan</span><span class="p">[</span><span class="n">tag</span><span class="p">];</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">hsdevp</span><span class="o">-&gt;</span><span class="n">cmd_issued</span><span class="p">[</span><span class="n">tag</span><span class="p">]</span> <span class="o">!=</span> <span class="n">SATA_DWC_CMD_ISSUED_NOT</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">start_dma</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dir</span> <span class="o">==</span> <span class="n">DMA_TO_DEVICE</span><span class="p">)</span>
			<span class="n">hsdevp</span><span class="o">-&gt;</span><span class="n">dma_pending</span><span class="p">[</span><span class="n">tag</span><span class="p">]</span> <span class="o">=</span> <span class="n">SATA_DWC_DMA_PENDING_TX</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">hsdevp</span><span class="o">-&gt;</span><span class="n">dma_pending</span><span class="p">[</span><span class="n">tag</span><span class="p">]</span> <span class="o">=</span> <span class="n">SATA_DWC_DMA_PENDING_RX</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s: Command not pending cmd_issued=%d &quot;</span>
			<span class="s">&quot;(tag=%d) DMA NOT started</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span>
			<span class="n">hsdevp</span><span class="o">-&gt;</span><span class="n">cmd_issued</span><span class="p">[</span><span class="n">tag</span><span class="p">],</span> <span class="n">tag</span><span class="p">);</span>
		<span class="n">start_dma</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">dev_dbg</span><span class="p">(</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s qc=%p tag: %x cmd: 0x%02x dma_dir: %s &quot;</span>
		<span class="s">&quot;start_dma? %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">qc</span><span class="p">,</span> <span class="n">tag</span><span class="p">,</span> <span class="n">qc</span><span class="o">-&gt;</span><span class="n">tf</span><span class="p">.</span><span class="n">command</span><span class="p">,</span>
		<span class="n">get_dma_dir_descript</span><span class="p">(</span><span class="n">qc</span><span class="o">-&gt;</span><span class="n">dma_dir</span><span class="p">),</span> <span class="n">start_dma</span><span class="p">);</span>
	<span class="n">sata_dwc_tf_dump</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">qc</span><span class="o">-&gt;</span><span class="n">tf</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">start_dma</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">reg</span> <span class="o">=</span> <span class="n">core_scr_read</span><span class="p">(</span><span class="n">SCR_ERROR</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">reg</span> <span class="o">&amp;</span> <span class="n">SATA_DWC_SERROR_ERR_BITS</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dev_err</span><span class="p">(</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s: ****** SError=0x%08x ******</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">__func__</span><span class="p">,</span> <span class="n">reg</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">dir</span> <span class="o">==</span> <span class="n">DMA_TO_DEVICE</span><span class="p">)</span>
			<span class="n">out_le32</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hsdev</span><span class="o">-&gt;</span><span class="n">sata_dwc_regs</span><span class="o">-&gt;</span><span class="n">dmacr</span><span class="p">,</span>
				<span class="n">SATA_DWC_DMACR_TXCHEN</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">out_le32</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hsdev</span><span class="o">-&gt;</span><span class="n">sata_dwc_regs</span><span class="o">-&gt;</span><span class="n">dmacr</span><span class="p">,</span>
				<span class="n">SATA_DWC_DMACR_RXCHEN</span><span class="p">);</span>

		<span class="cm">/* Enable AHB DMA transfer on the specified channel */</span>
		<span class="n">dma_dwc_xfer_start</span><span class="p">(</span><span class="n">dma_chan</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">sata_dwc_bmdma_start</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_queued_cmd</span> <span class="o">*</span><span class="n">qc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u8</span> <span class="n">tag</span> <span class="o">=</span> <span class="n">qc</span><span class="o">-&gt;</span><span class="n">tag</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ata_is_ncq</span><span class="p">(</span><span class="n">qc</span><span class="o">-&gt;</span><span class="n">tf</span><span class="p">.</span><span class="n">protocol</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dev_dbg</span><span class="p">(</span><span class="n">qc</span><span class="o">-&gt;</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s: ap-&gt;link.sactive=0x%08x tag=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">__func__</span><span class="p">,</span> <span class="n">qc</span><span class="o">-&gt;</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">link</span><span class="p">.</span><span class="n">sactive</span><span class="p">,</span> <span class="n">tag</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">tag</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">dev_dbg</span><span class="p">(</span><span class="n">qc</span><span class="o">-&gt;</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
	<span class="n">sata_dwc_bmdma_start_by_tag</span><span class="p">(</span><span class="n">qc</span><span class="p">,</span> <span class="n">tag</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Function : sata_dwc_qc_prep_by_tag</span>
<span class="cm"> * arguments : ata_queued_cmd *qc, u8 tag</span>
<span class="cm"> * Return value : None</span>
<span class="cm"> * qc_prep for a particular queued command based on tag</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">sata_dwc_qc_prep_by_tag</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_queued_cmd</span> <span class="o">*</span><span class="n">qc</span><span class="p">,</span> <span class="n">u8</span> <span class="n">tag</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">scatterlist</span> <span class="o">*</span><span class="n">sg</span> <span class="o">=</span> <span class="n">qc</span><span class="o">-&gt;</span><span class="n">sg</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span> <span class="o">=</span> <span class="n">qc</span><span class="o">-&gt;</span><span class="n">ap</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">dma_chan</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sata_dwc_device</span> <span class="o">*</span><span class="n">hsdev</span> <span class="o">=</span> <span class="n">HSDEV_FROM_AP</span><span class="p">(</span><span class="n">ap</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">sata_dwc_device_port</span> <span class="o">*</span><span class="n">hsdevp</span> <span class="o">=</span> <span class="n">HSDEVP_FROM_AP</span><span class="p">(</span><span class="n">ap</span><span class="p">);</span>

	<span class="n">dev_dbg</span><span class="p">(</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s: port=%d dma dir=%s n_elem=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">__func__</span><span class="p">,</span> <span class="n">ap</span><span class="o">-&gt;</span><span class="n">port_no</span><span class="p">,</span> <span class="n">get_dma_dir_descript</span><span class="p">(</span><span class="n">qc</span><span class="o">-&gt;</span><span class="n">dma_dir</span><span class="p">),</span>
		 <span class="n">qc</span><span class="o">-&gt;</span><span class="n">n_elem</span><span class="p">);</span>

	<span class="n">dma_chan</span> <span class="o">=</span> <span class="n">dma_dwc_xfer_setup</span><span class="p">(</span><span class="n">sg</span><span class="p">,</span> <span class="n">qc</span><span class="o">-&gt;</span><span class="n">n_elem</span><span class="p">,</span> <span class="n">hsdevp</span><span class="o">-&gt;</span><span class="n">llit</span><span class="p">[</span><span class="n">tag</span><span class="p">],</span>
				      <span class="n">hsdevp</span><span class="o">-&gt;</span><span class="n">llit_dma</span><span class="p">[</span><span class="n">tag</span><span class="p">],</span>
				      <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">__iomem</span><span class="p">)(</span><span class="o">&amp;</span><span class="n">hsdev</span><span class="o">-&gt;</span><span class="n">sata_dwc_regs</span><span class="o">-&gt;</span>\
				      <span class="n">dmadr</span><span class="p">),</span> <span class="n">qc</span><span class="o">-&gt;</span><span class="n">dma_dir</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dma_chan</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s: dma_dwc_xfer_setup returns err %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">__func__</span><span class="p">,</span> <span class="n">dma_chan</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">hsdevp</span><span class="o">-&gt;</span><span class="n">dma_chan</span><span class="p">[</span><span class="n">tag</span><span class="p">]</span> <span class="o">=</span> <span class="n">dma_chan</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">sata_dwc_qc_issue</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_queued_cmd</span> <span class="o">*</span><span class="n">qc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">sactive</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">tag</span> <span class="o">=</span> <span class="n">qc</span><span class="o">-&gt;</span><span class="n">tag</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span> <span class="o">=</span> <span class="n">qc</span><span class="o">-&gt;</span><span class="n">ap</span><span class="p">;</span>

<span class="cp">#ifdef DEBUG_NCQ</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">qc</span><span class="o">-&gt;</span><span class="n">tag</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">ap</span><span class="o">-&gt;</span><span class="n">link</span><span class="p">.</span><span class="n">sactive</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span>
		<span class="n">dev_info</span><span class="p">(</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s ap id=%d cmd(0x%02x)=%s qc tag=%d &quot;</span>
			 <span class="s">&quot;prot=%s ap active_tag=0x%08x ap sactive=0x%08x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			 <span class="n">__func__</span><span class="p">,</span> <span class="n">ap</span><span class="o">-&gt;</span><span class="n">print_id</span><span class="p">,</span> <span class="n">qc</span><span class="o">-&gt;</span><span class="n">tf</span><span class="p">.</span><span class="n">command</span><span class="p">,</span>
			 <span class="n">ata_get_cmd_descript</span><span class="p">(</span><span class="n">qc</span><span class="o">-&gt;</span><span class="n">tf</span><span class="p">.</span><span class="n">command</span><span class="p">),</span>
			 <span class="n">qc</span><span class="o">-&gt;</span><span class="n">tag</span><span class="p">,</span> <span class="n">get_prot_descript</span><span class="p">(</span><span class="n">qc</span><span class="o">-&gt;</span><span class="n">tf</span><span class="p">.</span><span class="n">protocol</span><span class="p">),</span>
			 <span class="n">ap</span><span class="o">-&gt;</span><span class="n">link</span><span class="p">.</span><span class="n">active_tag</span><span class="p">,</span> <span class="n">ap</span><span class="o">-&gt;</span><span class="n">link</span><span class="p">.</span><span class="n">sactive</span><span class="p">);</span>
<span class="cp">#endif</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ata_is_ncq</span><span class="p">(</span><span class="n">qc</span><span class="o">-&gt;</span><span class="n">tf</span><span class="p">.</span><span class="n">protocol</span><span class="p">))</span>
		<span class="n">tag</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">sata_dwc_qc_prep_by_tag</span><span class="p">(</span><span class="n">qc</span><span class="p">,</span> <span class="n">tag</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ata_is_ncq</span><span class="p">(</span><span class="n">qc</span><span class="o">-&gt;</span><span class="n">tf</span><span class="p">.</span><span class="n">protocol</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">sactive</span> <span class="o">=</span> <span class="n">core_scr_read</span><span class="p">(</span><span class="n">SCR_ACTIVE</span><span class="p">);</span>
		<span class="n">sactive</span> <span class="o">|=</span> <span class="p">(</span><span class="mh">0x00000001</span> <span class="o">&lt;&lt;</span> <span class="n">tag</span><span class="p">);</span>
		<span class="n">core_scr_write</span><span class="p">(</span><span class="n">SCR_ACTIVE</span><span class="p">,</span> <span class="n">sactive</span><span class="p">);</span>

		<span class="n">dev_dbg</span><span class="p">(</span><span class="n">qc</span><span class="o">-&gt;</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s: tag=%d ap-&gt;link.sactive = 0x%08x &quot;</span>
			<span class="s">&quot;sactive=0x%08x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">tag</span><span class="p">,</span> <span class="n">qc</span><span class="o">-&gt;</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">link</span><span class="p">.</span><span class="n">sactive</span><span class="p">,</span>
			<span class="n">sactive</span><span class="p">);</span>

		<span class="n">ap</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">sff_tf_load</span><span class="p">(</span><span class="n">ap</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">qc</span><span class="o">-&gt;</span><span class="n">tf</span><span class="p">);</span>
		<span class="n">sata_dwc_exec_command_by_tag</span><span class="p">(</span><span class="n">ap</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">qc</span><span class="o">-&gt;</span><span class="n">tf</span><span class="p">,</span> <span class="n">qc</span><span class="o">-&gt;</span><span class="n">tag</span><span class="p">,</span>
					     <span class="n">SATA_DWC_CMD_ISSUED_PEND</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">ata_sff_qc_issue</span><span class="p">(</span><span class="n">qc</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Function : sata_dwc_qc_prep</span>
<span class="cm"> * arguments : ata_queued_cmd *qc</span>
<span class="cm"> * Return value : None</span>
<span class="cm"> * qc_prep for a particular queued command</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">sata_dwc_qc_prep</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_queued_cmd</span> <span class="o">*</span><span class="n">qc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">qc</span><span class="o">-&gt;</span><span class="n">dma_dir</span> <span class="o">==</span> <span class="n">DMA_NONE</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">qc</span><span class="o">-&gt;</span><span class="n">tf</span><span class="p">.</span><span class="n">protocol</span> <span class="o">==</span> <span class="n">ATA_PROT_PIO</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

<span class="cp">#ifdef DEBUG_NCQ</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">qc</span><span class="o">-&gt;</span><span class="n">tag</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">dev_info</span><span class="p">(</span><span class="n">qc</span><span class="o">-&gt;</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;%s: qc-&gt;tag=%d ap-&gt;active_tag=0x%08x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			 <span class="n">__func__</span><span class="p">,</span> <span class="n">qc</span><span class="o">-&gt;</span><span class="n">tag</span><span class="p">,</span> <span class="n">qc</span><span class="o">-&gt;</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">link</span><span class="p">.</span><span class="n">active_tag</span><span class="p">);</span>

	<span class="k">return</span> <span class="p">;</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">sata_dwc_error_handler</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ap</span><span class="o">-&gt;</span><span class="n">link</span><span class="p">.</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">ATA_LFLAG_NO_HRST</span><span class="p">;</span>
	<span class="n">ata_sff_error_handler</span><span class="p">(</span><span class="n">ap</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * scsi mid-layer and libata interface structures</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">scsi_host_template</span> <span class="n">sata_dwc_sht</span> <span class="o">=</span> <span class="p">{</span>
	<span class="n">ATA_NCQ_SHT</span><span class="p">(</span><span class="n">DRV_NAME</span><span class="p">),</span>
	<span class="cm">/*</span>
<span class="cm">	 * test-only: Currently this driver doesn&#39;t handle NCQ</span>
<span class="cm">	 * correctly. We enable NCQ but set the queue depth to a</span>
<span class="cm">	 * max of 1. This will get fixed in in a future release.</span>
<span class="cm">	 */</span>
	<span class="p">.</span><span class="n">sg_tablesize</span>		<span class="o">=</span> <span class="n">LIBATA_MAX_PRD</span><span class="p">,</span>
	<span class="p">.</span><span class="n">can_queue</span>		<span class="o">=</span> <span class="n">ATA_DEF_QUEUE</span><span class="p">,</span>	<span class="cm">/* ATA_MAX_QUEUE */</span>
	<span class="p">.</span><span class="n">dma_boundary</span>		<span class="o">=</span> <span class="n">ATA_DMA_BOUNDARY</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">ata_port_operations</span> <span class="n">sata_dwc_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">inherits</span>		<span class="o">=</span> <span class="o">&amp;</span><span class="n">ata_sff_port_ops</span><span class="p">,</span>

	<span class="p">.</span><span class="n">error_handler</span>		<span class="o">=</span> <span class="n">sata_dwc_error_handler</span><span class="p">,</span>

	<span class="p">.</span><span class="n">qc_prep</span>		<span class="o">=</span> <span class="n">sata_dwc_qc_prep</span><span class="p">,</span>
	<span class="p">.</span><span class="n">qc_issue</span>		<span class="o">=</span> <span class="n">sata_dwc_qc_issue</span><span class="p">,</span>

	<span class="p">.</span><span class="n">scr_read</span>		<span class="o">=</span> <span class="n">sata_dwc_scr_read</span><span class="p">,</span>
	<span class="p">.</span><span class="n">scr_write</span>		<span class="o">=</span> <span class="n">sata_dwc_scr_write</span><span class="p">,</span>

	<span class="p">.</span><span class="n">port_start</span>		<span class="o">=</span> <span class="n">sata_dwc_port_start</span><span class="p">,</span>
	<span class="p">.</span><span class="n">port_stop</span>		<span class="o">=</span> <span class="n">sata_dwc_port_stop</span><span class="p">,</span>

	<span class="p">.</span><span class="n">bmdma_setup</span>		<span class="o">=</span> <span class="n">sata_dwc_bmdma_setup</span><span class="p">,</span>
	<span class="p">.</span><span class="n">bmdma_start</span>		<span class="o">=</span> <span class="n">sata_dwc_bmdma_start</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">ata_port_info</span> <span class="n">sata_dwc_port_info</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">{</span>
		<span class="p">.</span><span class="n">flags</span>		<span class="o">=</span> <span class="n">ATA_FLAG_SATA</span> <span class="o">|</span> <span class="n">ATA_FLAG_NCQ</span><span class="p">,</span>
		<span class="p">.</span><span class="n">pio_mask</span>	<span class="o">=</span> <span class="n">ATA_PIO4</span><span class="p">,</span>
		<span class="p">.</span><span class="n">udma_mask</span>	<span class="o">=</span> <span class="n">ATA_UDMA6</span><span class="p">,</span>
		<span class="p">.</span><span class="n">port_ops</span>	<span class="o">=</span> <span class="o">&amp;</span><span class="n">sata_dwc_ops</span><span class="p">,</span>
	<span class="p">},</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">sata_dwc_probe</span><span class="p">(</span><span class="k">struct</span> <span class="n">platform_device</span> <span class="o">*</span><span class="n">ofdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sata_dwc_device</span> <span class="o">*</span><span class="n">hsdev</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">idr</span><span class="p">,</span> <span class="n">versionr</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">ver</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">versionr</span><span class="p">;</span>
	<span class="n">u8</span> <span class="o">*</span><span class="n">base</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="n">rc</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ata_host</span> <span class="o">*</span><span class="n">host</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ata_port_info</span> <span class="n">pi</span> <span class="o">=</span> <span class="n">sata_dwc_port_info</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">ata_port_info</span> <span class="o">*</span><span class="n">ppi</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span> <span class="o">&amp;</span><span class="n">pi</span><span class="p">,</span> <span class="nb">NULL</span> <span class="p">};</span>

	<span class="cm">/* Allocate DWC SATA device */</span>
	<span class="n">hsdev</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">hsdev</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hsdev</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ofdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;kmalloc failed for hsdev</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Ioremap SATA registers */</span>
	<span class="n">base</span> <span class="o">=</span> <span class="n">of_iomap</span><span class="p">(</span><span class="n">ofdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">of_node</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">base</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ofdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;ioremap failed for SATA register&quot;</span>
			<span class="s">&quot; address</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">error_kmalloc</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">hsdev</span><span class="o">-&gt;</span><span class="n">reg_base</span> <span class="o">=</span> <span class="n">base</span><span class="p">;</span>
	<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ofdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;ioremap done for SATA register address</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="cm">/* Synopsys DWC SATA specific Registers */</span>
	<span class="n">hsdev</span><span class="o">-&gt;</span><span class="n">sata_dwc_regs</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">__iomem</span><span class="p">)(</span><span class="n">base</span> <span class="o">+</span> <span class="n">SATA_DWC_REG_OFFSET</span><span class="p">);</span>

	<span class="cm">/* Allocate and fill host */</span>
	<span class="n">host</span> <span class="o">=</span> <span class="n">ata_host_alloc_pinfo</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ofdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">ppi</span><span class="p">,</span> <span class="n">SATA_DWC_MAX_PORTS</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">host</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ofdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;ata_host_alloc_pinfo failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">error_iomap</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">host</span><span class="o">-&gt;</span><span class="n">private_data</span> <span class="o">=</span> <span class="n">hsdev</span><span class="p">;</span>

	<span class="cm">/* Setup port */</span>
	<span class="n">host</span><span class="o">-&gt;</span><span class="n">ports</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">ioaddr</span><span class="p">.</span><span class="n">cmd_addr</span> <span class="o">=</span> <span class="n">base</span><span class="p">;</span>
	<span class="n">host</span><span class="o">-&gt;</span><span class="n">ports</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">ioaddr</span><span class="p">.</span><span class="n">scr_addr</span> <span class="o">=</span> <span class="n">base</span> <span class="o">+</span> <span class="n">SATA_DWC_SCR_OFFSET</span><span class="p">;</span>
	<span class="n">host_pvt</span><span class="p">.</span><span class="n">scr_addr_sstatus</span> <span class="o">=</span> <span class="n">base</span> <span class="o">+</span> <span class="n">SATA_DWC_SCR_OFFSET</span><span class="p">;</span>
	<span class="n">sata_dwc_setup_port</span><span class="p">(</span><span class="o">&amp;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">ports</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">ioaddr</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">base</span><span class="p">);</span>

	<span class="cm">/* Read the ID and Version Registers */</span>
	<span class="n">idr</span> <span class="o">=</span> <span class="n">in_le32</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hsdev</span><span class="o">-&gt;</span><span class="n">sata_dwc_regs</span><span class="o">-&gt;</span><span class="n">idr</span><span class="p">);</span>
	<span class="n">versionr</span> <span class="o">=</span> <span class="n">in_le32</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hsdev</span><span class="o">-&gt;</span><span class="n">sata_dwc_regs</span><span class="o">-&gt;</span><span class="n">versionr</span><span class="p">);</span>
	<span class="n">dev_notice</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ofdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;id %d, controller version %c.%c%c</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		   <span class="n">idr</span><span class="p">,</span> <span class="n">ver</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">ver</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">ver</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span>

	<span class="cm">/* Get SATA DMA interrupt number */</span>
	<span class="n">irq</span> <span class="o">=</span> <span class="n">irq_of_parse_and_map</span><span class="p">(</span><span class="n">ofdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">of_node</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">irq</span> <span class="o">==</span> <span class="n">NO_IRQ</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ofdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;no SATA DMA irq</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">error_out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Get physical SATA DMA register base address */</span>
	<span class="n">host_pvt</span><span class="p">.</span><span class="n">sata_dma_regs</span> <span class="o">=</span> <span class="n">of_iomap</span><span class="p">(</span><span class="n">ofdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">of_node</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">host_pvt</span><span class="p">.</span><span class="n">sata_dma_regs</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ofdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;ioremap failed for AHBDMA register&quot;</span>
			<span class="s">&quot; address</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">error_out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Save dev for later use in dev_xxx() routines */</span>
	<span class="n">host_pvt</span><span class="p">.</span><span class="n">dwc_dev</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ofdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>

	<span class="cm">/* Initialize AHB DMAC */</span>
	<span class="n">dma_dwc_init</span><span class="p">(</span><span class="n">hsdev</span><span class="p">,</span> <span class="n">irq</span><span class="p">);</span>

	<span class="cm">/* Enable SATA Interrupts */</span>
	<span class="n">sata_dwc_enable_interrupts</span><span class="p">(</span><span class="n">hsdev</span><span class="p">);</span>

	<span class="cm">/* Get SATA interrupt number */</span>
	<span class="n">irq</span> <span class="o">=</span> <span class="n">irq_of_parse_and_map</span><span class="p">(</span><span class="n">ofdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">of_node</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">irq</span> <span class="o">==</span> <span class="n">NO_IRQ</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ofdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;no SATA DMA irq</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">error_out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Now, register with libATA core, this will also initiate the</span>
<span class="cm">	 * device discovery process, invoking our port_start() handler &amp;</span>
<span class="cm">	 * error_handler() to execute a dummy Softreset EH session</span>
<span class="cm">	 */</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">ata_host_activate</span><span class="p">(</span><span class="n">host</span><span class="p">,</span> <span class="n">irq</span><span class="p">,</span> <span class="n">sata_dwc_isr</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sata_dwc_sht</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ofdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;failed to activate host&quot;</span><span class="p">);</span>

	<span class="n">dev_set_drvdata</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ofdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">host</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">error_out:</span>
	<span class="cm">/* Free SATA DMA resources */</span>
	<span class="n">dma_dwc_exit</span><span class="p">(</span><span class="n">hsdev</span><span class="p">);</span>

<span class="nl">error_iomap:</span>
	<span class="n">iounmap</span><span class="p">(</span><span class="n">base</span><span class="p">);</span>
<span class="nl">error_kmalloc:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">hsdev</span><span class="p">);</span>
<span class="nl">error:</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">sata_dwc_remove</span><span class="p">(</span><span class="k">struct</span> <span class="n">platform_device</span> <span class="o">*</span><span class="n">ofdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ofdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ata_host</span> <span class="o">*</span><span class="n">host</span> <span class="o">=</span> <span class="n">dev_get_drvdata</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">sata_dwc_device</span> <span class="o">*</span><span class="n">hsdev</span> <span class="o">=</span> <span class="n">host</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>

	<span class="n">ata_host_detach</span><span class="p">(</span><span class="n">host</span><span class="p">);</span>
	<span class="n">dev_set_drvdata</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

	<span class="cm">/* Free SATA DMA resources */</span>
	<span class="n">dma_dwc_exit</span><span class="p">(</span><span class="n">hsdev</span><span class="p">);</span>

	<span class="n">iounmap</span><span class="p">(</span><span class="n">hsdev</span><span class="o">-&gt;</span><span class="n">reg_base</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">hsdev</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">host</span><span class="p">);</span>
	<span class="n">dev_dbg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ofdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;done</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">of_device_id</span> <span class="n">sata_dwc_match</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">{</span> <span class="p">.</span><span class="n">compatible</span> <span class="o">=</span> <span class="s">&quot;amcc,sata-460ex&quot;</span><span class="p">,</span> <span class="p">},</span>
	<span class="p">{}</span>
<span class="p">};</span>
<span class="n">MODULE_DEVICE_TABLE</span><span class="p">(</span><span class="n">of</span><span class="p">,</span> <span class="n">sata_dwc_match</span><span class="p">);</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">platform_driver</span> <span class="n">sata_dwc_driver</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">driver</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">DRV_NAME</span><span class="p">,</span>
		<span class="p">.</span><span class="n">owner</span> <span class="o">=</span> <span class="n">THIS_MODULE</span><span class="p">,</span>
		<span class="p">.</span><span class="n">of_match_table</span> <span class="o">=</span> <span class="n">sata_dwc_match</span><span class="p">,</span>
	<span class="p">},</span>
	<span class="p">.</span><span class="n">probe</span> <span class="o">=</span> <span class="n">sata_dwc_probe</span><span class="p">,</span>
	<span class="p">.</span><span class="n">remove</span> <span class="o">=</span> <span class="n">sata_dwc_remove</span><span class="p">,</span>
<span class="p">};</span>

<span class="n">module_platform_driver</span><span class="p">(</span><span class="n">sata_dwc_driver</span><span class="p">);</span>

<span class="n">MODULE_LICENSE</span><span class="p">(</span><span class="s">&quot;GPL&quot;</span><span class="p">);</span>
<span class="n">MODULE_AUTHOR</span><span class="p">(</span><span class="s">&quot;Mark Miesfeld &lt;mmiesfeld@amcc.com&gt;&quot;</span><span class="p">);</span>
<span class="n">MODULE_DESCRIPTION</span><span class="p">(</span><span class="s">&quot;DesignWare Cores SATA controller low lever driver&quot;</span><span class="p">);</span>
<span class="n">MODULE_VERSION</span><span class="p">(</span><span class="n">DRV_VERSION</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
