<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › ata › libata-sff.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>libata-sff.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> *  libata-sff.c - helper library for PCI IDE BMDMA</span>
<span class="cm"> *</span>
<span class="cm"> *  Maintained by:  Jeff Garzik &lt;jgarzik@pobox.com&gt;</span>
<span class="cm"> *    		    Please ALWAYS copy linux-ide@vger.kernel.org</span>
<span class="cm"> *		    on emails.</span>
<span class="cm"> *</span>
<span class="cm"> *  Copyright 2003-2006 Red Hat, Inc.  All rights reserved.</span>
<span class="cm"> *  Copyright 2003-2006 Jeff Garzik</span>
<span class="cm"> *</span>
<span class="cm"> *</span>
<span class="cm"> *  This program is free software; you can redistribute it and/or modify</span>
<span class="cm"> *  it under the terms of the GNU General Public License as published by</span>
<span class="cm"> *  the Free Software Foundation; either version 2, or (at your option)</span>
<span class="cm"> *  any later version.</span>
<span class="cm"> *</span>
<span class="cm"> *  This program is distributed in the hope that it will be useful,</span>
<span class="cm"> *  but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm"> *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="cm"> *  GNU General Public License for more details.</span>
<span class="cm"> *</span>
<span class="cm"> *  You should have received a copy of the GNU General Public License</span>
<span class="cm"> *  along with this program; see the file COPYING.  If not, write to</span>
<span class="cm"> *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.</span>
<span class="cm"> *</span>
<span class="cm"> *</span>
<span class="cm"> *  libata documentation is available via &#39;make {ps|pdf}docs&#39;,</span>
<span class="cm"> *  as Documentation/DocBook/libata.*</span>
<span class="cm"> *</span>
<span class="cm"> *  Hardware documentation available from http://www.t13.org/ and</span>
<span class="cm"> *  http://www.sata-io.org/</span>
<span class="cm"> *</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/gfp.h&gt;</span>
<span class="cp">#include &lt;linux/pci.h&gt;</span>
<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/libata.h&gt;</span>
<span class="cp">#include &lt;linux/highmem.h&gt;</span>

<span class="cp">#include &quot;libata.h&quot;</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">workqueue_struct</span> <span class="o">*</span><span class="n">ata_sff_wq</span><span class="p">;</span>

<span class="k">const</span> <span class="k">struct</span> <span class="n">ata_port_operations</span> <span class="n">ata_sff_port_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">inherits</span>		<span class="o">=</span> <span class="o">&amp;</span><span class="n">ata_base_port_ops</span><span class="p">,</span>

	<span class="p">.</span><span class="n">qc_prep</span>		<span class="o">=</span> <span class="n">ata_noop_qc_prep</span><span class="p">,</span>
	<span class="p">.</span><span class="n">qc_issue</span>		<span class="o">=</span> <span class="n">ata_sff_qc_issue</span><span class="p">,</span>
	<span class="p">.</span><span class="n">qc_fill_rtf</span>		<span class="o">=</span> <span class="n">ata_sff_qc_fill_rtf</span><span class="p">,</span>

	<span class="p">.</span><span class="n">freeze</span>			<span class="o">=</span> <span class="n">ata_sff_freeze</span><span class="p">,</span>
	<span class="p">.</span><span class="n">thaw</span>			<span class="o">=</span> <span class="n">ata_sff_thaw</span><span class="p">,</span>
	<span class="p">.</span><span class="n">prereset</span>		<span class="o">=</span> <span class="n">ata_sff_prereset</span><span class="p">,</span>
	<span class="p">.</span><span class="n">softreset</span>		<span class="o">=</span> <span class="n">ata_sff_softreset</span><span class="p">,</span>
	<span class="p">.</span><span class="n">hardreset</span>		<span class="o">=</span> <span class="n">sata_sff_hardreset</span><span class="p">,</span>
	<span class="p">.</span><span class="n">postreset</span>		<span class="o">=</span> <span class="n">ata_sff_postreset</span><span class="p">,</span>
	<span class="p">.</span><span class="n">error_handler</span>		<span class="o">=</span> <span class="n">ata_sff_error_handler</span><span class="p">,</span>

	<span class="p">.</span><span class="n">sff_dev_select</span>		<span class="o">=</span> <span class="n">ata_sff_dev_select</span><span class="p">,</span>
	<span class="p">.</span><span class="n">sff_check_status</span>	<span class="o">=</span> <span class="n">ata_sff_check_status</span><span class="p">,</span>
	<span class="p">.</span><span class="n">sff_tf_load</span>		<span class="o">=</span> <span class="n">ata_sff_tf_load</span><span class="p">,</span>
	<span class="p">.</span><span class="n">sff_tf_read</span>		<span class="o">=</span> <span class="n">ata_sff_tf_read</span><span class="p">,</span>
	<span class="p">.</span><span class="n">sff_exec_command</span>	<span class="o">=</span> <span class="n">ata_sff_exec_command</span><span class="p">,</span>
	<span class="p">.</span><span class="n">sff_data_xfer</span>		<span class="o">=</span> <span class="n">ata_sff_data_xfer</span><span class="p">,</span>
	<span class="p">.</span><span class="n">sff_drain_fifo</span>		<span class="o">=</span> <span class="n">ata_sff_drain_fifo</span><span class="p">,</span>

	<span class="p">.</span><span class="n">lost_interrupt</span>		<span class="o">=</span> <span class="n">ata_sff_lost_interrupt</span><span class="p">,</span>
<span class="p">};</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">ata_sff_port_ops</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> *	ata_sff_check_status - Read device status reg &amp; clear interrupt</span>
<span class="cm"> *	@ap: port where the device is</span>
<span class="cm"> *</span>
<span class="cm"> *	Reads ATA taskfile status register for currently-selected device</span>
<span class="cm"> *	and return its value. This also clears pending interrupts</span>
<span class="cm"> *      from this device</span>
<span class="cm"> *</span>
<span class="cm"> *	LOCKING:</span>
<span class="cm"> *	Inherited from caller.</span>
<span class="cm"> */</span>
<span class="n">u8</span> <span class="nf">ata_sff_check_status</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">ioread8</span><span class="p">(</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">ioaddr</span><span class="p">.</span><span class="n">status_addr</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">ata_sff_check_status</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> *	ata_sff_altstatus - Read device alternate status reg</span>
<span class="cm"> *	@ap: port where the device is</span>
<span class="cm"> *</span>
<span class="cm"> *	Reads ATA taskfile alternate status register for</span>
<span class="cm"> *	currently-selected device and return its value.</span>
<span class="cm"> *</span>
<span class="cm"> *	Note: may NOT be used as the check_altstatus() entry in</span>
<span class="cm"> *	ata_port_operations.</span>
<span class="cm"> *</span>
<span class="cm"> *	LOCKING:</span>
<span class="cm"> *	Inherited from caller.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">u8</span> <span class="nf">ata_sff_altstatus</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">sff_check_altstatus</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ap</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">sff_check_altstatus</span><span class="p">(</span><span class="n">ap</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ioread8</span><span class="p">(</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">ioaddr</span><span class="p">.</span><span class="n">altstatus_addr</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	ata_sff_irq_status - Check if the device is busy</span>
<span class="cm"> *	@ap: port where the device is</span>
<span class="cm"> *</span>
<span class="cm"> *	Determine if the port is currently busy. Uses altstatus</span>
<span class="cm"> *	if available in order to avoid clearing shared IRQ status</span>
<span class="cm"> *	when finding an IRQ source. Non ctl capable devices don&#39;t</span>
<span class="cm"> *	share interrupt lines fortunately for us.</span>
<span class="cm"> *</span>
<span class="cm"> *	LOCKING:</span>
<span class="cm"> *	Inherited from caller.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">u8</span> <span class="nf">ata_sff_irq_status</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u8</span> <span class="n">status</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">sff_check_altstatus</span> <span class="o">||</span> <span class="n">ap</span><span class="o">-&gt;</span><span class="n">ioaddr</span><span class="p">.</span><span class="n">altstatus_addr</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">ata_sff_altstatus</span><span class="p">(</span><span class="n">ap</span><span class="p">);</span>
		<span class="cm">/* Not us: We are busy */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">ATA_BUSY</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* Clear INTRQ latch */</span>
	<span class="n">status</span> <span class="o">=</span> <span class="n">ap</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">sff_check_status</span><span class="p">(</span><span class="n">ap</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	ata_sff_sync - Flush writes</span>
<span class="cm"> *	@ap: Port to wait for.</span>
<span class="cm"> *</span>
<span class="cm"> *	CAUTION:</span>
<span class="cm"> *	If we have an mmio device with no ctl and no altstatus</span>
<span class="cm"> *	method this will fail. No such devices are known to exist.</span>
<span class="cm"> *</span>
<span class="cm"> *	LOCKING:</span>
<span class="cm"> *	Inherited from caller.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">ata_sff_sync</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">sff_check_altstatus</span><span class="p">)</span>
		<span class="n">ap</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">sff_check_altstatus</span><span class="p">(</span><span class="n">ap</span><span class="p">);</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">ioaddr</span><span class="p">.</span><span class="n">altstatus_addr</span><span class="p">)</span>
		<span class="n">ioread8</span><span class="p">(</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">ioaddr</span><span class="p">.</span><span class="n">altstatus_addr</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	ata_sff_pause		-	Flush writes and wait 400nS</span>
<span class="cm"> *	@ap: Port to pause for.</span>
<span class="cm"> *</span>
<span class="cm"> *	CAUTION:</span>
<span class="cm"> *	If we have an mmio device with no ctl and no altstatus</span>
<span class="cm"> *	method this will fail. No such devices are known to exist.</span>
<span class="cm"> *</span>
<span class="cm"> *	LOCKING:</span>
<span class="cm"> *	Inherited from caller.</span>
<span class="cm"> */</span>

<span class="kt">void</span> <span class="nf">ata_sff_pause</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ata_sff_sync</span><span class="p">(</span><span class="n">ap</span><span class="p">);</span>
	<span class="n">ndelay</span><span class="p">(</span><span class="mi">400</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">ata_sff_pause</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> *	ata_sff_dma_pause	-	Pause before commencing DMA</span>
<span class="cm"> *	@ap: Port to pause for.</span>
<span class="cm"> *</span>
<span class="cm"> *	Perform I/O fencing and ensure sufficient cycle delays occur</span>
<span class="cm"> *	for the HDMA1:0 transition</span>
<span class="cm"> */</span>

<span class="kt">void</span> <span class="nf">ata_sff_dma_pause</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">sff_check_altstatus</span> <span class="o">||</span> <span class="n">ap</span><span class="o">-&gt;</span><span class="n">ioaddr</span><span class="p">.</span><span class="n">altstatus_addr</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* An altstatus read will cause the needed delay without</span>
<span class="cm">		   messing up the IRQ status */</span>
		<span class="n">ata_sff_altstatus</span><span class="p">(</span><span class="n">ap</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* There are no DMA controllers without ctl. BUG here to ensure</span>
<span class="cm">	   we never violate the HDMA1:0 transition timing and risk</span>
<span class="cm">	   corruption. */</span>
	<span class="n">BUG</span><span class="p">();</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">ata_sff_dma_pause</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> *	ata_sff_busy_sleep - sleep until BSY clears, or timeout</span>
<span class="cm"> *	@ap: port containing status register to be polled</span>
<span class="cm"> *	@tmout_pat: impatience timeout in msecs</span>
<span class="cm"> *	@tmout: overall timeout in msecs</span>
<span class="cm"> *</span>
<span class="cm"> *	Sleep until ATA Status register bit BSY clears,</span>
<span class="cm"> *	or a timeout occurs.</span>
<span class="cm"> *</span>
<span class="cm"> *	LOCKING:</span>
<span class="cm"> *	Kernel thread context (may sleep).</span>
<span class="cm"> *</span>
<span class="cm"> *	RETURNS:</span>
<span class="cm"> *	0 on success, -errno otherwise.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">ata_sff_busy_sleep</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span><span class="p">,</span>
		       <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">tmout_pat</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">tmout</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">timer_start</span><span class="p">,</span> <span class="n">timeout</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">status</span><span class="p">;</span>

	<span class="n">status</span> <span class="o">=</span> <span class="n">ata_sff_busy_wait</span><span class="p">(</span><span class="n">ap</span><span class="p">,</span> <span class="n">ATA_BUSY</span><span class="p">,</span> <span class="mi">300</span><span class="p">);</span>
	<span class="n">timer_start</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span>
	<span class="n">timeout</span> <span class="o">=</span> <span class="n">ata_deadline</span><span class="p">(</span><span class="n">timer_start</span><span class="p">,</span> <span class="n">tmout_pat</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">status</span> <span class="o">!=</span> <span class="mh">0xff</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">ATA_BUSY</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	       <span class="n">time_before</span><span class="p">(</span><span class="n">jiffies</span><span class="p">,</span> <span class="n">timeout</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ata_msleep</span><span class="p">(</span><span class="n">ap</span><span class="p">,</span> <span class="mi">50</span><span class="p">);</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">ata_sff_busy_wait</span><span class="p">(</span><span class="n">ap</span><span class="p">,</span> <span class="n">ATA_BUSY</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">!=</span> <span class="mh">0xff</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">ATA_BUSY</span><span class="p">))</span>
		<span class="n">ata_port_warn</span><span class="p">(</span><span class="n">ap</span><span class="p">,</span>
			      <span class="s">&quot;port is slow to respond, please be patient (Status 0x%x)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			      <span class="n">status</span><span class="p">);</span>

	<span class="n">timeout</span> <span class="o">=</span> <span class="n">ata_deadline</span><span class="p">(</span><span class="n">timer_start</span><span class="p">,</span> <span class="n">tmout</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">status</span> <span class="o">!=</span> <span class="mh">0xff</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">ATA_BUSY</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	       <span class="n">time_before</span><span class="p">(</span><span class="n">jiffies</span><span class="p">,</span> <span class="n">timeout</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ata_msleep</span><span class="p">(</span><span class="n">ap</span><span class="p">,</span> <span class="mi">50</span><span class="p">);</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">ap</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">sff_check_status</span><span class="p">(</span><span class="n">ap</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">==</span> <span class="mh">0xff</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">ATA_BUSY</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ata_port_err</span><span class="p">(</span><span class="n">ap</span><span class="p">,</span>
			     <span class="s">&quot;port failed to respond (%lu secs, Status 0x%x)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			     <span class="n">DIV_ROUND_UP</span><span class="p">(</span><span class="n">tmout</span><span class="p">,</span> <span class="mi">1000</span><span class="p">),</span> <span class="n">status</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">ata_sff_busy_sleep</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">ata_sff_check_ready</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_link</span> <span class="o">*</span><span class="n">link</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u8</span> <span class="n">status</span> <span class="o">=</span> <span class="n">link</span><span class="o">-&gt;</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">sff_check_status</span><span class="p">(</span><span class="n">link</span><span class="o">-&gt;</span><span class="n">ap</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ata_check_ready</span><span class="p">(</span><span class="n">status</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	ata_sff_wait_ready - sleep until BSY clears, or timeout</span>
<span class="cm"> *	@link: SFF link to wait ready status for</span>
<span class="cm"> *	@deadline: deadline jiffies for the operation</span>
<span class="cm"> *</span>
<span class="cm"> *	Sleep until ATA Status register bit BSY clears, or timeout</span>
<span class="cm"> *	occurs.</span>
<span class="cm"> *</span>
<span class="cm"> *	LOCKING:</span>
<span class="cm"> *	Kernel thread context (may sleep).</span>
<span class="cm"> *</span>
<span class="cm"> *	RETURNS:</span>
<span class="cm"> *	0 on success, -errno otherwise.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">ata_sff_wait_ready</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_link</span> <span class="o">*</span><span class="n">link</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">deadline</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">ata_wait_ready</span><span class="p">(</span><span class="n">link</span><span class="p">,</span> <span class="n">deadline</span><span class="p">,</span> <span class="n">ata_sff_check_ready</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">ata_sff_wait_ready</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> *	ata_sff_set_devctl - Write device control reg</span>
<span class="cm"> *	@ap: port where the device is</span>
<span class="cm"> *	@ctl: value to write</span>
<span class="cm"> *</span>
<span class="cm"> *	Writes ATA taskfile device control register.</span>
<span class="cm"> *</span>
<span class="cm"> *	Note: may NOT be used as the sff_set_devctl() entry in</span>
<span class="cm"> *	ata_port_operations.</span>
<span class="cm"> *</span>
<span class="cm"> *	LOCKING:</span>
<span class="cm"> *	Inherited from caller.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">ata_sff_set_devctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span><span class="p">,</span> <span class="n">u8</span> <span class="n">ctl</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">sff_set_devctl</span><span class="p">)</span>
		<span class="n">ap</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">sff_set_devctl</span><span class="p">(</span><span class="n">ap</span><span class="p">,</span> <span class="n">ctl</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">iowrite8</span><span class="p">(</span><span class="n">ctl</span><span class="p">,</span> <span class="n">ap</span><span class="o">-&gt;</span><span class="n">ioaddr</span><span class="p">.</span><span class="n">ctl_addr</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	ata_sff_dev_select - Select device 0/1 on ATA bus</span>
<span class="cm"> *	@ap: ATA channel to manipulate</span>
<span class="cm"> *	@device: ATA device (numbered from zero) to select</span>
<span class="cm"> *</span>
<span class="cm"> *	Use the method defined in the ATA specification to</span>
<span class="cm"> *	make either device 0, or device 1, active on the</span>
<span class="cm"> *	ATA channel.  Works with both PIO and MMIO.</span>
<span class="cm"> *</span>
<span class="cm"> *	May be used as the dev_select() entry in ata_port_operations.</span>
<span class="cm"> *</span>
<span class="cm"> *	LOCKING:</span>
<span class="cm"> *	caller.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">ata_sff_dev_select</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">device</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u8</span> <span class="n">tmp</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">device</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">tmp</span> <span class="o">=</span> <span class="n">ATA_DEVICE_OBS</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">tmp</span> <span class="o">=</span> <span class="n">ATA_DEVICE_OBS</span> <span class="o">|</span> <span class="n">ATA_DEV1</span><span class="p">;</span>

	<span class="n">iowrite8</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="n">ap</span><span class="o">-&gt;</span><span class="n">ioaddr</span><span class="p">.</span><span class="n">device_addr</span><span class="p">);</span>
	<span class="n">ata_sff_pause</span><span class="p">(</span><span class="n">ap</span><span class="p">);</span>	<span class="cm">/* needed; also flushes, for mmio */</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">ata_sff_dev_select</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> *	ata_dev_select - Select device 0/1 on ATA bus</span>
<span class="cm"> *	@ap: ATA channel to manipulate</span>
<span class="cm"> *	@device: ATA device (numbered from zero) to select</span>
<span class="cm"> *	@wait: non-zero to wait for Status register BSY bit to clear</span>
<span class="cm"> *	@can_sleep: non-zero if context allows sleeping</span>
<span class="cm"> *</span>
<span class="cm"> *	Use the method defined in the ATA specification to</span>
<span class="cm"> *	make either device 0, or device 1, active on the</span>
<span class="cm"> *	ATA channel.</span>
<span class="cm"> *</span>
<span class="cm"> *	This is a high-level version of ata_sff_dev_select(), which</span>
<span class="cm"> *	additionally provides the services of inserting the proper</span>
<span class="cm"> *	pauses and status polling, where needed.</span>
<span class="cm"> *</span>
<span class="cm"> *	LOCKING:</span>
<span class="cm"> *	caller.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">ata_dev_select</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">device</span><span class="p">,</span>
			   <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">wait</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">can_sleep</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ata_msg_probe</span><span class="p">(</span><span class="n">ap</span><span class="p">))</span>
		<span class="n">ata_port_info</span><span class="p">(</span><span class="n">ap</span><span class="p">,</span> <span class="s">&quot;ata_dev_select: ENTER, device %u, wait %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			      <span class="n">device</span><span class="p">,</span> <span class="n">wait</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">wait</span><span class="p">)</span>
		<span class="n">ata_wait_idle</span><span class="p">(</span><span class="n">ap</span><span class="p">);</span>

	<span class="n">ap</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">sff_dev_select</span><span class="p">(</span><span class="n">ap</span><span class="p">,</span> <span class="n">device</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">wait</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">can_sleep</span> <span class="o">&amp;&amp;</span> <span class="n">ap</span><span class="o">-&gt;</span><span class="n">link</span><span class="p">.</span><span class="n">device</span><span class="p">[</span><span class="n">device</span><span class="p">].</span><span class="n">class</span> <span class="o">==</span> <span class="n">ATA_DEV_ATAPI</span><span class="p">)</span>
			<span class="n">ata_msleep</span><span class="p">(</span><span class="n">ap</span><span class="p">,</span> <span class="mi">150</span><span class="p">);</span>
		<span class="n">ata_wait_idle</span><span class="p">(</span><span class="n">ap</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	ata_sff_irq_on - Enable interrupts on a port.</span>
<span class="cm"> *	@ap: Port on which interrupts are enabled.</span>
<span class="cm"> *</span>
<span class="cm"> *	Enable interrupts on a legacy IDE device using MMIO or PIO,</span>
<span class="cm"> *	wait for idle, clear any pending interrupts.</span>
<span class="cm"> *</span>
<span class="cm"> *	Note: may NOT be used as the sff_irq_on() entry in</span>
<span class="cm"> *	ata_port_operations.</span>
<span class="cm"> *</span>
<span class="cm"> *	LOCKING:</span>
<span class="cm"> *	Inherited from caller.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">ata_sff_irq_on</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ata_ioports</span> <span class="o">*</span><span class="n">ioaddr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">ioaddr</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">sff_irq_on</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ap</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">sff_irq_on</span><span class="p">(</span><span class="n">ap</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ap</span><span class="o">-&gt;</span><span class="n">ctl</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">ATA_NIEN</span><span class="p">;</span>
	<span class="n">ap</span><span class="o">-&gt;</span><span class="n">last_ctl</span> <span class="o">=</span> <span class="n">ap</span><span class="o">-&gt;</span><span class="n">ctl</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">sff_set_devctl</span> <span class="o">||</span> <span class="n">ioaddr</span><span class="o">-&gt;</span><span class="n">ctl_addr</span><span class="p">)</span>
		<span class="n">ata_sff_set_devctl</span><span class="p">(</span><span class="n">ap</span><span class="p">,</span> <span class="n">ap</span><span class="o">-&gt;</span><span class="n">ctl</span><span class="p">);</span>
	<span class="n">ata_wait_idle</span><span class="p">(</span><span class="n">ap</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">sff_irq_clear</span><span class="p">)</span>
		<span class="n">ap</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">sff_irq_clear</span><span class="p">(</span><span class="n">ap</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">ata_sff_irq_on</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> *	ata_sff_tf_load - send taskfile registers to host controller</span>
<span class="cm"> *	@ap: Port to which output is sent</span>
<span class="cm"> *	@tf: ATA taskfile register set</span>
<span class="cm"> *</span>
<span class="cm"> *	Outputs ATA taskfile to standard ATA host controller.</span>
<span class="cm"> *</span>
<span class="cm"> *	LOCKING:</span>
<span class="cm"> *	Inherited from caller.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">ata_sff_tf_load</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">ata_taskfile</span> <span class="o">*</span><span class="n">tf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ata_ioports</span> <span class="o">*</span><span class="n">ioaddr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">ioaddr</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">is_addr</span> <span class="o">=</span> <span class="n">tf</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">ATA_TFLAG_ISADDR</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">tf</span><span class="o">-&gt;</span><span class="n">ctl</span> <span class="o">!=</span> <span class="n">ap</span><span class="o">-&gt;</span><span class="n">last_ctl</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ioaddr</span><span class="o">-&gt;</span><span class="n">ctl_addr</span><span class="p">)</span>
			<span class="n">iowrite8</span><span class="p">(</span><span class="n">tf</span><span class="o">-&gt;</span><span class="n">ctl</span><span class="p">,</span> <span class="n">ioaddr</span><span class="o">-&gt;</span><span class="n">ctl_addr</span><span class="p">);</span>
		<span class="n">ap</span><span class="o">-&gt;</span><span class="n">last_ctl</span> <span class="o">=</span> <span class="n">tf</span><span class="o">-&gt;</span><span class="n">ctl</span><span class="p">;</span>
		<span class="n">ata_wait_idle</span><span class="p">(</span><span class="n">ap</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">is_addr</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">tf</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">ATA_TFLAG_LBA48</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">WARN_ON_ONCE</span><span class="p">(</span><span class="o">!</span><span class="n">ioaddr</span><span class="o">-&gt;</span><span class="n">ctl_addr</span><span class="p">);</span>
		<span class="n">iowrite8</span><span class="p">(</span><span class="n">tf</span><span class="o">-&gt;</span><span class="n">hob_feature</span><span class="p">,</span> <span class="n">ioaddr</span><span class="o">-&gt;</span><span class="n">feature_addr</span><span class="p">);</span>
		<span class="n">iowrite8</span><span class="p">(</span><span class="n">tf</span><span class="o">-&gt;</span><span class="n">hob_nsect</span><span class="p">,</span> <span class="n">ioaddr</span><span class="o">-&gt;</span><span class="n">nsect_addr</span><span class="p">);</span>
		<span class="n">iowrite8</span><span class="p">(</span><span class="n">tf</span><span class="o">-&gt;</span><span class="n">hob_lbal</span><span class="p">,</span> <span class="n">ioaddr</span><span class="o">-&gt;</span><span class="n">lbal_addr</span><span class="p">);</span>
		<span class="n">iowrite8</span><span class="p">(</span><span class="n">tf</span><span class="o">-&gt;</span><span class="n">hob_lbam</span><span class="p">,</span> <span class="n">ioaddr</span><span class="o">-&gt;</span><span class="n">lbam_addr</span><span class="p">);</span>
		<span class="n">iowrite8</span><span class="p">(</span><span class="n">tf</span><span class="o">-&gt;</span><span class="n">hob_lbah</span><span class="p">,</span> <span class="n">ioaddr</span><span class="o">-&gt;</span><span class="n">lbah_addr</span><span class="p">);</span>
		<span class="n">VPRINTK</span><span class="p">(</span><span class="s">&quot;hob: feat 0x%X nsect 0x%X, lba 0x%X 0x%X 0x%X</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">tf</span><span class="o">-&gt;</span><span class="n">hob_feature</span><span class="p">,</span>
			<span class="n">tf</span><span class="o">-&gt;</span><span class="n">hob_nsect</span><span class="p">,</span>
			<span class="n">tf</span><span class="o">-&gt;</span><span class="n">hob_lbal</span><span class="p">,</span>
			<span class="n">tf</span><span class="o">-&gt;</span><span class="n">hob_lbam</span><span class="p">,</span>
			<span class="n">tf</span><span class="o">-&gt;</span><span class="n">hob_lbah</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">is_addr</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">iowrite8</span><span class="p">(</span><span class="n">tf</span><span class="o">-&gt;</span><span class="n">feature</span><span class="p">,</span> <span class="n">ioaddr</span><span class="o">-&gt;</span><span class="n">feature_addr</span><span class="p">);</span>
		<span class="n">iowrite8</span><span class="p">(</span><span class="n">tf</span><span class="o">-&gt;</span><span class="n">nsect</span><span class="p">,</span> <span class="n">ioaddr</span><span class="o">-&gt;</span><span class="n">nsect_addr</span><span class="p">);</span>
		<span class="n">iowrite8</span><span class="p">(</span><span class="n">tf</span><span class="o">-&gt;</span><span class="n">lbal</span><span class="p">,</span> <span class="n">ioaddr</span><span class="o">-&gt;</span><span class="n">lbal_addr</span><span class="p">);</span>
		<span class="n">iowrite8</span><span class="p">(</span><span class="n">tf</span><span class="o">-&gt;</span><span class="n">lbam</span><span class="p">,</span> <span class="n">ioaddr</span><span class="o">-&gt;</span><span class="n">lbam_addr</span><span class="p">);</span>
		<span class="n">iowrite8</span><span class="p">(</span><span class="n">tf</span><span class="o">-&gt;</span><span class="n">lbah</span><span class="p">,</span> <span class="n">ioaddr</span><span class="o">-&gt;</span><span class="n">lbah_addr</span><span class="p">);</span>
		<span class="n">VPRINTK</span><span class="p">(</span><span class="s">&quot;feat 0x%X nsect 0x%X lba 0x%X 0x%X 0x%X</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">tf</span><span class="o">-&gt;</span><span class="n">feature</span><span class="p">,</span>
			<span class="n">tf</span><span class="o">-&gt;</span><span class="n">nsect</span><span class="p">,</span>
			<span class="n">tf</span><span class="o">-&gt;</span><span class="n">lbal</span><span class="p">,</span>
			<span class="n">tf</span><span class="o">-&gt;</span><span class="n">lbam</span><span class="p">,</span>
			<span class="n">tf</span><span class="o">-&gt;</span><span class="n">lbah</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">tf</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">ATA_TFLAG_DEVICE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">iowrite8</span><span class="p">(</span><span class="n">tf</span><span class="o">-&gt;</span><span class="n">device</span><span class="p">,</span> <span class="n">ioaddr</span><span class="o">-&gt;</span><span class="n">device_addr</span><span class="p">);</span>
		<span class="n">VPRINTK</span><span class="p">(</span><span class="s">&quot;device 0x%X</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">tf</span><span class="o">-&gt;</span><span class="n">device</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">ata_wait_idle</span><span class="p">(</span><span class="n">ap</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">ata_sff_tf_load</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> *	ata_sff_tf_read - input device&#39;s ATA taskfile shadow registers</span>
<span class="cm"> *	@ap: Port from which input is read</span>
<span class="cm"> *	@tf: ATA taskfile register set for storing input</span>
<span class="cm"> *</span>
<span class="cm"> *	Reads ATA taskfile registers for currently-selected device</span>
<span class="cm"> *	into @tf. Assumes the device has a fully SFF compliant task file</span>
<span class="cm"> *	layout and behaviour. If you device does not (eg has a different</span>
<span class="cm"> *	status method) then you will need to provide a replacement tf_read</span>
<span class="cm"> *</span>
<span class="cm"> *	LOCKING:</span>
<span class="cm"> *	Inherited from caller.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">ata_sff_tf_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ata_taskfile</span> <span class="o">*</span><span class="n">tf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ata_ioports</span> <span class="o">*</span><span class="n">ioaddr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">ioaddr</span><span class="p">;</span>

	<span class="n">tf</span><span class="o">-&gt;</span><span class="n">command</span> <span class="o">=</span> <span class="n">ata_sff_check_status</span><span class="p">(</span><span class="n">ap</span><span class="p">);</span>
	<span class="n">tf</span><span class="o">-&gt;</span><span class="n">feature</span> <span class="o">=</span> <span class="n">ioread8</span><span class="p">(</span><span class="n">ioaddr</span><span class="o">-&gt;</span><span class="n">error_addr</span><span class="p">);</span>
	<span class="n">tf</span><span class="o">-&gt;</span><span class="n">nsect</span> <span class="o">=</span> <span class="n">ioread8</span><span class="p">(</span><span class="n">ioaddr</span><span class="o">-&gt;</span><span class="n">nsect_addr</span><span class="p">);</span>
	<span class="n">tf</span><span class="o">-&gt;</span><span class="n">lbal</span> <span class="o">=</span> <span class="n">ioread8</span><span class="p">(</span><span class="n">ioaddr</span><span class="o">-&gt;</span><span class="n">lbal_addr</span><span class="p">);</span>
	<span class="n">tf</span><span class="o">-&gt;</span><span class="n">lbam</span> <span class="o">=</span> <span class="n">ioread8</span><span class="p">(</span><span class="n">ioaddr</span><span class="o">-&gt;</span><span class="n">lbam_addr</span><span class="p">);</span>
	<span class="n">tf</span><span class="o">-&gt;</span><span class="n">lbah</span> <span class="o">=</span> <span class="n">ioread8</span><span class="p">(</span><span class="n">ioaddr</span><span class="o">-&gt;</span><span class="n">lbah_addr</span><span class="p">);</span>
	<span class="n">tf</span><span class="o">-&gt;</span><span class="n">device</span> <span class="o">=</span> <span class="n">ioread8</span><span class="p">(</span><span class="n">ioaddr</span><span class="o">-&gt;</span><span class="n">device_addr</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">tf</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">ATA_TFLAG_LBA48</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">ioaddr</span><span class="o">-&gt;</span><span class="n">ctl_addr</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">iowrite8</span><span class="p">(</span><span class="n">tf</span><span class="o">-&gt;</span><span class="n">ctl</span> <span class="o">|</span> <span class="n">ATA_HOB</span><span class="p">,</span> <span class="n">ioaddr</span><span class="o">-&gt;</span><span class="n">ctl_addr</span><span class="p">);</span>
			<span class="n">tf</span><span class="o">-&gt;</span><span class="n">hob_feature</span> <span class="o">=</span> <span class="n">ioread8</span><span class="p">(</span><span class="n">ioaddr</span><span class="o">-&gt;</span><span class="n">error_addr</span><span class="p">);</span>
			<span class="n">tf</span><span class="o">-&gt;</span><span class="n">hob_nsect</span> <span class="o">=</span> <span class="n">ioread8</span><span class="p">(</span><span class="n">ioaddr</span><span class="o">-&gt;</span><span class="n">nsect_addr</span><span class="p">);</span>
			<span class="n">tf</span><span class="o">-&gt;</span><span class="n">hob_lbal</span> <span class="o">=</span> <span class="n">ioread8</span><span class="p">(</span><span class="n">ioaddr</span><span class="o">-&gt;</span><span class="n">lbal_addr</span><span class="p">);</span>
			<span class="n">tf</span><span class="o">-&gt;</span><span class="n">hob_lbam</span> <span class="o">=</span> <span class="n">ioread8</span><span class="p">(</span><span class="n">ioaddr</span><span class="o">-&gt;</span><span class="n">lbam_addr</span><span class="p">);</span>
			<span class="n">tf</span><span class="o">-&gt;</span><span class="n">hob_lbah</span> <span class="o">=</span> <span class="n">ioread8</span><span class="p">(</span><span class="n">ioaddr</span><span class="o">-&gt;</span><span class="n">lbah_addr</span><span class="p">);</span>
			<span class="n">iowrite8</span><span class="p">(</span><span class="n">tf</span><span class="o">-&gt;</span><span class="n">ctl</span><span class="p">,</span> <span class="n">ioaddr</span><span class="o">-&gt;</span><span class="n">ctl_addr</span><span class="p">);</span>
			<span class="n">ap</span><span class="o">-&gt;</span><span class="n">last_ctl</span> <span class="o">=</span> <span class="n">tf</span><span class="o">-&gt;</span><span class="n">ctl</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="n">WARN_ON_ONCE</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">ata_sff_tf_read</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> *	ata_sff_exec_command - issue ATA command to host controller</span>
<span class="cm"> *	@ap: port to which command is being issued</span>
<span class="cm"> *	@tf: ATA taskfile register set</span>
<span class="cm"> *</span>
<span class="cm"> *	Issues ATA command, with proper synchronization with interrupt</span>
<span class="cm"> *	handler / other threads.</span>
<span class="cm"> *</span>
<span class="cm"> *	LOCKING:</span>
<span class="cm"> *	spin_lock_irqsave(host lock)</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">ata_sff_exec_command</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">ata_taskfile</span> <span class="o">*</span><span class="n">tf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">DPRINTK</span><span class="p">(</span><span class="s">&quot;ata%u: cmd 0x%X</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ap</span><span class="o">-&gt;</span><span class="n">print_id</span><span class="p">,</span> <span class="n">tf</span><span class="o">-&gt;</span><span class="n">command</span><span class="p">);</span>

	<span class="n">iowrite8</span><span class="p">(</span><span class="n">tf</span><span class="o">-&gt;</span><span class="n">command</span><span class="p">,</span> <span class="n">ap</span><span class="o">-&gt;</span><span class="n">ioaddr</span><span class="p">.</span><span class="n">command_addr</span><span class="p">);</span>
	<span class="n">ata_sff_pause</span><span class="p">(</span><span class="n">ap</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">ata_sff_exec_command</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> *	ata_tf_to_host - issue ATA taskfile to host controller</span>
<span class="cm"> *	@ap: port to which command is being issued</span>
<span class="cm"> *	@tf: ATA taskfile register set</span>
<span class="cm"> *</span>
<span class="cm"> *	Issues ATA taskfile register set to ATA host controller,</span>
<span class="cm"> *	with proper synchronization with interrupt handler and</span>
<span class="cm"> *	other threads.</span>
<span class="cm"> *</span>
<span class="cm"> *	LOCKING:</span>
<span class="cm"> *	spin_lock_irqsave(host lock)</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">ata_tf_to_host</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span><span class="p">,</span>
				  <span class="k">const</span> <span class="k">struct</span> <span class="n">ata_taskfile</span> <span class="o">*</span><span class="n">tf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ap</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">sff_tf_load</span><span class="p">(</span><span class="n">ap</span><span class="p">,</span> <span class="n">tf</span><span class="p">);</span>
	<span class="n">ap</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">sff_exec_command</span><span class="p">(</span><span class="n">ap</span><span class="p">,</span> <span class="n">tf</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	ata_sff_data_xfer - Transfer data by PIO</span>
<span class="cm"> *	@dev: device to target</span>
<span class="cm"> *	@buf: data buffer</span>
<span class="cm"> *	@buflen: buffer length</span>
<span class="cm"> *	@rw: read/write</span>
<span class="cm"> *</span>
<span class="cm"> *	Transfer data from/to the device data register by PIO.</span>
<span class="cm"> *</span>
<span class="cm"> *	LOCKING:</span>
<span class="cm"> *	Inherited from caller.</span>
<span class="cm"> *</span>
<span class="cm"> *	RETURNS:</span>
<span class="cm"> *	Bytes consumed.</span>
<span class="cm"> */</span>
<span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">ata_sff_data_xfer</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span>
			       <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">buflen</span><span class="p">,</span> <span class="kt">int</span> <span class="n">rw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">link</span><span class="o">-&gt;</span><span class="n">ap</span><span class="p">;</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">data_addr</span> <span class="o">=</span> <span class="n">ap</span><span class="o">-&gt;</span><span class="n">ioaddr</span><span class="p">.</span><span class="n">data_addr</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">words</span> <span class="o">=</span> <span class="n">buflen</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/* Transfer multiple of 2 bytes */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rw</span> <span class="o">==</span> <span class="n">READ</span><span class="p">)</span>
		<span class="n">ioread16_rep</span><span class="p">(</span><span class="n">data_addr</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">words</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">iowrite16_rep</span><span class="p">(</span><span class="n">data_addr</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">words</span><span class="p">);</span>

	<span class="cm">/* Transfer trailing byte, if any. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">buflen</span> <span class="o">&amp;</span> <span class="mh">0x01</span><span class="p">))</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">pad</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="p">};</span>

		<span class="cm">/* Point buf to the tail of buffer */</span>
		<span class="n">buf</span> <span class="o">+=</span> <span class="n">buflen</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * Use io*16_rep() accessors here as well to avoid pointlessly</span>
<span class="cm">		 * swapping bytes to and from on the big endian machines...</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rw</span> <span class="o">==</span> <span class="n">READ</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ioread16_rep</span><span class="p">(</span><span class="n">data_addr</span><span class="p">,</span> <span class="n">pad</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
			<span class="o">*</span><span class="n">buf</span> <span class="o">=</span> <span class="n">pad</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">pad</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="o">*</span><span class="n">buf</span><span class="p">;</span>
			<span class="n">iowrite16_rep</span><span class="p">(</span><span class="n">data_addr</span><span class="p">,</span> <span class="n">pad</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">words</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">words</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">ata_sff_data_xfer</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> *	ata_sff_data_xfer32 - Transfer data by PIO</span>
<span class="cm"> *	@dev: device to target</span>
<span class="cm"> *	@buf: data buffer</span>
<span class="cm"> *	@buflen: buffer length</span>
<span class="cm"> *	@rw: read/write</span>
<span class="cm"> *</span>
<span class="cm"> *	Transfer data from/to the device data register by PIO using 32bit</span>
<span class="cm"> *	I/O operations.</span>
<span class="cm"> *</span>
<span class="cm"> *	LOCKING:</span>
<span class="cm"> *	Inherited from caller.</span>
<span class="cm"> *</span>
<span class="cm"> *	RETURNS:</span>
<span class="cm"> *	Bytes consumed.</span>
<span class="cm"> */</span>

<span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">ata_sff_data_xfer32</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span>
			       <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">buflen</span><span class="p">,</span> <span class="kt">int</span> <span class="n">rw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">link</span><span class="o">-&gt;</span><span class="n">ap</span><span class="p">;</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">data_addr</span> <span class="o">=</span> <span class="n">ap</span><span class="o">-&gt;</span><span class="n">ioaddr</span><span class="p">.</span><span class="n">data_addr</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">words</span> <span class="o">=</span> <span class="n">buflen</span> <span class="o">&gt;&gt;</span> <span class="mi">2</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">slop</span> <span class="o">=</span> <span class="n">buflen</span> <span class="o">&amp;</span> <span class="mi">3</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">pflags</span> <span class="o">&amp;</span> <span class="n">ATA_PFLAG_PIO32</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">ata_sff_data_xfer</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">buflen</span><span class="p">,</span> <span class="n">rw</span><span class="p">);</span>

	<span class="cm">/* Transfer multiple of 4 bytes */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rw</span> <span class="o">==</span> <span class="n">READ</span><span class="p">)</span>
		<span class="n">ioread32_rep</span><span class="p">(</span><span class="n">data_addr</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">words</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">iowrite32_rep</span><span class="p">(</span><span class="n">data_addr</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">words</span><span class="p">);</span>

	<span class="cm">/* Transfer trailing bytes, if any */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">slop</span><span class="p">))</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">pad</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="p">};</span>

		<span class="cm">/* Point buf to the tail of buffer */</span>
		<span class="n">buf</span> <span class="o">+=</span> <span class="n">buflen</span> <span class="o">-</span> <span class="n">slop</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * Use io*_rep() accessors here as well to avoid pointlessly</span>
<span class="cm">		 * swapping bytes to and from on the big endian machines...</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rw</span> <span class="o">==</span> <span class="n">READ</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">slop</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">)</span>
				<span class="n">ioread16_rep</span><span class="p">(</span><span class="n">data_addr</span><span class="p">,</span> <span class="n">pad</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
			<span class="k">else</span>
				<span class="n">ioread32_rep</span><span class="p">(</span><span class="n">data_addr</span><span class="p">,</span> <span class="n">pad</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
			<span class="n">memcpy</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">pad</span><span class="p">,</span> <span class="n">slop</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">memcpy</span><span class="p">(</span><span class="n">pad</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">slop</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">slop</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">)</span>
				<span class="n">iowrite16_rep</span><span class="p">(</span><span class="n">data_addr</span><span class="p">,</span> <span class="n">pad</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
			<span class="k">else</span>
				<span class="n">iowrite32_rep</span><span class="p">(</span><span class="n">data_addr</span><span class="p">,</span> <span class="n">pad</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">buflen</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">ata_sff_data_xfer32</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> *	ata_sff_data_xfer_noirq - Transfer data by PIO</span>
<span class="cm"> *	@dev: device to target</span>
<span class="cm"> *	@buf: data buffer</span>
<span class="cm"> *	@buflen: buffer length</span>
<span class="cm"> *	@rw: read/write</span>
<span class="cm"> *</span>
<span class="cm"> *	Transfer data from/to the device data register by PIO. Do the</span>
<span class="cm"> *	transfer with interrupts disabled.</span>
<span class="cm"> *</span>
<span class="cm"> *	LOCKING:</span>
<span class="cm"> *	Inherited from caller.</span>
<span class="cm"> *</span>
<span class="cm"> *	RETURNS:</span>
<span class="cm"> *	Bytes consumed.</span>
<span class="cm"> */</span>
<span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">ata_sff_data_xfer_noirq</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span>
				     <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">buflen</span><span class="p">,</span> <span class="kt">int</span> <span class="n">rw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">consumed</span><span class="p">;</span>

	<span class="n">local_irq_save</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
	<span class="n">consumed</span> <span class="o">=</span> <span class="n">ata_sff_data_xfer32</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">buflen</span><span class="p">,</span> <span class="n">rw</span><span class="p">);</span>
	<span class="n">local_irq_restore</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">consumed</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">ata_sff_data_xfer_noirq</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> *	ata_pio_sector - Transfer a sector of data.</span>
<span class="cm"> *	@qc: Command on going</span>
<span class="cm"> *</span>
<span class="cm"> *	Transfer qc-&gt;sect_size bytes of data from/to the ATA device.</span>
<span class="cm"> *</span>
<span class="cm"> *	LOCKING:</span>
<span class="cm"> *	Inherited from caller.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">ata_pio_sector</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_queued_cmd</span> <span class="o">*</span><span class="n">qc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">do_write</span> <span class="o">=</span> <span class="p">(</span><span class="n">qc</span><span class="o">-&gt;</span><span class="n">tf</span><span class="p">.</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">ATA_TFLAG_WRITE</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span> <span class="o">=</span> <span class="n">qc</span><span class="o">-&gt;</span><span class="n">ap</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">offset</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">qc</span><span class="o">-&gt;</span><span class="n">curbytes</span> <span class="o">==</span> <span class="n">qc</span><span class="o">-&gt;</span><span class="n">nbytes</span> <span class="o">-</span> <span class="n">qc</span><span class="o">-&gt;</span><span class="n">sect_size</span><span class="p">)</span>
		<span class="n">ap</span><span class="o">-&gt;</span><span class="n">hsm_task_state</span> <span class="o">=</span> <span class="n">HSM_ST_LAST</span><span class="p">;</span>

	<span class="n">page</span> <span class="o">=</span> <span class="n">sg_page</span><span class="p">(</span><span class="n">qc</span><span class="o">-&gt;</span><span class="n">cursg</span><span class="p">);</span>
	<span class="n">offset</span> <span class="o">=</span> <span class="n">qc</span><span class="o">-&gt;</span><span class="n">cursg</span><span class="o">-&gt;</span><span class="n">offset</span> <span class="o">+</span> <span class="n">qc</span><span class="o">-&gt;</span><span class="n">cursg_ofs</span><span class="p">;</span>

	<span class="cm">/* get the current page and offset */</span>
	<span class="n">page</span> <span class="o">=</span> <span class="n">nth_page</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="p">(</span><span class="n">offset</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">));</span>
	<span class="n">offset</span> <span class="o">%=</span> <span class="n">PAGE_SIZE</span><span class="p">;</span>

	<span class="n">DPRINTK</span><span class="p">(</span><span class="s">&quot;data %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">qc</span><span class="o">-&gt;</span><span class="n">tf</span><span class="p">.</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">ATA_TFLAG_WRITE</span> <span class="o">?</span> <span class="s">&quot;write&quot;</span> <span class="o">:</span> <span class="s">&quot;read&quot;</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">PageHighMem</span><span class="p">(</span><span class="n">page</span><span class="p">))</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

		<span class="cm">/* FIXME: use a bounce buffer */</span>
		<span class="n">local_irq_save</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
		<span class="n">buf</span> <span class="o">=</span> <span class="n">kmap_atomic</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>

		<span class="cm">/* do the actual data transfer */</span>
		<span class="n">ap</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">sff_data_xfer</span><span class="p">(</span><span class="n">qc</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">buf</span> <span class="o">+</span> <span class="n">offset</span><span class="p">,</span> <span class="n">qc</span><span class="o">-&gt;</span><span class="n">sect_size</span><span class="p">,</span>
				       <span class="n">do_write</span><span class="p">);</span>

		<span class="n">kunmap_atomic</span><span class="p">(</span><span class="n">buf</span><span class="p">);</span>
		<span class="n">local_irq_restore</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">buf</span> <span class="o">=</span> <span class="n">page_address</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="n">ap</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">sff_data_xfer</span><span class="p">(</span><span class="n">qc</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">buf</span> <span class="o">+</span> <span class="n">offset</span><span class="p">,</span> <span class="n">qc</span><span class="o">-&gt;</span><span class="n">sect_size</span><span class="p">,</span>
				       <span class="n">do_write</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">do_write</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">PageSlab</span><span class="p">(</span><span class="n">page</span><span class="p">))</span>
		<span class="n">flush_dcache_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>

	<span class="n">qc</span><span class="o">-&gt;</span><span class="n">curbytes</span> <span class="o">+=</span> <span class="n">qc</span><span class="o">-&gt;</span><span class="n">sect_size</span><span class="p">;</span>
	<span class="n">qc</span><span class="o">-&gt;</span><span class="n">cursg_ofs</span> <span class="o">+=</span> <span class="n">qc</span><span class="o">-&gt;</span><span class="n">sect_size</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">qc</span><span class="o">-&gt;</span><span class="n">cursg_ofs</span> <span class="o">==</span> <span class="n">qc</span><span class="o">-&gt;</span><span class="n">cursg</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">qc</span><span class="o">-&gt;</span><span class="n">cursg</span> <span class="o">=</span> <span class="n">sg_next</span><span class="p">(</span><span class="n">qc</span><span class="o">-&gt;</span><span class="n">cursg</span><span class="p">);</span>
		<span class="n">qc</span><span class="o">-&gt;</span><span class="n">cursg_ofs</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	ata_pio_sectors - Transfer one or many sectors.</span>
<span class="cm"> *	@qc: Command on going</span>
<span class="cm"> *</span>
<span class="cm"> *	Transfer one or many sectors of data from/to the</span>
<span class="cm"> *	ATA device for the DRQ request.</span>
<span class="cm"> *</span>
<span class="cm"> *	LOCKING:</span>
<span class="cm"> *	Inherited from caller.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">ata_pio_sectors</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_queued_cmd</span> <span class="o">*</span><span class="n">qc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">is_multi_taskfile</span><span class="p">(</span><span class="o">&amp;</span><span class="n">qc</span><span class="o">-&gt;</span><span class="n">tf</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* READ/WRITE MULTIPLE */</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">nsect</span><span class="p">;</span>

		<span class="n">WARN_ON_ONCE</span><span class="p">(</span><span class="n">qc</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">multi_count</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>

		<span class="n">nsect</span> <span class="o">=</span> <span class="n">min</span><span class="p">((</span><span class="n">qc</span><span class="o">-&gt;</span><span class="n">nbytes</span> <span class="o">-</span> <span class="n">qc</span><span class="o">-&gt;</span><span class="n">curbytes</span><span class="p">)</span> <span class="o">/</span> <span class="n">qc</span><span class="o">-&gt;</span><span class="n">sect_size</span><span class="p">,</span>
			    <span class="n">qc</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">multi_count</span><span class="p">);</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">nsect</span><span class="o">--</span><span class="p">)</span>
			<span class="n">ata_pio_sector</span><span class="p">(</span><span class="n">qc</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">ata_pio_sector</span><span class="p">(</span><span class="n">qc</span><span class="p">);</span>

	<span class="n">ata_sff_sync</span><span class="p">(</span><span class="n">qc</span><span class="o">-&gt;</span><span class="n">ap</span><span class="p">);</span> <span class="cm">/* flush */</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	atapi_send_cdb - Write CDB bytes to hardware</span>
<span class="cm"> *	@ap: Port to which ATAPI device is attached.</span>
<span class="cm"> *	@qc: Taskfile currently active</span>
<span class="cm"> *</span>
<span class="cm"> *	When device has indicated its readiness to accept</span>
<span class="cm"> *	a CDB, this function is called.  Send the CDB.</span>
<span class="cm"> *</span>
<span class="cm"> *	LOCKING:</span>
<span class="cm"> *	caller.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">atapi_send_cdb</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ata_queued_cmd</span> <span class="o">*</span><span class="n">qc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* send SCSI cdb */</span>
	<span class="n">DPRINTK</span><span class="p">(</span><span class="s">&quot;send cdb</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">WARN_ON_ONCE</span><span class="p">(</span><span class="n">qc</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">cdb_len</span> <span class="o">&lt;</span> <span class="mi">12</span><span class="p">);</span>

	<span class="n">ap</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">sff_data_xfer</span><span class="p">(</span><span class="n">qc</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">qc</span><span class="o">-&gt;</span><span class="n">cdb</span><span class="p">,</span> <span class="n">qc</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">cdb_len</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">ata_sff_sync</span><span class="p">(</span><span class="n">ap</span><span class="p">);</span>
	<span class="cm">/* FIXME: If the CDB is for DMA do we need to do the transition delay</span>
<span class="cm">	   or is bmdma_start guaranteed to do it ? */</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">qc</span><span class="o">-&gt;</span><span class="n">tf</span><span class="p">.</span><span class="n">protocol</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">ATAPI_PROT_PIO</span>:
		<span class="n">ap</span><span class="o">-&gt;</span><span class="n">hsm_task_state</span> <span class="o">=</span> <span class="n">HSM_ST</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">ATAPI_PROT_NODATA</span>:
		<span class="n">ap</span><span class="o">-&gt;</span><span class="n">hsm_task_state</span> <span class="o">=</span> <span class="n">HSM_ST_LAST</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
<span class="cp">#ifdef CONFIG_ATA_BMDMA</span>
	<span class="k">case</span> <span class="n">ATAPI_PROT_DMA</span>:
		<span class="n">ap</span><span class="o">-&gt;</span><span class="n">hsm_task_state</span> <span class="o">=</span> <span class="n">HSM_ST_LAST</span><span class="p">;</span>
		<span class="cm">/* initiate bmdma */</span>
		<span class="n">ap</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">bmdma_start</span><span class="p">(</span><span class="n">qc</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_ATA_BMDMA */</span><span class="cp"></span>
	<span class="nl">default:</span>
		<span class="n">BUG</span><span class="p">();</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	__atapi_pio_bytes - Transfer data from/to the ATAPI device.</span>
<span class="cm"> *	@qc: Command on going</span>
<span class="cm"> *	@bytes: number of bytes</span>
<span class="cm"> *</span>
<span class="cm"> *	Transfer Transfer data from/to the ATAPI device.</span>
<span class="cm"> *</span>
<span class="cm"> *	LOCKING:</span>
<span class="cm"> *	Inherited from caller.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">__atapi_pio_bytes</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_queued_cmd</span> <span class="o">*</span><span class="n">qc</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">bytes</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rw</span> <span class="o">=</span> <span class="p">(</span><span class="n">qc</span><span class="o">-&gt;</span><span class="n">tf</span><span class="p">.</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">ATA_TFLAG_WRITE</span><span class="p">)</span> <span class="o">?</span> <span class="n">WRITE</span> <span class="o">:</span> <span class="n">READ</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span> <span class="o">=</span> <span class="n">qc</span><span class="o">-&gt;</span><span class="n">ap</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ata_device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">qc</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ata_eh_info</span> <span class="o">*</span><span class="n">ehi</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">link</span><span class="o">-&gt;</span><span class="n">eh_info</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">scatterlist</span> <span class="o">*</span><span class="n">sg</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">offset</span><span class="p">,</span> <span class="n">count</span><span class="p">,</span> <span class="n">consumed</span><span class="p">;</span>

<span class="nl">next_sg:</span>
	<span class="n">sg</span> <span class="o">=</span> <span class="n">qc</span><span class="o">-&gt;</span><span class="n">cursg</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">sg</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ata_ehi_push_desc</span><span class="p">(</span><span class="n">ehi</span><span class="p">,</span> <span class="s">&quot;unexpected or too much trailing data &quot;</span>
				  <span class="s">&quot;buf=%u cur=%u bytes=%u&quot;</span><span class="p">,</span>
				  <span class="n">qc</span><span class="o">-&gt;</span><span class="n">nbytes</span><span class="p">,</span> <span class="n">qc</span><span class="o">-&gt;</span><span class="n">curbytes</span><span class="p">,</span> <span class="n">bytes</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">page</span> <span class="o">=</span> <span class="n">sg_page</span><span class="p">(</span><span class="n">sg</span><span class="p">);</span>
	<span class="n">offset</span> <span class="o">=</span> <span class="n">sg</span><span class="o">-&gt;</span><span class="n">offset</span> <span class="o">+</span> <span class="n">qc</span><span class="o">-&gt;</span><span class="n">cursg_ofs</span><span class="p">;</span>

	<span class="cm">/* get the current page and offset */</span>
	<span class="n">page</span> <span class="o">=</span> <span class="n">nth_page</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="p">(</span><span class="n">offset</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">));</span>
	<span class="n">offset</span> <span class="o">%=</span> <span class="n">PAGE_SIZE</span><span class="p">;</span>

	<span class="cm">/* don&#39;t overrun current sg */</span>
	<span class="n">count</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">sg</span><span class="o">-&gt;</span><span class="n">length</span> <span class="o">-</span> <span class="n">qc</span><span class="o">-&gt;</span><span class="n">cursg_ofs</span><span class="p">,</span> <span class="n">bytes</span><span class="p">);</span>

	<span class="cm">/* don&#39;t cross page boundaries */</span>
	<span class="n">count</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">count</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)</span><span class="n">PAGE_SIZE</span> <span class="o">-</span> <span class="n">offset</span><span class="p">);</span>

	<span class="n">DPRINTK</span><span class="p">(</span><span class="s">&quot;data %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">qc</span><span class="o">-&gt;</span><span class="n">tf</span><span class="p">.</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">ATA_TFLAG_WRITE</span> <span class="o">?</span> <span class="s">&quot;write&quot;</span> <span class="o">:</span> <span class="s">&quot;read&quot;</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">PageHighMem</span><span class="p">(</span><span class="n">page</span><span class="p">))</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

		<span class="cm">/* FIXME: use bounce buffer */</span>
		<span class="n">local_irq_save</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
		<span class="n">buf</span> <span class="o">=</span> <span class="n">kmap_atomic</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>

		<span class="cm">/* do the actual data transfer */</span>
		<span class="n">consumed</span> <span class="o">=</span> <span class="n">ap</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">sff_data_xfer</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span>  <span class="n">buf</span> <span class="o">+</span> <span class="n">offset</span><span class="p">,</span>
								<span class="n">count</span><span class="p">,</span> <span class="n">rw</span><span class="p">);</span>

		<span class="n">kunmap_atomic</span><span class="p">(</span><span class="n">buf</span><span class="p">);</span>
		<span class="n">local_irq_restore</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">buf</span> <span class="o">=</span> <span class="n">page_address</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="n">consumed</span> <span class="o">=</span> <span class="n">ap</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">sff_data_xfer</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span>  <span class="n">buf</span> <span class="o">+</span> <span class="n">offset</span><span class="p">,</span>
								<span class="n">count</span><span class="p">,</span> <span class="n">rw</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">bytes</span> <span class="o">-=</span> <span class="n">min</span><span class="p">(</span><span class="n">bytes</span><span class="p">,</span> <span class="n">consumed</span><span class="p">);</span>
	<span class="n">qc</span><span class="o">-&gt;</span><span class="n">curbytes</span> <span class="o">+=</span> <span class="n">count</span><span class="p">;</span>
	<span class="n">qc</span><span class="o">-&gt;</span><span class="n">cursg_ofs</span> <span class="o">+=</span> <span class="n">count</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">qc</span><span class="o">-&gt;</span><span class="n">cursg_ofs</span> <span class="o">==</span> <span class="n">sg</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">qc</span><span class="o">-&gt;</span><span class="n">cursg</span> <span class="o">=</span> <span class="n">sg_next</span><span class="p">(</span><span class="n">qc</span><span class="o">-&gt;</span><span class="n">cursg</span><span class="p">);</span>
		<span class="n">qc</span><span class="o">-&gt;</span><span class="n">cursg_ofs</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * There used to be a  WARN_ON_ONCE(qc-&gt;cursg &amp;&amp; count != consumed);</span>
<span class="cm">	 * Unfortunately __atapi_pio_bytes doesn&#39;t know enough to do the WARN</span>
<span class="cm">	 * check correctly as it doesn&#39;t know if it is the last request being</span>
<span class="cm">	 * made. Somebody should implement a proper sanity check.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bytes</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">next_sg</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	atapi_pio_bytes - Transfer data from/to the ATAPI device.</span>
<span class="cm"> *	@qc: Command on going</span>
<span class="cm"> *</span>
<span class="cm"> *	Transfer Transfer data from/to the ATAPI device.</span>
<span class="cm"> *</span>
<span class="cm"> *	LOCKING:</span>
<span class="cm"> *	Inherited from caller.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">atapi_pio_bytes</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_queued_cmd</span> <span class="o">*</span><span class="n">qc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span> <span class="o">=</span> <span class="n">qc</span><span class="o">-&gt;</span><span class="n">ap</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ata_device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">qc</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ata_eh_info</span> <span class="o">*</span><span class="n">ehi</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">link</span><span class="o">-&gt;</span><span class="n">eh_info</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ireason</span><span class="p">,</span> <span class="n">bc_lo</span><span class="p">,</span> <span class="n">bc_hi</span><span class="p">,</span> <span class="n">bytes</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i_write</span><span class="p">,</span> <span class="n">do_write</span> <span class="o">=</span> <span class="p">(</span><span class="n">qc</span><span class="o">-&gt;</span><span class="n">tf</span><span class="p">.</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">ATA_TFLAG_WRITE</span><span class="p">)</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Abuse qc-&gt;result_tf for temp storage of intermediate TF</span>
<span class="cm">	 * here to save some kernel stack usage.</span>
<span class="cm">	 * For normal completion, qc-&gt;result_tf is not relevant. For</span>
<span class="cm">	 * error, qc-&gt;result_tf is later overwritten by ata_qc_complete().</span>
<span class="cm">	 * So, the correctness of qc-&gt;result_tf is not affected.</span>
<span class="cm">	 */</span>
	<span class="n">ap</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">sff_tf_read</span><span class="p">(</span><span class="n">ap</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">qc</span><span class="o">-&gt;</span><span class="n">result_tf</span><span class="p">);</span>
	<span class="n">ireason</span> <span class="o">=</span> <span class="n">qc</span><span class="o">-&gt;</span><span class="n">result_tf</span><span class="p">.</span><span class="n">nsect</span><span class="p">;</span>
	<span class="n">bc_lo</span> <span class="o">=</span> <span class="n">qc</span><span class="o">-&gt;</span><span class="n">result_tf</span><span class="p">.</span><span class="n">lbam</span><span class="p">;</span>
	<span class="n">bc_hi</span> <span class="o">=</span> <span class="n">qc</span><span class="o">-&gt;</span><span class="n">result_tf</span><span class="p">.</span><span class="n">lbah</span><span class="p">;</span>
	<span class="n">bytes</span> <span class="o">=</span> <span class="p">(</span><span class="n">bc_hi</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">|</span> <span class="n">bc_lo</span><span class="p">;</span>

	<span class="cm">/* shall be cleared to zero, indicating xfer of data */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">ireason</span> <span class="o">&amp;</span> <span class="n">ATAPI_COD</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">atapi_check</span><span class="p">;</span>

	<span class="cm">/* make sure transfer direction matches expected */</span>
	<span class="n">i_write</span> <span class="o">=</span> <span class="p">((</span><span class="n">ireason</span> <span class="o">&amp;</span> <span class="n">ATAPI_IO</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">do_write</span> <span class="o">!=</span> <span class="n">i_write</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">atapi_check</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">bytes</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">atapi_check</span><span class="p">;</span>

	<span class="n">VPRINTK</span><span class="p">(</span><span class="s">&quot;ata%u: xfering %d bytes</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ap</span><span class="o">-&gt;</span><span class="n">print_id</span><span class="p">,</span> <span class="n">bytes</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">__atapi_pio_bytes</span><span class="p">(</span><span class="n">qc</span><span class="p">,</span> <span class="n">bytes</span><span class="p">)))</span>
		<span class="k">goto</span> <span class="n">err_out</span><span class="p">;</span>
	<span class="n">ata_sff_sync</span><span class="p">(</span><span class="n">ap</span><span class="p">);</span> <span class="cm">/* flush */</span>

	<span class="k">return</span><span class="p">;</span>

 <span class="nl">atapi_check:</span>
	<span class="n">ata_ehi_push_desc</span><span class="p">(</span><span class="n">ehi</span><span class="p">,</span> <span class="s">&quot;ATAPI check failed (ireason=0x%x bytes=%u)&quot;</span><span class="p">,</span>
			  <span class="n">ireason</span><span class="p">,</span> <span class="n">bytes</span><span class="p">);</span>
 <span class="nl">err_out:</span>
	<span class="n">qc</span><span class="o">-&gt;</span><span class="n">err_mask</span> <span class="o">|=</span> <span class="n">AC_ERR_HSM</span><span class="p">;</span>
	<span class="n">ap</span><span class="o">-&gt;</span><span class="n">hsm_task_state</span> <span class="o">=</span> <span class="n">HSM_ST_ERR</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	ata_hsm_ok_in_wq - Check if the qc can be handled in the workqueue.</span>
<span class="cm"> *	@ap: the target ata_port</span>
<span class="cm"> *	@qc: qc on going</span>
<span class="cm"> *</span>
<span class="cm"> *	RETURNS:</span>
<span class="cm"> *	1 if ok in workqueue, 0 otherwise.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">ata_hsm_ok_in_wq</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span><span class="p">,</span>
						<span class="k">struct</span> <span class="n">ata_queued_cmd</span> <span class="o">*</span><span class="n">qc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">qc</span><span class="o">-&gt;</span><span class="n">tf</span><span class="p">.</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">ATA_TFLAG_POLLING</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">hsm_task_state</span> <span class="o">==</span> <span class="n">HSM_ST_FIRST</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">qc</span><span class="o">-&gt;</span><span class="n">tf</span><span class="p">.</span><span class="n">protocol</span> <span class="o">==</span> <span class="n">ATA_PROT_PIO</span> <span class="o">&amp;&amp;</span>
		   <span class="p">(</span><span class="n">qc</span><span class="o">-&gt;</span><span class="n">tf</span><span class="p">.</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">ATA_TFLAG_WRITE</span><span class="p">))</span>
		    <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">ata_is_atapi</span><span class="p">(</span><span class="n">qc</span><span class="o">-&gt;</span><span class="n">tf</span><span class="p">.</span><span class="n">protocol</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		   <span class="o">!</span><span class="p">(</span><span class="n">qc</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">ATA_DFLAG_CDB_INTR</span><span class="p">))</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	ata_hsm_qc_complete - finish a qc running on standard HSM</span>
<span class="cm"> *	@qc: Command to complete</span>
<span class="cm"> *	@in_wq: 1 if called from workqueue, 0 otherwise</span>
<span class="cm"> *</span>
<span class="cm"> *	Finish @qc which is running on standard HSM.</span>
<span class="cm"> *</span>
<span class="cm"> *	LOCKING:</span>
<span class="cm"> *	If @in_wq is zero, spin_lock_irqsave(host lock).</span>
<span class="cm"> *	Otherwise, none on entry and grabs host lock.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">ata_hsm_qc_complete</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_queued_cmd</span> <span class="o">*</span><span class="n">qc</span><span class="p">,</span> <span class="kt">int</span> <span class="n">in_wq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span> <span class="o">=</span> <span class="n">qc</span><span class="o">-&gt;</span><span class="n">ap</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">error_handler</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">in_wq</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

			<span class="cm">/* EH might have kicked in while host lock is</span>
<span class="cm">			 * released.</span>
<span class="cm">			 */</span>
			<span class="n">qc</span> <span class="o">=</span> <span class="n">ata_qc_from_tag</span><span class="p">(</span><span class="n">ap</span><span class="p">,</span> <span class="n">qc</span><span class="o">-&gt;</span><span class="n">tag</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">qc</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">qc</span><span class="o">-&gt;</span><span class="n">err_mask</span> <span class="o">&amp;</span> <span class="n">AC_ERR_HSM</span><span class="p">)))</span> <span class="p">{</span>
					<span class="n">ata_sff_irq_on</span><span class="p">(</span><span class="n">ap</span><span class="p">);</span>
					<span class="n">ata_qc_complete</span><span class="p">(</span><span class="n">qc</span><span class="p">);</span>
				<span class="p">}</span> <span class="k">else</span>
					<span class="n">ata_port_freeze</span><span class="p">(</span><span class="n">ap</span><span class="p">);</span>
			<span class="p">}</span>

			<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">qc</span><span class="o">-&gt;</span><span class="n">err_mask</span> <span class="o">&amp;</span> <span class="n">AC_ERR_HSM</span><span class="p">)))</span>
				<span class="n">ata_qc_complete</span><span class="p">(</span><span class="n">qc</span><span class="p">);</span>
			<span class="k">else</span>
				<span class="n">ata_port_freeze</span><span class="p">(</span><span class="n">ap</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">in_wq</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
			<span class="n">ata_sff_irq_on</span><span class="p">(</span><span class="n">ap</span><span class="p">);</span>
			<span class="n">ata_qc_complete</span><span class="p">(</span><span class="n">qc</span><span class="p">);</span>
			<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="n">ata_qc_complete</span><span class="p">(</span><span class="n">qc</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	ata_sff_hsm_move - move the HSM to the next state.</span>
<span class="cm"> *	@ap: the target ata_port</span>
<span class="cm"> *	@qc: qc on going</span>
<span class="cm"> *	@status: current device status</span>
<span class="cm"> *	@in_wq: 1 if called from workqueue, 0 otherwise</span>
<span class="cm"> *</span>
<span class="cm"> *	RETURNS:</span>
<span class="cm"> *	1 when poll next status needed, 0 otherwise.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">ata_sff_hsm_move</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ata_queued_cmd</span> <span class="o">*</span><span class="n">qc</span><span class="p">,</span>
		     <span class="n">u8</span> <span class="n">status</span><span class="p">,</span> <span class="kt">int</span> <span class="n">in_wq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ata_link</span> <span class="o">*</span><span class="n">link</span> <span class="o">=</span> <span class="n">qc</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">link</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ata_eh_info</span> <span class="o">*</span><span class="n">ehi</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">link</span><span class="o">-&gt;</span><span class="n">eh_info</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">poll_next</span><span class="p">;</span>

	<span class="n">WARN_ON_ONCE</span><span class="p">((</span><span class="n">qc</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">ATA_QCFLAG_ACTIVE</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>

	<span class="cm">/* Make sure ata_sff_qc_issue() does not throw things</span>
<span class="cm">	 * like DMA polling into the workqueue. Notice that</span>
<span class="cm">	 * in_wq is not equivalent to (qc-&gt;tf.flags &amp; ATA_TFLAG_POLLING).</span>
<span class="cm">	 */</span>
	<span class="n">WARN_ON_ONCE</span><span class="p">(</span><span class="n">in_wq</span> <span class="o">!=</span> <span class="n">ata_hsm_ok_in_wq</span><span class="p">(</span><span class="n">ap</span><span class="p">,</span> <span class="n">qc</span><span class="p">));</span>

<span class="nl">fsm_start:</span>
	<span class="n">DPRINTK</span><span class="p">(</span><span class="s">&quot;ata%u: protocol %d task_state %d (dev_stat 0x%X)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">ap</span><span class="o">-&gt;</span><span class="n">print_id</span><span class="p">,</span> <span class="n">qc</span><span class="o">-&gt;</span><span class="n">tf</span><span class="p">.</span><span class="n">protocol</span><span class="p">,</span> <span class="n">ap</span><span class="o">-&gt;</span><span class="n">hsm_task_state</span><span class="p">,</span> <span class="n">status</span><span class="p">);</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">hsm_task_state</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">HSM_ST_FIRST</span>:
		<span class="cm">/* Send first data block or PACKET CDB */</span>

		<span class="cm">/* If polling, we will stay in the work queue after</span>
<span class="cm">		 * sending the data. Otherwise, interrupt handler</span>
<span class="cm">		 * takes over after sending the data.</span>
<span class="cm">		 */</span>
		<span class="n">poll_next</span> <span class="o">=</span> <span class="p">(</span><span class="n">qc</span><span class="o">-&gt;</span><span class="n">tf</span><span class="p">.</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">ATA_TFLAG_POLLING</span><span class="p">);</span>

		<span class="cm">/* check device status */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">((</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">ATA_DRQ</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/* handle BSY=0, DRQ=0 as error */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">ATA_ERR</span> <span class="o">|</span> <span class="n">ATA_DF</span><span class="p">)))</span>
				<span class="cm">/* device stops HSM for abort/error */</span>
				<span class="n">qc</span><span class="o">-&gt;</span><span class="n">err_mask</span> <span class="o">|=</span> <span class="n">AC_ERR_DEV</span><span class="p">;</span>
			<span class="k">else</span> <span class="p">{</span>
				<span class="cm">/* HSM violation. Let EH handle this */</span>
				<span class="n">ata_ehi_push_desc</span><span class="p">(</span><span class="n">ehi</span><span class="p">,</span>
					<span class="s">&quot;ST_FIRST: !(DRQ|ERR|DF)&quot;</span><span class="p">);</span>
				<span class="n">qc</span><span class="o">-&gt;</span><span class="n">err_mask</span> <span class="o">|=</span> <span class="n">AC_ERR_HSM</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="n">ap</span><span class="o">-&gt;</span><span class="n">hsm_task_state</span> <span class="o">=</span> <span class="n">HSM_ST_ERR</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">fsm_start</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* Device should not ask for data transfer (DRQ=1)</span>
<span class="cm">		 * when it finds something wrong.</span>
<span class="cm">		 * We ignore DRQ here and stop the HSM by</span>
<span class="cm">		 * changing hsm_task_state to HSM_ST_ERR and</span>
<span class="cm">		 * let the EH abort the command or reset the device.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">ATA_ERR</span> <span class="o">|</span> <span class="n">ATA_DF</span><span class="p">)))</span> <span class="p">{</span>
			<span class="cm">/* Some ATAPI tape drives forget to clear the ERR bit</span>
<span class="cm">			 * when doing the next command (mostly request sense).</span>
<span class="cm">			 * We ignore ERR here to workaround and proceed sending</span>
<span class="cm">			 * the CDB.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">qc</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">horkage</span> <span class="o">&amp;</span> <span class="n">ATA_HORKAGE_STUCK_ERR</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">ata_ehi_push_desc</span><span class="p">(</span><span class="n">ehi</span><span class="p">,</span> <span class="s">&quot;ST_FIRST: &quot;</span>
					<span class="s">&quot;DRQ=1 with device error, &quot;</span>
					<span class="s">&quot;dev_stat 0x%X&quot;</span><span class="p">,</span> <span class="n">status</span><span class="p">);</span>
				<span class="n">qc</span><span class="o">-&gt;</span><span class="n">err_mask</span> <span class="o">|=</span> <span class="n">AC_ERR_HSM</span><span class="p">;</span>
				<span class="n">ap</span><span class="o">-&gt;</span><span class="n">hsm_task_state</span> <span class="o">=</span> <span class="n">HSM_ST_ERR</span><span class="p">;</span>
				<span class="k">goto</span> <span class="n">fsm_start</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="cm">/* Send the CDB (atapi) or the first data block (ata pio out).</span>
<span class="cm">		 * During the state transition, interrupt handler shouldn&#39;t</span>
<span class="cm">		 * be invoked before the data transfer is complete and</span>
<span class="cm">		 * hsm_task_state is changed. Hence, the following locking.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">in_wq</span><span class="p">)</span>
			<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">qc</span><span class="o">-&gt;</span><span class="n">tf</span><span class="p">.</span><span class="n">protocol</span> <span class="o">==</span> <span class="n">ATA_PROT_PIO</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* PIO data out protocol.</span>
<span class="cm">			 * send first data block.</span>
<span class="cm">			 */</span>

			<span class="cm">/* ata_pio_sectors() might change the state</span>
<span class="cm">			 * to HSM_ST_LAST. so, the state is changed here</span>
<span class="cm">			 * before ata_pio_sectors().</span>
<span class="cm">			 */</span>
			<span class="n">ap</span><span class="o">-&gt;</span><span class="n">hsm_task_state</span> <span class="o">=</span> <span class="n">HSM_ST</span><span class="p">;</span>
			<span class="n">ata_pio_sectors</span><span class="p">(</span><span class="n">qc</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="cm">/* send CDB */</span>
			<span class="n">atapi_send_cdb</span><span class="p">(</span><span class="n">ap</span><span class="p">,</span> <span class="n">qc</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">in_wq</span><span class="p">)</span>
			<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

		<span class="cm">/* if polling, ata_sff_pio_task() handles the rest.</span>
<span class="cm">		 * otherwise, interrupt handler takes over from here.</span>
<span class="cm">		 */</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">HSM_ST</span>:
		<span class="cm">/* complete command or read/write the data register */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">qc</span><span class="o">-&gt;</span><span class="n">tf</span><span class="p">.</span><span class="n">protocol</span> <span class="o">==</span> <span class="n">ATAPI_PROT_PIO</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* ATAPI PIO protocol */</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">ATA_DRQ</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/* No more data to transfer or device error.</span>
<span class="cm">				 * Device error will be tagged in HSM_ST_LAST.</span>
<span class="cm">				 */</span>
				<span class="n">ap</span><span class="o">-&gt;</span><span class="n">hsm_task_state</span> <span class="o">=</span> <span class="n">HSM_ST_LAST</span><span class="p">;</span>
				<span class="k">goto</span> <span class="n">fsm_start</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="cm">/* Device should not ask for data transfer (DRQ=1)</span>
<span class="cm">			 * when it finds something wrong.</span>
<span class="cm">			 * We ignore DRQ here and stop the HSM by</span>
<span class="cm">			 * changing hsm_task_state to HSM_ST_ERR and</span>
<span class="cm">			 * let the EH abort the command or reset the device.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">ATA_ERR</span> <span class="o">|</span> <span class="n">ATA_DF</span><span class="p">)))</span> <span class="p">{</span>
				<span class="n">ata_ehi_push_desc</span><span class="p">(</span><span class="n">ehi</span><span class="p">,</span> <span class="s">&quot;ST-ATAPI: &quot;</span>
					<span class="s">&quot;DRQ=1 with device error, &quot;</span>
					<span class="s">&quot;dev_stat 0x%X&quot;</span><span class="p">,</span> <span class="n">status</span><span class="p">);</span>
				<span class="n">qc</span><span class="o">-&gt;</span><span class="n">err_mask</span> <span class="o">|=</span> <span class="n">AC_ERR_HSM</span><span class="p">;</span>
				<span class="n">ap</span><span class="o">-&gt;</span><span class="n">hsm_task_state</span> <span class="o">=</span> <span class="n">HSM_ST_ERR</span><span class="p">;</span>
				<span class="k">goto</span> <span class="n">fsm_start</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="n">atapi_pio_bytes</span><span class="p">(</span><span class="n">qc</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">hsm_task_state</span> <span class="o">==</span> <span class="n">HSM_ST_ERR</span><span class="p">))</span>
				<span class="cm">/* bad ireason reported by device */</span>
				<span class="k">goto</span> <span class="n">fsm_start</span><span class="p">;</span>

		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/* ATA PIO protocol */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">((</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">ATA_DRQ</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
				<span class="cm">/* handle BSY=0, DRQ=0 as error */</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">ATA_ERR</span> <span class="o">|</span> <span class="n">ATA_DF</span><span class="p">)))</span> <span class="p">{</span>
					<span class="cm">/* device stops HSM for abort/error */</span>
					<span class="n">qc</span><span class="o">-&gt;</span><span class="n">err_mask</span> <span class="o">|=</span> <span class="n">AC_ERR_DEV</span><span class="p">;</span>

					<span class="cm">/* If diagnostic failed and this is</span>
<span class="cm">					 * IDENTIFY, it&#39;s likely a phantom</span>
<span class="cm">					 * device.  Mark hint.</span>
<span class="cm">					 */</span>
					<span class="k">if</span> <span class="p">(</span><span class="n">qc</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">horkage</span> <span class="o">&amp;</span>
					    <span class="n">ATA_HORKAGE_DIAGNOSTIC</span><span class="p">)</span>
						<span class="n">qc</span><span class="o">-&gt;</span><span class="n">err_mask</span> <span class="o">|=</span>
							<span class="n">AC_ERR_NODEV_HINT</span><span class="p">;</span>
				<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
					<span class="cm">/* HSM violation. Let EH handle this.</span>
<span class="cm">					 * Phantom devices also trigger this</span>
<span class="cm">					 * condition.  Mark hint.</span>
<span class="cm">					 */</span>
					<span class="n">ata_ehi_push_desc</span><span class="p">(</span><span class="n">ehi</span><span class="p">,</span> <span class="s">&quot;ST-ATA: &quot;</span>
						<span class="s">&quot;DRQ=0 without device error, &quot;</span>
						<span class="s">&quot;dev_stat 0x%X&quot;</span><span class="p">,</span> <span class="n">status</span><span class="p">);</span>
					<span class="n">qc</span><span class="o">-&gt;</span><span class="n">err_mask</span> <span class="o">|=</span> <span class="n">AC_ERR_HSM</span> <span class="o">|</span>
							<span class="n">AC_ERR_NODEV_HINT</span><span class="p">;</span>
				<span class="p">}</span>

				<span class="n">ap</span><span class="o">-&gt;</span><span class="n">hsm_task_state</span> <span class="o">=</span> <span class="n">HSM_ST_ERR</span><span class="p">;</span>
				<span class="k">goto</span> <span class="n">fsm_start</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="cm">/* For PIO reads, some devices may ask for</span>
<span class="cm">			 * data transfer (DRQ=1) alone with ERR=1.</span>
<span class="cm">			 * We respect DRQ here and transfer one</span>
<span class="cm">			 * block of junk data before changing the</span>
<span class="cm">			 * hsm_task_state to HSM_ST_ERR.</span>
<span class="cm">			 *</span>
<span class="cm">			 * For PIO writes, ERR=1 DRQ=1 doesn&#39;t make</span>
<span class="cm">			 * sense since the data block has been</span>
<span class="cm">			 * transferred to the device.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">ATA_ERR</span> <span class="o">|</span> <span class="n">ATA_DF</span><span class="p">)))</span> <span class="p">{</span>
				<span class="cm">/* data might be corrputed */</span>
				<span class="n">qc</span><span class="o">-&gt;</span><span class="n">err_mask</span> <span class="o">|=</span> <span class="n">AC_ERR_DEV</span><span class="p">;</span>

				<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">qc</span><span class="o">-&gt;</span><span class="n">tf</span><span class="p">.</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">ATA_TFLAG_WRITE</span><span class="p">))</span> <span class="p">{</span>
					<span class="n">ata_pio_sectors</span><span class="p">(</span><span class="n">qc</span><span class="p">);</span>
					<span class="n">status</span> <span class="o">=</span> <span class="n">ata_wait_idle</span><span class="p">(</span><span class="n">ap</span><span class="p">);</span>
				<span class="p">}</span>

				<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">ATA_BUSY</span> <span class="o">|</span> <span class="n">ATA_DRQ</span><span class="p">))</span> <span class="p">{</span>
					<span class="n">ata_ehi_push_desc</span><span class="p">(</span><span class="n">ehi</span><span class="p">,</span> <span class="s">&quot;ST-ATA: &quot;</span>
						<span class="s">&quot;BUSY|DRQ persists on ERR|DF, &quot;</span>
						<span class="s">&quot;dev_stat 0x%X&quot;</span><span class="p">,</span> <span class="n">status</span><span class="p">);</span>
					<span class="n">qc</span><span class="o">-&gt;</span><span class="n">err_mask</span> <span class="o">|=</span> <span class="n">AC_ERR_HSM</span><span class="p">;</span>
				<span class="p">}</span>

				<span class="cm">/* There are oddball controllers with</span>
<span class="cm">				 * status register stuck at 0x7f and</span>
<span class="cm">				 * lbal/m/h at zero which makes it</span>
<span class="cm">				 * pass all other presence detection</span>
<span class="cm">				 * mechanisms we have.  Set NODEV_HINT</span>
<span class="cm">				 * for it.  Kernel bz#7241.</span>
<span class="cm">				 */</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">==</span> <span class="mh">0x7f</span><span class="p">)</span>
					<span class="n">qc</span><span class="o">-&gt;</span><span class="n">err_mask</span> <span class="o">|=</span> <span class="n">AC_ERR_NODEV_HINT</span><span class="p">;</span>

				<span class="cm">/* ata_pio_sectors() might change the</span>
<span class="cm">				 * state to HSM_ST_LAST. so, the state</span>
<span class="cm">				 * is changed after ata_pio_sectors().</span>
<span class="cm">				 */</span>
				<span class="n">ap</span><span class="o">-&gt;</span><span class="n">hsm_task_state</span> <span class="o">=</span> <span class="n">HSM_ST_ERR</span><span class="p">;</span>
				<span class="k">goto</span> <span class="n">fsm_start</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="n">ata_pio_sectors</span><span class="p">(</span><span class="n">qc</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">hsm_task_state</span> <span class="o">==</span> <span class="n">HSM_ST_LAST</span> <span class="o">&amp;&amp;</span>
			    <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">qc</span><span class="o">-&gt;</span><span class="n">tf</span><span class="p">.</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">ATA_TFLAG_WRITE</span><span class="p">)))</span> <span class="p">{</span>
				<span class="cm">/* all data read */</span>
				<span class="n">status</span> <span class="o">=</span> <span class="n">ata_wait_idle</span><span class="p">(</span><span class="n">ap</span><span class="p">);</span>
				<span class="k">goto</span> <span class="n">fsm_start</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="n">poll_next</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">HSM_ST_LAST</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">ata_ok</span><span class="p">(</span><span class="n">status</span><span class="p">)))</span> <span class="p">{</span>
			<span class="n">qc</span><span class="o">-&gt;</span><span class="n">err_mask</span> <span class="o">|=</span> <span class="n">__ac_err_mask</span><span class="p">(</span><span class="n">status</span><span class="p">);</span>
			<span class="n">ap</span><span class="o">-&gt;</span><span class="n">hsm_task_state</span> <span class="o">=</span> <span class="n">HSM_ST_ERR</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">fsm_start</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* no more data to transfer */</span>
		<span class="n">DPRINTK</span><span class="p">(</span><span class="s">&quot;ata%u: dev %u command complete, drv_stat 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">ap</span><span class="o">-&gt;</span><span class="n">print_id</span><span class="p">,</span> <span class="n">qc</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">devno</span><span class="p">,</span> <span class="n">status</span><span class="p">);</span>

		<span class="n">WARN_ON_ONCE</span><span class="p">(</span><span class="n">qc</span><span class="o">-&gt;</span><span class="n">err_mask</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">AC_ERR_DEV</span> <span class="o">|</span> <span class="n">AC_ERR_HSM</span><span class="p">));</span>

		<span class="n">ap</span><span class="o">-&gt;</span><span class="n">hsm_task_state</span> <span class="o">=</span> <span class="n">HSM_ST_IDLE</span><span class="p">;</span>

		<span class="cm">/* complete taskfile transaction */</span>
		<span class="n">ata_hsm_qc_complete</span><span class="p">(</span><span class="n">qc</span><span class="p">,</span> <span class="n">in_wq</span><span class="p">);</span>

		<span class="n">poll_next</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">HSM_ST_ERR</span>:
		<span class="n">ap</span><span class="o">-&gt;</span><span class="n">hsm_task_state</span> <span class="o">=</span> <span class="n">HSM_ST_IDLE</span><span class="p">;</span>

		<span class="cm">/* complete taskfile transaction */</span>
		<span class="n">ata_hsm_qc_complete</span><span class="p">(</span><span class="n">qc</span><span class="p">,</span> <span class="n">in_wq</span><span class="p">);</span>

		<span class="n">poll_next</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">poll_next</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">BUG</span><span class="p">();</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">poll_next</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">ata_sff_hsm_move</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">ata_sff_queue_work</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">queue_work</span><span class="p">(</span><span class="n">ata_sff_wq</span><span class="p">,</span> <span class="n">work</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">ata_sff_queue_work</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">ata_sff_queue_delayed_work</span><span class="p">(</span><span class="k">struct</span> <span class="n">delayed_work</span> <span class="o">*</span><span class="n">dwork</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">delay</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">queue_delayed_work</span><span class="p">(</span><span class="n">ata_sff_wq</span><span class="p">,</span> <span class="n">dwork</span><span class="p">,</span> <span class="n">delay</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">ata_sff_queue_delayed_work</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">ata_sff_queue_pio_task</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_link</span> <span class="o">*</span><span class="n">link</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">delay</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span> <span class="o">=</span> <span class="n">link</span><span class="o">-&gt;</span><span class="n">ap</span><span class="p">;</span>

	<span class="n">WARN_ON</span><span class="p">((</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">sff_pio_task_link</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		<span class="p">(</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">sff_pio_task_link</span> <span class="o">!=</span> <span class="n">link</span><span class="p">));</span>
	<span class="n">ap</span><span class="o">-&gt;</span><span class="n">sff_pio_task_link</span> <span class="o">=</span> <span class="n">link</span><span class="p">;</span>

	<span class="cm">/* may fail if ata_sff_flush_pio_task() in progress */</span>
	<span class="n">ata_sff_queue_delayed_work</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">sff_pio_task</span><span class="p">,</span> <span class="n">msecs_to_jiffies</span><span class="p">(</span><span class="n">delay</span><span class="p">));</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">ata_sff_queue_pio_task</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">ata_sff_flush_pio_task</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">DPRINTK</span><span class="p">(</span><span class="s">&quot;ENTER</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="n">cancel_delayed_work_sync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">sff_pio_task</span><span class="p">);</span>
	<span class="n">ap</span><span class="o">-&gt;</span><span class="n">hsm_task_state</span> <span class="o">=</span> <span class="n">HSM_ST_IDLE</span><span class="p">;</span>
	<span class="n">ap</span><span class="o">-&gt;</span><span class="n">sff_pio_task_link</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ata_msg_ctl</span><span class="p">(</span><span class="n">ap</span><span class="p">))</span>
		<span class="n">ata_port_dbg</span><span class="p">(</span><span class="n">ap</span><span class="p">,</span> <span class="s">&quot;%s: EXIT</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">ata_sff_pio_task</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span> <span class="o">=</span>
		<span class="n">container_of</span><span class="p">(</span><span class="n">work</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ata_port</span><span class="p">,</span> <span class="n">sff_pio_task</span><span class="p">.</span><span class="n">work</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">ata_link</span> <span class="o">*</span><span class="n">link</span> <span class="o">=</span> <span class="n">ap</span><span class="o">-&gt;</span><span class="n">sff_pio_task_link</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ata_queued_cmd</span> <span class="o">*</span><span class="n">qc</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">status</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">poll_next</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">sff_pio_task_link</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="cm">/* qc can be NULL if timeout occurred */</span>
	<span class="n">qc</span> <span class="o">=</span> <span class="n">ata_qc_from_tag</span><span class="p">(</span><span class="n">ap</span><span class="p">,</span> <span class="n">link</span><span class="o">-&gt;</span><span class="n">active_tag</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">qc</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ap</span><span class="o">-&gt;</span><span class="n">sff_pio_task_link</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

<span class="nl">fsm_start:</span>
	<span class="n">WARN_ON_ONCE</span><span class="p">(</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">hsm_task_state</span> <span class="o">==</span> <span class="n">HSM_ST_IDLE</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * This is purely heuristic.  This is a fast path.</span>
<span class="cm">	 * Sometimes when we enter, BSY will be cleared in</span>
<span class="cm">	 * a chk-status or two.  If not, the drive is probably seeking</span>
<span class="cm">	 * or something.  Snooze for a couple msecs, then</span>
<span class="cm">	 * chk-status again.  If still busy, queue delayed work.</span>
<span class="cm">	 */</span>
	<span class="n">status</span> <span class="o">=</span> <span class="n">ata_sff_busy_wait</span><span class="p">(</span><span class="n">ap</span><span class="p">,</span> <span class="n">ATA_BUSY</span><span class="p">,</span> <span class="mi">5</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">ATA_BUSY</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ata_msleep</span><span class="p">(</span><span class="n">ap</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">ata_sff_busy_wait</span><span class="p">(</span><span class="n">ap</span><span class="p">,</span> <span class="n">ATA_BUSY</span><span class="p">,</span> <span class="mi">10</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">ATA_BUSY</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ata_sff_queue_pio_task</span><span class="p">(</span><span class="n">link</span><span class="p">,</span> <span class="n">ATA_SHORT_PAUSE</span><span class="p">);</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * hsm_move() may trigger another command to be processed.</span>
<span class="cm">	 * clean the link beforehand.</span>
<span class="cm">	 */</span>
	<span class="n">ap</span><span class="o">-&gt;</span><span class="n">sff_pio_task_link</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="cm">/* move the HSM */</span>
	<span class="n">poll_next</span> <span class="o">=</span> <span class="n">ata_sff_hsm_move</span><span class="p">(</span><span class="n">ap</span><span class="p">,</span> <span class="n">qc</span><span class="p">,</span> <span class="n">status</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

	<span class="cm">/* another command or interrupt handler</span>
<span class="cm">	 * may be running at this point.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">poll_next</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">fsm_start</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	ata_sff_qc_issue - issue taskfile to a SFF controller</span>
<span class="cm"> *	@qc: command to issue to device</span>
<span class="cm"> *</span>
<span class="cm"> *	This function issues a PIO or NODATA command to a SFF</span>
<span class="cm"> *	controller.</span>
<span class="cm"> *</span>
<span class="cm"> *	LOCKING:</span>
<span class="cm"> *	spin_lock_irqsave(host lock)</span>
<span class="cm"> *</span>
<span class="cm"> *	RETURNS:</span>
<span class="cm"> *	Zero on success, AC_ERR_* mask on failure</span>
<span class="cm"> */</span>
<span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">ata_sff_qc_issue</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_queued_cmd</span> <span class="o">*</span><span class="n">qc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span> <span class="o">=</span> <span class="n">qc</span><span class="o">-&gt;</span><span class="n">ap</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ata_link</span> <span class="o">*</span><span class="n">link</span> <span class="o">=</span> <span class="n">qc</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">link</span><span class="p">;</span>

	<span class="cm">/* Use polling pio if the LLD doesn&#39;t handle</span>
<span class="cm">	 * interrupt driven pio and atapi CDB interrupt.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">ATA_FLAG_PIO_POLLING</span><span class="p">)</span>
		<span class="n">qc</span><span class="o">-&gt;</span><span class="n">tf</span><span class="p">.</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">ATA_TFLAG_POLLING</span><span class="p">;</span>

	<span class="cm">/* select the device */</span>
	<span class="n">ata_dev_select</span><span class="p">(</span><span class="n">ap</span><span class="p">,</span> <span class="n">qc</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">devno</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="cm">/* start the command */</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">qc</span><span class="o">-&gt;</span><span class="n">tf</span><span class="p">.</span><span class="n">protocol</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">ATA_PROT_NODATA</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">qc</span><span class="o">-&gt;</span><span class="n">tf</span><span class="p">.</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">ATA_TFLAG_POLLING</span><span class="p">)</span>
			<span class="n">ata_qc_set_polling</span><span class="p">(</span><span class="n">qc</span><span class="p">);</span>

		<span class="n">ata_tf_to_host</span><span class="p">(</span><span class="n">ap</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">qc</span><span class="o">-&gt;</span><span class="n">tf</span><span class="p">);</span>
		<span class="n">ap</span><span class="o">-&gt;</span><span class="n">hsm_task_state</span> <span class="o">=</span> <span class="n">HSM_ST_LAST</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">qc</span><span class="o">-&gt;</span><span class="n">tf</span><span class="p">.</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">ATA_TFLAG_POLLING</span><span class="p">)</span>
			<span class="n">ata_sff_queue_pio_task</span><span class="p">(</span><span class="n">link</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">ATA_PROT_PIO</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">qc</span><span class="o">-&gt;</span><span class="n">tf</span><span class="p">.</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">ATA_TFLAG_POLLING</span><span class="p">)</span>
			<span class="n">ata_qc_set_polling</span><span class="p">(</span><span class="n">qc</span><span class="p">);</span>

		<span class="n">ata_tf_to_host</span><span class="p">(</span><span class="n">ap</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">qc</span><span class="o">-&gt;</span><span class="n">tf</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">qc</span><span class="o">-&gt;</span><span class="n">tf</span><span class="p">.</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">ATA_TFLAG_WRITE</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* PIO data out protocol */</span>
			<span class="n">ap</span><span class="o">-&gt;</span><span class="n">hsm_task_state</span> <span class="o">=</span> <span class="n">HSM_ST_FIRST</span><span class="p">;</span>
			<span class="n">ata_sff_queue_pio_task</span><span class="p">(</span><span class="n">link</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

			<span class="cm">/* always send first data block using the</span>
<span class="cm">			 * ata_sff_pio_task() codepath.</span>
<span class="cm">			 */</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/* PIO data in protocol */</span>
			<span class="n">ap</span><span class="o">-&gt;</span><span class="n">hsm_task_state</span> <span class="o">=</span> <span class="n">HSM_ST</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">qc</span><span class="o">-&gt;</span><span class="n">tf</span><span class="p">.</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">ATA_TFLAG_POLLING</span><span class="p">)</span>
				<span class="n">ata_sff_queue_pio_task</span><span class="p">(</span><span class="n">link</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

			<span class="cm">/* if polling, ata_sff_pio_task() handles the</span>
<span class="cm">			 * rest.  otherwise, interrupt handler takes</span>
<span class="cm">			 * over from here.</span>
<span class="cm">			 */</span>
		<span class="p">}</span>

		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">ATAPI_PROT_PIO</span>:
	<span class="k">case</span> <span class="n">ATAPI_PROT_NODATA</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">qc</span><span class="o">-&gt;</span><span class="n">tf</span><span class="p">.</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">ATA_TFLAG_POLLING</span><span class="p">)</span>
			<span class="n">ata_qc_set_polling</span><span class="p">(</span><span class="n">qc</span><span class="p">);</span>

		<span class="n">ata_tf_to_host</span><span class="p">(</span><span class="n">ap</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">qc</span><span class="o">-&gt;</span><span class="n">tf</span><span class="p">);</span>

		<span class="n">ap</span><span class="o">-&gt;</span><span class="n">hsm_task_state</span> <span class="o">=</span> <span class="n">HSM_ST_FIRST</span><span class="p">;</span>

		<span class="cm">/* send cdb by polling if no cdb interrupt */</span>
		<span class="k">if</span> <span class="p">((</span><span class="o">!</span><span class="p">(</span><span class="n">qc</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">ATA_DFLAG_CDB_INTR</span><span class="p">))</span> <span class="o">||</span>
		    <span class="p">(</span><span class="n">qc</span><span class="o">-&gt;</span><span class="n">tf</span><span class="p">.</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">ATA_TFLAG_POLLING</span><span class="p">))</span>
			<span class="n">ata_sff_queue_pio_task</span><span class="p">(</span><span class="n">link</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="nl">default:</span>
		<span class="n">WARN_ON_ONCE</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">AC_ERR_SYSTEM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">ata_sff_qc_issue</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> *	ata_sff_qc_fill_rtf - fill result TF using -&gt;sff_tf_read</span>
<span class="cm"> *	@qc: qc to fill result TF for</span>
<span class="cm"> *</span>
<span class="cm"> *	@qc is finished and result TF needs to be filled.  Fill it</span>
<span class="cm"> *	using -&gt;sff_tf_read.</span>
<span class="cm"> *</span>
<span class="cm"> *	LOCKING:</span>
<span class="cm"> *	spin_lock_irqsave(host lock)</span>
<span class="cm"> *</span>
<span class="cm"> *	RETURNS:</span>
<span class="cm"> *	true indicating that result TF is successfully filled.</span>
<span class="cm"> */</span>
<span class="n">bool</span> <span class="nf">ata_sff_qc_fill_rtf</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_queued_cmd</span> <span class="o">*</span><span class="n">qc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">qc</span><span class="o">-&gt;</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">sff_tf_read</span><span class="p">(</span><span class="n">qc</span><span class="o">-&gt;</span><span class="n">ap</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">qc</span><span class="o">-&gt;</span><span class="n">result_tf</span><span class="p">);</span>
	<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">ata_sff_qc_fill_rtf</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">ata_sff_idle_irq</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ap</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">idle_irq</span><span class="o">++</span><span class="p">;</span>

<span class="cp">#ifdef ATA_IRQ_TRAP</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">stats</span><span class="p">.</span><span class="n">idle_irq</span> <span class="o">%</span> <span class="mi">1000</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ap</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">sff_check_status</span><span class="p">(</span><span class="n">ap</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">sff_irq_clear</span><span class="p">)</span>
			<span class="n">ap</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">sff_irq_clear</span><span class="p">(</span><span class="n">ap</span><span class="p">);</span>
		<span class="n">ata_port_warn</span><span class="p">(</span><span class="n">ap</span><span class="p">,</span> <span class="s">&quot;irq trap</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
<span class="cp">#endif</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>	<span class="cm">/* irq not handled */</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">__ata_sff_port_intr</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">ata_queued_cmd</span> <span class="o">*</span><span class="n">qc</span><span class="p">,</span>
					<span class="n">bool</span> <span class="n">hsmv_on_idle</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u8</span> <span class="n">status</span><span class="p">;</span>

	<span class="n">VPRINTK</span><span class="p">(</span><span class="s">&quot;ata%u: protocol %d task_state %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">ap</span><span class="o">-&gt;</span><span class="n">print_id</span><span class="p">,</span> <span class="n">qc</span><span class="o">-&gt;</span><span class="n">tf</span><span class="p">.</span><span class="n">protocol</span><span class="p">,</span> <span class="n">ap</span><span class="o">-&gt;</span><span class="n">hsm_task_state</span><span class="p">);</span>

	<span class="cm">/* Check whether we are expecting interrupt in this state */</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">hsm_task_state</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">HSM_ST_FIRST</span>:
		<span class="cm">/* Some pre-ATAPI-4 devices assert INTRQ</span>
<span class="cm">		 * at this state when ready to receive CDB.</span>
<span class="cm">		 */</span>

		<span class="cm">/* Check the ATA_DFLAG_CDB_INTR flag is enough here.</span>
<span class="cm">		 * The flag was turned on only for atapi devices.  No</span>
<span class="cm">		 * need to check ata_is_atapi(qc-&gt;tf.protocol) again.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">qc</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">ATA_DFLAG_CDB_INTR</span><span class="p">))</span>
			<span class="k">return</span> <span class="n">ata_sff_idle_irq</span><span class="p">(</span><span class="n">ap</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">HSM_ST_IDLE</span>:
		<span class="k">return</span> <span class="n">ata_sff_idle_irq</span><span class="p">(</span><span class="n">ap</span><span class="p">);</span>
	<span class="nl">default:</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* check main status, clearing INTRQ if needed */</span>
	<span class="n">status</span> <span class="o">=</span> <span class="n">ata_sff_irq_status</span><span class="p">(</span><span class="n">ap</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">ATA_BUSY</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">hsmv_on_idle</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* BMDMA engine is already stopped, we&#39;re screwed */</span>
			<span class="n">qc</span><span class="o">-&gt;</span><span class="n">err_mask</span> <span class="o">|=</span> <span class="n">AC_ERR_HSM</span><span class="p">;</span>
			<span class="n">ap</span><span class="o">-&gt;</span><span class="n">hsm_task_state</span> <span class="o">=</span> <span class="n">HSM_ST_ERR</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="k">return</span> <span class="n">ata_sff_idle_irq</span><span class="p">(</span><span class="n">ap</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* clear irq events */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">sff_irq_clear</span><span class="p">)</span>
		<span class="n">ap</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">sff_irq_clear</span><span class="p">(</span><span class="n">ap</span><span class="p">);</span>

	<span class="n">ata_sff_hsm_move</span><span class="p">(</span><span class="n">ap</span><span class="p">,</span> <span class="n">qc</span><span class="p">,</span> <span class="n">status</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>	<span class="cm">/* irq handled */</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	ata_sff_port_intr - Handle SFF port interrupt</span>
<span class="cm"> *	@ap: Port on which interrupt arrived (possibly...)</span>
<span class="cm"> *	@qc: Taskfile currently active in engine</span>
<span class="cm"> *</span>
<span class="cm"> *	Handle port interrupt for given queued command.</span>
<span class="cm"> *</span>
<span class="cm"> *	LOCKING:</span>
<span class="cm"> *	spin_lock_irqsave(host lock)</span>
<span class="cm"> *</span>
<span class="cm"> *	RETURNS:</span>
<span class="cm"> *	One if interrupt was handled, zero if not (shared irq).</span>
<span class="cm"> */</span>
<span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">ata_sff_port_intr</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ata_queued_cmd</span> <span class="o">*</span><span class="n">qc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">__ata_sff_port_intr</span><span class="p">(</span><span class="n">ap</span><span class="p">,</span> <span class="n">qc</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">ata_sff_port_intr</span><span class="p">);</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">irqreturn_t</span> <span class="nf">__ata_sff_interrupt</span><span class="p">(</span><span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">dev_instance</span><span class="p">,</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">port_intr</span><span class="p">)(</span><span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ata_queued_cmd</span> <span class="o">*</span><span class="p">))</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ata_host</span> <span class="o">*</span><span class="n">host</span> <span class="o">=</span> <span class="n">dev_instance</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">retried</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">handled</span><span class="p">,</span> <span class="n">idle</span><span class="p">,</span> <span class="n">polling</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="cm">/* TODO: make _irqsave conditional on x86 PCI IDE legacy mode */</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

<span class="nl">retry:</span>
	<span class="n">handled</span> <span class="o">=</span> <span class="n">idle</span> <span class="o">=</span> <span class="n">polling</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">host</span><span class="o">-&gt;</span><span class="n">n_ports</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span> <span class="o">=</span> <span class="n">host</span><span class="o">-&gt;</span><span class="n">ports</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="k">struct</span> <span class="n">ata_queued_cmd</span> <span class="o">*</span><span class="n">qc</span><span class="p">;</span>

		<span class="n">qc</span> <span class="o">=</span> <span class="n">ata_qc_from_tag</span><span class="p">(</span><span class="n">ap</span><span class="p">,</span> <span class="n">ap</span><span class="o">-&gt;</span><span class="n">link</span><span class="p">.</span><span class="n">active_tag</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">qc</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">qc</span><span class="o">-&gt;</span><span class="n">tf</span><span class="p">.</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">ATA_TFLAG_POLLING</span><span class="p">))</span>
				<span class="n">handled</span> <span class="o">|=</span> <span class="n">port_intr</span><span class="p">(</span><span class="n">ap</span><span class="p">,</span> <span class="n">qc</span><span class="p">);</span>
			<span class="k">else</span>
				<span class="n">polling</span> <span class="o">|=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">i</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="n">idle</span> <span class="o">|=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">i</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * If no port was expecting IRQ but the controller is actually</span>
<span class="cm">	 * asserting IRQ line, nobody cared will ensue.  Check IRQ</span>
<span class="cm">	 * pending status if available and clear spurious IRQ.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">handled</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">retried</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">bool</span> <span class="n">retry</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">host</span><span class="o">-&gt;</span><span class="n">n_ports</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span> <span class="o">=</span> <span class="n">host</span><span class="o">-&gt;</span><span class="n">ports</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">polling</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">i</span><span class="p">))</span>
				<span class="k">continue</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">sff_irq_check</span> <span class="o">||</span>
			    <span class="o">!</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">sff_irq_check</span><span class="p">(</span><span class="n">ap</span><span class="p">))</span>
				<span class="k">continue</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">idle</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">i</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">ap</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">sff_check_status</span><span class="p">(</span><span class="n">ap</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">sff_irq_clear</span><span class="p">)</span>
					<span class="n">ap</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">sff_irq_clear</span><span class="p">(</span><span class="n">ap</span><span class="p">);</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="cm">/* clear INTRQ and check if BUSY cleared */</span>
				<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">sff_check_status</span><span class="p">(</span><span class="n">ap</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">ATA_BUSY</span><span class="p">))</span>
					<span class="n">retry</span> <span class="o">|=</span> <span class="nb">true</span><span class="p">;</span>
				<span class="cm">/*</span>
<span class="cm">				 * With command in flight, we can&#39;t do</span>
<span class="cm">				 * sff_irq_clear() w/o racing with completion.</span>
<span class="cm">				 */</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">retry</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">retried</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">retry</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">IRQ_RETVAL</span><span class="p">(</span><span class="n">handled</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	ata_sff_interrupt - Default SFF ATA host interrupt handler</span>
<span class="cm"> *	@irq: irq line (unused)</span>
<span class="cm"> *	@dev_instance: pointer to our ata_host information structure</span>
<span class="cm"> *</span>
<span class="cm"> *	Default interrupt handler for PCI IDE devices.  Calls</span>
<span class="cm"> *	ata_sff_port_intr() for each port that is not disabled.</span>
<span class="cm"> *</span>
<span class="cm"> *	LOCKING:</span>
<span class="cm"> *	Obtains host lock during operation.</span>
<span class="cm"> *</span>
<span class="cm"> *	RETURNS:</span>
<span class="cm"> *	IRQ_NONE or IRQ_HANDLED.</span>
<span class="cm"> */</span>
<span class="n">irqreturn_t</span> <span class="nf">ata_sff_interrupt</span><span class="p">(</span><span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">dev_instance</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">__ata_sff_interrupt</span><span class="p">(</span><span class="n">irq</span><span class="p">,</span> <span class="n">dev_instance</span><span class="p">,</span> <span class="n">ata_sff_port_intr</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">ata_sff_interrupt</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> *	ata_sff_lost_interrupt	-	Check for an apparent lost interrupt</span>
<span class="cm"> *	@ap: port that appears to have timed out</span>
<span class="cm"> *</span>
<span class="cm"> *	Called from the libata error handlers when the core code suspects</span>
<span class="cm"> *	an interrupt has been lost. If it has complete anything we can and</span>
<span class="cm"> *	then return. Interface must support altstatus for this faster</span>
<span class="cm"> *	recovery to occur.</span>
<span class="cm"> *</span>
<span class="cm"> *	Locking:</span>
<span class="cm"> *	Caller holds host lock</span>
<span class="cm"> */</span>

<span class="kt">void</span> <span class="nf">ata_sff_lost_interrupt</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u8</span> <span class="n">status</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ata_queued_cmd</span> <span class="o">*</span><span class="n">qc</span><span class="p">;</span>

	<span class="cm">/* Only one outstanding command per SFF channel */</span>
	<span class="n">qc</span> <span class="o">=</span> <span class="n">ata_qc_from_tag</span><span class="p">(</span><span class="n">ap</span><span class="p">,</span> <span class="n">ap</span><span class="o">-&gt;</span><span class="n">link</span><span class="p">.</span><span class="n">active_tag</span><span class="p">);</span>
	<span class="cm">/* We cannot lose an interrupt on a non-existent or polled command */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">qc</span> <span class="o">||</span> <span class="n">qc</span><span class="o">-&gt;</span><span class="n">tf</span><span class="p">.</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">ATA_TFLAG_POLLING</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="cm">/* See if the controller thinks it is still busy - if so the command</span>
<span class="cm">	   isn&#39;t a lost IRQ but is still in progress */</span>
	<span class="n">status</span> <span class="o">=</span> <span class="n">ata_sff_altstatus</span><span class="p">(</span><span class="n">ap</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span> <span class="n">ATA_BUSY</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/* There was a command running, we are no longer busy and we have</span>
<span class="cm">	   no interrupt. */</span>
	<span class="n">ata_port_warn</span><span class="p">(</span><span class="n">ap</span><span class="p">,</span> <span class="s">&quot;lost interrupt (Status 0x%x)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
								<span class="n">status</span><span class="p">);</span>
	<span class="cm">/* Run the host interrupt logic as if the interrupt had not been</span>
<span class="cm">	   lost */</span>
	<span class="n">ata_sff_port_intr</span><span class="p">(</span><span class="n">ap</span><span class="p">,</span> <span class="n">qc</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">ata_sff_lost_interrupt</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> *	ata_sff_freeze - Freeze SFF controller port</span>
<span class="cm"> *	@ap: port to freeze</span>
<span class="cm"> *</span>
<span class="cm"> *	Freeze SFF controller port.</span>
<span class="cm"> *</span>
<span class="cm"> *	LOCKING:</span>
<span class="cm"> *	Inherited from caller.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">ata_sff_freeze</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ap</span><span class="o">-&gt;</span><span class="n">ctl</span> <span class="o">|=</span> <span class="n">ATA_NIEN</span><span class="p">;</span>
	<span class="n">ap</span><span class="o">-&gt;</span><span class="n">last_ctl</span> <span class="o">=</span> <span class="n">ap</span><span class="o">-&gt;</span><span class="n">ctl</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">sff_set_devctl</span> <span class="o">||</span> <span class="n">ap</span><span class="o">-&gt;</span><span class="n">ioaddr</span><span class="p">.</span><span class="n">ctl_addr</span><span class="p">)</span>
		<span class="n">ata_sff_set_devctl</span><span class="p">(</span><span class="n">ap</span><span class="p">,</span> <span class="n">ap</span><span class="o">-&gt;</span><span class="n">ctl</span><span class="p">);</span>

	<span class="cm">/* Under certain circumstances, some controllers raise IRQ on</span>
<span class="cm">	 * ATA_NIEN manipulation.  Also, many controllers fail to mask</span>
<span class="cm">	 * previously pending IRQ on ATA_NIEN assertion.  Clear it.</span>
<span class="cm">	 */</span>
	<span class="n">ap</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">sff_check_status</span><span class="p">(</span><span class="n">ap</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">sff_irq_clear</span><span class="p">)</span>
		<span class="n">ap</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">sff_irq_clear</span><span class="p">(</span><span class="n">ap</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">ata_sff_freeze</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> *	ata_sff_thaw - Thaw SFF controller port</span>
<span class="cm"> *	@ap: port to thaw</span>
<span class="cm"> *</span>
<span class="cm"> *	Thaw SFF controller port.</span>
<span class="cm"> *</span>
<span class="cm"> *	LOCKING:</span>
<span class="cm"> *	Inherited from caller.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">ata_sff_thaw</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* clear &amp; re-enable interrupts */</span>
	<span class="n">ap</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">sff_check_status</span><span class="p">(</span><span class="n">ap</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">sff_irq_clear</span><span class="p">)</span>
		<span class="n">ap</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">sff_irq_clear</span><span class="p">(</span><span class="n">ap</span><span class="p">);</span>
	<span class="n">ata_sff_irq_on</span><span class="p">(</span><span class="n">ap</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">ata_sff_thaw</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> *	ata_sff_prereset - prepare SFF link for reset</span>
<span class="cm"> *	@link: SFF link to be reset</span>
<span class="cm"> *	@deadline: deadline jiffies for the operation</span>
<span class="cm"> *</span>
<span class="cm"> *	SFF link @link is about to be reset.  Initialize it.  It first</span>
<span class="cm"> *	calls ata_std_prereset() and wait for !BSY if the port is</span>
<span class="cm"> *	being softreset.</span>
<span class="cm"> *</span>
<span class="cm"> *	LOCKING:</span>
<span class="cm"> *	Kernel thread context (may sleep)</span>
<span class="cm"> *</span>
<span class="cm"> *	RETURNS:</span>
<span class="cm"> *	0 on success, -errno otherwise.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">ata_sff_prereset</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_link</span> <span class="o">*</span><span class="n">link</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">deadline</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ata_eh_context</span> <span class="o">*</span><span class="n">ehc</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">link</span><span class="o">-&gt;</span><span class="n">eh_context</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">ata_std_prereset</span><span class="p">(</span><span class="n">link</span><span class="p">,</span> <span class="n">deadline</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>

	<span class="cm">/* if we&#39;re about to do hardreset, nothing more to do */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ehc</span><span class="o">-&gt;</span><span class="n">i</span><span class="p">.</span><span class="n">action</span> <span class="o">&amp;</span> <span class="n">ATA_EH_HARDRESET</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* wait for !BSY if we don&#39;t know that no device is attached */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ata_link_offline</span><span class="p">(</span><span class="n">link</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">ata_sff_wait_ready</span><span class="p">(</span><span class="n">link</span><span class="p">,</span> <span class="n">deadline</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">&amp;&amp;</span> <span class="n">rc</span> <span class="o">!=</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ata_link_warn</span><span class="p">(</span><span class="n">link</span><span class="p">,</span>
				      <span class="s">&quot;device not ready (errno=%d), forcing hardreset</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				      <span class="n">rc</span><span class="p">);</span>
			<span class="n">ehc</span><span class="o">-&gt;</span><span class="n">i</span><span class="p">.</span><span class="n">action</span> <span class="o">|=</span> <span class="n">ATA_EH_HARDRESET</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">ata_sff_prereset</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> *	ata_devchk - PATA device presence detection</span>
<span class="cm"> *	@ap: ATA channel to examine</span>
<span class="cm"> *	@device: Device to examine (starting at zero)</span>
<span class="cm"> *</span>
<span class="cm"> *	This technique was originally described in</span>
<span class="cm"> *	Hale Landis&#39;s ATADRVR (www.ata-atapi.com), and</span>
<span class="cm"> *	later found its way into the ATA/ATAPI spec.</span>
<span class="cm"> *</span>
<span class="cm"> *	Write a pattern to the ATA shadow registers,</span>
<span class="cm"> *	and if a device is present, it will respond by</span>
<span class="cm"> *	correctly storing and echoing back the</span>
<span class="cm"> *	ATA shadow register contents.</span>
<span class="cm"> *</span>
<span class="cm"> *	LOCKING:</span>
<span class="cm"> *	caller.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">ata_devchk</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">device</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ata_ioports</span> <span class="o">*</span><span class="n">ioaddr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">ioaddr</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">nsect</span><span class="p">,</span> <span class="n">lbal</span><span class="p">;</span>

	<span class="n">ap</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">sff_dev_select</span><span class="p">(</span><span class="n">ap</span><span class="p">,</span> <span class="n">device</span><span class="p">);</span>

	<span class="n">iowrite8</span><span class="p">(</span><span class="mh">0x55</span><span class="p">,</span> <span class="n">ioaddr</span><span class="o">-&gt;</span><span class="n">nsect_addr</span><span class="p">);</span>
	<span class="n">iowrite8</span><span class="p">(</span><span class="mh">0xaa</span><span class="p">,</span> <span class="n">ioaddr</span><span class="o">-&gt;</span><span class="n">lbal_addr</span><span class="p">);</span>

	<span class="n">iowrite8</span><span class="p">(</span><span class="mh">0xaa</span><span class="p">,</span> <span class="n">ioaddr</span><span class="o">-&gt;</span><span class="n">nsect_addr</span><span class="p">);</span>
	<span class="n">iowrite8</span><span class="p">(</span><span class="mh">0x55</span><span class="p">,</span> <span class="n">ioaddr</span><span class="o">-&gt;</span><span class="n">lbal_addr</span><span class="p">);</span>

	<span class="n">iowrite8</span><span class="p">(</span><span class="mh">0x55</span><span class="p">,</span> <span class="n">ioaddr</span><span class="o">-&gt;</span><span class="n">nsect_addr</span><span class="p">);</span>
	<span class="n">iowrite8</span><span class="p">(</span><span class="mh">0xaa</span><span class="p">,</span> <span class="n">ioaddr</span><span class="o">-&gt;</span><span class="n">lbal_addr</span><span class="p">);</span>

	<span class="n">nsect</span> <span class="o">=</span> <span class="n">ioread8</span><span class="p">(</span><span class="n">ioaddr</span><span class="o">-&gt;</span><span class="n">nsect_addr</span><span class="p">);</span>
	<span class="n">lbal</span> <span class="o">=</span> <span class="n">ioread8</span><span class="p">(</span><span class="n">ioaddr</span><span class="o">-&gt;</span><span class="n">lbal_addr</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">nsect</span> <span class="o">==</span> <span class="mh">0x55</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">lbal</span> <span class="o">==</span> <span class="mh">0xaa</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>	<span class="cm">/* we found a device */</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>		<span class="cm">/* nothing found */</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	ata_sff_dev_classify - Parse returned ATA device signature</span>
<span class="cm"> *	@dev: ATA device to classify (starting at zero)</span>
<span class="cm"> *	@present: device seems present</span>
<span class="cm"> *	@r_err: Value of error register on completion</span>
<span class="cm"> *</span>
<span class="cm"> *	After an event -- SRST, E.D.D., or SATA COMRESET -- occurs,</span>
<span class="cm"> *	an ATA/ATAPI-defined set of values is placed in the ATA</span>
<span class="cm"> *	shadow registers, indicating the results of device detection</span>
<span class="cm"> *	and diagnostics.</span>
<span class="cm"> *</span>
<span class="cm"> *	Select the ATA device, and read the values from the ATA shadow</span>
<span class="cm"> *	registers.  Then parse according to the Error register value,</span>
<span class="cm"> *	and the spec-defined values examined by ata_dev_classify().</span>
<span class="cm"> *</span>
<span class="cm"> *	LOCKING:</span>
<span class="cm"> *	caller.</span>
<span class="cm"> *</span>
<span class="cm"> *	RETURNS:</span>
<span class="cm"> *	Device type - %ATA_DEV_ATA, %ATA_DEV_ATAPI or %ATA_DEV_NONE.</span>
<span class="cm"> */</span>
<span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">ata_sff_dev_classify</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">present</span><span class="p">,</span>
				  <span class="n">u8</span> <span class="o">*</span><span class="n">r_err</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">link</span><span class="o">-&gt;</span><span class="n">ap</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ata_taskfile</span> <span class="n">tf</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">class</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">ap</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">sff_dev_select</span><span class="p">(</span><span class="n">ap</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">devno</span><span class="p">);</span>

	<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tf</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">tf</span><span class="p">));</span>

	<span class="n">ap</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">sff_tf_read</span><span class="p">(</span><span class="n">ap</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tf</span><span class="p">);</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">tf</span><span class="p">.</span><span class="n">feature</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">r_err</span><span class="p">)</span>
		<span class="o">*</span><span class="n">r_err</span> <span class="o">=</span> <span class="n">err</span><span class="p">;</span>

	<span class="cm">/* see if device passed diags: continue and warn later */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="cm">/* diagnostic fail : do nothing _YET_ */</span>
		<span class="n">dev</span><span class="o">-&gt;</span><span class="n">horkage</span> <span class="o">|=</span> <span class="n">ATA_HORKAGE_DIAGNOSTIC</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
		<span class="cm">/* do nothing */</span> <span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">devno</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">err</span> <span class="o">==</span> <span class="mh">0x81</span><span class="p">))</span>
		<span class="cm">/* do nothing */</span> <span class="p">;</span>
	<span class="k">else</span>
		<span class="k">return</span> <span class="n">ATA_DEV_NONE</span><span class="p">;</span>

	<span class="cm">/* determine if device is ATA or ATAPI */</span>
	<span class="n">class</span> <span class="o">=</span> <span class="n">ata_dev_classify</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tf</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">class</span> <span class="o">==</span> <span class="n">ATA_DEV_UNKNOWN</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* If the device failed diagnostic, it&#39;s likely to</span>
<span class="cm">		 * have reported incorrect device signature too.</span>
<span class="cm">		 * Assume ATA device if the device seems present but</span>
<span class="cm">		 * device signature is invalid with diagnostic</span>
<span class="cm">		 * failure.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">present</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">horkage</span> <span class="o">&amp;</span> <span class="n">ATA_HORKAGE_DIAGNOSTIC</span><span class="p">))</span>
			<span class="n">class</span> <span class="o">=</span> <span class="n">ATA_DEV_ATA</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">class</span> <span class="o">=</span> <span class="n">ATA_DEV_NONE</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">class</span> <span class="o">==</span> <span class="n">ATA_DEV_ATA</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		   <span class="p">(</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">sff_check_status</span><span class="p">(</span><span class="n">ap</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span>
		<span class="n">class</span> <span class="o">=</span> <span class="n">ATA_DEV_NONE</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">class</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">ata_sff_dev_classify</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> *	ata_sff_wait_after_reset - wait for devices to become ready after reset</span>
<span class="cm"> *	@link: SFF link which is just reset</span>
<span class="cm"> *	@devmask: mask of present devices</span>
<span class="cm"> *	@deadline: deadline jiffies for the operation</span>
<span class="cm"> *</span>
<span class="cm"> *	Wait devices attached to SFF @link to become ready after</span>
<span class="cm"> *	reset.  It contains preceding 150ms wait to avoid accessing TF</span>
<span class="cm"> *	status register too early.</span>
<span class="cm"> *</span>
<span class="cm"> *	LOCKING:</span>
<span class="cm"> *	Kernel thread context (may sleep).</span>
<span class="cm"> *</span>
<span class="cm"> *	RETURNS:</span>
<span class="cm"> *	0 on success, -ENODEV if some or all of devices in @devmask</span>
<span class="cm"> *	don&#39;t seem to exist.  -errno on other errors.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">ata_sff_wait_after_reset</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_link</span> <span class="o">*</span><span class="n">link</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">devmask</span><span class="p">,</span>
			     <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">deadline</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span> <span class="o">=</span> <span class="n">link</span><span class="o">-&gt;</span><span class="n">ap</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ata_ioports</span> <span class="o">*</span><span class="n">ioaddr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">ioaddr</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">dev0</span> <span class="o">=</span> <span class="n">devmask</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">0</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">dev1</span> <span class="o">=</span> <span class="n">devmask</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">,</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">ata_msleep</span><span class="p">(</span><span class="n">ap</span><span class="p">,</span> <span class="n">ATA_WAIT_AFTER_RESET</span><span class="p">);</span>

	<span class="cm">/* always check readiness of the master device */</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">ata_sff_wait_ready</span><span class="p">(</span><span class="n">link</span><span class="p">,</span> <span class="n">deadline</span><span class="p">);</span>
	<span class="cm">/* -ENODEV means the odd clown forgot the D7 pulldown resistor</span>
<span class="cm">	 * and TF status is 0xff, bail out on it too.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>

	<span class="cm">/* if device 1 was found in ata_devchk, wait for register</span>
<span class="cm">	 * access briefly, then wait for BSY to clear.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dev1</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

		<span class="n">ap</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">sff_dev_select</span><span class="p">(</span><span class="n">ap</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

		<span class="cm">/* Wait for register access.  Some ATAPI devices fail</span>
<span class="cm">		 * to set nsect/lbal after reset, so don&#39;t waste too</span>
<span class="cm">		 * much time on it.  We&#39;re gonna wait for !BSY anyway.</span>
<span class="cm">		 */</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">u8</span> <span class="n">nsect</span><span class="p">,</span> <span class="n">lbal</span><span class="p">;</span>

			<span class="n">nsect</span> <span class="o">=</span> <span class="n">ioread8</span><span class="p">(</span><span class="n">ioaddr</span><span class="o">-&gt;</span><span class="n">nsect_addr</span><span class="p">);</span>
			<span class="n">lbal</span> <span class="o">=</span> <span class="n">ioread8</span><span class="p">(</span><span class="n">ioaddr</span><span class="o">-&gt;</span><span class="n">lbal_addr</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">nsect</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">lbal</span> <span class="o">==</span> <span class="mi">1</span><span class="p">))</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="n">ata_msleep</span><span class="p">(</span><span class="n">ap</span><span class="p">,</span> <span class="mi">50</span><span class="p">);</span>	<span class="cm">/* give drive a breather */</span>
		<span class="p">}</span>

		<span class="n">rc</span> <span class="o">=</span> <span class="n">ata_sff_wait_ready</span><span class="p">(</span><span class="n">link</span><span class="p">,</span> <span class="n">deadline</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">!=</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">)</span>
				<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">rc</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* is all this really necessary? */</span>
	<span class="n">ap</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">sff_dev_select</span><span class="p">(</span><span class="n">ap</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dev1</span><span class="p">)</span>
		<span class="n">ap</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">sff_dev_select</span><span class="p">(</span><span class="n">ap</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dev0</span><span class="p">)</span>
		<span class="n">ap</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">sff_dev_select</span><span class="p">(</span><span class="n">ap</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">ata_sff_wait_after_reset</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">ata_bus_softreset</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">devmask</span><span class="p">,</span>
			     <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">deadline</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ata_ioports</span> <span class="o">*</span><span class="n">ioaddr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">ioaddr</span><span class="p">;</span>

	<span class="n">DPRINTK</span><span class="p">(</span><span class="s">&quot;ata%u: bus reset via SRST</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ap</span><span class="o">-&gt;</span><span class="n">print_id</span><span class="p">);</span>

	<span class="cm">/* software reset.  causes dev0 to be selected */</span>
	<span class="n">iowrite8</span><span class="p">(</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">ctl</span><span class="p">,</span> <span class="n">ioaddr</span><span class="o">-&gt;</span><span class="n">ctl_addr</span><span class="p">);</span>
	<span class="n">udelay</span><span class="p">(</span><span class="mi">20</span><span class="p">);</span>	<span class="cm">/* FIXME: flush */</span>
	<span class="n">iowrite8</span><span class="p">(</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">ctl</span> <span class="o">|</span> <span class="n">ATA_SRST</span><span class="p">,</span> <span class="n">ioaddr</span><span class="o">-&gt;</span><span class="n">ctl_addr</span><span class="p">);</span>
	<span class="n">udelay</span><span class="p">(</span><span class="mi">20</span><span class="p">);</span>	<span class="cm">/* FIXME: flush */</span>
	<span class="n">iowrite8</span><span class="p">(</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">ctl</span><span class="p">,</span> <span class="n">ioaddr</span><span class="o">-&gt;</span><span class="n">ctl_addr</span><span class="p">);</span>
	<span class="n">ap</span><span class="o">-&gt;</span><span class="n">last_ctl</span> <span class="o">=</span> <span class="n">ap</span><span class="o">-&gt;</span><span class="n">ctl</span><span class="p">;</span>

	<span class="cm">/* wait the port to become ready */</span>
	<span class="k">return</span> <span class="n">ata_sff_wait_after_reset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">link</span><span class="p">,</span> <span class="n">devmask</span><span class="p">,</span> <span class="n">deadline</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	ata_sff_softreset - reset host port via ATA SRST</span>
<span class="cm"> *	@link: ATA link to reset</span>
<span class="cm"> *	@classes: resulting classes of attached devices</span>
<span class="cm"> *	@deadline: deadline jiffies for the operation</span>
<span class="cm"> *</span>
<span class="cm"> *	Reset host port using ATA SRST.</span>
<span class="cm"> *</span>
<span class="cm"> *	LOCKING:</span>
<span class="cm"> *	Kernel thread context (may sleep)</span>
<span class="cm"> *</span>
<span class="cm"> *	RETURNS:</span>
<span class="cm"> *	0 on success, -errno otherwise.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">ata_sff_softreset</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_link</span> <span class="o">*</span><span class="n">link</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">classes</span><span class="p">,</span>
		      <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">deadline</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span> <span class="o">=</span> <span class="n">link</span><span class="o">-&gt;</span><span class="n">ap</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">slave_possible</span> <span class="o">=</span> <span class="n">ap</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">ATA_FLAG_SLAVE_POSS</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">devmask</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">DPRINTK</span><span class="p">(</span><span class="s">&quot;ENTER</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="cm">/* determine if device 0/1 are present */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ata_devchk</span><span class="p">(</span><span class="n">ap</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
		<span class="n">devmask</span> <span class="o">|=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">slave_possible</span> <span class="o">&amp;&amp;</span> <span class="n">ata_devchk</span><span class="p">(</span><span class="n">ap</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
		<span class="n">devmask</span> <span class="o">|=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">);</span>

	<span class="cm">/* select device 0 again */</span>
	<span class="n">ap</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">sff_dev_select</span><span class="p">(</span><span class="n">ap</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="cm">/* issue bus reset */</span>
	<span class="n">DPRINTK</span><span class="p">(</span><span class="s">&quot;about to softreset, devmask=%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">devmask</span><span class="p">);</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">ata_bus_softreset</span><span class="p">(</span><span class="n">ap</span><span class="p">,</span> <span class="n">devmask</span><span class="p">,</span> <span class="n">deadline</span><span class="p">);</span>
	<span class="cm">/* if link is occupied, -ENODEV too is an error */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">rc</span> <span class="o">!=</span> <span class="o">-</span><span class="n">ENODEV</span> <span class="o">||</span> <span class="n">sata_scr_valid</span><span class="p">(</span><span class="n">link</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">ata_link_err</span><span class="p">(</span><span class="n">link</span><span class="p">,</span> <span class="s">&quot;SRST failed (errno=%d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">rc</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* determine by signature whether we have ATA or ATAPI devices */</span>
	<span class="n">classes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">ata_sff_dev_classify</span><span class="p">(</span><span class="o">&amp;</span><span class="n">link</span><span class="o">-&gt;</span><span class="n">device</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
					  <span class="n">devmask</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">0</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">err</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">slave_possible</span> <span class="o">&amp;&amp;</span> <span class="n">err</span> <span class="o">!=</span> <span class="mh">0x81</span><span class="p">)</span>
		<span class="n">classes</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">ata_sff_dev_classify</span><span class="p">(</span><span class="o">&amp;</span><span class="n">link</span><span class="o">-&gt;</span><span class="n">device</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
						  <span class="n">devmask</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">err</span><span class="p">);</span>

	<span class="n">DPRINTK</span><span class="p">(</span><span class="s">&quot;EXIT, classes[0]=%u [1]=%u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">classes</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">classes</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">ata_sff_softreset</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> *	sata_sff_hardreset - reset host port via SATA phy reset</span>
<span class="cm"> *	@link: link to reset</span>
<span class="cm"> *	@class: resulting class of attached device</span>
<span class="cm"> *	@deadline: deadline jiffies for the operation</span>
<span class="cm"> *</span>
<span class="cm"> *	SATA phy-reset host port using DET bits of SControl register,</span>
<span class="cm"> *	wait for !BSY and classify the attached device.</span>
<span class="cm"> *</span>
<span class="cm"> *	LOCKING:</span>
<span class="cm"> *	Kernel thread context (may sleep)</span>
<span class="cm"> *</span>
<span class="cm"> *	RETURNS:</span>
<span class="cm"> *	0 on success, -errno otherwise.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">sata_sff_hardreset</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_link</span> <span class="o">*</span><span class="n">link</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">class</span><span class="p">,</span>
		       <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">deadline</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ata_eh_context</span> <span class="o">*</span><span class="n">ehc</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">link</span><span class="o">-&gt;</span><span class="n">eh_context</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">timing</span> <span class="o">=</span> <span class="n">sata_ehc_deb_timing</span><span class="p">(</span><span class="n">ehc</span><span class="p">);</span>
	<span class="n">bool</span> <span class="n">online</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">sata_link_hardreset</span><span class="p">(</span><span class="n">link</span><span class="p">,</span> <span class="n">timing</span><span class="p">,</span> <span class="n">deadline</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">online</span><span class="p">,</span>
				 <span class="n">ata_sff_check_ready</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">online</span><span class="p">)</span>
		<span class="o">*</span><span class="n">class</span> <span class="o">=</span> <span class="n">ata_sff_dev_classify</span><span class="p">(</span><span class="n">link</span><span class="o">-&gt;</span><span class="n">device</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

	<span class="n">DPRINTK</span><span class="p">(</span><span class="s">&quot;EXIT, class=%u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="o">*</span><span class="n">class</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">sata_sff_hardreset</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> *	ata_sff_postreset - SFF postreset callback</span>
<span class="cm"> *	@link: the target SFF ata_link</span>
<span class="cm"> *	@classes: classes of attached devices</span>
<span class="cm"> *</span>
<span class="cm"> *	This function is invoked after a successful reset.  It first</span>
<span class="cm"> *	calls ata_std_postreset() and performs SFF specific postreset</span>
<span class="cm"> *	processing.</span>
<span class="cm"> *</span>
<span class="cm"> *	LOCKING:</span>
<span class="cm"> *	Kernel thread context (may sleep)</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">ata_sff_postreset</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_link</span> <span class="o">*</span><span class="n">link</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">classes</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span> <span class="o">=</span> <span class="n">link</span><span class="o">-&gt;</span><span class="n">ap</span><span class="p">;</span>

	<span class="n">ata_std_postreset</span><span class="p">(</span><span class="n">link</span><span class="p">,</span> <span class="n">classes</span><span class="p">);</span>

	<span class="cm">/* is double-select really necessary? */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">classes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">ATA_DEV_NONE</span><span class="p">)</span>
		<span class="n">ap</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">sff_dev_select</span><span class="p">(</span><span class="n">ap</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">classes</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="n">ATA_DEV_NONE</span><span class="p">)</span>
		<span class="n">ap</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">sff_dev_select</span><span class="p">(</span><span class="n">ap</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="cm">/* bail out if no device is present */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">classes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">ATA_DEV_NONE</span> <span class="o">&amp;&amp;</span> <span class="n">classes</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">ATA_DEV_NONE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">DPRINTK</span><span class="p">(</span><span class="s">&quot;EXIT, no device</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* set up device control */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">sff_set_devctl</span> <span class="o">||</span> <span class="n">ap</span><span class="o">-&gt;</span><span class="n">ioaddr</span><span class="p">.</span><span class="n">ctl_addr</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ata_sff_set_devctl</span><span class="p">(</span><span class="n">ap</span><span class="p">,</span> <span class="n">ap</span><span class="o">-&gt;</span><span class="n">ctl</span><span class="p">);</span>
		<span class="n">ap</span><span class="o">-&gt;</span><span class="n">last_ctl</span> <span class="o">=</span> <span class="n">ap</span><span class="o">-&gt;</span><span class="n">ctl</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">ata_sff_postreset</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> *	ata_sff_drain_fifo - Stock FIFO drain logic for SFF controllers</span>
<span class="cm"> *	@qc: command</span>
<span class="cm"> *</span>
<span class="cm"> *	Drain the FIFO and device of any stuck data following a command</span>
<span class="cm"> *	failing to complete. In some cases this is necessary before a</span>
<span class="cm"> *	reset will recover the device.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>

<span class="kt">void</span> <span class="nf">ata_sff_drain_fifo</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_queued_cmd</span> <span class="o">*</span><span class="n">qc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">count</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span><span class="p">;</span>

	<span class="cm">/* We only need to flush incoming data when a command was running */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">qc</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="o">||</span> <span class="n">qc</span><span class="o">-&gt;</span><span class="n">dma_dir</span> <span class="o">==</span> <span class="n">DMA_TO_DEVICE</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">ap</span> <span class="o">=</span> <span class="n">qc</span><span class="o">-&gt;</span><span class="n">ap</span><span class="p">;</span>
	<span class="cm">/* Drain up to 64K of data before we give up this recovery method */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="p">(</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">sff_check_status</span><span class="p">(</span><span class="n">ap</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">ATA_DRQ</span><span class="p">)</span>
						<span class="o">&amp;&amp;</span> <span class="n">count</span> <span class="o">&lt;</span> <span class="mi">65536</span><span class="p">;</span> <span class="n">count</span> <span class="o">+=</span> <span class="mi">2</span><span class="p">)</span>
		<span class="n">ioread16</span><span class="p">(</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">ioaddr</span><span class="p">.</span><span class="n">data_addr</span><span class="p">);</span>

	<span class="cm">/* Can become DEBUG later */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">count</span><span class="p">)</span>
		<span class="n">ata_port_dbg</span><span class="p">(</span><span class="n">ap</span><span class="p">,</span> <span class="s">&quot;drained %d bytes to clear DRQ</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">count</span><span class="p">);</span>

<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">ata_sff_drain_fifo</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> *	ata_sff_error_handler - Stock error handler for SFF controller</span>
<span class="cm"> *	@ap: port to handle error for</span>
<span class="cm"> *</span>
<span class="cm"> *	Stock error handler for SFF controller.  It can handle both</span>
<span class="cm"> *	PATA and SATA controllers.  Many controllers should be able to</span>
<span class="cm"> *	use this EH as-is or with some added handling before and</span>
<span class="cm"> *	after.</span>
<span class="cm"> *</span>
<span class="cm"> *	LOCKING:</span>
<span class="cm"> *	Kernel thread context (may sleep)</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">ata_sff_error_handler</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ata_reset_fn_t</span> <span class="n">softreset</span> <span class="o">=</span> <span class="n">ap</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">softreset</span><span class="p">;</span>
	<span class="n">ata_reset_fn_t</span> <span class="n">hardreset</span> <span class="o">=</span> <span class="n">ap</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">hardreset</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ata_queued_cmd</span> <span class="o">*</span><span class="n">qc</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">qc</span> <span class="o">=</span> <span class="n">__ata_qc_from_tag</span><span class="p">(</span><span class="n">ap</span><span class="p">,</span> <span class="n">ap</span><span class="o">-&gt;</span><span class="n">link</span><span class="p">.</span><span class="n">active_tag</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">qc</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">qc</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">ATA_QCFLAG_FAILED</span><span class="p">))</span>
		<span class="n">qc</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * We *MUST* do FIFO draining before we issue a reset as</span>
<span class="cm">	 * several devices helpfully clear their internal state and</span>
<span class="cm">	 * will lock solid if we touch the data port post reset. Pass</span>
<span class="cm">	 * qc in case anyone wants to do different PIO/DMA recovery or</span>
<span class="cm">	 * has per command fixups</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">sff_drain_fifo</span><span class="p">)</span>
		<span class="n">ap</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">sff_drain_fifo</span><span class="p">(</span><span class="n">qc</span><span class="p">);</span>

	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="cm">/* ignore ata_sff_softreset if ctl isn&#39;t accessible */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">softreset</span> <span class="o">==</span> <span class="n">ata_sff_softreset</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">ioaddr</span><span class="p">.</span><span class="n">ctl_addr</span><span class="p">)</span>
		<span class="n">softreset</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="cm">/* ignore built-in hardresets if SCR access is not available */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">hardreset</span> <span class="o">==</span> <span class="n">sata_std_hardreset</span> <span class="o">||</span>
	     <span class="n">hardreset</span> <span class="o">==</span> <span class="n">sata_sff_hardreset</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">sata_scr_valid</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">link</span><span class="p">))</span>
		<span class="n">hardreset</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">ata_do_eh</span><span class="p">(</span><span class="n">ap</span><span class="p">,</span> <span class="n">ap</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">prereset</span><span class="p">,</span> <span class="n">softreset</span><span class="p">,</span> <span class="n">hardreset</span><span class="p">,</span>
		  <span class="n">ap</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">postreset</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">ata_sff_error_handler</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> *	ata_sff_std_ports - initialize ioaddr with standard port offsets.</span>
<span class="cm"> *	@ioaddr: IO address structure to be initialized</span>
<span class="cm"> *</span>
<span class="cm"> *	Utility function which initializes data_addr, error_addr,</span>
<span class="cm"> *	feature_addr, nsect_addr, lbal_addr, lbam_addr, lbah_addr,</span>
<span class="cm"> *	device_addr, status_addr, and command_addr to standard offsets</span>
<span class="cm"> *	relative to cmd_addr.</span>
<span class="cm"> *</span>
<span class="cm"> *	Does not set ctl_addr, altstatus_addr, bmdma_addr, or scr_addr.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">ata_sff_std_ports</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_ioports</span> <span class="o">*</span><span class="n">ioaddr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ioaddr</span><span class="o">-&gt;</span><span class="n">data_addr</span> <span class="o">=</span> <span class="n">ioaddr</span><span class="o">-&gt;</span><span class="n">cmd_addr</span> <span class="o">+</span> <span class="n">ATA_REG_DATA</span><span class="p">;</span>
	<span class="n">ioaddr</span><span class="o">-&gt;</span><span class="n">error_addr</span> <span class="o">=</span> <span class="n">ioaddr</span><span class="o">-&gt;</span><span class="n">cmd_addr</span> <span class="o">+</span> <span class="n">ATA_REG_ERR</span><span class="p">;</span>
	<span class="n">ioaddr</span><span class="o">-&gt;</span><span class="n">feature_addr</span> <span class="o">=</span> <span class="n">ioaddr</span><span class="o">-&gt;</span><span class="n">cmd_addr</span> <span class="o">+</span> <span class="n">ATA_REG_FEATURE</span><span class="p">;</span>
	<span class="n">ioaddr</span><span class="o">-&gt;</span><span class="n">nsect_addr</span> <span class="o">=</span> <span class="n">ioaddr</span><span class="o">-&gt;</span><span class="n">cmd_addr</span> <span class="o">+</span> <span class="n">ATA_REG_NSECT</span><span class="p">;</span>
	<span class="n">ioaddr</span><span class="o">-&gt;</span><span class="n">lbal_addr</span> <span class="o">=</span> <span class="n">ioaddr</span><span class="o">-&gt;</span><span class="n">cmd_addr</span> <span class="o">+</span> <span class="n">ATA_REG_LBAL</span><span class="p">;</span>
	<span class="n">ioaddr</span><span class="o">-&gt;</span><span class="n">lbam_addr</span> <span class="o">=</span> <span class="n">ioaddr</span><span class="o">-&gt;</span><span class="n">cmd_addr</span> <span class="o">+</span> <span class="n">ATA_REG_LBAM</span><span class="p">;</span>
	<span class="n">ioaddr</span><span class="o">-&gt;</span><span class="n">lbah_addr</span> <span class="o">=</span> <span class="n">ioaddr</span><span class="o">-&gt;</span><span class="n">cmd_addr</span> <span class="o">+</span> <span class="n">ATA_REG_LBAH</span><span class="p">;</span>
	<span class="n">ioaddr</span><span class="o">-&gt;</span><span class="n">device_addr</span> <span class="o">=</span> <span class="n">ioaddr</span><span class="o">-&gt;</span><span class="n">cmd_addr</span> <span class="o">+</span> <span class="n">ATA_REG_DEVICE</span><span class="p">;</span>
	<span class="n">ioaddr</span><span class="o">-&gt;</span><span class="n">status_addr</span> <span class="o">=</span> <span class="n">ioaddr</span><span class="o">-&gt;</span><span class="n">cmd_addr</span> <span class="o">+</span> <span class="n">ATA_REG_STATUS</span><span class="p">;</span>
	<span class="n">ioaddr</span><span class="o">-&gt;</span><span class="n">command_addr</span> <span class="o">=</span> <span class="n">ioaddr</span><span class="o">-&gt;</span><span class="n">cmd_addr</span> <span class="o">+</span> <span class="n">ATA_REG_CMD</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">ata_sff_std_ports</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_PCI</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">ata_resources_present</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">port</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="cm">/* Check the PCI resources for this channel are enabled */</span>
	<span class="n">port</span> <span class="o">=</span> <span class="n">port</span> <span class="o">*</span> <span class="mi">2</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pci_resource_start</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">port</span> <span class="o">+</span> <span class="n">i</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span>
		    <span class="n">pci_resource_len</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">port</span> <span class="o">+</span> <span class="n">i</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	ata_pci_sff_init_host - acquire native PCI ATA resources and init host</span>
<span class="cm"> *	@host: target ATA host</span>
<span class="cm"> *</span>
<span class="cm"> *	Acquire native PCI ATA resources for @host and initialize the</span>
<span class="cm"> *	first two ports of @host accordingly.  Ports marked dummy are</span>
<span class="cm"> *	skipped and allocation failure makes the port dummy.</span>
<span class="cm"> *</span>
<span class="cm"> *	Note that native PCI resources are valid even for legacy hosts</span>
<span class="cm"> *	as we fix up pdev resources array early in boot, so this</span>
<span class="cm"> *	function can be used for both native and legacy SFF hosts.</span>
<span class="cm"> *</span>
<span class="cm"> *	LOCKING:</span>
<span class="cm"> *	Inherited from calling layer (may sleep).</span>
<span class="cm"> *</span>
<span class="cm"> *	RETURNS:</span>
<span class="cm"> *	0 if at least one port is initialized, -ENODEV if no port is</span>
<span class="cm"> *	available.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">ata_pci_sff_init_host</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_host</span> <span class="o">*</span><span class="n">host</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">gdev</span> <span class="o">=</span> <span class="n">host</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span> <span class="o">=</span> <span class="n">to_pci_dev</span><span class="p">(</span><span class="n">gdev</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">mask</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">rc</span><span class="p">;</span>

	<span class="cm">/* request, iomap BARs and init port addresses accordingly */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span> <span class="o">=</span> <span class="n">host</span><span class="o">-&gt;</span><span class="n">ports</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="kt">int</span> <span class="n">base</span> <span class="o">=</span> <span class="n">i</span> <span class="o">*</span> <span class="mi">2</span><span class="p">;</span>
		<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span> <span class="k">const</span> <span class="o">*</span><span class="n">iomap</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">ata_port_is_dummy</span><span class="p">(</span><span class="n">ap</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="cm">/* Discard disabled ports.  Some controllers show</span>
<span class="cm">		 * their unused channels this way.  Disabled ports are</span>
<span class="cm">		 * made dummy.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ata_resources_present</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">i</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">ap</span><span class="o">-&gt;</span><span class="n">ops</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ata_dummy_port_ops</span><span class="p">;</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">rc</span> <span class="o">=</span> <span class="n">pcim_iomap_regions</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="mh">0x3</span> <span class="o">&lt;&lt;</span> <span class="n">base</span><span class="p">,</span>
					<span class="n">dev_driver_string</span><span class="p">(</span><span class="n">gdev</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dev_warn</span><span class="p">(</span><span class="n">gdev</span><span class="p">,</span>
				 <span class="s">&quot;failed to request/iomap BARs for port %d (errno=%d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				 <span class="n">i</span><span class="p">,</span> <span class="n">rc</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">==</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">)</span>
				<span class="n">pcim_pin_device</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
			<span class="n">ap</span><span class="o">-&gt;</span><span class="n">ops</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ata_dummy_port_ops</span><span class="p">;</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">host</span><span class="o">-&gt;</span><span class="n">iomap</span> <span class="o">=</span> <span class="n">iomap</span> <span class="o">=</span> <span class="n">pcim_iomap_table</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>

		<span class="n">ap</span><span class="o">-&gt;</span><span class="n">ioaddr</span><span class="p">.</span><span class="n">cmd_addr</span> <span class="o">=</span> <span class="n">iomap</span><span class="p">[</span><span class="n">base</span><span class="p">];</span>
		<span class="n">ap</span><span class="o">-&gt;</span><span class="n">ioaddr</span><span class="p">.</span><span class="n">altstatus_addr</span> <span class="o">=</span>
		<span class="n">ap</span><span class="o">-&gt;</span><span class="n">ioaddr</span><span class="p">.</span><span class="n">ctl_addr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="p">)</span>
			<span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">iomap</span><span class="p">[</span><span class="n">base</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">|</span> <span class="n">ATA_PCI_CTL_OFS</span><span class="p">);</span>
		<span class="n">ata_sff_std_ports</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">ioaddr</span><span class="p">);</span>

		<span class="n">ata_port_desc</span><span class="p">(</span><span class="n">ap</span><span class="p">,</span> <span class="s">&quot;cmd 0x%llx ctl 0x%llx&quot;</span><span class="p">,</span>
			<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">pci_resource_start</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">base</span><span class="p">),</span>
			<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">pci_resource_start</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">base</span> <span class="o">+</span> <span class="mi">1</span><span class="p">));</span>

		<span class="n">mask</span> <span class="o">|=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">i</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mask</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="n">gdev</span><span class="p">,</span> <span class="s">&quot;no available native port</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">ata_pci_sff_init_host</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> *	ata_pci_sff_prepare_host - helper to prepare PCI PIO-only SFF ATA host</span>
<span class="cm"> *	@pdev: target PCI device</span>
<span class="cm"> *	@ppi: array of port_info, must be enough for two ports</span>
<span class="cm"> *	@r_host: out argument for the initialized ATA host</span>
<span class="cm"> *</span>
<span class="cm"> *	Helper to allocate PIO-only SFF ATA host for @pdev, acquire</span>
<span class="cm"> *	all PCI resources and initialize it accordingly in one go.</span>
<span class="cm"> *</span>
<span class="cm"> *	LOCKING:</span>
<span class="cm"> *	Inherited from calling layer (may sleep).</span>
<span class="cm"> *</span>
<span class="cm"> *	RETURNS:</span>
<span class="cm"> *	0 on success, -errno otherwise.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">ata_pci_sff_prepare_host</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">,</span>
			     <span class="k">const</span> <span class="k">struct</span> <span class="n">ata_port_info</span> <span class="o">*</span> <span class="k">const</span> <span class="o">*</span><span class="n">ppi</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">ata_host</span> <span class="o">**</span><span class="n">r_host</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ata_host</span> <span class="o">*</span><span class="n">host</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">devres_open_group</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">host</span> <span class="o">=</span> <span class="n">ata_host_alloc_pinfo</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">ppi</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">host</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;failed to allocate ATA host</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">err_out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">ata_pci_sff_init_host</span><span class="p">(</span><span class="n">host</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err_out</span><span class="p">;</span>

	<span class="n">devres_remove_group</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="o">*</span><span class="n">r_host</span> <span class="o">=</span> <span class="n">host</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">err_out:</span>
	<span class="n">devres_release_group</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">ata_pci_sff_prepare_host</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> *	ata_pci_sff_activate_host - start SFF host, request IRQ and register it</span>
<span class="cm"> *	@host: target SFF ATA host</span>
<span class="cm"> *	@irq_handler: irq_handler used when requesting IRQ(s)</span>
<span class="cm"> *	@sht: scsi_host_template to use when registering the host</span>
<span class="cm"> *</span>
<span class="cm"> *	This is the counterpart of ata_host_activate() for SFF ATA</span>
<span class="cm"> *	hosts.  This separate helper is necessary because SFF hosts</span>
<span class="cm"> *	use two separate interrupts in legacy mode.</span>
<span class="cm"> *</span>
<span class="cm"> *	LOCKING:</span>
<span class="cm"> *	Inherited from calling layer (may sleep).</span>
<span class="cm"> *</span>
<span class="cm"> *	RETURNS:</span>
<span class="cm"> *	0 on success, -errno otherwise.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">ata_pci_sff_activate_host</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_host</span> <span class="o">*</span><span class="n">host</span><span class="p">,</span>
			      <span class="n">irq_handler_t</span> <span class="n">irq_handler</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">scsi_host_template</span> <span class="o">*</span><span class="n">sht</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">host</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span> <span class="o">=</span> <span class="n">to_pci_dev</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">drv_name</span> <span class="o">=</span> <span class="n">dev_driver_string</span><span class="p">(</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">legacy_mode</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">ata_host_start</span><span class="p">(</span><span class="n">host</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">class</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">==</span> <span class="n">PCI_CLASS_STORAGE_IDE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">u8</span> <span class="n">tmp8</span><span class="p">,</span> <span class="n">mask</span><span class="p">;</span>

		<span class="cm">/* TODO: What if one channel is in native mode ... */</span>
		<span class="n">pci_read_config_byte</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">PCI_CLASS_PROG</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tmp8</span><span class="p">);</span>
		<span class="n">mask</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">tmp8</span> <span class="o">&amp;</span> <span class="n">mask</span><span class="p">)</span> <span class="o">!=</span> <span class="n">mask</span><span class="p">)</span>
			<span class="n">legacy_mode</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="cp">#if defined(CONFIG_NO_ATA_LEGACY)</span>
		<span class="cm">/* Some platforms with PCI limits cannot address compat</span>
<span class="cm">		   port space. In that case we punt if their firmware has</span>
<span class="cm">		   left a device in compatibility mode */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">legacy_mode</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;ata: Compatibility mode ATA is not supported on this platform, skipping.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EOPNOTSUPP</span><span class="p">;</span>
		<span class="p">}</span>
<span class="cp">#endif</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">devres_open_group</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">legacy_mode</span> <span class="o">&amp;&amp;</span> <span class="n">pdev</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

		<span class="n">rc</span> <span class="o">=</span> <span class="n">devm_request_irq</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">pdev</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">,</span> <span class="n">irq_handler</span><span class="p">,</span>
				      <span class="n">IRQF_SHARED</span><span class="p">,</span> <span class="n">drv_name</span><span class="p">,</span> <span class="n">host</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ata_port_is_dummy</span><span class="p">(</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">ports</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="n">ata_port_desc</span><span class="p">(</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">ports</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="s">&quot;irq %d&quot;</span><span class="p">,</span> <span class="n">pdev</span><span class="o">-&gt;</span><span class="n">irq</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">legacy_mode</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ata_port_is_dummy</span><span class="p">(</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">ports</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span> <span class="p">{</span>
			<span class="n">rc</span> <span class="o">=</span> <span class="n">devm_request_irq</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">ATA_PRIMARY_IRQ</span><span class="p">(</span><span class="n">pdev</span><span class="p">),</span>
					      <span class="n">irq_handler</span><span class="p">,</span> <span class="n">IRQF_SHARED</span><span class="p">,</span>
					      <span class="n">drv_name</span><span class="p">,</span> <span class="n">host</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

			<span class="n">ata_port_desc</span><span class="p">(</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">ports</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="s">&quot;irq %d&quot;</span><span class="p">,</span>
				      <span class="n">ATA_PRIMARY_IRQ</span><span class="p">(</span><span class="n">pdev</span><span class="p">));</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ata_port_is_dummy</span><span class="p">(</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">ports</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span> <span class="p">{</span>
			<span class="n">rc</span> <span class="o">=</span> <span class="n">devm_request_irq</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">ATA_SECONDARY_IRQ</span><span class="p">(</span><span class="n">pdev</span><span class="p">),</span>
					      <span class="n">irq_handler</span><span class="p">,</span> <span class="n">IRQF_SHARED</span><span class="p">,</span>
					      <span class="n">drv_name</span><span class="p">,</span> <span class="n">host</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

			<span class="n">ata_port_desc</span><span class="p">(</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">ports</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="s">&quot;irq %d&quot;</span><span class="p">,</span>
				      <span class="n">ATA_SECONDARY_IRQ</span><span class="p">(</span><span class="n">pdev</span><span class="p">));</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">ata_host_register</span><span class="p">(</span><span class="n">host</span><span class="p">,</span> <span class="n">sht</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">devres_remove_group</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">devres_release_group</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">ata_pci_sff_activate_host</span><span class="p">);</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">ata_port_info</span> <span class="o">*</span><span class="nf">ata_sff_find_valid_pi</span><span class="p">(</span>
					<span class="k">const</span> <span class="k">struct</span> <span class="n">ata_port_info</span> <span class="o">*</span> <span class="k">const</span> <span class="o">*</span><span class="n">ppi</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="cm">/* look up the first valid port_info */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">2</span> <span class="o">&amp;&amp;</span> <span class="n">ppi</span><span class="p">[</span><span class="n">i</span><span class="p">];</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ppi</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">port_ops</span> <span class="o">!=</span> <span class="o">&amp;</span><span class="n">ata_dummy_port_ops</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">ppi</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">ata_pci_init_one</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">,</span>
		<span class="k">const</span> <span class="k">struct</span> <span class="n">ata_port_info</span> <span class="o">*</span> <span class="k">const</span> <span class="o">*</span><span class="n">ppi</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">scsi_host_template</span> <span class="o">*</span><span class="n">sht</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">host_priv</span><span class="p">,</span>
		<span class="kt">int</span> <span class="n">hflags</span><span class="p">,</span> <span class="n">bool</span> <span class="n">bmdma</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">ata_port_info</span> <span class="o">*</span><span class="n">pi</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ata_host</span> <span class="o">*</span><span class="n">host</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">DPRINTK</span><span class="p">(</span><span class="s">&quot;ENTER</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="n">pi</span> <span class="o">=</span> <span class="n">ata_sff_find_valid_pi</span><span class="p">(</span><span class="n">ppi</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pi</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_err</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;no valid port_info specified</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">devres_open_group</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">pcim_enable_device</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_ATA_BMDMA</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bmdma</span><span class="p">)</span>
		<span class="cm">/* prepare and activate BMDMA host */</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">ata_pci_bmdma_prepare_host</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">ppi</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">host</span><span class="p">);</span>
	<span class="k">else</span>
<span class="cp">#endif</span>
		<span class="cm">/* prepare and activate SFF host */</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">ata_pci_sff_prepare_host</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">ppi</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">host</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="n">host</span><span class="o">-&gt;</span><span class="n">private_data</span> <span class="o">=</span> <span class="n">host_priv</span><span class="p">;</span>
	<span class="n">host</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">hflags</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_ATA_BMDMA</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bmdma</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pci_set_master</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">ata_pci_sff_activate_host</span><span class="p">(</span><span class="n">host</span><span class="p">,</span> <span class="n">ata_bmdma_interrupt</span><span class="p">,</span> <span class="n">sht</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span>
<span class="cp">#endif</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">ata_pci_sff_activate_host</span><span class="p">(</span><span class="n">host</span><span class="p">,</span> <span class="n">ata_sff_interrupt</span><span class="p">,</span> <span class="n">sht</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">devres_remove_group</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">devres_release_group</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	ata_pci_sff_init_one - Initialize/register PIO-only PCI IDE controller</span>
<span class="cm"> *	@pdev: Controller to be initialized</span>
<span class="cm"> *	@ppi: array of port_info, must be enough for two ports</span>
<span class="cm"> *	@sht: scsi_host_template to use when registering the host</span>
<span class="cm"> *	@host_priv: host private_data</span>
<span class="cm"> *	@hflag: host flags</span>
<span class="cm"> *</span>
<span class="cm"> *	This is a helper function which can be called from a driver&#39;s</span>
<span class="cm"> *	xxx_init_one() probe function if the hardware uses traditional</span>
<span class="cm"> *	IDE taskfile registers and is PIO only.</span>
<span class="cm"> *</span>
<span class="cm"> *	ASSUMPTION:</span>
<span class="cm"> *	Nobody makes a single channel controller that appears solely as</span>
<span class="cm"> *	the secondary legacy port on PCI.</span>
<span class="cm"> *</span>
<span class="cm"> *	LOCKING:</span>
<span class="cm"> *	Inherited from PCI layer (may sleep).</span>
<span class="cm"> *</span>
<span class="cm"> *	RETURNS:</span>
<span class="cm"> *	Zero on success, negative on errno-based value on error.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">ata_pci_sff_init_one</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">,</span>
		 <span class="k">const</span> <span class="k">struct</span> <span class="n">ata_port_info</span> <span class="o">*</span> <span class="k">const</span> <span class="o">*</span><span class="n">ppi</span><span class="p">,</span>
		 <span class="k">struct</span> <span class="n">scsi_host_template</span> <span class="o">*</span><span class="n">sht</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">host_priv</span><span class="p">,</span> <span class="kt">int</span> <span class="n">hflag</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">ata_pci_init_one</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">ppi</span><span class="p">,</span> <span class="n">sht</span><span class="p">,</span> <span class="n">host_priv</span><span class="p">,</span> <span class="n">hflag</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">ata_pci_sff_init_one</span><span class="p">);</span>

<span class="cp">#endif </span><span class="cm">/* CONFIG_PCI */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> *	BMDMA support</span>
<span class="cm"> */</span>

<span class="cp">#ifdef CONFIG_ATA_BMDMA</span>

<span class="k">const</span> <span class="k">struct</span> <span class="n">ata_port_operations</span> <span class="n">ata_bmdma_port_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">inherits</span>		<span class="o">=</span> <span class="o">&amp;</span><span class="n">ata_sff_port_ops</span><span class="p">,</span>

	<span class="p">.</span><span class="n">error_handler</span>		<span class="o">=</span> <span class="n">ata_bmdma_error_handler</span><span class="p">,</span>
	<span class="p">.</span><span class="n">post_internal_cmd</span>	<span class="o">=</span> <span class="n">ata_bmdma_post_internal_cmd</span><span class="p">,</span>

	<span class="p">.</span><span class="n">qc_prep</span>		<span class="o">=</span> <span class="n">ata_bmdma_qc_prep</span><span class="p">,</span>
	<span class="p">.</span><span class="n">qc_issue</span>		<span class="o">=</span> <span class="n">ata_bmdma_qc_issue</span><span class="p">,</span>

	<span class="p">.</span><span class="n">sff_irq_clear</span>		<span class="o">=</span> <span class="n">ata_bmdma_irq_clear</span><span class="p">,</span>
	<span class="p">.</span><span class="n">bmdma_setup</span>		<span class="o">=</span> <span class="n">ata_bmdma_setup</span><span class="p">,</span>
	<span class="p">.</span><span class="n">bmdma_start</span>		<span class="o">=</span> <span class="n">ata_bmdma_start</span><span class="p">,</span>
	<span class="p">.</span><span class="n">bmdma_stop</span>		<span class="o">=</span> <span class="n">ata_bmdma_stop</span><span class="p">,</span>
	<span class="p">.</span><span class="n">bmdma_status</span>		<span class="o">=</span> <span class="n">ata_bmdma_status</span><span class="p">,</span>

	<span class="p">.</span><span class="n">port_start</span>		<span class="o">=</span> <span class="n">ata_bmdma_port_start</span><span class="p">,</span>
<span class="p">};</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">ata_bmdma_port_ops</span><span class="p">);</span>

<span class="k">const</span> <span class="k">struct</span> <span class="n">ata_port_operations</span> <span class="n">ata_bmdma32_port_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">inherits</span>		<span class="o">=</span> <span class="o">&amp;</span><span class="n">ata_bmdma_port_ops</span><span class="p">,</span>

	<span class="p">.</span><span class="n">sff_data_xfer</span>		<span class="o">=</span> <span class="n">ata_sff_data_xfer32</span><span class="p">,</span>
	<span class="p">.</span><span class="n">port_start</span>		<span class="o">=</span> <span class="n">ata_bmdma_port_start32</span><span class="p">,</span>
<span class="p">};</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">ata_bmdma32_port_ops</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> *	ata_bmdma_fill_sg - Fill PCI IDE PRD table</span>
<span class="cm"> *	@qc: Metadata associated with taskfile to be transferred</span>
<span class="cm"> *</span>
<span class="cm"> *	Fill PCI IDE PRD (scatter-gather) table with segments</span>
<span class="cm"> *	associated with the current disk command.</span>
<span class="cm"> *</span>
<span class="cm"> *	LOCKING:</span>
<span class="cm"> *	spin_lock_irqsave(host lock)</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">ata_bmdma_fill_sg</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_queued_cmd</span> <span class="o">*</span><span class="n">qc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span> <span class="o">=</span> <span class="n">qc</span><span class="o">-&gt;</span><span class="n">ap</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ata_bmdma_prd</span> <span class="o">*</span><span class="n">prd</span> <span class="o">=</span> <span class="n">ap</span><span class="o">-&gt;</span><span class="n">bmdma_prd</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">scatterlist</span> <span class="o">*</span><span class="n">sg</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">si</span><span class="p">,</span> <span class="n">pi</span><span class="p">;</span>

	<span class="n">pi</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">for_each_sg</span><span class="p">(</span><span class="n">qc</span><span class="o">-&gt;</span><span class="n">sg</span><span class="p">,</span> <span class="n">sg</span><span class="p">,</span> <span class="n">qc</span><span class="o">-&gt;</span><span class="n">n_elem</span><span class="p">,</span> <span class="n">si</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">u32</span> <span class="n">addr</span><span class="p">,</span> <span class="n">offset</span><span class="p">;</span>
		<span class="n">u32</span> <span class="n">sg_len</span><span class="p">,</span> <span class="n">len</span><span class="p">;</span>

		<span class="cm">/* determine if physical DMA addr spans 64K boundary.</span>
<span class="cm">		 * Note h/w doesn&#39;t support 64-bit, so we unconditionally</span>
<span class="cm">		 * truncate dma_addr_t to u32.</span>
<span class="cm">		 */</span>
		<span class="n">addr</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span> <span class="n">sg_dma_address</span><span class="p">(</span><span class="n">sg</span><span class="p">);</span>
		<span class="n">sg_len</span> <span class="o">=</span> <span class="n">sg_dma_len</span><span class="p">(</span><span class="n">sg</span><span class="p">);</span>

		<span class="k">while</span> <span class="p">(</span><span class="n">sg_len</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">offset</span> <span class="o">=</span> <span class="n">addr</span> <span class="o">&amp;</span> <span class="mh">0xffff</span><span class="p">;</span>
			<span class="n">len</span> <span class="o">=</span> <span class="n">sg_len</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">offset</span> <span class="o">+</span> <span class="n">sg_len</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mh">0x10000</span><span class="p">)</span>
				<span class="n">len</span> <span class="o">=</span> <span class="mh">0x10000</span> <span class="o">-</span> <span class="n">offset</span><span class="p">;</span>

			<span class="n">prd</span><span class="p">[</span><span class="n">pi</span><span class="p">].</span><span class="n">addr</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">addr</span><span class="p">);</span>
			<span class="n">prd</span><span class="p">[</span><span class="n">pi</span><span class="p">].</span><span class="n">flags_len</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">len</span> <span class="o">&amp;</span> <span class="mh">0xffff</span><span class="p">);</span>
			<span class="n">VPRINTK</span><span class="p">(</span><span class="s">&quot;PRD[%u] = (0x%X, 0x%X)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">pi</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>

			<span class="n">pi</span><span class="o">++</span><span class="p">;</span>
			<span class="n">sg_len</span> <span class="o">-=</span> <span class="n">len</span><span class="p">;</span>
			<span class="n">addr</span> <span class="o">+=</span> <span class="n">len</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">prd</span><span class="p">[</span><span class="n">pi</span> <span class="o">-</span> <span class="mi">1</span><span class="p">].</span><span class="n">flags_len</span> <span class="o">|=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">ATA_PRD_EOT</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	ata_bmdma_fill_sg_dumb - Fill PCI IDE PRD table</span>
<span class="cm"> *	@qc: Metadata associated with taskfile to be transferred</span>
<span class="cm"> *</span>
<span class="cm"> *	Fill PCI IDE PRD (scatter-gather) table with segments</span>
<span class="cm"> *	associated with the current disk command. Perform the fill</span>
<span class="cm"> *	so that we avoid writing any length 64K records for</span>
<span class="cm"> *	controllers that don&#39;t follow the spec.</span>
<span class="cm"> *</span>
<span class="cm"> *	LOCKING:</span>
<span class="cm"> *	spin_lock_irqsave(host lock)</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">ata_bmdma_fill_sg_dumb</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_queued_cmd</span> <span class="o">*</span><span class="n">qc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span> <span class="o">=</span> <span class="n">qc</span><span class="o">-&gt;</span><span class="n">ap</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ata_bmdma_prd</span> <span class="o">*</span><span class="n">prd</span> <span class="o">=</span> <span class="n">ap</span><span class="o">-&gt;</span><span class="n">bmdma_prd</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">scatterlist</span> <span class="o">*</span><span class="n">sg</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">si</span><span class="p">,</span> <span class="n">pi</span><span class="p">;</span>

	<span class="n">pi</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">for_each_sg</span><span class="p">(</span><span class="n">qc</span><span class="o">-&gt;</span><span class="n">sg</span><span class="p">,</span> <span class="n">sg</span><span class="p">,</span> <span class="n">qc</span><span class="o">-&gt;</span><span class="n">n_elem</span><span class="p">,</span> <span class="n">si</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">u32</span> <span class="n">addr</span><span class="p">,</span> <span class="n">offset</span><span class="p">;</span>
		<span class="n">u32</span> <span class="n">sg_len</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">blen</span><span class="p">;</span>

		<span class="cm">/* determine if physical DMA addr spans 64K boundary.</span>
<span class="cm">		 * Note h/w doesn&#39;t support 64-bit, so we unconditionally</span>
<span class="cm">		 * truncate dma_addr_t to u32.</span>
<span class="cm">		 */</span>
		<span class="n">addr</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span> <span class="n">sg_dma_address</span><span class="p">(</span><span class="n">sg</span><span class="p">);</span>
		<span class="n">sg_len</span> <span class="o">=</span> <span class="n">sg_dma_len</span><span class="p">(</span><span class="n">sg</span><span class="p">);</span>

		<span class="k">while</span> <span class="p">(</span><span class="n">sg_len</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">offset</span> <span class="o">=</span> <span class="n">addr</span> <span class="o">&amp;</span> <span class="mh">0xffff</span><span class="p">;</span>
			<span class="n">len</span> <span class="o">=</span> <span class="n">sg_len</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">offset</span> <span class="o">+</span> <span class="n">sg_len</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mh">0x10000</span><span class="p">)</span>
				<span class="n">len</span> <span class="o">=</span> <span class="mh">0x10000</span> <span class="o">-</span> <span class="n">offset</span><span class="p">;</span>

			<span class="n">blen</span> <span class="o">=</span> <span class="n">len</span> <span class="o">&amp;</span> <span class="mh">0xffff</span><span class="p">;</span>
			<span class="n">prd</span><span class="p">[</span><span class="n">pi</span><span class="p">].</span><span class="n">addr</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">addr</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">blen</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/* Some PATA chipsets like the CS5530 can&#39;t</span>
<span class="cm">				   cope with 0x0000 meaning 64K as the spec</span>
<span class="cm">				   says */</span>
				<span class="n">prd</span><span class="p">[</span><span class="n">pi</span><span class="p">].</span><span class="n">flags_len</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="mh">0x8000</span><span class="p">);</span>
				<span class="n">blen</span> <span class="o">=</span> <span class="mh">0x8000</span><span class="p">;</span>
				<span class="n">prd</span><span class="p">[</span><span class="o">++</span><span class="n">pi</span><span class="p">].</span><span class="n">addr</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">addr</span> <span class="o">+</span> <span class="mh">0x8000</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="n">prd</span><span class="p">[</span><span class="n">pi</span><span class="p">].</span><span class="n">flags_len</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">blen</span><span class="p">);</span>
			<span class="n">VPRINTK</span><span class="p">(</span><span class="s">&quot;PRD[%u] = (0x%X, 0x%X)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">pi</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>

			<span class="n">pi</span><span class="o">++</span><span class="p">;</span>
			<span class="n">sg_len</span> <span class="o">-=</span> <span class="n">len</span><span class="p">;</span>
			<span class="n">addr</span> <span class="o">+=</span> <span class="n">len</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">prd</span><span class="p">[</span><span class="n">pi</span> <span class="o">-</span> <span class="mi">1</span><span class="p">].</span><span class="n">flags_len</span> <span class="o">|=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">ATA_PRD_EOT</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	ata_bmdma_qc_prep - Prepare taskfile for submission</span>
<span class="cm"> *	@qc: Metadata associated with taskfile to be prepared</span>
<span class="cm"> *</span>
<span class="cm"> *	Prepare ATA taskfile for submission.</span>
<span class="cm"> *</span>
<span class="cm"> *	LOCKING:</span>
<span class="cm"> *	spin_lock_irqsave(host lock)</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">ata_bmdma_qc_prep</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_queued_cmd</span> <span class="o">*</span><span class="n">qc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">qc</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">ATA_QCFLAG_DMAMAP</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">ata_bmdma_fill_sg</span><span class="p">(</span><span class="n">qc</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">ata_bmdma_qc_prep</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> *	ata_bmdma_dumb_qc_prep - Prepare taskfile for submission</span>
<span class="cm"> *	@qc: Metadata associated with taskfile to be prepared</span>
<span class="cm"> *</span>
<span class="cm"> *	Prepare ATA taskfile for submission.</span>
<span class="cm"> *</span>
<span class="cm"> *	LOCKING:</span>
<span class="cm"> *	spin_lock_irqsave(host lock)</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">ata_bmdma_dumb_qc_prep</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_queued_cmd</span> <span class="o">*</span><span class="n">qc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">qc</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">ATA_QCFLAG_DMAMAP</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">ata_bmdma_fill_sg_dumb</span><span class="p">(</span><span class="n">qc</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">ata_bmdma_dumb_qc_prep</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> *	ata_bmdma_qc_issue - issue taskfile to a BMDMA controller</span>
<span class="cm"> *	@qc: command to issue to device</span>
<span class="cm"> *</span>
<span class="cm"> *	This function issues a PIO, NODATA or DMA command to a</span>
<span class="cm"> *	SFF/BMDMA controller.  PIO and NODATA are handled by</span>
<span class="cm"> *	ata_sff_qc_issue().</span>
<span class="cm"> *</span>
<span class="cm"> *	LOCKING:</span>
<span class="cm"> *	spin_lock_irqsave(host lock)</span>
<span class="cm"> *</span>
<span class="cm"> *	RETURNS:</span>
<span class="cm"> *	Zero on success, AC_ERR_* mask on failure</span>
<span class="cm"> */</span>
<span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">ata_bmdma_qc_issue</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_queued_cmd</span> <span class="o">*</span><span class="n">qc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span> <span class="o">=</span> <span class="n">qc</span><span class="o">-&gt;</span><span class="n">ap</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ata_link</span> <span class="o">*</span><span class="n">link</span> <span class="o">=</span> <span class="n">qc</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">link</span><span class="p">;</span>

	<span class="cm">/* defer PIO handling to sff_qc_issue */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ata_is_dma</span><span class="p">(</span><span class="n">qc</span><span class="o">-&gt;</span><span class="n">tf</span><span class="p">.</span><span class="n">protocol</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">ata_sff_qc_issue</span><span class="p">(</span><span class="n">qc</span><span class="p">);</span>

	<span class="cm">/* select the device */</span>
	<span class="n">ata_dev_select</span><span class="p">(</span><span class="n">ap</span><span class="p">,</span> <span class="n">qc</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">devno</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="cm">/* start the command */</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">qc</span><span class="o">-&gt;</span><span class="n">tf</span><span class="p">.</span><span class="n">protocol</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">ATA_PROT_DMA</span>:
		<span class="n">WARN_ON_ONCE</span><span class="p">(</span><span class="n">qc</span><span class="o">-&gt;</span><span class="n">tf</span><span class="p">.</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">ATA_TFLAG_POLLING</span><span class="p">);</span>

		<span class="n">ap</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">sff_tf_load</span><span class="p">(</span><span class="n">ap</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">qc</span><span class="o">-&gt;</span><span class="n">tf</span><span class="p">);</span>  <span class="cm">/* load tf registers */</span>
		<span class="n">ap</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">bmdma_setup</span><span class="p">(</span><span class="n">qc</span><span class="p">);</span>	    <span class="cm">/* set up bmdma */</span>
		<span class="n">ap</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">bmdma_start</span><span class="p">(</span><span class="n">qc</span><span class="p">);</span>	    <span class="cm">/* initiate bmdma */</span>
		<span class="n">ap</span><span class="o">-&gt;</span><span class="n">hsm_task_state</span> <span class="o">=</span> <span class="n">HSM_ST_LAST</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">ATAPI_PROT_DMA</span>:
		<span class="n">WARN_ON_ONCE</span><span class="p">(</span><span class="n">qc</span><span class="o">-&gt;</span><span class="n">tf</span><span class="p">.</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">ATA_TFLAG_POLLING</span><span class="p">);</span>

		<span class="n">ap</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">sff_tf_load</span><span class="p">(</span><span class="n">ap</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">qc</span><span class="o">-&gt;</span><span class="n">tf</span><span class="p">);</span>  <span class="cm">/* load tf registers */</span>
		<span class="n">ap</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">bmdma_setup</span><span class="p">(</span><span class="n">qc</span><span class="p">);</span>	    <span class="cm">/* set up bmdma */</span>
		<span class="n">ap</span><span class="o">-&gt;</span><span class="n">hsm_task_state</span> <span class="o">=</span> <span class="n">HSM_ST_FIRST</span><span class="p">;</span>

		<span class="cm">/* send cdb by polling if no cdb interrupt */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">qc</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">ATA_DFLAG_CDB_INTR</span><span class="p">))</span>
			<span class="n">ata_sff_queue_pio_task</span><span class="p">(</span><span class="n">link</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="nl">default:</span>
		<span class="n">WARN_ON</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">AC_ERR_SYSTEM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">ata_bmdma_qc_issue</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> *	ata_bmdma_port_intr - Handle BMDMA port interrupt</span>
<span class="cm"> *	@ap: Port on which interrupt arrived (possibly...)</span>
<span class="cm"> *	@qc: Taskfile currently active in engine</span>
<span class="cm"> *</span>
<span class="cm"> *	Handle port interrupt for given queued command.</span>
<span class="cm"> *</span>
<span class="cm"> *	LOCKING:</span>
<span class="cm"> *	spin_lock_irqsave(host lock)</span>
<span class="cm"> *</span>
<span class="cm"> *	RETURNS:</span>
<span class="cm"> *	One if interrupt was handled, zero if not (shared irq).</span>
<span class="cm"> */</span>
<span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">ata_bmdma_port_intr</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ata_queued_cmd</span> <span class="o">*</span><span class="n">qc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ata_eh_info</span> <span class="o">*</span><span class="n">ehi</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">link</span><span class="p">.</span><span class="n">eh_info</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">host_stat</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">bmdma_stopped</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">handled</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">hsm_task_state</span> <span class="o">==</span> <span class="n">HSM_ST_LAST</span> <span class="o">&amp;&amp;</span> <span class="n">ata_is_dma</span><span class="p">(</span><span class="n">qc</span><span class="o">-&gt;</span><span class="n">tf</span><span class="p">.</span><span class="n">protocol</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* check status of DMA engine */</span>
		<span class="n">host_stat</span> <span class="o">=</span> <span class="n">ap</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">bmdma_status</span><span class="p">(</span><span class="n">ap</span><span class="p">);</span>
		<span class="n">VPRINTK</span><span class="p">(</span><span class="s">&quot;ata%u: host_stat 0x%X</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ap</span><span class="o">-&gt;</span><span class="n">print_id</span><span class="p">,</span> <span class="n">host_stat</span><span class="p">);</span>

		<span class="cm">/* if it&#39;s not our irq... */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">host_stat</span> <span class="o">&amp;</span> <span class="n">ATA_DMA_INTR</span><span class="p">))</span>
			<span class="k">return</span> <span class="n">ata_sff_idle_irq</span><span class="p">(</span><span class="n">ap</span><span class="p">);</span>

		<span class="cm">/* before we do anything else, clear DMA-Start bit */</span>
		<span class="n">ap</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">bmdma_stop</span><span class="p">(</span><span class="n">qc</span><span class="p">);</span>
		<span class="n">bmdma_stopped</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">host_stat</span> <span class="o">&amp;</span> <span class="n">ATA_DMA_ERR</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/* error when transferring data to/from memory */</span>
			<span class="n">qc</span><span class="o">-&gt;</span><span class="n">err_mask</span> <span class="o">|=</span> <span class="n">AC_ERR_HOST_BUS</span><span class="p">;</span>
			<span class="n">ap</span><span class="o">-&gt;</span><span class="n">hsm_task_state</span> <span class="o">=</span> <span class="n">HSM_ST_ERR</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">handled</span> <span class="o">=</span> <span class="n">__ata_sff_port_intr</span><span class="p">(</span><span class="n">ap</span><span class="p">,</span> <span class="n">qc</span><span class="p">,</span> <span class="n">bmdma_stopped</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">qc</span><span class="o">-&gt;</span><span class="n">err_mask</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">ata_is_dma</span><span class="p">(</span><span class="n">qc</span><span class="o">-&gt;</span><span class="n">tf</span><span class="p">.</span><span class="n">protocol</span><span class="p">))</span>
		<span class="n">ata_ehi_push_desc</span><span class="p">(</span><span class="n">ehi</span><span class="p">,</span> <span class="s">&quot;BMDMA stat 0x%x&quot;</span><span class="p">,</span> <span class="n">host_stat</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">handled</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">ata_bmdma_port_intr</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> *	ata_bmdma_interrupt - Default BMDMA ATA host interrupt handler</span>
<span class="cm"> *	@irq: irq line (unused)</span>
<span class="cm"> *	@dev_instance: pointer to our ata_host information structure</span>
<span class="cm"> *</span>
<span class="cm"> *	Default interrupt handler for PCI IDE devices.  Calls</span>
<span class="cm"> *	ata_bmdma_port_intr() for each port that is not disabled.</span>
<span class="cm"> *</span>
<span class="cm"> *	LOCKING:</span>
<span class="cm"> *	Obtains host lock during operation.</span>
<span class="cm"> *</span>
<span class="cm"> *	RETURNS:</span>
<span class="cm"> *	IRQ_NONE or IRQ_HANDLED.</span>
<span class="cm"> */</span>
<span class="n">irqreturn_t</span> <span class="nf">ata_bmdma_interrupt</span><span class="p">(</span><span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">dev_instance</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">__ata_sff_interrupt</span><span class="p">(</span><span class="n">irq</span><span class="p">,</span> <span class="n">dev_instance</span><span class="p">,</span> <span class="n">ata_bmdma_port_intr</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">ata_bmdma_interrupt</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> *	ata_bmdma_error_handler - Stock error handler for BMDMA controller</span>
<span class="cm"> *	@ap: port to handle error for</span>
<span class="cm"> *</span>
<span class="cm"> *	Stock error handler for BMDMA controller.  It can handle both</span>
<span class="cm"> *	PATA and SATA controllers.  Most BMDMA controllers should be</span>
<span class="cm"> *	able to use this EH as-is or with some added handling before</span>
<span class="cm"> *	and after.</span>
<span class="cm"> *</span>
<span class="cm"> *	LOCKING:</span>
<span class="cm"> *	Kernel thread context (may sleep)</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">ata_bmdma_error_handler</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ata_queued_cmd</span> <span class="o">*</span><span class="n">qc</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">thaw</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

	<span class="n">qc</span> <span class="o">=</span> <span class="n">__ata_qc_from_tag</span><span class="p">(</span><span class="n">ap</span><span class="p">,</span> <span class="n">ap</span><span class="o">-&gt;</span><span class="n">link</span><span class="p">.</span><span class="n">active_tag</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">qc</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">qc</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">ATA_QCFLAG_FAILED</span><span class="p">))</span>
		<span class="n">qc</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="cm">/* reset PIO HSM and stop DMA engine */</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">qc</span> <span class="o">&amp;&amp;</span> <span class="n">ata_is_dma</span><span class="p">(</span><span class="n">qc</span><span class="o">-&gt;</span><span class="n">tf</span><span class="p">.</span><span class="n">protocol</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">u8</span> <span class="n">host_stat</span><span class="p">;</span>

		<span class="n">host_stat</span> <span class="o">=</span> <span class="n">ap</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">bmdma_status</span><span class="p">(</span><span class="n">ap</span><span class="p">);</span>

		<span class="cm">/* BMDMA controllers indicate host bus error by</span>
<span class="cm">		 * setting DMA_ERR bit and timing out.  As it wasn&#39;t</span>
<span class="cm">		 * really a timeout event, adjust error mask and</span>
<span class="cm">		 * cancel frozen state.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">qc</span><span class="o">-&gt;</span><span class="n">err_mask</span> <span class="o">==</span> <span class="n">AC_ERR_TIMEOUT</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">host_stat</span> <span class="o">&amp;</span> <span class="n">ATA_DMA_ERR</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">qc</span><span class="o">-&gt;</span><span class="n">err_mask</span> <span class="o">=</span> <span class="n">AC_ERR_HOST_BUS</span><span class="p">;</span>
			<span class="n">thaw</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">ap</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">bmdma_stop</span><span class="p">(</span><span class="n">qc</span><span class="p">);</span>

		<span class="cm">/* if we&#39;re gonna thaw, make sure IRQ is clear */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">thaw</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ap</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">sff_check_status</span><span class="p">(</span><span class="n">ap</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">sff_irq_clear</span><span class="p">)</span>
				<span class="n">ap</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">sff_irq_clear</span><span class="p">(</span><span class="n">ap</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">thaw</span><span class="p">)</span>
		<span class="n">ata_eh_thaw_port</span><span class="p">(</span><span class="n">ap</span><span class="p">);</span>

	<span class="n">ata_sff_error_handler</span><span class="p">(</span><span class="n">ap</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">ata_bmdma_error_handler</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> *	ata_bmdma_post_internal_cmd - Stock post_internal_cmd for BMDMA</span>
<span class="cm"> *	@qc: internal command to clean up</span>
<span class="cm"> *</span>
<span class="cm"> *	LOCKING:</span>
<span class="cm"> *	Kernel thread context (may sleep)</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">ata_bmdma_post_internal_cmd</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_queued_cmd</span> <span class="o">*</span><span class="n">qc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span> <span class="o">=</span> <span class="n">qc</span><span class="o">-&gt;</span><span class="n">ap</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ata_is_dma</span><span class="p">(</span><span class="n">qc</span><span class="o">-&gt;</span><span class="n">tf</span><span class="p">.</span><span class="n">protocol</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="n">ap</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">bmdma_stop</span><span class="p">(</span><span class="n">qc</span><span class="p">);</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">ata_bmdma_post_internal_cmd</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> *	ata_bmdma_irq_clear - Clear PCI IDE BMDMA interrupt.</span>
<span class="cm"> *	@ap: Port associated with this ATA transaction.</span>
<span class="cm"> *</span>
<span class="cm"> *	Clear interrupt and error flags in DMA status register.</span>
<span class="cm"> *</span>
<span class="cm"> *	May be used as the irq_clear() entry in ata_port_operations.</span>
<span class="cm"> *</span>
<span class="cm"> *	LOCKING:</span>
<span class="cm"> *	spin_lock_irqsave(host lock)</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">ata_bmdma_irq_clear</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">mmio</span> <span class="o">=</span> <span class="n">ap</span><span class="o">-&gt;</span><span class="n">ioaddr</span><span class="p">.</span><span class="n">bmdma_addr</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mmio</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">iowrite8</span><span class="p">(</span><span class="n">ioread8</span><span class="p">(</span><span class="n">mmio</span> <span class="o">+</span> <span class="n">ATA_DMA_STATUS</span><span class="p">),</span> <span class="n">mmio</span> <span class="o">+</span> <span class="n">ATA_DMA_STATUS</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">ata_bmdma_irq_clear</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> *	ata_bmdma_setup - Set up PCI IDE BMDMA transaction</span>
<span class="cm"> *	@qc: Info associated with this ATA transaction.</span>
<span class="cm"> *</span>
<span class="cm"> *	LOCKING:</span>
<span class="cm"> *	spin_lock_irqsave(host lock)</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">ata_bmdma_setup</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_queued_cmd</span> <span class="o">*</span><span class="n">qc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span> <span class="o">=</span> <span class="n">qc</span><span class="o">-&gt;</span><span class="n">ap</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">rw</span> <span class="o">=</span> <span class="p">(</span><span class="n">qc</span><span class="o">-&gt;</span><span class="n">tf</span><span class="p">.</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">ATA_TFLAG_WRITE</span><span class="p">);</span>
	<span class="n">u8</span> <span class="n">dmactl</span><span class="p">;</span>

	<span class="cm">/* load PRD table addr. */</span>
	<span class="n">mb</span><span class="p">();</span>	<span class="cm">/* make sure PRD table writes are visible to controller */</span>
	<span class="n">iowrite32</span><span class="p">(</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">bmdma_prd_dma</span><span class="p">,</span> <span class="n">ap</span><span class="o">-&gt;</span><span class="n">ioaddr</span><span class="p">.</span><span class="n">bmdma_addr</span> <span class="o">+</span> <span class="n">ATA_DMA_TABLE_OFS</span><span class="p">);</span>

	<span class="cm">/* specify data direction, triple-check start bit is clear */</span>
	<span class="n">dmactl</span> <span class="o">=</span> <span class="n">ioread8</span><span class="p">(</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">ioaddr</span><span class="p">.</span><span class="n">bmdma_addr</span> <span class="o">+</span> <span class="n">ATA_DMA_CMD</span><span class="p">);</span>
	<span class="n">dmactl</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">ATA_DMA_WR</span> <span class="o">|</span> <span class="n">ATA_DMA_START</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rw</span><span class="p">)</span>
		<span class="n">dmactl</span> <span class="o">|=</span> <span class="n">ATA_DMA_WR</span><span class="p">;</span>
	<span class="n">iowrite8</span><span class="p">(</span><span class="n">dmactl</span><span class="p">,</span> <span class="n">ap</span><span class="o">-&gt;</span><span class="n">ioaddr</span><span class="p">.</span><span class="n">bmdma_addr</span> <span class="o">+</span> <span class="n">ATA_DMA_CMD</span><span class="p">);</span>

	<span class="cm">/* issue r/w command */</span>
	<span class="n">ap</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">sff_exec_command</span><span class="p">(</span><span class="n">ap</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">qc</span><span class="o">-&gt;</span><span class="n">tf</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">ata_bmdma_setup</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> *	ata_bmdma_start - Start a PCI IDE BMDMA transaction</span>
<span class="cm"> *	@qc: Info associated with this ATA transaction.</span>
<span class="cm"> *</span>
<span class="cm"> *	LOCKING:</span>
<span class="cm"> *	spin_lock_irqsave(host lock)</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">ata_bmdma_start</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_queued_cmd</span> <span class="o">*</span><span class="n">qc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span> <span class="o">=</span> <span class="n">qc</span><span class="o">-&gt;</span><span class="n">ap</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">dmactl</span><span class="p">;</span>

	<span class="cm">/* start host DMA transaction */</span>
	<span class="n">dmactl</span> <span class="o">=</span> <span class="n">ioread8</span><span class="p">(</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">ioaddr</span><span class="p">.</span><span class="n">bmdma_addr</span> <span class="o">+</span> <span class="n">ATA_DMA_CMD</span><span class="p">);</span>
	<span class="n">iowrite8</span><span class="p">(</span><span class="n">dmactl</span> <span class="o">|</span> <span class="n">ATA_DMA_START</span><span class="p">,</span> <span class="n">ap</span><span class="o">-&gt;</span><span class="n">ioaddr</span><span class="p">.</span><span class="n">bmdma_addr</span> <span class="o">+</span> <span class="n">ATA_DMA_CMD</span><span class="p">);</span>

	<span class="cm">/* Strictly, one may wish to issue an ioread8() here, to</span>
<span class="cm">	 * flush the mmio write.  However, control also passes</span>
<span class="cm">	 * to the hardware at this point, and it will interrupt</span>
<span class="cm">	 * us when we are to resume control.  So, in effect,</span>
<span class="cm">	 * we don&#39;t care when the mmio write flushes.</span>
<span class="cm">	 * Further, a read of the DMA status register _immediately_</span>
<span class="cm">	 * following the write may not be what certain flaky hardware</span>
<span class="cm">	 * is expected, so I think it is best to not add a readb()</span>
<span class="cm">	 * without first all the MMIO ATA cards/mobos.</span>
<span class="cm">	 * Or maybe I&#39;m just being paranoid.</span>
<span class="cm">	 *</span>
<span class="cm">	 * FIXME: The posting of this write means I/O starts are</span>
<span class="cm">	 * unnecessarily delayed for MMIO</span>
<span class="cm">	 */</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">ata_bmdma_start</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> *	ata_bmdma_stop - Stop PCI IDE BMDMA transfer</span>
<span class="cm"> *	@qc: Command we are ending DMA for</span>
<span class="cm"> *</span>
<span class="cm"> *	Clears the ATA_DMA_START flag in the dma control register</span>
<span class="cm"> *</span>
<span class="cm"> *	May be used as the bmdma_stop() entry in ata_port_operations.</span>
<span class="cm"> *</span>
<span class="cm"> *	LOCKING:</span>
<span class="cm"> *	spin_lock_irqsave(host lock)</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">ata_bmdma_stop</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_queued_cmd</span> <span class="o">*</span><span class="n">qc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span> <span class="o">=</span> <span class="n">qc</span><span class="o">-&gt;</span><span class="n">ap</span><span class="p">;</span>
	<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">mmio</span> <span class="o">=</span> <span class="n">ap</span><span class="o">-&gt;</span><span class="n">ioaddr</span><span class="p">.</span><span class="n">bmdma_addr</span><span class="p">;</span>

	<span class="cm">/* clear start/stop bit */</span>
	<span class="n">iowrite8</span><span class="p">(</span><span class="n">ioread8</span><span class="p">(</span><span class="n">mmio</span> <span class="o">+</span> <span class="n">ATA_DMA_CMD</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">ATA_DMA_START</span><span class="p">,</span>
		 <span class="n">mmio</span> <span class="o">+</span> <span class="n">ATA_DMA_CMD</span><span class="p">);</span>

	<span class="cm">/* one-PIO-cycle guaranteed wait, per spec, for HDMA1:0 transition */</span>
	<span class="n">ata_sff_dma_pause</span><span class="p">(</span><span class="n">ap</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">ata_bmdma_stop</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> *	ata_bmdma_status - Read PCI IDE BMDMA status</span>
<span class="cm"> *	@ap: Port associated with this ATA transaction.</span>
<span class="cm"> *</span>
<span class="cm"> *	Read and return BMDMA status register.</span>
<span class="cm"> *</span>
<span class="cm"> *	May be used as the bmdma_status() entry in ata_port_operations.</span>
<span class="cm"> *</span>
<span class="cm"> *	LOCKING:</span>
<span class="cm"> *	spin_lock_irqsave(host lock)</span>
<span class="cm"> */</span>
<span class="n">u8</span> <span class="nf">ata_bmdma_status</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">ioread8</span><span class="p">(</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">ioaddr</span><span class="p">.</span><span class="n">bmdma_addr</span> <span class="o">+</span> <span class="n">ATA_DMA_STATUS</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">ata_bmdma_status</span><span class="p">);</span>


<span class="cm">/**</span>
<span class="cm"> *	ata_bmdma_port_start - Set port up for bmdma.</span>
<span class="cm"> *	@ap: Port to initialize</span>
<span class="cm"> *</span>
<span class="cm"> *	Called just after data structures for each port are</span>
<span class="cm"> *	initialized.  Allocates space for PRD table.</span>
<span class="cm"> *</span>
<span class="cm"> *	May be used as the port_start() entry in ata_port_operations.</span>
<span class="cm"> *</span>
<span class="cm"> *	LOCKING:</span>
<span class="cm"> *	Inherited from caller.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">ata_bmdma_port_start</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">mwdma_mask</span> <span class="o">||</span> <span class="n">ap</span><span class="o">-&gt;</span><span class="n">udma_mask</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ap</span><span class="o">-&gt;</span><span class="n">bmdma_prd</span> <span class="o">=</span>
			<span class="n">dmam_alloc_coherent</span><span class="p">(</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">ATA_PRD_TBL_SZ</span><span class="p">,</span>
					    <span class="o">&amp;</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">bmdma_prd_dma</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">bmdma_prd</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">ata_bmdma_port_start</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> *	ata_bmdma_port_start32 - Set port up for dma.</span>
<span class="cm"> *	@ap: Port to initialize</span>
<span class="cm"> *</span>
<span class="cm"> *	Called just after data structures for each port are</span>
<span class="cm"> *	initialized.  Enables 32bit PIO and allocates space for PRD</span>
<span class="cm"> *	table.</span>
<span class="cm"> *</span>
<span class="cm"> *	May be used as the port_start() entry in ata_port_operations for</span>
<span class="cm"> *	devices that are capable of 32bit PIO.</span>
<span class="cm"> *</span>
<span class="cm"> *	LOCKING:</span>
<span class="cm"> *	Inherited from caller.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">ata_bmdma_port_start32</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ap</span><span class="o">-&gt;</span><span class="n">pflags</span> <span class="o">|=</span> <span class="n">ATA_PFLAG_PIO32</span> <span class="o">|</span> <span class="n">ATA_PFLAG_PIO32CHANGE</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">ata_bmdma_port_start</span><span class="p">(</span><span class="n">ap</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">ata_bmdma_port_start32</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_PCI</span>

<span class="cm">/**</span>
<span class="cm"> *	ata_pci_bmdma_clear_simplex -	attempt to kick device out of simplex</span>
<span class="cm"> *	@pdev: PCI device</span>
<span class="cm"> *</span>
<span class="cm"> *	Some PCI ATA devices report simplex mode but in fact can be told to</span>
<span class="cm"> *	enter non simplex mode. This implements the necessary logic to</span>
<span class="cm"> *	perform the task on such devices. Calling it on other devices will</span>
<span class="cm"> *	have -undefined- behaviour.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">ata_pci_bmdma_clear_simplex</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">bmdma</span> <span class="o">=</span> <span class="n">pci_resource_start</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>
	<span class="n">u8</span> <span class="n">simplex</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">bmdma</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>

	<span class="n">simplex</span> <span class="o">=</span> <span class="n">inb</span><span class="p">(</span><span class="n">bmdma</span> <span class="o">+</span> <span class="mh">0x02</span><span class="p">);</span>
	<span class="n">outb</span><span class="p">(</span><span class="n">simplex</span> <span class="o">&amp;</span> <span class="mh">0x60</span><span class="p">,</span> <span class="n">bmdma</span> <span class="o">+</span> <span class="mh">0x02</span><span class="p">);</span>
	<span class="n">simplex</span> <span class="o">=</span> <span class="n">inb</span><span class="p">(</span><span class="n">bmdma</span> <span class="o">+</span> <span class="mh">0x02</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">simplex</span> <span class="o">&amp;</span> <span class="mh">0x80</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EOPNOTSUPP</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">ata_pci_bmdma_clear_simplex</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">ata_bmdma_nodma</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_host</span> <span class="o">*</span><span class="n">host</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">reason</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">dev_err</span><span class="p">(</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;BMDMA: %s, falling back to PIO</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">reason</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">host</span><span class="o">-&gt;</span><span class="n">ports</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">mwdma_mask</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">host</span><span class="o">-&gt;</span><span class="n">ports</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">udma_mask</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	ata_pci_bmdma_init - acquire PCI BMDMA resources and init ATA host</span>
<span class="cm"> *	@host: target ATA host</span>
<span class="cm"> *</span>
<span class="cm"> *	Acquire PCI BMDMA resources and initialize @host accordingly.</span>
<span class="cm"> *</span>
<span class="cm"> *	LOCKING:</span>
<span class="cm"> *	Inherited from calling layer (may sleep).</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">ata_pci_bmdma_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_host</span> <span class="o">*</span><span class="n">host</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">gdev</span> <span class="o">=</span> <span class="n">host</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span> <span class="o">=</span> <span class="n">to_pci_dev</span><span class="p">(</span><span class="n">gdev</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">rc</span><span class="p">;</span>

	<span class="cm">/* No BAR4 allocation: No DMA */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pci_resource_start</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ata_bmdma_nodma</span><span class="p">(</span><span class="n">host</span><span class="p">,</span> <span class="s">&quot;BAR4 is zero&quot;</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Some controllers require BMDMA region to be initialized</span>
<span class="cm">	 * even if DMA is not in use to clear IRQ status via</span>
<span class="cm">	 * -&gt;sff_irq_clear method.  Try to initialize bmdma_addr</span>
<span class="cm">	 * regardless of dma masks.</span>
<span class="cm">	 */</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">pci_set_dma_mask</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">ATA_DMA_MASK</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="n">ata_bmdma_nodma</span><span class="p">(</span><span class="n">host</span><span class="p">,</span> <span class="s">&quot;failed to set dma mask&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">pci_set_consistent_dma_mask</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">ATA_DMA_MASK</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
			<span class="n">ata_bmdma_nodma</span><span class="p">(</span><span class="n">host</span><span class="p">,</span>
					<span class="s">&quot;failed to set consistent dma mask&quot;</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* request and iomap DMA region */</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">pcim_iomap_regions</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">4</span><span class="p">,</span> <span class="n">dev_driver_string</span><span class="p">(</span><span class="n">gdev</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ata_bmdma_nodma</span><span class="p">(</span><span class="n">host</span><span class="p">,</span> <span class="s">&quot;failed to request/iomap BAR4&quot;</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">host</span><span class="o">-&gt;</span><span class="n">iomap</span> <span class="o">=</span> <span class="n">pcim_iomap_table</span><span class="p">(</span><span class="n">pdev</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span> <span class="o">=</span> <span class="n">host</span><span class="o">-&gt;</span><span class="n">ports</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="kt">void</span> <span class="n">__iomem</span> <span class="o">*</span><span class="n">bmdma</span> <span class="o">=</span> <span class="n">host</span><span class="o">-&gt;</span><span class="n">iomap</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">+</span> <span class="mi">8</span> <span class="o">*</span> <span class="n">i</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">ata_port_is_dummy</span><span class="p">(</span><span class="n">ap</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">ap</span><span class="o">-&gt;</span><span class="n">ioaddr</span><span class="p">.</span><span class="n">bmdma_addr</span> <span class="o">=</span> <span class="n">bmdma</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">((</span><span class="o">!</span><span class="p">(</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">ATA_FLAG_IGN_SIMPLEX</span><span class="p">))</span> <span class="o">&amp;&amp;</span>
		    <span class="p">(</span><span class="n">ioread8</span><span class="p">(</span><span class="n">bmdma</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x80</span><span class="p">))</span>
			<span class="n">host</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">ATA_HOST_SIMPLEX</span><span class="p">;</span>

		<span class="n">ata_port_desc</span><span class="p">(</span><span class="n">ap</span><span class="p">,</span> <span class="s">&quot;bmdma 0x%llx&quot;</span><span class="p">,</span>
		    <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">pci_resource_start</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span> <span class="o">+</span> <span class="mi">8</span> <span class="o">*</span> <span class="n">i</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">ata_pci_bmdma_init</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> *	ata_pci_bmdma_prepare_host - helper to prepare PCI BMDMA ATA host</span>
<span class="cm"> *	@pdev: target PCI device</span>
<span class="cm"> *	@ppi: array of port_info, must be enough for two ports</span>
<span class="cm"> *	@r_host: out argument for the initialized ATA host</span>
<span class="cm"> *</span>
<span class="cm"> *	Helper to allocate BMDMA ATA host for @pdev, acquire all PCI</span>
<span class="cm"> *	resources and initialize it accordingly in one go.</span>
<span class="cm"> *</span>
<span class="cm"> *	LOCKING:</span>
<span class="cm"> *	Inherited from calling layer (may sleep).</span>
<span class="cm"> *</span>
<span class="cm"> *	RETURNS:</span>
<span class="cm"> *	0 on success, -errno otherwise.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">ata_pci_bmdma_prepare_host</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">,</span>
			       <span class="k">const</span> <span class="k">struct</span> <span class="n">ata_port_info</span> <span class="o">*</span> <span class="k">const</span> <span class="o">*</span> <span class="n">ppi</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">ata_host</span> <span class="o">**</span><span class="n">r_host</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">ata_pci_sff_prepare_host</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">ppi</span><span class="p">,</span> <span class="n">r_host</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">ata_pci_bmdma_init</span><span class="p">(</span><span class="o">*</span><span class="n">r_host</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">ata_pci_bmdma_prepare_host</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> *	ata_pci_bmdma_init_one - Initialize/register BMDMA PCI IDE controller</span>
<span class="cm"> *	@pdev: Controller to be initialized</span>
<span class="cm"> *	@ppi: array of port_info, must be enough for two ports</span>
<span class="cm"> *	@sht: scsi_host_template to use when registering the host</span>
<span class="cm"> *	@host_priv: host private_data</span>
<span class="cm"> *	@hflags: host flags</span>
<span class="cm"> *</span>
<span class="cm"> *	This function is similar to ata_pci_sff_init_one() but also</span>
<span class="cm"> *	takes care of BMDMA initialization.</span>
<span class="cm"> *</span>
<span class="cm"> *	LOCKING:</span>
<span class="cm"> *	Inherited from PCI layer (may sleep).</span>
<span class="cm"> *</span>
<span class="cm"> *	RETURNS:</span>
<span class="cm"> *	Zero on success, negative on errno-based value on error.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">ata_pci_bmdma_init_one</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">,</span>
			   <span class="k">const</span> <span class="k">struct</span> <span class="n">ata_port_info</span> <span class="o">*</span> <span class="k">const</span> <span class="o">*</span> <span class="n">ppi</span><span class="p">,</span>
			   <span class="k">struct</span> <span class="n">scsi_host_template</span> <span class="o">*</span><span class="n">sht</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">host_priv</span><span class="p">,</span>
			   <span class="kt">int</span> <span class="n">hflags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">ata_pci_init_one</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">ppi</span><span class="p">,</span> <span class="n">sht</span><span class="p">,</span> <span class="n">host_priv</span><span class="p">,</span> <span class="n">hflags</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">ata_pci_bmdma_init_one</span><span class="p">);</span>

<span class="cp">#endif </span><span class="cm">/* CONFIG_PCI */</span><span class="cp"></span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_ATA_BMDMA */</span><span class="cp"></span>

<span class="cm">/**</span>
<span class="cm"> *	ata_sff_port_init - Initialize SFF/BMDMA ATA port</span>
<span class="cm"> *	@ap: Port to initialize</span>
<span class="cm"> *</span>
<span class="cm"> *	Called on port allocation to initialize SFF/BMDMA specific</span>
<span class="cm"> *	fields.</span>
<span class="cm"> *</span>
<span class="cm"> *	LOCKING:</span>
<span class="cm"> *	None.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">ata_sff_port_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">INIT_DELAYED_WORK</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">sff_pio_task</span><span class="p">,</span> <span class="n">ata_sff_pio_task</span><span class="p">);</span>
	<span class="n">ap</span><span class="o">-&gt;</span><span class="n">ctl</span> <span class="o">=</span> <span class="n">ATA_DEVCTL_OBS</span><span class="p">;</span>
	<span class="n">ap</span><span class="o">-&gt;</span><span class="n">last_ctl</span> <span class="o">=</span> <span class="mh">0xFF</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">__init</span> <span class="nf">ata_sff_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ata_sff_wq</span> <span class="o">=</span> <span class="n">alloc_workqueue</span><span class="p">(</span><span class="s">&quot;ata_sff&quot;</span><span class="p">,</span> <span class="n">WQ_MEM_RECLAIM</span><span class="p">,</span> <span class="n">WQ_MAX_ACTIVE</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ata_sff_wq</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">ata_sff_exit</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">destroy_workqueue</span><span class="p">(</span><span class="n">ata_sff_wq</span><span class="p">);</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
