<!DOCTYPE html>
<html><head><title>joekychen/linux » drivers › ata › pata_hpt366.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>pata_hpt366.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Libata driver for the highpoint 366 and 368 UDMA66 ATA controllers.</span>
<span class="cm"> *</span>
<span class="cm"> * This driver is heavily based upon:</span>
<span class="cm"> *</span>
<span class="cm"> * linux/drivers/ide/pci/hpt366.c		Version 0.36	April 25, 2003</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 1999-2003		Andre Hedrick &lt;andre@linux-ide.org&gt;</span>
<span class="cm"> * Portions Copyright (C) 2001	        Sun Microsystems, Inc.</span>
<span class="cm"> * Portions Copyright (C) 2003		Red Hat Inc</span>
<span class="cm"> *</span>
<span class="cm"> *</span>
<span class="cm"> * TODO</span>
<span class="cm"> *	Look into engine reset on timeout errors. Should not be required.</span>
<span class="cm"> */</span>

<span class="cp">#define pr_fmt(fmt) KBUILD_MODNAME &quot;: &quot; fmt</span>

<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/pci.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/blkdev.h&gt;</span>
<span class="cp">#include &lt;linux/delay.h&gt;</span>
<span class="cp">#include &lt;scsi/scsi_host.h&gt;</span>
<span class="cp">#include &lt;linux/libata.h&gt;</span>

<span class="cp">#define DRV_NAME	&quot;pata_hpt366&quot;</span>
<span class="cp">#define DRV_VERSION	&quot;0.6.11&quot;</span>

<span class="k">struct</span> <span class="n">hpt_clock</span> <span class="p">{</span>
	<span class="n">u8</span>	<span class="n">xfer_mode</span><span class="p">;</span>
	<span class="n">u32</span>	<span class="n">timing</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* key for bus clock timings</span>
<span class="cm"> * bit</span>
<span class="cm"> * 0:3    data_high_time. Inactive time of DIOW_/DIOR_ for PIO and MW DMA.</span>
<span class="cm"> *        cycles = value + 1</span>
<span class="cm"> * 4:7    data_low_time. Active time of DIOW_/DIOR_ for PIO and MW DMA.</span>
<span class="cm"> *        cycles = value + 1</span>
<span class="cm"> * 8:11   cmd_high_time. Inactive time of DIOW_/DIOR_ during task file</span>
<span class="cm"> *        register access.</span>
<span class="cm"> * 12:15  cmd_low_time. Active time of DIOW_/DIOR_ during task file</span>
<span class="cm"> *        register access.</span>
<span class="cm"> * 16:18  udma_cycle_time. Clock cycles for UDMA xfer?</span>
<span class="cm"> * 19:21  pre_high_time. Time to initialize 1st cycle for PIO and MW DMA xfer.</span>
<span class="cm"> * 22:24  cmd_pre_high_time. Time to initialize 1st PIO cycle for task file</span>
<span class="cm"> *        register access.</span>
<span class="cm"> * 28     UDMA enable.</span>
<span class="cm"> * 29     DMA  enable.</span>
<span class="cm"> * 30     PIO_MST enable. If set, the chip is in bus master mode during</span>
<span class="cm"> *        PIO xfer.</span>
<span class="cm"> * 31     FIFO enable.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">hpt_clock</span> <span class="n">hpt366_40</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">{</span>	<span class="n">XFER_UDMA_4</span><span class="p">,</span>	<span class="mh">0x900fd943</span>	<span class="p">},</span>
	<span class="p">{</span>	<span class="n">XFER_UDMA_3</span><span class="p">,</span>	<span class="mh">0x900ad943</span>	<span class="p">},</span>
	<span class="p">{</span>	<span class="n">XFER_UDMA_2</span><span class="p">,</span>	<span class="mh">0x900bd943</span>	<span class="p">},</span>
	<span class="p">{</span>	<span class="n">XFER_UDMA_1</span><span class="p">,</span>	<span class="mh">0x9008d943</span>	<span class="p">},</span>
	<span class="p">{</span>	<span class="n">XFER_UDMA_0</span><span class="p">,</span>	<span class="mh">0x9008d943</span>	<span class="p">},</span>

	<span class="p">{</span>	<span class="n">XFER_MW_DMA_2</span><span class="p">,</span>	<span class="mh">0xa008d943</span>	<span class="p">},</span>
	<span class="p">{</span>	<span class="n">XFER_MW_DMA_1</span><span class="p">,</span>	<span class="mh">0xa010d955</span>	<span class="p">},</span>
	<span class="p">{</span>	<span class="n">XFER_MW_DMA_0</span><span class="p">,</span>	<span class="mh">0xa010d9fc</span>	<span class="p">},</span>

	<span class="p">{</span>	<span class="n">XFER_PIO_4</span><span class="p">,</span>	<span class="mh">0xc008d963</span>	<span class="p">},</span>
	<span class="p">{</span>	<span class="n">XFER_PIO_3</span><span class="p">,</span>	<span class="mh">0xc010d974</span>	<span class="p">},</span>
	<span class="p">{</span>	<span class="n">XFER_PIO_2</span><span class="p">,</span>	<span class="mh">0xc010d997</span>	<span class="p">},</span>
	<span class="p">{</span>	<span class="n">XFER_PIO_1</span><span class="p">,</span>	<span class="mh">0xc010d9c7</span>	<span class="p">},</span>
	<span class="p">{</span>	<span class="n">XFER_PIO_0</span><span class="p">,</span>	<span class="mh">0xc018d9d9</span>	<span class="p">},</span>
	<span class="p">{</span>	<span class="mi">0</span><span class="p">,</span>		<span class="mh">0x0120d9d9</span>	<span class="p">}</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">hpt_clock</span> <span class="n">hpt366_33</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">{</span>	<span class="n">XFER_UDMA_4</span><span class="p">,</span>	<span class="mh">0x90c9a731</span>	<span class="p">},</span>
	<span class="p">{</span>	<span class="n">XFER_UDMA_3</span><span class="p">,</span>	<span class="mh">0x90cfa731</span>	<span class="p">},</span>
	<span class="p">{</span>	<span class="n">XFER_UDMA_2</span><span class="p">,</span>	<span class="mh">0x90caa731</span>	<span class="p">},</span>
	<span class="p">{</span>	<span class="n">XFER_UDMA_1</span><span class="p">,</span>	<span class="mh">0x90cba731</span>	<span class="p">},</span>
	<span class="p">{</span>	<span class="n">XFER_UDMA_0</span><span class="p">,</span>	<span class="mh">0x90c8a731</span>	<span class="p">},</span>

	<span class="p">{</span>	<span class="n">XFER_MW_DMA_2</span><span class="p">,</span>	<span class="mh">0xa0c8a731</span>	<span class="p">},</span>
	<span class="p">{</span>	<span class="n">XFER_MW_DMA_1</span><span class="p">,</span>	<span class="mh">0xa0c8a732</span>	<span class="p">},</span>	<span class="cm">/* 0xa0c8a733 */</span>
	<span class="p">{</span>	<span class="n">XFER_MW_DMA_0</span><span class="p">,</span>	<span class="mh">0xa0c8a797</span>	<span class="p">},</span>

	<span class="p">{</span>	<span class="n">XFER_PIO_4</span><span class="p">,</span>	<span class="mh">0xc0c8a731</span>	<span class="p">},</span>
	<span class="p">{</span>	<span class="n">XFER_PIO_3</span><span class="p">,</span>	<span class="mh">0xc0c8a742</span>	<span class="p">},</span>
	<span class="p">{</span>	<span class="n">XFER_PIO_2</span><span class="p">,</span>	<span class="mh">0xc0d0a753</span>	<span class="p">},</span>
	<span class="p">{</span>	<span class="n">XFER_PIO_1</span><span class="p">,</span>	<span class="mh">0xc0d0a7a3</span>	<span class="p">},</span>	<span class="cm">/* 0xc0d0a793 */</span>
	<span class="p">{</span>	<span class="n">XFER_PIO_0</span><span class="p">,</span>	<span class="mh">0xc0d0a7aa</span>	<span class="p">},</span>	<span class="cm">/* 0xc0d0a7a7 */</span>
	<span class="p">{</span>	<span class="mi">0</span><span class="p">,</span>		<span class="mh">0x0120a7a7</span>	<span class="p">}</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">hpt_clock</span> <span class="n">hpt366_25</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">{</span>	<span class="n">XFER_UDMA_4</span><span class="p">,</span>	<span class="mh">0x90c98521</span>	<span class="p">},</span>
	<span class="p">{</span>	<span class="n">XFER_UDMA_3</span><span class="p">,</span>	<span class="mh">0x90cf8521</span>	<span class="p">},</span>
	<span class="p">{</span>	<span class="n">XFER_UDMA_2</span><span class="p">,</span>	<span class="mh">0x90cf8521</span>	<span class="p">},</span>
	<span class="p">{</span>	<span class="n">XFER_UDMA_1</span><span class="p">,</span>	<span class="mh">0x90cb8521</span>	<span class="p">},</span>
	<span class="p">{</span>	<span class="n">XFER_UDMA_0</span><span class="p">,</span>	<span class="mh">0x90cb8521</span>	<span class="p">},</span>

	<span class="p">{</span>	<span class="n">XFER_MW_DMA_2</span><span class="p">,</span>	<span class="mh">0xa0ca8521</span>	<span class="p">},</span>
	<span class="p">{</span>	<span class="n">XFER_MW_DMA_1</span><span class="p">,</span>	<span class="mh">0xa0ca8532</span>	<span class="p">},</span>
	<span class="p">{</span>	<span class="n">XFER_MW_DMA_0</span><span class="p">,</span>	<span class="mh">0xa0ca8575</span>	<span class="p">},</span>

	<span class="p">{</span>	<span class="n">XFER_PIO_4</span><span class="p">,</span>	<span class="mh">0xc0ca8521</span>	<span class="p">},</span>
	<span class="p">{</span>	<span class="n">XFER_PIO_3</span><span class="p">,</span>	<span class="mh">0xc0ca8532</span>	<span class="p">},</span>
	<span class="p">{</span>	<span class="n">XFER_PIO_2</span><span class="p">,</span>	<span class="mh">0xc0ca8542</span>	<span class="p">},</span>
	<span class="p">{</span>	<span class="n">XFER_PIO_1</span><span class="p">,</span>	<span class="mh">0xc0d08572</span>	<span class="p">},</span>
	<span class="p">{</span>	<span class="n">XFER_PIO_0</span><span class="p">,</span>	<span class="mh">0xc0d08585</span>	<span class="p">},</span>
	<span class="p">{</span>	<span class="mi">0</span><span class="p">,</span>		<span class="mh">0x01208585</span>	<span class="p">}</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> *	hpt36x_find_mode	-	find the hpt36x timing</span>
<span class="cm"> *	@ap: ATA port</span>
<span class="cm"> *	@speed: transfer mode</span>
<span class="cm"> *</span>
<span class="cm"> *	Return the 32bit register programming information for this channel</span>
<span class="cm"> *	that matches the speed provided.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="n">u32</span> <span class="nf">hpt36x_find_mode</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span><span class="p">,</span> <span class="kt">int</span> <span class="n">speed</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">hpt_clock</span> <span class="o">*</span><span class="n">clocks</span> <span class="o">=</span> <span class="n">ap</span><span class="o">-&gt;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">clocks</span><span class="o">-&gt;</span><span class="n">xfer_mode</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">clocks</span><span class="o">-&gt;</span><span class="n">xfer_mode</span> <span class="o">==</span> <span class="n">speed</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">clocks</span><span class="o">-&gt;</span><span class="n">timing</span><span class="p">;</span>
		<span class="n">clocks</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">BUG</span><span class="p">();</span>
	<span class="k">return</span> <span class="mh">0xffffffffU</span><span class="p">;</span>	<span class="cm">/* silence compiler warning */</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span> <span class="k">const</span> <span class="n">bad_ata33</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="s">&quot;Maxtor 92720U8&quot;</span><span class="p">,</span> <span class="s">&quot;Maxtor 92040U6&quot;</span><span class="p">,</span> <span class="s">&quot;Maxtor 91360U4&quot;</span><span class="p">,</span> <span class="s">&quot;Maxtor 91020U3&quot;</span><span class="p">,</span>
	<span class="s">&quot;Maxtor 90845U3&quot;</span><span class="p">,</span> <span class="s">&quot;Maxtor 90650U2&quot;</span><span class="p">,</span>
	<span class="s">&quot;Maxtor 91360D8&quot;</span><span class="p">,</span> <span class="s">&quot;Maxtor 91190D7&quot;</span><span class="p">,</span> <span class="s">&quot;Maxtor 91020D6&quot;</span><span class="p">,</span> <span class="s">&quot;Maxtor 90845D5&quot;</span><span class="p">,</span>
	<span class="s">&quot;Maxtor 90680D4&quot;</span><span class="p">,</span> <span class="s">&quot;Maxtor 90510D3&quot;</span><span class="p">,</span> <span class="s">&quot;Maxtor 90340D2&quot;</span><span class="p">,</span>
	<span class="s">&quot;Maxtor 91152D8&quot;</span><span class="p">,</span> <span class="s">&quot;Maxtor 91008D7&quot;</span><span class="p">,</span> <span class="s">&quot;Maxtor 90845D6&quot;</span><span class="p">,</span> <span class="s">&quot;Maxtor 90840D6&quot;</span><span class="p">,</span>
	<span class="s">&quot;Maxtor 90720D5&quot;</span><span class="p">,</span> <span class="s">&quot;Maxtor 90648D5&quot;</span><span class="p">,</span> <span class="s">&quot;Maxtor 90576D4&quot;</span><span class="p">,</span>
	<span class="s">&quot;Maxtor 90510D4&quot;</span><span class="p">,</span>
	<span class="s">&quot;Maxtor 90432D3&quot;</span><span class="p">,</span> <span class="s">&quot;Maxtor 90288D2&quot;</span><span class="p">,</span> <span class="s">&quot;Maxtor 90256D2&quot;</span><span class="p">,</span>
	<span class="s">&quot;Maxtor 91000D8&quot;</span><span class="p">,</span> <span class="s">&quot;Maxtor 90910D8&quot;</span><span class="p">,</span> <span class="s">&quot;Maxtor 90875D7&quot;</span><span class="p">,</span> <span class="s">&quot;Maxtor 90840D7&quot;</span><span class="p">,</span>
	<span class="s">&quot;Maxtor 90750D6&quot;</span><span class="p">,</span> <span class="s">&quot;Maxtor 90625D5&quot;</span><span class="p">,</span> <span class="s">&quot;Maxtor 90500D4&quot;</span><span class="p">,</span>
	<span class="s">&quot;Maxtor 91728D8&quot;</span><span class="p">,</span> <span class="s">&quot;Maxtor 91512D7&quot;</span><span class="p">,</span> <span class="s">&quot;Maxtor 91303D6&quot;</span><span class="p">,</span> <span class="s">&quot;Maxtor 91080D5&quot;</span><span class="p">,</span>
	<span class="s">&quot;Maxtor 90845D4&quot;</span><span class="p">,</span> <span class="s">&quot;Maxtor 90680D4&quot;</span><span class="p">,</span> <span class="s">&quot;Maxtor 90648D3&quot;</span><span class="p">,</span> <span class="s">&quot;Maxtor 90432D2&quot;</span><span class="p">,</span>
	<span class="nb">NULL</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span> <span class="k">const</span> <span class="n">bad_ata66_4</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="s">&quot;IBM-DTLA-307075&quot;</span><span class="p">,</span>
	<span class="s">&quot;IBM-DTLA-307060&quot;</span><span class="p">,</span>
	<span class="s">&quot;IBM-DTLA-307045&quot;</span><span class="p">,</span>
	<span class="s">&quot;IBM-DTLA-307030&quot;</span><span class="p">,</span>
	<span class="s">&quot;IBM-DTLA-307020&quot;</span><span class="p">,</span>
	<span class="s">&quot;IBM-DTLA-307015&quot;</span><span class="p">,</span>
	<span class="s">&quot;IBM-DTLA-305040&quot;</span><span class="p">,</span>
	<span class="s">&quot;IBM-DTLA-305030&quot;</span><span class="p">,</span>
	<span class="s">&quot;IBM-DTLA-305020&quot;</span><span class="p">,</span>
	<span class="s">&quot;IC35L010AVER07-0&quot;</span><span class="p">,</span>
	<span class="s">&quot;IC35L020AVER07-0&quot;</span><span class="p">,</span>
	<span class="s">&quot;IC35L030AVER07-0&quot;</span><span class="p">,</span>
	<span class="s">&quot;IC35L040AVER07-0&quot;</span><span class="p">,</span>
	<span class="s">&quot;IC35L060AVER07-0&quot;</span><span class="p">,</span>
	<span class="s">&quot;WDC AC310200R&quot;</span><span class="p">,</span>
	<span class="nb">NULL</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span> <span class="k">const</span> <span class="n">bad_ata66_3</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="s">&quot;WDC AC310200R&quot;</span><span class="p">,</span>
	<span class="nb">NULL</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">hpt_dma_blacklisted</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">ata_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">modestr</span><span class="p">,</span>
			       <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span> <span class="k">const</span> <span class="n">list</span><span class="p">[])</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">model_num</span><span class="p">[</span><span class="n">ATA_ID_PROD_LEN</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">ata_id_c_string</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">,</span> <span class="n">model_num</span><span class="p">,</span> <span class="n">ATA_ID_PROD</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">model_num</span><span class="p">));</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">list</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strcmp</span><span class="p">(</span><span class="n">list</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">model_num</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">pr_warn</span><span class="p">(</span><span class="s">&quot;%s is not supported for %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">modestr</span><span class="p">,</span> <span class="n">list</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">i</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	hpt366_filter	-	mode selection filter</span>
<span class="cm"> *	@adev: ATA device</span>
<span class="cm"> *</span>
<span class="cm"> *	Block UDMA on devices that cause trouble with this controller.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">hpt366_filter</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_device</span> <span class="o">*</span><span class="n">adev</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">mask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">adev</span><span class="o">-&gt;</span><span class="n">class</span> <span class="o">==</span> <span class="n">ATA_DEV_ATA</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">hpt_dma_blacklisted</span><span class="p">(</span><span class="n">adev</span><span class="p">,</span> <span class="s">&quot;UDMA&quot;</span><span class="p">,</span>  <span class="n">bad_ata33</span><span class="p">))</span>
			<span class="n">mask</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">ATA_MASK_UDMA</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">hpt_dma_blacklisted</span><span class="p">(</span><span class="n">adev</span><span class="p">,</span> <span class="s">&quot;UDMA3&quot;</span><span class="p">,</span> <span class="n">bad_ata66_3</span><span class="p">))</span>
			<span class="n">mask</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="mh">0xF8</span> <span class="o">&lt;&lt;</span> <span class="n">ATA_SHIFT_UDMA</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">hpt_dma_blacklisted</span><span class="p">(</span><span class="n">adev</span><span class="p">,</span> <span class="s">&quot;UDMA4&quot;</span><span class="p">,</span> <span class="n">bad_ata66_4</span><span class="p">))</span>
			<span class="n">mask</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="mh">0xF0</span> <span class="o">&lt;&lt;</span> <span class="n">ATA_SHIFT_UDMA</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">adev</span><span class="o">-&gt;</span><span class="n">class</span> <span class="o">==</span> <span class="n">ATA_DEV_ATAPI</span><span class="p">)</span>
		<span class="n">mask</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">ATA_MASK_MWDMA</span> <span class="o">|</span> <span class="n">ATA_MASK_UDMA</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">mask</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">hpt36x_cable_detect</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span> <span class="o">=</span> <span class="n">to_pci_dev</span><span class="p">(</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">u8</span> <span class="n">ata66</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Each channel of pata_hpt366 occupies separate PCI function</span>
<span class="cm">	 * as the primary channel and bit1 indicates the cable type.</span>
<span class="cm">	 */</span>
	<span class="n">pci_read_config_byte</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="mh">0x5A</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ata66</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ata66</span> <span class="o">&amp;</span> <span class="mi">2</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ATA_CBL_PATA40</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">ATA_CBL_PATA80</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">hpt366_set_mode</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ata_device</span> <span class="o">*</span><span class="n">adev</span><span class="p">,</span>
			    <span class="n">u8</span> <span class="n">mode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">pdev</span> <span class="o">=</span> <span class="n">to_pci_dev</span><span class="p">(</span><span class="n">ap</span><span class="o">-&gt;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">u32</span> <span class="n">addr</span> <span class="o">=</span> <span class="mh">0x40</span> <span class="o">+</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">adev</span><span class="o">-&gt;</span><span class="n">devno</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">mask</span><span class="p">,</span> <span class="n">reg</span><span class="p">,</span> <span class="n">t</span><span class="p">;</span>

	<span class="cm">/* determine timing mask and find matching clock entry */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mode</span> <span class="o">&lt;</span> <span class="n">XFER_MW_DMA_0</span><span class="p">)</span>
		<span class="n">mask</span> <span class="o">=</span> <span class="mh">0xc1f8ffff</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">mode</span> <span class="o">&lt;</span> <span class="n">XFER_UDMA_0</span><span class="p">)</span>
		<span class="n">mask</span> <span class="o">=</span> <span class="mh">0x303800ff</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">mask</span> <span class="o">=</span> <span class="mh">0x30070000</span><span class="p">;</span>

	<span class="n">t</span> <span class="o">=</span> <span class="n">hpt36x_find_mode</span><span class="p">(</span><span class="n">ap</span><span class="p">,</span> <span class="n">mode</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Combine new mode bits with old config bits and disable</span>
<span class="cm">	 * on-chip PIO FIFO/buffer (and PIO MST mode as well) to avoid</span>
<span class="cm">	 * problems handling I/O errors later.</span>
<span class="cm">	 */</span>
	<span class="n">pci_read_config_dword</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">reg</span><span class="p">);</span>
	<span class="n">reg</span> <span class="o">=</span> <span class="p">((</span><span class="n">reg</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">mask</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">t</span> <span class="o">&amp;</span> <span class="n">mask</span><span class="p">))</span> <span class="o">&amp;</span> <span class="o">~</span><span class="mh">0xc0000000</span><span class="p">;</span>
	<span class="n">pci_write_config_dword</span><span class="p">(</span><span class="n">pdev</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">reg</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	hpt366_set_piomode		-	PIO setup</span>
<span class="cm"> *	@ap: ATA interface</span>
<span class="cm"> *	@adev: device on the interface</span>
<span class="cm"> *</span>
<span class="cm"> *	Perform PIO mode setup.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">hpt366_set_piomode</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ata_device</span> <span class="o">*</span><span class="n">adev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">hpt366_set_mode</span><span class="p">(</span><span class="n">ap</span><span class="p">,</span> <span class="n">adev</span><span class="p">,</span> <span class="n">adev</span><span class="o">-&gt;</span><span class="n">pio_mode</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	hpt366_set_dmamode		-	DMA timing setup</span>
<span class="cm"> *	@ap: ATA interface</span>
<span class="cm"> *	@adev: Device being configured</span>
<span class="cm"> *</span>
<span class="cm"> *	Set up the channel for MWDMA or UDMA modes. Much the same as with</span>
<span class="cm"> *	PIO, load the mode number and then set MWDMA or UDMA flag.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">hpt366_set_dmamode</span><span class="p">(</span><span class="k">struct</span> <span class="n">ata_port</span> <span class="o">*</span><span class="n">ap</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ata_device</span> <span class="o">*</span><span class="n">adev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">hpt366_set_mode</span><span class="p">(</span><span class="n">ap</span><span class="p">,</span> <span class="n">adev</span><span class="p">,</span> <span class="n">adev</span><span class="o">-&gt;</span><span class="n">dma_mode</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">scsi_host_template</span> <span class="n">hpt36x_sht</span> <span class="o">=</span> <span class="p">{</span>
	<span class="n">ATA_BMDMA_SHT</span><span class="p">(</span><span class="n">DRV_NAME</span><span class="p">),</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> *	Configuration for HPT366/68</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">ata_port_operations</span> <span class="n">hpt366_port_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">inherits</span>	<span class="o">=</span> <span class="o">&amp;</span><span class="n">ata_bmdma_port_ops</span><span class="p">,</span>
	<span class="p">.</span><span class="n">cable_detect</span>	<span class="o">=</span> <span class="n">hpt36x_cable_detect</span><span class="p">,</span>
	<span class="p">.</span><span class="n">mode_filter</span>	<span class="o">=</span> <span class="n">hpt366_filter</span><span class="p">,</span>
	<span class="p">.</span><span class="n">set_piomode</span>	<span class="o">=</span> <span class="n">hpt366_set_piomode</span><span class="p">,</span>
	<span class="p">.</span><span class="n">set_dmamode</span>	<span class="o">=</span> <span class="n">hpt366_set_dmamode</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> *	hpt36x_init_chipset	-	common chip setup</span>
<span class="cm"> *	@dev: PCI device</span>
<span class="cm"> *</span>
<span class="cm"> *	Perform the chip setup work that must be done at both init and</span>
<span class="cm"> *	resume time</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">hpt36x_init_chipset</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u8</span> <span class="n">drive_fast</span><span class="p">;</span>

	<span class="n">pci_write_config_byte</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">PCI_CACHE_LINE_SIZE</span><span class="p">,</span> <span class="p">(</span><span class="n">L1_CACHE_BYTES</span> <span class="o">/</span> <span class="mi">4</span><span class="p">));</span>
	<span class="n">pci_write_config_byte</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">PCI_LATENCY_TIMER</span><span class="p">,</span> <span class="mh">0x78</span><span class="p">);</span>
	<span class="n">pci_write_config_byte</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">PCI_MIN_GNT</span><span class="p">,</span> <span class="mh">0x08</span><span class="p">);</span>
	<span class="n">pci_write_config_byte</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">PCI_MAX_LAT</span><span class="p">,</span> <span class="mh">0x08</span><span class="p">);</span>

	<span class="n">pci_read_config_byte</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mh">0x51</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">drive_fast</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">drive_fast</span> <span class="o">&amp;</span> <span class="mh">0x80</span><span class="p">)</span>
		<span class="n">pci_write_config_byte</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mh">0x51</span><span class="p">,</span> <span class="n">drive_fast</span> <span class="o">&amp;</span> <span class="o">~</span><span class="mh">0x80</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	hpt36x_init_one		-	Initialise an HPT366/368</span>
<span class="cm"> *	@dev: PCI device</span>
<span class="cm"> *	@id: Entry in match table</span>
<span class="cm"> *</span>
<span class="cm"> *	Initialise an HPT36x device. There are some interesting complications</span>
<span class="cm"> *	here. Firstly the chip may report 366 and be one of several variants.</span>
<span class="cm"> *	Secondly all the timings depend on the clock for the chip which we must</span>
<span class="cm"> *	detect and look up</span>
<span class="cm"> *</span>
<span class="cm"> *	This is the known chip mappings. It may be missing a couple of later</span>
<span class="cm"> *	releases.</span>
<span class="cm"> *</span>
<span class="cm"> *	Chip version		PCI		Rev	Notes</span>
<span class="cm"> *	HPT366			4 (HPT366)	0	UDMA66</span>
<span class="cm"> *	HPT366			4 (HPT366)	1	UDMA66</span>
<span class="cm"> *	HPT368			4 (HPT366)	2	UDMA66</span>
<span class="cm"> *	HPT37x/30x		4 (HPT366)	3+	Other driver</span>
<span class="cm"> *</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">hpt36x_init_one</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">pci_device_id</span> <span class="o">*</span><span class="n">id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">ata_port_info</span> <span class="n">info_hpt366</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">flags</span> <span class="o">=</span> <span class="n">ATA_FLAG_SLAVE_POSS</span><span class="p">,</span>
		<span class="p">.</span><span class="n">pio_mask</span> <span class="o">=</span> <span class="n">ATA_PIO4</span><span class="p">,</span>
		<span class="p">.</span><span class="n">mwdma_mask</span> <span class="o">=</span> <span class="n">ATA_MWDMA2</span><span class="p">,</span>
		<span class="p">.</span><span class="n">udma_mask</span> <span class="o">=</span> <span class="n">ATA_UDMA4</span><span class="p">,</span>
		<span class="p">.</span><span class="n">port_ops</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">hpt366_port_ops</span>
	<span class="p">};</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">ata_port_info</span> <span class="o">*</span><span class="n">ppi</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span> <span class="o">&amp;</span><span class="n">info_hpt366</span><span class="p">,</span> <span class="nb">NULL</span> <span class="p">};</span>

	<span class="kt">void</span> <span class="o">*</span><span class="n">hpriv</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">reg1</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">pcim_enable_device</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>

	<span class="cm">/* May be a later chip in disguise. Check */</span>
	<span class="cm">/* Newer chips are not in the HPT36x driver. Ignore them */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">revision</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>

	<span class="n">hpt36x_init_chipset</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

	<span class="n">pci_read_config_dword</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mh">0x40</span><span class="p">,</span>  <span class="o">&amp;</span><span class="n">reg1</span><span class="p">);</span>

	<span class="cm">/* PCI clocking determines the ATA timing values to use */</span>
	<span class="cm">/* info_hpt366 is safe against re-entry so we can scribble on it */</span>
	<span class="k">switch</span> <span class="p">((</span><span class="n">reg1</span> <span class="o">&amp;</span> <span class="mh">0x700</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="mi">9</span>:
		<span class="n">hpriv</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">hpt366_40</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">5</span>:
		<span class="n">hpriv</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">hpt366_25</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">hpriv</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">hpt366_33</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* Now kick off ATA set up */</span>
	<span class="k">return</span> <span class="n">ata_pci_bmdma_init_one</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">ppi</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hpt36x_sht</span><span class="p">,</span> <span class="n">hpriv</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_PM</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">hpt36x_reinit_one</span><span class="p">(</span><span class="k">struct</span> <span class="n">pci_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ata_host</span> <span class="o">*</span><span class="n">host</span> <span class="o">=</span> <span class="n">dev_get_drvdata</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">ata_pci_device_do_resume</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
	<span class="n">hpt36x_init_chipset</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="n">ata_host_resume</span><span class="p">(</span><span class="n">host</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">pci_device_id</span> <span class="n">hpt36x</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">{</span> <span class="n">PCI_VDEVICE</span><span class="p">(</span><span class="n">TTI</span><span class="p">,</span> <span class="n">PCI_DEVICE_ID_TTI_HPT366</span><span class="p">),</span> <span class="p">},</span>
	<span class="p">{</span> <span class="p">},</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">pci_driver</span> <span class="n">hpt36x_pci_driver</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">name</span>		<span class="o">=</span> <span class="n">DRV_NAME</span><span class="p">,</span>
	<span class="p">.</span><span class="n">id_table</span>	<span class="o">=</span> <span class="n">hpt36x</span><span class="p">,</span>
	<span class="p">.</span><span class="n">probe</span>		<span class="o">=</span> <span class="n">hpt36x_init_one</span><span class="p">,</span>
	<span class="p">.</span><span class="n">remove</span>		<span class="o">=</span> <span class="n">ata_pci_remove_one</span><span class="p">,</span>
<span class="cp">#ifdef CONFIG_PM</span>
	<span class="p">.</span><span class="n">suspend</span>	<span class="o">=</span> <span class="n">ata_pci_device_suspend</span><span class="p">,</span>
	<span class="p">.</span><span class="n">resume</span>		<span class="o">=</span> <span class="n">hpt36x_reinit_one</span><span class="p">,</span>
<span class="cp">#endif</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">hpt36x_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">pci_register_driver</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hpt36x_pci_driver</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__exit</span> <span class="nf">hpt36x_exit</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pci_unregister_driver</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hpt36x_pci_driver</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">MODULE_AUTHOR</span><span class="p">(</span><span class="s">&quot;Alan Cox&quot;</span><span class="p">);</span>
<span class="n">MODULE_DESCRIPTION</span><span class="p">(</span><span class="s">&quot;low-level driver for the Highpoint HPT366/368&quot;</span><span class="p">);</span>
<span class="n">MODULE_LICENSE</span><span class="p">(</span><span class="s">&quot;GPL&quot;</span><span class="p">);</span>
<span class="n">MODULE_DEVICE_TABLE</span><span class="p">(</span><span class="n">pci</span><span class="p">,</span> <span class="n">hpt36x</span><span class="p">);</span>
<span class="n">MODULE_VERSION</span><span class="p">(</span><span class="n">DRV_VERSION</span><span class="p">);</span>

<span class="n">module_init</span><span class="p">(</span><span class="n">hpt36x_init</span><span class="p">);</span>
<span class="n">module_exit</span><span class="p">(</span><span class="n">hpt36x_exit</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
